<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2024 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ko_KR" product="SimulinkBlocks" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="SFunInterpND">S-Function 블록 ''Interpolation (n-D) using PreLookup''을 내장 블록 ''Interpolation Using Prelookup''으로 바꾸십시오.</entry>
    <entry key="SFunPrelookup">S-Function 블록 ''PreLookup Index Search''를 내장 블록 ''Prelookup''으로 바꾸십시오.</entry>
    <entry key="levelResetContIntegrator"> Integrator 블록의 &lt;b&gt;외부 재설정&lt;/b&gt; 파라미터가 &lt;tt&gt;레벨&lt;/tt&gt;으로 설정되어 있습니다. R2006b부터 &lt;tt&gt;레벨&lt;/tt&gt; 재설정 동작은 R14SP2와 그 이전 릴리스와의 호환성을 위해 수정되었습니다. R14SP3과 R2006a에 존재하는 &lt;tt&gt;레벨&lt;/tt&gt; 재설정 동작을 원하는 경우 &lt;b&gt;외부 재설정&lt;/b&gt; 파라미터를 &lt;tt&gt;레벨 유지&lt;/tt&gt;로 설정하십시오. &lt;tt&gt;레벨&lt;/tt&gt; 및 &lt;tt&gt;레벨 유지&lt;/tt&gt; 재설정 옵션에 대한 자세한 내용을 보려면 Simulink 참고 문서의 &lt;a href="matlab:doc integrator"&gt;Integrator&lt;/a&gt;를 참조하십시오.</entry>
    <entry key="wrongNumMaskEntries">Unexpected Mask Condition: wrong number of mask entries on block ''{0}''</entry>
    <entry key="emlFimathCastBeforeSumFalse">MATLAB Function 블록 ''{0}''에 대한 입력 embedded.fimath의 ''CastBeforeSum''이 false로 설정되어 있습니다.\n이 설정은 더 이상 MATLAB Function 블록에서 지원되지 않습니다. 이 설정을 true로 변경합니다.</entry>
    <entry key="emlFimathForFiConstructorsObsolete">MATLAB Function 블록 ''{0}''에 대해 ''MATLAB factory default''로 설정된 ''FIMATH for fi and fimath constructors''는 더 이상 지원되지 않습니다. 이 설정이 ''MATLAB Function Block FIMATH''를 사용하도록 변경합니다.</entry>
    <entry key="SFTruthTableFimathCastBeforeSumFalse">Stateflow Truth Table 블록 ''{0}''에 대한 입력 embedded.fimath의 ''CastBeforeSum''이 false로 설정되어 있습니다.\n이 설정은 더 이상 지원되지 않습니다. 이 설정을 true로 변경합니다.</entry>
    <entry key="SFTruthTableFimathForFiConstructorsObsolete">Stateflow Truth Table 블록 ''{0}''에 대해 ''MATLAB factory default''으로 설정된 ''FIMATH for fi and fimath constructors''는 더 이상 지원되지 않습니다 이 설정이 ''MATLAB Function Block FIMATH''를 사용하도록 변경합니다.</entry>
    <entry key="mathBlockSqrtFunction1"> Math 블록의 ''sqrt'' 함수는 더 이상 사용되지 않으므로 Sqrt Function 블록의 ''signedSqrt'' 함수로 대체되어야 합니다.</entry>
    <entry key="mathBlockSqrtFunction2"> Math 블록의 ''sqrt'' 함수는 더 이상 사용되지 않으므로 Sqrt Function 블록의 ''sqrt'' 함수로 대체되어야 합니다.</entry>
    <entry key="unitDelayBlockContinuousMode"> Unit Delay 블록은 일반적으로 이산 샘플 시간을 사용합니다. 이 블록이 연속 샘플 시간을 상속한 경우 시간 지연은 고정되지 않으며 각 시간 스텝에 따라 변경될 수 있습니다. 이는 Unit Delay 블록에서 예기치 않은 동작입니다. 연속 샘플 시간에 대해서는 Unit Delay 블록을 Memory 블록으로 바꾸십시오.</entry>
    <entry key="updateParameters">파라미터 업데이트</entry>
    <entry key="toWksSyntaxError">Unrecognized syntax in ToWorkspace block ''{0}'': Please separate the appropriate elements of the ''Maximum number of rows'' parameter into the appropriate dialog entries: [rows, decimation, ts]</entry>
    <entry key="setOutportIcEmpty">다음 서브시스템 출력 포트는 초기 출력값을 지정합니다. 시뮬레이션이 이 InitialOutput 파라미터를 사용하지 않으므로 이 값은 의미가 없습니다. 설계의 명확성을 높이려면 set_param을 사용하여 초기 출력값을 빈 []로 설정하십시오. 자세한 내용을 보려면 MATLAB 명령줄에 "help set_param"을 입력하십시오.</entry>
    <entry key="RepeatingSequenceRemoveDuplicates"> Repeating Sequence 블록은 '시간 값'의 중복된 숫자를 처리할 수 없습니다. 중복된 '시간 값' 입력이 감지되면 그 중복된 값들은 로컬 eps로 간격을 둔 두 개의 시간 지점으로 대체됩니다. '시간 값'이 작업 공간 변수를 사용한 경우 이 변수는 새 변수로 바뀌고 'slprj/modeladvisor/'에 '.mat' 파일로 저장됩니다. 원래 변수는 변경되지 않습니다. 이전 값과 새 값을 비교하여 제안된 값이 허용되는지 확인하십시오.</entry>
    <entry key="RepeatingSequenceRemoveDuplicatesResult"> ''{0}''의 파라미터가 업데이트되었습니다. 원래 변수는 ''{1}''인데 새 변수는 ''{2}''입니다. 해당하는 데이터는 ''{3}''에 저장되었습니다. 그 파일을 데이터 디렉터리에 복사하십시오.</entry>
    <entry key="RepeatingSequenceRemoveDuplicatesLoadFileErr"> The data file ''{0}'' generated by the upgrade advisor check is lost. To regenerate it again, you can change the variable ''{1}'' in block ''{2}'' back to its original variable name, and rerun the upgrade advisor check again.</entry>
    <entry key="MPSwitchOneDataPortEnumUnsupported"> 제어 포트 데이터형은 열거형이고 블록은 하나의 데이터 포트를 갖습니다. 데이터 포트 순서에 대한 인덱스를 지정하도록 자동으로 업데이트될 수 없습니다.</entry>
    <entry key="MPSwitchDeadportsInBlockUnsupported"> 제어 포트 데이터형이 열거형인데, 이 열거형은 블록의 데이터 포트 개수에 매핑되지 않으므로 이 블록은 데이터 포트 인덱스를 지정하도록 자동으로 바뀔 수 없습니다.</entry>
    <entry key="MPSwitchEnumCaseCompatible"> 제어 포트 데이터형은 열거형이고 ''데이터 포트 순서''는 연속형입니다. 파라미터 ''데이터 포트 순서''는 자동으로 ''인덱스 지정''으로 바뀌고 ''데이터 포트 인덱스''가 지정됩니다.</entry>
    <entry key="initCondSetToZero">블록 ''{0}''의 초기 조건이 0 또는 1이 아닙니다. 업데이트된 블록의 초기 조건을 0으로 설정합니다.</entry>
    <entry key="unrecognizedFlipFlopType">인식할 수 없는 Flip-Flop 블록 유형</entry>
    <entry key="skipReplaceDCM">''{0}''을(를) 건너뜁니다. 이 블록은 Aerospace Blockset 라이브러리에서 사용자 지정되었을 수 있으며 업데이트가 필요할 수 있습니다.</entry>
    <entry key="fromBlockCloseFcnCallback"> From 블록에는 더 이상 CloseFcn 콜백이 필요하지 않습니다. 따라서 이 함수는 제거되었습니다. CloseFcn 콜백에서 "tagdialog Close" 문자열을 제거하여 누락된 함수에 대한 경고가 표시되지 않도록 하십시오. </entry>
    <entry key="lookupTableCompatible">Lookup Table 블록과 Lookup Table (2-D) 블록은 완전히 지원되고 호환되지만 더 이상 향상되지 않습니다. 이 블록들은 각각 1-D Lookup Table 블록과 2-D Lookup Table 블록으로 자동으로 대체될 수 있고, 새 블록들은 데이터형과 알고리즘에 대한 새로운 설정을 제공합니다. 이러한 설정을 사용하여 시뮬레이션과 코드 생성에서 메모리 사용과 계산 속도를 개선할 수 있습니다. </entry>
    <entry key="lookupTableIncompatibleRepeatedBp"> 반복되는 절점 데이터를 갖는 Lookup Table 블록과 Lookup Table (2-D) 블록: Lookup Table 블록과 Lookup Table (2-D) 블록은 완전히 지원되고 호환되지만 더 이상 향상되지 않습니다. 이 블록들은 각각 1-D Lookup Table 블록과 2-D Lookup Table 블록으로 대체될 수 있고, 새 블록들은 데이터형과 알고리즘에 대한 새로운 설정을 제공합니다. 이러한 설정을 사용하여 시뮬레이션과 코드 생성에서 메모리 사용과 계산 속도를 개선할 수 있습니다. 다음 Lookup Table 블록과 Lookup Table (2-D) 블록은 반복되는 절점 데이터를 갖지만 1-D Lookup Table 블록과 2-D Lookup Table 블록은 이를 지원하지 않습니다. 이 블록들이 자동으로 업데이트될 수 있도록 반복되는 데이터를 제거하기 위해 절점을 수동으로 업데이트해 보십시오. </entry>
    <entry key="lookupTableIncompatibleUnsupportedLum"> "룩업 방법"이 ''입력에서 가장 가까운 값 사용'' 또는 ''입력 윗값 사용''인 Lookup Table 블록과 Lookup Table (2-D) 블록: Lookup Table 블록과 Lookup Table (2-D) 블록은 완전히 지원되고 호환되지만 더 이상 향상되지 않습니다. 이 블록들은 각각 1-D Lookup Table 블록과 2-D Lookup Table 블록으로 대체될 수 있고, 새 블록들은 데이터형과 알고리즘에 대한 새로운 설정을 제공합니다. 이러한 설정을 사용하여 시뮬레이션과 코드 생성에서 메모리 사용과 계산 속도를 개선할 수 있습니다. 다음 Lookup Table 블록과 Lookup Table (2-D) 블록에서는 "룩업 방법"이 ''입력에서 가장 가까운 값 사용'' 또는 ''입력 윗값 사용''이지만 1-D Lookup Table 블록과 2-D Lookup Table 블록은 이를 지원하지 않습니다. 이 블록들이 자동으로 업데이트될 수 있도록 "룩업 방법"을 "보간-외삽", "보간-끝 값 사용" 또는 "입력 아랫값 사용"으로 수동으로 업데이트해 보십시오. 그렇지 않으면 블록 대체 기능을 통해 이 블록들이 자동으로 대체되고, 새 블록들의 "보간 방법"은 "선형"으로 설정되고 "외삽 방법"은 "자르기''로 설정됩니다. 결과적으로 수치적 차이가 생길 수 있습니다. </entry>
    <entry key="lookupTableIncompatibleUnsupportedExtrapMeth"> 입력과 출력이 동일한 부동소수점 유형이 아닌 경우 "룩업 방법"이 ''보간-외삽''인 Lookup Table 블록과 Lookup Table (2-D) 블록: Lookup Table 블록과 Lookup Table (2-D) 블록은 완전히 지원되고 호환되지만 더 이상 향상되지 않습니다. 이 블록들은 각각 1-D Lookup Table 블록과 2-D Lookup Table 블록으로 대체될 수 있고, 새 블록들은 데이터형과 알고리즘에 대한 새로운 설정을 제공합니다. 이러한 설정을 사용하여 시뮬레이션과 코드 생성에서 메모리 사용과 계산 속도를 개선할 수 있습니다. 다음 Lookup Table 블록과 Lookup Table (2-D) 블록에서는 입력과 출력이 동일한 부동소수점 유형이 아닌 경우 "룩업 방법"이 ''보간-외삽"이지만 1-D Lookup Table 블록과 2-D Lookup Table 블록은 이를 지원하지 않습니다. 이 블록들이 자동으로 업데이트될 수 있도록 "룩업 방법"을 "보간-끝 값 사용"으로 수동으로 업데이트하거나 포트 데이터형을 동일한 부동소수점 데이터형으로 변경해 보십시오. 그렇지 않으면 블록 대체 기능을 통해 이 블록들이 자동으로 대체되고, 새 블록들의 "보간 방법"은 "선형"으로 설정되고 "외삽 방법"은 "자르기''로 설정됩니다. 결과적으로 수치적 차이가 생길 수 있습니다. </entry>
    <entry key="lookupTableIncompatibleUnsupportedBigProd"> 보간을 수행할 때 곱셈을 먼저 하는 Lookup Table 블록과 Lookup Table (2-D) 블록: Lookup Table 블록과 Lookup Table (2-D) 블록은 완전히 지원되고 호환되지만 더 이상 향상되지 않습니다. 이 블록들은 각각 1-D Lookup Table 블록과 2-D Lookup Table 블록으로 자동으로 대체될 수 있고, 새 블록들은 데이터형과 알고리즘에 대한 새로운 설정을 제공합니다. 이러한 설정을 사용하여 시뮬레이션과 코드 생성에서 메모리 사용과 계산 속도를 개선할 수 있습니다. 다음 Lookup Table 블록과 Lookup Table (2-D) 블록은 보간을 수행할 때 곱셈을 먼저 하지만 1-D Lookup Table 블록과 2-D Lookup Table 블록은 항상 나눗셈을 먼저 합니다. 블록 대체 기능을 통해 이 블록들이 자동으로 대체됩니다. 결과적으로 블록 대체 후 수치적 차이가 생길 수 있습니다. </entry>
    <entry key="lookup1D2DChooseIndexSearchMethPrompt"> 균일한 간격의 절점을 갖는 Lookup Table 블록과 Lookup Table (2-D) 블록: Lookup Table 블록과 Lookup Table (2-D) 블록은 완전히 지원되고 호환되지만 더 이상 향상되지 않습니다. 이 블록들은 각각 1-D Lookup Table 블록과 2-D Lookup Table 블록으로 자동으로 대체될 수 있고, 새 블록들은 데이터형과 알고리즘에 대한 새로운 설정을 제공합니다. 이러한 설정을 사용하여 시뮬레이션과 코드 생성에서 메모리 사용과 계산 속도를 개선할 수 있습니다. 블록 ''{0}''을(를) 1-D Lookup Table 블록 또는 2-D Lookup Table 블록으로 자동으로 바꿔 보십시오. 블록 대체 기능은 기본적으로 ''인덱스 탐색 방법''을 ''이진 탐색''으로 설정합니다. 블록 ''{1}''에 균일한 간격의 절점이 있으므로 탐색 속도를 높이기 위해 ''인덱스 탐색 방법''을 ''균일 간격의 점''으로 설정하시겠습니까? ([y]/n/a)</entry>
    <entry key="lookupTableIncompatibleUnsupportedLumPrompt"> "룩업 방법"이 ''입력에서 가장 가까운 값 사용'' 또는 ''입력 윗값 사용''인 Lookup Table 블록과 Lookup Table (2-D) 블록: Lookup Table 블록과 Lookup Table (2-D) 블록은 완전히 지원되고 호환되지만 더 이상 향상되지 않습니다. 이 블록들은 각각 1-D Lookup Table 블록과 2-D Lookup Table 블록으로 자동으로 대체될 수 있고, 새 블록들은 데이터형과 알고리즘에 대한 새로운 설정을 제공합니다. 이러한 설정을 사용하여 시뮬레이션과 코드 생성에서 메모리 사용과 계산 속도를 개선할 수 있습니다. 블록 ''{0}''에서는 "룩업 방법"이 ''입력에서 가장 가까운 값 사용'' 또는 ''입력 윗값 사용''이지만 1-D Lookup Table 블록과 2-D Lookup Table 블록은 이를 지원하지 않습니다. 블록 대체 기능을 통해 블록 ''{1}''은(는) 자동으로 1-D Lookup Table 블록 또는 2-D Lookup Table 블록으로 대체되고, 새 블록의 "보간 방법"은 "선형"으로 설정되고 "외삽 방법"은 "자르기''로 설정됩니다. 결과적으로 블록 대체 후 수치적 차이가 생길 수 있습니다. </entry>
    <entry key="lookupTableIncompatibleUnsupportedExtrapMethPrompt"> 입력과 출력이 동일한 부동소수점 유형이 아닌 경우 "룩업 방법"이 ''보간-외삽''인 Lookup Table 블록과 Lookup Table (2-D) 블록: Lookup Table 블록과 Lookup Table (2-D) 블록은 완전히 지원되고 호환되지만 더 이상 향상되지 않습니다. 이 블록들은 각각 1-D Lookup Table 블록과 2-D Lookup Table 블록으로 자동으로 대체될 수 있고, 새 블록들은 데이터형과 알고리즘에 대한 새로운 설정을 제공합니다. 이러한 설정을 사용하여 시뮬레이션과 코드 생성에서 메모리 사용과 계산 속도를 개선할 수 있습니다. 블록 ''{0}''에서는 입력과 출력이 동일한 부동소수점 유형이 아닌 경우 "룩업 방법"이 ''보간-외삽"이지만 1-D Lookup Table 블록과 2-D Lookup Table 블록은 이를 지원하지 않습니다. 블록 대체 기능을 통해 블록 ''{1}''은(는) 자동으로 1-D Lookup Table 블록 또는 2-D Lookup Table 블록으로 대체되고, 새 블록의 "보간 방법"은 "선형"으로 설정되고 "외삽 방법"은 "자르기''로 설정됩니다. 결과적으로 블록 대체 후 수치적 차이가 생길 수 있습니다. </entry>
    <entry key="lookupTableIncompatibleUnsupportedBigProdPrompt"> 보간을 수행할 때 곱셈을 먼저 하는 Lookup Table 블록과 Lookup Table (2-D) 블록: Lookup Table 블록과 Lookup Table (2-D) 블록은 완전히 지원되고 호환되지만 더 이상 향상되지 않습니다. 이 블록들은 각각 1-D Lookup Table 블록과 2-D Lookup Table 블록으로 자동으로 대체될 수 있고, 새 블록들은 데이터형과 알고리즘에 대한 새로운 설정을 제공합니다. 이러한 설정을 사용하여 시뮬레이션과 코드 생성에서 메모리 사용과 계산 속도를 개선할 수 있습니다. 블록 ''{0}''은(는) 보간을 수행할 때 곱셈을 먼저 하지만 1-D Lookup Table 블록과 2-D Lookup Table 블록은 항상 나눗셈을 먼저 합니다. 블록 대체 기능을 통해 블록 ''{1}''은(는) 자동으로 1-D Lookup Table 블록 또는 2-D Lookup Table 블록으로 대체됩니다. 결과적으로 블록 대체 후 수치적 차이가 생길 수 있습니다. </entry>
    <entry key="lookupTableIncompatibleReplacePrompt"> 블록 ''{0}'' 대체를 계속 하시겠습니까?([y]/n/a)</entry>
    <entry key="InterpolationUpdateHiddenValidIndexParameterforFlatInterp"> Interpolation Using Prelookup 블록 ''{0}''에는 '평탄' 보간 방법에 대하여 '유효한 인덱스 입력이 마지막 인덱스에 도달할 수 있음' 체크박스가 선택돼 있습니다. R2014b 이전 릴리스에서 이 체크박스는 숨겨져 있고 항상 선택 해제된 것으로 간주됩니다. R2014b부터 이 체크박스는 표시되고 업그레이드 시 적용되기 시작합니다. 현재 동작을 유지하기 위해 업그레이드 어드바이저가 이 체크박스를 선택 해제합니다.</entry>
    <entry key="unrecognizedSpecAnBlock">Unrecognized Spectrum Analyzer block type in link reconnection</entry>
    <entry key="configSetRefUpdatingSourceConfigSet">Updated configuration set for variable: {0}.</entry>
    <entry key="configSetsToBeUpdated">다음 구성 세트를 업데이트해야 합니다({0}).</entry>
    <entry key="unableToUpdateCS">Error encountered while attempting to update configuration set:\n{0}\n</entry>
    <entry key="upgradeSFunctionBuilderWithPaddedBus">다음 S-Function Builder 블록에 대한 입력 또는 출력으로 사용되는 버스에 Simulink가 채우기를 추가했습니다. 고속 액셀러레이터 시뮬레이션에서 최상위 모델의 이러한 S-Function 중 하나를 사용하기 전에 그 S-Function을 다시 생성하십시오.</entry>
    <entry key="upgradeLegacyCodeToolWithPaddedBus">다음 레거시 코드 툴 S-Function 블록에 대한 입력 또는 출력으로 사용되는 버스에 Simulink가 채우기를 추가했습니다. 고속 액셀러레이터 시뮬레이션에서 최상위 모델의 이러한 S-Function 중 하나를 사용하기 전에 그 S-Function을 다시 생성하십시오.
    </entry>
    <entry key="upgradeOtherSFunctionWithPaddedBus">다음 S-Function 블록에 대한 입력 또는 출력으로 사용되는 버스에 Simulink가 채우기를 추가했습니다. 고속 액셀러레이터 시뮬레이션에서 최상위 모델의 이러한 S-function 중 하나를 사용하기 전에 그 S-function을 생성하기 위해 원래 사용했던 툴을 사용하여 다시 생성하십시오.</entry>
    <entry key="upgradeLegacyCodeToolRtwMakeCfgFile">현재 Simulink 버전을 사용하여 코드를 생성하는 경우 레거시 코드 툴이 생성한 rtwmakecfg 파일이 오류를 일으킬 수 있습니다. 연결된 S-Function에 대하여 코드를 생성하기 전에 이 파일을 다시 생성하십시오.
    </entry>
    <entry key="upgradeLegacyCodeToolTlcBlockFile">현재 Simulink 버전을 사용하여 코드를 생성하는 경우 레거시 코드 툴이 생성한 TLC 블록 파일이 오류를 일으킬 수 있습니다. 연결된 S-Function에 대하여 코드를 생성하기 전에 이 파일을 다시 생성하십시오.
    </entry>
    <entry key="upgradeLegacyCodeToolFileFailed">Unexpected error while modifying the file {0}:\n{1}\n</entry>
  </message>
</rsccat>
