<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2024 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ja_JP" product="polyspace" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="badFunctionMapping">Function ''{0}'' could not be mapped to standard function ''{1}''.</entry>
    <entry key="badReturnType">The functions do not have compatible return types.</entry>
    <entry key="badNumberOfArguments">The functions do not have the same number of arguments.</entry>
    <entry key="userFunctionIsVarArg">Function ''{0}'' has variable number of arguments. Map the arguments explicitly using the 'mapping' tag.</entry>
    <entry key="badArgumentFcnHasPredefName">Function ''{0}'' has variable number of arguments. Argument {1,number,integer} of the functions do not have compatible types.</entry>
    <entry key="badArgumentFcnHasntPredefName">You mapped argument {2,number,integer} of ''{0}'' to argument {3,number,integer} of ''{1}''. The arguments do not have compatible types.</entry>
    <entry key="badMapping">You mapped argument {2,number,integer} of ''{0}'' to an argument of ''{1}''. Argument {2,number,integer} does not exist.</entry>
    <entry key="badPredefName">Function ''{0}'' is not a recognized standard function.</entry>
    <entry key="badUserName">You cannot override standard function ''{0}''.</entry>
    <entry key="mappingVectorHasWrongSizeFatalError">Attempting to map the function ''{0}'' to the standard function ''{1}''. This standard function requires {2,number,integer} arguments whereas user defined mapping refers to {3,number,integer} arguments. </entry>
    <entry key="userFunctionMappedToStandardFunction">Function ''{0}'' successfully mapped to standard function ''{1}''.</entry>
    <entry key="titleCheckOnArgument">Checks on {0} {1}:</entry>
    <entry key="checkOnArgument">{0}</entry>
    <entry key="otherChecks">Other checks:</entry>
    <entry key="checkPointerAccess">{0} a memory area that is accessible within the boundary given by the {1}.</entry>
    <entry key="checkPointerOverlap">{0} and {1} {2} overlapping memory.</entry>
    <entry key="doesNotPointToEscapedPointer">Does not point to an escaped variable (variable that is no longer on stack).</entry>
    <entry key="mayPointToEscapedPointer">May point to variable that is no longer on the stack.</entry>
    <entry key="pointsToEscapedPointer">Points to variable that is no longer on the stack.</entry>
    <entry key="argumentIsWithinRange">Argument is within expected range [{0} .. {1}]{2}</entry>
    <entry key="argumentMayBeOutsideRange">Argument might be outside expected range [{0} .. {1}]{2}</entry>
    <entry key="argumentDefinitvelyOutsideRange">Argument is outside expected range [{0} .. {1}]{2}</entry>
    <entry key="argumentIsNotNaN">Argument is not NaN</entry>
    <entry key="argumentMayBeNaN">Argument might be NaN</entry>
    <entry key="argumentDefinitivelyNaN">Argument is NaN</entry>
    <entry key="functionCannotFail">Function ''{0}'' has a well-defined behavior for finite floating-point values.</entry>
    <entry key="functionDoesNotOverflow">{0} does not overflow</entry>
    <entry key="functionMayOverflow">{0} may overflow</entry>
    <entry key="functionOverflows">{0} will always overflow</entry>
    <entry key="argumentIsGeqThanZero">Argument is positive or zero</entry>
    <entry key="argumentMayNotBeGeqThanZero">Argument might be negative{0}</entry>
    <entry key="argumentIsLtThanZero">Argument is negative{0}</entry>
    <entry key="argumentIsGeq">Argument is greater than or equal to {0}</entry>
    <entry key="argumentMayNotBeGeq">Argument might be smaller than {0} {1}</entry>
    <entry key="argumentIsDefinitivelyLtThan">Argument is less than {0} {1}</entry>
    <entry key="argumentNeitherNegIntegerNorNegInf">Argument is not a negative integer or negative infinity</entry>
    <entry key="argumentMaybeNegIntegerOrNegInf">Argument might be a negative integer or negative infinity</entry>
    <entry key="argumentDefinitivelyNegIntegerOrNegInf">Argument is definitely a negative integer or negative infinity</entry>
    <entry key="argumentIsNonZeroWhenNotNaN">{0} argument is non-zero (when arguments are not NaN)</entry>
    <entry key="argumentIsNonZero">{0} argument is non-zero</entry>
    <entry key="argumentMayBeZero">{0} argument may equal to zero</entry>
    <entry key="argumentIsEqToZero">{0} argument is equal to zero</entry>
    <entry key="argumentIsFiniteWhenNotNaN">{0} argument is finite (when arguments are not NaN)</entry>
    <entry key="argumentIsFinite">{0} argument is finite</entry>
    <entry key="argumentMayBeInfinite">{0} argument might be infinite</entry>
    <entry key="argumentIsInfinite">{0} argument is infinite</entry>
    <entry key="argumentIsFiniteOrNaN">{0} argument is finite or NaN</entry>
    <entry key="powNoZDV">First argument is non-zero or second argument is positive or zero</entry>
    <entry key="powMayZDV">Second argument might be negative with first argument equal to zero</entry>
    <entry key="powDefinitivelyZDV">Second argument is negative with first argument equal to zero</entry>
    <entry key="powNegArgWellDefined">First argument is not negative or second argument is an integer value</entry>
    <entry key="powNegArgMayNotBeDefined">Second argument may not be an integer value with first argument negative</entry>
    <entry key="powNegArgNotDefined">Second argument is not an integer value with first argument negative</entry>
    <entry key="FMAInvalidFirstTwoArgsZeroAndInfBad">First two arguments are 0 and +/-inf</entry>
    <entry key="FMAInvalidFirstTwoArgsZeroAndInfMaybeBad">First two arguments might be 0 and +/-inf</entry>
    <entry key="FMAInvalidFirstTwoArgsZeroAndInfOk">First two arguments are not 0 and +/- inf</entry>
    <entry key="FMAInvalidFirstTwoArgsInfAndZeroBad">First two arguments are +/-inf and 0</entry>
    <entry key="FMAInvalidFirstTwoArgsInfAndZeroMaybeBad">First two arguments might be +/-inf and 0</entry>
    <entry key="FMAInvalidFirstTwoArgsInfAndZeroOk">First two arguments are not +/-inf and 0</entry>
    <entry key="FMAInvalidSumInfBad">First two arguments are +inf and -inf</entry>
    <entry key="FMAInvalidSumInfMaybeBad">First two arguments might be +inf and -inf</entry>
    <entry key="FMAInvalidSumInfOk">First two arguments are not +inf and -inf</entry>
    <entry key="FMAInvalidProductPlusInfMinusInfBad">Product of first two arguments and third argument are +inf and -inf</entry>
    <entry key="FMAInvalidProductPlusInfMinusInfInfMaybeBad">Product of first two arguments and third argument might be +inf and -inf</entry>
    <entry key="FMAInvalidProductPlusInfMinusInfOk">Product of first two arguments and third argument are not +inf and -inf</entry>
    <entry key="FMAInvalidProductMinusInfPlusInfBad">Product of first two arguments and third argument are -inf and +inf</entry>
    <entry key="FMAInvalidProductMinusInfPlusInfInfMaybeBad">Product of first two arguments and third argument might be -inf and +inf</entry>
    <entry key="FMAInvalidProductMinusInfPlusInfOk">Product of first two arguments and third argument are not -inf and +inf</entry>
    <entry key="ECLutDetected">* Function ''{0}'' has been recognized as an Embedded Coder Lookup-Table function.\n  It is stubbed by Polyspace to increase precision.</entry>
    <entry key="ECPreLutDetected">* Function ''{0}'' has been recognized as an Embedded Coder Pre Lookup-Table function.\n  It is stubbed by Polyspace to increase precision.</entry>
    <entry key="LUTFcnNotModeledAsFcnNotDefined">Function ''{0}'' has not been modeled as an Embedded Lookup Table, despite its name matches a valid EC Lookup tabble, because this function is not defined.</entry>
  </message>
</rsccat>
