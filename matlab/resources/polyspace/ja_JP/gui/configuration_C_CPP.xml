<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ja_JP" product="polyspace" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="not_available_with_c_cpp_title">C/C++ 言語では使用できません</entry>
    <entry key="ComputingSettings_node">分散コンピューティング</entry>
    <entry key="ComputingSettings_title">分散コンピューティング</entry>
    <entry key="MergedComputingSettings_node">実行設定</entry>
    <entry key="MergedComputingSettings_title">実行設定</entry>
    <entry key="distributed_settings_section">分散コンピューティング</entry>
    <entry key="bugfinder_run_settings_section">解析モード</entry>
    <entry key="extra_settings_section">その他の Polyspace オプション</entry>
    <entry key="_batch">バッチ</entry>
    <entry key="_add_to_results_repository">結果リポジトリに追加</entry>
    <entry key="__batch_bug_finder">リモート クラスターで Bug Finder 解析を実行</entry>
    <entry key="__batch_bug_finder_help">[基本設定] で指定したクラスターに解析を送信します。&lt;BR&gt;製品オプションは -batch です。</entry>
    <entry key="__batch_code_prover">リモート クラスターで Code Prover 解析を実行</entry>
    <entry key="__batch_code_prover_help">[基本設定] で指定したクラスターに解析を送信します。&lt;BR&gt;製品オプションは -batch です。</entry>
    <entry key="_batch_help">Polyspace クラスターで Polyspace をバッチ コマンドにより実行します。&lt;BR&gt;(Parallel Computing Toolbox が必要)</entry>
    <entry key="_add_to_results_repository_help">Polyspace の結果をリポジトリに保管し、コード メトリクスと結果の Web ベースのレポート作成を可能にします。</entry>
    <entry key="_fast_analysis">Bug Finder を高速解析モードで使用</entry>
    <entry key="_fast_analysis_help">Bug Finder を高速解析モードで実行します。変更されたファイルのみが解析されます。&lt;BR&gt;メモ: 高速解析モードは、Bug Finder の欠陥ルールとコーディング ルールのサブセットのみをチェックします。</entry>
    <entry key="language_section">ターゲット言語</entry>
    <entry key="_lang">ソース コードの言語</entry>
    <entry key="TargetCompiler_node">ターゲットおよびコンパイラ</entry>
    <entry key="TargetCompiler_title">ターゲットおよびコンパイラ</entry>
    <entry key="target_environment_section">ターゲット環境</entry>
    <entry key="compiler_behavior_section">コンパイラの動作</entry>
    <entry key="_target">ターゲット プロセッサ タイプ</entry>
    <entry key="_compiler">コンパイラ</entry>
    <entry key="_sfr_types">sfr 型のサポート</entry>
    <entry key="_sfr_types_column_1">名前</entry>
    <entry key="_sfr_types_column_2">サイズ</entry>
    <entry key="_c_version">C 標準バージョン</entry>
    <entry key="_cpp_version">C++ 標準バージョン</entry>
    <entry key="_no_uliterals">ブロック char16/32_t 型</entry>
    <entry key="_pack_alignment_value">パック アライメント値</entry>
    <entry key="_ignore_pragma_pack">pragma pack 指令を無視</entry>
    <entry key="_div_round_down">除算での負方向への丸め</entry>
    <entry key="_enum_type_definition">列挙型の定義</entry>
    <entry key="_logical_signed_right_shift">符号付き右シフト</entry>
    <entry key="_for_loop_index_scope">'for ループ' のインデックス スコープの管理 </entry>
    <entry key="_wchar_t_is">wchar_t の管理</entry>
    <entry key="_wchar_t_is_unsigned_long">wchar_t を符号なしの long 型に設定</entry>
    <entry key="_wchar_t_type_is">wchar_t の管理</entry>
    <entry key="_size_t_is_unsigned_long">size_t を符号なしの long 型に設定</entry>
    <entry key="_size_t_type_is">size_t の管理</entry>
    <entry key="_target_help">ターゲット マシンのプロセッサ タイプを選択します。</entry>
    <entry key="_compiler_help">使用する C/C++ コンパイラを指定してください。解析ではコンパイラ固有の C/C++ 言語拡張が認識されます。</entry>
    <entry key="_lang_help">プロジェクトのソース コード言語を指定します。&lt;BR&gt;&lt;li&gt;C - C ソース コード&lt;BR&gt;&lt;li&gt;CPP - C++ ソース コード&lt;BR&gt;&lt;li&gt;C-CPP - C/C++ 混在ソース コード (Bug Finder でのみ使用可能)</entry>
    <entry key="_sfr_types_help">このオプションにより、指定された &lt;i&gt;sfr&lt;/i&gt; 型のリストをサポートできます。このリストが空の場合、&lt;i&gt;sfr&lt;/i&gt; 型は許可されません。&lt;BR&gt;名前は 1 回のみ指定しなければなりません。サイズは、8、16 または 32 でなければなりません。</entry>
    <entry key="_c_version_help">使用する C 標準のバージョンを選択します。</entry>
    <entry key="_cpp_version_help">使用する C++ 標準のバージョンを選択します。</entry>
    <entry key="_no_uliterals_help">char16_t 型と char32_t 型は使用できません。</entry>
    <entry key="_pack_alignment_value_help">Polyspace にパック アライメント値を渡します。</entry>
    <entry key="_ignore_pragma_pack_help">pragma pack 指令を無視する場合に選択します。</entry>
    <entry key="_div_round_down_help">負の数値の商および法を負方向に丸めます。&lt;BR&gt;&lt;BR&gt;このオプションが設定されていない場合、-5/3 の値は -1 になります。&lt;BR&gt;商を負方向に丸めると -5/3 の値は -2 になります。</entry>
    <entry key="_enum_type_definition_help">列挙データ型の表現方法を指定します。&lt;BR&gt;&lt;li&gt;'defined-by-compiler' - 整数 (gnu 方言を除いて、次のリストのうちすべての列挙子値を保持できる最初の型: 符号付き int、符号なし int、符号付き long、&lt;BR&gt;符号なし long、符号付き long long、符号なし long long)。&lt;BR&gt;&lt;li&gt;'auto-signed-first' - 次のリストのうちすべての列挙子値を保持できる最初の型: 符号付き char、符号なし char、符号付き short、符号なし short、&lt;BR&gt;符号付き int、符号なし int、符号付き long、符号なし long、符号付き long long、符号なし long long。&lt;BR&gt;&lt;li&gt;'auto-unsigned-first' - 次のリストのうちすべての列挙子値を保持できる最初の型:&lt;BR&gt; * 列挙子値がすべて正の場合: 符号なし char、符号なし short、符号なし int、符号なし long、符号なし long long。&lt;BR&gt; * 1 つ以上の列挙子値が負の場合: 符号付き char、符号付き short、符号付き int、符号付き long、符号付き long long。</entry>
    <entry key="_logical_signed_right_shift_help">算術演算または論理演算を選択します。&lt;UL&gt;&lt;li&gt;算術: 符号ビットは維持される:&lt;BR&gt;(-4) &gt;&gt; 1 = -2&lt;BR&gt;(-7) &gt;&gt; 1 = -4&lt;BR&gt;7 &gt;&gt; 1 = 3&lt;BR&gt;&lt;li&gt;論理: 符号ビットが 0 に置き換わる&lt;BR&gt;(-4) &gt;&gt; 1 = (-4U) &gt;&gt; 1 = 2147483646&lt;BR&gt;(-7) &gt;&gt; 1 = (-7U) &gt;&gt; 1 = 2147483644&lt;BR&gt;7 &gt;&gt; 1 = 3&lt;BR&gt;&lt;/ul&gt;</entry>
    <entry key="_for_loop_index_scope_help">for ループ内で宣言されるインデックス変数のスコープを変更します。&lt;BR&gt;例: for (int index=0; ...)'{''}' index++; // この時点でインデックス変数を利用できるか (out) 利用できないか (in) になります。&lt;BR&gt;&lt;BR&gt;設定可能な値は 'defined-by-dialect'、'in' および 'out' です。&lt;ul&gt;&lt;li&gt;'defined-by-dialect' は、選択した方言に対応する既定の動作です (下記を参照)。&lt;BR&gt;&lt;li&gt;'out' は、方言オプション visual6、visual7 および visual 7.1 の既定値です。&lt;BR&gt;&lt;li&gt;'in' は、visual8 以降を含むその他すべての方言の既定値です。&lt;/li&gt;C++ 規格ではインデックスが 'in' として処理されるように指定しています。&lt;/ul&gt;このオプションを使用すると、Polyspace 方言オプションによって暗黙的に指定された既定の動作をオーバーライドできます。&lt;BR&gt;このオプションは Visual C++ オプション /Zc:forScope および Zc:forScope- と等価です。</entry>
    <entry key="_wchar_t_is_help">wchar_t を C++ 規格でのキーワードまたは Microsoft Visual C++ 6/7 方言での typedef として処理します。&lt;BR&gt;&lt;BR&gt;設定可能な値は 'defined-by-dialect'、'typedef' および 'keyword' です。&lt;ul&gt;&lt;li&gt;'defined-by-dialect' は、選択した方言に対応する既定の動作です (下記を参照)。&lt;BR&gt;&lt;li&gt;'typedef' は、方言オプション visual6、visual7 および visual 7.1 での既定の動作です。&lt;BR&gt;&lt;li&gt;'keyword' は、visual8 以降を含むその他すべての方言での既定の動作です。&lt;/ul&gt;このオプションを使用すると、Polyspace 方言オプションによって暗黙的に指定された既定の動作をオーバーライドできます。&lt;BR&gt;このオプションは Visual C++ オプション /Zc:wchar および /Zc:wchar- と等価です。</entry>
    <entry key="_wchar_t_is_unsigned_long_help">typedef であるかキーワードであるかとは無関係に、wchar_t の元になる型を符号なしの long 型に設定します (既定値は符号なしの short 型)。</entry>
    <entry key="_wchar_t_type_is_help">wchar_t の基となる型を、対応する型に設定します。</entry>
    <entry key="_size_t_is_unsigned_long_help">size_t で想定される型を符号なしの long 型に設定します (既定値は符号なしの int 型)。</entry>
    <entry key="_size_t_type_is_help">size_t で必要な型を、対応する型に設定します。</entry>
    <entry key="Macros_node">マクロ</entry>
    <entry key="Macros_title">プリプロセッサ マクロ</entry>
    <entry key="_D">プリプロセッサ定義</entry>
    <entry key="_D_column_1">マクロ</entry>
    <entry key="_U">無効なプリプロセッサ定義</entry>
    <entry key="_U_column_1">マクロ</entry>
    <entry key="_D_help">前処理シンボルを指定します</entry>
    <entry key="_U_help">無効にするプリプロセッサ定義を指定します</entry>
    <entry key="EnvironmentSettings_node">環境設定</entry>
    <entry key="EnvironmentSettings_title">環境設定</entry>
    <entry key="_sources_encoding">ソース コードのエンコード</entry>
    <entry key="_dos">DOS または Windows ファイル システムからのコード</entry>
    <entry key="_stop_if_compile_error">ファイルがコンパイルされない場合は解析を停止</entry>
    <entry key="_no_extern_C">リンク エラーを無視</entry>
    <entry key="_post_preprocessing_command">前処理済みファイルに適用するコマンド/スクリプト</entry>
    <entry key="_I">インクルード フォルダー</entry>
    <entry key="_I_column_1">フォルダー</entry>
    <entry key="_include">インクルード</entry>
    <entry key="_include_column_1">ファイル</entry>
    <entry key="_sources_encoding_help">ソース コード内の非 ASCII 文字を解釈するために、解析で使用されるエンコードを指定します。&lt;BR&gt;このオプションは、特殊文字が原因でコードがコンパイルされない場合、または UI 内で正しくレンダリングされない場合に使用します。&lt;BR&gt;他のエンコードを有効にする方法については、'?' をクリックしてください。</entry>
    <entry key="_dos_help">コードが &lt;B&gt;DOS または Windows&lt;/B&gt; ファイル システムのものである場合は、このオプションを使用します。&lt;BR&gt;このオプションは、大文字/小文字の区別や制御文字の問題に対応します。</entry>
    <entry key="_stop_if_compile_error_help">このオプションを使用してすべてのコンパイル エラーを解決して、すべてのファイルが必ず解析されるようにします。&lt;BR&gt;既定では、コンパイル エラーのあるファイルは解析されません。これらのファイルの関数は、残りの解析用にスタブされます。</entry>
    <entry key="_no_extern_C_help">C リンケージと C++ リンケージを区別せずに処理します。</entry>
    <entry key="_post_preprocessing_command_help">各ソース ファイルの前処理段階後に所定のコマンドを実行します。&lt;BR&gt;&lt;BR&gt;コマンド ファイルの絶対パスとファイル名を指定する必要があります。&lt;BR&gt;コマンドは、標準入力から読み取り、標準出力に結果を生成するものでなければなりません。</entry>
    <entry key="_I_help">インクルード フォルダー</entry>
    <entry key="_include_help">コンパイル時に自動的にインクルードするファイルを指定します。&lt;BR&gt;これらのファイルが各 C/C++ ファイルにインクルードされてから、&lt;i&gt;#includes&lt;/i&gt; ステートメントが処理されます。</entry>
    <entry key="Multitasking_node">マルチタスキング</entry>
    <entry key="Multitasking_title">マルチタスキング</entry>
    <entry key="automatic_concurrency_section">自動構成</entry>
    <entry key="manual_multitasking_section">手動構成</entry>
    <entry key="_osek_multitasking">OIL ファイルの選択</entry>
    <entry key="_osek_multitasking_column_1">ファイル</entry>
    <entry key="_autosar_multitasking">ARXML ファイルの選択</entry>
    <entry key="_autosar_multitasking_column_1">ファイル</entry>
    <entry key="_enable_concurrency_detection">Code Prover の同時実行の自動検出を有効にする</entry>
    <entry key="_disable_concurrency_detection">同時実行の自動検出を無効にする</entry>
    <entry key="__multitasking">マルチタスクを手動で構成</entry>
    <entry key="__external_multitasking">外部マルチタスキング構成</entry>
    <entry key="_entry_points">タスク</entry>
    <entry key="_entry_points_column_1">タスク</entry>
    <entry key="_cyclic_tasks">周期タスク</entry>
    <entry key="_cyclic_tasks_column_1">タスク</entry>
    <entry key="_interrupts">割り込み</entry>
    <entry key="_interrupts_column_1">割り込みサービス ルーチン</entry>
    <entry key="_routine_disable_interrupts">すべての割り込みを無効にする</entry>
    <entry key="_routine_enable_interrupts">すべての割り込みを無効にする (2 列目)</entry>
    <entry key="_routine_disable_interrupts_column_1">無効にするルーチン</entry>
    <entry key="_routine_disable_interrupts_column_2">有効にするルーチン</entry>
    <entry key="_critical_section_begin">クリティカル セクション詳細</entry>
    <entry key="_critical_section_end">クリティカル セクション詳細 (2 列目)</entry>
    <entry key="_critical_section_begin_column_1">開始ルーチン</entry>
    <entry key="_critical_section_begin_column_2">終了ルーチン</entry>
    <entry key="_temporal_exclusions_file">時間的に排他なタスク</entry>
    <entry key="_temporal_exclusions_file_column_1">タスク</entry>
    <entry key="_enable_concurrency_detection_help">pthread_create など、特定の同時実行のプリミティブ型を自動的に認識します。&lt;BR&gt; &lt;ul&gt; &lt;li&gt;Code Prover: 同時実行のプリミティブ型を含むマルチタスク アプリケーションには、このオプションを使用します。&lt;br&gt;アプリケーションには ‘main’ 関数がなければなりません。&lt;li&gt;Bug Finder: このオプションは必要ありません。Bug Finder は既定で同時実行のプリミティブ型を認識します。&lt;/ul&gt;検出できるプリミティブ型のリストについては、[詳しいヘルプ] をクリックしてください。</entry>
    <entry key="_disable_concurrency_detection_help">特定の同時実行のプリミティブ型の自動検出を無効にします｡&lt;BR&gt;検出できるプリミティブ型のリストを参照するには [詳しいヘルプ] をクリックしてください。</entry>
    <entry key="__multitasking_help">マルチタスキング コードを検証します。</entry>
    <entry key="__external_multitasking_help">マルチタスキング構成を外部ファイルから指定します。&lt;ul&gt;&lt;li&gt;osek: OSEK OIL ファイルを基にしたマルチタスキングの記述。&lt;/li&gt;&lt;li&gt;autosar: AUTOSAR ARXML ファイルを基にしたマルチタスキングの記述。&lt;/li&gt;&lt;/ul&gt;</entry>
    <entry key="_osek_multitasking_help">OSEK マルチタスキング構成の記述が格納されている OIL ファイルのリストを指定します。&lt;ul&gt;&lt;li&gt;自動: Polyspace がソース ファイルまたはヘッダー ファイルを含むフォルダー内で OIL ファイルを検索します。&lt;/li&gt; &lt;li&gt;カスタム: OIL ファイル、または OIL ファイルが格納されているフォルダーを指定します。Polyspace は指定したフォルダーとサブフォルダー内で OIL ファイルを検索します。&lt;/li&gt;&lt;/ul&gt;
</entry>
    <entry key="_autosar_multitasking_help">AUTOSAR マルチタスキング構成の記述を含んだ ARXML ファイルのリストを指定します。
</entry>
    <entry key="_entry_points_help">解析するタスクのリストを指定します。これらのエントリ ポイントではパラメーターを使わないでください。&lt;BR&gt;タスクのエントリ ポイントがパラメーターを伴う関数の場合は、これらの関数を&lt;BR&gt;パラメーターのない関数にカプセル化し、パラメーターはグローバル変数によって渡すことができます。</entry>
    <entry key="_cyclic_tasks_help">解析する周期タスクのリストを指定します。これらのタスクではパラメーターを使わないでください。&lt;BR&gt;タスクがパラメーターを伴う関数の場合は、これらの関数を&lt;BR&gt;パラメーターのない関数にカプセル化し、パラメーターはグローバル変数によって渡すことができます。</entry>
    <entry key="_interrupts_help">システム内の割り込みのリストを指定します。割り込みは周期タスクであり、プリエンプトされません。</entry>
    <entry key="_critical_section_begin_help">クリティカル セクションの開始ルーチンと終了ルーチンのリストを指定します。各クリティカル セクションには開始と終了があります。&lt;BR&gt;共有リソースの保護をモデル化する場合に、これらのクリティカル セクションを使用します。</entry>
    <entry key="_routine_disable_interrupts_help">Bug Finder 解析で割り込みを無効にするルーチンと有効にするルーチンを入力します。&lt;BR&gt;&lt;ul&gt;&lt;li&gt;無効にするルーチンを呼び出すと、他のタスクと割り込みによるタスクのプリエンプションが回避されます。&lt;li&gt;有効にするルーチンを呼び出すと、以前無効になっていた場合は他のタスクと割り込みによるタスクのプリエンプションが再び有効になります。&lt;/ul&gt;</entry>
    <entry key="_temporal_exclusions_file_help">同時に実行されることのない一連のポイントを指定します。</entry>
    <entry key="CodingStandards_node">コーディング規約およびコード メトリクス</entry>
    <entry key="CodingStandards_title">コーディング規約およびコード メトリクス</entry>
    <entry key="coding_standards_section">コーディング規約</entry>
    <entry key="__checkers_selection_file">ファイルごとにチェッカーを設定</entry>
    <entry key="__checkers_selection_file_help">コードが、ファイルで定義されているチェック項目の選択に準拠しているかどうかをチェックします。</entry>
    <entry key="_checkers_selection_file_help">コードが、ファイルで定義されているチェック項目の選択に準拠しているかどうかをチェックします。</entry>
    <entry key="__cert_c">SEI CERT-C をチェック</entry>
    <entry key="__cert_c_help">コードが CERT-C 標準に準拠しているかどうかをチェックします。</entry>
    <entry key="_cert_c_help">コードが CERT-C 標準に準拠しているかどうかをチェックします。</entry>
    <entry key="__cert_cpp">SEI CERT-C++ をチェック</entry>
    <entry key="__cert_cpp_help">コードが CERT-C++ 規約に準拠しているかどうかをチェックします。</entry>
    <entry key="_cert_cpp_help">コードが CERT-C++ 規約に準拠しているかどうかをチェックします。</entry>
    <entry key="__iso_17961">ISO/IEC TS 17961 をチェック</entry>
    <entry key="__iso_17961_help">コードが ISO-17961 標準に準拠しているかどうかをチェックします。</entry>
    <entry key="_iso_17961_help">コードが ISO-17961 標準に準拠しているかどうかをチェックします。</entry>
    <entry key="__autosar_cpp14">AUTOSAR C++14 をチェック</entry>
    <entry key="__autosar_cpp14_help">コードが AUTOSAR C++14 規約に準拠しているかどうかをチェックします。</entry>
    <entry key="_autosar_cpp14_help">コードが AUTOSAR C++14 規約に準拠しているかどうかをチェックします。</entry>
    <entry key="__guidelines">Polyspace ガイドラインのチェック</entry>
    <entry key="__guidelines_help">コードがコーディング ガイドラインに準拠しているかどうかをチェックします。</entry>
    <entry key="_guidelines_help">コードがコーディング ガイドラインに準拠しているかどうかをチェックします。</entry>
    <entry key="__cwe">CWE チェック</entry>
    <entry key="_cwe_help">コードが CWE 標準に準拠しているかどうかをチェックします。&lt;BR&gt;cwe-658-659 は、C (CWE-658) または C++ (CWE-659) で記述されたソフトウェアの脆弱性に関するルールのサブセットを有効にします。</entry>
    <entry key="__cwe_help">コードが CWE 標準に準拠しているかどうかをチェックします。&lt;BR&gt;cwe-658-659 は、C (CWE-658) または C++ (CWE-659) で記述されたソフトウェアの脆弱性に関するルールのサブセットを有効にします。</entry>
    <entry key="coding_standard_dialog_title">チェッカーの選択</entry>
    <entry key="cannot_open_coding_stantard_selection_file">コーディング規約選択ファイルを開けません: {0}。&lt;BR&gt;選択したファイルが有効な Polyspace コーディング規約選択ファイルであることを確認してください。</entry>
    <entry key="cannot_open_coding_stantard_selection_file_version">コーディング規約選択ファイルを開けません: {0}。&lt;BR&gt;このファイルは Polyspace As you Code 機能以外を使用して開くことはできません。</entry>
    <entry key="backup_coding_stantard_selection_file">コーディング規約選択ファイル {0} が&lt;BR&gt;新しいファイル形式に変換されました。&lt;BR&gt;&lt;BR&gt;以前のファイルのバックアップはこちらから使用できます&lt;BR&gt;{1} </entry>
    <entry key="coding_stantard_selection_file_already_exists">コーディング規約選択ファイル {0} は既に存在します。</entry>
    <entry key="coding_stantard_selection_file_filter">コーディング規約構成ファイル (*{0})</entry>
    <entry key="given_file_does_not_exist">オプション {1} に指定したファイル {0} が存在しません。</entry>
    <entry key="should_import_selection_file">ファイル {0} は Polyspace の古いバージョンで作成されています。\n\n[インポート] をクリックして、チェッカー選択をこのバージョンの Polyspace に移行してください。</entry>
    <entry key="invalid_pschk_file">無効な pschk ファイル: {0}。\npolyspace-catalog-bundler コマンドを使用して、有効なファイルを生成してください。</entry>
    <entry key="CodingRulesCodeMetrics_node">コーディング ルールおよびコード メトリクス</entry>
    <entry key="CodingRulesCodeMetrics_title">コーディング ルールおよびコード メトリクス</entry>
    <entry key="coding_rules_section">コーディング ルール</entry>
    <entry key="code_metrics_section">コード メトリクス</entry>
    <entry key="__misra_cpp">MISRA C++:2008 をチェック</entry>
    <entry key="__jsf_coding_rules">JSF AV C++ をチェック</entry>
    <entry key="__misra2">MISRA C:2004 のチェック</entry>
    <entry key="__misra_ac_agc">MISRA AC AGC のチェック</entry>
    <entry key="__misra3">MISRA C:2012 のチェック</entry>
    <entry key="_misra3_agc_mode">生成されたコードの要件を使用</entry>
    <entry key="__misra_c_2023">MISRA C:2023 のチェック</entry>
    <entry key="_misra_c_2023_agc_mode">生成されたコードの要件を使用</entry>
    <entry key="__misra_cpp_2023">MISRA C++:2023 のチェック</entry>
    <entry key="_boolean_types">有効な boolean 型</entry>
    <entry key="_boolean_types_column_1">型</entry>
    <entry key="_allowed_pragmas">許可されるプラグマ</entry>
    <entry key="_allowed_pragmas_column_1">プラグマ</entry>
    <entry key="__custom_rules">カスタム ルールのチェック</entry>
    <entry key="_generate_results_for">ソースおよび次に対する結果を生成する:</entry>
    <entry key="_generate_results_for_column_1">ファイル/フォルダー</entry>
    <entry key="_do_not_generate_results_for">次に対する結果を生成しない:</entry>
    <entry key="_do_not_generate_results_for_column_1">ファイル/フォルダー</entry>
    <entry key="__misra_cpp_help">コードが MISRA C++ 規格に準拠しているかどうかチェックします。</entry>
    <entry key="_misra_cpp_help">コードが MISRA C++ 規格に準拠しているかどうかチェックします。</entry>
    <entry key="__jsf_coding_rules_help">コードが JSF AV 標準に準拠しているかどうかチェックします。</entry>
    <entry key="_jsf_coding_rules_help">コードが JSF AV 標準に準拠しているかどうかチェックします。</entry>
    <entry key="__misra2_help">コードが MISRA C:2004 規格に準拠しているかどうかチェックします。</entry>
    <entry key="_misra2_help">コードが MISRA C:2004 規格に準拠しているかどうかチェックします。</entry>
    <entry key="__misra_ac_agc_help">コードが MISRA AC AGC 規格に準拠しているかどうかをチェックします。</entry>
    <entry key="_misra_ac_agc_help">コードが MISRA AC AGC 規格に準拠しているかどうかをチェックします。</entry>
    <entry key="__misra3_help">組み込み制御とスタンドアロン ソフトウェアの両方で C 言語を使用するときのガイドライン。</entry>
    <entry key="_misra3_help">生成されたコードに適用する場合、MISRA C:2012 の一部のルールではカテゴリ (必要、勧告、可読性) が変更されます。&lt;BR&gt;カテゴリを使用して、生成されたコードを MISRA C:2012 に沿ってチェックするにはこのオプションを使用してください。</entry>
    <entry key="_misra3_agc_mode_help">自動コード生成のコンテキストで MISRA C:2012 に沿ってチェックします。</entry>
    <entry key="__misra_c_2023_help">組み込み制御とスタンドアロン ソフトウェアの両方で C 言語を使用するときのガイドライン。</entry>
    <entry key="_misra_c_2023_help">生成されたコードに適用する場合、MISRA C:2023 の一部のルールではカテゴリ (必要、勧告、可読性) が変更されます。&lt;BR&gt;カテゴリを使用して、生成されたコードを MISRA C:2023 に沿ってチェックするにはこのオプションを使用してください。</entry>
    <entry key="_misra_c_2023_agc_mode_help">自動コード生成のコンテキストで MISRA C:2023 に沿ってチェックします。</entry>
    <entry key="__misra_cpp_2023_help">コードが MISRA C++:2023 規格に準拠しているかどうかチェックします。</entry>
    <entry key="_misra_cpp_2023_help">コードが MISRA C++:2023 規格に準拠しているかどうかチェックします。</entry>
    <entry key="_boolean_types_help">Polyspace が boolean と見なすデータ型を指定するにはこのオプションを使用します。&lt;BR&gt;typedef ステートメントで定義したデータ型のみがサポートされます。</entry>
    <entry key="_allowed_pragmas_help">以下のチェックのためのプラグマを指定します: &lt;ul&gt;&lt;li&gt;MISRA-C および MISRA AC AGC ルール 3.4 &lt;/li&gt; &lt;li&gt;MISRA C++ ルール 16-6-1&lt;/li&gt;&lt;/ul&gt; ルール チェッカーでは、ドキュメント化されたプラグマが考慮され、これらのルールの違反にはフラグが立てられません。</entry>
    <entry key="__custom_rules_help">コードがカスタム コーディング ルールに準拠しているかどうかチェックします。</entry>
    <entry key="_custom_rules_help">コードがカスタム コーディング ルールに準拠しているかどうかチェックします。</entry>
    <entry key="_generate_results_for_help">解析の結果を必要とするヘッダー ファイルを指定します。 &lt;ul&gt;&lt;li&gt;source-headers: ソース ファイルと同じフォルダー内のヘッダー &lt;/li&gt; &lt;li&gt;all-headers: ソース ファイルと同じフォルダー内のヘッダー、インクルード フォルダー内のヘッダー &lt;/li&gt; &lt;li&gt;custom: 指定したファイルまたは指定したフォルダー内のファイル &lt;/li&gt;&lt;/ul&gt; このオプションはコーディング ルール、コード メトリクスおよび Polyspace Bug Finder の欠陥にのみ適用されます。</entry>
    <entry key="_do_not_generate_results_for_help">解析の結果を必要としないヘッダー ファイルを指定します。 &lt;ul&gt;&lt;li&gt;include-folders: インクルード フォルダー内のヘッダー &lt;/li&gt; &lt;li&gt;all-headers: インクルード フォルダー内のヘッダー、ソース ファイルと同じフォルダー内のヘッダー &lt;/li&gt; &lt;li&gt;custom: 指定したファイルまたは指定したフォルダー内のファイル &lt;/li&gt;&lt;/ul&gt; このオプションはコーディング ルール、コード メトリクスおよび Polyspace Bug Finder の欠陥にのみ適用されます。</entry>
    <entry key="_code_metrics">コード メトリクスの計算</entry>
    <entry key="_code_metrics_help">コード メトリクスを計算します。</entry>
    <entry key="__bug_finder_multitasking">マルチタスキング</entry>
    <entry key="__bug_finder_multitasking_help">マルチタスキング コードを検証します。</entry>
    <entry key="BugFinderAnalysis_node">Bug Finder 解析</entry>
    <entry key="BugFinderAnalysis_title">Bug Finder 解析</entry>
    <entry key="__enable_checkers">欠陥の検出</entry>
    <entry key="__enable_checkers_help">欠陥のチェックを有効または無効にします</entry>
    <entry key="__checkers_preset_help">欠陥のプリセットを選択します</entry>
    <entry key="_checks_using_system_input_values">システムのすべての入力値を考慮する、さらに厳密なチェックを実行</entry>
    <entry key="_checks_using_system_input_values_help">以下について、すべての取り得る値を考慮してください: &lt;ul&gt;&lt;li&gt;グローバル変数&lt;/li&gt;&lt;li&gt;volatile 変数の読み取り値&lt;/li&gt;&lt;li&gt;スタブされた関数の戻り値&lt;/li&gt;&lt;li&gt;[次の関数の入力を考慮する] で指定された関数入力&lt;/li&gt;&lt;/ul&gt; より厳密な静的解析では数値的なエッジ ケースから生じうる問題が検出され、&lt;BR&gt;検出された欠陥につながる可能性のある例の値が提示されます。&lt;BR&gt;&lt;BR&gt; オプション [次の関数の入力を考慮する] (-system-inputs-from) で指定された関数に対してより厳密な解析が実行されます。
</entry>
    <entry key="_system_inputs_from">次の関数の入力を考慮する</entry>
    <entry key="_system_inputs_from_help">解析ですべての可能な入力値が考慮される、対象の関数を指定します。 &lt;ul&gt;&lt;li&gt;auto: main 関数およびタスク (存在する場合)、または少なくとも 1 つの呼び出し先をもつ呼び出されない関数 (main 関数が存在しない場合)&lt;/li&gt; &lt;li&gt;uncalled: 呼び出されないすべての関数&lt;/li&gt; &lt;li&gt;all: すべての関数&lt;/li&gt; &lt;li&gt;custom: ユーザー指定の関数&lt;/li&gt;&lt;/ul&gt;
</entry>
    <entry key="_system_inputs_from_column_1">関数</entry>
    <entry key="CodeProverVerification_node">Code Prover 検証</entry>
    <entry key="CodeProverVerification_title">Code Prover 検証</entry>
    <entry key="MainGenerator_node">main ジェネレーター</entry>
    <entry key="MainGenerator_title">main ジェネレーター</entry>
    <entry key="__main">アプリケーション全体の検証</entry>
    <entry key="_init_only_mode">初期化コードのみを検証</entry>
    <entry key="_main">メイン エントリ ポイント</entry>
    <entry key="_main_generator">モジュールまたはライブラリの検証</entry>
    <entry key="_main_generator_mbd">モデル生成コードの検証</entry>
    <entry key="_main_generator_autosar">AUTOSAR 仕様から生成されたメイン</entry>
    <entry key="_class_analyzer">クラス</entry>
    <entry key="_class_analyzer_column_1">クラス</entry>
    <entry key="_class_analyzer_calls">指定クラス内で呼び出す関数</entry>
    <entry key="_class_analyzer_calls_column_1">関数</entry>
    <entry key="_class_only">クラスの内容のみを解析</entry>
    <entry key="_no_constructors_init_check">メンバー初期化チェックをスキップ</entry>
    <entry key="_main_generator_writes_variables">初期化する変数</entry>
    <entry key="_main_generator_writes_variables_column_1">グローバル変数</entry>
    <entry key="_functions_called_before_main">初期化関数</entry>
    <entry key="_functions_called_before_main_column_1">関数</entry>
    <entry key="_main_generator_calls">呼び出す関数</entry>
    <entry key="_main_generator_calls_column_1">関数</entry>
    <entry key="_unit_by_unit">ファイルを個別に検証</entry>
    <entry key="_unit_by_unit_common_source">共通のソース ファイル</entry>
    <entry key="_unit_by_unit_common_source_column_1">ファイル</entry>
    <entry key="_variables_written_before_loop">パラメーター</entry>
    <entry key="_variables_written_before_loop_column_1">変数</entry>
    <entry key="_variables_written_in_loop">入力</entry>
    <entry key="_variables_written_in_loop_column_1">変数</entry>
    <entry key="_functions_called_before_loop">初期化関数</entry>
    <entry key="_functions_called_before_loop_column_1">関数</entry>
    <entry key="_functions_called_in_loop">ステップ関数</entry>
    <entry key="_functions_called_in_loop_column_1">関数</entry>
    <entry key="_functions_called_after_loop">終了関数</entry>
    <entry key="_functions_called_after_loop_column_1">関数</entry>
    <entry key="_shared_variables_mode">グローバル変数の共有と使用のみを表示</entry>
    <entry key="__main_help">既存の main 関数を検証の開始点として使用します。</entry>
    <entry key="_init_only_mode_help">コードの初期化セクションにランタイム エラーおよび他の問題がないかどうかをチェックします。&lt;BR&gt;アプリケーション全体を検証する場合、初期化コードは 'main' の冒頭からプラグマ 'polyspace_end_of_init' までです。&lt;BR&gt;モジュールまたはライブラリを検証する場合、初期化コードは初期化関数のシーケンスです。</entry>
    <entry key="_main_help">既存の main 関数を検証の開始点として使用します。</entry>
    <entry key="_main_generator_help">'main' 関数を自動生成します。</entry>
    <entry key="_class_analyzer_help">main の生成に使用するクラスのリストを入力します。&lt;ul&gt;&lt;li&gt;none: クラスなし&lt;BR&gt;&lt;li&gt;all: すべてのクラス&lt;BR&gt;&lt;li&gt;custom: 特定クラスのリスト&lt;BR&gt;特定クラスのリストの選択されたメンバー関数 ([指定クラス内で呼び出す関数] で定義) が、生成された main によって呼び出されます。&lt;BR&gt;&lt;/ul&gt;</entry>
    <entry key="_class_only_help">[クラス] (-class-analyzer) オプションで指定されたクラスに含まれているコードのみを解析します。&lt;BR&gt;Polyspace でソース コードを指定した場合でも、クラス外部で定義されている関数にはすべてスタブが生成されます。</entry>
    <entry key="_class_analyzer_calls_help">オプション -class-analyzer で指定されたクラスの対象メソッドを検証します。対象メソッドは、指定したクラスの静的メソッド、パブリック メソッドおよび保護メソッドです。&lt;ul&gt;&lt;li&gt;all: 生成された main により、指定クラスのすべてのパブリック メソッドと保護メソッドが呼び出されます。親クラスから継承されたメンバーは呼び出されません。&lt;BR&gt;&lt;li&gt;all-public: 生成された main が保護メソッド以外のメソッドをすべて呼び出します。&lt;BR&gt;&lt;li&gt;inherited-all: 生成された main が指定クラスとその親のパブリック メソッドと保護メソッドをすべて呼び出します。&lt;BR&gt;&lt;li&gt;inherited-all-public: 生成された main が指定クラスとその親のパブリック メソッドをすべて呼び出します。&lt;BR&gt;&lt;li&gt;unused: 既定値です。生成された main は、指定クラス内で呼び出されないメソッドをすべて呼び出します。&lt;BR&gt;&lt;li&gt;unused-public: 生成された main は、指定クラス内で呼び出されないメソッドを (保護メソッドを除き) すべて呼び出します。&lt;BR&gt;&lt;li&gt;inherited-unused: 生成された main が、別のメソッドで呼び出されない指定クラスとその親のパブリック メソッドと保護メソッドをすべて呼び出します。&lt;BR&gt;&lt;li&gt;inherited-unused-public: 生成された main が、別のメソッドで呼び出されない指定クラスとその親のパブリック メソッドをすべて呼び出します。&lt;BR&gt;&lt;li&gt;custom=list_of_methods: 生成された main は、list_of_methods で指定されたメソッドを呼び出します。&lt;BR&gt;&lt;/ul&gt;</entry>
    <entry key="_no_constructors_init_check_help">生成された main に対し、すべてのクラス フィールドが初期化されているかどうかをチェックしないように指定します。</entry>
    <entry key="_main_generator_writes_variables_help">生成された main によるグローバル変数の初期化方法を指定します。&lt;BR&gt;&lt;li&gt;uninit - main ジェネレーターは初期化されないグローバル変数に乱数を書き込みます (C++ のみ)。&lt;BR&gt;&lt;li&gt;none - main はどのグローバル変数にも書き込みを行いません。&lt;BR&gt;&lt;li&gt;public - 静的および const 変数を除くすべての変数に対し、利用可能な値の全範囲を表現する "乱数" 値が代入されます。&lt;BR&gt;&lt;li&gt;all - すべての変数に対し、利用可能な値の全範囲を表現する "乱数" 値が代入されます。&lt;BR&gt;&lt;li&gt;custom - リストにある変数のみに対し、利用可能な値の全範囲を表現する "乱数" 値が代入されます。</entry>
    <entry key="_functions_called_before_main_help">初期化関数を指定します。&lt;br&gt;自動生成された main によって他の関数よりも先に呼び出される関数です。</entry>
    <entry key="_main_generator_calls_help">パブリックと見なされる関数を指定します。&lt;BR&gt;自動生成された main によってランダムな順序で呼び出される関数です。 </entry>
    <entry key="_variables_written_before_loop_help">循環システムのパラメーターと見なされる一連の変数を指定します。&lt;BR&gt;この変数は、生成された main によって循環ループよりも先に書き込まれます。</entry>
    <entry key="_variables_written_in_loop_help">循環システムの入力と見なされる一連の変数を指定します。&lt;BR&gt;この変数は、生成された main によって循環ループの反復ごとにリセットされます。</entry>
    <entry key="_functions_called_before_loop_help">生成された main によってステップ ループよりも先に呼び出される一連の初期化関数を指定します。</entry>
    <entry key="_functions_called_in_loop_help">ループ内で呼び出す一連の関数を指定します。&lt;BR&gt;&lt;li&gt;なし - このオプションはサブプログラムを呼び出さない場合に使用します。&lt;BR&gt;&lt;li&gt;未使用 - 生成された main はファイル内で呼び出されない関数のみを呼び出します。&lt;BR&gt;&lt;li&gt;すべて - 生成された main はすべての関数を呼び出します。たとえば、関数 'f' が 'g' によって呼び出される場合、生成された main は 'f' も、各パラメーターにランダムな値を当てて呼び出します。&lt;BR&gt;&lt;li&gt;カスタム - 生成された main によって呼び出される関数のリストを指定します。</entry>
    <entry key="_functions_called_after_loop_help">生成された main により循環ループの後に呼び出される関数を指定します。</entry>
    <entry key="_unit_by_unit_help">プロジェクトのソース ファイルごとに個別の検証ジョブを作成します。&lt;br&gt;各ファイルはコンパイルされてから、個別に検証されます。</entry>
    <entry key="_unit_by_unit_common_source_help">各ファイル検証とともに含めるファイルのリストを指定します。&lt;br&gt;このリストに含まれていない関数はスタブされます。</entry>
    <entry key="_shared_variables_mode_help">高速解析を実行して、グローバル変数の共有と使用を判別します。&lt;BR&gt;&lt;BR&gt;解析結果には以下の内容が含まれます:&lt;BR&gt;&lt;ul&gt;&lt;li&gt;グローバル変数 (共有、非共有、使用、未使用)&lt;li&gt;コーディング ルール (有効な場合)&lt;li&gt;コード メトリクス (有効な場合)&lt;/ul&gt;&lt;BR&gt;変数アクセス ビューには、すべてのグローバル変数に対する読み取りおよび書き込み操作も表示されます。</entry>
    <entry key="InputsStubbing_node">入力およびスタブ</entry>
    <entry key="InputsStubbing_title">入力およびスタブ</entry>
    <entry key="Inputs_section">入力</entry>
    <entry key="Stubbing_section">スタブ</entry>
    <entry key="Filtering_section">フィルター</entry>
    <entry key="_data_range_specifications">制約の設定</entry>
    <entry key="_no_def_init_glob">グローバル変数の既定の初期化を無視する</entry>
    <entry key="_no_stl_stubs">STL スタブなし</entry>
    <entry key="_functions_to_stub">スタブを生成する関数</entry>
    <entry key="_library">使用するライブラリ</entry>
    <entry key="_functions_to_stub_column_1">関数</entry>
    <entry key="_stub_embedded_coder_lookup_table_functions">Embedded Coder ルックアップ テーブルのスタブを生成</entry>
    <entry key="_data_range_specifications_help">グローバル変数、ポインターおよび関数パラメーターのデータ制約を指定します。&lt;BR&gt;[編集] ボタンをクリックしてウィザードを開き、指示に従って制約を設定します。あるいは、このフィールドに制約テンプレート ファイルを指定します。&lt;BR&gt;&lt;BR&gt;ここで指定する制約によって Simulink モデルから抽出された値がオーバーライドされます。</entry>
    <entry key="_no_def_init_glob_help">既定でグローバル変数が未初期化として処理されるよう指定します。&lt;BR&gt; - 'on': Polyspace はグローバル変数の暗黙的な初期化を無視します。&lt;BR&gt;グローバル変数の読み取りが書き込みより前に実行されると、未初期化変数エラーが発生します。&lt;BR&gt; - 'off': Polyspace はグローバル変数が ANSI C (ISO C++) 規格に従って初期化されるものとみなします。&lt;BR&gt; 既定の初期化値は float では 0.0、int と char では 0 です。</entry>
    <entry key="_no_stl_stubs_help">標準テンプレート ライブラリ (STL) の Polyspace 実装を使用しません。&lt;BR&gt;標準テンプレート ライブラリの関数のスタブ作成には標準ルールを使用します。</entry>
    <entry key="_functions_to_stub_help">Polyspace でスタブを生成する関数を指定します。</entry>
    <entry key="_library_help">プログラムで使用するライブラリを指定します。&lt;BR&gt;解析では、汎用的なスタブの代わりに、これらライブラリの関数に対するスマート スタブが使用されます (また、関数実装のチェックは試みません)。&lt;BR&gt;このオプションを使用することで、精度を下げずに解析が高速化でき、ライブラリ関数の呼び出しに際してライブラリ固有のチェックがトリガーされます。</entry>
    <entry key="_stub_embedded_coder_lookup_table_functions_help">Embedded Coder ルックアップ テーブルのスタブを自動生成するにはこのオプションをオンにします</entry>
    <entry key="VerificationAssumption_node">検証の前提条件</entry>
    <entry key="VerificationAssumption_title">検証の前提条件</entry>
    <entry key="_respect_types_in_fields">フィールドの型に従う</entry>
    <entry key="_respect_types_in_globals">グローバル変数の型に従う</entry>
    <entry key="_float_rounding_mode">浮動小数点の丸めモード</entry>
    <entry key="_consider_volatile_qualifier_on_fields">フィールドに volatile 修飾子があることを考慮する</entry>
    <entry key="_stubbed_pointers_are_unsafe">環境ポインターが安全でないことを考慮する</entry>
    <entry key="_ignore_assembly_code">アセンブリ コードを無視</entry>
    <entry key="_respect_types_in_fields_help">ポインター型として宣言されていない構造体フィールドはポインター値の保持に使用されないものと見なします。&lt;br&gt;タイプセーフな C コードの場合のみこのオプションを選択してください。</entry>
    <entry key="_respect_types_in_globals_help">ポインター型として宣言されていないグローバル変数はポインター値の保持に使用されないものと見なします。&lt;br&gt;タイプセーフな C コードの場合のみこのオプションを選択してください。</entry>
    <entry key="_float_rounding_mode_help">浮動小数点演算の結果を判定する場合に考慮する丸めモードを指定します。 &lt;BR&gt; &lt;ul&gt; &lt;li&gt;to-nearest: 最も近い整数への丸めモードを考慮し、拡張精度は考慮しません。 &lt;li&gt;all: すべての丸めモードと拡張精度を考慮します。 &lt;/ul&gt;</entry>
    <entry key="_ignore_assembly_code_help">すべてのアセンブリ コードを無視します。&lt;br&gt;このオプションをオンにしない限り、ソフトウェアはアセンブリ コードが C/C++ 変数を変更できると仮定します。</entry>
    <entry key="ChecksAssumption_node">チェック動作</entry>
    <entry key="ChecksAssumption_title">チェック動作</entry>
    <entry key="OverflowAssumption_section">オーバーフロー</entry>
    <entry key="Initialization_section">初期化</entry>
    <entry key="DeadCode_section">デッド コード</entry>
    <entry key="PointerAssumption_section">ポインター</entry>
    <entry key="FloatingPoint_section">浮動小数点</entry>
    <entry key="ImpactAnalysis_section">影響分析</entry>
    <entry key="StackUsage_section">スタック使用量</entry>
    <entry key="_ignore_constant_overflows">定数計算でのオーバーフローを無視</entry>
    <entry key="_allow_negative_operand_in_shift">左シフトで負のオペランドを許可</entry>
    <entry key="_signed_integer_overflows">符号付き整数のオーバーフロー モード</entry>
    <entry key="_unsigned_integer_overflows">符号なし整数のオーバーフロー モード</entry>
    <entry key="_disable_initialization_checks">未初期化のチェックを無効にする</entry>
    <entry key="_check_globals_init">ウォーム リブート後にグローバル変数が初期化されることをチェック</entry>
    <entry key="_detect_pointer_escape">スコープ外のスタック ポインター デリファレンスを検出</entry>
    <entry key="_allow_ptr_arith_on_struct">フィールド間のポインター演算を有効にする</entry>
    <entry key="_size_in_bytes">構造体の部分的割り当てを許可</entry>
    <entry key="_permissive_function_pointer">関数ポインターの許容呼び出し</entry>
    <entry key="_uncalled_function_checks">呼び出されない関数の検出</entry>
    <entry key="_allow_non_finite_floats">非有限の浮動小数点を検討</entry>
    <entry key="_check_infinite">無限大</entry>
    <entry key="_check_nan">NaN</entry>
    <entry key="_check_subnormal">非正規検出モード</entry>
    <entry key="_impact_analysis">影響分析を有効化</entry>
    <entry key="_impact_specifications">ソースとシンクの指定</entry>
    <entry key="_impact_analysis_only">影響分析の結果のみを表示</entry>
    <entry key="_stack_usage">スタック使用量の計算</entry>
    <entry key="_ignore_constant_overflows_help">定数計算でオーバーフローする場合に ANSI/ISO C-90 規格への準拠を緩和します。&lt;br&gt;たとえば、この規格に準拠すると、&lt;i&gt;char x = 0xff;&lt;/i&gt; というコードではオーバーフローが発生します。&lt;br&gt;しかし、このオプションを選択すると、コードは &lt;i&gt;char x = -1;&lt;/i&gt; に変更されます。</entry>
    <entry key="_allow_negative_operand_in_shift_help">ANSI/ISO C-90 規格では、負の数値のシフト演算は許可されていません。既定では、検証が停止します。&lt;br&gt;&lt;br&gt;たとえば、&lt;i&gt; -2 &lt;&lt; 2 &lt;/i&gt; というコードによって検証が停止します。&lt;br&gt;しかしこのオプションを選択すると、Polyspace ではこの演算が有効と見なされ、-2 &lt;&lt; 2 = -8 という結果が生じます。</entry>
    <entry key="_signed_integer_overflows_help">符号付き整数の計算によって範囲外の値 (範囲はデータ型によって決まります) が発生した場合は、Code Prover の動作を指定します:&lt;ul&gt;&lt;li&gt;allow - Code Prover はオーバーフローにフラグを立てません。オーバーフローした結果はラップされます。&lt;br&gt;たとえば、MAX_INT + 1 の結果は MIN_INT にラップされます。&lt;br&gt;&lt;li&gt;forbid (既定) - Code Prover はオーバーフローにフラグを立てます。オーバーフローを引き起こす値は、以降の演算に伝播されません。&lt;br&gt; この動作は ANSI C (ISO C++) 規格に準拠しています。&lt;br&gt;&lt;li&gt;warn-with-wrap-around - Code Prover はオーバーフローにフラグを立てます。オーバーフローした結果はラップされます。</entry>
    <entry key="_unsigned_integer_overflows_help">符号なし整数の計算によって範囲外の値 (範囲はデータ型によって決まります) が発生した場合は、Code Prover の動作を指定します:&lt;ul&gt;&lt;li&gt;allow (既定) - Code Prover はオーバーフローにフラグを立てません。オーバーフローした結果はラップされます。&lt;br&gt;たとえば、MAX_INT + 1 の結果は MIN_INT にラップされます。&lt;br&gt; この動作は ANSI C (ISO C++) 規格に準拠しています。&lt;br&gt;&lt;li&gt;forbid - Code Prover はオーバーフローにフラグを立てます。オーバーフローを引き起こす値は、以降の演算に伝播されません。&lt;br&gt;&lt;li&gt;warn-with-wrap-around - Code Prover はオーバーフローにフラグを立てます。オーバーフローした結果はラップされます。</entry>
    <entry key="_scalar_overflows_behavior_help">[オーバーフローの検出] と共に使用して、整数計算または整数変換のチェックの後の結果を指定します。&lt;br&gt;&lt;br&gt;次のいずれかの値を選択します。&lt;ul&gt;&lt;li&gt;truncate-on-error (既定値) - 結果は許容値に制限され、検証は停止します。&lt;br&gt;チェックがレッドの場合は、以降のすべてのチェックはブラックになります。チェックがオレンジの場合、検証は制限された値で続行されます。&lt;br&gt;&lt;li&gt;wrap-around - 結果は型の範囲でラップアラウンドします。チェックは残りの検証の値には影響しません。</entry>
    <entry key="_disable_initialization_checks_help">以下のチェックを無効にします。&lt;ul&gt;&lt;li&gt;未初期化ローカル変数&lt;br&gt;&lt;li&gt;未初期化変数&lt;br&gt;&lt;li&gt;未初期化ポインター&lt;br&gt;&lt;li&gt;初期化済み戻り値&lt;/i&gt;&lt;/ul&gt;このオプションをオンにすると、宣言時に変数は全範囲とみなされ、ポインターは null または不明なオフセットでメモリ ブロックを指します。</entry>
    <entry key="_check_globals_init_help">指定した初期化コード内でグローバル変数に値が代入されることをチェックします。&lt;BR&gt;アプリケーション全体を検証する場合、初期化コードは、'main' の冒頭からプラグマ 'polyspace_end_of_init' までです。&lt;BR&gt;モジュールまたはライブラリを検証する場合、初期化コードは初期化関数のシーケンスです。</entry>
    <entry key="_detect_pointer_escape_help">未定義の動作の原因となる、関数がローカル変数のいずれかにポインターを返すケースの場所を検出します。</entry>
    <entry key="_allow_ptr_arith_on_struct_help">構造体フィールドの境界を超えるポインター演算を許可します。これは ANSI/ISO C-90 の動作と異なります。</entry>
    <entry key="_size_in_bytes_help">&lt;i&gt;malloc&lt;/i&gt; または &lt;i&gt;cast&lt;/i&gt; ステートメントからの部分的なメモリの割り当てを許可します。</entry>
    <entry key="_permissive_function_pointer_help">既定では、Polyspace は関数ポインターと関数の型が同一の場合にのみ関数ポインターを使用して関数を呼び出すことができます。&lt;br&gt;たとえば、型: &lt;br&gt;&lt;i&gt;int f(int*)&lt;/i&gt;&lt;br&gt; の関数を型: &lt;br&gt;&lt;i&gt;int fptr(void*)&lt;/i&gt; の関数ポインターで呼び出すことはできません。&lt;br&gt;このオプションを設定すると、Polyspace はこのような呼び出しを許可します。&lt;br&gt;関数ポインターを広範に使用するアプリケーションでこのオプションを使用すると、Polyspace はより多くの実行パスを考慮しなければならなくなるため、&lt;br&gt;パフォーマンスが大幅に低下し、多数のオレンジ チェックが示される場合があります。</entry>
    <entry key="_uncalled_function_checks_help">実行時に main または別のエントリ ポイントから直接的または間接的に呼び出されない関数を検出します。&lt;br&gt; &lt;li&gt;none - 呼び出されない関数を検出しない。&lt;br&gt;&lt;li&gt;never-called - 定義済みの呼び出されない関数を検出。&lt;br&gt;関数 func が "never-called" と識別された場合、func からのみ呼び出される関数もすべて "never-called" として識別されます。&lt;br&gt;&lt;li&gt;called-from-unreachable - コードの到達不能の部分から呼び出される定義済みの関数を検出。&lt;br&gt;関数 func が "called-from-unreachable" と識別された場合、func からのみ呼び出される関数もすべて "called-from-unreachable" として識別されます。&lt;br&gt;&lt;li&gt;all - 呼び出されない関数をすべて検出</entry>
    <entry key="_allow_non_finite_floats_help">Inf と NaN を検証に含めます。たとえば、次のようになります。 &lt;BR&gt; &lt;ul&gt; &lt;li&gt;浮動小数点演算からの Inf と NaN を許可します。 &lt;li&gt;不明な値の浮動小数点変数が無限大または NaN であると仮定します。 &lt;/ul&gt; このオプションを使用するだけで、浮動小数点演算に対する多くの数値チェックが実質的に&lt;BR&gt;無効となります。無限大と NaN を全般的に考慮したものの、すべての状況を検討したかどうか&lt;BR&gt;確信がない場合は、無限大と NaN のオプションを warn-first に設定します。&lt;br&gt;&lt;br&gt;Bug Finder では、解析で、無限大との比較、およびデッド コードの NaNs にフラグを付ける場合にこのオプションを使用します。</entry>
    <entry key="_stubbed_pointers_are_unsafe_help">特に制約がある場合を除き､環境ポインターが NULL である可能性があることを指定します｡&lt;br&gt;環境ポインターは次のいずれかです。&lt;br&gt;&lt;ul&gt;&lt;li&gt;global または extern､&lt;/li&gt;&lt;li&gt;スタブ化された関数の戻り値､&lt;/li&gt;&lt;li&gt;呼び出しが生成されたユーザー定義関数のパラメーター｡&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;このオプションを使用しない限り､環境ポインターは既定で、安全かつ NULL ではないとみなされます｡&lt;br&gt;</entry>
    <entry key="_check_infinite_help">結果が無限大 (Inf) になる演算を検出します。&lt;BR&gt;&lt;ul&gt;&lt;li&gt;allow: 演算に対するチェックを生成しません。&lt;BR&gt;&lt;/li&gt;&lt;li&gt;warn-first: オペランドが無限大でない場合にのみ演算に対するチェックを生成します。&lt;BR&gt;チェックがレッドでも検証を続行します。&lt;BR&gt;このモードでは最初に出現した無限大値のみを強調表示します。&lt;/li&gt;&lt;li&gt;forbid: 演算に対するチェックを生成します。&lt;BR&gt;チェックがレッドの場合は検証を停止します。&lt;/li&gt;&lt;/ul&gt;</entry>
    <entry key="_check_nan_help">結果が NaN となる演算を検出します。&lt;BR&gt;&lt;ul&gt;&lt;li&gt;allow: 演算に対するチェックを生成しません。&lt;BR&gt;&lt;/li&gt;&lt;li&gt;warn-first: オペランドが NaN でない場合にのみ演算に対するチェックを生成します。&lt;BR&gt;チェックがレッドでも検証を続行します。&lt;BR&gt;このモードでは最初に出現した NaN のみを強調表示します。&lt;/li&gt;&lt;li&gt;forbid: 演算に対するチェックを生成します。&lt;BR&gt;チェックがレッドの場合は検証を停止します。&lt;/li&gt;&lt;/ul&gt;</entry>
    <entry key="_check_subnormal_help">結果が非正規浮動小数点値となる演算を検出します｡&lt;BR&gt;&lt;ul&gt;&lt;li&gt;allow: 演算に対してチェックを生成しません｡&lt;BR&gt;&lt;/li&gt;&lt;li&gt;warn-first: オペランドが非正規でなはい場合にのみ演算に対するチェックを生成します｡&lt;BR&gt;チェックがレッドでも検証を続行します｡&lt;BR&gt;このモードでは最初に出現した非正規値のみを強調表示します｡&lt;/li&gt;&lt;li&gt;warn-all: オペランドが非正規値でも演算に対するチェックを生成します｡&lt;BR&gt;チェックがレッドでも検証を続行します｡&lt;BR&gt;このモードではすべての非正規値の出現が強調表示されます｡&lt;/li&gt;&lt;li&gt;forbid: 演算にチェックを生成します｡&lt;BR&gt;チェックがレッドの場合は検証を停止します｡&lt;/li&gt;&lt;/ul&gt;</entry>
    <entry key="_consider_volatile_qualifier_on_fields_help">構造体のフィールドの volatile 修飾子を無視しません。&lt;br&gt;このオプションをオンにすると、ソフトウェアは次の仮定を行います。&lt;ul&gt;&lt;li&gt;構造体の 1 つのフィールドが volatile の場合、構造体全体が volatile である。&lt;br&gt;volatile 識別子がない場合でも、すべてのフィールドが volatile である。&lt;/li&gt;&lt;li&gt;volatile 構造体の各フィールドはコード内のどの時点でも全範囲の値をもつ。&lt;/li&gt;&lt;/ul&gt;</entry>
    <entry key="_impact_analysis_help">ソースとシンクとして指定されているプログラム要素間の影響の有無を確認します。</entry>
    <entry key="_impact_specifications_help">プログラム要素をソースとシンクとして特定している XML ファイルを指定して、影響分析を行います。</entry>
    <entry key="_impact_analysis_only_help">実行時エラーの通常の Code Prover チェックをスキップして、影響分析のみを行います。</entry>
    <entry key="_stack_usage_help">スタックの推定使用量の計算と表示</entry>
    <entry key="Precision_node">精度</entry>
    <entry key="Precision_title">精度</entry>
    <entry key="GlobalSettings_section">グローバル設定</entry>
    <entry key="SpecificConstructsSettings_section">特定構成要素の設定</entry>
    <entry key="_O">精度レベル</entry>
    <entry key="_to">検証レベル</entry>
    <entry key="_timeout">検証時間の制限</entry>
    <entry key="_retype_pointer">ポインター型変数の型変更</entry>
    <entry key="_retype_int_pointer">整数型シンボルの型変更</entry>
    <entry key="_context_sensitivity">状況依存性</entry>
    <entry key="_context_sensitivity_column_1">手続き</entry>
    <entry key="_path_sensitivity_delta">手続き間解析の精度を高める</entry>
    <entry key="_modules_precision">特定の精度</entry>
    <entry key="_modules_precision_column_1">ファイル名</entry>
    <entry key="_modules_precision_column_2">精度</entry>
    <entry key="_O_help">検証の精度レベルを指定します。精度レベルが高くなると、検証時間がそれだけ長くなります。&lt;ul&gt;&lt;li&gt;レベル 0 - 静的間隔のコード検証。&lt;li&gt;レベル 1 - 検証に領域値の複雑な多面体モデルを使用します。&lt;li&gt;レベル 2 - より複雑なアルゴリズムを検証に使用して領域値を厳密にモデル化します (整数格子と複雑な多面体による混合アプローチ)。&lt;li&gt;レベル 3 - 長さが 1,000 行に満たないコードのみに適しています。こうしたコードでは選択性が高くなり、コード検証時間が非常に長くなる場合があります。たとえば、コード 1000 行につき 1 時間を要します。&lt;/ul&gt;コード検証をレベル 0 から開始してください。次に、レッド チェックとグレー チェックを修正します。その上で、精度を上げて検証を実行します。</entry>
    <entry key="_to_help">検証レベルを指定します。検証レベルを高くすると選択率が上がります。&lt;br&gt;検証レベルを上げると検証時間も長くなります。</entry>
    <entry key="_timeout_help">指定した制限時間 X[.Y] または X[,Y] 以内に検証が完了しない場合、検証を停止します。ここで、X は時間数を、Y (オプション) は時間の小数部を表します。&lt;br&gt;&lt;br&gt;例:&lt;ul&gt;&lt;li&gt;timeout 5.75 は 5 時間 45 分の制限時間を指定&lt;br&gt;&lt;li&gt;timeout 3,5 は 3 時間 30 分の制限時間を指定&lt;/ul&gt;検証が指定の制限時間内に完了しない場合は、検証失敗と見なされます。</entry>
    <entry key="_retype_pointer_help">ポインター変換連鎖の精度を向上させるために、ポインター型変数の型変更を行います。&lt;BR&gt;例: &lt;BR&gt;struct A '{'int a; char b;'}' s = '{'1, 2'}';&lt;BR&gt;char *tmp = (char *)&amp;s;&lt;BR&gt;struct A *pa = (struct A *)tmp;&lt;BR&gt;assert((pa-&gt;a == 1) &amp;&amp; (pa-&gt;b == 2));&lt;BR&gt;ポインター型のシンボルがオブジェクトの 1 つの型にエイリアスするときに、その元の型をエイリアスされたオブジェクト型で置き換えることができるという原理です。&lt;BR&gt;&lt;BR&gt;この原理はポインター型の構造体/共用体のフィールドに適用できます。&lt;BR&gt;このオプションは [整数型シンボルの型変更] (-retype-int-pointer) と併用することはできません。</entry>
    <entry key="_retype_int_pointer_help">ポインター型と同じサイズの符号付きまたは符号なし整数型のシンボルを型変更します。&lt;BR&gt;例: &lt;BR&gt;struct S '{'&lt;BR&gt;int x;&lt;BR&gt;int y;&lt;BR&gt;int z;&lt;BR&gt;char t;&lt;BR&gt;'}' s = '{'1, 2, 3, 4'}';&lt;BR&gt;struct S2 '{'&lt;BR&gt;int first;&lt;BR&gt;void *p;&lt;BR&gt;'}' s2, *ptr = &amp;s2;&lt;BR&gt;...&lt;BR&gt;ptr-&gt;first = (int)&amp;s;&lt;BR&gt;assert(((struct S *)ptr-&gt;first)-&gt;y == 2);&lt;BR&gt;&lt;BR&gt;このオプションは [ポインター型変数の型変更] (-retype-pointer) と併用することはできません。</entry>
    <entry key="_context_sensitivity_help">所定の関数に含まれるチェックの呼び出しコンテキスト情報を追加します。&lt;br&gt;たとえば、関数に対する 1 つの呼び出しがレッド チェックとなり、別の呼び出しがグリーン チェックとなる場合、両方の呼び出し情報と色がチェック内に含められます。&lt;br&gt;&lt;br&gt;以下の値のいずれかを選択します。&lt;ul&gt;&lt;li&gt;none - 状況依存性なし&lt;br&gt;&lt;li&gt;auto - 状況依存性が適用される関数を自動選択&lt;br&gt;&lt;li&gt;custom - 状況依存性が適用される関数を指定&lt;/li&gt;</entry>
    <entry key="_path_sensitivity_delta_help">手続き間解析の精度を高めます。&lt;br&gt;&lt;br&gt;警告: 3 以下の値を使用してください。&lt;br&gt;そうしない場合、検証に時間がかかります。</entry>
    <entry key="_modules_precision_help">指定された [精度レベル] (-O) とは異なる精度で解析されるコンパイル ユニットのリストを指定します。&lt;BR&gt;&lt;BR&gt;既定では、検証にはすべてのコンパイル ユニットに同じ精度が使用されます。&lt;BR&gt;コンパイル ユニットは .c ファイルのみです。</entry>
    <entry key="Scaling_node">スケーリング</entry>
    <entry key="Scaling_title">スケーリング</entry>
    <entry key="_inline">インライン</entry>
    <entry key="_inline_column_1">手続き</entry>
    <entry key="_k_limiting">構造体内の検証の深さ</entry>
    <entry key="_inline_help">リストされた手続きのそれぞれに対し、すべての呼び出しについて手続きのクローンを作成します。&lt;br&gt;このインライン化によって、指定された手続きでのエイリアス数が減り、精度が向上する可能性があります。&lt;br&gt;&lt;br&gt;&lt;b&gt;警告:&lt;/b&gt; このオプションを多用するとコードが過度に重複し、スケーリングの問題が発生することがあります。</entry>
    <entry key="_k_limiting_help">ポインター解析で識別する構造体内のフィールド数を制限します。つまり、構造体内の解析の深さを指定します。&lt;br&gt;&lt;br&gt;警告: 2 以上の値を使用してください。そうしない場合、検証に時間がかかったり、精度が低下したりします。</entry>
    <entry key="Advanced_node">詳細設定</entry>
    <entry key="Advanced_title">詳細設定</entry>
    <entry key="MergedAdvanced_node">詳細設定</entry>
    <entry key="MergedAdvanced_title">詳細設定</entry>
    <entry key="post_verification_section">ポスト検証</entry>
    <entry key="_post_analysis_command">コード検証の終了後に適用するコマンド/スクリプト</entry>
    <entry key="__other">その他</entry>
    <entry key="_post_analysis_command_help">コード検証の完了後に実行しなければならないコマンドまたはファイルを指定します。</entry>
    <entry key="__other_help">必要に応じて、テクニカル サポート チームによる検証の微調整用非公式オプションの提供が可能です。</entry>
    <entry key="Reporting_node">レポート</entry>
    <entry key="MergedReporting_node">レポート</entry>
    <entry key="Reporting_title">レポート</entry>
    <entry key="MergedReporting_title">レポート</entry>
    <entry key="__report_generation">レポートの生成</entry>
    <entry key="__report_template_code_prover">Code Prover レポート</entry>
    <entry key="__report_template_code_prover_help">Code Prover レポートのテンプレートを指定します&lt;BR&gt;製品オプションは -report-template です。</entry>
    <entry key="__report_template_bug_finder">Bug Finder レポート</entry>
    <entry key="__report_template_bug_finder_help">Bug Finder レポートのテンプレートを指定します&lt;BR&gt;製品オプションは -report-template です。</entry>
    <entry key="_report_template">レポート テンプレート</entry>
    <entry key="_report_template_bug_finder">レポート テンプレート</entry>
    <entry key="_report_template_code_prover">レポート テンプレート</entry>
    <entry key="_report_output_format">出力形式</entry>
    <entry key="__report_generation_help">レポート生成オプションを使用して検証レポートを作成します。</entry>
    <entry key="_report_template_help">解析レポートを生成するためのテンプレートを指定します。</entry>
    <entry key="__bf_report_template_help">解析レポートを生成するためのテンプレートを指定します。</entry>
    <entry key="_report_output_format_help">レポートの出力形式を指定します。</entry>
    <entry key="__external_multitasking_type"/>
    <entry key="_checkers_selection_file"/>
    <entry key="_cert_c"/>
    <entry key="_cert_cpp"/>
    <entry key="_iso_17961"/>
    <entry key="_autosar_cpp14"/>
    <entry key="_guidelines"/>
    <entry key="_cwe"/>
    <entry key="_misra_cpp"/>
    <entry key="_jsf_coding_rules"/>
    <entry key="_misra2"/>
    <entry key="_misra_ac_agc"/>
    <entry key="_misra3"/>
    <entry key="_misra_c_2023"/>
    <entry key="_misra_cpp_2023"/>
    <entry key="_custom_rules"/>
    <entry key="__checkers_preset"/>
  </message>
</rsccat>
