<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2024 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ja_JP" product="polyspace" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="scalarStr">scalar</entry>
    <entry key="ScalarStr">Scalar</entry>
    <entry key="floatStr">float</entry>
    <entry key="FloatStr">Float</entry>
    <entry key="CheckZDVGray">Unreachable check: division by zero error</entry>
    <entry key="CheckZDVGreen">{0} division by zero does not occur</entry>
    <entry key="CheckZDVRed">Error: {0} division by zero occurs</entry>
    <entry key="CheckZDVRedForEvent">{0} division by zero occurs</entry>
    <entry key="CheckZDVOrange">Warning: {0} division by zero may occur</entry>
    <entry key="CheckZDVDarkOrange">Warning (probable error): {0} division by zero may occur</entry>
    <entry key="CheckNIVGrey">Unreachable check: not initialized variable error</entry>
    <entry key="CheckNIVGreen">variable is initialized (type: {0})</entry>
    <entry key="CheckNIVRed">Error: variable is not initialized (type: {0})</entry>
    <entry key="CheckNIVOrange">Warning: variable may not be initialized (type: {0})</entry>
    <entry key="CheckNIVDarkOrange">Warning (probable error): variable may not be initialized (type: {0})</entry>
    <entry key="CheckNIVLGrey">Unreachable check: not initialized local variable error</entry>
    <entry key="CheckNIVLGreen">Local variable is initialized (type: {0})</entry>
    <entry key="CheckNIVLRed">Error: Local variable is not initialized (type: {0})</entry>
    <entry key="CheckNIVLOrange">Warning: Local variable may not be initialized (type: {0})</entry>
    <entry key="CheckNIVLDarkOrange">Warning (probable error): Local variable may not be initialized (type: {0})</entry>
    <entry key="CheckNIVLBitAssign">{0} might not be initialized before assignment.\nOnly some bits of {1} are initialized by assignment.</entry>
    <entry key="CheckNIVLBitAssignSure">{0} is not initialized before assignment.\nOnly some bits of {1} are initialized by assignment.</entry>
    <entry key="CheckSHFGray">Unreachable check: shift error[0..{0,number,integer}]</entry>
    <entry key="CheckSHFGreen">{0} shift amount is within its bounds[0..{1,number,integer}]</entry>
    <entry key="CheckSHFRed">Error: {0} shift amount is outside its bounds[0..{1,number,integer}]</entry>
    <entry key="CheckSHFRedForEvent">{0} shift amount is outside its bounds[0..{1,number,integer}]</entry>
    <entry key="CheckSHFOrange">Warning: {0} shift amount may be outside its bounds[0..{1,number,integer}]</entry>
    <entry key="CheckSHFDarkOrange">Warning (probable error): {0} shift amount may be outside its bounds[0..{1,number,integer}]</entry>
    <entry key="CheckOVFLGray">Unreachable check: overflow operation not reachable in {0} range</entry>
    <entry key="CheckOVFLGreen">Operation [{0}] on {1} does not overflow in {2} range</entry>
    <entry key="CheckOVFLRedOvfl">Error: operation [{0}] on {1} overflows (result is always strictly greater than MAX {2})</entry>
    <entry key="CheckOVFLRedUnfl">Error: operation [{0}] on {1} overflows (result is always strictly lower than MIN {2})</entry>
    <entry key="CheckOVFLRed">Error: operation [{0}] on {1} overflows</entry>
    <entry key="CheckOVFLRedOvflForEvent">Operation [{0}] on {1} overflows (result is always strictly greater than MAX {2})</entry>
    <entry key="CheckOVFLRedUnflForEvent">Operation [{0}] on {1} overflows (result is always strictly lower than MIN {2})</entry>
    <entry key="CheckOVFLRedForEvent">Operation [{0}] on {1} overflows</entry>
    <entry key="CheckOVFLOrangeOvfl">Warning: operation [{0}] on {1} may overflow (result strictly greater than MAX {2})</entry>
    <entry key="CheckOVFLOrangeUnfl">Warning: operation [{0}] on {1} may overflow (result strictly lower than MIN {2})</entry>
    <entry key="CheckOVFLOrange">Warning: operation [{0}] on {1} may overflow (on MIN or MAX bounds of {2})</entry>
    <entry key="CheckOVFLDarkOrangeOvfl">Warning (probable error): operation [{0}] on {1} overflows (result strictly greater than MAX {2})</entry>
    <entry key="CheckOVFLDarkOrangeUnfl">Warning (probable error): operation [{0}] on {1} overflows (result strictly lower than MIN {2})</entry>
    <entry key="CheckOVFLDarkOrange">Warning (probable error): operation [{0}] on {1} overflows</entry>
    <entry key="CheckCONV_OVFLGray">Unreachable check: overflow operation not reachable in {0} range</entry>
    <entry key="CheckCONV_OVFLGrayTrivial">By definition, unreachable check: overflow operation not reachable in {0} range</entry>
    <entry key="CheckCONV_OVFLGreen">Operation [conversion from {0} to {1}] on {2} does not overflow in {3} range</entry>
    <entry key="CheckCONV_OVFLGreenTrivial">By definition, operation [conversion from {0} to {1}] on {2} does not overflow in {3} range</entry>
    <entry key="CheckCONV_OVFLRedOvfl">Error: operation [conversion from {0} to {1}] on {2} overflows (result is always strictly greater than MAX {3})</entry>
    <entry key="CheckCONV_OVFLRedUnfl">Error: operation [conversion from {0} to {1}] on {2} overflows (result is always strictly lower than MIN {3})</entry>
    <entry key="CheckCONV_OVFLRed">Error: operation [conversion from {0} to {1}] on {2} overflows</entry>
    <entry key="CheckCONV_OVFLRedOvflForEvent">Operation [conversion from {0} to {1}] on {2} overflows (result is always strictly greater than MAX {3})</entry>
    <entry key="CheckCONV_OVFLRedUnflForEvent">Operation [conversion from {0} to {1}] on {2} overflows (result is always strictly lower than MIN {3})</entry>
    <entry key="CheckCONV_OVFLRedForEvent">Operation [conversion from {0} to {1}] on {2} overflows</entry>
    <entry key="CheckCONV_OVFLOrangeOvfl">Warning: operation [conversion from {0} to {1}] on {2} may overflow (result strictly greater than MAX {3})</entry>
    <entry key="CheckCONV_OVFLOrangeUnfl">Warning: operation [conversion from {0} to {1}] on {2} may overflow (result strictly lower than MIN {3})</entry>
    <entry key="CheckCONV_OVFLOrange">Warning: operation [conversion from {0} to {1}] on {2} may overflow (on MIN or MAX bounds of {3})</entry>
    <entry key="CheckCONV_OVFLDarkOrangeOvfl">Warning (probable error): operation [conversion from {0} to {1}] on {2} overflows (result strictly greater than MAX {3})</entry>
    <entry key="CheckCONV_OVFLDarkOrangeUnfl">Warning (probable error): operation [conversion from {0} to {1}] on {2} overflows (result strictly lower than MIN {3})</entry>
    <entry key="CheckCONV_OVFLDarkOrange">Warning (probable error): operation [conversion from {0} to {1}] on {2} overflows</entry>
    <entry key="CheckOBAIGrey">Unreachable check: out of bounds array index check</entry>
    <entry key="CheckOBAIGreenSizeUndefined">Array index is within bounds : [array size undefined]</entry>
    <entry key="CheckOBAIGreen">Array index is within bounds : [0..{0, number, integer}]</entry>
    <entry key="CheckOBAIOrange">Warning: array index may be outside bounds : [0..{0, number, integer}]</entry>
    <entry key="CheckOBAIOrangeSizeUndefined">Warning: array index may be outside bounds : [array size undefined]</entry>
    <entry key="CheckOBAIRed">Error: array index is outside its bounds : [0..{0, number, integer}]</entry>
    <entry key="CheckIntZDVCertain">Divisor is 0.</entry>
    <entry key="CheckIntZDVUncertain">Divisor may be 0.</entry>
    <entry key="CheckFloatZDVCertain">Divisor is 0.0.</entry>
    <entry key="CheckFloatZDVUncertain">Divisor may be 0.0.</entry>
    <entry key="CheckSHFCertain">Right operand of {0_operation} is outside the shift capacity.</entry>
    <entry key="CheckSHFUncertain">Right operand of {0_operation} may be outside the shift capacity.</entry>
    <entry key="CheckOVFLCertain">Operation {0_operation} overflows.</entry>
    <entry key="CheckOVFLUncertain">Operation {0_operation} may overflow.</entry>
    <entry key="CheckCONV_OVFLCertain">Conversion from {0} to {1} overflows.</entry>
    <entry key="CheckCONV_OVFLUncertain">Conversion from {0} to {1} may overflow.</entry>
    <entry key="CheckFLOAT_ABSORPTIONFirstAbsorbedCertain">The {0_operation} operation is redundant in the current context.\nThe first operand is negligible compared to the second operand and has no effect on the result.</entry>
    <entry key="CheckFLOAT_ABSORPTIONSecondAbsorbedCertain">The {0_operation} operation is redundant in the current context.\nThe second operand is negligible compared to the first operand and has no effect on the result.</entry>
    <entry key="CheckFLOAT_ABSORPTIONFirstAbsorbedUncertain">The {0_operation} operation may be redundant in the current context.\nThe first operand may be negligible compared to the second operand and may have no effect on the result.</entry>
    <entry key="CheckFLOAT_ABSORPTIONSecondAbsorbedUncertain">The {0_operation} operation may be redundant in the current context.\nThe second operand may be negligible compared to the first operand and may have no effect on the result.</entry>
    <entry key="LeftOperand">Left operand: {0}</entry>
    <entry key="RightOperand">Right operand: {0}</entry>
    <entry key="ValidRangeStrPair">Valid range: [{0} .. {1}]</entry>
    <entry key="ValidRangeZeroToMax">Valid range: [0 .. {0,number,integer}]</entry>
    <entry key="ResultIncludesExampleValues">Result includes example values that lead to the defect.</entry>
    <entry key="IsPositiveOrZeroGreen">{0} is positive or null</entry>
    <entry key="IsPositiveOrZeroOrange">{0} may not be positive nor null</entry>
    <entry key="IsPositiveOrZeroRed">{0} is definitely negative</entry>
    <entry key="IsNonZeroGreen">{0} is non null</entry>
    <entry key="IsNonZeroOrange">{0} may be null</entry>
    <entry key="IsNonZeroRed">{0} is definitely null</entry>
    <entry key="IsStrictlyPositiveGreen">{0} is strictly positive</entry>
    <entry key="IsStrictlyPositiveOrange">{0} may not be strictly positive</entry>
    <entry key="IsStrictlyPositiveRed">{0} is definitely negative or null</entry>
    <entry key="IsStrictlyNegativeGreen">{0} is strictly negative</entry>
    <entry key="IsStrictlyNegativeOrange">{0} may not be strictly negative</entry>
    <entry key="IsStrictlyNegativeRed">{0} is definitely positive or null</entry>
    <entry key="IsNegativeOrZeroGreen">{0} is negative or null</entry>
    <entry key="IsNegativeOrZeroOrange">{0} may not be negative nor null</entry>
    <entry key="IsNegativeOrZeroRed">{0} is definitely positive</entry>
    <entry key="ExpectedRangeOrSingleValueGreen">{0} is within either expected range: {1} or {2}</entry>
    <entry key="ExpectedRangeOrSingleValueOrange">{0} may not be within either expected range: {1} or {2}</entry>
    <entry key="ExpectedRangeOrSingleValueRed">{0} is not within either expected range: {1} or {2}</entry>
    <entry key="WritableArrayGreen">{0} is a writable pointer with the given size</entry>
    <entry key="WritableArrayOrange">{0} may not be a writable pointer with the given size</entry>
    <entry key="WritableArrayRed">{0} is not a writable pointer with the given size</entry>
    <entry key="ReadableArrayGreen">{0} is a readable pointer</entry>
    <entry key="ReadableArrayOrange">{0} may not be a readable pointer</entry>
    <entry key="ReadableArrayRed">{0} is not a readable pointer</entry>
    <entry key="CheckInfoReturnedValueNumericGreen">value returned fits in range of returned type</entry>
    <entry key="CheckInfoReturnedValueNumericOrange">value returned may not fit in range of returned type</entry>
    <entry key="CheckInfoReturnedValueNumericRed">value returned does not fit in range of returned type</entry>
    <entry key="StdFuncAlreadyDefined">Standard function {0} is already defined, it won't be emulated.</entry>
    <entry key="ReadParam2">second argument (output buffer)</entry>
    <entry key="ReadParam3">third argument (nbytes)</entry>
    <entry key="WriteParam2">second argument (input buffer)</entry>
    <entry key="NullOrValidStringGreen">{0} is a null pointer or a valid string</entry>
    <entry key="NullOrValidStringOrange">{0} may not be a valid string</entry>
    <entry key="NullOrValidStringRed">{0} is neither a null pointer nor a valid string</entry>
    <entry key="ValidStringGreen">{0} is a valid string</entry>
    <entry key="ValidStringOrange">{0} may not be a valid string</entry>
    <entry key="ValidStringRed">{0} is not a valid string</entry>
    <entry key="ReadParamBuffer1">first argument (input buffer)</entry>
    <entry key="ReadParamBuffer2">second argument (input buffer)</entry>
    <entry key="ReadParamBuffer3">third argument (input buffer)</entry>
    <entry key="ReadParamBufferN">{0}th argument (input buffer)</entry>
    <entry key="TitleLibraryCheckGreen">The {0} function call {1_symbol} is compliant with the API reference.</entry>
    <entry key="TitleLibraryCheckOrange">Warning: The {0} function call {1_symbol} may not be compliant with the API reference.</entry>
    <entry key="TitleLibraryCheckRed">Error: The {0} function call {1_symbol} is not compliant with the API reference.</entry>
    <entry key="TitleLibraryCheckGrey">Unreachable check: invalid argument(s) error</entry>
    <entry key="CheckForThisParameter">{0} parameter:</entry>
    <entry key="ArgumentIsNotNullPtrGreen">{0} cannot be a null pointer.</entry>
    <entry key="ArgumentIsNotNullPtrOrange">{0} might be a null pointer.</entry>
    <entry key="ArgumentIsNotNullPtrRed">{0} is a null pointer.</entry>
    <entry key="ArgumentIsNotNullPtrGrey">{0} might be a null pointer (not checked).</entry>
    <entry key="ArgumentIsAllocatedGreen">{0} is allocated.</entry>
    <entry key="ArgumentIsAllocatedOrange">{0} might not be allocated.</entry>
    <entry key="ArgumentIsAllocatedRed">{0} is not allocated.</entry>
    <entry key="ArgumentIsAllocatedGrey">{0} might not be allocated (not checked).</entry>
    <entry key="ArgumentIsInitializedGreen">{0} points to initialized memory.</entry>
    <entry key="ArgumentIsInitializedOrange">{0} might not point to initialized memory.</entry>
    <entry key="ArgumentIsInitializedRed">{0} does not point to initialized memory.</entry>
    <entry key="ArgumentIsInitializedGrey">{0} might not point to initialized memory (not checked).</entry>
    <entry key="ArgumentIsInitializedGreyForSmBus">{0} might not point to initialized memory (not checked because data is not read by the function, or because a previous check is blocking).</entry>
    <entry key="ArgumentIsInRangeGreen">{0} is in the expected range.</entry>
    <entry key="ArgumentIsInRangeOrange">{0} might not be in expected range.</entry>
    <entry key="ArgumentIsInRangeRed">{0} is not in the expected range.</entry>
    <entry key="ArgumentIsInRangeGrey">{0} might not be in expected range (not checked).</entry>
    <entry key="ArgumentIsReadOrWriteGreen">{0} is either I2C_SMBUS_READ or I2C_SMBUS_WRITE.</entry>
    <entry key="ArgumentIsReadOrWriteOrange">{0} might be neither I2C_SMBUS_READ nor I2C_SMBUS_WRITE.</entry>
    <entry key="ArgumentIsReadOrWriteRed">{0} is neither I2C_SMBUS_READ nor I2C_SMBUS_WRITE.</entry>
    <entry key="ArgumentIsReadOrWriteGrey">{0} might be neither I2C_SMBUS_READ nor I2C_SMBUS_WRITE (not checked).</entry>
    <entry key="ArgumentMayBeNonFinite">Argument {0,number,integer} may be infinite or NaN.</entry>
    <entry key="PstUnitPolicyIsValid">Specified policy is valid.</entry>
    <entry key="PstUnitPolicyIsValidGreen">Specified policy value is valid.</entry>
    <entry key="PstUnitPolicyIsValidRed">Specified policy value is invalid.</entry>
    <entry key="PstUnitPolicyIsValidOrange">Specified policy value may not be valid.</entry>
    <entry key="PstUnitRangeIsValid">Specified range is valid.</entry>
    <entry key="PstUnitRangeIsValidGreen">Minimum range value is lower than or equal to maximum.</entry>
    <entry key="PstUnitRangeIsValidRed">Minimum range value is greater than maximum.</entry>
    <entry key="PstUnitRangeIsValidOrange">Minimum range value may be greater than maximum.</entry>
    <entry key="PstUnitRangeValueIsValid">Specified value is valid.</entry>
    <entry key="PstUnitRangeValueIsValidGreen">Specified value is in range [min .. max].</entry>
    <entry key="PstUnitRangeValueIsValidRed">Specified value is outside of range [min .. max].</entry>
    <entry key="PstUnitRangeValueIsValidOrange">Specified value may be outside of range [min .. max].</entry>
    <entry key="PstUnitRangeIsValidMemberSize">The size of the buffer members is valid.</entry>
    <entry key="PstUnitRangeIsScalarMemberSizeGreen">The size of the buffer members is the size of a scalar type.</entry>
    <entry key="PstUnitRangeIsScalarMemberSizeRed">The size of the buffer members is not the size of a scalar type.</entry>
    <entry key="PstUnitRangeIsScalarMemberSizeOrange">The size of the buffer members may not be the size of a scalar type.</entry>
    <entry key="PstUnitRangeIsFloatMemberSizeGreen">The size of the buffer members is the size of a float type.</entry>
    <entry key="PstUnitRangeIsFloatMemberSizeRed">The size of the buffer members is not the size of a float type.</entry>
    <entry key="PstUnitRangeIsFloatMemberSizeOrange">The size of the buffer members may not be the size of a float type.</entry>
    <entry key="PstUnitRangeMatchesDataType">Specified range matches data type.</entry>
    <entry key="PstUnitRangeMinMatchesDataTypeGreen">The minimum value of the range is greater than or equal to the minimum value allowed by the type.</entry>
    <entry key="PstUnitRangeMinMatchesDataTypeRed">The minimum value of the range is lower than the minimum value allowed by the type.</entry>
    <entry key="PstUnitRangeMinMatchesDataTypeOrange">The minimum value of the range may not be greater than or equal to the minimum value allowed by the type.</entry>
    <entry key="PstUnitRangeMaxMatchesDataTypeGreen">The maximum value of the range is lower than or equal to the maximum value allowed by the type.</entry>
    <entry key="PstUnitRangeMaxMatchesDataTypeRed">The maximum value of the range is greater than the maximum value allowed by the type.</entry>
    <entry key="PstUnitRangeMaxMatchesDataTypeOrange">The maximum value of the range may not be lower than or equal to the maximum value allowed by the type.</entry>
    <entry key="PstUnitRangeValueMatchesDataType">Specified value matches data type.</entry>
    <entry key="PstUnitRangeValueMatchesDataTypeMinGreen">Specified value is greater than or equal to the minimum value allowed by the type.</entry>
    <entry key="PstUnitRangeValueMatchesDataTypeMinRed">Specified value is lower than the minimum value allowed by the type.</entry>
    <entry key="PstUnitRangeValueMatchesDataTypeMinOrange">Specified value may be lower than the minimum value allowed by the type.</entry>
    <entry key="PstUnitRangeValueMatchesDataTypeMaxGreen">Specified value is lower than or equal to the maximum value allowed by the type.</entry>
    <entry key="PstUnitRangeValueMatchesDataTypeMaxRed">Specified value is greater than the maximum value allowed by the type.</entry>
    <entry key="PstUnitRangeValueMatchesDataTypeMaxOrange">Specified value may be greater than the maximum value allowed by the type.</entry>
    <entry key="PstUnitRangeValidNmemb">Specified number of elements is valid</entry>
    <entry key="PstUnitRangeValidNmembGreen">Specified number of elements is non-null</entry>
    <entry key="PstUnitRangeValidNmembRed">Specified number of elements is null</entry>
    <entry key="PstUnitRangeValidNmembOrange">Specified number of elements may be null</entry>
    <entry key="PstUnitRangeBufferNotNull">Specified buffer is non-null</entry>
    <entry key="PstUnitRangeBufferValid">Specified buffer is valid</entry>
    <entry key="PstUnitRangeBufferValidGreen">Specified buffer points an allocated memory area.</entry>
    <entry key="PstUnitRangeBufferValidRed">Specified buffer points an unallocated memory area or overflows beyond an allocated memory area.</entry>
    <entry key="PstUnitRangeBufferValidOrange">Specified buffer may point an unallocated memory area or may overflow beyond an allocated memory area.</entry>
    <entry key="InfoOperator">operator {0_operation} on type {1_symbol}</entry>
    <entry key="InfoConversionOp">Conversion from {0_symbol} to {1_symbol}</entry>
    <entry key="InfoLeftOperand">\n{0}     left:   {1}{2}</entry>
    <entry key="InfoRightOperand">\n{0}     right:  {1}{2}</entry>
    <entry key="InfoOperand">\n{0}     right:  {1}{2}</entry>
    <entry key="InfoOperandsRelation">\n{0}     Relation(s): {1}{2}</entry>
    <entry key="InfoOperationResult">\n{0}     result: {1}{2}</entry>
    <entry key="InfoOCTruncatedMode">\n{0}     (result is truncated){1}</entry>
    <entry key="InfoOCWrapAroundMode">\n{0}     (result is wrapped){1}</entry>
    <entry key="InfoKnownArraySize">array size : {0, number, integer}</entry>
    <entry key="InfoUnknownArraySize">array size: undefined</entry>
    <entry key="InfoArrayIndex">array index value: </entry>
    <entry key="ContextCxxTopCtor">- when called as a top-constructor</entry>
    <entry key="ContextCxxTopDtor">- when called as a top-destructor</entry>
    <entry key="ContextCxxSubCtor">- when called during construction of a {0} object</entry>
    <entry key="ContextCxxSubDtor">- when called during destruction of a {0} object</entry>
    <entry key="ContextCxxSpecialized">- when called when this-type is a {0} or a derived class</entry>
    <entry key="ContextCxxDuringConstr">- when called during construction of a {0} object, when this-type is known to be a {1}</entry>
    <entry key="ContextCxxDuringDestr">- when called during destruction of a {0} object, when this-type is known to be a {1}</entry>
    <entry key="ContextCxxDuringConstrDestr">- when called during construction/destruction of a {0} object, when this-type is known to be a {1}</entry>
    <entry key="ContextCxxDuringConstrNoParent">- when called during construction of a derived object, when this-type is known to be a {0}</entry>
    <entry key="ContextCxxDuringDestrNoParent">- when called during destruction of a derived object, when this-type is known to be a {0}</entry>
    <entry key="ContextCxxDuringConstrDestrNoParent">- when called during construction/destruction of a derived object, when this-type is known to be a {0}</entry>
    <entry key="ExceptNewReturnNull">Replacement "{0}" implementation might return null.\nThis replacement operator must not return null according to the required behavior specifications of the Standard.\nTo fix, throw a std::bad_alloc exception instead of returning null.</entry>
    <entry key="NoreturnFuncReturn">Function "{0}" returns through this point of exit.\nA function that returns when it is declared with attribute 'noreturn' is undefined behavior.</entry>
    <entry key="InvalidThreadEntryPointParam">Invalid index "{0}" in thread_entry_point_param library property.</entry>
  </message>
</rsccat>
