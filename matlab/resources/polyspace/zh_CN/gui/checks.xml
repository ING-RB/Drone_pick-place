<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="zh_CN" product="polyspace" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="defect">缺陷</entry>
    <entry key="defects">缺陷</entry>
    <entry key="numerical">数值</entry>
    <entry key="int_zero_div">整数除以零</entry>
    <entry key="float_zero_div">浮点数除以零</entry>
    <entry key="int_conv_ovfl">整数转换溢出</entry>
    <entry key="uint_conv_ovfl">无符号整数转换溢出</entry>
    <entry key="sign_change">符号变化整数转换溢出</entry>
    <entry key="float_conv_ovfl">浮点数转换溢出</entry>
    <entry key="int_ovfl">整数溢出</entry>
    <entry key="uint_ovfl">无符号整数溢出</entry>
    <entry key="int_constant_ovfl">整数常量溢出</entry>
    <entry key="uint_constant_ovfl">无符号整数常量溢出</entry>
    <entry key="float_ovfl">浮点数溢出</entry>
    <entry key="int_std_lib">无效的标准库整数例程使用</entry>
    <entry key="float_std_lib">无效的标准库浮点例程使用</entry>
    <entry key="shift_neg">负值移位</entry>
    <entry key="shift_ovfl">移位运算的右操作数越界</entry>
    <entry key="invalid_float_op">无效的浮点数运算</entry>
    <entry key="float_absorption">浮点操作数被吸收</entry>
    <entry key="subnormal">次正规浮点数</entry>
    <entry key="bad_plain_char_use">对数值使用纯字符类型</entry>
    <entry key="bitwise_neg">对负值执行按位运算</entry>
    <entry key="int_precision_exceeded">超出整数精度</entry>
    <entry key="invalid_operation_on_boolean">可能无效的布尔操作数运算</entry>
    <entry key="int_to_float_precision_loss">整数到浮点数的转换存在精度损失</entry>
    <entry key="static_memory">静态内存</entry>
    <entry key="out_bound_array">数组访问越界</entry>
    <entry key="null_ptr">对空指针执行解引用</entry>
    <entry key="out_bound_ptr">指针访问越界</entry>
    <entry key="func_cast">不可靠的函数指针转换</entry>
    <entry key="ptr_cast">不可靠的指针转换</entry>
    <entry key="local_addr_escape">堆栈变量的指针或引用超出作用域</entry>
    <entry key="stack_ovfl">堆栈溢出</entry>
    <entry key="mem_std_lib">无效的标准库内存例程使用</entry>
    <entry key="str_std_lib">无效的标准库字符串例程使用</entry>
    <entry key="null_ptr_arith">对空指针执行算术运算</entry>
    <entry key="object_size_mismatch">错误分配转换对象的大小</entry>
    <entry key="path_buffer_overflow">在未检查最大缓冲区的情况下使用路径操作函数</entry>
    <entry key="str_format_buffer_overflow">字符串格式设定符不正确导致缓冲区溢出</entry>
    <entry key="strlib_buffer_overflow">字符串操作中目标缓冲区上溢</entry>
    <entry key="strlib_buffer_underflow">字符串操作中目标缓冲区下溢</entry>
    <entry key="putenv_auto_var">使用自动变量作为 putenv 族函数参数</entry>
    <entry key="ptr_to_diff_array">在指向不同数组的指针之间做减法或进行比较</entry>
    <entry key="move_const_object">对 const 对象执行移动运算</entry>
    <entry key="incorrect_value_forwarding">不正确的值转发</entry>
    <entry key="dynamic_memory">动态内存</entry>
    <entry key="freed_ptr">使用之前已释放的指针</entry>
    <entry key="unchecked_allocated_memory">未检查可能的动态内存分配失败</entry>
    <entry key="unprotected_memory_allocation">无保护动态内存分配</entry>
    <entry key="double_deallocation">释放之前已释放的指针</entry>
    <entry key="bad_free">无效的指针释放</entry>
    <entry key="mem_leak">内存泄漏</entry>
    <entry key="bad_delete">无效的指针删除</entry>
    <entry key="delete_non_virtual">删除非虚拟内存</entry>
    <entry key="win_mismatch_dealloc">Windows 上的分配/取消分配函数不匹配</entry>
    <entry key="alignment_change">内存重新分配后对齐发生改变</entry>
    <entry key="programming">编程</entry>
    <entry key="assert">断言</entry>
    <entry key="bad_equal_use">无效的 = 运算符使用</entry>
    <entry key="bad_equal_equal_use">无效的 == 运算符使用</entry>
    <entry key="decl_mismatch">声明不匹配</entry>
    <entry key="typedef_mismatch">Typedef 不匹配</entry>
    <entry key="bad_float_op">使用相等运算符进行浮点比较</entry>
    <entry key="missing_null_char">字符串数组中缺失空字符</entry>
    <entry key="qualifier_mismatch">在转换中删除限定符</entry>
    <entry key="ptr_sizeof_mismatch">在 sizeof 中使用错误的类型</entry>
    <entry key="operator_precedence">运算符优先级规则导致可能的非预期表达式计算</entry>
    <entry key="std_func_arg_mismatch">用不正确的参数调用标准函数</entry>
    <entry key="invalid_memory_assumption">无效的内存组织假设</entry>
    <entry key="bad_ptr_scaling">不正确的指针缩放</entry>
    <entry key="constant_object_write">写入 const 限定对象</entry>
    <entry key="improper_array_init">不正确的数组初始化</entry>
    <entry key="memset_invalid_size">使用大小参数为零的 memset</entry>
    <entry key="invalid_va_list_arg">无效的 va_list 参数</entry>
    <entry key="non_positive_vla_size">大小不为正数的可变长度数组</entry>
    <entry key="overlapping_assign">重叠赋值</entry>
    <entry key="overlapping_copy">内存重叠的复制</entry>
    <entry key="sizeof_misuse">可能的 sizeof 误用</entry>
    <entry key="bad_file_access_mode_status">错误的文件访问模式或状态</entry>
    <entry key="write_internal_buffer_returned_from_std_func">修改由不可重入标准函数返回的内部缓冲区</entry>
    <entry key="memset_invalid_value">使用非预期值调用 memset 族函数</entry>
    <entry key="missing_switch_case">切换条件缺少 case</entry>
    <entry key="other_std_lib">无效的标准库例程使用</entry>
    <entry key="autosar_lib_non_compliance">不符合 AUTOSAR 规范</entry>
    <entry key="code_behavior_spec_non_compliance">不符合代码行为规范</entry>
    <entry key="i2c_smbus_lib_non_compliance">不符合 I2C SMBus 规范</entry>
    <entry key="bad_int_ptr_cast">指针和整数之间的不安全转换</entry>
    <entry key="unsafe_str_to_numeric">从字符串到数值的不安全转换</entry>
    <entry key="exit_abnormal_handler">退出处理程序异常终止</entry>
    <entry key="memcmp_strings">比较字符串内存</entry>
    <entry key="memcmp_padding_data">比较填充数据内存</entry>
    <entry key="non_reentrant_std_return">误用不可重入标准函数的返回值</entry>
    <entry key="errno_misuse">误用 errno</entry>
    <entry key="missing_errno_reset">errno 未重置</entry>
    <entry key="character_misuse">误用符号扩展字符值</entry>
    <entry key="char_eof_confused">字符值被吸收转化为 EOF</entry>
    <entry key="io_interleaving">从文件流中交替执行输入和输出运算间未执行刷新和定位调用</entry>
    <entry key="sig_handler_comp_excp_return">从计算异常信号处理程序返回结果</entry>
    <entry key="sig_handler_calling_signal">从信号处理程序内部调用 signal</entry>
    <entry key="sig_handler_async_unsafe">从信号处理程序调用的函数不是异步安全的</entry>
    <entry key="sig_handler_async_unsafe_strict">从信号处理程序调用的函数不是异步安全的(严格 ISO C)</entry>
    <entry key="unprototyped_func_call">通过非原型函数指针进行调用</entry>
    <entry key="file_object_misuse">误用 FILE 对象</entry>
    <entry key="flexible_array_member_struct_misuse">误用具有灵活数组成员的结构体</entry>
    <entry key="missing_byteswap">传输数据时未对字节重新排序</entry>
    <entry key="sig_handler_shared_object">在信号处理程序内访问共享数据</entry>
    <entry key="sig_handler_errno_misuse">在信号处理程序中误用 errno</entry>
    <entry key="invalid_file_pos">无效的文件位置</entry>
    <entry key="indeterminate_string">使用不确定字符串</entry>
    <entry key="macro_used_as_object">预定义宏用作对象</entry>
    <entry key="unnamed_namespace_in_header">头文件中未命名的命名空间</entry>
    <entry key="side_effect_ignored">表达式的副作用被忽略</entry>
    <entry key="pre_ucname_join_tokens">通过标记串联创建通用字符名称</entry>
    <entry key="pre_directive_macro_arg">在宏参数中使用预处理器指令</entry>
    <entry key="inline_constraint_not_respected">未遵守内联约束</entry>
    <entry key="va_arg_incorrect_type">传递给 va_arg 的数据类型不正确</entry>
    <entry key="too_many_va_arg_calls">va_arg 调用次数相对当前参数列表太多</entry>
    <entry key="stream_with_side_effect">可能带非预期副作用的流参数</entry>
    <entry key="temp_object_access">访问具有临时存在时间的对象</entry>
    <entry key="memcmp_float">比较浮点值内存</entry>
    <entry key="invalid_env_pointer">环境指针因前面的运算而失效</entry>
    <entry key="narrow_wide_str_misuse">误用窄字符串或宽字符串</entry>
    <entry key="side_effect_in_unsafe_macro_arg">不安全的宏中带副作用的参数</entry>
    <entry key="offsetof_misuse">在 C++ 中不正确地使用 offsetof</entry>
    <entry key="va_start_misuse">不正确地使用 va_start</entry>
    <entry key="va_start_incorrect_type">传递给 va_start 类型数据不正确</entry>
    <entry key="copy_paste">复制粘贴</entry>
    <entry key="clone">克隆</entry>
    <entry key="duplicated_code">重复代码</entry>
    <entry key="almost_duplicated_code">部分重复代码</entry>
    <entry key="copy_paste_error">可能发生复制粘贴错误</entry>
    <entry key="std_string_c_str_compared_to_pointer">将 string::c_str() 结果与另一个指针做比较</entry>
    <entry key="std_remove_without_erase">不正确的 erase-remove 惯用法</entry>
    <entry key="invalid_iterator_usage">无效的迭代器用法</entry>
    <entry key="dangling_string_view">用悬空指针初始化 std::string_view</entry>
    <entry key="library_usage">库的用法</entry>
    <entry key="pointer_to_temporary_object">指向销毁的临时对象的指针或引用</entry>
    <entry key="pstunit_misuse">误用 PSTUnit 库</entry>
    <entry key="pstunit_misuse_setup_teardown">不正确地使用测试设置/拆解 API</entry>
    <entry key="pstunit_misuse_fixtures">不正确地使用测试脚手架</entry>
    <entry key="pstunit_misuse_mocking">不正确地使用模拟 API</entry>
    <entry key="pstunit_misuse_registration">不正确的测试注册或定义</entry>
    <entry key="pstunit_unsupported_syntax">对测试编写 API 使用了不受支持的语法</entry>
    <entry key="var_read_after_move">变量在转移后读取</entry>
    <entry key="std_string_c_str_compared_to_pointer_default_message">这种与指针的比较可能是不必要的或非预期的。请改用字符串比较。</entry>
    <entry key="std_remove_without_erase_default_message">调用了 std::remove()，但结果未传递给容器的 erase() 方法。未从容器中删除任何条目。</entry>
    <entry key="dangling_string_view_default_message">构造 std::string_view 时使用的是在 string_view 对象之前超出作用域的未命名临时变量。</entry>
    <entry key="pointer_to_temporary_object_default_message">对象在表达式或控制语句结束时销毁。</entry>
    <entry key="var_read_after_move_default_message">读取已转移的变量会导致未定义的行为。</entry>
    <entry key="object_oriented">面向对象</entry>
    <entry key="object_slicing">对象切片</entry>
    <entry key="partial_override">部分覆盖重载的虚拟函数</entry>
    <entry key="virtual_func_hiding">类型不兼容导致无法覆盖</entry>
    <entry key="missing_copy_ctor_call">初始化列表中未调用复制构造函数</entry>
    <entry key="missing_base_assign_op_call">未调用基类赋值运算符</entry>
    <entry key="non_init_member">构造函数中存在未初始化的成员</entry>
    <entry key="dtor_not_virtual">基类析构函数不是虚拟函数</entry>
    <entry key="return_not_ref_to_this">复制赋值运算符中未返回 *this</entry>
    <entry key="missing_member_init_in_list">初始化列表中缺失显式成员初始化</entry>
    <entry key="missing_explicit_keyword">缺失显式关键字</entry>
    <entry key="missing_self_assign_test">未在运算符中测试自赋值</entry>
    <entry key="breaking_data_encapsulation">向封装数据成员返回非常量句柄</entry>
    <entry key="missing_virtual_inheritance">缺失虚拟继承</entry>
    <entry key="dtor_may_throw">析构函数可能抛出异常</entry>
    <entry key="rethrow_out_of_catch">在 catch 块外重新抛出异常</entry>
    <entry key="excp_spec_violation">违反异常设定</entry>
    <entry key="missing_excp_handler_in_main">main 函数中缺失 catch(...)</entry>
    <entry key="copy_modifying_source">修改源操作数的复制运算</entry>
    <entry key="incomplete_class_ptr">转换或删除不完整的类指针</entry>
    <entry key="lambda_type_misuse">Lambda 用作 typeid 操作数</entry>
    <entry key="missing_overload_new_for_aligned_obj">运算符 new 未重载可能过度对齐的类</entry>
    <entry key="memop_on_nontrivial_obj">对非平凡类对象执行字节运算</entry>
    <entry key="cpp_exceptions">C++ 异常</entry>
    <entry key="excp_caught_by_value">按值捕获异常</entry>
    <entry key="excp_handler_hidden">异常处理程序被上一处理程序隐藏</entry>
    <entry key="throw_argument_expression_throws">throw 语句的参数表达式可能引发意外异常</entry>
    <entry key="noexcept_function_throws">Noexcept 函数可能因异常而退出</entry>
    <entry key="throw_expression_calls_new">throw 参数表达式调用 new</entry>
    <entry key="throw_argument_expression_throws_default_message">'throw' 语句的参数表达式可能引发意外异常。</entry>
    <entry key="noexcept_function_throws_default_message">显式标记为 'noexcept' 的函数可能会抛出异常。进而导致意外 std::terminate 的发生。</entry>
    <entry key="uncaught_exception">未捕获异常</entry>
    <entry key="throw_expression_calls_new_default_message">在 throw 表达式中调用 new 会导致无法处理的异常或内存泄漏。</entry>
    <entry key="data_flow">数据流</entry>
    <entry key="useless_write">写入后未被读取</entry>
    <entry key="non_init_var">未初始化的变量</entry>
    <entry key="non_init_ptr">未初始化的指针</entry>
    <entry key="var_shadowing">变量遮蔽</entry>
    <entry key="missing_return">缺失 return 语句</entry>
    <entry key="unreachable">不可达代码</entry>
    <entry key="bad_unreachable">有缺陷的不可达代码</entry>
    <entry key="dead_code">死代码</entry>
    <entry key="useless_if">无用的 if 条件</entry>
    <entry key="partially_access_array">未完整访问的数组</entry>
    <entry key="partially_accessed_array">未完整访问的数组</entry>
    <entry key="uncalled_func">静态未调用函数</entry>
    <entry key="infinite_loop">无限循环</entry>
    <entry key="non_init_ptr_conv">指向未初始化值的指针转换为常量指针</entry>
    <entry key="deactivated_code">因始终为 false 的条件停用的代码</entry>
    <entry key="useless_preproc_condition">无用预处理器条件句指令</entry>
    <entry key="useless_preproc_condition_default_message">无用预处理器条件句指令。</entry>
    <entry key="resource_management">资源管理</entry>
    <entry key="read_only_resource_write">写入只读资源</entry>
    <entry key="closed_resource_use">使用之前已关闭的资源</entry>
    <entry key="double_resource_close">关闭之前已关闭的资源</entry>
    <entry key="double_resource_open">打开之前已打开的资源</entry>
    <entry key="resource_leak">资源泄漏</entry>
    <entry key="resource_access_mode_mismatch">以不同模式打开之前已打开的资源</entry>
    <entry key="concurrency">并发</entry>
    <entry key="deadlock">死锁</entry>
    <entry key="livelock">活锁</entry>
    <entry key="bad_lock">缺失解锁</entry>
    <entry key="bad_unlock">缺失锁</entry>
    <entry key="double_lock">双锁</entry>
    <entry key="double_unlock">双解锁</entry>
    <entry key="destroy_locked">销毁锁定互斥锁</entry>
    <entry key="lock_too_long">锁定时间太长</entry>
    <entry key="race_cond">竞态条件</entry>
    <entry key="data_race">数据争用</entry>
    <entry key="data_race_std_lib">对标准库函数调用的数据争用</entry>
    <entry key="data_race_bit_fields">相邻位字段的数据争用</entry>
    <entry key="data_race_all">包含原子运算的数据争用</entry>
    <entry key="signal_use_in_multithreaded_program">在多线程程序中调用 signal</entry>
    <entry key="thread_killed_with_signal">使用信号终止线程</entry>
    <entry key="blocking_while_locked">保持锁时阻塞运算</entry>
    <entry key="atomic_var_access_twice">在表达式中访问原子变量两次</entry>
    <entry key="atomic_var_sequence_not_atomic">原子加载和存储序列是非原子的</entry>
    <entry key="spurious_wakeup_not_wrapped_in_loop">可虚假唤醒的函数未置于循环中</entry>
    <entry key="spurious_failure_not_wrapped_in_loop">可虚假失败的函数未置于循环中</entry>
    <entry key="thread_mem_leak">线程特有内存泄漏</entry>
    <entry key="undefined_thread_id">使用未定义的线程 ID</entry>
    <entry key="double_join_or_detach">连接已连接的线程或分离已分离的线程</entry>
    <entry key="bad_thread_attribute">线程属性缺失初始化或重复初始化</entry>
    <entry key="signaled_cond_var_not_unique">多个线程等待同一条件变量</entry>
    <entry key="asynchronously_cancellable_thread">可异步取消的线程</entry>
    <entry key="multi_mutex_with_one_cond_var">使用的多个互斥锁基于同一条件变量</entry>
    <entry key="local_addr_escape_thread">自动或线程局部变量逃逸出线程</entry>
    <entry key="security">安全</entry>
    <entry key="path_traversal">易受攻击的路径操作</entry>
    <entry key="missing_sentinel">数组未以空字符终止</entry>
    <entry key="strlib_buffer_overflow_using_source_size">使用源缓冲区大小的目标缓冲区溢出</entry>
    <entry key="delete_sentinel">意外删除空字符使字符串永不终止</entry>
    <entry key="path_excessive_length">路径操作函数无法处理长度大于 MAX_PATH 的路径</entry>
    <entry key="dangerous_std_func">使用危险标准函数</entry>
    <entry key="chroot_misuse">chroot() 之后未调用 chdir("/") 即进行文件操作</entry>
    <entry key="ignored_return_value">敏感例程调用的返回值被忽略</entry>
    <entry key="return_not_checked">未检查敏感函数的返回值</entry>
    <entry key="bad_umask">Umask 与 chmod-style 参数一起使用</entry>
    <entry key="string_format">格式字符串设定符和参数不匹配</entry>
    <entry key="dangerous_permissions">易受攻击的权限分配</entry>
    <entry key="rand_seed_constant">从常量种子得出的确定性随机输出</entry>
    <entry key="rand_seed_predictable">从可预测种子得出的可预测随机输出</entry>
    <entry key="vulnerable_prng">易受攻击的伪随机数生成器</entry>
    <entry key="func_ptr_absolute_addr">分配有绝对地址的函数指针</entry>
    <entry key="single_signal_handler">用单个处理程序处理多个信号可能导致争用条件</entry>
    <entry key="toctou">在检查时间和使用时间之间(TOCTOU)进行文件访问</entry>
    <entry key="relative_path_lib">从相对路径加载库可以被外部执行者所控制</entry>
    <entry key="relative_path_cmd">从相对路径执行二进制文件可以被外部执行者所控制</entry>
    <entry key="non_secure_temp_file">使用不安全的临时文件</entry>
    <entry key="sensitive_stack_not_cleared">堆栈中存在未清除的敏感数据</entry>
    <entry key="sensitive_heap_not_cleared">释放前未清除敏感堆内存</entry>
    <entry key="sensitive_data_export_with_env_var">环境变量或寄存器引起信息泄露</entry>
    <entry key="sensitive_data_print">敏感数据被打印输出</entry>
    <entry key="obsolete_std_func">使用过时的标准函数</entry>
    <entry key="bad_network_connect_order">网络连接操作顺序不正确</entry>
    <entry key="data_length_mismatch">数据长度和大小不匹配</entry>
    <entry key="unsafe_std_func">不安全的标准函数</entry>
    <entry key="unsafe_std_crypt">不安全的标准加密函数</entry>
    <entry key="bad_privilege_drop_order">丢弃特权的顺序错误</entry>
    <entry key="missing_privilege_drop_check">特权丢弃未经验证</entry>
    <entry key="readlink_misuse">误用 readlink()</entry>
    <entry key="errno_not_checked">未检查 errno</entry>
    <entry key="file_exposure_to_child">向子进程暴露文件描述符</entry>
    <entry key="unsafe_system_call">不安全的系统函数调用</entry>
    <entry key="padding_info_leak">结构体填充可能导致信息泄漏</entry>
    <entry key="inappropriate_io_on_device">对设备文件进行不当的 I/O 操作</entry>
    <entry key="hard_coded_sensitive_data">敏感数据被硬编码</entry>
    <entry key="uncertain_memory_cleaning">不确定的内存清理</entry>
    <entry key="dummy_security">使用伪检查项检验基础设施工作</entry>
    <entry key="unsafe_system_call_default_message">对系统函数的调用不安全。</entry>
    <entry key="cryptography">加密</entry>
    <entry key="crypto_no_cleanup">对象尚未清理，敏感数据可能尚未从内存中删除</entry>
    <entry key="crypto_no_free">对象尚未释放，敏感数据可能尚未从内存中删除</entry>
    <entry key="crypto_no_init">算法必须由库加载之后才能使用</entry>
    <entry key="crypto_deprecated">此函数已弃用</entry>
    <entry key="crypto_bad_init">此对象未正确初始化</entry>
    <entry key="crypto_bad_free">此对象已关联到另一个对象，不应直接释放</entry>
    <entry key="crypto_bad_option">给定值与有效选项不匹配</entry>
    <entry key="crypto_md_weak_hash">不安全的哈希算法</entry>
    <entry key="crypto_md_no_algorithm">缺失哈希算法</entry>
    <entry key="crypto_md_bad_function">未正确初始化摘要运算的上下文</entry>
    <entry key="crypto_md_no_data">未向上下文添加数据</entry>
    <entry key="crypto_md_no_final">哈希更新运算后缺失最终步骤</entry>
    <entry key="crypto_md_no_salt">哈希运算缺失加密盐</entry>
    <entry key="crypto_cipher_weak_cipher">弱加密算法</entry>
    <entry key="crypto_cipher_weak_mode">弱加密模式</entry>
    <entry key="crypto_cipher_constant_key">常量加密密钥</entry>
    <entry key="crypto_cipher_constant_iv">常量块加密初始化向量</entry>
    <entry key="crypto_cipher_predictable_key">可预测的加密密钥</entry>
    <entry key="crypto_cipher_predictable_iv">可预测的块加密初始化向量</entry>
    <entry key="crypto_cipher_iv_reuse_on_key_change">使用新密钥后必须立即更改初始化向量</entry>
    <entry key="crypto_cipher_no_salt_in_passwd_hash">在对密码进行哈希处理之前必须先进行 "加盐"，以防止选择明文攻击</entry>
    <entry key="crypto_cipher_bad_function">加密运算不一致</entry>
    <entry key="crypto_cipher_no_algorithm">缺失加密算法</entry>
    <entry key="crypto_cipher_no_key">缺失加密密钥</entry>
    <entry key="crypto_cipher_no_iv">缺失块加密初始化向量</entry>
    <entry key="crypto_cipher_no_data">缺失要处理的加密数据</entry>
    <entry key="crypto_cipher_no_padding">应为此块运算模式设置填充</entry>
    <entry key="crypto_cipher_no_final">缺失加密最终步骤</entry>
    <entry key="crypto_pkey_weak_params">不安全的密钥生成参数</entry>
    <entry key="crypto_rsa_low_exponent">不安全的 RSA 公钥指数</entry>
    <entry key="crypto_pkey_incorrect_key">加密算法的密钥不正确</entry>
    <entry key="crypto_pkey_incorrect_init">加密运算的上下文初始化不正确</entry>
    <entry key="crypto_pkey_no_params">缺失密钥生成参数</entry>
    <entry key="crypto_pkey_no_public_key">缺失公钥</entry>
    <entry key="crypto_pkey_no_private_key">缺失私钥</entry>
    <entry key="crypto_pkey_no_peer">缺失对等密钥</entry>
    <entry key="crypto_pkey_no_data">缺失用于加密、解密或签名运算的数据</entry>
    <entry key="crypto_rsa_weak_padding">对 RSA 算法使用弱填充</entry>
    <entry key="crypto_rsa_bad_padding">对 RSA 算法运算使用不兼容的填充</entry>
    <entry key="crypto_rsa_no_padding">RSA 算法缺失填充</entry>
    <entry key="crypto_rsa_no_blinding">RSA 算法缺失盲化</entry>
    <entry key="crypto_ssl_weak_protocol">不安全的 SSL/TLS 协议</entry>
    <entry key="crypto_ssl_weak_authentication">匿名身份验证无法确保保密性，必须予以避免</entry>
    <entry key="crypto_ssl_weak_cipher_suite">一些建议的加密法太弱</entry>
    <entry key="crypto_ssl_weak_renegociation">原有重新协商已终止，无法再使用</entry>
    <entry key="crypto_ssl_no_role">未设置 TLS/SSL 连接方法</entry>
    <entry key="crypto_ssl_bad_role">TLS/SSL 连接方法设置不正确</entry>
    <entry key="crypto_ssl_no_socket">尚未设置用于通信的套接字</entry>
    <entry key="crypto_ssl_no_private_key">缺失 X.509 证书的私钥</entry>
    <entry key="crypto_ssl_no_certificate">缺失 X.509 证书</entry>
    <entry key="crypto_ssl_hostname_not_checked">未检查服务器证书的通用名</entry>
    <entry key="crypto_ssl_no_cert_check">私钥和证书尚未检查，可能不匹配</entry>
    <entry key="crypto_ssl_no_ca">缺失证书认证中心列表</entry>
    <entry key="crypto_ssl_cert_not_checked">未检查 X.509 对等证书</entry>
    <entry key="tainted_data">被污染的数据</entry>
    <entry key="tainted_hostid">使用外部控制元素进行主机更改</entry>
    <entry key="tainted_env_variable">使用外部控制的环境变量</entry>
    <entry key="tainted_string_format">字符串格式被污染</entry>
    <entry key="tainted_sign_change">符号变化转换被污染</entry>
    <entry key="tainted_loop_boundary">循环界限值被污染</entry>
    <entry key="tainted_memory_alloc_size">内存分配大小被污染</entry>
    <entry key="tainted_path_lib">从外部控制路径加载的库</entry>
    <entry key="tainted_path_cmd">从外部控制路径执行的命令</entry>
    <entry key="tainted_external_cmd">执行外部控制命令</entry>
    <entry key="tainted_vla_size">可变长度数组大小被污染</entry>
    <entry key="tainted_int_mod">模操作数被污染</entry>
    <entry key="tainted_int_division">除法操作数被污染</entry>
    <entry key="tainted_array_index">使用被污染的索引进行数组访问</entry>
    <entry key="tainted_ptr_offset">使用被污染的偏移量进行指针解引用</entry>
    <entry key="tainted_ptr">使用被污染的指针</entry>
    <entry key="tainted_string">受污染的 NULL 或未以空字符终止的字符串</entry>
    <entry key="tainted_source_use_custom">敏感函数使用了污染源</entry>
    <entry key="good_practice">最佳实践</entry>
    <entry key="unused_parameter">未使用的参数</entry>
    <entry key="pass_by_value">按值传递的参数较大</entry>
    <entry key="good_practice_defects">最佳实践</entry>
    <entry key="hard_coded_buffer_size">缓冲区大小被硬编码</entry>
    <entry key="hard_coded_loop_boundary">循环边界被硬编码</entry>
    <entry key="hard_coded_mem_size">用于操作内存的对象大小被硬编码</entry>
    <entry key="setjmp_longjmp_use">使用 setjmp/longjmp</entry>
    <entry key="more_than_one_statement">一行包含多条语句</entry>
    <entry key="delete_of_void_ptr">删除 void 指针</entry>
    <entry key="bitwise_arith_mix">对相同数据混合进行按位和算术运算</entry>
    <entry key="missing_freed_ptr_reset">未对释放的指针进行重置</entry>
    <entry key="missing_switch_break">switch case 缺失 break</entry>
    <entry key="flexible_array_member_incorrect_size">灵活数组成员大小的语法不正确</entry>
    <entry key="most_vexing_parse">声明语法具有多义性</entry>
    <entry key="cv_qualified_reference_type">用 const 或 volatile 限定 C++ 引用类型</entry>
    <entry key="write_reference_to_const_type">由 const 限定类型的 C++ 引用后续被修改</entry>
    <entry key="missing_overload_new_delete_pair">未重载对应的分配或释放函数</entry>
    <entry key="multi_stmt_macro">包含多个语句的宏</entry>
    <entry key="semicolon_terminated_macro">以分号终止的宏</entry>
    <entry key="semicolon_ctrl_stmt_same_line">分号与 if、for 或 while 语句在同一行</entry>
    <entry key="incorrect_indentation">缩进不正确的语句</entry>
    <entry key="sizeof_useless_op">sizeof 操作数中的冗余表达式</entry>
    <entry key="inappropriate_type_in_switch">switch 表达式的数据类型可能不当</entry>
    <entry key="forbidden_func">使用禁止的函数</entry>
    <entry key="forbidden_keyword">使用禁止的 C/C++ 关键字</entry>
    <entry key="forbidden_macro">使用禁止的宏</entry>
    <entry key="unmodified_var_not_const">未用 const 限定值不会被修改的变量</entry>
    <entry key="file_does_not_compile">文件无法编译</entry>
    <entry key="catch_for_generic_exception">捕获通用异常的 catch 声明</entry>
    <entry key="throw_for_generic_exception">抛出通用异常的 throw 声明</entry>
    <entry key="method_not_const">方法不是常量</entry>
    <entry key="public_static_field_not_const">公共静态字段不是常量</entry>
    <entry key="critical_data_member_declared_public">关键数据成员不是私有类</entry>
    <entry key="sql_injection">SQL 注入</entry>
    <entry key="invalid_notation_on_e_constant">无效的科学记数法格式</entry>
    <entry key="useless_include">无用包含</entry>
    <entry key="ldap_injection">LDAP 注入</entry>
    <entry key="plain_text_password_in_filesystem">存储在文件系统中的纯文本密码。</entry>
    <entry key="unused_variable">未使用的变量</entry>
    <entry key="useless_capture">无用的捕获</entry>
    <entry key="resource_injection">资源注入</entry>
    <entry key="unused_variable_default_message">变量在此作用域中未被读取。</entry>
    <entry key="useless_capture_default_message">lambda 中未使用捕获的变量。</entry>
    <entry key="performance">性能</entry>
    <entry key="std_endl_use">std::endl 可能导致不必要的刷新</entry>
    <entry key="empty_destructor_defined">空析构函数可能导致不必要的数据副本</entry>
    <entry key="const_return_value">常量返回值可能导致不必要的数据副本</entry>
    <entry key="const_parameter_value">常量参数值可能导致不必要的数据副本</entry>
    <entry key="inefficient_basic_string_length">字符串长度计算效率低下</entry>
    <entry key="move_operation_may_throw">移动运算可能抛出异常</entry>
    <entry key="expensive_pass_by_value">高成本的按值传递</entry>
    <entry key="expensive_return_by_value">高成本的按值返回</entry>
    <entry key="expensive_range_based_for_loop_iteration">基于范围的 for 循环迭代中的高成本复制</entry>
    <entry key="expensive_std_move_const_object">常量 std::move 输入可能导致更高成本的对象副本</entry>
    <entry key="std_move_unmovable_type">对不可移动类型调用 std::move</entry>
    <entry key="missing_constexpr">缺失 constexpr 设定符</entry>
    <entry key="expensive_constant_std_string">从常量字符串进行高成本的 std::string 或 std::regex 构造</entry>
    <entry key="expensive_c_str_std_string_operation">不必要地使用 std::string::c_str() 或等效的字符串方法</entry>
    <entry key="unnecessary_empty_string_literal">高成本使用 std::string 处理空字符串字面值</entry>
    <entry key="expensive_use_of_std_string_methods">高成本使用 std::string 方法而非更高效的重载</entry>
    <entry key="expensive_std_string_append">高成本使用非成员 std::string operator+() 而非简单的 append 方法</entry>
    <entry key="expensive_std_string_resize">高成本使用 substr() 缩短 std::string</entry>
    <entry key="const_rvalue_reference_parameter">常量 rvalue 引用参数可能导致不必要的数据副本</entry>
    <entry key="expensive_logical_operation">高成本逻辑运算</entry>
    <entry key="expensive_local_variable">高成本局部变量复制</entry>
    <entry key="expensive_container_count">高成本使用容器的 count 方法</entry>
    <entry key="expensive_container_insertion">高成本使用容器的 insertion 方法</entry>
    <entry key="expensive_container_emptiness_check">高成本使用容器的 size 方法</entry>
    <entry key="expensive_map_insert_or_assign">高成本使用 map 的方括号运算符插入值或赋值</entry>
    <entry key="expensive_use_of_std_algorithm">高成本使用标准算法而未采用已有更高效的方法</entry>
    <entry key="expensive_use_of_c_string_api">高成本使用 C 标准库中的字符串函数</entry>
    <entry key="missing_make_shared">使用 new 或 make_unique，而非更高效的 make_shared</entry>
    <entry key="unnecessary_struct_padding">不必要的填充</entry>
    <entry key="inefficient_sprintf">低效使用 sprintf</entry>
    <entry key="expensive_post_increment">高成本后增量运算</entry>
    <entry key="expensive_dynamic_cast">高成本 dynamic_cast</entry>
    <entry key="move_operation_uses_copy">移动运算使用复制</entry>
    <entry key="expensive_return_const_object">高成本返回 const 对象</entry>
    <entry key="prefer_range_based_for_loops">低效使用 for 循环</entry>
    <entry key="expensive_alloc_in_loop">高成本循环分配</entry>
    <entry key="expensive_return_std_move">不必要 std::move 导致高成本返回</entry>
    <entry key="missing_container_reserve">缺失对容器保留方法的调用</entry>
    <entry key="unnecessary_construction_before_assignment">在重新分配前执行不必要的构造</entry>
    <entry key="unnecessary_impl_of_special_member_function">不必要的特殊成员函数实现</entry>
    <entry key="expensive_any_cast">高成本使用 std::any_cast</entry>
    <entry key="expensive_member_initialization">高成本成员初始化</entry>
    <entry key="expensive_pass_by_reference">对参数的不必要引用</entry>
    <entry key="expensive_unused_object">高成本的未使用对象</entry>
    <entry key="expensive_std_function">高成本 std::function 的类型定义</entry>
    <entry key="expensive_use_of_map_instead_of_set">高成本使用 map 而不是使用 set</entry>
    <entry key="expensive_copy_on_last_use">变量的最后一次使用成本高昂</entry>
    <entry key="missing_constexpr_default_message">Constexpr 设定符可用于编译时计算。\n 编译时计算可节省运行时的不必要开销。</entry>
    <entry key="unnecessary_struct_padding_default_message">类或结构体包含不必要的填充。可对成员重新排序以节省内存。</entry>
    <entry key="inefficient_sprintf_default_message">sprintf 的此类使用可替换为更高效的 strcpy。</entry>
    <entry key="expensive_post_increment_default_message">这种后增量运算可替换为更快的前增量运算。</entry>
    <entry key="move_operation_uses_copy_default_message">此成员或基类作为另一类移动运算的一部分进行复制。\n移动此对象可以正确且高效地传输资源。</entry>
    <entry key="prefer_range_based_for_loops_default_message">建议使用基于范围的 for 循环，它更快、更清晰，且不易出错。</entry>
    <entry key="missing_container_reserve_default_message">通过在插入元素之前调用容器的 reserve 方法来预分配内存，可以提高性能。</entry>
    <entry key="expensive_any_cast_default_message">将按值转换(std::any_cast&lt;T&gt;)替换为按引用转换(std::any_cast&lt;const T&amp;&gt;)以提高效率</entry>
    <entry key="expensive_unused_object_default_message">删除构造起来可能成本很高的未使用对象可使您的代码更高效。</entry>
    <entry key="expensive_std_function_default_message">此 std::function 对象的一个或多个参数对复制成本高的对象使用传值语义。</entry>
    <entry key="expensive_use_of_map_instead_of_set_default_message">该键是正在插入的值的成员。使用 std::set 可能比使用 std::map 更加高效。</entry>
    <entry key="expensive_pass_by_reference_default_message">输入参数复制成本低，可以按值传递。</entry>
    <entry key="expensive_copy_on_last_use_default_message">在最后一次使用时移动变量比复制更高效。</entry>
    <entry key="custom_rules">用户定义的自定义规则</entry>
    <entry key="custom_lib">自定义库</entry>
    <entry key="custom_rule_01">自定义规则 1</entry>
    <entry key="custom_rule_02">自定义规则 2</entry>
    <entry key="custom_rule_03">自定义规则 3</entry>
    <entry key="custom_rule_04">自定义规则 4</entry>
    <entry key="custom_rule_05">自定义规则 5</entry>
    <entry key="custom_rule_06">自定义规则 6</entry>
    <entry key="custom_rule_07">自定义规则 7</entry>
    <entry key="custom_rule_08">自定义规则 8</entry>
    <entry key="custom_rule_09">自定义规则 9</entry>
    <entry key="custom_rule_10">自定义规则 10</entry>
    <entry key="custom_rule_11">自定义规则 11</entry>
    <entry key="custom_rule_12">自定义规则 12</entry>
    <entry key="custom_rule_13">自定义规则 13</entry>
    <entry key="custom_rule_14">自定义规则 14</entry>
    <entry key="custom_rule_15">自定义规则 15</entry>
    <entry key="custom_rule_16">自定义规则 16</entry>
    <entry key="custom_rule_17">自定义规则 17</entry>
    <entry key="custom_rule_18">自定义规则 18</entry>
    <entry key="custom_rule_19">自定义规则 19</entry>
    <entry key="custom_rule_20">自定义规则 20</entry>
    <entry key="custom_rule_21">自定义规则 21</entry>
    <entry key="custom_rule_22">自定义规则 22</entry>
    <entry key="custom_rule_23">自定义规则 23</entry>
    <entry key="custom_rule_24">自定义规则 24</entry>
    <entry key="custom_rule_25">自定义规则 25</entry>
    <entry key="custom_rule_26">自定义规则 26</entry>
    <entry key="custom_rule_27">自定义规则 27</entry>
    <entry key="custom_rule_28">自定义规则 28</entry>
    <entry key="custom_rule_29">自定义规则 29</entry>
    <entry key="custom_rule_30">自定义规则 30</entry>
    <entry key="rte">运行时错误</entry>
    <entry key="numerical_checks">数值</entry>
    <entry key="pow">正幂值</entry>
    <entry key="ovfl">溢出</entry>
    <entry key="sovfl">标量溢出</entry>
    <entry key="fovfl">浮点数溢出</entry>
    <entry key="zdv">除以零</entry>
    <entry key="shf">移位运算无效</entry>
    <entry key="uovfl">上溢/下溢</entry>
    <entry key="unfl">下溢</entry>
    <entry key="static_memory_checks">静态内存</entry>
    <entry key="obai">数组索引越界</entry>
    <entry key="idp">非法解引用指针</entry>
    <entry key="abs_addr">使用绝对地址</entry>
    <entry key="data_flow_checks">数据流</entry>
    <entry key="nip">未初始化的指针</entry>
    <entry key="niv">未初始化的变量</entry>
    <entry key="nivl">未初始化的局部变量</entry>
    <entry key="irv">返回值未初始化</entry>
    <entry key="fnc">未调用函数</entry>
    <entry key="fnr">不可达函数</entry>
    <entry key="global_set_at_initialization">全局变量未在初始化代码中赋值</entry>
    <entry key="control_flow_checks">控制流</entry>
    <entry key="ntc">无限调用</entry>
    <entry key="ntl">无限循环</entry>
    <entry key="unr">不可达代码</entry>
    <entry key="k_ntc">已知无限调用</entry>
    <entry key="exc">未捕获异常</entry>
    <entry key="excp">算术异常</entry>
    <entry key="nnt">调用方法的 this 指针为空</entry>
    <entry key="cpp">无效的 C++ 特定运算</entry>
    <entry key="oop">不正确的面向对象编程</entry>
    <entry key="frv">未返回值的函数</entry>
    <entry key="inf">信息检查</entry>
    <entry key="other_checks">其他</entry>
    <entry key="asrt">用户断言</entry>
    <entry key="std_lib">无效的标准库例程使用</entry>
    <entry key="autosar_use">无效的 AUTOSAR 运行时环境函数使用</entry>
    <entry key="autosar_impl">无效的 AUTOSAR 可运行实体实现结果</entry>
    <entry key="autosar_noimpl">未实现的 AUTOSAR 可运行实体</entry>
    <entry key="simulink_design_minmax">模型引用的输入/输出超出指定范围</entry>
    <entry key="ipt">检查点</entry>
    <entry key="cor">正确性判定条件</entry>
    <entry key="precondition">预条件</entry>
    <entry key="postcondition">后条件</entry>
    <entry key="autosar_compliance">不符合 AUTOSAR 规范</entry>
    <entry key="i2c_smbus_compliance">不符合 I2C SMBus 规范</entry>
    <entry key="code_behavior_spec_compliance">不符合代码行为规范</entry>
    <entry key="impact_specifications">影响设定</entry>
    <entry key="expected_impact">预期有影响</entry>
    <entry key="expected_no_impact">预期无影响</entry>
    <entry key="global_variable">全局变量</entry>
    <entry key="shared_global_variable">共享</entry>
    <entry key="unshared_global_variable">未共享</entry>
    <entry key="global_shared_protected_variable">受保护变量</entry>
    <entry key="global_shared_unprotected_variable">潜在不受保护的变量</entry>
    <entry key="global_unshared_variable">使用的非共享变量</entry>
    <entry key="global_unused_variable">未使用的变量</entry>
    <entry key="spec_check">规范检查</entry>
    <entry key="spec_violated">违反设定</entry>
    <entry key="spec_potentially_violated">可能违反设定</entry>
    <entry key="spec_proven">设定经过证明</entry>
    <entry key="spec_impact">影响分析</entry>
    <entry key="may_impact_sink">潜在受影响的汇点</entry>
    <entry key="impact_free_sink">不受影响的汇点</entry>
    <entry key="impact_free_source">不受影响的源点</entry>
    <entry key="spec_impact_couple">影响对</entry>
    <entry key="may_impact_couple">潜在受影响的源点/汇点对</entry>
    <entry key="impact_free_couple">不受影响的源点/汇点对</entry>
    <entry key="spec_potential_impact">潜在影响</entry>
    <entry key="spec_impact_free">不受影响</entry>
    <entry key="code_coverage_checks">代码覆盖率</entry>
    <entry key="function_cov">函数覆盖率</entry>
    <entry key="condition_cov">条件覆盖率</entry>
    <entry key="decision_cov">决策覆盖率</entry>
    <entry key="condition_mcdc">MC/DC 条件贡献</entry>
    <entry key="block_cov">块覆盖率</entry>
    <entry key="stmt_cov">语句覆盖率</entry>
    <entry key="function_exit_cov">函数出口点覆盖率</entry>
    <entry key="project_metrics">工程度量</entry>
    <entry key="file_metrics">文件度量</entry>
    <entry key="function_metrics">函数度量</entry>
    <entry key="name">名称</entry>
    <entry key="files">文件数</entry>
    <entry key="ada_files">文件数</entry>
    <entry key="includes">头文件数</entry>
    <entry key="ap_cg_cycle">递归次数</entry>
    <entry key="ap_cg_direct_cycle">直接递归次数</entry>
    <entry key="total_lines">行数</entry>
    <entry key="lines_without_cmt">无注释行数</entry>
    <entry key="comf">注释密度</entry>
    <entry key="comr">注释比率</entry>
    <entry key="path">路径数</entry>
    <entry key="goto">Goto 语句数</entry>
    <entry key="vg">圈复杂度</entry>
    <entry key="calling">主调函数数量</entry>
    <entry key="calls">被调函数数量</entry>
    <entry key="param">函数参数数量</entry>
    <entry key="stmt">指令数</entry>
    <entry key="level">调用层数</entry>
    <entry key="return">Return 语句数</entry>
    <entry key="vocf">语言范围</entry>
    <entry key="pshv">受保护共享变量数</entry>
    <entry key="unpshv">潜在不受保护的共享变量数</entry>
    <entry key="fco">估计的函数耦合</entry>
    <entry key="fcomf">函数注释密度</entry>
    <entry key="flin">正文行数</entry>
    <entry key="fxln">可执行行数</entry>
    <entry key="ncalls">调用次数</entry>
    <entry key="classes">类数量</entry>
    <entry key="packages">包数量</entry>
    <entry key="packwith">With 语句中的包数量</entry>
    <entry key="ada_lines_without_cmt">无注释行数</entry>
    <entry key="subpwith">With 语句中的子程序数</entry>
    <entry key="local_vars_max">局部变量大小的较高估计值</entry>
    <entry key="local_vars_min">局部变量大小的较低估计值</entry>
    <entry key="local_vars">局部非静态变量数</entry>
    <entry key="local_static_vars">局部静态变量数</entry>
    <entry key="max_stack">最大堆栈使用量</entry>
    <entry key="min_stack">最小堆栈使用量</entry>
    <entry key="prog_max_stack">程序最大堆栈使用量</entry>
    <entry key="prog_min_stack">程序最小堆栈使用量</entry>
    <entry key="fsc">函数压力复杂性</entry>
    <entry key="name_default_message">名称</entry>
    <entry key="fsc_default_message">此度量显示函数的函数压力复杂性。</entry>
    <entry key="func_cast_default_message">Unreliable cast between two different pointer function types.</entry>
    <entry key="ptr_cast_default_message">Unreliable cast between two different pointer types.</entry>
    <entry key="str_format_buffer_overflow_default_message">Buffer out of bound risk without correct precision in the format specifier.</entry>
    <entry key="move_const_object_default_message">The object used in the std::move operation is declared const.\nThe resources in the object will not be transferred to another object.</entry>
    <entry key="incorrect_value_forwarding_default_message">Forwarding value to other functions shall be correctly done</entry>
    <entry key="bad_equal_use_default_message">Use of '=' instead of '==' in a logical expression.</entry>
    <entry key="bad_equal_equal_use_default_message">Use of '==' instead of '=' in a statement.</entry>
    <entry key="decl_mismatch_default_message">Inconsistent multiple declarations of the same identifier.</entry>
    <entry key="bad_float_op_default_message">Floating point equality or inequality statement may be inaccurate.</entry>
    <entry key="operator_precedence_default_message">Probably missing parentheses leading to wrong order of operations.</entry>
    <entry key="ptr_sizeof_mismatch_default_message">Mismatch between pointers and sizeof.</entry>
    <entry key="missing_null_char_default_message">Missing null char at the end of an array of chars because it has been declared with less elements than the initializing string.</entry>
    <entry key="qualifier_mismatch_default_message">Cast between pointer types with different qualifiers.</entry>
    <entry key="overlapping_assign_default_message">Overlapping assignment.</entry>
    <entry key="improper_array_init_default_message">Improper array initialization.</entry>
    <entry key="overlapping_copy_default_message">Copy of overlapping memory.</entry>
    <entry key="bad_int_ptr_cast_default_message">Unsafe conversion between pointer and integer.</entry>
    <entry key="typedef_mismatch_default_message">Inconsistent multiple declarations of the same typedef.</entry>
    <entry key="unprototyped_func_call_default_message">Call through non-prototyped function pointer.</entry>
    <entry key="flexible_array_member_struct_misuse_default_message">Misuse of structure with flexible array member.</entry>
    <entry key="unnamed_namespace_in_header_default_message">Unnamed namespace in header file.</entry>
    <entry key="return_not_ref_to_this_default_message">Assignment operator does not return a reference to *this.</entry>
    <entry key="object_slicing_default_message">Slicing on pass-by-value and class hierarchies.</entry>
    <entry key="dtor_not_virtual_default_message">Potential leaking problem if this class is expected to behave polymorphically on derived class objects deletion.</entry>
    <entry key="partial_override_default_message">Overloaded virtual function is only partially overridden.</entry>
    <entry key="missing_self_assign_test_default_message">Handle assignment to self in operator=. Leak and unneeded copies may be avoided.</entry>
    <entry key="breaking_data_encapsulation_default_message">Avoid returning handles to object internals. A client referring to an object of this class and calling this method may modify the associated object contents.</entry>
    <entry key="missing_copy_ctor_call_default_message">Not all subobjects and/or members are copied in initialization list.</entry>
    <entry key="missing_base_assign_op_call_default_message">Missing calls to copy assignment for base subobjects.</entry>
    <entry key="missing_virtual_inheritance_default_message">An accessible base class is both virtual and non-virtual in the same hierarchy.</entry>
    <entry key="missing_member_init_in_list_default_message">Missing (explicit) member initialization in list.</entry>
    <entry key="virtual_func_hiding_default_message">Hiding of virtual function results from failed override attempt.</entry>
    <entry key="missing_explicit_keyword_default_message">Missing keyword "explicit" in constructor, candidate for use in implicit conversions (from first argument type).</entry>
    <entry key="excp_caught_by_value_default_message">Exception is caught by value instead of reference (recommended) or pointer.</entry>
    <entry key="excp_handler_hidden_default_message">Handler hidden by previous handler. It will never be executed.</entry>
    <entry key="var_shadowing_default_message">A variable declared in an inner scope hides a variable with the same name declared in an outer scope.</entry>
    <entry key="missing_return_default_message">Exit path of the function without return statement or return value.</entry>
    <entry key="uncalled_func_default_message">Static function not called.</entry>
    <entry key="deactivated_code_default_message">Branch deactivated.</entry>
    <entry key="string_format_default_message">Mismatch between the specifiers and the arguments of a format string.</entry>
    <entry key="func_ptr_absolute_addr_default_message">Function pointer assigned with absolute address.</entry>
    <entry key="local_ref_to_unnamed_temporary">Reference to un-named temporary.</entry>
    <entry key="pass_by_value_default_message">The size of the passed-by-value parameter object is too large.</entry>
    <entry key="missing_switch_break_default_message">Missing break of switch case.</entry>
    <entry key="more_than_one_statement_default_message">Line with more than one statement.</entry>
    <entry key="hard_coded_buffer_size_default_message">Hard-coded buffer size.</entry>
    <entry key="hard_coded_loop_boundary_default_message">Hard-coded loop boundary.</entry>
    <entry key="unused_parameter_default_message">Unused parameter.</entry>
    <entry key="delete_of_void_ptr_default_message">Deleting void pointer may result in undefined behavior.</entry>
    <entry key="bitwise_arith_mix_default_message">Bitwise and arithmetic operations on the same data.</entry>
    <entry key="missing_freed_ptr_reset_default_message">Missing reset of freed pointer.</entry>
    <entry key="inappropriate_type_in_switch_default_message">The switch expression has a data type other than char, short, int or enum.</entry>
    <entry key="method_not_const_default_message">This non-const method does not modify any state, and should be marked const.</entry>
    <entry key="invalid_notation_on_e_constant_default_message">Constant format does not match expected format of one non-zero digit to the left of the decimal.</entry>
    <entry key="useless_include_default_message">There shall be no unused include directives.</entry>
    <entry key="local_ref_to_unnamed_temporary_default_message">An unnamed temporary object that is returned by value is captured in a reference, perhaps unintentionally.</entry>
    <entry key="std_endl_use_default_message">Calling std::endl implicitly flushes the IOStream.\nThis flush may be expensive, and may be unintended.</entry>
    <entry key="empty_destructor_defined_default_message">User declared destructors prevent auto-generated move constructors and move assignment operators.\nThis absence may cause a more expensive copy.</entry>
    <entry key="const_return_value_default_message">Const return values cannot be moved by the calling function.\nThis restriction may cause a more expensive copy.</entry>
    <entry key="const_parameter_value_default_message">Const parameter values cannot be moved by the called function.\nThis restriction may cause a more expensive copy.</entry>
    <entry key="inefficient_basic_string_length_default_message">std::string::length() is more efficient than passing c_str to other string length functions.</entry>
    <entry key="move_operation_may_throw_default_message">Throwing move operations are unexpected, and STL containers may use the copy operations instead.</entry>
    <entry key="expensive_pass_by_value_default_message">This input parameter can be passed by const pointer/reference.\nThis change avoids a copy for each call.</entry>
    <entry key="expensive_return_by_value_default_message">This output can be returned by pointer/reference.\nThis change avoids a copy for each call.</entry>
    <entry key="expensive_range_based_for_loop_iteration_default_message">This range-based for loop variable can be a const reference.\nThis change avoids a copy for each iteration.</entry>
    <entry key="expensive_std_move_const_object_default_message">Const std::move input cannot be moved.\nThis restriction may cause a more expensive copy.</entry>
    <entry key="std_move_unmovable_type_default_message">Both the move constructor and move assignment operator are not declared for this type.</entry>
    <entry key="expensive_constant_std_string_default_message">A std::string is reconstructed from constant data on every block execution.\nThis can be expensive.</entry>
    <entry key="expensive_c_str_std_string_operation_default_message">The output of std::string::c_str(), std::string::data(), std::string::operator[](), or std::string::at() is passed to a function when directly passing the string would have been more efficient.</entry>
    <entry key="unnecessary_empty_string_literal_default_message">A std::string is constructed from, assigned from, or compared to an empty string literal.\nThere are more efficient alternatives.</entry>
    <entry key="expensive_use_of_std_string_methods_default_message">A std::string method is called with a double-quoted string literal parameter.\n A single-quoted character can be used instead.</entry>
    <entry key="expensive_std_string_append_default_message">The non-member std::string operator+() function is called when the append (or +=) method would have been more efficient.</entry>
    <entry key="expensive_std_string_resize_default_message">std::string::substr() is called when calling std::string::resize() is more efficient.</entry>
    <entry key="const_rvalue_reference_parameter_default_message">Const rvalue reference parameter cannot be moved.\nThis restriction may cause a more expensive copy.</entry>
    <entry key="expensive_logical_operation_default_message">This logical operation may be ordered sub-optimally.\nIf the right operand can be safely evaluated before the left operand, reorder operands to improve performance.</entry>
    <entry key="expensive_local_variable_default_message">This unmodified local variable can be a const reference.\nThis change avoids a more expensive object copy.</entry>
    <entry key="expensive_container_count_default_message">Do not use count() method to check if element exists in container. Use the less expensive find() method instead.</entry>
    <entry key="expensive_container_emptiness_check_default_message">Do not use the container's size() method to check for emptiness. Use its empty() method instead.</entry>
    <entry key="expensive_map_insert_or_assign_default_message">The [] operator is less efficient than the map's insert_or_assign() method.</entry>
    <entry key="expensive_use_of_std_algorithm_default_message">A standard algorithm was called with iterators from a container that has a more efficient method.</entry>
    <entry key="missing_make_shared_default_message">Using 'new' to initialize a shared_ptr is more expensive than using make_shared.</entry>
    <entry key="cpp_checks">C++</entry>
    <entry key="decision_mcdc">MC/DC</entry>
    <entry key="files_default_message">This metric shows the number of source files considered for analysis.</entry>
    <entry key="ada_files_default_message">This metric shows the number of files.</entry>
    <entry key="includes_default_message">This metric shows the number of header files considered for analysis.</entry>
    <entry key="ap_cg_cycle_default_message">This metric shows the number of recursions, both direct and indirect.</entry>
    <entry key="ap_cg_direct_cycle_default_message">This metric shows the number of instances of a function calling itself directly.</entry>
    <entry key="total_lines_default_message">This metric shows the total number of lines in a file.</entry>
    <entry key="lines_without_cmt_default_message">This metric shows the total number of lines in a file excluding comment-only lines and blank lines.</entry>
    <entry key="comf_default_message">This metric shows the ratio of number of comments to number of statements, expressed as a percentage.</entry>
    <entry key="comr_default_message">This metric shows the ratio of number of comment lines to number of code lines, expressed as a percentage.</entry>
    <entry key="path_default_message">This metric shows the number of paths through a function.</entry>
    <entry key="goto_default_message">This metric shows the number of goto statements in a function.</entry>
    <entry key="vg_default_message">This metric shows the cyclomatic complexity of a function.</entry>
    <entry key="calling_default_message">This metric shows the number of distinct callers of a function.</entry>
    <entry key="calls_default_message">This metric shows the number of callees of a function.</entry>
    <entry key="param_default_message">This metric shows the number of arguments of a function.</entry>
    <entry key="stmt_default_message">This metric shows the number of instructions in a function body.</entry>
    <entry key="level_default_message">This metric shows the maximum depth of nesting of control flow structures in a function.</entry>
    <entry key="return_default_message">This metric measures the number of return statements in a function.</entry>
    <entry key="vocf_default_message">This metric estimates the cost of maintaining or changing a function.</entry>
    <entry key="pshv_default_message">This metric shows the number of shared variables protected from concurrent access.</entry>
    <entry key="unpshv_default_message">This metric shows the number of shared variables not protected from concurrent access.</entry>
    <entry key="fco_default_message">This metric is calculated as: Number of call occurrences - Number of function definitions + 1.</entry>
    <entry key="fcomf_default_message">This metric shows the ratio of number of comments to number of statements per function, expressed as a percentage.</entry>
    <entry key="flin_default_message">This metric shows the number of lines in a function body.</entry>
    <entry key="fxln_default_message">This metric shows the number of executable lines in a function body.</entry>
    <entry key="ncalls_default_message">This metric shows the number of calls in a function body.</entry>
    <entry key="classes_default_message">This metric shows the number of classes.</entry>
    <entry key="packages_default_message">This metric shows the number of packages.</entry>
    <entry key="packwith_default_message">This metric shows the number of packages in with statements.</entry>
    <entry key="ada_lines_without_cmt_default_message">This metric shows the number of lines without comment.</entry>
    <entry key="subpwith_default_message">This metric shows the number of subprograms in with statements.</entry>
    <entry key="local_vars_max_default_message">This metric shows the total size of all local variables in a function.</entry>
    <entry key="local_vars_min_default_message">This metric shows the total size of local variables in a function taking nested scopes into account.</entry>
    <entry key="local_vars_default_message">This metric shows the number of local non-static variables in a function.</entry>
    <entry key="local_static_vars_default_message">This metric shows the total number of local static variables in a function.</entry>
    <entry key="max_stack_default_message">This metric shows the total size of all local variables in a function plus the maximum stack usage from its callees (called functions).</entry>
    <entry key="min_stack_default_message">This metric shows the total size of all local variables in a function plus the minimum stack usage from its callees (called functions). This metric takes nested scopes into account when determining local variable size.</entry>
    <entry key="prog_max_stack_default_message">This metric shows the maximum stack usage in the analyzed program.</entry>
    <entry key="prog_min_stack_default_message">This metric shows the minimum stack usage in the analyzed program, taking nested scopes into account.</entry>
    <entry key="classification_unbounded_input">This check may be an issue related to unbounded input values\n</entry>
    <entry key="classification_bounded_input">This check may be an issue related to bounded input values\n</entry>
    <entry key="classification_path_related">This check may be a path-related issue, which is not dependent on input values\n</entry>
    <entry key="classification_safe_input_values">The function's known input values will not cause a defect.</entry>
    <entry key="classification_unreachable">This defect is unreachable given the function's known input values.</entry>
    <entry key="purple_box">This is bad.</entry>
  </message>
</rsccat>
