<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2024 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="zh_CN" product="polyspace" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="not_available_with_c_cpp_title">不适用于 C/C++ 语言</entry>
    <entry key="ComputingSettings_node">分布式计算</entry>
    <entry key="ComputingSettings_title">分布式计算</entry>
    <entry key="MergedComputingSettings_node">运行设置</entry>
    <entry key="MergedComputingSettings_title">运行设置</entry>
    <entry key="distributed_settings_section">分布式计算</entry>
    <entry key="bugfinder_run_settings_section">分析模式</entry>
    <entry key="extra_settings_section">其他 Polyspace 选项</entry>
    <entry key="_batch">批量</entry>
    <entry key="_add_to_results_repository">添加至结果存储库</entry>
    <entry key="__batch_bug_finder">在远程集群上运行 Bug Finder 分析</entry>
    <entry key="__batch_bug_finder_help">将分析发送到您在 "预设项" 中指定的集群。&lt;BR&gt;产品选项 -batch。</entry>
    <entry key="__batch_code_prover">在远程集群上运行 Code Prover 分析</entry>
    <entry key="__batch_code_prover_help">将分析发送到您在 "预设项" 中指定的集群。&lt;BR&gt;产品选项 -batch。</entry>
    <entry key="_batch_help">使用批处理命令在 Polyspace 集群上运行 Polyspace。&lt;BR&gt;(需要 Parallel Computing Toolbox)</entry>
    <entry key="_add_to_results_repository_help">将 Polyspace 结果存储在存储库中，并支持基于 Web 的代码度量和结果报告。</entry>
    <entry key="_fast_analysis">Bug Finder 使用快速分析模式</entry>
    <entry key="_fast_analysis_help">在快速分析模式下运行 Bug Finder 分析。只分析已修改的文件。&lt;BR&gt;注意: 快速分析模式只检查一部分 Bug Finder 缺陷和编码规则。</entry>
    <entry key="language_section">目标语言</entry>
    <entry key="_lang">源代码语言</entry>
    <entry key="TargetCompiler_node">目标和编译器</entry>
    <entry key="TargetCompiler_title">目标和编译器</entry>
    <entry key="target_environment_section">目标环境</entry>
    <entry key="compiler_behavior_section">编译器行为</entry>
    <entry key="_target">目标处理器类型</entry>
    <entry key="_compiler">编译器</entry>
    <entry key="_sfr_types">sfr 类型支持</entry>
    <entry key="_sfr_types_column_1">名称</entry>
    <entry key="_sfr_types_column_2">大小</entry>
    <entry key="_c_version">C 标准版本</entry>
    <entry key="_cpp_version">C++ 标准版本</entry>
    <entry key="_no_uliterals">禁止 char16/32_t 类型</entry>
    <entry key="_pack_alignment_value">包对齐值</entry>
    <entry key="_ignore_pragma_pack">忽略 pragma 包指令</entry>
    <entry key="_div_round_down">除法向下舍入</entry>
    <entry key="_enum_type_definition">枚举类型定义</entry>
    <entry key="_logical_signed_right_shift">有符号数右移位</entry>
    <entry key="_for_loop_index_scope">管理 'for loop' 索引作用域 </entry>
    <entry key="_wchar_t_is">管理 wchar_t</entry>
    <entry key="_wchar_t_is_unsigned_long">将 wchar_t 设置为 unsigned long</entry>
    <entry key="_wchar_t_type_is">管理 wchar_t</entry>
    <entry key="_size_t_is_unsigned_long">将 size_t 设置为 unsigned long</entry>
    <entry key="_size_t_type_is">管理 size_t</entry>
    <entry key="_target_help">选择目标机器的处理器类型。</entry>
    <entry key="_compiler_help">指定所使用的 C/C++ 编译器。分析会识别特定于该编译器的 C/C++ 语言扩展。</entry>
    <entry key="_lang_help">指定工程的源代码语言:&lt;BR&gt;&lt;li&gt; C 表示 C 源代码&lt;BR&gt;&lt;li&gt; CPP 表示 C++ 源代码&lt;BR&gt;&lt;li&gt; C-CPP 表示 C/C++ 混合源代码(仅在 Bug Finder 中可用)</entry>
    <entry key="_sfr_types_help">此选项允许支持给定的 &lt;i&gt;sfr&lt;/i&gt; 类型列表。如果列表为空，则不允许使用任何 &lt;i&gt;sfr&lt;/i&gt; 类型。&lt;BR&gt;一个名称只能指定一次。大小必须为 8、16 或 32。</entry>
    <entry key="_c_version_help">选择要使用的 C 标准版本。</entry>
    <entry key="_cpp_version_help">选择要使用的 C++ 标准版本。</entry>
    <entry key="_no_uliterals_help">不允许使用 char16_t 和 char32_t 类型。</entry>
    <entry key="_pack_alignment_value_help">将包对齐值传递给 Polyspace。</entry>
    <entry key="_ignore_pragma_pack_help">选择忽略 pragma 包指令。</entry>
    <entry key="_div_round_down_help">对负数的取模和除法运算进行向下舍入。&lt;BR&gt;&lt;BR&gt;如果不设置此选项，则 -5/3 的值为 -1。&lt;BR&gt;除法向下舍入意味着 -5/3 的值为 -2。</entry>
    <entry key="_enum_type_definition_help">指定枚举类型的表示方式:&lt;BR&gt;&lt;li&gt;'defined-by-compiler' - 整数(除在 gnu 方言中以外，可保存以下列表中所有枚举值的首选类型: signed int、unsigned int、signed long、&lt;BR&gt;unsigned long、signed long long、unsigned long long)。&lt;BR&gt;&lt;li&gt;'auto-signed-first' - 可保存以下列表中所有枚举值的首选类型: signed char、unsigned char、signed short、unsigned short、&lt;BR&gt;signed int、unsigned int、signed long、unsigned long、signed long long、unsigned long long。&lt;BR&gt;&lt;li&gt;'auto-unsigned-first' - 可保存以下列表中所有枚举值的首选类型:&lt;BR&gt;* 如果枚举值为正值: unsigned char、unsigned short、unsigned int、unsigned long、unsigned long long。&lt;BR&gt;* 如果一个或多个枚举值为负值: signed char、signed short、signed int、signed long、signed long long。</entry>
    <entry key="_logical_signed_right_shift_help">在算术计算和逻辑计算之间进行选择:&lt;UL&gt;&lt;li&gt;算数计算: 符号位保留不变:&lt;BR&gt;(-4) &gt;&gt; 1 = -2&lt;BR&gt;(-7) &gt;&gt; 1 = -4&lt;BR&gt;7 &gt;&gt; 1 = 3&lt;BR&gt;&lt;li&gt;逻辑计算: 0 替换符号位&lt;BR&gt;(-4) &gt;&gt; 1 = (-4U) &gt;&gt; 1 = 2147483646&lt;BR&gt;(-7) &gt;&gt; 1 = (-7U) &gt;&gt; 1 = 2147483644&lt;BR&gt;7 &gt;&gt; 1 = 3&lt;BR&gt;&lt;/ul&gt;</entry>
    <entry key="_for_loop_index_scope_help">更改在 for 循环中声明的索引变量的作用域。&lt;BR&gt;例如: for (int index=0; ...)'{''}' index++; //此时，索引变量可用(out)或不可用(in)&lt;BR&gt;&lt;BR&gt;可能的值为 'defined-by-dialect'、'in' 和 'out':&lt;ul&gt;&lt;li&gt;'defined-by-dialect' 是所选方言的默认行为(见下文)。&lt;BR&gt;&lt;li&gt;'out' 是方言选项 visual6、visual7 和 visual 7.1 的默认值。&lt;BR&gt;&lt;li&gt;'in' 是所有其他方言(包括 visual8 及更高版本)的默认值。&lt;/li&gt;C++ 标准将索引视为 'in'。&lt;/ul&gt;此选项允许覆盖 Polyspace 方言选项隐含的默认行为。&lt;BR&gt;此选项等效于 Visual C++ 选项 /Zc:forScope 和 Zc:forScope-。</entry>
    <entry key="_wchar_t_is_help">强制按照 C++ 标准将 wchar_t 视为关键字处理，或按照 Microsoft Visual C++ 6/7 方言将 wchar_t 视为 typedef 处理。&lt;BR&gt;&lt;BR&gt;可能的值为 'defined-by-dialect'、'typedef' 和 'keyword': &lt;ul&gt;&lt;li&gt;'defined-by-dialect' 是所选方言的默认行为(见下文)。&lt;BR&gt;&lt;li&gt;'typedef' 是方言选项 visual6、visual7 和 visual 7.1 的默认行为。&lt;BR&gt;&lt;li&gt;'keyword' 是所有其他方言(包括 visual8 及更高版本)的默认行为。&lt;/ul&gt;此选项允许覆盖 Polyspace 方言选项隐含的默认行为。&lt;BR&gt;此选项等效于 Visual C++ 选项 /Zc:wchar 和 /Zc:wchar-。</entry>
    <entry key="_wchar_t_is_unsigned_long_help">将 wchar_t 的基础类型设置为 unsigned long，无论它是 typedef 还是关键字(默认为 unsigned short)。</entry>
    <entry key="_wchar_t_type_is_help">将 wchar_t 的基础类型设置为相应类型。</entry>
    <entry key="_size_t_is_unsigned_long_help">将 size_t 的预期类型设置为 unsigned long(默认为 unsigned int)。</entry>
    <entry key="_size_t_type_is_help">将 size_t 的预期类型设置为相应类型。</entry>
    <entry key="Macros_node">宏</entry>
    <entry key="Macros_title">预处理器宏</entry>
    <entry key="_D">预处理器定义</entry>
    <entry key="_D_column_1">宏</entry>
    <entry key="_U">已禁用的预处理器定义</entry>
    <entry key="_U_column_1">宏</entry>
    <entry key="_D_help">指定预处理符号</entry>
    <entry key="_U_help">指定要禁用的预处理器定义</entry>
    <entry key="EnvironmentSettings_node">环境设置</entry>
    <entry key="EnvironmentSettings_title">环境设置</entry>
    <entry key="_sources_encoding">源代码编码</entry>
    <entry key="_dos">代码来自 DOS 或 Windows 文件系统</entry>
    <entry key="_stop_if_compile_error">如果文件无法编译，则停止分析</entry>
    <entry key="_no_extern_C">忽略链接错误</entry>
    <entry key="_post_preprocessing_command">要应用于预处理文件的命令/脚本</entry>
    <entry key="_I">包含文件夹</entry>
    <entry key="_I_column_1">文件夹</entry>
    <entry key="_include">包含</entry>
    <entry key="_include_column_1">文件</entry>
    <entry key="_sources_encoding_help">指定分析过程用于解释源代码中非 ASCII 字符的编码。&lt;BR&gt;如果由于特殊字符导致代码无法编译或在 UI 中呈现不正确，请使用此选项。&lt;BR&gt;有关如何启用其他编码的信息，请点击 '?'。</entry>
    <entry key="_dos_help">当代码来自 &lt;B&gt;DOS 或 Windows&lt;/B&gt; 文件系统时，使用此选项。&lt;BR&gt;此选项有助于解决大小写和控制字符问题。</entry>
    <entry key="_stop_if_compile_error_help">使用此选项以便解决所有编译错误，并确保分析所有文件。&lt;BR&gt;默认情况下，系统不会分析具有编译错误的文件。系统会对这些文件中的函数插桩，以便执行其余分析。</entry>
    <entry key="_no_extern_C_help">同时支持 C 链接和 C++ 链接。</entry>
    <entry key="_post_preprocessing_command_help">在预处理阶段之后，对每个源文件运行给定的命令。&lt;BR&gt;&lt;BR&gt;指定命令文件的绝对路径和文件名非常重要。&lt;BR&gt;此命令应设计为从其标准输入读取，并将其结果输出到标准输出。</entry>
    <entry key="_I_help">包含文件夹</entry>
    <entry key="_include_help">指定要在编译期间自动包含的文件。&lt;BR&gt;在处理任何 &lt;i&gt;#includes&lt;/i&gt; 语句之前，这些文件将包含在每个 C/C++ 文件中。</entry>
    <entry key="Multitasking_node">多任务</entry>
    <entry key="Multitasking_title">多任务</entry>
    <entry key="automatic_concurrency_section">自动配置</entry>
    <entry key="manual_multitasking_section">手动配置</entry>
    <entry key="_osek_multitasking">OIL 文件选择</entry>
    <entry key="_osek_multitasking_column_1">文件</entry>
    <entry key="_autosar_multitasking">ARXML 文件选择</entry>
    <entry key="_autosar_multitasking_column_1">文件</entry>
    <entry key="_enable_concurrency_detection">为 Code Prover 启用自动并发检测</entry>
    <entry key="_disable_concurrency_detection">禁用自动并发检测</entry>
    <entry key="__multitasking">手动配置多任务</entry>
    <entry key="__external_multitasking">外部多任务配置</entry>
    <entry key="_entry_points">任务</entry>
    <entry key="_entry_points_column_1">任务</entry>
    <entry key="_cyclic_tasks">周期任务</entry>
    <entry key="_cyclic_tasks_column_1">任务</entry>
    <entry key="_interrupts">中断</entry>
    <entry key="_interrupts_column_1">中断服务例程</entry>
    <entry key="_routine_disable_interrupts">禁用所有中断</entry>
    <entry key="_routine_enable_interrupts">禁用所有中断(第二列)</entry>
    <entry key="_routine_disable_interrupts_column_1">禁用例程</entry>
    <entry key="_routine_disable_interrupts_column_2">启用例程</entry>
    <entry key="_critical_section_begin">临界区详细信息</entry>
    <entry key="_critical_section_end">临界区详细信息(第二列)</entry>
    <entry key="_critical_section_begin_column_1">起始例程</entry>
    <entry key="_critical_section_begin_column_2">结束例程</entry>
    <entry key="_temporal_exclusions_file">时序互斥任务</entry>
    <entry key="_temporal_exclusions_file_column_1">任务</entry>
    <entry key="_enable_concurrency_detection_help">自动识别某些并发原语，如 pthread_create。&lt;BR&gt; &lt;ul&gt; &lt;li&gt;Code Prover: 此选项用于包含并发原语的多任务应用程序。&lt;br&gt;您的应用程序必须具有 ‘main’ 函数。&lt;li&gt;Bug Finder: 此选项不是必需的。Bug Finder 默认识别并发原语。&lt;/ul&gt;点击 '更多帮助' 查看可检测的原语列表。</entry>
    <entry key="_disable_concurrency_detection_help">禁用某些并发原语的自动检测。&lt;BR&gt;点击 '更多帮助' 查看可检测的原语列表。</entry>
    <entry key="__multitasking_help">验证多任务处理代码。</entry>
    <entry key="__external_multitasking_help">从外部文件指定多任务配置。&lt;ul&gt;&lt;li&gt;osek: 基于 OSEK OIL 文件的多任务描述。&lt;/li&gt;&lt;li&gt;autosar: 基于 AUTOSAR ARXML 文件的多任务描述。&lt;/li&gt;&lt;/ul&gt;</entry>
    <entry key="_osek_multitasking_help">指定包含 OSEK 多任务配置描述的 OIL 文件列表。 &lt;ul&gt;&lt;li&gt;自动: Polyspace 将在包含源文件或头文件的文件夹中查找 OIL 文件。&lt;/li&gt; &lt;li&gt;自定义: 指定 OIL 文件或包含 OIL 文件的文件夹。Polyspace 将在给定文件夹和子文件夹中查找 OIL 文件。&lt;/li&gt;&lt;/ul&gt;
    </entry>
    <entry key="_autosar_multitasking_help">指定包含 AUTOSAR 多任务配置描述的 ARXML 文件列表。
    </entry>
    <entry key="_entry_points_help">指定要分析的任务列表。这些入口函数不得使用参数。&lt;BR&gt;如果任务入口函数是带参数的函数，则可以将其&lt;BR&gt;封装在不带参数的函数中，并通过全局变量传递参数。</entry>
    <entry key="_cyclic_tasks_help">指定要分析的周期任务列表。这些任务不得使用参数。&lt;BR&gt;如果任务是带参数的函数，则可以将其&lt;BR&gt;封装在不带参数的函数中，并通过全局变量传递参数。</entry>
    <entry key="_interrupts_help">指定系统中的中断列表。中断是无法抢占的周期任务。</entry>
    <entry key="_critical_section_begin_help">指定作为临界区起点和终点的例程的列表。每个临界区都有起点和终点。&lt;BR&gt;当您要模拟对共享资源的保护时，请使用这些临界区。</entry>
    <entry key="_routine_disable_interrupts_help">输入为 Bug Finder 分析启用和禁用中断的例程。&lt;BR&gt;&lt;ul&gt; &lt;li&gt;调用禁用例程可防止某一任务被其他任务和中断抢占。&lt;li&gt;调用启用例程可重新允许其他任务和中断抢占某一任务(如果之前被禁用)。&lt;/ul&gt;</entry>
    <entry key="_temporal_exclusions_file_help">指定一系列永远不会同时执行的入口函数。</entry>
    <entry key="CodingStandards_node">编码标准和代码度量</entry>
    <entry key="CodingStandards_title">编码标准和代码度量</entry>
    <entry key="coding_standards_section">编码标准</entry>
    <entry key="__checkers_selection_file">使用文件设置检查项</entry>
    <entry key="__checkers_selection_file_help">检查代码是否符合文件中定义的所选检查。</entry>
    <entry key="_checkers_selection_file_help">检查代码是否符合文件中定义的所选检查。</entry>
    <entry key="__cert_c">检查 SEI CERT-C</entry>
    <entry key="__cert_c_help">检查代码是否符合 CERT-C 标准。</entry>
    <entry key="_cert_c_help">检查代码是否符合 CERT-C 标准。</entry>
    <entry key="__cert_cpp">检查 SEI CERT-C++</entry>
    <entry key="__cert_cpp_help">检查代码是否符合 CERT-C++ 标准。</entry>
    <entry key="_cert_cpp_help">检查代码是否符合 CERT-C++ 标准。</entry>
    <entry key="__iso_17961">检查 ISO/IEC TS 17961</entry>
    <entry key="__iso_17961_help">检查代码是否符合 ISO-17961 标准。</entry>
    <entry key="_iso_17961_help">检查代码是否符合 ISO-17961 标准。</entry>
    <entry key="__autosar_cpp14">检查 AUTOSAR C++14</entry>
    <entry key="__autosar_cpp14_help">检查代码是否符合 AUTOSAR C++14 标准。</entry>
    <entry key="_autosar_cpp14_help">检查代码是否符合 AUTOSAR C++14 标准。</entry>
    <entry key="__guidelines">检查 Guidelines</entry>
    <entry key="__guidelines_help">检查代码是否符合编码规范。</entry>
    <entry key="_guidelines_help">检查代码是否符合编码规范。</entry>
    <entry key="__cwe">检查 CWE</entry>
    <entry key="_cwe_help">检查代码是否符合 CWE 标准。&lt;BR&gt;cwe-658-659 可激活适用于以 C 语言(CWE-658)或 C++ (CWE-659)编写的软件中发现的弱点的规则子集。</entry>
    <entry key="__cwe_help">检查代码是否符合 CWE 标准。&lt;BR&gt;cwe-658-659 可激活适用于以 C 语言(CWE-658)或 C++ (CWE-659)编写的软件中发现的弱点的规则子集。</entry>
    <entry key="coding_standard_dialog_title">检查项选择</entry>
    <entry key="cannot_open_coding_stantard_selection_file">无法打开编码标准选择文件: {0}。&lt;BR&gt;确保所选文件是有效的 Polyspace 编码标准选择文件。</entry>
    <entry key="cannot_open_coding_stantard_selection_file_version">无法打开编码标准选择文件: {0}。&lt;BR&gt;此文件只能使用 Polyspace as You Code 功能打开。</entry>
    <entry key="backup_coding_stantard_selection_file">编码标准选择文件 {0} 已&lt;BR&gt;转换为新的文件格式。&lt;BR&gt;&lt;BR&gt;点击此处可获得以前的文件的备份: &lt;BR&gt;{1} </entry>
    <entry key="coding_stantard_selection_file_already_exists">编码标准选择文件 {0} 已存在。</entry>
    <entry key="coding_stantard_selection_file_filter">编码标准配置文件(*{0})</entry>
    <entry key="given_file_does_not_exist">选项 {1} 的指定文件 {0} 不存在。</entry>
    <entry key="should_import_selection_file">文件 {0} 是使用旧版本的 Polyspace 创建的。\n\n点击 "导入" 以将您的检查项选择迁移到此版本的 Polyspace。</entry>
    <entry key="invalid_pschk_file">无效的 pschk 文件: {0}。\n请使用 polyspace-catalog-bundler 命令生成有效文件。</entry>
    <entry key="CodingRulesCodeMetrics_node">编码规则和代码度量</entry>
    <entry key="CodingRulesCodeMetrics_title">编码规则和代码度量</entry>
    <entry key="coding_rules_section">编码规则</entry>
    <entry key="code_metrics_section">代码度量</entry>
    <entry key="__misra_cpp">检查 MISRA C++:2008</entry>
    <entry key="__jsf_coding_rules">检查 JSF AV C++</entry>
    <entry key="__misra2">检查 MISRA C:2004</entry>
    <entry key="__misra_ac_agc">检查 MISRA AC AGC</entry>
    <entry key="__misra3">检查 MISRA C:2012</entry>
    <entry key="_misra3_agc_mode">使用生成代码的要求</entry>
    <entry key="__misra_c_2023">检查 MISRA C:2023</entry>
    <entry key="_misra_c_2023_agc_mode">使用生成代码的要求</entry>
    <entry key="__misra_cpp_2023">检查 MISRA C++:2023</entry>
    <entry key="_boolean_types">有效布尔类型</entry>
    <entry key="_boolean_types_column_1">类型</entry>
    <entry key="_allowed_pragmas">允许的 pragma</entry>
    <entry key="_allowed_pragmas_column_1">Pragma</entry>
    <entry key="__custom_rules">检查自定义规则</entry>
    <entry key="_generate_results_for">为源代码和以下项生成结果</entry>
    <entry key="_generate_results_for_column_1">文件/文件夹</entry>
    <entry key="_do_not_generate_results_for">不为以下项生成结果</entry>
    <entry key="_do_not_generate_results_for_column_1">文件/文件夹</entry>
    <entry key="__misra_cpp_help">检查代码是否符合 MISRA C++ 标准。</entry>
    <entry key="_misra_cpp_help">检查代码是否符合 MISRA C++ 标准。</entry>
    <entry key="__jsf_coding_rules_help">检查代码是否符合 JSF AV 标准。</entry>
    <entry key="_jsf_coding_rules_help">检查代码是否符合 JSF AV 标准。</entry>
    <entry key="__misra2_help">检查代码是否符合 MISRA C:2004 标准。</entry>
    <entry key="_misra2_help">检查代码是否符合 MISRA C:2004 标准。</entry>
    <entry key="__misra_ac_agc_help">检查代码是否符合 MISRA AC AGC 标准。</entry>
    <entry key="_misra_ac_agc_help">检查代码是否符合 MISRA AC AGC 标准。</entry>
    <entry key="__misra3_help">嵌入式控件和独立软件的 C 语言使用规范。</entry>
    <entry key="_misra3_help">当应用于生成代码时，有些 MISRA C:2012 规则会改变类别(必需、建议、可读性)。&lt;BR&gt;使用此选项可基于适用于生成代码的分类来检查 MISRA C:2012 合规性。</entry>
    <entry key="_misra3_agc_mode_help">在自动代码生成的上下文中检查 MISRA C:2012 合规性。</entry>
    <entry key="__misra_c_2023_help">嵌入式控件和独立软件的 C 语言使用规范。</entry>
    <entry key="_misra_c_2023_help">当应用于生成代码时，有些 MISRA C:2023 规则会改变类别(必需、建议、可读性)。&lt;BR&gt;使用此选项可基于适用于生成代码的分类来检查是否符合 MISRA C:2023 标准。</entry>
    <entry key="_misra_c_2023_agc_mode_help">在自动代码生成的上下文中检查 MISRA C:2023 合规性。</entry>
    <entry key="__misra_cpp_2023_help">检查代码是否符合 MISRA C++:2023 标准。</entry>
    <entry key="_misra_cpp_2023_help">检查代码是否符合 MISRA C++:2023 标准。</entry>
    <entry key="_boolean_types_help">使用此选项指定希望 Polyspace 将其视为布尔值的数据类型。&lt;BR&gt;仅支持由 typedef 语句定义的数据类型。</entry>
    <entry key="_allowed_pragmas_help">指定进行以下检查的 pragma: &lt;ul&gt;&lt;li&gt;MISRA-C 和 MISRA AC AGC 规则 3.4 &lt;/li&gt; &lt;li&gt;MISRA C++ 规则 16-6-1&lt;/li&gt;&lt;/ul&gt; 此规则检查项将视这些 pragma 已提供文档说明，从而不会将其标记为违反这些规则。</entry>
    <entry key="__custom_rules_help">检查代码是否符合自定义编码规则。</entry>
    <entry key="_custom_rules_help">检查代码是否符合自定义编码规则。</entry>
    <entry key="_generate_results_for_help">指定需要分析结果的头文件。&lt;ul&gt;&lt;li&gt;source-headers: 与源文件位于同一文件夹中的头文件 &lt;/li&gt; &lt;li&gt;all-headers: 与源文件位于同一文件夹中的头文件、位于包含文件夹中的头文件 &lt;/li&gt; &lt;li&gt;custom: 指定的文件，或指定文件夹中的文件 &lt;/li&gt;&lt;/ul&gt; 此选项仅适用于编码规则、代码指标和 Polyspace Bug Finder 缺陷。</entry>
    <entry key="_do_not_generate_results_for_help">指定不需要分析结果的文件。&lt;ul&gt;&lt;li&gt;include-folders: 包含文件夹中的头文件 &lt;/li&gt; &lt;li&gt;all-headers: 位于包含文件夹中的头文件、与源文件位于同一文件夹中的头文件 &lt;/li&gt; &lt;li&gt;custom: 指定的文件，或指定文件夹中的文件 &lt;/li&gt;&lt;/ul&gt; 此选项仅适用于编码规则、代码指标和 Polyspace Bug Finder 缺陷。</entry>
    <entry key="_code_metrics">计算代码度量</entry>
    <entry key="_code_metrics_help">计算代码度量。</entry>
    <entry key="__bug_finder_multitasking">多任务</entry>
    <entry key="__bug_finder_multitasking_help">验证多任务处理代码。</entry>
    <entry key="BugFinderAnalysis_node">Bug Finder 分析</entry>
    <entry key="BugFinderAnalysis_title">Bug Finder 分析</entry>
    <entry key="__enable_checkers">查找缺陷</entry>
    <entry key="__enable_checkers_help">启用或禁用缺陷检查</entry>
    <entry key="__checkers_preset_help">选择预设的缺陷</entry>
    <entry key="_checks_using_system_input_values">运行更严格的检查并考虑所有的系统输入值</entry>
    <entry key="_checks_using_system_input_values_help">考虑以下各项的所有可能的值: &lt;ul&gt;&lt;li&gt;全局变量&lt;/li&gt; &lt;li&gt;易失变量的读取值&lt;/li&gt; &lt;li&gt;插桩函数的返回值&lt;/li&gt; &lt;li&gt;使用 "考虑这些函数的输入" 指定的函数输入&lt;/li&gt;&lt;/ul&gt; 更严格的静态分析可检测边缘数值情况可能导致的问题，&lt;BR&gt;并提供可能导致检测到的缺陷的示例值。&lt;BR&gt; &lt;BR&gt; 对使用选项 "考虑这些函数的输入" (-system-input -from)指定的函数执行更严格的分析。
    </entry>
    <entry key="_system_inputs_from">考虑这些函数的输入</entry>
    <entry key="_system_inputs_from_help">指定分析将考虑其所有可能输入值的函数。&lt;ul&gt;&lt;li&gt;auto: main 函数和任务(如有)，或者至少具有一个被调用方的未调用函数(当 main 函数不存在时)&lt;/li&gt; &lt;li&gt;uncalled: 所有未调用的函数&lt;/li&gt; &lt;li&gt;all: 所有函数&lt;/li&gt; &lt;li&gt;custom: 用户指定的函数&lt;/li&gt;&lt;/ul&gt;
    </entry>
    <entry key="_system_inputs_from_column_1">函数</entry>
    <entry key="CodeProverVerification_node">Code Prover 验证</entry>
    <entry key="CodeProverVerification_title">Code Prover 验证</entry>
    <entry key="MainGenerator_node">main 函数生成器</entry>
    <entry key="MainGenerator_title">main 函数生成器</entry>
    <entry key="__main">验证整个应用程序</entry>
    <entry key="_init_only_mode">仅验证初始化代码</entry>
    <entry key="_main">主入口函数</entry>
    <entry key="_main_generator">验证模块或库</entry>
    <entry key="_main_generator_mbd">验证模型的生成代码</entry>
    <entry key="_main_generator_autosar">从 AUTOSAR 规范生成的 main 函数</entry>
    <entry key="_class_analyzer">类</entry>
    <entry key="_class_analyzer_column_1">类</entry>
    <entry key="_class_analyzer_calls">指定类内要调用的函数</entry>
    <entry key="_class_analyzer_calls_column_1">函数</entry>
    <entry key="_class_only">仅分析类内容</entry>
    <entry key="_no_constructors_init_check">跳过成员初始化检查</entry>
    <entry key="_main_generator_writes_variables">要初始化的变量</entry>
    <entry key="_main_generator_writes_variables_column_1">全局变量</entry>
    <entry key="_functions_called_before_main">初始化函数</entry>
    <entry key="_functions_called_before_main_column_1">函数</entry>
    <entry key="_main_generator_calls">要调用的函数</entry>
    <entry key="_main_generator_calls_column_1">函数</entry>
    <entry key="_unit_by_unit">单独验证文件</entry>
    <entry key="_unit_by_unit_common_source">共同源文件</entry>
    <entry key="_unit_by_unit_common_source_column_1">文件</entry>
    <entry key="_variables_written_before_loop">参数</entry>
    <entry key="_variables_written_before_loop_column_1">变量</entry>
    <entry key="_variables_written_in_loop">输入</entry>
    <entry key="_variables_written_in_loop_column_1">变量</entry>
    <entry key="_functions_called_before_loop">初始化函数</entry>
    <entry key="_functions_called_before_loop_column_1">函数</entry>
    <entry key="_functions_called_in_loop">单步函数</entry>
    <entry key="_functions_called_in_loop_column_1">函数</entry>
    <entry key="_functions_called_after_loop">终止函数</entry>
    <entry key="_functions_called_after_loop_column_1">函数</entry>
    <entry key="_shared_variables_mode">仅显示全局变量的共享和使用情况</entry>
    <entry key="__main_help">使用现有的 'main' 函数作为验证的起点。</entry>
    <entry key="_init_only_mode_help">检查代码的初始化部分是否有运行时错误和其他问题。&lt;BR&gt;验证整个应用程序时，初始化代码从 'main' 开始，到 pragma 'polyspace_end_of_init' 结束。&lt;BR&gt;验证模块或库时，初始化代码是一组初始化函数的序列。</entry>
    <entry key="_main_help">使用现有的 'main' 函数作为验证的起点。</entry>
    <entry key="_main_generator_help">自动生成一个 'main' 函数。</entry>
    <entry key="_class_analyzer_help">输入用于生成 main 函数的类列表:&lt;ul&gt;&lt;li&gt;none: 没有类&lt;BR&gt;&lt;li&gt;all: 每个类&lt;BR&gt;&lt;li&gt;custom: 给定类的列表。&lt;BR&gt;给定类列表的选定成员函数(由 '要调用的在指定类内函数' 定义)将由生成的 main 函数调用。&lt;BR&gt;&lt;/ul&gt;</entry>
    <entry key="_class_only_help">仅分析由类(-class-analyzer)选项指定的类中包含的代码。&lt;BR&gt;系统将为在类之外定义的所有函数插桩，即使为 Polyspace 提供了源代码也是如此。</entry>
    <entry key="_class_analyzer_calls_help">验证由选项 -class-analyzer 指定的类的合格方法。合格方法是指定类的静态、公共和受保护方法。&lt;ul&gt;&lt;li&gt;all: 生成的 main 函数将调用指定类的所有公共和受保护方法。不调用从父类继承的成员。&lt;BR&gt;&lt;li&gt;all-public: 生成的 main 函数将调用受保护方法之外的所有方法。&lt;BR&gt;&lt;li&gt;inherited-all: 生成的 main 函数将调用指定类及其父类的所有公共和受保护方法。&lt;BR&gt;&lt;li&gt;inherited-all-public: 生成的 main 函数将调用指定类及其父类的所有公共方法。&lt;BR&gt;&lt;li&gt;unused: 默认。生成的 main 函数将调用指定类中未调用的所有方法。&lt;BR&gt;&lt;li&gt;unused-public: 除受保护方法之外，生成的 main 函数将调用指定类中未调用的所有方法。&lt;BR&gt;&lt;li&gt;inherited-unused: 生成的 main 函数将调用指定类及其父类的所有未被其他方法调用的公共和受保护方法。&lt;BR&gt;&lt;li&gt;inherited-unused-public: 生成的 main 函数将调用指定类及其父类的所有未被其他方法调用的所有公共方法。&lt;BR&gt;&lt;li&gt;custom=list_of_methods: 生成的 main 函数将调用在 list_of_methods 中提供的方法。&lt;BR&gt;&lt;/ul&gt;</entry>
    <entry key="_no_constructors_init_check_help">指示生成的 main 函数不要检查所有类字段是否都已初始化。</entry>
    <entry key="_main_generator_writes_variables_help">指定生成的 main 函数将如何初始化全局变量:&lt;BR&gt;&lt;li&gt;uninit - main 函数生成器会向未初始化的全局变量写入一个随机值(仅 C++)&lt;BR&gt;&lt;li&gt;none - main 函数不会写入任何全局变量&lt;BR&gt;&lt;li&gt;public - 除静态和常量变量之外，每个变量都被赋予一个 "随机" 值，表示可能值的完整范围&lt;BR&gt;&lt;li&gt;all - 每个变量都被赋予一个 "随机" 值，表示可能值的完整范围&lt;BR&gt;&lt;li&gt;custom - 仅列表中存在的变量被分配一个 "随机" 值，表示可能值的完整范围</entry>
    <entry key="_functions_called_before_main_help">指定初始化函数。&lt;br&gt;由自动生成的 main 函数在其他函数之前调用的函数。</entry>
    <entry key="_main_generator_calls_help">指定被视为公共函数的函数。&lt;BR&gt;由自动生成的 main 函数按随机顺序调用的函数。 </entry>
    <entry key="_variables_written_before_loop_help">指定被视为循环系统参数的一组变量。&lt;BR&gt;由生成的 main 函数在连续循环之前写入的变量。</entry>
    <entry key="_variables_written_in_loop_help">指定被视为循环系统输入的一组变量。&lt;BR&gt;由生成的 main 函数在连续循环的每次迭代中重置的变量。</entry>
    <entry key="_functions_called_before_loop_help">指定由生成的 main 函数在单步循环之前调用的一组初始化函数。</entry>
    <entry key="_functions_called_in_loop_help">指定在循环中调用的一组函数:&lt;BR&gt;&lt;li&gt;none - 不调用子程序时使用此选项。&lt;BR&gt;&lt;li&gt;unused - 生成的 main 函数仅调用文件中未调用的函数。&lt;BR&gt;&lt;li&gt;all - 生成的 main 函数调用所有函数。例如，如果函数 'f' 被 'g' 调用，则生成的 main 函数也会使用每个参数的随机值调用 'f'。&lt;BR&gt;&lt;li&gt;custom - 指定由生成的 main 函数调用的函数列表。</entry>
    <entry key="_functions_called_after_loop_help">指定由生成的 main 函数在连续循环后调用的函数。</entry>
    <entry key="_unit_by_unit_help">为工程中的每个源文件创建一个单独的验证作业。&lt;br&gt;编译每个文件，然后分别验证。</entry>
    <entry key="_unit_by_unit_common_source_help">指定每次验证文件时要包含的一系列文件。&lt;br&gt;此列表中未包含的函数将会插桩。</entry>
    <entry key="_shared_variables_mode_help">运行更快的分析以确定全局变量的共享和使用情况。&lt;BR&gt;&lt;BR&gt;分析结果包含:&lt;BR&gt;&lt;ul&gt;&lt;li&gt;全局变量(已共享、未共享、已使用、未使用)&lt;li&gt;编码规则(如启用)&lt;li&gt;代码度量(如启用)&lt;/ul&gt;&lt;BR&gt;"变量访问" 视图还显示对所有全局变量的读取和写入操作。</entry>
    <entry key="InputsStubbing_node">输入和插桩</entry>
    <entry key="InputsStubbing_title">输入和插桩</entry>
    <entry key="Inputs_section">输入</entry>
    <entry key="Stubbing_section">插桩</entry>
    <entry key="Filtering_section">过滤</entry>
    <entry key="_data_range_specifications">约束设置</entry>
    <entry key="_no_def_init_glob">忽略全局变量的默认初始化</entry>
    <entry key="_no_stl_stubs">无 STL 桩件</entry>
    <entry key="_functions_to_stub">要插桩的函数</entry>
    <entry key="_library">使用的库</entry>
    <entry key="_functions_to_stub_column_1">函数</entry>
    <entry key="_stub_embedded_coder_lookup_table_functions">为 Embedded Coder 查找表生成桩件</entry>
    <entry key="_data_range_specifications_help">为全局变量、指针和函数参数指定数据约束。&lt;BR&gt;点击 "编辑" 按钮打开向导，引导您完成约束设置。或者，在字段中指定约束模板文件。&lt;BR&gt;&lt;BR&gt;指定的约束将覆盖从 Simulink 模型中提取的值。</entry>
    <entry key="_no_def_init_glob_help">指定全局变量默认视为未初始化。&lt;BR&gt; - 'on': Polyspace 忽略全局变量的隐式初始化。&lt;BR&gt;如果在写入全局变量之前读取全局变量，则会产生未初始化变量错误。&lt;BR&gt; - 'off': Polyspace 根据 ANSI C (ISO C++) 标准将全局变量视为已初始化。&lt;BR&gt;对于浮点数，默认初始化值为 0.0，对于 int 和 char，默认初始化值为 0。</entry>
    <entry key="_no_stl_stubs_help">不要使用标准模板库(STL)的 Polyspace 实现。&lt;BR&gt;使用标准规则为标准模板库的函数插桩。</entry>
    <entry key="_functions_to_stub_help">指定 Polyspace 要插桩的函数。</entry>
    <entry key="_library_help">指定在程序中使用的库。&lt;BR&gt;分析将使用智能桩件来代替这些库的函数，而非使用通用桩件(并且不尝试检查函数实现)。&lt;BR&gt;使用此选项可以在不损失精度的情况下加快分析速度，并基于库函数调用触发特定于库的检查。</entry>
    <entry key="_stub_embedded_coder_lookup_table_functions_help">选中此选项可自动生成 Embedded Coder 查找表的桩件</entry>
    <entry key="VerificationAssumption_node">验证假设</entry>
    <entry key="VerificationAssumption_title">验证假设</entry>
    <entry key="_respect_types_in_fields">遵从字段中的类型</entry>
    <entry key="_respect_types_in_globals">遵从全局变量中的类型</entry>
    <entry key="_float_rounding_mode">浮点数舍入模式</entry>
    <entry key="_consider_volatile_qualifier_on_fields">考虑字段的 volatile 限定符</entry>
    <entry key="_stubbed_pointers_are_unsafe">将环境指针视为不安全</entry>
    <entry key="_ignore_assembly_code">忽略汇编代码</entry>
    <entry key="_respect_types_in_fields_help">假设声明为非指针类型的结构体字段不用于保存指针值。&lt;br&gt;仅为类型安全的 C 代码选择选项。</entry>
    <entry key="_respect_types_in_globals_help">假设声明为非指针类型的结构体字段不用于保存指针值。&lt;br&gt;仅为类型安全的 C 代码选择选项。</entry>
    <entry key="_float_rounding_mode_help">指定在确定浮点运算结果时要考虑的舍入模式。&lt;BR&gt; &lt;ul&gt; &lt;li&gt;to-nearest: 考虑就近舍入模式，并且不使用扩展精度。&lt;li&gt;all: 考虑所有舍入模式并使用扩展精度。&lt;/ul&gt;</entry>
    <entry key="_ignore_assembly_code_help">忽略所有汇编代码。&lt;br&gt;除非您打开此选项，否则软件假定汇编代码可以修改 C/C++ 变量。</entry>
    <entry key="ChecksAssumption_node">检查行为</entry>
    <entry key="ChecksAssumption_title">检查行为</entry>
    <entry key="OverflowAssumption_section">溢出</entry>
    <entry key="Initialization_section">初始化</entry>
    <entry key="DeadCode_section">死代码</entry>
    <entry key="PointerAssumption_section">指针</entry>
    <entry key="FloatingPoint_section">浮点</entry>
    <entry key="ImpactAnalysis_section">影响分析</entry>
    <entry key="StackUsage_section">堆栈使用情况</entry>
    <entry key="_ignore_constant_overflows">忽略常量的溢出计算</entry>
    <entry key="_allow_negative_operand_in_shift">允许左移负操作数</entry>
    <entry key="_signed_integer_overflows">有符号整数的溢出模式</entry>
    <entry key="_unsigned_integer_overflows">无符号整数的溢出模式</entry>
    <entry key="_disable_initialization_checks">禁用非初始化检查</entry>
    <entry key="_check_globals_init">检查全局变量在热重启后是否初始化</entry>
    <entry key="_detect_pointer_escape">检测超出作用域的堆栈指针解引用</entry>
    <entry key="_allow_ptr_arith_on_struct">启用跨字段的指针算术</entry>
    <entry key="_size_in_bytes">允许为结构体分配不足量的内存</entry>
    <entry key="_permissive_function_pointer">宽松函数指针调用</entry>
    <entry key="_uncalled_function_checks">检测未调用的函数</entry>
    <entry key="_allow_non_finite_floats">考虑非有限浮点数</entry>
    <entry key="_check_infinite">无限值</entry>
    <entry key="_check_nan">NaN</entry>
    <entry key="_check_subnormal">次正规数值检测模式</entry>
    <entry key="_impact_analysis">启用影响分析</entry>
    <entry key="_impact_specifications">指定源点和汇点</entry>
    <entry key="_impact_analysis_only">仅显示影响分析结果</entry>
    <entry key="_stack_usage">计算堆栈使用情况</entry>
    <entry key="_ignore_constant_overflows_help">当常量计算溢出时，放宽对遵守 ANSI/ISO C-90 标准的要求。&lt;br&gt;例如，参照此标准，代码 &lt;i&gt;char x = 0xff;&lt;/i&gt; 会导致溢出。&lt;br&gt;但是，选择此选项会将代码更改为 &lt;i&gt;char x = -1;&lt;/i&gt;</entry>
    <entry key="_allow_negative_operand_in_shift_help">ANSI/ISO C-90 标准不允许对负数进行移位运算。默认情况下，验证停止。&lt;br&gt;&lt;br&gt;例如，代码 &lt;i&gt; -2 &lt;&lt; 2 &lt;/i&gt; 将导致验证停止。&lt;br&gt;但是，如果选择此选项，Polyspace 将认为操作有效并输出结果: -2 &lt;&lt; 2 = -8</entry>
    <entry key="_signed_integer_overflows_help">指定当有符号整数计算产生超出范围(由数据类型确定)的值时 Code Prover 的行为:&lt;ul&gt;&lt;li&gt;allow - Code Prover 不会标记溢出。溢出结果将被绕回。&lt;br&gt;例如，MAX_INT + 1 的结果将绕回到 MIN_INT。&lt;br&gt;&lt;li&gt;forbid(默认) - Code Prover 会标记溢出。导致溢出的值不会传播到后续操作。&lt;br&gt;此行为符合 ANSI C (ISO C++)标准。&lt;br&gt;&lt;li&gt;warn-with-wrap-around - Code Prover 会标记溢出。溢出结果将被绕回。</entry>
    <entry key="_unsigned_integer_overflows_help">指定当无符号整数计算产生超出范围(由数据类型确定的范围)的值时 Code Prover 的行为:&lt;ul&gt;&lt;li&gt;allow(默认) - Code Prover 不会标记溢出。溢出结果将被绕回。&lt;br&gt;例如，MAX_INT + 1 的结果将绕回到 MIN_INT。&lt;br&gt;此行为符合 ANSI C (ISO C++)标准。&lt;br&gt;&lt;li&gt;forbid - Code Prover 会标记溢出。导致溢出的值不会传播到后续操作。&lt;br&gt;&lt;li&gt;warn-with-wrap-around - Code Prover 会标记溢出。溢出结果将被绕回。</entry>
    <entry key="_scalar_overflows_behavior_help">将此选项与 "检测溢出" 一起使用以指定整数计算或整数转换检查后的结果。&lt;br&gt;&lt;br&gt;选择以下值之一: &lt;ul&gt;&lt;li&gt;truncate-on-error (默认) - 结果仅限于可接受的值并且验证停止。&lt;br&gt;如果此检查为红色，则所有后续检查为黑色。如果检查为橙色，则使用受限值继续验证。&lt;br&gt;&lt;li&gt;wrap-around - 结果对类型范围进行绕回。此检查对验证的其他部分的值没有影响。</entry>
    <entry key="_disable_initialization_checks_help">禁用以下检查:&lt;ul&gt;&lt;li&gt;未初始化的局部变量&lt;br&gt;&lt;li&gt;未初始化的变量&lt;br&gt;&lt;li&gt;未初始化的指针&lt;br&gt;&lt;li&gt;初始化的返回值&lt;/i&gt;&lt;/ul&gt;如果启动此选项，则在声明时，变量被视为使用完整范围，指针为空或者指向未知偏移量处的内存模块。</entry>
    <entry key="_check_globals_init_help">检查全局变量是否在指定的初始化代码中进行了赋值。&lt;BR&gt;验证整个应用程序时，初始化代码从 'main' 开始，到 pragma 'polyspace_end_of_init' 结束。&lt;BR&gt;验证模块或库时，初始化代码是一组初始化函数的序列。</entry>
    <entry key="_detect_pointer_escape_help">查找因为函数返回了指向其局部变量之一的指针而导致未定义行为的情况。</entry>
    <entry key="_allow_ptr_arith_on_struct_help">允许跨结构体字段边界的指针算术运算 - 这不是符合 ANSI/ISO C-90 的行为。</entry>
    <entry key="_size_in_bytes_help">允许使用 &lt;i&gt;malloc&lt;/i&gt; 或 &lt;i&gt;cast&lt;/i&gt; 语句分配不足量的内存。</entry>
    <entry key="_permissive_function_pointer_help">默认情况下，只有当函数指针和函数类型完全相同时，Polyspace 才允许函数指针调用函数。&lt;br&gt;例如，假设有一个以下类型的函数:&lt;br&gt;&lt;i&gt;int f(int*)&lt;/i&gt;&lt;br&gt;则该函数无法由以下类型的函数调用:&lt;br&gt;&lt;i&gt;int fptr(void*)&lt;/i&gt;&lt;br&gt;如果设置了此选项，则 Polyspace 允许此类调用。&lt;br&gt;对于大量使用函数指针的应用程序，此选项可能会导致性能显著下降和更多&lt;br&gt;橙色检查，因为 Polyspace 必须考虑更多执行路径。</entry>
    <entry key="_uncalled_function_checks_help">检测在运行时未从主入口函数或其他入口函数直接或间接调用的函数。&lt;br&gt; &lt;li&gt;none - 不检测未调用的函数。&lt;br&gt;&lt;li&gt; never-called - 检测已定义但从未调用的函数。&lt;br&gt;如果函数 func 被标识为从未被调用，则仅从 func 调用的所有函数也被标识为从未被调用。&lt;br&gt;&lt;li&gt; called-from-unreachable - 检测从代码中不可达的部分定义和调用的函数。&lt;br&gt;如果函数 func 被标识为从不可达函数调用，则仅从 func 调用的所有函数也被标识为从不可达函数调用。&lt;br&gt;&lt;li&gt; all - 检测所有未调用的函数</entry>
    <entry key="_allow_non_finite_floats_help">将 Inf 和 NaN 纳入验证。例如: &lt;BR&gt; &lt;ul&gt; &lt;li&gt;允许浮点运算产生 Inf 和 NaN。&lt;li&gt;假定具有未知值的浮点变量可以是无限值或 NaN。&lt;/ul&gt;单使用这一选项实质上会禁止对浮点&lt;BR&gt;运算进行许多数值检查。如果已大体考虑了无限值和 NaN，但不确定&lt;BR&gt;是否涵盖了所有情况，则可以将 "无限值" 和 "NaN" 选项设置为 warn-first。&lt;br&gt;&lt;br&gt;在 Bug Finder 中，如果分析将无限值和 NaN 的比较标记为死代码，则可使用此选项。</entry>
    <entry key="_stubbed_pointers_are_unsafe_help">指定除非另有约束，否则环境指针可以为空。&lt;br&gt;环境指针可以是以下各项之一:&lt;br&gt;&lt;ul&gt;&lt;li&gt;全局或外部变量，&lt;/li&gt;&lt;li&gt;已插桩函数的返回值，&lt;/li&gt;&lt;li&gt;生成调用的用户定义函数的参数。&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;除非使用此选项，否则默认情况下环境指针被视为安全，而不是空。&lt;br&gt;</entry>
    <entry key="_check_infinite_help">检测产生无限值(Inf-s)的运算。&lt;BR&gt;&lt;ul&gt;&lt;li&gt;allow: 不对运算进行检查。&lt;BR&gt;&lt;/li&gt;&lt;li&gt;warn-first: 仅当操作数不是无限值时才对运算进行检查。&lt;BR&gt;即使检查变成红色，也会继续验证。&lt;BR&gt;此模式仅突出显示第一次出现的无限值。&lt;/li&gt;&lt;li&gt;forbid: 对运算进行检查。&lt;BR&gt;如果检查为红色，则停止验证。&lt;/li&gt;&lt;/ul&gt;</entry>
    <entry key="_check_nan_help">检测产生 NaN 的运算。&lt;BR&gt;&lt;ul&gt;&lt;li&gt;allow: 不对运算进行检查。&lt;BR&gt;&lt;/li&gt;&lt;li&gt;warn-first: 仅当操作数不是 NaN 时才对运算进行检查。&lt;BR&gt;即使检查变为红色，也会继续验证。&lt;BR&gt;此模式仅突出显示第一次出现的 NaN。&lt;/li&gt;&lt;li&gt;forbid: 对运算进行检查。&lt;BR&gt;如果检查变为红色，则停止验证。&lt;/li&gt;&lt;/ul&gt;</entry>
    <entry key="_check_subnormal_help">检测产生次正规浮点值的运算。&lt;BR&gt;&lt;ul&gt;&lt;li&gt;allow: 不对运算进行检查。&lt;BR&gt;&lt;/li&gt;&lt;li&gt;warn-first: 仅当操作数不是次正规值时才对运算进行检查。&lt;BR&gt;即使检查变为红色，也会继续验证。&lt;BR&gt;此模式仅突出显示第一次出现的次正规值。&lt;/li&gt;&lt;li&gt;warn-all: 即使操作数为次正规值，也对运算进行检查。&lt;BR&gt;即使检查变为红色，也会继续验证。&lt;BR&gt;此模式会突出显示所有出现的次正规值。&lt;/li&gt;&lt;li&gt;forbid: 对运算进行检查。&lt;BR&gt;如果检查变为红色，则停止验证。&lt;/li&gt;&lt;/ul&gt;</entry>
    <entry key="_consider_volatile_qualifier_on_fields_help">不忽略结构体字段的 volatile 限定符。&lt;br&gt;如果启用此选项，软件会做出以下假设:&lt;ul&gt;&lt;li&gt;如果结构体的某个字段为易失类型，则整个结构体均视为易失类型。&lt;br&gt;所有字段均视为易失类型，即使没有 volatile 限定符也是如此。&lt;/li&gt;&lt;li&gt;易失结构体的每个字段在代码中的任何位置都具有完整范围的值。&lt;/li&gt;&lt;/ul&gt;</entry>
    <entry key="_impact_analysis_help">检查指定为源点和汇点的程序元素之间是否存在影响。</entry>
    <entry key="_impact_specifications_help">指定将项目元素标识为影响分析的源点和汇点的 XML 文件。</entry>
    <entry key="_impact_analysis_only_help">跳过常规的 Code Prover 运行时错误检查，只执行影响分析。</entry>
    <entry key="_stack_usage_help">计算和显示估计的堆栈使用情况</entry>
    <entry key="Precision_node">精度</entry>
    <entry key="Precision_title">精度</entry>
    <entry key="GlobalSettings_section">全局设置</entry>
    <entry key="SpecificConstructsSettings_section">特定构造设置</entry>
    <entry key="_O">精度等级</entry>
    <entry key="_to">验证等级</entry>
    <entry key="_timeout">验证时限</entry>
    <entry key="_retype_pointer">修改指针类型变量的类型</entry>
    <entry key="_retype_int_pointer">修改整数类型符号的类型</entry>
    <entry key="_context_sensitivity">上下文敏感</entry>
    <entry key="_context_sensitivity_column_1">过程</entry>
    <entry key="_path_sensitivity_delta">提高过程间分析的精度</entry>
    <entry key="_modules_precision">特定精度</entry>
    <entry key="_modules_precision_column_1">文件名</entry>
    <entry key="_modules_precision_column_2">精度</entry>
    <entry key="_O_help">指定验证的精度等级。精度等级越高，验证时间越长:&lt;ul&gt;&lt;li&gt;0 级 - 静态区间代码验证。&lt;li&gt;1 级 - 验证使用域值的复杂多面体模型。&lt;li&gt;2 级 - 验证使用更复杂的算法对域值进行紧密建模(一种包含整数网格和复杂多面体的混合方法)。&lt;li&gt;3 级 - 仅适用于长度小于 1000 行的代码。对于此类代码，选择度可能会变高，导致代码验证时间较长。例如，每 1000 行代码需要 1 小时。&lt;/ul&gt;从 0 级开始代码验证。接下来，改正红色和灰色检查。然后，以更高等级的精度运行验证。</entry>
    <entry key="_to_help">指定验证等级。验证等级越高，选择度越高。&lt;br&gt;验证等级越高，验证时间越长。</entry>
    <entry key="_timeout_help">如果验证未在指定时间限制 X[.Y] 或 X[,Y] 内完成，则停止验证，其中 X 表示小时，Y(可选)表示小时的小数。&lt;br&gt;&lt;br&gt;例如: &lt;ul&gt;&lt;li&gt;timeout 5.75 表示时限为 5 小时 45 分钟&lt;br&gt;&lt;li&gt;timeout 3,5 表示时限为 3 小时 30 分钟&lt;/ul&gt;如果验证未在指定时限内完成，则认为验证失败。</entry>
    <entry key="_retype_pointer_help">修改指针类型变量的类型，以提高指针转换链的精度，例如:&lt;BR&gt;struct A '{'int a; char b;'}' s = '{'1, 2'}';&lt;BR&gt;char *tmp = (char *)&amp;s;&lt;BR&gt;struct A *pa = (struct A *)tmp;&lt;BR&gt;assert((pa-&gt;a == 1) &amp;&amp; (pa-&gt;b == 2));&lt;BR&gt;原理是，当指针类型的符号别名为单一类型的对象时，其原始类型可以被别名对象类型替换。&lt;BR&gt;&lt;BR&gt;此原理可以应用于指针类型的 struct/union 字段。&lt;BR&gt;不能将此选项与 '重新键入整数类型符号' (-retype-int-pointer)一起使用。</entry>
    <entry key="_retype_int_pointer_help">修改大小与指针类型相同的有符号或无符号整数类型的符号类型。&lt;BR&gt;例如:&lt;BR&gt;struct S '{'&lt;BR&gt;int x;&lt;BR&gt;int y;&lt;BR&gt;int z;&lt;BR&gt;char t;&lt;BR&gt;'}' s = '{'1, 2, 3, 4'}';&lt;BR&gt;struct S2 '{'&lt;BR&gt;int first;&lt;BR&gt;void *p;&lt;BR&gt;'}' s2, *ptr = &amp;s2;&lt;BR&gt;...&lt;BR&gt;ptr-&gt;first = (int)&amp;s;&lt;BR&gt;assert(((struct S *)ptr-&gt;first)-&gt;y == 2);&lt;BR&gt;&lt;BR&gt;不能将此选项与 "修改指针类型变量的类型" (-retype-pointer)一起使用。</entry>
    <entry key="_context_sensitivity_help">为给定函数中包含的检查添加调用上下文信息。&lt;br&gt;例如，如果对函数的一个调用结果为红色检查，而另一个调用结果为绿色检查，则两者的调用信息和颜色都将包含在检查中。&lt;br&gt;&lt;br&gt;选择以下值之一:&lt;ul&gt;&lt;li&gt;无 - 无上下文敏感&lt;br&gt;&lt;li&gt;自动 - 自动选择将应用上下文敏感的函数&lt;br&gt;&lt;li&gt;自定义 - 提供将应用上下文敏感的函数&lt;/li&gt;</entry>
    <entry key="_path_sensitivity_delta_help">提高过程间分析的精度。&lt;br&gt;&lt;br&gt;警告: 应该使用小于或等于 3 的值。&lt;br&gt;否则，验证可能需要更长时间。</entry>
    <entry key="_modules_precision_help">指定要以特定精度来分析的编译单元列表，该精度与所指定 "精度等级" (-O)不同。&lt;BR&gt;&lt;BR&gt;默认情况下，所有编译单元都以相同的精度进行验证。&lt;BR&gt;编译单元均为 .c 文件。</entry>
    <entry key="Scaling_node">规模</entry>
    <entry key="Scaling_title">规模</entry>
    <entry key="_inline">内联</entry>
    <entry key="_inline_column_1">过程</entry>
    <entry key="_k_limiting">结构体内部的验证深度</entry>
    <entry key="_inline_help">针对列出的每个过程，为每次调用创建一份过程克隆。&lt;br&gt;此内联减少了给定过程中的别名数量，并且可能提高精度。&lt;br&gt;&lt;br&gt;&lt;b&gt;警告:&lt;/b&gt; 大规模使用此选项可能会导致过多的代码重复，并导致规模问题。</entry>
    <entry key="_k_limiting_help">限制指针分析要区分的结构体中的字段数，即指定结构体内部的分析深度。&lt;br&gt;&lt;br&gt;警告: 应使用大于或等于 2 的值。否则，验证可能需要更长时间或不太准确。</entry>
    <entry key="Advanced_node">高级设置</entry>
    <entry key="Advanced_title">高级设置</entry>
    <entry key="MergedAdvanced_node">高级设置</entry>
    <entry key="MergedAdvanced_title">高级设置</entry>
    <entry key="post_verification_section">验证后</entry>
    <entry key="_post_analysis_command">代码验证结束后要应用的命令/脚本</entry>
    <entry key="__other">其他</entry>
    <entry key="_post_analysis_command_help">指定在代码验证完成后必须运行的命令或文件。</entry>
    <entry key="__other_help">如有必要，技术支持团队可以提供非官方选项用于对您的验证进行微调。</entry>
    <entry key="Reporting_node">报告</entry>
    <entry key="MergedReporting_node">报告</entry>
    <entry key="Reporting_title">报告</entry>
    <entry key="MergedReporting_title">报告</entry>
    <entry key="__report_generation">生成报告</entry>
    <entry key="__report_template_code_prover">Code Prover 报告</entry>
    <entry key="__report_template_code_prover_help">为 Code Prover 报告指定模板&lt;BR&gt;产品选项 -report-template。</entry>
    <entry key="__report_template_bug_finder">Bug Finder 报告</entry>
    <entry key="__report_template_bug_finder_help">为 Bug Finder 报告指定模板&lt;BR&gt;产品选项 -report-template。</entry>
    <entry key="_report_template">报告模板</entry>
    <entry key="_report_template_bug_finder">报告模板</entry>
    <entry key="_report_template_code_prover">报告模板</entry>
    <entry key="_report_output_format">输出格式</entry>
    <entry key="__report_generation_help">使用报告生成选项创建验证报告。</entry>
    <entry key="_report_template_help">指定用于生成分析报告的模板。</entry>
    <entry key="__bf_report_template_help">指定用于生成分析报告的模板。</entry>
    <entry key="_report_output_format_help">指定报告的输出格式。</entry>
    <entry key="__external_multitasking_type"/>
    <entry key="_checkers_selection_file"/>
    <entry key="_cert_c"/>
    <entry key="_cert_cpp"/>
    <entry key="_iso_17961"/>
    <entry key="_autosar_cpp14"/>
    <entry key="_guidelines"/>
    <entry key="_cwe"/>
    <entry key="_misra_cpp"/>
    <entry key="_jsf_coding_rules"/>
    <entry key="_misra2"/>
    <entry key="_misra_ac_agc"/>
    <entry key="_misra3"/>
    <entry key="_misra_c_2023"/>
    <entry key="_misra_cpp_2023"/>
    <entry key="_custom_rules"/>
    <entry key="__checkers_preset"/>
  </message>
</rsccat>
