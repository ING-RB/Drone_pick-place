<?xml version="1.0"?>
<!-- Copyright 2022-2024 The MathWorks, Inc. -->
<rsccat version="1.0" locale="en_US" product="polyspace">
    <message>
        <entry key="badFunctionMapping" translate="false">Function ''{0}'' could not be mapped to standard function ''{1}''.</entry>
        <entry key="badReturnType" translate="false">The functions do not have compatible return types.</entry>
        <entry key="badNumberOfArguments" translate="false">The functions do not have the same number of arguments.</entry>
        <entry key="userFunctionIsVarArg" translate="false">Function ''{0}'' has variable number of arguments. Map the arguments explicitly using the 'mapping' tag.</entry>
        <entry key="badArgumentFcnHasPredefName" translate="false">Function ''{0}'' has variable number of arguments. Argument {1,number,integer} of the functions do not have compatible types.</entry>
        <entry key="badArgumentFcnHasntPredefName" translate="false">You mapped argument {2,number,integer} of ''{0}'' to argument {3,number,integer} of ''{1}''. The arguments do not have compatible types.</entry>
        <entry key="badMapping" translate="false">You mapped argument {2,number,integer} of ''{0}'' to an argument of ''{1}''. Argument {2,number,integer} does not exist.</entry>
        <entry key="badPredefName" translate="false">Function ''{0}'' is not a recognized standard function.</entry>
        <entry key="badUserName" translate="false">You cannot override standard function ''{0}''.</entry>
        <entry key="mappingVectorHasWrongSizeFatalError" translate="false">Attempting to map the function ''{0}'' to the standard function ''{1}''. This standard function requires {2,number,integer} arguments whereas user defined mapping refers to {3,number,integer} arguments. </entry>
        <entry key="userFunctionMappedToStandardFunction" translate="false">Function ''{0}'' successfully mapped to standard function ''{1}''.</entry>
        <!-- Tooltips messages-->
        <entry key="titleCheckOnArgument" translate="false">Checks on {0} {1}:</entry>
        <entry key="checkOnArgument" translate="false">{0}</entry> <!-- Argument number, Source or Destination, NonNull, maybenull or null-->
        <entry key="otherChecks" translate="false">Other checks:</entry>
        <entry key="checkPointerAccess" translate="false">{0} a memory area that is accessible within the boundary given by the {1}.</entry>
        <entry key="checkPointerOverlap" translate="false">{0} and {1} {2} overlapping memory.</entry> <!-- Pointer Var, Pointer Var, dot not or may or have-->
        <entry key="doesNotPointToEscapedPointer" translate="false">Does not point to an escaped variable (variable that is no longer on stack).</entry>
        <entry key="mayPointToEscapedPointer" translate="false">May point to variable that is no longer on the stack.</entry>
        <entry key="pointsToEscapedPointer" translate="false">Points to variable that is no longer on the stack.</entry>
        <!--First parameter is the lower value of the range, the second parameter is the upper value then the third is either "or NaN" or empty string-->
        <entry key="argumentIsWithinRange" translate="false">Argument is within expected range [{0} .. {1}]{2}</entry>
        <entry key="argumentMayBeOutsideRange" translate="false">Argument might be outside expected range [{0} .. {1}]{2}</entry>
        <entry key="argumentDefinitvelyOutsideRange" translate="false">Argument is outside expected range [{0} .. {1}]{2}</entry>
        <entry key="argumentIsNotNaN" translate="false">Argument is not NaN</entry>
        <entry key="argumentMayBeNaN" translate="false">Argument might be NaN</entry>
        <entry key="argumentDefinitivelyNaN" translate="false">Argument is NaN</entry>
        <entry key="functionCannotFail" translate="false">Function ''{0}'' has a well-defined behavior for finite floating-point values.</entry>
        <entry key="functionDoesNotOverflow" translate="false">{0} does not overflow</entry>
        <entry key="functionMayOverflow" translate="false">{0} may overflow</entry>
        <entry key="functionOverflows" translate="false">{0} will always overflow</entry>
        <entry key="argumentIsGeqThanZero" translate="false">Argument is positive or zero</entry>
        <entry key="argumentMayNotBeGeqThanZero" translate="false">Argument might be negative{0}</entry>
        <entry key="argumentIsLtThanZero" translate="false">Argument is negative{0}</entry>
        <entry key="argumentIsGeq" translate="false">Argument is greater than or equal to {0}</entry>
        <entry key="argumentMayNotBeGeq" translate="false">Argument might be smaller than {0} {1}</entry>
        <entry key="argumentIsDefinitivelyLtThan" translate="false">Argument is less than {0} {1}</entry>
        <entry key="argumentNeitherNegIntegerNorNegInf" translate="false">Argument is not a negative integer or negative infinity</entry>
        <entry key="argumentMaybeNegIntegerOrNegInf" translate="false">Argument might be a negative integer or negative infinity</entry>
        <entry key="argumentDefinitivelyNegIntegerOrNegInf" translate="false">Argument is definitely a negative integer or negative infinity</entry>
        <entry key="argumentIsNonZeroWhenNotNaN" translate="false">{0} argument is non-zero (when arguments are not NaN)</entry>
        <entry key="argumentIsNonZero" translate="false">{0} argument is non-zero</entry>
        <entry key="argumentMayBeZero" translate="false">{0} argument may equal to zero</entry>
        <entry key="argumentIsEqToZero" translate="false">{0} argument is equal to zero</entry>
        <entry key="argumentIsFiniteWhenNotNaN" translate="false">{0} argument is finite (when arguments are not NaN)</entry>
        <entry key="argumentIsFinite" translate="false">{0} argument is finite</entry>
        <entry key="argumentMayBeInfinite" translate="false">{0} argument might be infinite</entry>
        <entry key="argumentIsInfinite" translate="false">{0} argument is infinite</entry>
        <entry key="argumentIsFiniteOrNaN" translate="false">{0} argument is finite or NaN</entry>
        <entry key="powNoZDV" translate="false">First argument is non-zero or second argument is positive or zero</entry>
        <entry key="powMayZDV" translate="false">Second argument might be negative with first argument equal to zero</entry>
        <entry key="powDefinitivelyZDV" translate="false">Second argument is negative with first argument equal to zero</entry>
        <entry key="powNegArgWellDefined" translate="false">First argument is not negative or second argument is an integer value</entry>
        <entry key="powNegArgMayNotBeDefined" translate="false">Second argument may not be an integer value with first argument negative</entry>
        <entry key="powNegArgNotDefined" translate="false">Second argument is not an integer value with first argument negative</entry>
        <entry key="FMAInvalidFirstTwoArgsZeroAndInfBad" translate="false">First two arguments are 0 and +/-inf</entry>
        <entry key="FMAInvalidFirstTwoArgsZeroAndInfMaybeBad" translate="false">First two arguments might be 0 and +/-inf</entry>
        <entry key="FMAInvalidFirstTwoArgsZeroAndInfOk" translate="false">First two arguments are not 0 and +/- inf</entry>
        <entry key="FMAInvalidFirstTwoArgsInfAndZeroBad" translate="false">First two arguments are +/-inf and 0</entry>
        <entry key="FMAInvalidFirstTwoArgsInfAndZeroMaybeBad" translate="false">First two arguments might be +/-inf and 0</entry>
        <entry key="FMAInvalidFirstTwoArgsInfAndZeroOk" translate="false">First two arguments are not +/-inf and 0</entry>
        <entry key="FMAInvalidSumInfBad" translate="false">First two arguments are +inf and -inf</entry>
        <entry key="FMAInvalidSumInfMaybeBad" translate="false">First two arguments might be +inf and -inf</entry>
        <entry key="FMAInvalidSumInfOk" translate="false">First two arguments are not +inf and -inf</entry>
        <entry key="FMAInvalidProductPlusInfMinusInfBad" translate="false">Product of first two arguments and third argument are +inf and -inf</entry>
        <entry key="FMAInvalidProductPlusInfMinusInfInfMaybeBad" translate="false">Product of first two arguments and third argument might be +inf and -inf</entry>
        <entry key="FMAInvalidProductPlusInfMinusInfOk" translate="false">Product of first two arguments and third argument are not +inf and -inf</entry>
        <entry key="FMAInvalidProductMinusInfPlusInfBad" translate="false">Product of first two arguments and third argument are -inf and +inf</entry>
        <entry key="FMAInvalidProductMinusInfPlusInfInfMaybeBad" translate="false">Product of first two arguments and third argument might be -inf and +inf</entry>
        <entry key="FMAInvalidProductMinusInfPlusInfOk" translate="false">Product of first two arguments and third argument are not -inf and +inf</entry>
        <entry key="ECLutDetected" translate="false">* Function ''{0}'' has been recognized as an Embedded Coder Lookup-Table function.\n  It is stubbed by Polyspace to increase precision.</entry>
        <entry key="ECPreLutDetected" translate="false">* Function ''{0}'' has been recognized as an Embedded Coder Pre Lookup-Table function.\n  It is stubbed by Polyspace to increase precision.</entry>
        <entry key="LUTFcnNotModeledAsFcnNotDefined" translate="false">Function ''{0}'' has not been modeled as an Embedded Lookup Table, despite its name matches a valid EC Lookup tabble, because this function is not defined.</entry>
    </message>
</rsccat>
