<?xml version="1.0"?>
<!-- Copyright 2019-2024 The MathWorks, Inc. -->
<rsccat version="1.0" locale="en_US" product="polyspace">
  <message>
    <entry key="scalarStr" note="scalar in the computer science meaning" translate="false">scalar</entry>
    <entry key="ScalarStr" note="scalar in the computer science meaning" translate="false">Scalar</entry>
    <entry key="floatStr" note="float in the computer science meaning" translate="false">float</entry>
    <entry key="FloatStr" note="float in the computer science meaning" translate="false">Float</entry>

    <!-- messages for Code Prover checks -->
    <entry key="CheckZDVGray" translate="false">Unreachable check: division by zero error</entry>
    <entry key="CheckZDVGreen" translate="false">{0} division by zero does not occur</entry>
    <entry key="CheckZDVRed" translate="false">Error: {0} division by zero occurs</entry>
    <entry key="CheckZDVRedForEvent" translate="false">{0} division by zero occurs</entry>
    <entry key="CheckZDVOrange" translate="false">Warning: {0} division by zero may occur</entry>
    <entry key="CheckZDVDarkOrange" translate="false">Warning (probable error): {0} division by zero may occur</entry>

    <entry key="CheckNIVGrey" translate="false">Unreachable check: not initialized variable error</entry>
    <entry key="CheckNIVGreen" translate="false">variable is initialized (type: {0})</entry>
    <entry key="CheckNIVRed" translate="false">Error: variable is not initialized (type: {0})</entry>
    <entry key="CheckNIVOrange" translate="false">Warning: variable may not be initialized (type: {0})</entry>
    <entry key="CheckNIVDarkOrange" translate="false">Warning (probable error): variable may not be initialized (type: {0})</entry>

    <entry key="CheckNIVLGrey" translate="false">Unreachable check: not initialized local variable error</entry>
    <entry key="CheckNIVLGreen" translate="false">Local variable is initialized (type: {0})</entry>
    <entry key="CheckNIVLRed" translate="false">Error: Local variable is not initialized (type: {0})</entry>
    <entry key="CheckNIVLOrange" translate="false">Warning: Local variable may not be initialized (type: {0})</entry>
    <entry key="CheckNIVLDarkOrange" translate="false">Warning (probable error): Local variable may not be initialized (type: {0})</entry>
    <entry key="CheckNIVLBitAssign" translate="false">{0} might not be initialized before assignment.\nOnly some bits of {1} are initialized by assignment.</entry>
    <entry key="CheckNIVLBitAssignSure" translate="false">{0} is not initialized before assignment.\nOnly some bits of {1} are initialized by assignment.</entry>

    <entry key="CheckSHFGray" translate="false">Unreachable check: shift error[0..{0,number,integer}]</entry>
    <entry key="CheckSHFGreen" translate="false">{0} shift amount is within its bounds[0..{1,number,integer}]</entry>
    <entry key="CheckSHFRed" translate="false">Error: {0} shift amount is outside its bounds[0..{1,number,integer}]</entry>
    <entry key="CheckSHFRedForEvent" translate="false">{0} shift amount is outside its bounds[0..{1,number,integer}]</entry>
    <entry key="CheckSHFOrange" translate="false">Warning: {0} shift amount may be outside its bounds[0..{1,number,integer}]</entry>
    <entry key="CheckSHFDarkOrange" translate="false">Warning (probable error): {0} shift amount may be outside its bounds[0..{1,number,integer}]</entry>

    <entry key="CheckOVFLGray" translate="false">Unreachable check: overflow operation not reachable in {0} range</entry>
    <entry key="CheckOVFLGreen" translate="false">Operation [{0}] on {1} does not overflow in {2} range</entry>
    <entry key="CheckOVFLRedOvfl" translate="false">Error: operation [{0}] on {1} overflows (result is always strictly greater than MAX {2})</entry>
    <entry key="CheckOVFLRedUnfl" translate="false">Error: operation [{0}] on {1} overflows (result is always strictly lower than MIN {2})</entry>
    <entry key="CheckOVFLRed" translate="false">Error: operation [{0}] on {1} overflows</entry>
    <entry key="CheckOVFLRedOvflForEvent" translate="false">Operation [{0}] on {1} overflows (result is always strictly greater than MAX {2})</entry>
    <entry key="CheckOVFLRedUnflForEvent" translate="false">Operation [{0}] on {1} overflows (result is always strictly lower than MIN {2})</entry>
    <entry key="CheckOVFLRedForEvent" translate="false">Operation [{0}] on {1} overflows</entry>
    <entry key="CheckOVFLOrangeOvfl" translate="false">Warning: operation [{0}] on {1} may overflow (result strictly greater than MAX {2})</entry>
    <entry key="CheckOVFLOrangeUnfl" translate="false">Warning: operation [{0}] on {1} may overflow (result strictly lower than MIN {2})</entry>
    <entry key="CheckOVFLOrange" translate="false">Warning: operation [{0}] on {1} may overflow (on MIN or MAX bounds of {2})</entry>
    <entry key="CheckOVFLDarkOrangeOvfl" translate="false">Warning (probable error): operation [{0}] on {1} overflows (result strictly greater than MAX {2})</entry>
    <entry key="CheckOVFLDarkOrangeUnfl" translate="false">Warning (probable error): operation [{0}] on {1} overflows (result strictly lower than MIN {2})</entry>
    <entry key="CheckOVFLDarkOrange" translate="false">Warning (probable error): operation [{0}] on {1} overflows</entry>

    <entry key="CheckCONV_OVFLGray" translate="false">Unreachable check: overflow operation not reachable in {0} range</entry>
    <entry key="CheckCONV_OVFLGrayTrivial" translate="false">By definition, unreachable check: overflow operation not reachable in {0} range</entry>
    <entry key="CheckCONV_OVFLGreen" translate="false">Operation [conversion from {0} to {1}] on {2} does not overflow in {3} range</entry>
    <entry key="CheckCONV_OVFLGreenTrivial" translate="false">By definition, operation [conversion from {0} to {1}] on {2} does not overflow in {3} range</entry>
    <entry key="CheckCONV_OVFLRedOvfl" translate="false">Error: operation [conversion from {0} to {1}] on {2} overflows (result is always strictly greater than MAX {3})</entry>
    <entry key="CheckCONV_OVFLRedUnfl" translate="false">Error: operation [conversion from {0} to {1}] on {2} overflows (result is always strictly lower than MIN {3})</entry>
    <entry key="CheckCONV_OVFLRed" translate="false">Error: operation [conversion from {0} to {1}] on {2} overflows</entry>
    <entry key="CheckCONV_OVFLRedOvflForEvent" translate="false">Operation [conversion from {0} to {1}] on {2} overflows (result is always strictly greater than MAX {3})</entry>
    <entry key="CheckCONV_OVFLRedUnflForEvent" translate="false">Operation [conversion from {0} to {1}] on {2} overflows (result is always strictly lower than MIN {3})</entry>
    <entry key="CheckCONV_OVFLRedForEvent" translate="false">Operation [conversion from {0} to {1}] on {2} overflows</entry>
    <entry key="CheckCONV_OVFLOrangeOvfl" translate="false">Warning: operation [conversion from {0} to {1}] on {2} may overflow (result strictly greater than MAX {3})</entry>
    <entry key="CheckCONV_OVFLOrangeUnfl" translate="false">Warning: operation [conversion from {0} to {1}] on {2} may overflow (result strictly lower than MIN {3})</entry>
    <entry key="CheckCONV_OVFLOrange" translate="false">Warning: operation [conversion from {0} to {1}] on {2} may overflow (on MIN or MAX bounds of {3})</entry>
    <entry key="CheckCONV_OVFLDarkOrangeOvfl" translate="false">Warning (probable error): operation [conversion from {0} to {1}] on {2} overflows (result strictly greater than MAX {3})</entry>
    <entry key="CheckCONV_OVFLDarkOrangeUnfl" translate="false">Warning (probable error): operation [conversion from {0} to {1}] on {2} overflows (result strictly lower than MIN {3})</entry>
    <entry key="CheckCONV_OVFLDarkOrange" translate="false">Warning (probable error): operation [conversion from {0} to {1}] on {2} overflows</entry>
    <entry key="CheckOBAIGrey" translate="false">Unreachable check: out of bounds array index check</entry>
    <entry key="CheckOBAIGreenSizeUndefined" translate="false">Array index is within bounds : [array size undefined]</entry>
    <entry key="CheckOBAIGreen" translate="false">Array index is within bounds : [0..{0, number, integer}]</entry>
    <entry key="CheckOBAIOrange" translate="false">Warning: array index may be outside bounds : [0..{0, number, integer}]</entry>
    <entry key="CheckOBAIOrangeSizeUndefined" translate="false">Warning: array index may be outside bounds : [array size undefined]</entry>
    <entry key="CheckOBAIRed" translate="false">Error: array index is outside its bounds : [0..{0, number, integer}]</entry>

    <!-- messages for Bug Finder defects -->
    <entry key="CheckIntZDVCertain" translate="false">Divisor is 0.</entry>
    <entry key="CheckIntZDVUncertain" translate="false">Divisor may be 0.</entry>
    <entry key="CheckFloatZDVCertain" translate="false">Divisor is 0.0.</entry>
    <entry key="CheckFloatZDVUncertain" translate="false">Divisor may be 0.0.</entry>

    <entry key="CheckSHFCertain" translate="false">Right operand of {0_operation} is outside the shift capacity.</entry>
    <entry key="CheckSHFUncertain" translate="false">Right operand of {0_operation} may be outside the shift capacity.</entry>

    <entry key="CheckOVFLCertain" translate="false">Operation {0_operation} overflows.</entry>
    <entry key="CheckOVFLUncertain" translate="false">Operation {0_operation} may overflow.</entry>

    <entry key="CheckCONV_OVFLCertain" translate="false">Conversion from {0} to {1} overflows.</entry>
    <entry key="CheckCONV_OVFLUncertain" translate="false">Conversion from {0} to {1} may overflow.</entry>

    <entry key="CheckFLOAT_ABSORPTIONFirstAbsorbedCertain" translate="false">The {0_operation} operation is redundant in the current context.\nThe first operand is negligible compared to the second operand and has no effect on the result.</entry>
    <entry key="CheckFLOAT_ABSORPTIONSecondAbsorbedCertain" translate="false">The {0_operation} operation is redundant in the current context.\nThe second operand is negligible compared to the first operand and has no effect on the result.</entry>
    <entry key="CheckFLOAT_ABSORPTIONFirstAbsorbedUncertain" translate="false">The {0_operation} operation may be redundant in the current context.\nThe first operand may be negligible compared to the second operand and may have no effect on the result.</entry>
    <entry key="CheckFLOAT_ABSORPTIONSecondAbsorbedUncertain" translate="false">The {0_operation} operation may be redundant in the current context.\nThe second operand may be negligible compared to the first operand and may have no effect on the result.</entry>

    <entry key="LeftOperand" translate="false">Left operand: {0}</entry>
    <entry key="RightOperand" translate="false">Right operand: {0}</entry>

    <entry key="ValidRangeStrPair" translate="false">Valid range: [{0} .. {1}]</entry>
    <entry key="ValidRangeZeroToMax" translate="false">Valid range: [0 .. {0,number,integer}]</entry>
    <!-- special message suffix for defects found from counter examples. -->
    <entry key="ResultIncludesExampleValues" translate="false">Result includes example values that lead to the defect.</entry>

    <!-- STD_LIB message  -->
    <entry key="IsPositiveOrZeroGreen" translate="false">{0} is positive or null</entry>
    <entry key="IsPositiveOrZeroOrange" translate="false">{0} may not be positive nor null</entry>
    <entry key="IsPositiveOrZeroRed" translate="false">{0} is definitely negative</entry>
    <entry key="IsNonZeroGreen" translate="false">{0} is non null</entry>
    <entry key="IsNonZeroOrange" translate="false">{0} may be null</entry>
    <entry key="IsNonZeroRed" translate="false">{0} is definitely null</entry>
    <entry key="IsStrictlyPositiveGreen" translate="false">{0} is strictly positive</entry>
    <entry key="IsStrictlyPositiveOrange" translate="false">{0} may not be strictly positive</entry>
    <entry key="IsStrictlyPositiveRed" translate="false">{0} is definitely negative or null</entry>
    <entry key="IsStrictlyNegativeGreen" translate="false">{0} is strictly negative</entry>
    <entry key="IsStrictlyNegativeOrange" translate="false">{0} may not be strictly negative</entry>
    <entry key="IsStrictlyNegativeRed" translate="false">{0} is definitely positive or null</entry>
    <entry key="IsNegativeOrZeroGreen" translate="false">{0} is negative or null</entry>
    <entry key="IsNegativeOrZeroOrange" translate="false">{0} may not be negative nor null</entry>
    <entry key="IsNegativeOrZeroRed" translate="false">{0} is definitely positive</entry>
    <entry key="ExpectedRangeOrSingleValueGreen" translate="false">{0} is within either expected range: {1} or {2}</entry>
    <entry key="ExpectedRangeOrSingleValueOrange" translate="false">{0} may not be within either expected range: {1} or {2}</entry>
    <entry key="ExpectedRangeOrSingleValueRed" translate="false">{0} is not within either expected range: {1} or {2}</entry>
    <entry key="WritableArrayGreen" translate="false">{0} is a writable pointer with the given size</entry>
    <entry key="WritableArrayOrange" translate="false">{0} may not be a writable pointer with the given size</entry>
    <entry key="WritableArrayRed" translate="false">{0} is not a writable pointer with the given size</entry>
    <entry key="ReadableArrayGreen" translate="false">{0} is a readable pointer</entry>
    <entry key="ReadableArrayOrange" translate="false">{0} may not be a readable pointer</entry>
    <entry key="ReadableArrayRed" translate="false">{0} is not a readable pointer</entry>
    <entry key="CheckInfoReturnedValueNumericGreen" translate="false">value returned fits in range of returned type</entry>
    <entry key="CheckInfoReturnedValueNumericOrange" translate="false">value returned may not fit in range of returned type</entry>
    <entry key="CheckInfoReturnedValueNumericRed" translate="false">value returned does not fit in range of returned type</entry>
    <entry key="StdFuncAlreadyDefined" translate="false">Standard function {0} is already defined, it won't be emulated.</entry>
    <entry key="ReadParam2" translate="false">second argument (output buffer)</entry>
    <entry key="ReadParam3" translate="false">third argument (nbytes)</entry>
    <entry key="WriteParam2" translate="false">second argument (input buffer)</entry>
    <entry key="NullOrValidStringGreen" translate="false">{0} is a null pointer or a valid string</entry>
    <entry key="NullOrValidStringOrange" translate="false">{0} may not be a valid string</entry>
    <entry key="NullOrValidStringRed" translate="false">{0} is neither a null pointer nor a valid string</entry>
    <entry key="ValidStringGreen" translate="false">{0} is a valid string</entry>
    <entry key="ValidStringOrange" translate="false">{0} may not be a valid string</entry>
    <entry key="ValidStringRed" translate="false">{0} is not a valid string</entry>
    <entry key="ReadParamBuffer1" translate="false">first argument (input buffer)</entry>
    <entry key="ReadParamBuffer2" translate="false">second argument (input buffer)</entry>
    <entry key="ReadParamBuffer3" translate="false">third argument (input buffer)</entry>
    <entry key="ReadParamBufferN" translate="false">{0}th argument (input buffer)</entry>

    <!-- vvir_checkers/library passes message  -->
    <entry key="TitleLibraryCheckGreen" translate="false">The {0} function call {1_symbol} is compliant with the API reference.</entry>
    <entry key="TitleLibraryCheckOrange" translate="false">Warning: The {0} function call {1_symbol} may not be compliant with the API reference.</entry>
    <entry key="TitleLibraryCheckRed" translate="false">Error: The {0} function call {1_symbol} is not compliant with the API reference.</entry>
    <entry key="TitleLibraryCheckGrey" translate="false">Unreachable check: invalid argument(s) error</entry>
    <entry key="CheckForThisParameter" translate="false">{0} parameter:</entry>
    <entry key="ArgumentIsNotNullPtrGreen" translate="false">{0} cannot be a null pointer.</entry>
    <entry key="ArgumentIsNotNullPtrOrange" translate="false">{0} might be a null pointer.</entry>
    <entry key="ArgumentIsNotNullPtrRed" translate="false">{0} is a null pointer.</entry>
    <entry key="ArgumentIsNotNullPtrGrey" translate="false">{0} might be a null pointer (not checked).</entry>
    <entry key="ArgumentIsAllocatedGreen" translate="false">{0} is allocated.</entry>
    <entry key="ArgumentIsAllocatedOrange" translate="false">{0} might not be allocated.</entry>
    <entry key="ArgumentIsAllocatedRed" translate="false">{0} is not allocated.</entry>
    <entry key="ArgumentIsAllocatedGrey" translate="false">{0} might not be allocated (not checked).</entry>
    <entry key="ArgumentIsInitializedGreen" translate="false">{0} points to initialized memory.</entry>
    <entry key="ArgumentIsInitializedOrange" translate="false">{0} might not point to initialized memory.</entry>
    <entry key="ArgumentIsInitializedRed" translate="false">{0} does not point to initialized memory.</entry>
    <entry key="ArgumentIsInitializedGrey" translate="false">{0} might not point to initialized memory (not checked).</entry>
    <entry key="ArgumentIsInitializedGreyForSmBus" translate="false">{0} might not point to initialized memory (not checked because data is not read by the function, or because a previous check is blocking).</entry>
    <entry key="ArgumentIsInRangeGreen" translate="false">{0} is in the expected range.</entry>
    <entry key="ArgumentIsInRangeOrange" translate="false">{0} might not be in expected range.</entry>
    <entry key="ArgumentIsInRangeRed" translate="false">{0} is not in the expected range.</entry>
    <entry key="ArgumentIsInRangeGrey" translate="false">{0} might not be in expected range (not checked).</entry>
    <entry key="ArgumentIsReadOrWriteGreen" translate="false">{0} is either I2C_SMBUS_READ or I2C_SMBUS_WRITE.</entry>
    <entry key="ArgumentIsReadOrWriteOrange" translate="false">{0} might be neither I2C_SMBUS_READ nor I2C_SMBUS_WRITE.</entry>
    <entry key="ArgumentIsReadOrWriteRed" translate="false">{0} is neither I2C_SMBUS_READ nor I2C_SMBUS_WRITE.</entry>
    <entry key="ArgumentIsReadOrWriteGrey" translate="false">{0} might be neither I2C_SMBUS_READ nor I2C_SMBUS_WRITE (not checked).</entry>
    <entry key="ArgumentMayBeNonFinite" translate="false">Argument {0,number,integer} may be infinite or NaN.</entry>
    <!-- pst_unit checkers -->
    <entry key="PstUnitPolicyIsValid" translate="false">Specified policy is valid.</entry>
    <entry key="PstUnitPolicyIsValidGreen" translate="false">Specified policy value is valid.</entry>
    <entry key="PstUnitPolicyIsValidRed" translate="false">Specified policy value is invalid.</entry>
    <entry key="PstUnitPolicyIsValidOrange" translate="false">Specified policy value may not be valid.</entry>
    <entry key="PstUnitRangeIsValid" translate="false">Specified range is valid.</entry>
    <entry key="PstUnitRangeIsValidGreen" translate="false">Minimum range value is lower than or equal to maximum.</entry>
    <entry key="PstUnitRangeIsValidRed" translate="false">Minimum range value is greater than maximum.</entry>
    <entry key="PstUnitRangeIsValidOrange" translate="false">Minimum range value may be greater than maximum.</entry>
    <entry key="PstUnitRangeValueIsValid" translate="false">Specified value is valid.</entry>
    <entry key="PstUnitRangeValueIsValidGreen" translate="false">Specified value is in range [min .. max].</entry>
    <entry key="PstUnitRangeValueIsValidRed" translate="false">Specified value is outside of range [min .. max].</entry>
    <entry key="PstUnitRangeValueIsValidOrange" translate="false">Specified value may be outside of range [min .. max].</entry>
    <entry key="PstUnitRangeIsValidMemberSize" translate="false">The size of the buffer members is valid.</entry>
    <entry key="PstUnitRangeIsScalarMemberSizeGreen" translate="false">The size of the buffer members is the size of a scalar type.</entry>
    <entry key="PstUnitRangeIsScalarMemberSizeRed" translate="false">The size of the buffer members is not the size of a scalar type.</entry>
    <entry key="PstUnitRangeIsScalarMemberSizeOrange" translate="false">The size of the buffer members may not be the size of a scalar type.</entry>
    <entry key="PstUnitRangeIsFloatMemberSizeGreen" translate="false">The size of the buffer members is the size of a float type.</entry>
    <entry key="PstUnitRangeIsFloatMemberSizeRed" translate="false">The size of the buffer members is not the size of a float type.</entry>
    <entry key="PstUnitRangeIsFloatMemberSizeOrange" translate="false">The size of the buffer members may not be the size of a float type.</entry>
    <entry key="PstUnitRangeMatchesDataType" translate="false">Specified range matches data type.</entry>
    <entry key="PstUnitRangeMinMatchesDataTypeGreen" translate="false">The minimum value of the range is greater than or equal to the minimum value allowed by the type.</entry>
    <entry key="PstUnitRangeMinMatchesDataTypeRed" translate="false">The minimum value of the range is lower than the minimum value allowed by the type.</entry>
    <entry key="PstUnitRangeMinMatchesDataTypeOrange" translate="false">The minimum value of the range may not be greater than or equal to the minimum value allowed by the type.</entry>
    <entry key="PstUnitRangeMaxMatchesDataTypeGreen" translate="false">The maximum value of the range is lower than or equal to the maximum value allowed by the type.</entry>
    <entry key="PstUnitRangeMaxMatchesDataTypeRed" translate="false">The maximum value of the range is greater than the maximum value allowed by the type.</entry>
    <entry key="PstUnitRangeMaxMatchesDataTypeOrange" translate="false">The maximum value of the range may not be lower than or equal to the maximum value allowed by the type.</entry>
    <entry key="PstUnitRangeValueMatchesDataType" translate="false">Specified value matches data type.</entry>
    <entry key="PstUnitRangeValueMatchesDataTypeMinGreen" translate="false">Specified value is greater than or equal to the minimum value allowed by the type.</entry>
    <entry key="PstUnitRangeValueMatchesDataTypeMinRed" translate="false">Specified value is lower than the minimum value allowed by the type.</entry>
    <entry key="PstUnitRangeValueMatchesDataTypeMinOrange" translate="false">Specified value may be lower than the minimum value allowed by the type.</entry>
    <entry key="PstUnitRangeValueMatchesDataTypeMaxGreen" translate="false">Specified value is lower than or equal to the maximum value allowed by the type.</entry>
    <entry key="PstUnitRangeValueMatchesDataTypeMaxRed" translate="false">Specified value is greater than the maximum value allowed by the type.</entry>
    <entry key="PstUnitRangeValueMatchesDataTypeMaxOrange" translate="false">Specified value may be greater than the maximum value allowed by the type.</entry>
    <entry key="PstUnitRangeValidNmemb" translate="false">Specified number of elements is valid</entry>
    <entry key="PstUnitRangeValidNmembGreen" translate="false">Specified number of elements is non-null</entry>
    <entry key="PstUnitRangeValidNmembRed" translate="false">Specified number of elements is null</entry>
    <entry key="PstUnitRangeValidNmembOrange" translate="false">Specified number of elements may be null</entry>
    <entry key="PstUnitRangeBufferNotNull" translate="false">Specified buffer is non-null</entry>
    <entry key="PstUnitRangeBufferValid" translate="false">Specified buffer is valid</entry>
    <entry key="PstUnitRangeBufferValidGreen" translate="false">Specified buffer points an allocated memory area.</entry>
    <entry key="PstUnitRangeBufferValidRed" translate="false">Specified buffer points an unallocated memory area or overflows beyond an allocated memory area.</entry>
    <entry key="PstUnitRangeBufferValidOrange" translate="false">Specified buffer may point an unallocated memory area or may overflow beyond an allocated memory area.</entry>

    <!-- messages for tooltips -->
    <entry key="InfoOperator" translate="false">operator {0_operation} on type {1_symbol}</entry>
    <entry key="InfoConversionOp" translate="false">Conversion from {0_symbol} to {1_symbol}</entry>
    <!-- the indentation before left, right, ... and the spaces after -->
    <!-- the ":" comes directly from kernel_api/common/Infos.sml      -->
    <!-- the common format of the texts for operands is:              -->
    <!-- "\n<operand_tag>    operand: value</operand_tag>"            -->
    <!-- hence {0} is the begin operand tag                           -->
    <!-- hence {1} is the value                                       -->
    <!-- hence {2} is the end operand tag                             -->
    <!-- texts for binary operators: -->
    <entry key="InfoLeftOperand"      translate="false">\n{0}     left:   {1}{2}</entry>
    <entry key="InfoRightOperand"     translate="false">\n{0}     right:  {1}{2}</entry>
    <!-- text for unary operators (used for Code Prover, for now "right" is displayed): -->
    <entry key="InfoOperand"          translate="false">\n{0}     right:  {1}{2}</entry>
    <!-- texts for result and other details about the operation: -->
    <entry key="InfoOperandsRelation" translate="false">\n{0}     Relation(s): {1}{2}</entry>
    <entry key="InfoOperationResult"  translate="false">\n{0}     result: {1}{2}</entry>
    <!-- for the following two texts, there is no value: {0} => begin tag, {1} => end tag -->
    <entry key="InfoOCTruncatedMode"  translate="false">\n{0}     (result is truncated){1}</entry>
    <entry key="InfoOCWrapAroundMode" translate="false">\n{0}     (result is wrapped){1}</entry>

    <entry key="InfoKnownArraySize" translate="false">array size : {0, number, integer}</entry>
    <entry key="InfoUnknownArraySize" translate="false">array size: undefined</entry>
    <entry key="InfoArrayIndex" translate="false">array index value: </entry>

    <!-- messages for contexts -->
    <entry key="ContextCxxTopCtor" translate="false">- when called as a top-constructor</entry>
    <entry key="ContextCxxTopDtor" translate="false">- when called as a top-destructor</entry>
    <entry key="ContextCxxSubCtor" translate="false">- when called during construction of a {0} object</entry>
    <entry key="ContextCxxSubDtor" translate="false">- when called during destruction of a {0} object</entry>
    <entry key="ContextCxxSpecialized" translate="false">- when called when this-type is a {0} or a derived class</entry>
    <entry key="ContextCxxDuringConstr" translate="false">- when called during construction of a {0} object, when this-type is known to be a {1}</entry>
    <entry key="ContextCxxDuringDestr" translate="false">- when called during destruction of a {0} object, when this-type is known to be a {1}</entry>
    <entry key="ContextCxxDuringConstrDestr" translate="false">- when called during construction/destruction of a {0} object, when this-type is known to be a {1}</entry>
    <entry key="ContextCxxDuringConstrNoParent" translate="false">- when called during construction of a derived object, when this-type is known to be a {0}</entry>
    <entry key="ContextCxxDuringDestrNoParent" translate="false">- when called during destruction of a derived object, when this-type is known to be a {0}</entry>
    <entry key="ContextCxxDuringConstrDestrNoParent" translate="false">- when called during construction/destruction of a derived object, when this-type is known to be a {0}</entry>

    <entry key="ExceptNewReturnNull" translate="false">Replacement "{0}" implementation might return null.\nThis replacement operator must not return null according to the required behavior specifications of the Standard.\nTo fix, throw a std::bad_alloc exception instead of returning null.</entry>
    <entry key="NoreturnFuncReturn" translate="false">Function "{0}" returns through this point of exit.\nA function that returns when it is declared with attribute 'noreturn' is undefined behavior.</entry>
    <entry key="InvalidThreadEntryPointParam" translate="false">Invalid index "{0}" in thread_entry_point_param library property.</entry>
  </message>
</rsccat>
