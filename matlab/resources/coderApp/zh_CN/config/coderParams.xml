<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="zh_CN" product="coderApp" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="category_output">输出</entry>
    <entry key="buildType">编译类型</entry>
    <entry key="buildType_desc">从生成的 C/C++ 代码输出到编译</entry>
    <entry key="targetLang">语言</entry>
    <entry key="targetLang_desc">要在生成代码中使用的语言</entry>
    <entry key="targetLangStandard">语言标准</entry>
    <entry key="targetLangStandard_desc">指定要在生成代码中使用的语言标准</entry>
    <entry key="genCodeOnly">仅生成源代码</entry>
    <entry key="genCodeOnly_desc">生成代码后不执行联编文件</entry>
    <entry key="category_speed">速度</entry>
    <entry key="responsivenessChecks">启用对 CTRL+C 和图刷新的响应</entry>
    <entry key="responsivenessChecks_desc">定期检查 Ctrl+C 断点并刷新图。如果没有这些检查，结束长时间执行的唯一方法可能是终止 MATLAB。关闭此检查会减少生成的代码并加快 MEX 函数的执行。</entry>
    <entry key="extrinsicCalls">保留外部调用</entry>
    <entry key="extrinsicCalls_desc">禁用时，删除需要 MEX 函数接口的调用</entry>
    <entry key="integrityChecks">检查内存完整性</entry>
    <entry key="integrityChecks_desc">检测生成代码中违反内存完整性的情况，出现违规情况则停止执行并提供诊断信息。如果没有这些检查，违规将导致不可预测的行为。内存完整性问题最可能的原因是访问超出数组界限。关闭此检查会减少生成的代码并加快 MEX 函数的执行。</entry>
    <entry key="saturateOnIntegerOverflow">对整数溢出进行饱和处理</entry>
    <entry key="saturateOnIntegerOverflow_desc">选中时，将溢出饱和处理为数据类型能够表示的最小值或最大值。否则，它们将绕回到数据类型可以表示的合适值。</entry>
    <entry key="purelyIntegerCode">仅支持纯整数</entry>
    <entry key="purelyIntegerCode_desc">在生成代码中仅支持整数数值数据类型。选中时，浮点数不会出现在生成代码中。</entry>
    <entry key="supportNonFinite">支持非有限数</entry>
    <entry key="supportNonFinite_desc">在生成代码中支持非有限值(inf、nan、Inf)</entry>
    <entry key="loopUnrollThreshold">循环展开阈值</entry>
    <entry key="loopUnrollThreshold_desc">生成 "for" 循环的最小迭代次数</entry>
    <entry key="preserveInputData">保留入口函数的输入数据</entry>
    <entry key="preserveInputData_desc">指定生成代码是否必须保留作为入口函数参量提供的输入数据。</entry>
    <entry key="enableAutoParallelization">启用自动并行化</entry>
    <entry key="enableAutoParallelization_desc">使用 OpenMP pragma 指令自动并行化部分生成的代码</entry>
    <entry key="highlightImplicitExpansionIssues">突出显示隐式扩展导致的潜在问题</entry>
    <entry key="highlightImplicitExpansionIssues_desc">在代码生成报告中突出显示隐式扩展导致的潜在问题</entry>
    <entry key="highlightLoopControlIssues">突出显示使用 coder.loop 函数的潜在问题</entry>
    <entry key="highlightLoopControlIssues_desc">在代码生成报告中突出显示使用 coder.loop 函数的潜在问题</entry>
    <entry key="numberOfCpuThreads">最大 CPU 线程数</entry>
    <entry key="numberOfCpuThreads_desc">自动并行循环中使用的最大 CPU 线程数</entry>
    <entry key="simdAcceleration">硬件 SIMD 加速</entry>
    <entry key="simdAcceleration_desc">选择硬件 SIMD 加速的级别</entry>
    <entry key="category_targetSpecificOptimizations">特定于目标的优化</entry>
    <entry key="category_memory">内存</entry>
    <entry key="category_dynamicMemory">可变大小支持</entry>
    <entry key="globalDataSyncMethod">全局数据同步模式</entry>
    <entry key="globalDataSyncMethod_desc">控制生成的 MEX 函数的全局数据何时与 MATLAB 工作区同步</entry>
    <entry key="enableVariableSizing">启用可变大小</entry>
    <entry key="enableVariableSizing_desc">启用对可变大小数组的支持</entry>
    <entry key="enableDynamicMemoryAllocation">启用动态内存分配</entry>
    <entry key="enableDynamicMemoryAllocation_desc">启用对动态内存分配的支持</entry>
    <entry key="dynamicMemoryAllocation">可变大小数组的动态内存分配</entry>
    <entry key="dynamicMemoryAllocation_desc">何时对可变大小数组使用动态内存分配</entry>
    <entry key="dynamicMemoryAllocationFixedSize">对固定大小数组启用动态内存分配</entry>
    <entry key="dynamicMemoryAllocationFixedSize_desc">启用对固定大小数组的动态内存分配的支持</entry>
    <entry key="dynamicMemoryAllocationVarSize">可变大小数组的动态内存分配</entry>
    <entry key="dynamicMemoryAllocationVarSize_desc">何时对可变大小数组使用动态内存分配</entry>
    <entry key="dynamicMemoryAllocationThreshold">动态内存分配阈值</entry>
    <entry key="dynamicMemoryAllocationThreshold_desc">当矩阵/数组超过此阈值(以字节为单位)时，使用动态内存分配</entry>
    <entry key="dynamicMemoryAllocationInterface">动态内存分配接口</entry>
    <entry key="dynamicMemoryAllocationInterface_desc">选择与可变大小数组对接的 API 代码样式</entry>
    <entry key="rowMajor">数组布局</entry>
    <entry key="rowMajor_desc">为使用指定布局的数组生成代码。布局可以是列优先(第一个维度连续)或行优先(最后一个维度连续)。</entry>
    <entry key="highlightPotentialRowMajorIssues">突出显示潜在的行优先问题</entry>
    <entry key="highlightPotentialRowMajorIssues_desc">在代码生成报告中突出显示潜在的行优先问题</entry>
    <entry key="preserveArrayDimensions">保留数组维度</entry>
    <entry key="preserveArrayDimensions_desc">使用 N 维索引下标在生成代码中保留数组维度</entry>
    <entry key="stackUsageMax">最大堆栈使用量</entry>
    <entry key="stackUsageMax_desc">指定每个应用程序的最大堆栈使用量(以字节为单位)</entry>
    <entry key="multiInstanceCode">生成可重入代码</entry>
    <entry key="multiInstanceCode_desc">生成多个程序可以同时使用的可重用/可重入代码</entry>
    <entry key="preserveUnusedStructFields">保留未使用的字段和属性</entry>
    <entry key="preserveUnusedStructFields_desc">在生成代码中保留未使用的结构体字段和类属性</entry>
    <entry key="category_appearance">代码外观</entry>
    <entry key="category_comments">注释</entry>
    <entry key="category_codeStyle">代码样式</entry>
    <entry key="category_dataTypeAlias">自定义数据类型替换</entry>
    <entry key="category_dataTypeAlias_grid">数据类型别名</entry>
    <entry key="category_namingRules">命名规则</entry>
    <entry key="filePartitionMethod">生成文件的分区方法</entry>
    <entry key="filePartitionMethod_desc">选择生成文件的分区方法。对每个 MATLAB 文件生成一个文件有助于将生成代码与源代码关联起来。生成单个 C/C++ 文件有助于将生成代码与现有软件集成。</entry>
    <entry key="largeConstantGeneration">大型常量生成</entry>
    <entry key="largeConstantGeneration_desc">指定在生成的代码中打包多大的常量。</entry>
    <entry key="largeConstantThreshold">大型常量阈值</entry>
    <entry key="largeConstantThreshold_desc">指定以字节为单位的大小，大于该值的常量将被写入数据文件。当 "大型常量生成" 设置为 "仅将深度学习常量写入数据文件" 或 "写入数据文件" 时，将遵循此阈值</entry>
    <entry key="generateComments">包括注释</entry>
    <entry key="generateComments_desc">根据以下自定义在生成文件中包括注释</entry>
    <entry key="commentStyle">注释样式</entry>
    <entry key="commentStyle_desc">在生成代码中指定注释的样式</entry>
    <entry key="matlabSourceComments">MATLAB 源代码作为注释</entry>
    <entry key="matlabSourceComments_desc">将 MATLAB 源代码作为注释插入生成代码中</entry>
    <entry key="matlabSourceCommentLineNumbers">MATLAB 源代码注释行号</entry>
    <entry key="matlabSourceCommentLineNumbers_desc">在注释中显示 MATLAB 源代码行号</entry>
    <entry key="matlabFcnDesc">MATLAB 函数帮助文本</entry>
    <entry key="matlabFcnDesc_desc">将 MATLAB 函数描述(帮助文本)作为函数前注的一部分插入生成代码中</entry>
    <entry key="requirementsComments">需求汇总作为注释</entry>
    <entry key="requirementsComments_desc">将链接到 MATLAB 代码的需求汇总以注释的形式包括在生成的代码中。</entry>
    <entry key="convertIfToSwitch">将 if-elseif-else 构型转换为 switch-case 语句</entry>
    <entry key="convertIfToSwitch_desc">尽可能将 if-elseif-else 构型转换为 switch-case 语句来提高可读性</entry>
    <entry key="preserveExternInFcnDecls">在函数声明中保留 extern 关键字</entry>
    <entry key="preserveExternInFcnDecls_desc">指定生成的外部函数的声明是否包含 "extern" 关键字</entry>
    <entry key="enableSignedLeftShifts">使用有符号左移位进行定点运算和 2 次幂的乘法</entry>
    <entry key="enableSignedLeftShifts_desc">指定在生成代码中是使用有符号左移位还是 2 次幂的乘法</entry>
    <entry key="enableSignedRightShifts">允许有符号整数右移</entry>
    <entry key="enableSignedRightShifts_desc">指定是使用有符号右移位，还是用避免有符号移位的函数调用来替换这些移位</entry>
    <entry key="parenthesesLevel">圆括号</entry>
    <entry key="parenthesesLevel_desc">指定代码中加括号的层级要求</entry>
    <entry key="maxIdLength">最大标识符长度</entry>
    <entry key="maxIdLength_desc">变量、typedef 和函数名称的最大标识符长度</entry>
    <entry key="headerGuardStyle">头文件防卫式声明样式</entry>
    <entry key="headerGuardStyle_desc">生成代码中预处理器指令的样式</entry>
    <entry key="dataTypeReplacement">数据类型替换</entry>
    <entry key="dataTypeReplacement_desc">数据类型替换</entry>
    <entry key="enableCustomReplacementTypes">启用自定义数据类型替换</entry>
    <entry key="enableCustomReplacementTypes_desc">为内置 MATLAB 数据类型指定别名</entry>
    <entry key="replacementTypes_double">double</entry>
    <entry key="replacementTypes_double_desc">为类型 'double' 指定自定义替换名称。自定义名称应为有效的 C 标识符，而不是目标语言中的保留关键字。</entry>
    <entry key="replacementTypes_single">单精度</entry>
    <entry key="replacementTypes_single_desc">为类型 'single' 指定自定义替换名称。自定义名称应为有效的 C 标识符，而不是目标语言中的保留关键字。</entry>
    <entry key="replacementTypes_uint8">uint8</entry>
    <entry key="replacementTypes_uint8_desc">为类型 'uint8' 指定自定义替换名称。自定义名称应为有效的 C 标识符，而不是目标语言中的保留关键字。</entry>
    <entry key="replacementTypes_uint16">uint16</entry>
    <entry key="replacementTypes_uint16_desc">为类型 'uint16' 指定自定义替换名称。自定义名称应为有效的 C 标识符，而不是目标语言中的保留关键字。</entry>
    <entry key="replacementTypes_uint32">uint32 </entry>
    <entry key="replacementTypes_uint32_desc">为类型 'uint32' 指定自定义替换名称。自定义名称应为有效的 C 标识符，而不是目标语言中的保留关键字。</entry>
    <entry key="replacementTypes_uint64">uint64</entry>
    <entry key="replacementTypes_uint64_desc">为类型 'uint64' 指定自定义替换名称。自定义名称应为有效的 C 标识符，而不是目标语言中的保留关键字。</entry>
    <entry key="replacementTypes_int8">int8</entry>
    <entry key="replacementTypes_int8_desc">为类型 'int8' 指定自定义替换名称。自定义名称应为有效的 C 标识符，而不是目标语言中的保留关键字。</entry>
    <entry key="replacementTypes_int16">int16  </entry>
    <entry key="replacementTypes_int16_desc">为类型 'int16' 指定自定义替换名称。自定义名称应为有效的 C 标识符，而不是目标语言中的保留关键字。</entry>
    <entry key="replacementTypes_int32">int32</entry>
    <entry key="replacementTypes_int32_desc">为类型 'int32' 指定自定义替换名称。自定义名称应为有效的 C 标识符，而不是目标语言中的保留关键字。</entry>
    <entry key="replacementTypes_int64">int64</entry>
    <entry key="replacementTypes_int64_desc">为类型 'int64' 指定自定义替换名称。自定义名称应为有效的 C 标识符，而不是目标语言中的保留关键字。</entry>
    <entry key="replacementTypes_char">char</entry>
    <entry key="replacementTypes_char_desc">为类型 'char' 指定自定义替换名称。自定义名称应为有效的 C 标识符，而不是目标语言中的保留关键字。</entry>
    <entry key="replacementTypes_logical">logical</entry>
    <entry key="replacementTypes_logical_desc">为类型 'logical' 指定自定义替换名称。自定义名称应为有效的 C 标识符，而不是目标语言中的保留关键字。</entry>
    <entry key="importCustomTypes">从外部头文件导入自定义类型</entry>
    <entry key="importCustomTypes_desc">指定是否从外部头文件导入类型定义</entry>
    <entry key="customTypesHeaderFiles">头文件:</entry>
    <entry key="customTypesHeaderFiles_desc">头文件名列表</entry>
    <entry key="customFileNameStr">生成的源文件和头文件名称格式</entry>
    <entry key="customFileNameStr_desc">所生成文件的文件名格式规则。规则可以包含有效的文件名字符和以下宏:\n$M - 修饰\n$R - 根工程名称\n$N - 所标识对象的名称</entry>
    <entry key="customSymbolStrGlobalVar">全局变量</entry>
    <entry key="customSymbolStrGlobalVar_desc">全局变量的符号格式规则。规则可以包含有效的 C 标识符字符和以下宏:\n$M - 修饰\n$R - 根工程名称\n$N - 所标识对象的名称</entry>
    <entry key="customSymbolStrType">全局类型</entry>
    <entry key="customSymbolStrType_desc">全局类型的符号格式规则。规则可以包含有效的 C 标识符字符和以下宏:\n$M - 修饰\n$R - 根工程名称\n$N - 所标识对象的名称</entry>
    <entry key="customSymbolStrField">全局类型的字段名称</entry>
    <entry key="customSymbolStrField_desc">全局类型的字段名称的符号格式规则。规则可以包含有效的 C 标识符字符和以下宏:\n$M - 修饰\n$R - 根工程名称\n$N - 所标识对象的名称</entry>
    <entry key="customSymbolStrFcn">局部函数</entry>
    <entry key="customSymbolStrFcn_desc">局部函数的符号格式规则。规则可以包含有效的 C 标识符字符和以下宏:\n$M - 修饰\n$R - 根工程名称\n$N - 所标识对象的名称</entry>
    <entry key="customSymbolStrTmpVar">局部临时变量</entry>
    <entry key="customSymbolStrTmpVar_desc">局部临时变量的符号格式规则。规则可以包含有效的 C 标识符字符和以下宏:\n$M - 修饰\n$R - 根工程名称\n$N - 所标识对象的名称</entry>
    <entry key="customSymbolStrMacro">常量宏</entry>
    <entry key="customSymbolStrMacro_desc">常量宏的符号格式规则。规则可以包含有效的 C 标识符字符和以下宏:\n$M - 修饰\n$R - 根工程名称\n$N - 所标识对象的名称</entry>
    <entry key="customSymbolStrEMXArray">EMX 数组类型</entry>
    <entry key="customSymbolStrEMXArray_desc">EMX 数组的符号格式规则(可嵌入 mxArray)。规则可以包含有效的 C 标识符字符和以下宏:\n$M - 修饰\n$R - 根工程名称\n$N - 所标识对象的名称</entry>
    <entry key="customSymbolStrEMXArrayFcn">EMX 数组工具函数</entry>
    <entry key="customSymbolStrEMXArrayFcn_desc">EMX 数组工具函数的符号格式规则。规则可以包含有效的 C 标识符字符和以下宏:\n$M - 修饰\n$R - 根工程名称\n$N - 所标识对象的名称</entry>
    <entry key="reservedNameArray">保留名称</entry>
    <entry key="reservedNameArray_desc">要从生成代码中排除的保留名称列表</entry>
    <entry key="codeTemplate">代码生成模板文件</entry>
    <entry key="codeTemplate_desc">代码生成模板文件(CGT)的位置</entry>
    <entry key="clangFormatFile">控制 clang 格式配置文件的使用</entry>
    <entry key="clangFormatFile_desc">指定是生成 clang 格式配置文件还是使用现有文件</entry>
    <entry key="codeFormattingTool">选择要使用的代码格式工具</entry>
    <entry key="codeFormattingTool_desc">指定应使用哪个代码格式工具</entry>
    <entry key="category_cppFeatures">C++ 语言功能</entry>
    <entry key="cppNamespace">C++ 命名空间</entry>
    <entry key="cppNamespace_desc">在指定的命名空间下生成 C++ 代码</entry>
    <entry key="cppInterfaceStyle">接口样式</entry>
    <entry key="cppInterfaceStyle_desc">从 MATLAB 入口函数生成的 C++ 代码的接口样式</entry>
    <entry key="cppInterfaceClassName">C++ 接口类名称</entry>
    <entry key="cppInterfaceClassName_desc">生成的 C++ 代码的接口类名称</entry>
    <entry key="cppPreserveClasses">从 MATLAB 类生成 C++ 类</entry>
    <entry key="cppPreserveClasses_desc">指定是为 MATLAB 类生成 C++ 类还是 C 样式结构体</entry>
    <entry key="cppNamespaceForMathworksCode">MathWorks 代码的命名空间</entry>
    <entry key="cppNamespaceForMathworksCode_desc">将所有 MathWorks 代码放入指定的 C++ 命名空间</entry>
    <entry key="cppPreserveNamespaces">从 MATLAB 命名空间生成 C++ 命名空间</entry>
    <entry key="cppPreserveNamespaces_desc">指定是否为 MATLAB 命名空间生成 C++ 命名空间</entry>
    <entry key="cppGenerateEnumClass">从 MATLAB 枚举生成 C++ 枚举类</entry>
    <entry key="cppGenerateEnumClass_desc">指定是否为 MATLAB 枚举生成 C++ 枚举类</entry>
    <entry key="category_debug">调试</entry>
    <entry key="category_report">代码生成报告</entry>
    <entry key="category_xil">SIL/PIL</entry>
    <entry key="enableDebugging">启用 C/C++ 编译器调试模式</entry>
    <entry key="enableDebugging_desc">在调试模式下编译生成的代码。生成的代码未优化，导致编译时间更快，但执行速度更慢。</entry>
    <entry key="runtimeChecks">生成运行时错误检查</entry>
    <entry key="runtimeChecks_desc">在生成的 C/C++ 代码中启用运行时错误检测和报告。如果选择此选项，生成的代码将检查错误，如超出边界的数组索引。</entry>
    <entry key="verbose">显示详尽的编译器输出</entry>
    <entry key="verbose_desc">显示代码生成阶段和编译器输出</entry>
    <entry key="verbosity">显示详尽的编译器输出</entry>
    <entry key="verbosity_desc">显示代码生成阶段和编译器输出</entry>
    <entry key="reportPotentialDifferences">报告与 MATLAB 的差异</entry>
    <entry key="reportPotentialDifferences_desc">报告 MATLAB 代码与生成代码的运行时行为不同的 MATLAB 代码所在的位置</entry>
    <entry key="generateReport">始终创建报告</entry>
    <entry key="generateReport_desc">如果未选择此选项，则仅当出现编译错误时 MATLAB Coder 软件才会创建报告。</entry>
    <entry key="generateCodeMetricsReport">生成静态代码度量报告 </entry>
    <entry key="generateCodeMetricsReport_desc">生成静态代码度量报告，包括生成的文件信息、行数和内存使用量</entry>
    <entry key="generateCodeReplacementReport">生成代码替换报告</entry>
    <entry key="generateCodeReplacementReport_desc">生成代码替换报告，其中摘要显示所选代码替换库的替换项</entry>
    <entry key="highlightPotentialDataTypeIssues">突出显示潜在的数据类型问题</entry>
    <entry key="highlightPotentialDataTypeIssues_desc">在代码生成报告的 MATLAB 代码窗格中突出显示单精度运算、双精度运算和高成本的定点运算</entry>
    <entry key="enableAutoParReporting">启用自动并行化报告</entry>
    <entry key="enableAutoParReporting_desc">在代码生成报告的 MATLAB 代码窗格中突出显示自动并行化的循环，并显示不自动并行化特定循环的原因</entry>
    <entry key="launchReport">生成报告后自动启动报告</entry>
    <entry key="launchReport_desc">自动打开代码生成报告或错误报告</entry>
    <entry key="reportInfoVarName">将报告信息导出到变量</entry>
    <entry key="reportInfoVarName_desc">指定要导出报告信息的变量的名称</entry>
    <entry key="silPilDebugging">为 SIL 或 PIL 启用源代码级别调试</entry>
    <entry key="silPilDebugging_desc">指定在软件在环(SIL)或处理器在环(PIL)执行期间是否启用生成代码的源代码级调试</entry>
    <entry key="silPilCheckConstantInputs">检查常量输入</entry>
    <entry key="silPilCheckConstantInputs_desc">指定是为 SIL 还是 PIL 执行启用常量输入检查模式</entry>
    <entry key="silPilSyncGlobalData">同步全局数据</entry>
    <entry key="silPilSyncGlobalData_desc">指定是否将 SIL 或 PIL 执行环境中的全局变量的值与 MATLAB 工作区中的值同步</entry>
    <entry key="codeExecutionProfiling">启用入口函数执行探查</entry>
    <entry key="codeExecutionProfiling_desc">在软件在环(SIL)或处理器在环(PIL)执行期间启用执行时间探查，这会为生成的入口函数生成执行时间探查。</entry>
    <entry key="codeProfilingInstrumentation">启用函数执行探查</entry>
    <entry key="codeProfilingInstrumentation_desc">指定是否启用对执行时间的测量，并为生成代码中的函数生成度量</entry>
    <entry key="codeProfilingSaveOptions">指定探查保存选项</entry>
    <entry key="codeProfilingSaveOptions_desc">管理探查数据的收集。\n'所有数据' 在仿真期间上传所有测量和分析数据，并在仿真结束时将数据存储在工作区变量中。\n'仅摘要数据' 在仿真期间上传所有数据，但通过在结束时仅在工作区中存储摘要数据来减少内存使用量。\n'仅限度量' 在仿真期间仅在目标硬件上存储探查摘要，并在结束时上传摘要，从而减少通信带宽的使用</entry>
    <entry key="codeStackProfiling">启用入口函数堆栈探查</entry>
    <entry key="codeStackProfiling_desc">在软件在环(SIL)或处理器在环(PIL)执行期间启用堆栈使用量探查，为生成的入口函数和内部函数生成堆栈使用量探查</entry>
    <entry key="codeCoverage">启用 C/C++ 代码覆盖率</entry>
    <entry key="codeCoverage_desc">指定是在软件在环(SIL)执行期间还是在处理器在环(PIL)执行期间启用代码覆盖率</entry>
    <entry key="verificationMode">验证模式</entry>
    <entry key="verificationMode_desc">代码验证模式</entry>
    <entry key="enableMexProfiling">启用执行探查</entry>
    <entry key="enableMexProfiling_desc">指定是否对生成的 MEX 函数启用探查</entry>
    <entry key="enableInstrumentCode">启用对具有时间探查功能的 instrumentCode 函数的支持</entry>
    <entry key="enableInstrumentCode_desc">指定是否串行化其他数据以支持具有时间探查功能的 instrumentCode 函数</entry>
    <entry key="category_customCode">自定义代码</entry>
    <entry key="category_crl">代码替换库</entry>
    <entry key="category_performanceLibs">高性能库</entry>
    <entry key="category_customSourceCode">生成文件的自定义 C 代码</entry>
    <entry key="customSourceCode">源文件</entry>
    <entry key="customSourceCode_desc">出现在生成的 C/C++ 源文件顶部的代码</entry>
    <entry key="customHeaderCode">头文件</entry>
    <entry key="customHeaderCode_desc">出现在生成的头文件顶部的代码</entry>
    <entry key="customInitializer">初始化函数</entry>
    <entry key="customInitializer_desc">出现在生成的初始化函数中的代码</entry>
    <entry key="customTerminator">终止函数</entry>
    <entry key="customTerminator_desc">出现在生成的终止函数中的代码</entry>
    <entry key="customInclude">其他包括目录</entry>
    <entry key="customInclude_desc">编译生成代码时要添加到包含路径中的包含目录的列表</entry>
    <entry key="customSource">其他源文件</entry>
    <entry key="customSource_desc">要编译并与生成代码链接的源文件的列表</entry>
    <entry key="customLibrary">其他库</entry>
    <entry key="customLibrary_desc">要与生成代码链接的静态库文件的列表</entry>
    <entry key="postCodeGenCommand">代码生成后的命令</entry>
    <entry key="postCodeGenCommand_desc">用于在编译生成代码之前更新编译信息的钩子。例如，添加编译器或链接器选项。</entry>
    <entry key="codeReplacementLibrary">代码替换库</entry>
    <entry key="codeReplacementLibrary_desc">指定对目标可用的代码替换库，以生成特定于处理器的代码来提高执行性能</entry>
    <entry key="category_hardware">硬件</entry>
    <entry key="category_devices">设备</entry>
    <entry key="category_hardwareImpl">硬件实现</entry>
    <entry key="category_buildProcess">编译过程</entry>
    <entry key="category_prodDevice">设备(生产)</entry>
    <entry key="category_targetDevice">设备(测试)</entry>
    <entry key="category_sameDevice">设备</entry>
    <entry key="category_deviceDetails">设备详细信息</entry>
    <entry key="category_hardwareSizes">大小</entry>
    <entry key="category_toolchain">编译过程</entry>
    <entry key="hardwareName">硬件板</entry>
    <entry key="hardwareName_desc">硬件板的名称</entry>
    <entry key="hardwareName_target">硬件板(测试)</entry>
    <entry key="prodEqTarget">测试硬件与生产硬件相同</entry>
    <entry key="prodEqTarget_desc">指定用于测试此工程生成代码的硬件与最终运行该代码的目标硬件相同。如果未选择此选项，将生成额外的代码在测试硬件上模拟最终硬件。</entry>
    <entry key="toolchain">工具链</entry>
    <entry key="toolchain_desc">用于编译 C/C++ 库或可执行程序的工具链</entry>
    <entry key="customToolchainOptions">自定义工具链选项</entry>
    <entry key="customToolchainOptions_desc">为所选工具链中的工具指定自定义设置</entry>
    <entry key="buildConfiguration">编译配置</entry>
    <entry key="buildConfiguration_desc">工具链的编译器优化或调试设置</entry>
    <entry key="deviceVendor">设备供应商</entry>
    <entry key="deviceType">设备类型</entry>
    <entry key="device_desc">选择预定义的硬件设备，以便为您的微处理器指定 C/C++ 语言约束；如果您的微处理器未列出，则选择&lt;code&gt;泛型&amp;gt;自定义&lt;/code&gt;。选择 &lt;code&gt;ASIC/FPGA-&amp;gt;ASIC/FPGA&lt;/code&gt; 表示无约束。</entry>
    <entry key="prodBitPerChar">char</entry>
    <entry key="prodBitPerChar_desc">生产硬件支持的 C char 数据类型的长度(以位为单位)</entry>
    <entry key="prodBitPerShort">short</entry>
    <entry key="prodBitPerShort_desc">生产硬件支持的 C short 数据类型的长度(以位为单位)</entry>
    <entry key="prodBitPerInt">int</entry>
    <entry key="prodBitPerInt_desc">生产硬件支持的 C int 数据类型的长度(以位为单位)</entry>
    <entry key="prodBitPerLong">long</entry>
    <entry key="prodBitPerLong_desc">生产硬件支持的 C long 数据类型的长度(以位为单位)</entry>
    <entry key="prodBitPerLongLong">long long</entry>
    <entry key="prodBitPerLongLong_desc">生产硬件支持的 C long long 数据类型的长度(以位为单位)</entry>
    <entry key="prodBitPerFloat">float</entry>
    <entry key="prodBitPerFloat_desc">生产硬件支持的 C 浮点数据类型的长度(以位为单位)</entry>
    <entry key="prodBitPerDouble">double</entry>
    <entry key="prodBitPerDouble_desc">生产硬件支持的 C double 数据类型的长度(以位为单位)</entry>
    <entry key="prodWordSize">计算机字长</entry>
    <entry key="prodWordSize_desc">目标处理器一次可以处理的位数。提供处理器的原生字长允许在转换数据类型的 endian 字节顺序时生成更高效的代码。</entry>
    <entry key="prodBitPerPointer">指针</entry>
    <entry key="prodBitPerPointer_desc">生产硬件支持的指针数据的长度(以位为单位)</entry>
    <entry key="prodBitPerSizeT">size_t</entry>
    <entry key="prodBitPerSizeT_desc">生产硬件支持的 size_t 数据的长度(以位为单位)</entry>
    <entry key="prodBitPerPtrDiffT">ptrdiff_t</entry>
    <entry key="prodBitPerPtrDiffT_desc">生产硬件支持的 ptrdiff_t 数据的长度(以位为单位)</entry>
    <entry key="prodEndianness">字节顺序</entry>
    <entry key="prodEndianness_desc">指定目标的字节顺序是 Big Endian (最高有效位字节优先)还是 Little Endian (最低有效位字节优先)。如果未指定，将由生成代码计算结果。</entry>
    <entry key="prodShiftRightIntArith">采用算术移位方式右移有符号整数</entry>
    <entry key="prodShiftRightIntArith_desc">指定 C/C++ 编译器将有符号整数的右移实现为算术右移。几乎所有编译器都这样做。</entry>
    <entry key="prodLongLongMode">启用 long long</entry>
    <entry key="prodLongLongMode_desc">指定 C 编译器支持 long long。大多数 C99 编译器都支持 long long</entry>
    <entry key="prodLargestAtomicInteger">最大原子整数大小</entry>
    <entry key="prodLargestAtomicInteger_desc">指定可自动加载和存储在所选硬件上的最大整数数据类型。所有较小的整数数据类型都将被视为原子类型。</entry>
    <entry key="prodLargestAtomicFloat">最大原子浮点大小</entry>
    <entry key="prodLargestAtomicFloat_desc">指定可自动加载和存储在所选硬件上的最大浮点数据类型。如果指定 Double，则 Float 也将被视为原子类型。</entry>
    <entry key="prodIntDivRoundTo">有符号整数除法舍入方式</entry>
    <entry key="prodIntDivRoundTo_desc">指定 C/C++ 编译器如何对两个有符号整数相除的结果进行舍入。这些信息支持从此工程生成高效 C/C++ 代码。</entry>
    <entry key="targetBitPerChar">char</entry>
    <entry key="targetBitPerChar_desc">目标硬件支持的 C char 数据类型的长度(以位为单位)</entry>
    <entry key="targetBitPerShort">short</entry>
    <entry key="targetBitPerShort_desc">目标硬件支持的 C short 数据类型的长度(以位为单位)</entry>
    <entry key="targetBitPerInt">int</entry>
    <entry key="targetBitPerInt_desc">目标硬件支持的 C int 数据类型的长度(以位为单位)</entry>
    <entry key="targetBitPerLong">long</entry>
    <entry key="targetBitPerLong_desc">目标硬件支持的 C long 数据类型的长度(以位为单位)</entry>
    <entry key="targetBitPerLongLong">long long</entry>
    <entry key="targetBitPerLongLong_desc">目标硬件支持的 C long long 数据类型的长度(以位为单位)</entry>
    <entry key="targetBitPerFloat">float</entry>
    <entry key="targetBitPerFloat_desc">目标硬件支持的 C float 数据类型的长度(以位为单位)</entry>
    <entry key="targetBitPerDouble">double</entry>
    <entry key="targetBitPerDouble_desc">目标硬件支持的 C double 数据类型的长度(以位为单位)</entry>
    <entry key="targetBitPerHalf">half</entry>
    <entry key="targetBitPerHalf_desc">目标硬件支持的 C half 数据类型的长度(以位为单位)</entry>
    <entry key="targetWordSize">计算机字长</entry>
    <entry key="targetWordSize_desc">目标处理器一次可以处理的位数。提供处理器的原生字长允许在转换数据类型的 endian 字节顺序时生成更高效的代码。</entry>
    <entry key="targetBitPerPointer">指针</entry>
    <entry key="targetBitPerPointer_desc">目标硬件支持的指针数据的长度(以位为单位)</entry>
    <entry key="targetBitPerSizeT">size_t</entry>
    <entry key="targetBitPerSizeT_desc">目标硬件支持的 size_t 数据的长度(以位为单位)</entry>
    <entry key="targetBitPerPtrDiffT">ptrdiff_t</entry>
    <entry key="targetBitPerPtrDiffT_desc">ptrdiff_t 数据的长度(以位为单位)</entry>
    <entry key="targetEndianness">字节顺序</entry>
    <entry key="targetEndianness_desc">指定目标的字节顺序是 Big Endian (最高有效位字节优先)还是 Little Endian (最低有效位字节优先)。如果未指定，将由生成代码计算结果。</entry>
    <entry key="targetShiftRightIntArith">采用算术移位方式右移有符号整数</entry>
    <entry key="targetShiftRightIntArith_desc">指定 C/C++ 编译器将有符号整数的右移实现为算术右移。几乎所有编译器都这样做。</entry>
    <entry key="targetLongLongMode">启用 long long</entry>
    <entry key="targetLongLongMode_desc">指定 C 编译器支持 long long。大多数 C99 编译器都支持 long long</entry>
    <entry key="targetLargestAtomicInteger">最大原子整数大小</entry>
    <entry key="targetLargestAtomicInteger_desc">指定可自动加载和存储在所选硬件上的最大整数数据类型。所有较小的整数数据类型都将被视为原子类型。</entry>
    <entry key="targetLargestAtomicFloat">最大原子浮点大小</entry>
    <entry key="targetLargestAtomicFloat_desc">指定可自动加载和存储在所选硬件上的最大浮点数据类型。如果指定 Double，则 Float 也将被视为原子类型。</entry>
    <entry key="targetIntDivRoundTo">有符号整数除法舍入方式</entry>
    <entry key="targetIntDivRoundTo_desc">指定 C/C++ 编译器如何对两个有符号整数相除的结果进行舍入。这些信息支持从此工程生成高效 C/C++ 代码。</entry>
    <entry key="category_advanced">高级</entry>
    <entry key="category_legacy">原有</entry>
    <entry key="castingMode">强制转换模式</entry>
    <entry key="castingMode_desc">指定代码中的强制转换级别</entry>
    <entry key="indentStyle">缩进样式</entry>
    <entry key="indentStyle_desc">指定代码中的缩进样式</entry>
    <entry key="indentSize">缩进大小</entry>
    <entry key="indentSize_desc">缩进大小</entry>
    <entry key="columnLimit">列限制</entry>
    <entry key="columnLimit_desc">无换行符的最大列数</entry>
    <entry key="constantFoldingTimeout">常量折叠超时</entry>
    <entry key="constantFoldingTimeout_desc">指定在尝试确定表达式是否可简化为常量时要执行的最大指令数。如果您的代码包含非常复杂的表达式，您可能需要增大此限制，否则 MATLAB Coder 将过早地停止尝试分析表达式。</entry>
    <entry key="compileTimeRecursionLimit">编译时递归限制</entry>
    <entry key="compileTimeRecursionLimit_desc">指定编译时递归限制。如果收到关于达到递归限制的错误消息，请增大此限制。要禁用递归，请设置为 0。</entry>
    <entry key="enableRuntimeRecursion">启用运行时递归</entry>
    <entry key="enableRuntimeRecursion_desc">禁用此选项可防止生成代码中出现运行时递归</entry>
    <entry key="runInitializeFcn">自动运行初始化函数</entry>
    <entry key="runInitializeFcn_desc">在入口函数的开头自动插入对初始化函数的调用</entry>
    <entry key="includeInitializeFcn">需要初始化函数</entry>
    <entry key="includeInitializeFcn_desc">生成工程初始化函数</entry>
    <entry key="includeTerminateFcn">需要终止函数</entry>
    <entry key="includeTerminateFcn_desc">生成工程终止函数</entry>
    <entry key="generateExampleMain">生成示例主函数</entry>
    <entry key="generateExampleMain_desc">生成示例主函数</entry>
    <entry key="preserveVariableNames">保留变量名称</entry>
    <entry key="preserveVariableNames_desc">指定变量重用优化必须保留的变量名称</entry>
    <entry key="inlineUserFunctions">用户编写的 MATLAB 函数的内联策略</entry>
    <entry key="inlineUserFunctions_desc">指定应对所有用户编写的 MATLAB 函数应用哪种内联策略，这些函数未使用 coder.inline API 显式设置为内联或非内联</entry>
    <entry key="inlineMWFunctions">MathWorks 编写的 MATLAB 函数的内联策略</entry>
    <entry key="inlineMWFunctions_desc">指定应对所有 MathWorks 编写的 MATLAB 函数应用哪种内联策略，这些函数未使用 coder.inline API 显式设置为内联或非内联</entry>
    <entry key="inlineMWFunctionsInUserFunctions">MathWorks 函数和用户函数之间调用的内联策略</entry>
    <entry key="inlineMWFunctionsInUserFunctions_desc">指定应对 MathWorks MATLAB 函数和用户编写的 MATLAB 函数之间的所有调用点应用什么内联策略</entry>
    <entry key="generateMakefile">生成联编文件</entry>
    <entry key="generateMakefile_desc">启用生成联编文件来编译生成的代码</entry>
    <entry key="buildToolEnable">启用编译工具集成</entry>
    <entry key="buildToolEnable_desc">确定是否启用编译工具集成</entry>
    <entry key="buildToolConfiguration">编译工具配置</entry>
    <entry key="buildToolConfiguration_desc">选择用于编译生成代码的配置</entry>
    <entry key="echoExpressions">回显不带终止分号的表达式</entry>
    <entry key="echoExpressions_desc">使运行时输出在调试的 MEX 函数执行过程中出现在 MATLAB 命令行窗口中。禁用此选项可加快 MEX 函数的执行速度。</entry>
    <entry key="enableAutoExtrinsicCalls">自动引入外部调用</entry>
    <entry key="enableAutoExtrinsicCalls_desc">不支持的函数会尽可能自动绕过代码生成。另请参阅 coder.extrinsic。</entry>
    <entry key="inlineThreshold">内联阈值</entry>
    <entry key="inlineThreshold_desc">指定要内联的函数的最大大小</entry>
    <entry key="inlineThresholdMax">最大内联阈值</entry>
    <entry key="inlineThresholdMax_desc">指定内联后函数的最大大小</entry>
    <entry key="inlineStackLimit">内联堆栈限制</entry>
    <entry key="inlineStackLimit_desc">指定内联函数的堆栈大小限制</entry>
    <entry key="enableStrengthReduction">简化数组索引</entry>
    <entry key="enableStrengthReduction_desc">指定是否使用强度缩减优化来简化生成代码中循环的数组索引</entry>
    <entry key="enableMemcpy">使用 memcpy 进行向量赋值</entry>
    <entry key="enableMemcpy_desc">通过用 memcpy 代替 for 循环进行向量赋值来优化代码</entry>
    <entry key="memcpyThreshold">Memcpy 阈值(字节)</entry>
    <entry key="memcpyThreshold_desc">如果(元素数) * (每个元素的字节数)等于或大于此阈值，则使用 memcpy。在此上下文中，一个字节是一个 char 的宽度。</entry>
    <entry key="enableOpenMP">尽可能启用 OpenMP 库</entry>
    <entry key="enableOpenMP_desc">启用 OpenMP (可移植共享内存并行编程)库来加速 MEX 函数的执行(如果可能)</entry>
    <entry key="initFltsAndDblsToZero">使用 memset 将浮点数和双精度值初始化为 0.0</entry>
    <entry key="initFltsAndDblsToZero_desc">优化浮点数和双精度值存储的初始化。如果编译器和目标 CPU 使用的浮点零表示与整数位模式 0 相同，请选择此选项。</entry>
    <entry key="defaultVariableInitialization">变量初始化</entry>
    <entry key="defaultVariableInitialization_desc">声明局部变量时，还需要指定默认值</entry>
    <entry key="generateNonFiniteFilesIfUsed">生成非有限值的支持文件(使用时)</entry>
    <entry key="generateNonFiniteFilesIfUsed_desc">生成非有限值的支持文件(仅当使用时)</entry>
    <entry key="passStructByReference">按引用向入口函数传递结构体</entry>
    <entry key="passStructByReference_desc">按引用向入口函数传递结构体</entry>
    <entry key="constantInputs">常量输入</entry>
    <entry key="constantInputs_desc">常量函数参数处理</entry>
    <entry key="customLAPACKCallback">自定义 LAPACK 库回调</entry>
    <entry key="customLAPACKCallback_desc">在为 MATLAB 代码中的某些线性代数函数生成的代码中，LAPACK 库调用的回调类</entry>
    <entry key="customFFTCallback">自定义 FFT 库回调</entry>
    <entry key="customFFTCallback_desc">为 FFT 函数生成的代码中的 FFT 库调用的回调类</entry>
    <entry key="useBuiltinFFTWLibrary">使用内置 FFTW 库</entry>
    <entry key="useBuiltinFFTWLibrary_desc">在为 FFT 函数生成的代码中使用内置 FFTW 库</entry>
    <entry key="customBLASCallback">自定义 BLAS 库回调</entry>
    <entry key="customBLASCallback_desc">在为 MATLAB 代码中的某些矩阵运算生成的代码中，BLAS 库调用的回调类</entry>
    <entry key="usePrecompiledLibraries">使用预编译库</entry>
    <entry key="usePrecompiledLibraries_desc">指示代码生成器优先使用预编译库或替代实现。</entry>
    <entry key="enableCRICodeCoverage">收集代码覆盖率</entry>
    <entry key="enableCRICodeCoverage_desc">收集代码覆盖率</entry>
    <entry key="enableJIT">对 MEX 的编译类型使用 JIT 编译</entry>
    <entry key="enableJIT_desc">指定是否使用即时(JIT)编译技术来生成 MEX 函数</entry>
    <entry key="enableJITSilentBailOut">静默 JIT bailout 理由</entry>
    <entry key="generateDefaultInSwitch">始终为 switch 生成默认 case</entry>
    <entry key="generateDefaultInSwitch_desc">指定是否为生成代码中的所有 switch 语句生成默认 case</entry>
    <entry key="enableTraceability">启用代码可追溯性</entry>
    <entry key="enableTraceability_desc">指定代码生成报告是否应包括代码可追溯性</entry>
    <entry key="featureFlags">其他标志</entry>
    <entry key="featureFlags_desc">这只应在 MathWorks 代表要求时使用</entry>
    <entry key="category_inlining">函数内联</entry>
    <entry key="enableGitSupport">启用 Git 集成支持</entry>
    <entry key="enableAutoCommit">允许在 codegen 完成后自动提交更改</entry>
    <entry key="repositoryStyle">Git 存储库创建样式</entry>
    <entry key="enableImplicitExpansion">启用隐式扩展</entry>
    <entry key="enableImplicitExpansion_desc">隐式扩展支持对不同大小的特定数组进行二元运算。禁用此功能将使此类运算生成错误。</entry>
    <entry key="configName">配置对象名称</entry>
    <entry key="configDescription">配置对象描述</entry>
    <entry key="cacheDynamicArrayDataPointer">缓存动态数组数据</entry>
    <entry key="cacheDynamicArrayDataPointer_desc">通过增大生成代码的向量化来提高性能</entry>
    <entry key="silPilVerbosity">SIL/PIL 详细程度</entry>
    <entry key="silPilVerbosity_desc">在软件在环(SIL)或处理器在环(PIL)执行期间显示通信 I/O 信息。</entry>
    <entry key="codeProfilingCodeMetrics">SIL/PIL 探查度量</entry>
    <entry key="codeProfilingCodeMetrics_desc">指定 SIL/PIL 执行产生的探查度量的类型。</entry>
    <entry key="category_misra">MISRA 合规性</entry>
    <entry key="justifyMISRAViolations">为已知的 MISRA 违规生成申述注释</entry>
    <entry key="justifyMISRAViolations_desc">为已知的 MISRA 违规生成申述注释</entry>
    <entry key="category_paths">路径</entry>
    <entry key="outputFile">自定义输出文件</entry>
    <entry key="outputFile_desc">主输出文件的基本文件名</entry>
    <entry key="useEmbeddedCoderFeatures">使用 Embedded Coder 功能</entry>
    <entry key="useEmbeddedCoderFeatures_desc">是否使用 Embedded Coder 功能</entry>
    <entry key="buildFolderType">编译文件夹</entry>
    <entry key="buildFolderType_desc">用于放置编译过程中生成的所有文件的文件夹</entry>
    <entry key="buildFolderPath">编译文件夹路径</entry>
    <entry key="buildFolderPath_desc">指定用于放置编译过程中生成的所有文件的文件夹</entry>
    <entry key="workingFolderType">工作文件夹</entry>
    <entry key="workingFolderType_desc">在编译过程中用作 "当前工作文件夹" 的文件夹</entry>
    <entry key="workingFolderPath">工作文件夹路径</entry>
    <entry key="workingFolderPath_desc">指定要在编译过程中用作 "当前工作文件夹" 的文件夹</entry>
    <entry key="enableJITSilentBailOut_desc"/>
  </message>
</rsccat>
