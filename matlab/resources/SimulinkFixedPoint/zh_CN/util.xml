<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="zh_CN" product="SimulinkFixedPoint" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="AttemptToUseNonFiniteBitMask">位掩码必须为有限值。</entry>
    <entry key="AttemptconvertNaN2Fix">Invalid data type conversion: Parameter ''{0}'' contains a NaN, which cannot be converted to the output data type ''{1}''. Consider specifying either double or single as the output data type instead.</entry>
    <entry key="FailedwriteRoundingSaturationInfoRTWfile">无法将舍入/饱和度信息写入 .rtw 文件。</entry>
    <entry key="IllegalFixedPointDataType_bias_Inf">Illegal Fixed-Point Data Type: Bias cannot be Inf. {0}</entry>
    <entry key="IllegalFixedPointDataType_bias_IsNotFinite">定点数据类型非法: 偏置应为有限值。</entry>
    <entry key="IllegalFixedPointDataType_bias_NaN">Illegal Fixed-Point Data Type: Bias cannot be NaN. {0}</entry>
    <entry key="IllegalFixedPointDataType_signed_one_bit">Illegal Fixed-Point Data Type: For signed, the number of bits must be 2 or more. {0}</entry>
    <entry key="IllegalFixedPointDataType_slope_Inf">定点数据类型非法: 斜率不能为 Inf。{0}</entry>
    <entry key="IllegalFixedPointDataType_slope_NaN">定点数据类型非法: 斜率不能为 NaN。{0}</entry>
    <entry key="IllegalFixedPointDataType_slope_not_normalized">定点数据类型非法: 斜率必须归一化以满足 1 &lt;= Fslope &lt; 2。{0}</entry>
    <entry key="IllegalFixedPointDataType_too_many_bits">非法的定点数据类型: 位数超出支持的最大值。{0}</entry>
    <entry key="IllegalFixedPointDataType_unknown_data_type_mode">数据类型非法: 数据类型模式必须为双精度、单精度、布尔、定点或定标双精度。{0}</entry>
    <entry key="IllegalFixedPointDataType_unsigned_zero_bits">定点数据类型非法: 对于无符号值，其位数必须大于零。{0}</entry>
    <entry key="Nameofdatatypewaslongerthansupportedmaximum">数据类型的名称超过支持的最大长度。</entry>
    <entry key="Overflowoccurred">Wrap on overflow detected. This originated from ''{0}''&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="Saturationoccurred">Saturate on overflow detected. This originated from ''{0}''&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="SlopeWasNotFiniteAndOutOfRange">斜率必须为大于或等于 1 且严格小于 2 的有限值。</entry>
    <entry key="SlopeWasNotFiniteAndStrictlyPositive">斜率必须为有限值且严格为正值。</entry>
    <entry key="Unablelogfixedpointminsandmaxsduememorylimitations">由于内存限制，无法记录定点最小值和最大值。</entry>
    <entry key="Unrecognizedporttype">无法识别的端口类型。</entry>
    <entry key="Unsupporteddatatype">数据类型不受支持。</entry>
    <entry key="fhpCalculateFraction_inputandxdatahavesamedatatype">fhpCalculateFraction: 输入和 XData 必须具有相同的数据类型。</entry>
    <entry key="fhpEvenSearch_inputandxdatahasnontrivialbias">fhpEvenSearch: 用于等间距搜索的数据类型有非平凡偏置。</entry>
    <entry key="fhpEvenSearch_inputandxdatahavesamedatatype">fhpEvenSearch: 输入和 XData 必须具有相同的数据类型。</entry>
    <entry key="fhpScalarPreLookup_inputandxdatahasnontrivialbias">fhpScalarPreLookup: 用于等间距搜索的数据类型有非平凡偏置。</entry>
    <entry key="fhpScalarPreLookup_inputandxdatahassamedatatype">fhpScalarPreLookup: 输入和 XData 必须具有相同的数据类型。</entry>
    <entry key="fxpAbs_inputandoutputarenotallowedbecomplex">fxpAbs: 不允许输入和输出为复数。</entry>
    <entry key="fxpAbs_inputandoutputhavenonzerobias">fxpAbs: 输入和输出必须具有非零偏置。</entry>
    <entry key="fxpAbs_nonscalarinputbethesamesizeasoutput">fxpAbs: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpAccumNegCollapse_notyetconfiguredhandleinputsnonzerobias">fxpAccumNegCollapse: 尚未配置为处理具有非零偏置的输入。</entry>
    <entry key="fxpAccumNegCollapse_notyetconfiguredhandleoutputsnonzerobias">fxpAccumNegCollapse: 尚未配置为处理具有非零偏置的输出。</entry>
    <entry key="fxpAccumNegCollapse_outputbecomplexifinputcomplex">fxpAccumNegCollapse: 如果输入为复数，则输出必须为复数。</entry>
    <entry key="fxpAccumNeg_nonscalarinputbethesamesizeasoutput">fxpAccumNeg: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpAccumNeg_notyetconfiguredhandleoutputsnonzerobias">fxpAccumNeg: 尚未配置为处理具有非零偏置的输出。</entry>
    <entry key="fxpAccumNeg_outputbecomplexifinputcomplex">fxpAccumNeg: 如果输入为复数，则输出必须为复数。</entry>
    <entry key="fxpAccumPosCollapse_notyetconfiguredhandleinputsnonzerobias">fxpAccumPosCollapse: 尚未配置为处理具有非零偏置的输入。</entry>
    <entry key="fxpAccumPosCollapse_notyetconfiguredhandleoutputsnonzerobias">fxpAccumPosCollapse: 尚未配置为处理具有非零偏置的输出。</entry>
    <entry key="fxpAccumPosCollapse_outputbecomplexifinputcomplex">fxpAccumPosCollapse: 如果输入为复数，则输出必须为复数。</entry>
    <entry key="fxpAccumPos_nonscalarinputbethesamesizeasoutput">fxpAccumPos: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpAccumPos_notyetconfiguredhandleoutputsnonzerobias">fxpAccumPos: 尚未配置为处理具有非零偏置的输出。</entry>
    <entry key="fxpAccumPos_outputbecomplexifinputcomplex">fxpAccumPos: 如果输入为复数，则输出必须为复数。</entry>
    <entry key="fxpAndCollapse_inputandoutputarenotallowedbecomplex">fxpAndCollapse: 不允许输入和输出为复数。</entry>
    <entry key="fxpAndCollapse_outputbescalar">fxpAndCollapse: 输出必须为标量。</entry>
    <entry key="fxpAndEqual_inputandoutputarenotallowedbecomplex">fxpAndEqual: 不允许输入和输出为复数。</entry>
    <entry key="fxpAndEqual_nonscalarinputbethesamesizeasoutput">fxpAndEqual: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpBitwiseAndCollapse_inputandoutputarenotallowedbecomplex">fxpBitwiseAndCollapse: 不允许输入和输出为复数。</entry>
    <entry key="fxpBitwiseAndCollapse_outputbescalar">fxpBitwiseAndCollapse: 输出必须为标量。</entry>
    <entry key="fxpBitwiseAndEqual_inputandoutputarenotallowedbecomplex">fxpBitwiseAndEqual: 不允许输入和输出为复数。</entry>
    <entry key="fxpBitwiseAndEqual_nonscalarinputbethesamesizeasoutput">fxpBitwiseAndEqual: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpBitwiseComplement_inputandoutputarenotallowedbecomplex">fxpBitwiseComplement: 不允许输入和输出为复数。</entry>
    <entry key="fxpBitwiseComplement_nonscalarinputbethesamesizeasoutput">fxpBitwiseComplement: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpBitwiseOrCollapse_inputandoutputarenotallowedbecomplex">fxpBitwiseOrCollapse: 不允许输入和输出为复数。</entry>
    <entry key="fxpBitwiseOrCollapse_outputbescalar">fxpBitwiseOrCollapse: 输出必须为标量。</entry>
    <entry key="fxpBitwiseOrEqual_inputandoutputarenotallowedbecomplex">fxpBitwiseOrEqual: 不允许输入和输出为复数。</entry>
    <entry key="fxpBitwiseOrEqual_nonscalarinputbethesamesizeasoutput">fxpBitwiseOrEqual: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpBitwiseXorCollapse_inputandoutputarenotallowedbecomplex">fxpBitwiseXorCollapse: 不允许输入和输出为复数。</entry>
    <entry key="fxpBitwiseXorCollapse_outputbescalar">fxpBitwiseXorCollapse: 输出必须为标量。</entry>
    <entry key="fxpBitwiseXorEqual_inputandoutputarenotallowedbecomplex">fxpBitwiseXorEqual: 不允许输入和输出为复数。</entry>
    <entry key="fxpBitwiseXorEqual_nonscalarinputbethesamesizeasoutput">fxpBitwiseXorEqual: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpCleanBoolean_inputandoutputarenotallowedbecomplex">fxpCleanBoolean: 不允许输入和输出为复数。</entry>
    <entry key="fxpCleanBoolean_nonscalarinputbethesamesizeasoutput">fxpCleanBoolean: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpClient_ErrorEncountered">类 ''{0}'' 的定点客户端遇到错误。</entry>
    <entry key="fxpCompare_Unsupportedrelationaloperator">fxpCompare: 不支持的关系运算符。</entry>
    <entry key="fxpCompare_complextypesarenotsupported">fxpCompare: 不支持复数类型。</entry>
    <entry key="fxpCompare_nonscalarinputsbethesamesizeastheoutput">fxpCompare: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpComplement_inputandoutputarenotallowedbecomplex">fxpComplement: 不允许输入和输出为复数。</entry>
    <entry key="fxpComplement_nonscalarinputbethesamesizeasoutput">fxpComplement: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpConj_inputandoutputhavenonzerobias">fxpConj: 输入和输出必须具有非零偏置。</entry>
    <entry key="fxpConj_nonscalarinputbethesamesizeasoutput">fxpConj: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpConj_outputbecomplexifinputcomplex">fxpConj: 如果输入为复数，则输出必须为复数。</entry>
    <entry key="fxpConvert_nonscalarinputbethesamesizeasoutput">fxpConvert: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpConvert_outputbecomplexifinputcomplex">fxpConvert: 如果输入为复数，则输出必须为复数。</entry>
    <entry key="fxpConvert_thin2bool_inputandoutputbenoncomplexifinputconvertedBooleanoutput">fxpConvert_thin2bool: 如果输入转换为布尔输出，则输入和输出必须为非复数。</entry>
    <entry key="fxpConvert_thin2bool_nonscalarinputbethesamesizeasoutput">fxpConvert_thin2bool: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpCordic_complexinputnotsupported">对于 CORDIC 逼近，不支持复数输入。</entry>
    <entry key="fxpCordic_inputisInforNaN">The input angle is Inf or NaN. CORDIC Approximation method does not support Inf or NaN values.</entry>
    <entry key="fxpCordic_slopebiasscaledinputnotsupported">对于 CORDIC 逼近，不支持具有非零偏置或斜率不是 2 的幂的输入。</entry>
    <entry key="fxpDataTypeIsNotFixedPoint">数据类型不是定点类型。</entry>
    <entry key="fxpDataTypeIsNotMultiWord">数据类型不是多字类型。</entry>
    <entry key="fxpDeadZone_complexcasenotsupported">fxpDeadZone: 不支持复数情况。</entry>
    <entry key="fxpDeadZone_neitherLoLimnorHiLimallowedbediscontiguous">fxpDeadZone: LoLim 和 HiLim 都不允许不连续。</entry>
    <entry key="fxpDeadZone_nonscalarinputsbethesamesizeastheoutput">fxpDeadZone: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpDivideCollapse_inputdenominatorcannotcomplex">fxpDivideCollapse: 输入(分母)不能为复数。</entry>
    <entry key="fxpDivide_nonscalarinputsbethesamesizeastheoutput">fxpDivide: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpDivide_outputbecomplexifeitherinputcomplex">fxpDivide: 如果任一输入为复数，则输出必须为复数。</entry>
    <entry key="fxpDivide_secondinputdenominatorcannotcomplex">fxpDivide: 第二个输入(分母)不能为复数。</entry>
    <entry key="fxpDivisionByZero">出现除以零。商已饱和。这源于 ''{0}''&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="fxpDotProduct_nonscalarinputsbethesamesize">fxpDotProduct: 非标量输入的大小必须相同。</entry>
    <entry key="fxpDotProduct_outputbecomplexifeitherinputcomplex">fxpDotProduct: 如果任一输入为复数，则输出必须为复数。</entry>
    <entry key="fxpDotProduct_outputbescalar">fxpDotProduct: 输出必须为标量。</entry>
    <entry key="fxpFailToRegisterLegacyChunkArray">要注册原有分块数组，字长必须大于 32。</entry>
    <entry key="fxpFltContainerWordLengthUnsupported">浮点数据类型不支持对存储容器字长的请求。</entry>
    <entry key="fxpFltIsSignedUnsupported">浮点数据类型不支持对 IsSigned 属性的请求。</entry>
    <entry key="fxpFltWordLengthUnsupported">浮点数据类型不支持对字长属性的请求。</entry>
    <entry key="fxpLook1DAbove_XDataandYDatabethesamesize">fxpLook1DAbove: XData 和 YData 的大小必须相同。</entry>
    <entry key="fxpLook1DAbove_neitherXDatanorYDataallowedbediscontiguous">fxpLook1DAbove: XData 和 YData 都不允许不连续。</entry>
    <entry key="fxpLook1DAbove_neitherinputnorXDataareallowedbecomplex">fxpLook1DAbove: 输入和 XData 都不允许为复数。</entry>
    <entry key="fxpLook1DAbove_nonscalarinputsbethesamesizeastheoutput">fxpLook1DAbove: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpLook1DAbove_outputcomplexifandonlyifYDatacomplex">fxpLook1DAbove: 当且仅当 YData 为复数时，输出才为复数。</entry>
    <entry key="fxpLook1DBelow_XDataandYDatabethesamesize">fxpLook1DBelow: XData 和 YData 的大小必须相同。</entry>
    <entry key="fxpLook1DBelow_neitherXDatanorYDataallowedbediscontiguous">fxpLook1DBelow: XData 和 YData 都不允许不连续。</entry>
    <entry key="fxpLook1DBelow_neitherinputnorXDataareallowedbecomplex">fxpLook1DBelow: 输入和 XData 都不允许为复数。</entry>
    <entry key="fxpLook1DBelow_nonscalarinputsbethesamesizeastheoutput">fxpLook1DBelow: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpLook1DBelow_outputcomplexifandonlyifYDatacomplex">fxpLook1DBelow: 当且仅当 YData 为复数时，输出才为复数。</entry>
    <entry key="fxpLook1DInterpExtrap_XDataandYDatabethesamesize">fxpLook1DInterpExtrap: XData 和 YData 的大小必须相同。</entry>
    <entry key="fxpLook1DInterpExtrap_neitherXDatanorYDataallowedbediscontiguous">fxpLook1DInterpExtrap: XData 和 YData 都不允许不连续。</entry>
    <entry key="fxpLook1DInterpExtrap_neitherinputnorXDataareallowedbecomplex">fxpLook1DInterpExtrap: 输入和 XData 都不允许为复数。</entry>
    <entry key="fxpLook1DInterpExtrap_nonscalarinputsbethesamesizeastheoutput">fxpLook1DInterpExtrap: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpLook1DInterpExtrap_outputcomplexifandonlyifYDatacomplex">fxpLook1DInterpExtrap: 当且仅当 YData 为复数时，输出才为复数。</entry>
    <entry key="fxpLook1DInterpUsingIndexandFraction_complexindexorfraction">fxpLook1DInterpUsingIndexandFraction: 索引和区间比必须为实数值。</entry>
    <entry key="fxpLook1DInterpUsingIndexandFraction_inconsistentsize">fxpLook1DInterpUsingIndexandFraction: 不允许索引、区间比和输出使用不一致的宽度。</entry>
    <entry key="fxpLook1DInterpUsingIndexandFraction_outputcomplexifandonlyifYDatacomplex">fxpLook1DInterpUsingIndexandFraction: 输出和表数据必须具有相同的信号类型。</entry>
    <entry key="fxpLook1DInterp_XDataandYDatabethesamesize">fxpLook1DInterp: XData 和 YData 的大小必须相同。</entry>
    <entry key="fxpLook1DInterp_neitherXDatanorYDataallowedbediscontiguous">fxpLook1DInterp: XData 和 YData 都不允许不连续。</entry>
    <entry key="fxpLook1DInterp_neitherinputnorXDataareallowedbecomplex">fxpLook1DInterp: 输入和 XData 都不允许为复数。</entry>
    <entry key="fxpLook1DInterp_nonscalarinputsbethesamesizeastheoutput">fxpLook1DInterp: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpLook1DInterp_outputcomplexifandonlyifYDatacomplex">fxpLook1DInterp: 当且仅当 YData 为复数时，输出才为复数。</entry>
    <entry key="fxpLook1DNearest_XDataandYDatabethesamesize">fxpLook1DNearest: XData 和 YData 的大小必须相同。</entry>
    <entry key="fxpLook1DNearest_neitherXDatanorYDataallowedbediscontiguous">fxpLook1DNearest: XData 和 YData 都不允许不连续。</entry>
    <entry key="fxpLook1DNearest_neitherinputnorXDataareallowedbecomplex">fxpLook1DNearest: 输入和 XData 都不允许为复数。</entry>
    <entry key="fxpLook1DNearest_nonscalarinputsbethesamesizeastheoutput">fxpLook1DNearest: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpLook1DNearest_outputcomplexifandonlyifYDatacomplex">fxpLook1DNearest: 当且仅当 YData 为复数时，输出才为复数。</entry>
    <entry key="fxpLook2DAbove_ThelengthofU0DatabethesameasthenumberofrowsofYData">fxpLook2DAbove: U0Data 的长度必须与 YData 的行数相同。</entry>
    <entry key="fxpLook2DAbove_ThelengthofU1DatabethesameasthenumberofcolumnsofYData">fxpLook2DAbove: U1Data 的长度必须与 YData 的列数相同。</entry>
    <entry key="fxpLook2DAbove_neitherU0DatanorU1DatanorYDataallowedbediscontiguous">fxpLook2DAbove: U0Data、U1Data 和 YData 都不允许不连续。</entry>
    <entry key="fxpLook2DAbove_neithercomplexinputsnorcomplexU0Dataareallowed">fxpLook2DAbove: 既不允许输入为复数，也不允许 U0Data 为复数。</entry>
    <entry key="fxpLook2DAbove_nonscalarinputsbethesamesizeastheoutput">fxpLook2DAbove: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpLook2DAbove_outputcomplexifandonlyifYDatacomplex">fxpLook2DAbove: 当且仅当 YData 为复数时，输出才为复数。</entry>
    <entry key="fxpLook2DBelow_ThelengthofU0DatabethesameasthenumberofrowsofYData">fxpLook2DBelow: U0Data 的长度必须与 YData 的行数相同。</entry>
    <entry key="fxpLook2DBelow_ThelengthofU1DatabethesameasthenumberofcolumnsofYData">fxpLook2DBelow: U1Data 的长度必须与 YData 的列数相同。</entry>
    <entry key="fxpLook2DBelow_neitherU0DatanorU1DatanorYDataallowedbediscontiguous">fxpLook2DBelow: U0Data、U1Data 和 YData 都不允许不连续。</entry>
    <entry key="fxpLook2DBelow_neithercomplexinputsnorcomplexU0Dataareallowed">fxpLook2DBelow: 既不允许输入为复数，也不允许 U0Data 为复数。</entry>
    <entry key="fxpLook2DBelow_nonscalarinputsbethesamesizeastheoutput">fxpLook2DBelow: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpLook2DBelow_outputcomplexifandonlyifYDatacomplex">fxpLook2DBelow: 当且仅当 YData 为复数时，输出才为复数。</entry>
    <entry key="fxpLook2DInterpExtrap_ThelengthofU0DatabethesameasthenumberofrowsofYData">fxpLook2DInterpExtrap: U0Data 的长度必须与 YData 的行数相同。</entry>
    <entry key="fxpLook2DInterpExtrap_ThelengthofU1DatabethesameasthenumberofcolumnsofYData">fxpLook2DInterpExtrap: U1Data 的长度必须与 YData 的列数相同。</entry>
    <entry key="fxpLook2DInterpExtrap_neitherU0DatanorU1DatanorYDataallowedbediscontiguous">fxpLook2DInterpExtrap: U0Data、U1Data 和 YData 都不允许不连续。</entry>
    <entry key="fxpLook2DInterpExtrap_neithercomplexinputsnorcomplexU0Dataareallowed">fxpLook2DInterpExtrap: 既不允许输入为复数，也不允许 U0Data 为复数。</entry>
    <entry key="fxpLook2DInterpExtrap_nonscalarinputsbethesamesizeastheoutput">fxpLook2DInterpExtrap: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpLook2DInterpExtrap_outputcomplexifandonlyifYDatacomplex">fxpLook2DInterpExtrap: 当且仅当 YData 为复数时，输出才为复数。</entry>
    <entry key="fxpLook2DInterp_ThelengthofU0DatabethesameasthenumberofrowsofYData">fxpLook2DInterp: U0Data 的长度必须与 YData 的行数相同。</entry>
    <entry key="fxpLook2DInterp_ThelengthofU1DatabethesameasthenumberofcolumnsofYData">fxpLook2DInterp: U1Data 的长度必须与 YData 的列数相同。</entry>
    <entry key="fxpLook2DInterp_neitherU0DatanorU1DatanorYDataallowedbediscontiguous">fxpLook2DInterp: U0Data、U1Data 和 YData 都不允许不连续。</entry>
    <entry key="fxpLook2DInterp_neithercomplexinputsnorcomplexU0Dataareallowed">fxpLook2DInterp: 既不允许输入为复数，也不允许 U0Data 为复数。</entry>
    <entry key="fxpLook2DInterp_nonscalarinputsbethesamesizeastheoutput">fxpLook2DInterp: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpLook2DInterp_outputcomplexifandonlyifYDatacomplex">fxpLook2DInterp: 当且仅当 YData 为复数时，输出才为复数。</entry>
    <entry key="fxpLook2DNearest_ThelengthofU0DatabethesameasthenumberofrowsofYData">fxpLook2DNearest: U0Data 的长度必须与 YData 的行数相同。</entry>
    <entry key="fxpLook2DNearest_ThelengthofU1DatabethesameasthenumberofcolumnsofYData">fxpLook2DNearest: U1Data 的长度必须与 YData 的列数相同。</entry>
    <entry key="fxpLook2DNearest_neitherU0DatanorU1DatanorYDataallowedbediscontiguous">fxpLook2DNearest: U0Data、U1Data 和 YData 都不允许不连续。</entry>
    <entry key="fxpLook2DNearest_neithercomplexinputsnorcomplexU0Dataareallowed">fxpLook2DNearest: 既不允许输入为复数，也不允许 U0Data 为复数。</entry>
    <entry key="fxpLook2DNearest_nonscalarinputsbethesamesizeastheoutput">fxpLook2DNearest: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpLook2DNearest_outputcomplexifandonlyifYDatacomplex">fxpLook2DNearest: 当且仅当 YData 为复数时，输出才为复数。</entry>
    <entry key="fxpMagSquared_nonscalarinputsbethesamesizeastheoutput">fxpMagSquared: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpMaxCollapse_inputandoutputarenotallowedbecomplex">fxpMaxCollapse: 不允许输入和输出为复数。</entry>
    <entry key="fxpMaxCollapse_outputbescalar">fxpMaxCollapse: 输出必须为标量。</entry>
    <entry key="fxpMaxRefine_inputandoutputarenotallowedbecomplex">fxpMaxRefine: 不允许输入和输出为复数。</entry>
    <entry key="fxpMaxRefine_nonscalarinputbethesamesizeasoutput">fxpMaxRefine: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpMinCollapse_inputandoutputarenotallowedbecomplex">fxpMinCollapse: 不允许输入和输出为复数。</entry>
    <entry key="fxpMinCollapse_outputbescalar">fxpMinCollapse: 输出必须为标量。</entry>
    <entry key="fxpMinRefine_inputandoutputarenotallowedbecomplex">fxpMinRefine: 不允许输入和输出为复数。</entry>
    <entry key="fxpMinRefine_nonscalarinputbethesamesizeasoutput">fxpMinRefine: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpMultiplyAccum_nonscalarinputsbethesamesizeastheoutput">fxpMultiplyAccum: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpMultiplyAccum_notyetconfiguredhandleoutputsnonzerobias">fxpMultiplyAccum: 尚未配置为处理具有非零偏置的输出。</entry>
    <entry key="fxpMultiplyAccum_outputbecomplexifeitherinputcomplex">fxpMultiplyAccum: 如果任一输入为复数，则输出必须为复数。</entry>
    <entry key="fxpMultiplyCollapse_outputbecomplexifinputcomplex">fxpMultiplyCollapse: 如果输入为复数，则输出必须为复数。</entry>
    <entry key="fxpMultiplyMatrixAccum_dimensionsdonotagree">fxpMultiplyMatrixAccum: 维度不一致。</entry>
    <entry key="fxpMultiplyMatrixAccum_inputsarenotallowedbediscontiguous">fxpMultiplyMatrixAccum: 不允许输入不连续。</entry>
    <entry key="fxpMultiplyMatrixAccum_notyetconfiguredhandleoutputsnonzerobias">fxpMultiplyMatrixAccum: 尚未配置为处理具有非零偏置的输出。</entry>
    <entry key="fxpMultiplyMatrixAccum_outputbecomplexifeitherinputcomplex">fxpMultiplyMatrixAccum: 如果任一输入为复数，则输出必须为复数。</entry>
    <entry key="fxpMultiplyMatrix_dimensionsdonotagree">fxpMultiplyMatrix: 维度不一致。</entry>
    <entry key="fxpMultiplyMatrix_inputsarenotallowedbediscontiguous">fxpMultiplyMatrix: 不允许输入不连续。</entry>
    <entry key="fxpMultiplyMatrix_outputbecomplexifeitherinputcomplex">fxpMultiplyMatrix: 如果任一输入为复数，则输出必须为复数。</entry>
    <entry key="fxpMultiply_nonscalarinputsbethesamesizeastheoutput">fxpMultiply: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpMultiply_outputbecomplexifeitherinputcomplex">fxpMultiply: 如果任一输入为复数，则输出必须为复数。</entry>
    <entry key="fxpNetScalingDiagnosticOverflow">净定标量化导致了溢出。{0} 的原始值为 {1}。量化值为 {2}，误差为 {3}.{4}&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="fxpNetScalingDiagnosticPrecisionLoss">Net scaling quantization caused precision loss. The original value for {0} was {1}. The quantized value was {2} with an error of {3}.{4}&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="fxpNetScalingDiagnosticUnderflow">净定标量化导致了下溢。{0} 的原始值为 {1}。量化值为 {2}，误差为 {3}.{4}&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="fxpNetScalingDiagnosticUnderflowNoQuantError">净定标量化导致了来自 {0} 的下溢。原始值为 {1}。&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="fxpNonPowerofTwoFractionLengthUnsupported">如果数据类型的斜率不是 2 的幂，则不支持对 FractionLength 属性的请求。</entry>
    <entry key="fxpNonZeroBiasFractionLengthUnsupported">如果数据类型具有非零偏置，则不支持对 FractionLength 属性的请求。</entry>
    <entry key="fxpOrCollapse_inputandoutputarenotallowedbecomplex">fxpOrCollapse: 不允许输入和输出为复数。</entry>
    <entry key="fxpOrCollapse_outputbescalar">fxpOrCollapse: 输出必须为标量。</entry>
    <entry key="fxpOrEqual_inputandoutputarenotallowedbecomplex">fxpOrEqual: 不允许输入和输出为复数。</entry>
    <entry key="fxpOrEqual_nonscalarinputbethesamesizeasoutput">fxpOrEqual: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpParameterOverflowOld">''{1}'' 的 ''{0}'' 出现参数溢出。参数的值超出运行时数据类型可以表示的范围。指定的值已饱和处理为最接近的可表示值。要禁用此警告或错误，请在 "配置参数 &gt; 诊断 &gt; 数据有效性" 窗格中，将 "参数" 组中的 ''检测溢出'' 选项设置为 ''无''。&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="paramQuantLossTimes">乘 </entry>
    <entry key="firstOccurrence">第一次出现: </entry>
    <entry key="fxpParameterOverflow">''{1}'' 的 ''{0}'' 发生参数溢出{8}{9}。参数值超出运行时数据类型 {2} 可以表示的范围。{10} 指定的值，{3}{4}，已饱和处理为最接近的可表示值 {5}。出现量化误差，绝对差为 {6}，相对差为 {7_Double}。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;Simulink.output.ParamDiagnosticFixits.fix('OpenParamQuantizeManager',''{0}'',''{1}'');&lt;/cmd&gt; &lt;txt&gt;要在参数量化顾问中查看详细信息，请点击 "打开" 按钮。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suppression"&gt;&lt;/action&gt; &lt;/actions&gt;</entry>
    <entry key="fxpParameterPrecisionLossOld">''{1}'' 的 ''{0}'' 出现参数精度损失。使用运行时数据类型无法准确表示参数值。出现微小的量化误差。要禁用此警告或错误，请在 "配置参数 &gt; 诊断 &gt; 数据有效性" 窗格中，将 "参数" 组中的 ''检测精度损失'' 选项设置为 ''无''。&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="fxpParameterPrecisionLoss">''{1}'' 的 ''{0}'' 发生参数精度损失{8}{9}。{10} 无法使用运行时数据类型 {4} 准确表示参数 {2}{3} 的原始值。该值量化为 {5}。出现量化误差，绝对差为 {6}，相对差为 {7_Double}。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;Simulink.output.ParamDiagnosticFixits.fix('HighlightParam',''{1}'','ParameterPrecisionLossMsg');&lt;/cmd&gt; &lt;txt&gt;要控制发出警告或错误的精度损失水平，请调整诊断阈值设置。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;Simulink.output.ParamDiagnosticFixits.fix('OpenParamQuantizeManager',''{0}'',''{1}'');&lt;/cmd&gt; &lt;txt&gt;要在参数量化顾问中查看详细信息，请点击 "打开" 按钮。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suppression"&gt;&lt;/action&gt; &lt;/actions&gt;</entry>
    <entry key="fxpParameterUnderflowOld">''{1}'' 的 ''{0}'' 出现参数下溢。该参数值不为零，但量化为运行时数据类型后，该值为零。要禁用此警告或错误，请在 "配置参数 &gt; 诊断 &gt; 数据有效性" 窗格中，将 "参数" 组中的 ''检测下溢'' 选项设置为 ''无''。&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="fxpParameterUnderflow">Parameter underflow occurred{8}{9} for ''{0}'' of ''{1}''. {10} The value of the parameter, {2}{3}, is non-zero, but after quantization to the run-time data type {4}, the value is zero ({5}). Quantization error occurred with an absolute difference of {6} and a relative difference of {7_Double}.
    &lt;actions exclusiveFixIts="yes"&gt;      
       &lt;action type="suggestion"&gt;
          &lt;cmd&gt;Simulink.output.ParamDiagnosticFixits.fix('OpenParamQuantizeManager',''{0}'',''{1}'');&lt;/cmd&gt;
          &lt;txt&gt;To review details in the Parameter Quantization Advisor app, click the Open button.&lt;/txt&gt;
       &lt;/action&gt;
       &lt;action type="suppression"&gt;&lt;/action&gt;
       &lt;/actions&gt;</entry>
    <entry key="fxpPreLookup_XDataNotAllowedbediscontiguous">fxpPreLookup: 断点不允许具有异构属性。</entry>
    <entry key="fxpPreLookup_neitherIndexnorFractionareallowedbecomplex">fxpPreLookup: 索引和区间比不能为复数。</entry>
    <entry key="fxpReciprocal_inputdenominatorcannotcomplex">fxpReciprocal: 输入(分母)不能为复数。</entry>
    <entry key="fxpReciprocal_nonscalarinputsbethesamesizeastheoutput">fxpReciprocal: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpSFunBlockNotSupportRTW33Plus">要处理任何超过 32 位的定点数据类型，必须在 S-Function 的 mdlInitializeSizes 函数中调用 ssFxpSetU32BitRegionCompliant。为了避免这种情况，请在此 S-Function 模块的前后插入一个入口模块。</entry>
    <entry key="fxpSFunEmptyParameter">A parameter is empty in S-function ''{0}''.</entry>
    <entry key="fxpSFunParamHasWrongNum">A parameter of S-function ''{0}'' does not have the correct number of elements.</entry>
    <entry key="fxpSFunParamNotDouble">S-Function ''{0}'' 的一个参数必须为双精度类型。</entry>
    <entry key="fxpSFunParamIsNotNumber">A scalar parameter of S-function ''{0}'' must be a number.</entry>
    <entry key="fxpSFunParamIsNotString">S-Function ''{0}'' 的一个参数必须为字符向量。</entry>
    <entry key="fxpSFunParamIsNotVector">A parameter of S-function ''{0}'' must be a real vector.</entry>
    <entry key="fxpSFunParamNotSupportHalfType">A parameter of S-function ''{0}'' cannot be of half precision data type.</entry>
    <entry key="fxpSFuncLegacyError">''{1}'' 中的 S-Function ''{0}'' 报告错误: {2}</entry>
    <entry key="fxpScaledDoubleContainerWordLengthUnsupported">ScaledDouble 数据类型不支持对存储容器字长的请求。</entry>
    <entry key="fxpSignExtensionViolation">仿真位违反符号扩展。</entry>
    <entry key="fxpSqrt_complexinputnotsupported">Complex inputs for integer and fixed-point data types are not supported for block ''{0}''.</entry>
    <entry key="fxpSqrt_complexoutputnotsupported">模块 ''{0}'' 不支持整数和定点数据类型的复数输出。</entry>
    <entry key="fxpSqrt_inputoutputmismatchsize">输入和输出信号维度必须相同。否则，输入必须为标量。</entry>
    <entry key="fxpSqrt_invalidIntermediateDtypeWL">''中间结果数据类型'' 的字长无效。它需要至少 4 位。</entry>
    <entry key="fxpSqrt_negativeinput">负数的平方根。</entry>
    <entry key="fxpSqrt_negativeinputnotsupported">Negative inputs for integer and fixed-point data types are not supported for block ''{0}''.</entry>
    <entry key="fxpSqrt_slopebiasscaledinputoutputnotsupported">模块 ''{0}'' 不支持具有非零偏置或斜率不是 2 的幂的输入和输出。</entry>
    <entry key="fxpSqrt_outoffxprepresentationrange">fxpSqrt: Data is out of the fixed-point representation range.</entry>
    <entry key="fxpStorageContainerUnsupported">尝试标识不支持类型的存储容器。</entry>
    <entry key="fxpSumPosCollapse_notyetconfiguredhandleinputsnonzerobias">fxpSumPosCollapse: 尚未配置为处理具有非零偏置的输入。</entry>
    <entry key="fxpSumPosCollapse_notyetconfiguredhandleoutputsnonzerobias">fxpSumPosCollapse: 尚未配置为处理具有非零偏置的输出。</entry>
    <entry key="fxpSumPosCollapse_outputbecomplexifinputcomplex">fxpSumPosCollapse: 如果输入为复数，则输出必须为复数。</entry>
    <entry key="fxpSumPosCollapse_outputbescalar">fxpSumPosCollapse: 输出必须为标量。</entry>
    <entry key="fxpThisOriginatedFrom">这源于 ''{0}''。</entry>
    <entry key="fxpUnaryMinus_inputandoutputhavenonzerobias">fxpUnaryMinus: 输入和输出必须具有非零偏置。</entry>
    <entry key="fxpUnaryMinus_nonscalarinputbethesamesizeasoutput">fxpUnaryMinus: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpUnaryMinus_outputbecomplexifinputcomplex">fxpUnaryMinus: 如果输入为复数，则输出必须为复数。</entry>
    <entry key="fxpUnsupportedDataTypeId">数据类型 ID 与 Simulink 内置或定点数据类型不对应。</entry>
    <entry key="fxpXorCollapse_inputandoutputarenotallowedbecomplex">fxpXorCollapse: 不允许输入和输出为复数。</entry>
    <entry key="fxpXorCollapse_outputbescalar">fxpXorCollapse: 输出必须为标量。</entry>
    <entry key="fxpXorEqual_inputandoutputarenotallowedbecomplex">fxpXorEqual: 不允许输入和输出为复数。</entry>
    <entry key="fxpXorEqual_nonscalarinputbethesamesizeasoutput">fxpXorEqual: 非标量输入必须与输出大小相同。</entry>
    <entry key="fxpZeroValueError">值不应为零。</entry>
    <entry key="fxppVoidDestSizeMismatch">pVoidDest 指向的内存的大小不是指定的数据类型 ID 所需的正确大小。</entry>
    <entry key="fxppVoidSrcSizeMismatch">pVoidSrc 指向的内存的大小不是指定的数据类型 ID 所需的正确大小。</entry>
    <entry key="DataTypePropErrorInDTProp">数据类型传播导致了违反继承规则。手动设置此模块的数据类型和定标是一种消除此错误的方法。</entry>
    <entry key="UnsupportedInputdatatype">模块 ''{0}'' 具有不支持的输入数据类型。</entry>
    <entry key="UnsupportedOutputdatatype">模块 ''{0}'' 具有不支持的输出数据类型。</entry>
    <entry key="UnsupportedNumOfBits">继承的输出数据类型包含的位数已超过支持的位数。</entry>
    <entry key="fxptpropDataTypeConflict">在模块 ''{0}'' 中，另一个模块已设置&lt;sldiag objui="inport" objparam="3" objname="{0}"&gt;输入端口 3&lt;/sldiag&gt; 的数据类型。该数据类型与此模块要设置的数据类型不一致。 </entry>
    <entry key="fxptpropInportFinite">在模块 ''{0}'' 中，指定的输入端口数必须为有限正数，并且小于 1001。 </entry>
    <entry key="fxptpropUnsupportedOperationId">在模块 ''{0}'' 中，向 S-Function 传递了不支持的操作 ID。 </entry>
    <entry key="fxptpropInsufficientNumParameter">在模块 ''{0}'' 中，没有足够的参数传递给 S-Function。</entry>
    <entry key="fxptpropUnsupportedInputType">模块 ''{0}'' 具有不支持的输入数据类型。</entry>
    <entry key="fxptpropUnknownIsSignedValue">模块 ''{0}'' 具有无法识别的 isSigned 设置选择项。 </entry>
    <entry key="fxptpropUnknownNumBits">模块 ''{0}'' 具有无法识别的位数基值选择项。</entry>
    <entry key="fxptpropTooFewNumBits">模块 ''{0}'' 具有数据类型传播错误: 位数太少。</entry>
    <entry key="fxptpropTooManyNumBits">Block ''{0}'' has data type propagation error: too many bits. </entry>
    <entry key="fxptpropUnknownSlope">模块 ''{0}'' 具有无法识别的斜率基值选择项 </entry>
    <entry key="fxptpropNegSlope">Block ''{0}'' has data type propagation error: slope negative or zero. </entry>
    <entry key="fxptpropUnknownBias">模块 ''{0}'' 具有无法识别的偏置基值选择项 </entry>
    <entry key="fxptpropUnsupportedNumBits">Block ''{0}'' has data type propagation error: more bits than allowed </entry>
    <entry key="fxpBitOpNotOneInput">在模块 ''{0}'' 中，NOT 运算接受有且仅有一个输入端口。</entry>
    <entry key="fxpBitOpPositive">在模块 ''{0}'' 中，输入端口数必须为正数。</entry>
    <entry key="fxpBitOpUnsupportedOps">在模块 ''{0}'' 中，已选择不支持的逻辑运算。</entry>
    <entry key="fxpBitOpUnsupportedBitMask">模块 ''{0}'' 不能为位掩码处理分配内存。</entry>
    <entry key="fxpUserDataNotNull">在模块 ''{0}'' 中，用户数据在被分配和初始化之前必须为空。 </entry>
    <entry key="fxpUserDataAllocateFail">模块 ''{0}'' 无法为用户数据分配内存。 </entry>
    <entry key="fxpBitOpInputPropAllocateFail">模块 ''{0}'' 无法为输入属性分配内存。</entry>
    <entry key="fxpBitOpMaskVecAllocateFail">模块 ''{0}'' 无法为封装向量分配内存。 </entry>
    <entry key="fxpBitOpUnsupportedPortType">模块 ''{0}'' 具有不支持的端口数据类型。 </entry>
    <entry key="fxpBitOpUnsupportedFloatType">模块 ''{0}'' 不支持真正的浮点数据类型。 </entry>
    <entry key="fxpBitOpOutTypeIncompatible">In block ''{0}'', the output port data type was not compatible with the data type determine by the block's propagation rule. </entry>
    <entry key="fxpBitOpInTypeIncompatible">在模块 ''{0}'' 中，输入端口数据类型与由模块的传播规则确定的数据类型不兼容。 </entry>
    <entry key="fxpMultiWordConvR2007aLegacy">The fixed-point ChunkArray memory format used in R2007a and earlier is no longer supported. You should delete block ''{0}'' and update any of your old fixed-point S-functions to use the memory layout introduced in R2007b.</entry>
    <entry key="fxpMultiWordConvInputWidth">在模块 ''{0}'' 中，输入端口宽度与输出端口宽度不兼容。 </entry>
    <entry key="fxpFirAllocateMemInitCondition">模块 ''{0}'' 无法为初始条件分配内存。 </entry>
    <entry key="fxpFirIllegalContSampleTime">模块 ''{0}'' 非法继承了连续采样时间。</entry>
    <entry key="fxpFirInitCondNotAgreeGain">在模块 ''{0}'' 中，初始条件的数量与增益不一致。初始条件的数量应等于 1 或增益中的列数减 1。 </entry>
    <entry key="fxpFirSampleTime">在模块 ''{0}'' 中，采样时间必须包含一个或两个元素采样时间和一个可选的偏移时间。 </entry>
    <entry key="fxpFirInvalidSampleTime">Block ''{0}'' has invalid sample time</entry>
    <entry key="fxpFirSampleTimeOffsetZero">在模块 ''{0}'' 中，对于继承的采样时间: 偏移量必须为零。</entry>
    <entry key="fxpFirOffsetLessThanSampleTime">在模块 ''{0}'' 中，偏移量必须小于采样时间。 </entry>
    <entry key="fxpFirRadixOnly">在模块 ''{0}'' 中，增益定标只能是基数，因此斜率必须为 2 的幂，且偏置必须为零。 </entry>
    <entry key="fxpOutputPortDimsIncompatible">在模块 ''{0}'' 中，输出端口维度与第一个输入端口不兼容。</entry>
    <entry key="fxpBpTablePortWidthNoLessThanTwo">在模块 ''{0}'' 中，断点和表端口宽度必须等于或大于 2。</entry>
    <entry key="fxpBpTablePortDimsIncompatible">断点端口维度与表端口不兼容。</entry>
    <entry key="fxpBpTablePortDimensionMustBeSpec">在模块 ''{0}'' 中，必须指定断点和表端口维度，它们无法逆向继承。建议: 使用上游模块指定断点端口或表端口维度。</entry>
    <entry key="fxpSameSlopeBias">In block ''{0}'', input 1 and 2 must have the same bias and the same fractional slope.</entry>
    <entry key="fxpSameSignedness">In block ''{0}'', input 1 and 2 must both be signed or both be unsigned.</entry>
    <entry key="fxpLessPrecision">In block ''{0}'', input 1 is not allowed to have less precision than input 2. The slope of Input 1 must be less than or equal to the slope of Input 2.</entry>
    <entry key="fxpRangeMismatch">In block ''{0}'', input 1 is not allowed to have less range than input 2. A combination of the following steps can be used to solve the range problem. The number of bits for Input 2 can be decreased relative to Input 1. The slope of Input 2 can be reduced down to but not lower than the slope of Input 1.</entry>
    <entry key="fxpSameSlopeBiasOutIn3">In block ''{0}'', output and Input 3 must have the same bias and the same fractional slope.</entry>
    <entry key="fxpUnsupportTableMethod">模块 ''{0}'' 具有无法识别的查找表方法。</entry>
    <entry key="fxpInvalidTableMethod">查找方法无效。</entry>
    <entry key="fxpNonMonotonicIncreasingErr">在模块 ''{0}'' 中，xdat 向量是断点数据，它必须严格单调递增。</entry>
    <entry key="fxpInitCondNumMismatch">在模块 ''{0}'' 中，初始条件的数量与延迟的数量不一致。</entry>
    <entry key="fxpNumDelayFloatOrInt">在模块 ''{0}'' 中，延迟次数的数据类型必须为双精度、单精度或整数。</entry>
    <entry key="fxpNumDelayNonFrac">In block ''{0}'', the number of delays must be a positive integer.</entry>
    <entry key="fxpNumDelayPositive">在模块 ''{0}'' 中，延迟的数量必须为正数。</entry>
    <entry key="fxpNumDelayPositiveOrInherited">In block ''{0}'', the number of delays must be positive or -1 for inherited.</entry>
    <entry key="fxpNumOutputDelayPositiveOrInherited">在模块 ''{0}'' 中，输出的延迟数必须为正数或 -1 (表示继承)。</entry>
    <entry key="fxpDSPLicense">模块 ''{0}'' 无法签出 DSP System Toolbox 的许可证。</entry>
    <entry key="fxpInputSampleBased">在模块 ''{0}'' 中，当 '输入处理' 参数设置为 '元素作为通道(基于采样)' 时，输入必须是基于采样的信号。</entry>
    <entry key="tapDelayUnsupportFrameBased">The Tapped Delay Block, ''{0}'', does not support frame based signals</entry>
    <entry key="tapDelayWidthIncorrect">The Tapped Delay Block, ''{0}'', must have output port width greater than 1 when including the current input in the output vector.</entry>
    <entry key="fxpDelayExceedChannelLength">在模块 ''{0}'' 中，延迟的数量超过帧输入的通道长度。</entry>
    <entry key="fxpInitCondScaler">在模块 ''{0}'' 中，对于基于帧的输入，初始条件必须为标量。</entry>
    <entry key="fxpDelayNumExceed">在模块 ''{0}'' 中，延迟的数量超过上限: 32 位整数的最大值除以输入数据类型大小(以字节为单位)。</entry>
    <entry key="fxpNumDelayFailMemAlloc">模块 ''{0}'' 有内存分配错误。延迟的数量太多，无法为状态分配内存。</entry>
    <entry key="fxpOutputScalar">在模块 ''{0}'' 中，输出必须为标量、向量或一维矩阵。</entry>
    <entry key="compDblWithMinMaxFixPtValueRequiresSixInputs">compDblWithMinMaxFixPtValue requires six input arguments.</entry>
    <entry key="compDblWithMinMaxFixPtValueRequiresOneOutputs">compDblWithMinMaxFixPtValue requires one output argument.</entry>
    <entry key="compDblWithMinMaxFixPtValueInvalidMantBits1">compDblWithMinMaxFixPtValue requires MantBits be a positive integer between 1 and 128 inclusive for unsigned fixed-point data type.</entry>
    <entry key="compDblWithMinMaxFixPtValueInvalidMantBits2">compDblWithMinMaxFixPtValue requires MantBits be a positive integer between 2 and 128 inclusive for signed fixed-point data type.</entry>
    <entry key="compDblWithMinMaxFixPtValueRequiresDouble">compDblWithMinMaxFixPtValue requires that DblValue be double.</entry>
    <entry key="compDblWithMinMaxFixPtValueSupportsScalarOnly">compDblWithMinMaxFixPtValue only supports scalar.</entry>
    <entry key="compDblWithMinMaxFixPtValueIsSignedZeroOrOne">compDblWithMinMaxFixPtValue requires that IsSigned be 0 or 1.</entry>
    <entry key="compDblWithMinMaxFixPtValueFixExpInteger">compDblWithMinMaxFixPtValue requires FixExp be an integer.</entry>
    <entry key="compDblWithMinMaxFixPtValueFracSlopeRestriction">compDblWithMinMaxFixPtValue requires FracSlope to be between 1.0 and 2.0.</entry>
    <entry key="compDblWithMinMaxFixPtValueFiniteBias">compDblWithMinMaxFixPtValue requires Bias to be finite.</entry>
    <entry key="fxpMW2DecStrTwoInputs">fixpt_convertMW2DecString requires two input arguments.</entry>
    <entry key="fxpMW2DecStrOneOutput">fixpt_convertMW2DecString requires one output argument.</entry>
    <entry key="fxpMW2DecStrMxMWValueBeString">fixpt_convertMW2DecString requires that mxMWValue be a character vector.</entry>
    <entry key="fxpMW2DecStrBitsOfLongBeDouble">fixpt_convertMW2DecString requires that bitsOfLong be double.</entry>
    <entry key="fxpMW2DecStrWrongMultiWordString">The multiword character vector is not correct.</entry>
    <entry key="fxpMW2DecStrWrongMultiError">fixpt_convertMW2DecString got an error.</entry>
    <entry key="sfix_dtpropBitLess">模块 {0}: 在应用乘性和加性调整后，传播的位数少于有符号数所需的最小 {1} 位。位数将增加到允许的最小最终值。</entry>
    <entry key="fxpClassifierEmptyDataType">必须指定一种数据类型。</entry>
    <entry key="fxpClassifierSignedness">数据类型需要 IsSigned 结构体字段，并且它必须为标量逻辑值。</entry>
    <entry key="fxpClassifierWordLength">数据类型需要 WordLength 结构体字段，并且它必须为整数标量。</entry>
    <entry key="fxpClassifierWrongNumFields">数据类型必须具有以下字段: IsSigned、WordLength、FractionLength 或 IsSigned、WordLength、Slope、Bias。</entry>
    <entry key="fxpClassifierFractionLength">数据类型需要 FractionLength 结构体字段，并且它必须为整数标量。</entry>
    <entry key="fxpClassifierSlope">数据类型需要 Slope 结构体字段，并且它必须为双精度标量。</entry>
    <entry key="fxpClassifierBias">数据类型需要 Bias 结构体字段，并且它必须为双精度标量。</entry>
    <entry key="UnsupportedTypes">不支持的输入数据类型。</entry>
    <entry key="ContainsMoreBits">继承的输出数据类型包含的位数已超过支持的位数。</entry>
    <entry key="PropagationViolation">数据类型传播导致了违反继承规则。手动设置此模块的数据类型和定标是一种消除此错误的方法。</entry>
    <entry key="ComSpecICOverflow">端口 ''{0}'' (''{1}'')的 ''通信'' 属性的 ''初始值'' 参数发生参数溢出{6}{7}。{8} 参数的指定值 {3}{4} 超出运行时数据类型 {2} 可以表示的范围。请将此参数的值更改为最接近的可表示值 {5}。</entry>
    <entry key="ComSpecICUnderflow">端口 ''{0}'' (''{1}'')的 ''通信'' 属性的 ''初始值'' 出现参数下溢{6}{7}。{8} 指定的值 {3}{4} 为非零值，但量化为运行时数据类型 {2} 后，该值应更改为零({5})。</entry>
    <entry key="ComSpecICPrecisionLoss">端口 ''{0}'' 的 ''通信'' 属性的 ''初始值'' (''{1}'')出现参数精度损失{6}{7}。{8} 无法使用运行时数据类型 {4} 准确表示参数 {2}{3} 的原始值。请考虑将此参数的值更改为量化值 {5}。</entry>
  </message>
</rsccat>
