<?xml version="1.0" encoding="UTF-8" ?>
<!--Copyright 2009-2024 The MathWorks, Inc. -->
<rsccat version="1.0" locale="en_US" product="SimulinkFixedPoint" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../schema/msgcat.xsd">
  <message>
    <entry key="AttemptToUseNonFiniteBitMask">Bit masks must be finite.</entry>
    <entry key="AttemptconvertNaN2Fix">Invalid data type conversion: Parameter ''{0}'' contains a NaN, which cannot be converted to the output data type ''{1}''. Consider specifying either double or single as the output data type instead.</entry>
    <entry key="FailedwriteRoundingSaturationInfoRTWfile">Failed to write Rounding/Saturation Info to .rtw file.</entry>
    <entry key="IllegalFixedPointDataType_bias_Inf">Illegal Fixed-Point Data Type: Bias cannot be Inf. {0}</entry>
    <entry key="IllegalFixedPointDataType_bias_IsNotFinite">Illegal Fixed-Point Data Type: Bias should be finite.</entry>
    <entry key="IllegalFixedPointDataType_bias_NaN">Illegal Fixed-Point Data Type: Bias cannot be NaN. {0}</entry>
    <entry key="IllegalFixedPointDataType_signed_one_bit">Illegal Fixed-Point Data Type: For signed, the number of bits must be 2 or more. {0}</entry>
    <entry key="IllegalFixedPointDataType_slope_Inf">Illegal Fixed-Point Data Type: Slope cannot be Inf. {0}</entry>
    <entry key="IllegalFixedPointDataType_slope_NaN">Illegal Fixed-Point Data Type: Slope cannot be NaN. {0}</entry>
    <entry key="IllegalFixedPointDataType_slope_not_normalized"><![CDATA[Illegal Fixed-Point Data Type: Slope must be normalized 1 <= Fslope < 2. {0}]]></entry>
    <entry key="IllegalFixedPointDataType_too_many_bits">Illegal Fixed-Point Data Type: the number of bits exceeded the supported maximum. {0}</entry>
    <entry key="IllegalFixedPointDataType_unknown_data_type_mode">Illegal Data Type: the data type mode must be double, single, boolean, fixed-point or scaled double. {0}</entry>
    <entry key="IllegalFixedPointDataType_unsigned_zero_bits">Illegal Fixed-Point Data Type: For unsigned, the number of bits must be greater than zero. {0}</entry>
    <entry key="Nameofdatatypewaslongerthansupportedmaximum">Name of data type was longer than supported maximum.</entry>
    <entry key="Overflowoccurred"><![CDATA[Wrap on overflow detected. This originated from ''{0}''<actions exclusiveFixIts="no"><action type="suppression"></action></actions>]]></entry>
    <entry key="Saturationoccurred"><![CDATA[Saturate on overflow detected. This originated from ''{0}''<actions exclusiveFixIts="no"><action type="suppression"></action></actions>]]></entry>
    <entry key="SlopeWasNotFiniteAndOutOfRange">The slope must be finite, greater than or equal to 1 and strictly less than 2.</entry>
    <entry key="SlopeWasNotFiniteAndStrictlyPositive">The slope must be finite and strictly positive.</entry>
    <entry key="Unablelogfixedpointminsandmaxsduememorylimitations">Unable to log fixed-point mins and maxs due to memory limitations.</entry>
    <entry key="Unrecognizedporttype">Unrecognized port type.</entry>
    <entry key="Unsupporteddatatype">Unsupported data type.</entry>
    <entry key="fhpCalculateFraction_inputandxdatahavesamedatatype">fhpCalculateFraction: input and XData must have same data type.</entry>
    <entry key="fhpEvenSearch_inputandxdatahasnontrivialbias">fhpEvenSearch: The data type used for evenly spaced search has a non trivial bias.</entry>
    <entry key="fhpEvenSearch_inputandxdatahavesamedatatype">fhpEvenSearch: input and XData must have same data type.</entry>
    <entry key="fhpScalarPreLookup_inputandxdatahasnontrivialbias">fhpScalarPreLookup: The data type used for evenly spaced search has a non trivial bias.</entry>
    <entry key="fhpScalarPreLookup_inputandxdatahassamedatatype">fhpScalarPreLookup: input and XData must have same data type.</entry>
    <entry key="fxpAbs_inputandoutputarenotallowedbecomplex">fxpAbs: input and output are not allowed to be complex.</entry>
    <entry key="fxpAbs_inputandoutputhavenonzerobias">fxpAbs: input and output must have non-zero bias.</entry>
    <entry key="fxpAbs_nonscalarinputbethesamesizeasoutput">fxpAbs: nonscalar input must be the same size as output.</entry>
    <entry key="fxpAccumNegCollapse_notyetconfiguredhandleinputsnonzerobias">fxpAccumNegCollapse: not yet configured to handle inputs with non-zero bias.</entry>
    <entry key="fxpAccumNegCollapse_notyetconfiguredhandleoutputsnonzerobias">fxpAccumNegCollapse: not yet configured to handle outputs with non-zero bias.</entry>
    <entry key="fxpAccumNegCollapse_outputbecomplexifinputcomplex">fxpAccumNegCollapse: output must be complex if input is complex.</entry>
    <entry key="fxpAccumNeg_nonscalarinputbethesamesizeasoutput">fxpAccumNeg: nonscalar input must be the same size as output.</entry>
    <entry key="fxpAccumNeg_notyetconfiguredhandleoutputsnonzerobias">fxpAccumNeg: not yet configured to handle outputs with non-zero bias.</entry>
    <entry key="fxpAccumNeg_outputbecomplexifinputcomplex">fxpAccumNeg: output must be complex if input is complex.</entry>
    <entry key="fxpAccumPosCollapse_notyetconfiguredhandleinputsnonzerobias">fxpAccumPosCollapse: not yet configured to handle inputs with non-zero bias.</entry>
    <entry key="fxpAccumPosCollapse_notyetconfiguredhandleoutputsnonzerobias">fxpAccumPosCollapse: not yet configured to handle outputs with non-zero bias.</entry>
    <entry key="fxpAccumPosCollapse_outputbecomplexifinputcomplex">fxpAccumPosCollapse: output must be complex if input is complex.</entry>
    <entry key="fxpAccumPos_nonscalarinputbethesamesizeasoutput">fxpAccumPos: nonscalar input must be the same size as output.</entry>
    <entry key="fxpAccumPos_notyetconfiguredhandleoutputsnonzerobias">fxpAccumPos: not yet configured to handle outputs with non-zero bias.</entry>
    <entry key="fxpAccumPos_outputbecomplexifinputcomplex">fxpAccumPos: output must be complex if input is complex.</entry>
    <entry key="fxpAndCollapse_inputandoutputarenotallowedbecomplex">fxpAndCollapse: input and output are not allowed to be complex.</entry>
    <entry key="fxpAndCollapse_outputbescalar">fxpAndCollapse: output must be a scalar.</entry>
    <entry key="fxpAndEqual_inputandoutputarenotallowedbecomplex">fxpAndEqual: input and output are not allowed to be complex.</entry>
    <entry key="fxpAndEqual_nonscalarinputbethesamesizeasoutput">fxpAndEqual: nonscalar input must be the same size as output.</entry>
    <entry key="fxpBitwiseAndCollapse_inputandoutputarenotallowedbecomplex">fxpBitwiseAndCollapse: input and output are not allowed to be complex.</entry>
    <entry key="fxpBitwiseAndCollapse_outputbescalar">fxpBitwiseAndCollapse: output must be a scalar.</entry>
    <entry key="fxpBitwiseAndEqual_inputandoutputarenotallowedbecomplex">fxpBitwiseAndEqual: input and output are not allowed to be complex.</entry>
    <entry key="fxpBitwiseAndEqual_nonscalarinputbethesamesizeasoutput">fxpBitwiseAndEqual: nonscalar input must be the same size as output.</entry>
    <entry key="fxpBitwiseComplement_inputandoutputarenotallowedbecomplex">fxpBitwiseComplement: input and output are not allowed to be complex.</entry>
    <entry key="fxpBitwiseComplement_nonscalarinputbethesamesizeasoutput">fxpBitwiseComplement: nonscalar input must be the same size as output.</entry>
    <entry key="fxpBitwiseOrCollapse_inputandoutputarenotallowedbecomplex">fxpBitwiseOrCollapse: input and output are not allowed to be complex.</entry>
    <entry key="fxpBitwiseOrCollapse_outputbescalar">fxpBitwiseOrCollapse: output must be a scalar.</entry>
    <entry key="fxpBitwiseOrEqual_inputandoutputarenotallowedbecomplex">fxpBitwiseOrEqual: input and output are not allowed to be complex.</entry>
    <entry key="fxpBitwiseOrEqual_nonscalarinputbethesamesizeasoutput">fxpBitwiseOrEqual: nonscalar input must be the same size as output.</entry>
    <entry key="fxpBitwiseXorCollapse_inputandoutputarenotallowedbecomplex">fxpBitwiseXorCollapse: input and output are not allowed to be complex.</entry>
    <entry key="fxpBitwiseXorCollapse_outputbescalar">fxpBitwiseXorCollapse: output must be a scalar.</entry>
    <entry key="fxpBitwiseXorEqual_inputandoutputarenotallowedbecomplex">fxpBitwiseXorEqual: input and output are not allowed to be complex.</entry>
    <entry key="fxpBitwiseXorEqual_nonscalarinputbethesamesizeasoutput">fxpBitwiseXorEqual: nonscalar input must be the same size as output.</entry>
    <entry key="fxpCleanBoolean_inputandoutputarenotallowedbecomplex">fxpCleanBoolean: input and output are not allowed to be complex.</entry>
    <entry key="fxpCleanBoolean_nonscalarinputbethesamesizeasoutput">fxpCleanBoolean: nonscalar input must be the same size as output.</entry>
    <entry key="fxpClient_ErrorEncountered">A fixed point client of class ''{0}'' encountered an error.</entry>
    <entry key="fxpCompare_Unsupportedrelationaloperator">fxpCompare: Unsupported relational operator.</entry>
    <entry key="fxpCompare_complextypesarenotsupported">fxpCompare: complex types are not supported.</entry>
    <entry key="fxpCompare_nonscalarinputsbethesamesizeastheoutput">fxpCompare: nonscalar inputs must be the same size as the output.</entry>
    <entry key="fxpComplement_inputandoutputarenotallowedbecomplex">fxpComplement: input and output are not allowed to be complex.</entry>
    <entry key="fxpComplement_nonscalarinputbethesamesizeasoutput">fxpComplement: nonscalar input must be the same size as output.</entry>
    <entry key="fxpConj_inputandoutputhavenonzerobias">fxpConj: input and output must have non-zero bias.</entry>
    <entry key="fxpConj_nonscalarinputbethesamesizeasoutput">fxpConj: nonscalar input must be the same size as output.</entry>
    <entry key="fxpConj_outputbecomplexifinputcomplex">fxpConj: output must be complex if input is complex.</entry>
    <entry key="fxpConvert_nonscalarinputbethesamesizeasoutput">fxpConvert: nonscalar input must be the same size as output.</entry>
    <entry key="fxpConvert_outputbecomplexifinputcomplex">fxpConvert: output must be complex if input is complex.</entry>
    <entry key="fxpConvert_thin2bool_inputandoutputbenoncomplexifinputconvertedBooleanoutput">fxpConvert_thin2bool: input and output must be non-complex if input is converted to Boolean output.</entry>
    <entry key="fxpConvert_thin2bool_nonscalarinputbethesamesizeasoutput">fxpConvert_thin2bool: nonscalar input must be the same size as output.</entry>
    <entry key="fxpCordic_complexinputnotsupported">For CORDIC approximation, complex inputs are not supported.</entry>
    <entry key="fxpCordic_inputisInforNaN">The input angle is Inf or NaN. CORDIC Approximation method does not support Inf or NaN values.</entry>
    <entry key="fxpCordic_slopebiasscaledinputnotsupported">For CORDIC approximation, an input with non-zero bias or slope that is not a power of 2 is not supported.</entry>
    <entry key="fxpDataTypeIsNotFixedPoint">Data Type is not a fixed point.</entry>
    <entry key="fxpDataTypeIsNotMultiWord">Data type is not multiword.</entry>
    <entry key="fxpDeadZone_complexcasenotsupported">fxpDeadZone: complex case not supported.</entry>
    <entry key="fxpDeadZone_neitherLoLimnorHiLimallowedbediscontiguous">fxpDeadZone: neither LoLim nor HiLim is allowed to be discontiguous.</entry>
    <entry key="fxpDeadZone_nonscalarinputsbethesamesizeastheoutput">fxpDeadZone: nonscalar inputs must be the same size as the output.</entry>
    <entry key="fxpDivideCollapse_inputdenominatorcannotcomplex">fxpDivideCollapse: input (denominator) can not be complex.</entry>
    <entry key="fxpDivide_nonscalarinputsbethesamesizeastheoutput">fxpDivide: nonscalar inputs must be the same size as the output.</entry>
    <entry key="fxpDivide_outputbecomplexifeitherinputcomplex">fxpDivide: output must be complex if either input is complex.</entry>
    <entry key="fxpDivide_secondinputdenominatorcannotcomplex">fxpDivide: second input (denominator) can not be complex.</entry>
    <entry key="fxpDivisionByZero"><![CDATA[Division by zero occurred. Quotient was saturated. This originated from ''{0}''<actions exclusiveFixIts="no"><action type="suppression"></action></actions>]]></entry>
    <entry key="fxpDotProduct_nonscalarinputsbethesamesize">fxpDotProduct: non-scalar inputs must be the same size.</entry>
    <entry key="fxpDotProduct_outputbecomplexifeitherinputcomplex">fxpDotProduct: output must be complex if either input is complex.</entry>
    <entry key="fxpDotProduct_outputbescalar">fxpDotProduct: output must be a scalar.</entry>
    <entry key="fxpFailToRegisterLegacyChunkArray">The word length must be greater than 32 to register a legacy chunk array.</entry>
    <entry key="fxpFltContainerWordLengthUnsupported">Requests for Storage Container Word Length is not supported for floating point data types.</entry>
    <entry key="fxpFltIsSignedUnsupported">Requests for IsSigned property is not supported for floating point data types.</entry>
    <entry key="fxpFltWordLengthUnsupported">Requests for Word Length property is not supported for floating point data types.</entry>
    <entry key="fxpLook1DAbove_XDataandYDatabethesamesize">fxpLook1DAbove: XData and YData must be the same size.</entry>
    <entry key="fxpLook1DAbove_neitherXDatanorYDataallowedbediscontiguous">fxpLook1DAbove: neither XData nor YData is allowed to be discontiguous.</entry>
    <entry key="fxpLook1DAbove_neitherinputnorXDataareallowedbecomplex">fxpLook1DAbove: neither input nor XData are allowed to be complex.</entry>
    <entry key="fxpLook1DAbove_nonscalarinputsbethesamesizeastheoutput">fxpLook1DAbove: nonscalar inputs must be the same size as the output.</entry>
    <entry key="fxpLook1DAbove_outputcomplexifandonlyifYDatacomplex">fxpLook1DAbove: output is complex if and only if YData is complex.</entry>
    <entry key="fxpLook1DBelow_XDataandYDatabethesamesize">fxpLook1DBelow: XData and YData must be the same size.</entry>
    <entry key="fxpLook1DBelow_neitherXDatanorYDataallowedbediscontiguous">fxpLook1DBelow: neither XData nor YData is allowed to be discontiguous.</entry>
    <entry key="fxpLook1DBelow_neitherinputnorXDataareallowedbecomplex">fxpLook1DBelow: neither input nor XData are allowed to be complex.</entry>
    <entry key="fxpLook1DBelow_nonscalarinputsbethesamesizeastheoutput">fxpLook1DBelow: nonscalar inputs must be the same size as the output.</entry>
    <entry key="fxpLook1DBelow_outputcomplexifandonlyifYDatacomplex">fxpLook1DBelow: output is complex if and only if YData is complex.</entry>
    <entry key="fxpLook1DInterpExtrap_XDataandYDatabethesamesize">fxpLook1DInterpExtrap: XData and YData must be the same size.</entry>
    <entry key="fxpLook1DInterpExtrap_neitherXDatanorYDataallowedbediscontiguous">fxpLook1DInterpExtrap: neither XData nor YData is allowed to be discontiguous.</entry>
    <entry key="fxpLook1DInterpExtrap_neitherinputnorXDataareallowedbecomplex">fxpLook1DInterpExtrap: neither input nor XData are allowed to be complex.</entry>
    <entry key="fxpLook1DInterpExtrap_nonscalarinputsbethesamesizeastheoutput">fxpLook1DInterpExtrap: nonscalar inputs must be the same size as the output.</entry>
    <entry key="fxpLook1DInterpExtrap_outputcomplexifandonlyifYDatacomplex">fxpLook1DInterpExtrap: output is complex if and only if YData is complex.</entry>
    <entry key="fxpLook1DInterpUsingIndexandFraction_complexindexorfraction">fxpLook1DInterpUsingIndexandFraction: index and fraction must be real values.</entry>
    <entry key="fxpLook1DInterpUsingIndexandFraction_inconsistentsize">fxpLook1DInterpUsingIndexandFraction: Heterogeneous width of index, fraction and output are not allowed.</entry>
    <entry key="fxpLook1DInterpUsingIndexandFraction_outputcomplexifandonlyifYDatacomplex">fxpLook1DInterpUsingIndexandFraction: output and table data must have same signal type.</entry>
    <entry key="fxpLook1DInterp_XDataandYDatabethesamesize">fxpLook1DInterp: XData and YData must be the same size.</entry>
    <entry key="fxpLook1DInterp_neitherXDatanorYDataallowedbediscontiguous">fxpLook1DInterp: neither XData nor YData is allowed to be discontiguous.</entry>
    <entry key="fxpLook1DInterp_neitherinputnorXDataareallowedbecomplex">fxpLook1DInterp: neither input nor XData are allowed to be complex.</entry>
    <entry key="fxpLook1DInterp_nonscalarinputsbethesamesizeastheoutput">fxpLook1DInterp: nonscalar inputs must be the same size as the output.</entry>
    <entry key="fxpLook1DInterp_outputcomplexifandonlyifYDatacomplex">fxpLook1DInterp: output is complex if and only if YData is complex.</entry>
    <entry key="fxpLook1DNearest_XDataandYDatabethesamesize">fxpLook1DNearest: XData and YData must be the same size.</entry>
    <entry key="fxpLook1DNearest_neitherXDatanorYDataallowedbediscontiguous">fxpLook1DNearest: neither XData nor YData is allowed to be discontiguous.</entry>
    <entry key="fxpLook1DNearest_neitherinputnorXDataareallowedbecomplex">fxpLook1DNearest: neither input nor XData are allowed to be complex.</entry>
    <entry key="fxpLook1DNearest_nonscalarinputsbethesamesizeastheoutput">fxpLook1DNearest: nonscalar inputs must be the same size as the output.</entry>
    <entry key="fxpLook1DNearest_outputcomplexifandonlyifYDatacomplex">fxpLook1DNearest: output is complex if and only if YData is complex.</entry>
    <entry key="fxpLook2DAbove_ThelengthofU0DatabethesameasthenumberofrowsofYData">fxpLook2DAbove: The length of U0Data must be the same as the number of rows of YData.</entry>
    <entry key="fxpLook2DAbove_ThelengthofU1DatabethesameasthenumberofcolumnsofYData">fxpLook2DAbove: The length of U1Data must be the same as the number of columns of YData.</entry>
    <entry key="fxpLook2DAbove_neitherU0DatanorU1DatanorYDataallowedbediscontiguous">fxpLook2DAbove: neither U0Data nor U1Data nor YData is allowed to be discontiguous.</entry>
    <entry key="fxpLook2DAbove_neithercomplexinputsnorcomplexU0Dataareallowed">fxpLook2DAbove: neither complex inputs nor complex U0Data are allowed.</entry>
    <entry key="fxpLook2DAbove_nonscalarinputsbethesamesizeastheoutput">fxpLook2DAbove: nonscalar inputs must be the same size as the output.</entry>
    <entry key="fxpLook2DAbove_outputcomplexifandonlyifYDatacomplex">fxpLook2DAbove: output is complex if and only if YData is complex.</entry>
    <entry key="fxpLook2DBelow_ThelengthofU0DatabethesameasthenumberofrowsofYData">fxpLook2DBelow: The length of U0Data must be the same as the number of rows of YData.</entry>
    <entry key="fxpLook2DBelow_ThelengthofU1DatabethesameasthenumberofcolumnsofYData">fxpLook2DBelow: The length of U1Data must be the same as the number of columns of YData.</entry>
    <entry key="fxpLook2DBelow_neitherU0DatanorU1DatanorYDataallowedbediscontiguous">fxpLook2DBelow: neither U0Data nor U1Data nor YData is allowed to be discontiguous.</entry>
    <entry key="fxpLook2DBelow_neithercomplexinputsnorcomplexU0Dataareallowed">fxpLook2DBelow: neither complex inputs nor complex U0Data are allowed.</entry>
    <entry key="fxpLook2DBelow_nonscalarinputsbethesamesizeastheoutput">fxpLook2DBelow: nonscalar inputs must be the same size as the output.</entry>
    <entry key="fxpLook2DBelow_outputcomplexifandonlyifYDatacomplex">fxpLook2DBelow: output is complex if and only if YData is complex.</entry>
    <entry key="fxpLook2DInterpExtrap_ThelengthofU0DatabethesameasthenumberofrowsofYData">fxpLook2DInterpExtrap: The length of U0Data must be the same as the number of rows of YData.</entry>
    <entry key="fxpLook2DInterpExtrap_ThelengthofU1DatabethesameasthenumberofcolumnsofYData">fxpLook2DInterpExtrap: The length of U1Data must be the same as the number of columns of YData.</entry>
    <entry key="fxpLook2DInterpExtrap_neitherU0DatanorU1DatanorYDataallowedbediscontiguous">fxpLook2DInterpExtrap: neither U0Data nor U1Data nor YData is allowed to be discontiguous.</entry>
    <entry key="fxpLook2DInterpExtrap_neithercomplexinputsnorcomplexU0Dataareallowed">fxpLook2DInterpExtrap: neither complex inputs nor complex U0Data are allowed.</entry>
    <entry key="fxpLook2DInterpExtrap_nonscalarinputsbethesamesizeastheoutput">fxpLook2DInterpExtrap: nonscalar inputs must be the same size as the output.</entry>
    <entry key="fxpLook2DInterpExtrap_outputcomplexifandonlyifYDatacomplex">fxpLook2DInterpExtrap: output is complex if and only if YData is complex.</entry>
    <entry key="fxpLook2DInterp_ThelengthofU0DatabethesameasthenumberofrowsofYData">fxpLook2DInterp: The length of U0Data must be the same as the number of rows of YData.</entry>
    <entry key="fxpLook2DInterp_ThelengthofU1DatabethesameasthenumberofcolumnsofYData">fxpLook2DInterp: The length of U1Data must be the same as the number of columns of YData.</entry>
    <entry key="fxpLook2DInterp_neitherU0DatanorU1DatanorYDataallowedbediscontiguous">fxpLook2DInterp: neither U0Data nor U1Data nor YData is allowed to be discontiguous.</entry>
    <entry key="fxpLook2DInterp_neithercomplexinputsnorcomplexU0Dataareallowed">fxpLook2DInterp: neither complex inputs nor complex U0Data are allowed.</entry>
    <entry key="fxpLook2DInterp_nonscalarinputsbethesamesizeastheoutput">fxpLook2DInterp: nonscalar inputs must be the same size as the output.</entry>
    <entry key="fxpLook2DInterp_outputcomplexifandonlyifYDatacomplex">fxpLook2DInterp: output is complex if and only if YData is complex.</entry>
    <entry key="fxpLook2DNearest_ThelengthofU0DatabethesameasthenumberofrowsofYData">fxpLook2DNearest: The length of U0Data must be the same as the number of rows of YData.</entry>
    <entry key="fxpLook2DNearest_ThelengthofU1DatabethesameasthenumberofcolumnsofYData">fxpLook2DNearest: The length of U1Data must be the same as the number of columns of YData.</entry>
    <entry key="fxpLook2DNearest_neitherU0DatanorU1DatanorYDataallowedbediscontiguous">fxpLook2DNearest: neither U0Data nor U1Data nor YData is allowed to be discontiguous.</entry>
    <entry key="fxpLook2DNearest_neithercomplexinputsnorcomplexU0Dataareallowed">fxpLook2DNearest: neither complex inputs nor complex U0Data are allowed.</entry>
    <entry key="fxpLook2DNearest_nonscalarinputsbethesamesizeastheoutput">fxpLook2DNearest: nonscalar inputs must be the same size as the output.</entry>
    <entry key="fxpLook2DNearest_outputcomplexifandonlyifYDatacomplex">fxpLook2DNearest: output is complex if and only if YData is complex.</entry>
    <entry key="fxpMagSquared_nonscalarinputsbethesamesizeastheoutput">fxpMagSquared: nonscalar inputs must be the same size as the output.</entry>
    <entry key="fxpMaxCollapse_inputandoutputarenotallowedbecomplex">fxpMaxCollapse: input and output are not allowed to be complex.</entry>
    <entry key="fxpMaxCollapse_outputbescalar">fxpMaxCollapse: output must be a scalar.</entry>
    <entry key="fxpMaxRefine_inputandoutputarenotallowedbecomplex">fxpMaxRefine: input and output are not allowed to be complex.</entry>
    <entry key="fxpMaxRefine_nonscalarinputbethesamesizeasoutput">fxpMaxRefine: nonscalar input must be the same size as output.</entry>
    <entry key="fxpMinCollapse_inputandoutputarenotallowedbecomplex">fxpMinCollapse: input and output are not allowed to be complex.</entry>
    <entry key="fxpMinCollapse_outputbescalar">fxpMinCollapse: output must be a scalar.</entry>
    <entry key="fxpMinRefine_inputandoutputarenotallowedbecomplex">fxpMinRefine: input and output are not allowed to be complex.</entry>
    <entry key="fxpMinRefine_nonscalarinputbethesamesizeasoutput">fxpMinRefine: nonscalar input must be the same size as output.</entry>
    <entry key="fxpMultiplyAccum_nonscalarinputsbethesamesizeastheoutput">fxpMultiplyAccum: nonscalar inputs must be the same size as the output.</entry>
    <entry key="fxpMultiplyAccum_notyetconfiguredhandleoutputsnonzerobias">fxpMultiplyAccum: not yet configured to handle outputs with non-zero bias.</entry>
    <entry key="fxpMultiplyAccum_outputbecomplexifeitherinputcomplex">fxpMultiplyAccum: output must be complex if either input is complex.</entry>
    <entry key="fxpMultiplyCollapse_outputbecomplexifinputcomplex">fxpMultiplyCollapse: output must be complex if input is complex.</entry>
    <entry key="fxpMultiplyMatrixAccum_dimensionsdonotagree">fxpMultiplyMatrixAccum: dimensions do not agree.</entry>
    <entry key="fxpMultiplyMatrixAccum_inputsarenotallowedbediscontiguous">fxpMultiplyMatrixAccum: inputs are not allowed to be discontiguous.</entry>
    <entry key="fxpMultiplyMatrixAccum_notyetconfiguredhandleoutputsnonzerobias">fxpMultiplyMatrixAccum: not yet configured to handle outputs with non-zero bias.</entry>
    <entry key="fxpMultiplyMatrixAccum_outputbecomplexifeitherinputcomplex">fxpMultiplyMatrixAccum: output must be complex if either input is complex.</entry>
    <entry key="fxpMultiplyMatrix_dimensionsdonotagree">fxpMultiplyMatrix: dimensions do not agree.</entry>
    <entry key="fxpMultiplyMatrix_inputsarenotallowedbediscontiguous">fxpMultiplyMatrix: inputs are not allowed to be discontiguous.</entry>
    <entry key="fxpMultiplyMatrix_outputbecomplexifeitherinputcomplex">fxpMultiplyMatrix: output must be complex if either input is complex.</entry>
    <entry key="fxpMultiply_nonscalarinputsbethesamesizeastheoutput">fxpMultiply: nonscalar inputs must be the same size as the output.</entry>
    <entry key="fxpMultiply_outputbecomplexifeitherinputcomplex">fxpMultiply: output must be complex if either input is complex.</entry>
    <entry key="fxpNetScalingDiagnosticOverflow"><![CDATA[Net scaling quantization caused overflow. The original value for {0} was {1}. The quantized value was {2} with an error of {3}.{4}<actions exclusiveFixIts="no"><action type="suppression"></action></actions>]]></entry>
    <entry key="fxpNetScalingDiagnosticPrecisionLoss"><![CDATA[Net scaling quantization caused precision loss. The original value for {0} was {1}. The quantized value was {2} with an error of {3}.{4}<actions exclusiveFixIts="no"><action type="suppression"></action></actions>]]></entry>
    <entry key="fxpNetScalingDiagnosticUnderflow"><![CDATA[Net scaling quantization caused underflow. The original value for {0} was {1}. The quantized value was {2} with an error of {3}.{4}<actions exclusiveFixIts="no"><action type="suppression"></action></actions>]]></entry>
    <entry key="fxpNetScalingDiagnosticUnderflowNoQuantError"><![CDATA[Net scaling quantization caused underflow from {0}. The original value was {1}.<actions exclusiveFixIts="no"><action type="suppression"></action></actions>]]></entry>
    <entry key="fxpNonPowerofTwoFractionLengthUnsupported">Requests for FractionLength property is not supported for data types with non-power of two slopes.</entry>
    <entry key="fxpNonZeroBiasFractionLengthUnsupported">Requests for FractionLength property is not supported for data types with non-zero biases.</entry>
    <entry key="fxpOrCollapse_inputandoutputarenotallowedbecomplex">fxpOrCollapse: input and output are not allowed to be complex.</entry>
    <entry key="fxpOrCollapse_outputbescalar">fxpOrCollapse: output must be a scalar.</entry>
    <entry key="fxpOrEqual_inputandoutputarenotallowedbecomplex">fxpOrEqual: input and output are not allowed to be complex.</entry>
    <entry key="fxpOrEqual_nonscalarinputbethesamesizeasoutput">fxpOrEqual: nonscalar input must be the same size as output.</entry>
    <entry key="fxpParameterOverflowOld"><![CDATA[Parameter overflow occurred for ''{0}'' of ''{1}''. The parameter''s value is outside the range that the run-time data type can represent. The specified value was saturated to the closest representable value. To disable this warning or error, in the Configuration Parameters > Diagnostics > Data Validity pane, set the ''Detect overflow'' option in the Parameters group to ''none''.<actions exclusiveFixIts="no"><action type="suppression"></action></actions>]]></entry>
    <entry key="paramQuantLossTimes">times </entry>
    <entry key="firstOccurrence">First occurrence: </entry>
    <entry key="fxpParameterOverflow" note="for one occurrence, holes 8, 9 and 10 are empty; for two or more occurrences, hole 8 is an integer number, hole 9 see entry paramQuantLossTimes, hole 10 see entry firstOccurence"><![CDATA[Parameter overflow occurred{8}{9} for ''{0}'' of ''{1}''. The value of the parameter is outside the range that the run-time data type {2} can represent. {10} The specified value, {3}{4}, was saturated to the closest representable value {5}. Quantization error occurred with an absolute difference of {6} and a relative difference of {7_Double}.
    <actions exclusiveFixIts="yes">
       <action type="suggestion">
          <cmd>Simulink.output.ParamDiagnosticFixits.fix('OpenParamQuantizeManager',''{0}'',''{1}'');</cmd>
          <txt>To review details in the Parameter Quantization Advisor app, click the Open button.</txt>
       </action>
       <action type="suppression"></action>
       </actions>]]></entry>
    <entry key="fxpParameterPrecisionLossOld"><![CDATA[Parameter precision loss occurred for ''{0}'' of ''{1}''. The parameter''s value cannot be represented exactly using the run-time data type. A small quantization error has occurred. To disable this warning or error, in the Configuration Parameters > Diagnostics > Data Validity pane, set the ''Detect precision loss'' option in the Parameters group to ''none''.<actions exclusiveFixIts="no"><action type="suppression"></action></actions>]]></entry>
    <entry key="fxpParameterPrecisionLoss" note="for one occurrence, holes 8, 9 and 10 are empty; for two or more occurrences, hole 8 is an integer number, hole 9 see entry paramQuantLossTimes, hole 10 see entry firstOccurence"><![CDATA[Parameter precision loss occurred{8}{9} for ''{0}'' of ''{1}''. {10} The original value of the parameter, {2}{3}, cannot be represented exactly using the run-time data type {4}. The value is quantized to {5}. Quantization error occurred with an absolute difference of {6} and a relative difference of {7_Double}.
    <actions exclusiveFixIts="yes">
       <action type="suggestion">
         <cmd>Simulink.output.ParamDiagnosticFixits.fix('HighlightParam',''{1}'','ParameterPrecisionLossMsg');</cmd>
         <txt>To control the level of precision loss at which a warning or error is issued, adjust the diagnostic threshold settings.</txt>
       </action>
       <action type="suggestion">
          <cmd>Simulink.output.ParamDiagnosticFixits.fix('OpenParamQuantizeManager',''{0}'',''{1}'');</cmd>
          <txt>To review details in the Parameter Quantization Advisor app, click the Open button.</txt>
       </action>
       <action type="suppression"></action>
       </actions>]]></entry>   
    <entry key="fxpParameterUnderflowOld"><![CDATA[Parameter underflow occurred for ''{0}'' of ''{1}''. The parameter''s value is non-zero, but after quantization to the run-time data type the value is zero. To disable this warning or error, in the Configuration Parameters > Diagnostics > Data Validity pane, set the ''Detect underflow'' option in the Parameters group to ''none''.<actions exclusiveFixIts="no"><action type="suppression"></action></actions>]]></entry>
    <entry key="fxpParameterUnderflow" note="for one occurrence, holes 8, 9 and 10 are empty; for two or more occurrences, hole 8 is an integer number, hole 9 see entry paramQuantLossTimes, hole 10 see entry firstOccurence"><![CDATA[Parameter underflow occurred{8}{9} for ''{0}'' of ''{1}''. {10} The value of the parameter, {2}{3}, is non-zero, but after quantization to the run-time data type {4}, the value is zero ({5}). Quantization error occurred with an absolute difference of {6} and a relative difference of {7_Double}.
    <actions exclusiveFixIts="yes">      
       <action type="suggestion">
          <cmd>Simulink.output.ParamDiagnosticFixits.fix('OpenParamQuantizeManager',''{0}'',''{1}'');</cmd>
          <txt>To review details in the Parameter Quantization Advisor app, click the Open button.</txt>
       </action>
       <action type="suppression"></action>
       </actions>]]></entry>
    <entry key="fxpPreLookup_XDataNotAllowedbediscontiguous">fxpPreLookup: breakpoint is not allowed to have heterogeneous properties.</entry>
    <entry key="fxpPreLookup_neitherIndexnorFractionareallowedbecomplex">fxpPreLookup: the index and fraction can not be complex.</entry>
    <entry key="fxpReciprocal_inputdenominatorcannotcomplex">fxpReciprocal: input (denominator) can not be complex.</entry>
    <entry key="fxpReciprocal_nonscalarinputsbethesamesizeastheoutput">fxpReciprocal: nonscalar inputs must be the same size as the output.</entry>
    <entry key="fxpSFunBlockNotSupportRTW33Plus">To handle any fixed-point data type with more than 32 bits, this S-function must call ssFxpSetU32BitRegionCompliant in the mdlInitializeSizes function. To avoid this, insert a gateway block before and after this S-function block.</entry>
    <entry key="fxpSFunEmptyParameter">A parameter is empty in S-function ''{0}''.</entry>
    <entry key="fxpSFunParamHasWrongNum">A parameter of S-function ''{0}'' does not have the correct number of elements.</entry>
    <entry key="fxpSFunParamNotDouble">A parameter of S-function ''{0}'' must be of type double.</entry>
    <entry key="fxpSFunParamIsNotNumber">A scalar parameter of S-function ''{0}'' must be a number.</entry>
    <entry key="fxpSFunParamIsNotString" note="stringDatatypeUpdate">A parameter of S-function ''{0}'' must be a character vector.</entry>
    <entry key="fxpSFunParamIsNotVector">A parameter of S-function ''{0}'' must be a real vector.</entry>
    <entry key="fxpSFunParamNotSupportHalfType">A parameter of S-function ''{0}'' cannot be of half precision data type.</entry>
    <entry key="fxpSFuncLegacyError">Error reported by S-function ''{0}'' in ''{1}'': {2}</entry>
    <entry key="fxpScaledDoubleContainerWordLengthUnsupported">Requests for Storage Container Word Length is not supported for ScaledDouble data types.</entry>
    <entry key="fxpSignExtensionViolation">Emulation bits violate sign extension.</entry>
    <entry key="fxpSqrt_complexinputnotsupported">Complex inputs for integer and fixed-point data types are not supported for block ''{0}''.</entry>
    <entry key="fxpSqrt_complexoutputnotsupported">Complex outputs for integer and fixed-point data types are not supported for block ''{0}''.</entry>
    <entry key="fxpSqrt_inputoutputmismatchsize">The input and output signal dimensions must be the same. Otherwise the input must be a scalar.</entry>
    <entry key="fxpSqrt_invalidIntermediateDtypeWL">Invalid word length for ''Intermediate results data type''. It needs at least 4 bits.</entry>
    <entry key="fxpSqrt_negativeinput">Square root of a negative number.</entry>
    <entry key="fxpSqrt_negativeinputnotsupported">Negative inputs for integer and fixed-point data types are not supported for block ''{0}''.</entry>
    <entry key="fxpSqrt_slopebiasscaledinputoutputnotsupported">Inputs and outputs with non-zero biases or slopes that are not a power of 2 are not supported for block ''{0}''.</entry>
    <entry key="fxpSqrt_outoffxprepresentationrange">fxpSqrt: Data is out of the fixed-point representation range.</entry>
    <entry key="fxpStorageContainerUnsupported">Attempt to identify storage container for unsupported type.</entry>
    <entry key="fxpSumPosCollapse_notyetconfiguredhandleinputsnonzerobias">fxpSumPosCollapse: not yet configured to handle inputs with non-zero bias.</entry>
    <entry key="fxpSumPosCollapse_notyetconfiguredhandleoutputsnonzerobias">fxpSumPosCollapse: not yet configured to handle outputs with non-zero bias.</entry>
    <entry key="fxpSumPosCollapse_outputbecomplexifinputcomplex">fxpSumPosCollapse: output must be complex if input is complex.</entry>
    <entry key="fxpSumPosCollapse_outputbescalar">fxpSumPosCollapse: output must be a scalar.</entry>
    <entry key="fxpThisOriginatedFrom">This originated from ''{0}''.</entry>
    <entry key="fxpUnaryMinus_inputandoutputhavenonzerobias">fxpUnaryMinus: input and output must have non-zero bias.</entry>
    <entry key="fxpUnaryMinus_nonscalarinputbethesamesizeasoutput">fxpUnaryMinus: nonscalar input must be the same size as output.</entry>
    <entry key="fxpUnaryMinus_outputbecomplexifinputcomplex">fxpUnaryMinus: output must be complex if input is complex.</entry>
    <entry key="fxpUnsupportedDataTypeId">The data type id does not correspond to a Simulink builtin or fixed-point data type.</entry>
    <entry key="fxpXorCollapse_inputandoutputarenotallowedbecomplex">fxpXorCollapse: input and output are not allowed to be complex.</entry>
    <entry key="fxpXorCollapse_outputbescalar">fxpXorCollapse: output must be a scalar.</entry>
    <entry key="fxpXorEqual_inputandoutputarenotallowedbecomplex">fxpXorEqual: input and output are not allowed to be complex.</entry>
    <entry key="fxpXorEqual_nonscalarinputbethesamesizeasoutput">fxpXorEqual: nonscalar input must be the same size as output.</entry>
    <entry key="fxpZeroValueError">Value should not be zero.</entry>
    <entry key="fxppVoidDestSizeMismatch">The pVoidDest pointed to memory that was not the correct size for the specified data type id.</entry>
    <entry key="fxppVoidSrcSizeMismatch">The pVoidSrc pointed to memory that was not the correct size for the specified data type id.</entry>
    <entry key="DataTypePropErrorInDTProp">Data Type Propagation caused violation of inheritance rule. Manually setting the data type and scaling for this block is one way to eliminate this error.</entry>
    <entry key="UnsupportedInputdatatype">Block ''{0}'' has unsupported input data type.</entry>
    <entry key="UnsupportedOutputdatatype">Block ''{0}'' has unsupported output data type.</entry>
    <entry key="UnsupportedNumOfBits">Inherited output data type contains more bits than is supported.</entry>
    <entry key="fxptpropDataTypeConflict"><![CDATA[In block ''{0}'', another block has already set the data type of the <sldiag objui="inport" objparam="3" objname="{0}">input port 3</sldiag>. The data type does not agree with the one that this block would set. ]]></entry>
    <entry key="fxptpropInportFinite">In block ''{0}'', the specified number of input ports must be finite, positive, and less than 1001. </entry>
    <entry key="fxptpropUnsupportedOperationId">In block ''{0}'', unsupported operation id passed to S-function. </entry>
    <entry key="fxptpropInsufficientNumParameter">In block ''{0}'', not enough parameters passed to S-function.</entry>
    <entry key="fxptpropUnsupportedInputType">Block ''{0}'' has unsupported input data type.</entry>
    <entry key="fxptpropUnknownIsSignedValue">Block ''{0}'' has unrecognized choice for setting isSigned. </entry>
    <entry key="fxptpropUnknownNumBits">Block ''{0}'' has unrecognized choice for the Number-of-Bits Base.</entry>
    <entry key="fxptpropTooFewNumBits">Block ''{0}'' has data type propagation error: too few bits.</entry>
    <entry key="fxptpropTooManyNumBits">Block ''{0}'' has data type propagation error: too many bits. </entry>
    <entry key="fxptpropUnknownSlope">Block ''{0}'' has unrecognized choice for Slope Base </entry>
    <entry key="fxptpropNegSlope">Block ''{0}'' has data type propagation error: slope negative or zero. </entry>
    <entry key="fxptpropUnknownBias">Block ''{0}'' has unrecognized choice for Bias Base </entry>
    <entry key="fxptpropUnsupportedNumBits">Block ''{0}'' has data type propagation error: more bits than allowed </entry>
    <entry key="fxpBitOpNotOneInput">In block ''{0}'', the NOT operation accepts one and only one input port.</entry>
    <entry key="fxpBitOpPositive">In block ''{0}'', the number of input ports must be positive.</entry>
    <entry key="fxpBitOpUnsupportedOps">In block ''{0}'', unsupported logical operation has been selected.</entry>
    <entry key="fxpBitOpUnsupportedBitMask">Block ''{0}'' could not allocate memory for Bit Mask processing.</entry>
    <entry key="fxpUserDataNotNull">In block ''{0}'', user data must be NULL before it is allocated and initialized. </entry>
    <entry key="fxpUserDataAllocateFail">Block ''{0}'' is unable to allocate memory for user data. </entry>
    <entry key="fxpBitOpInputPropAllocateFail">Block ''{0}'' is unable to allocate memory for input properties.</entry>
    <entry key="fxpBitOpMaskVecAllocateFail">Block ''{0}'' is unable to allocate memory for mask vector. </entry>
    <entry key="fxpBitOpUnsupportedPortType">Block ''{0}'' has unsupported port data type. </entry>
    <entry key="fxpBitOpUnsupportedFloatType">Block ''{0}'' does not support true floating point data types. </entry>
    <entry key="fxpBitOpOutTypeIncompatible">In block ''{0}'', the output port data type was not compatible with the data type determine by the block's propagation rule. </entry>
    <entry key="fxpBitOpInTypeIncompatible">In block ''{0}'', an input port data type was not compatible with the data type determined by the block's propagation rule. </entry>
    <entry key="fxpMultiWordConvR2007aLegacy">The fixed-point ChunkArray memory format used in R2007a and earlier is no longer supported. You should delete block ''{0}'' and update any of your old fixed-point S-functions to use the memory layout introduced in R2007b.</entry>
    <entry key="fxpMultiWordConvInputWidth">In block ''{0}'', input port width not compatible with output port width. </entry>
    <entry key="fxpFirAllocateMemInitCondition">Block ''{0}'' is unable to allocate memory for initial conditions. </entry>
    <entry key="fxpFirIllegalContSampleTime">Block ''{0}'' has illegally inherited a continuous sample time.</entry>
    <entry key="fxpFirInitCondNotAgreeGain">In block ''{0}'', the number of initial conditions does not agree with the gain. The number of initial conditions should equal one, or the number of initial conditions should equal one less than the number of columns in the gain. </entry>
    <entry key="fxpFirSampleTime">In block ''{0}'', sample time must contain one or two elements sample time and an optional offset time. </entry>
    <entry key="fxpFirInvalidSampleTime">Block ''{0}'' has invalid sample time</entry>
    <entry key="fxpFirSampleTimeOffsetZero">In block ''{0}'', for inherited sample time: offset must be zero.</entry>
    <entry key="fxpFirOffsetLessThanSampleTime">In block ''{0}'', offset must be less than sample time. </entry>
    <entry key="fxpFirRadixOnly">In block ''{0}'', gain scaling must be radix only, so Slope must be a power of two, and Bias must be zero. </entry>
    <entry key="fxpOutputPortDimsIncompatible">In block ''{0}'', output port dimension not compatible with first input port.</entry>
    <entry key="fxpBpTablePortWidthNoLessThanTwo">In block ''{0}'', breakpoint and table port width must be equal to or greater than 2.</entry>
    <entry key="fxpBpTablePortDimsIncompatible">Breakpoint port dimension not compatible with table port.</entry>
    <entry key="fxpBpTablePortDimensionMustBeSpec">In block ''{0}'', breakpoint and table port dimensions must be specified, they cannot be back-inherited. Recommendation: specify breakpoint port or table port dimensions using upstream blocks.</entry>
    <entry key="fxpSameSlopeBias">In block ''{0}'', input 1 and 2 must have the same bias and the same fractional slope.</entry>
    <entry key="fxpSameSignedness">In block ''{0}'', input 1 and 2 must both be signed or both be unsigned.</entry>
    <entry key="fxpLessPrecision">In block ''{0}'', input 1 is not allowed to have less precision than input 2. The slope of Input 1 must be less than or equal to the slope of Input 2.</entry>
    <entry key="fxpRangeMismatch">In block ''{0}'', input 1 is not allowed to have less range than input 2. A combination of the following steps can be used to solve the range problem. The number of bits for Input 2 can be decreased relative to Input 1. The slope of Input 2 can be reduced down to but not lower than the slope of Input 1.</entry>
    <entry key="fxpSameSlopeBiasOutIn3">In block ''{0}'', output and Input 3 must have the same bias and the same fractional slope.</entry>
    <entry key="fxpUnsupportTableMethod">Block ''{0}'' has unrecognized lookup table method.</entry>
    <entry key="fxpInvalidTableMethod">Invalid lookup method.</entry>
    <entry key="fxpNonMonotonicIncreasingErr">In block ''{0}'', the xdat vector is the breakpoint data, which must be strictly monotonically increasing.</entry>
    <entry key="fxpInitCondNumMismatch">In block ''{0}'', number of initial conditions does not agree with number of delays.</entry>
    <entry key="fxpNumDelayFloatOrInt">In block ''{0}'', the data type for number of delays must be double, single, or integer.</entry>
    <entry key="fxpNumDelayNonFrac">In block ''{0}'', the number of delays must be a positive integer.</entry>
    <entry key="fxpNumDelayPositive">In block ''{0}'', the number of delays must be positive.</entry>
    <entry key="fxpNumDelayPositiveOrInherited">In block ''{0}'', the number of delays must be positive or -1 for inherited.</entry>
    <entry key="fxpNumOutputDelayPositiveOrInherited">In block ''{0}'', the number of delays to output must be positive or -1 for inherited.</entry>
    <entry key="fxpDSPLicense">Block ''{0}'' is unable to check out a license for the DSP System Toolbox.</entry>
    <entry key="fxpInputSampleBased">In block ''{0}'', when the 'Input processing' parameter is set to 'Elements as channels (Sample-based)', the input must be a sample-based signal.</entry>
    <entry key="tapDelayUnsupportFrameBased">The Tapped Delay Block, ''{0}'', does not support frame based signals</entry>
    <entry key="tapDelayWidthIncorrect">The Tapped Delay Block, ''{0}'', must have output port width greater than 1 when including the current input in the output vector.</entry>
    <entry key="fxpDelayExceedChannelLength">In block ''{0}'', the number of delays exceeds the channel length of the frame input.</entry>
    <entry key="fxpInitCondScaler">In block ''{0}'', for frame based inputs the initial conditions have to be a scalar.</entry>
    <entry key="fxpDelayNumExceed">In block ''{0}'', the number of delays exceeds the upper limit: the maximum value of a 32-bit integer divided by the input data type size in bytes.</entry>
    <entry key="fxpNumDelayFailMemAlloc">Block ''{0}'' has memory Allocation Error. The number of delays is too high to allocate memory for states.</entry>
    <entry key="fxpOutputScalar">In block ''{0}'', output must be a scalar, vector or 1-D matrix.</entry>
    <entry key="compDblWithMinMaxFixPtValueRequiresSixInputs">compDblWithMinMaxFixPtValue requires six input arguments.</entry>
    <entry key="compDblWithMinMaxFixPtValueRequiresOneOutputs">compDblWithMinMaxFixPtValue requires one output argument.</entry>
    <entry key="compDblWithMinMaxFixPtValueInvalidMantBits1">compDblWithMinMaxFixPtValue requires MantBits be a positive integer between 1 and 128 inclusive for unsigned fixed-point data type.</entry>
    <entry key="compDblWithMinMaxFixPtValueInvalidMantBits2">compDblWithMinMaxFixPtValue requires MantBits be a positive integer between 2 and 128 inclusive for signed fixed-point data type.</entry>
    <entry key="compDblWithMinMaxFixPtValueRequiresDouble">compDblWithMinMaxFixPtValue requires that DblValue be double.</entry>
    <entry key="compDblWithMinMaxFixPtValueSupportsScalarOnly">compDblWithMinMaxFixPtValue only supports scalar.</entry>
    <entry key="compDblWithMinMaxFixPtValueIsSignedZeroOrOne">compDblWithMinMaxFixPtValue requires that IsSigned be 0 or 1.</entry>
    <entry key="compDblWithMinMaxFixPtValueFixExpInteger">compDblWithMinMaxFixPtValue requires FixExp be an integer.</entry>
    <entry key="compDblWithMinMaxFixPtValueFracSlopeRestriction">compDblWithMinMaxFixPtValue requires FracSlope to be between 1.0 and 2.0.</entry>
    <entry key="compDblWithMinMaxFixPtValueFiniteBias">compDblWithMinMaxFixPtValue requires Bias to be finite.</entry>
    <entry key="fxpMW2DecStrTwoInputs">fixpt_convertMW2DecString requires two input arguments.</entry>
    <entry key="fxpMW2DecStrOneOutput">fixpt_convertMW2DecString requires one output argument.</entry>
    <entry key="fxpMW2DecStrMxMWValueBeString" note="stringDatatypeUpdate">fixpt_convertMW2DecString requires that mxMWValue be a character vector.</entry>
    <entry key="fxpMW2DecStrBitsOfLongBeDouble">fixpt_convertMW2DecString requires that bitsOfLong be double.</entry>
    <entry key="fxpMW2DecStrWrongMultiWordString" note="stringDatatypeUpdate">The multiword character vector is not correct.</entry>
    <entry key="fxpMW2DecStrWrongMultiError">fixpt_convertMW2DecString got an error.</entry>
    <entry key="sfix_dtpropBitLess">Block {0}: After applying the multiplicative and additive adjustments, the propagated number of bits was less than the minimum {1} bits required for signed numbers.  The number of bits will be increased to the minimum allowable final value.</entry>
    <entry key="fxpClassifierEmptyDataType">A data type must be specified.</entry>
    <entry key="fxpClassifierSignedness">The data type requires an IsSigned struct field and it must be a scalar logical.</entry>
    <entry key="fxpClassifierWordLength">The data type requires a WordLength struct field and it must be a scalar integer.</entry>
    <entry key="fxpClassifierWrongNumFields">A data type must have the following fields: IsSigned, WordLength, FractionLength or IsSigned, WordLength, Slope, Bias.</entry>
    <entry key="fxpClassifierFractionLength">The data type requires a FractionLength struct field and it must be a scalar integer.</entry>
    <entry key="fxpClassifierSlope">The data type requires a Slope struct field and it must be a scalar double.</entry>
    <entry key="fxpClassifierBias">The data type requires a Bias struct field and it must be a scalar double.</entry>
    <entry key="UnsupportedTypes">Unsupported input data type.</entry>
    <entry key="ContainsMoreBits">Inherited output data type contains more bits than is supported.</entry>
    <entry key="PropagationViolation">Data Type Propagation caused violation of inheritance rule. Manually setting the data type and scaling for this block is one way to eliminate this error.</entry>

    <!-- ComSpec related entries-->
    <entry key="ComSpecICOverflow" note="for one occurrence, holes 6, 7 and 8 are empty; for two or more occurrences, hole 6 is an integer number, hole 7 see entry paramQuantLossTimes, hole 8 see entry firstOccurence">Parameter overflow occurred{6}{7} for the ''Initial value'' of ''Communication'' property of port ''{0}'' (''{1}''). {8} The specified value {3}{4} of the parameter is outside the range that the run-time data type {2} can represent. Change the value of this parameter to be within the closet representable value {5}.</entry>
    <entry key="ComSpecICUnderflow" note="for one occurrence, holes 6, 7 and 8 are empty; for two or more occurrences, hole 6 is an integer number, hole 7 see entry paramQuantLossTimes, hole 8 see entry firstOccurence">Parameter underflow occurred{6}{7} for the ''Initial value'' of ''Communication'' property of port ''{0}'' (''{1}''). {8} The specified value {3}{4}, is non-zero, but after quantization to the run-time data type {2}, the value should changed to zero ({5}).</entry>
    <entry key="ComSpecICPrecisionLoss" note="for one occurrence, holes 6, 7 and 8 are empty; for two or more occurrences, hole 6 is an integer number, hole 7 see entry paramQuantLossTimes, hole 8 see entry firstOccurence">Parameter precision loss occurred{6}{7} for the ''Initial value'' of ''Communication'' property of port ''{0}'' (''{1}''). {8} The original value of the parameter, {2}{3}, cannot be represented exactly using the run-time data type {4}. Consider changing the value of this parameter to quantized value {5}.</entry>   
  </message>
</rsccat>

<!-- LocalWords:  discontiguous Fslope mins maxs fhp Lim DAbove DBelow DInterp Fixits
     LocalWords:  Extrap Indexand DNearest Dest xdat Mant
-->
