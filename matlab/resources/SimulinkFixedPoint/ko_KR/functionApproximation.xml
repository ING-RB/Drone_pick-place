<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ko_KR" product="SimulinkFixedPoint" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="invalidFunctionToApproximate">Invalid input to 'FunctionApproximation.Problem'. Function to approximate must be stateless, time invariant, vectorized, and perform element-wise operations. For more information, see &lt;a href="matlab:helpview(fullfile(docroot,'fixedpoint','fixedpoint.map'), 'luto_vectorization')"&gt;documentation&lt;/a&gt;.</entry>
    <entry key="typeMustBeNumerictype">Input must be a embedded.numerictype or Simulink.NumericType.</entry>
    <entry key="invalidBlockPath">Block path is invalid.</entry>
    <entry key="invalidSubsystemPath">Subsystem block is in a configuration that is not supported for approximation.</entry>
    <entry key="blockTypeNotSupported">선택된 블록은 근사에서 지원되지 않습니다. Subsystem 블록, Math Function 블록, Trigonometric Function 블록 또는 n-D Lookup 블록을 선택하십시오.</entry>
    <entry key="functionNotVectorized">Function to approximate must be stateless, time invariant, vectorized, and perform element-wise operations. For more information, see &lt;a href="matlab:helpview(fullfile(docroot,'fixedpoint','fixedpoint.map'), 'luto_vectorization')"&gt;documentation&lt;/a&gt;.</entry>
    <entry key="inputDimensionsMustBeLessThan">Function to approximate has {0} input dimensions. Number of inputs dimensions must be between 1 and {1}.</entry>
    <entry key="numberOfElementsInLowerBoundsEqualToInputDimensions">Number of elements in input lower bounds must be equal to the number of input dimensions.</entry>
    <entry key="numberOfElementsInUpperBoundsEqualToInputDimensions">입력 상한의 요소 개수는 입력 차원 수와 같아야 합니다.</entry>
    <entry key="correctingAbsTol">입력 상한의 요소 개수는 입력 차원 수와 같아야 합니다.</entry>
    <entry key="inputTypeClassCheck">입력 유형은 'embedded.numerictype' 또는 'Simulink.NumericType'이어야 합니다.</entry>
    <entry key="outputTypeInvalid">출력 유형이 유효하지 않습니다.</entry>
    <entry key="outputTypeClassCheck">출력 유형은 'embedded.numerictype' 또는 'Simulink.NumericType'이어야 합니다.</entry>
    <entry key="onlyOneOutputType">출력 유형은 오직 하나여야 합니다.</entry>
    <entry key="outputTypeMustBeFullySpecified">출력 유형을 완전히 지정해야 합니다.</entry>
    <entry key="customFunctionHandle">사용자 지정 함수 핸들이 감지되었습니다. 이 기능은 베타 단계에 있습니다.</entry>
    <entry key="lowerBoundSnapped">Minimum for input {0} has been set to the minimum representable value of the type {1}.</entry>
    <entry key="upperBoundSnapped">입력 {0}의 최댓값이 {1} 유형의 표현 가능한 최댓값으로 설정되었습니다.</entry>
    <entry key="lowerBoundMustBeSpecifiedIfTypeIsDouble">데이터형이 부동소수점 데이터형이므로, 차원 {0}의 최솟값을 지정해야 합니다.</entry>
    <entry key="upperBoundMustBeSpecifiedIfTypeIsDouble">데이터형이 부동소수점 데이터형이므로, 차원 {0}의 최댓값을 지정해야 합니다.</entry>
    <entry key="needBoundsForScaling">입력 유형의 스케일링을 결정하려면 차원 {0}에 대한 상한 및 하한을 제공해야 합니다.</entry>
    <entry key="absTolMustBeGreaterThan">Absolute tolerance must be greater than or equal to {0}.</entry>
    <entry key="outputTypePrecisionInsufficient">출력 유형 정밀도가 충분하지 않습니다.</entry>
    <entry key="explicitValuesNotAllowedOnlyFor">{0} 사양은 {1} 입력 차원을 갖는 함수에만 사용 가능합니다. 균일 간격만 시도됩니다.</entry>
    <entry key="issuesWhileSettingBounds">입력 범위가 유효하지 않습니다.</entry>
    <entry key="boundsMustBeNumeric">범위는 숫자형이어야 합니다.</entry>
    <entry key="increaseOutputRepresentableRange">Approximation not possible. The function to approximate evaluates to {0} at {1}. The evaluation must be in the range of {2}. Try changing input bounds or output type. Alternatively, saturate the original function's output to the output type by setting the "SaturateToOutputType" property of the FunctionApproximation.Options object associated with the Problem definition to "true".</entry>
    <entry key="approximationNotPossible">Unable to find a solution using the current options. Edit the options to find a solution.</entry>
    <entry key="comparisonNotPossibleGreaterThan2D">No comparison available when number of input dimensions is greater than 2.</entry>
    <entry key="numberOfInputTypesMustMatchDimensions">Number of input types must match number of input dimensions.</entry>
    <entry key="mathBlockModeNotSupported">현재 모드에서 Math 블록은 지원되지 않습니다.</entry>
    <entry key="useOneInputPortForAllInputData">Look-Up Table 블록에서는 모든 입력 데이터에 포트를 1개만 허용합니다. 해당 블록은 이 모드에서 지원되지 않습니다.</entry>
    <entry key="interpMethodCubicSpline">LUT 블록의 보간 방법은 3차 스플라인입니다. 현재 모드에서 블록은 값으로 구성된 벡터를 허용하도록 설정되지 않았습니다.</entry>
    <entry key="allDataMustBeFromLUTBlock">블록 파라미터 대화 상자 또는 Simulink.LookupTable 객체를 사용하여 테이블 데이터와 절점을 지정해야 합니다.</entry>
    <entry key="lutNotFoundForMemoryCalculation">No LUTs were found.</entry>
    <entry key="memoryExceedsTheSpecifiedLimit">지정한 최대 메모리 사용량이 제한을 초과합니다. 디폴트 값 {0}이(가) 사용됩니다.</entry>
    <entry key="originalLUTBest">원래 룩업 테이블을 추가로 압축할 수 없습니다.</entry>
    <entry key="bestSolution">최선해</entry>
    <entry key="bestInfeasibleSolution">실현 가능하지 않는 최선해</entry>
    <entry key="invalidIDToGetSolution">ID must belong to {0}.</entry>
    <entry key="upperLesserThanLowerBound">Upper bound is less than or equal to the lower bound when both are quantized to the input type for dimension {0}.</entry>
    <entry key="functionEvaluatesToInfAt">다음 입력 값에 대해 함수가 Inf로 평가됨: {0}.</entry>
    <entry key="functionEvaluatesToInfAtAndMore">Function evaluates to Inf for the following input values: {0}, ...</entry>
    <entry key="boundsModifiedToBeRepresentableByInputTypes">범위는 지정된 출력 데이터형으로 표현 가능해야 합니다. 입력 하한과 입력 상한을 각각 {0} 및 {1}(으)로 변경하여 표현 가능하면서 지정된 범위를 포함하도록 했습니다.</entry>
    <entry key="functionEvaluatesToNaNAt">다음 입력 값에 대해 함수가 NaN으로 평가됨: {0}.</entry>
    <entry key="functionEvaluatesToNaNAtAndMore">Function evaluates to NaN for the following input values: {0}, ...</entry>
    <entry key="updateDiagramError">다이어그램을 업데이트할 수 없습니다. 모델 {0}을(를) 오류 없이 시뮬레이션할 수 있는지 확인하십시오.</entry>
    <entry key="unmatchedFields">{0}에 대해 일치하지 않는 필드가 발견됨: {1}.</entry>
    <entry key="cannotConvertToStruct">Unable to convert {0} to a struct.</entry>
    <entry key="scopeResults">스코프를 열어 시뮬레이션 결과 보기</entry>
    <entry key="withProperties">- 속성 있음:</entry>
    <entry key="inputTypesWLGreaterThan128">하나 이상의 입력 유형의 워드 길이가 128보다 큽니다. 모든 입력 유형의 워드 길이는 128보다 작거나 같아야 합니다.</entry>
    <entry key="outputTypeWLGreaterThan128">출력 유형의 워드 길이가 128보다 큽니다. 출력 유형의 워드 길이는 128보다 작거나 같아야 합니다.</entry>
    <entry key="plotterInput">입력</entry>
    <entry key="plotterFunctionValue">함수 값</entry>
    <entry key="plotterErrors">오차</entry>
    <entry key="plotterInputDimX">입력 차원 {0}</entry>
    <entry key="plotterOriginalSaturated">포화된 원래 함수</entry>
    <entry key="plotterOriginal">원래</entry>
    <entry key="plotterApproximation">근사</entry>
    <entry key="plotterAbsDiff">절대 오차: abs({0} - {1})</entry>
    <entry key="plotterMaxDiff">허용된 최대 오차: max(abs({0}) * RelTol, AbsTol)</entry>
    <entry key="canReplaceOnlyBlocks">Original function is not a block. Unable to replace original function.</entry>
    <entry key="canRevertOnlyBlocks">Original function is not a block. Unable to revert to original function.</entry>
    <entry key="approximateDescription">이 블록은 함수 근사를 사용하여 생성되었습니다.</entry>
    <entry key="busAsInterface">블록에 대한 입력 또는 출력이 버스입니다. 이러한 구성의 블록은 지원되지 않습니다.</entry>
    <entry key="blockMustHaveOneOutput">블록에는 1개의 출력이 있어야 합니다.</entry>
    <entry key="blockMustHaveAtLeastOneInput">블록에는 최소 1개의 입력이 있어야 합니다.</entry>
    <entry key="subsystemHasStates">상태가 있는 서브시스템은 근사에 지원되지 않습니다.</entry>
    <entry key="subsystemNotTimeInvariant">Subsystems with time variant output are not supported for approximation.</entry>
    <entry key="subsystemContainsModelReference">계층 구조에 Model 블록이 있는 서브시스템은 근사에 지원되지 않습니다.</entry>
    <entry key="inactiveVariant">Variant Subsystem에서는 활성 Variant만 룩업 테이블로 근사할 수 있습니다.</entry>
    <entry key="complexEvaluationNotSupported">Evaluating the function to approximate within the input bounds leads to output values that are complex. Only real values are supported for approximation.</entry>
    <entry key="functionComparisonTitle">{0} 함수와 {1} 비교</entry>
    <entry key="feasibilityOfSolution">해의 실현 가능성</entry>
    <entry key="feasibleState">실현 가능함</entry>
    <entry key="infeasibleState">실현 불가능</entry>
    <entry key="feasibleRegionLegendKey">실현 가능 영역: 절대 오차 {0} 허용된 최대 오차</entry>
    <entry key="interpolationNoneInterfaceTypeCheck">보간이 ''안 함''으로 설정된 경우 입력 유형은 이진 소수점 스케일링을 적용한 고정소수점, 내장 정수 또는 부울이어야 합니다. 출력 유형은 이진 소수점 스케일링을 적용한 고정소수점, 내장 정수, 부울 또는 single형이어야 합니다. 또한 표현 가능한 입력값의 가능한 모든 조합 수는 2^26보다 작거나 같아야 합니다.</entry>
    <entry key="infStopTime">Function to approximate is from a model with stop time set to Inf. Change the stop time to a finite value.</entry>
    <entry key="elapsedTimeExceededMaxTime">Time limit for finding a solution has been reached.</entry>
    <entry key="minFeasibleSolutionsReached">Minimum number of feasible solutions for successfully finding breakpoints satisfying constraints is reached.</entry>
    <entry key="breakpointSearchStop">Search for optimal breakpoints is stopped.</entry>
    <entry key="noFeasibleSolutionFound">Unable to find a solution using the current options. Returning the solution with minimum constraint violation. Edit the options to find a solution.</entry>
    <entry key="footerReasonForInfeasibility">해가 다음 제약 조건을 충족하지 않기 때문에 실현 가능하지 않음:</entry>
    <entry key="footerReasonForInfeasibilityError">오차</entry>
    <entry key="footerReasonForInfeasibilityMemory">메모리</entry>
    <entry key="iterationPrefix">반복</entry>
    <entry key="optimizationInterrupted">최적화가 중단됨</entry>
    <entry key="autosarCompliance">Problem definition is not AUTOSAR compliant.</entry>
    <entry key="autosarDimensionCompliance">Number of input dimensions must be less than or equal to 2.</entry>
    <entry key="autosarTypeCompliance">Input and output types must all be single, or must all be fixed-point and integer data types.</entry>
    <entry key="autosarFixedPointWLCompliance">Fixed-point and integer input and output types must have word lengths equal to 8 or 16.</entry>
    <entry key="autosarInterpolationCompliance1DIFX">Interpolation must be linear or flat when number of inputs is 1 and input type is fixed-point or integer.</entry>
    <entry key="autosarInterpolationCompliance2DIFX">Interpolation must be linear, flat, or nearest when number of inputs is 2 and input types are fixed-point or integer.</entry>
    <entry key="autosarEvenSpacingAllTypesMustBeSameCompliance">All input and output types must be same when breakpoint specification is even spacing.</entry>
    <entry key="autosarInterpolationComplianceIFL">Interpolation must be linear when input types are single.</entry>
    <entry key="autosarIFLExplicitValuesCompliance">Breakpoint specification must be explicit values when input types are single.</entry>
    <entry key="autosarInputTypesMustBeSameCompliance">All input types must be the same.</entry>
    <entry key="failedToCheckoutAUTOSARBlocksetLicense">Failed to check out AUTOSAR Blockset license.</entry>
    <entry key="activeVariantsOnly">Only blocks under active variants can be analyzed. Set the 'Variants' property of the FindOptions object to 'ActiveVariants'.</entry>
    <entry key="uncommentedBlocksOnly">Only uncommented blocks can be analyzed. Set the 'IncludeCommented' property of the FindOptions object to false.</entry>
    <entry key="tableDescriptionPathIsALUT">Lookup Table 블록에서 사용하는 메모리: {0}</entry>
    <entry key="tableDescriptionPathIsASUD">Lookup Table 블록에서 사용하는 메모리: {0}</entry>
    <entry key="descriptionForMemoryColumn">테이블 값을 저장하기 위해 사용하는 메모리</entry>
    <entry key="descriptionForBlockPathColumn">Lookup Table 블록의 경로</entry>
    <entry key="displayCompressedSolutionFoundForBlockPath">{1}에서 {0}%</entry>
    <entry key="numLUTsFound">지원되는 룩업 테이블이 {0}개 발견됨</entry>
    <entry key="displayCompressedSolutionPercentReductionHeader">압축된 해에서의 메모리 절감 비율</entry>
    <entry key="descriptionNewMemoryUsage">압축 후 테이블 값을 저장하기 위해 사용하는 메모리</entry>
    <entry key="descriptionMemoryDifferencePercentage">압축 후 메모리 사용량의 상대 차이</entry>
    <entry key="descriptionMemoryDifference">압축 후 메모리 사용량의 차이</entry>
    <entry key="rowIDNotInBounds">Indices must be integers between 1 and {0}.</entry>
    <entry key="rfabShowOriginalPrompt">원래 함수 표시</entry>
    <entry key="rfabShowOriginalTooltip">원래 함수를 봅니다</entry>
    <entry key="rfabShowCurrentPrompt">선택한 함수 표시</entry>
    <entry key="rfabShowCurrentTooltip">선택한 함수를 봅니다</entry>
    <entry key="rfabSelectFunctionVersionPrompt">원하는 함수 버전 선택</entry>
    <entry key="rfabRevertToOriginalPrompt">원래 함수로 바꾸기</entry>
    <entry key="rfabRevertToOriginalTooltip">현재 블록을 원래 함수로 바꿉니다</entry>
    <entry key="rfabInvalidNumberOfApproximates">Number of approximates must be a positive integer.</entry>
    <entry key="rfabRevertDialogPart1">경고.</entry>
    <entry key="rfabRevertDialogPart2">이 동작을 진행하면 함수 근사 해가 영구적으로 삭제되고 원래 함수로 바뀝니다. 그 결과 해를 생성하는 데 사용된 모든 정보가 손실됩니다.</entry>
    <entry key="rfabRevertDialogPart3">계속하려면 {0}을(를) 클릭하십시오.</entry>
    <entry key="rfabRevertDialogAbort">취소</entry>
    <entry key="rfabRevertDialogContinue">계속</entry>
    <entry key="rfabOriginalNoLongerAvailable">{0}은(는) 더 이상 사용할 수 없습니다. 원래 함수를 가져올 수 없습니다.</entry>
    <entry key="rfabRedesignPrompt">근사 함수 다시 설계</entry>
    <entry key="rfabRedesignTooltip">원래 함수에 대한 근사를 새로 구합니다.</entry>
    <entry key="rfabOthersAreDefault">(디폴트 값 아님)</entry>
    <entry key="rfabComparePrompt">원래 함수와 비교</entry>
    <entry key="rfabCompareTooltip">원래 함수와 선택한 함수 간의 차이를 시각화합니다.</entry>
    <entry key="rfabBlockDescription">이 블록에는 원래 함수(Original)와 근사 함수(Approximate)가 포함되어 있습니다.</entry>
    <entry key="rfabDetailsPrompt">문제 정의</entry>
    <entry key="rfabDetailsTooltip">근사를 위한 문제 정의 세부 정보</entry>
    <entry key="rfabDelayBeforeLookupPrompt">근사 함수에서 룩업 테이블 앞의 지연 길이</entry>
    <entry key="rfabDelayAfterLookupPrompt">근사 함수에서 룩업 테이블 뒤의 지연 길이</entry>
    <entry key="rfabDelayAfterLookupInitialConditionPrompt">근사 함수에서 룩업 테이블 뒤의 지연에 대한 초기 조건</entry>
    <entry key="rfabSimulateWithDelayPrompt">대기 시간을 갖는 시뮬레이션</entry>
    <entry key="halfInInterfaceTypes">입력 유형 또는 출력 유형이 half이면 둘 모두 부동소수점이어야 합니다.</entry>
    <entry key="solverStoppedUsingController">The solver was stopped as an interruption was detected.</entry>
    <entry key="unsupportedDataType">Unsupported data type encountered.</entry>
    <entry key="cannotConvertToFile">Unable to generate file. File name should be a character row vector or string scalar </entry>
    <entry key="handleVectorization">근사할 함수가 벡터화되지 않았습니다. 최적화 속도가 느려질 수 있습니다.</entry>
    <entry key="hdlOptimizedModeIssues">Unable to proceed to obtain an HDL-Optimized LUT.</entry>
    <entry key="hdlNumberOfInputsMustBeOne">Only functions with one input dimension are supported for HDL-Optimized mode.</entry>
    <entry key="hdlInterpolationMustBeFlatOrNearest">Only flat and linear interpolation are supported for HDL-Optimized mode</entry>
    <entry key="hdlNotCompatibleWithAUTOSAR">AUTOSAR compliance is not supported for HDL-Optimized mode.</entry>
    <entry key="hdlOptimizedUnableToSearchExplicitValues">[HDL에 최적화]가 True로 설정된 경우에만 균일 간격이 지원됩니다.</entry>
    <entry key="mlutIssues">Unable to generate MATLAB LUT.</entry>
    <entry key="mlutUseParallelNotSupported">UseParallel not supported for MATLAB LUT generation.</entry>
    <entry key="mlutNotCompatibleWithAUTOSAR">AUTOSAR compliance not supported for MATLAB LUT generation.</entry>
    <entry key="mlutHDLOptimizedNotSupported">HDLOptimized not supported for MATLAB LUT generation.</entry>
    <entry key="mlutNumberOfInputsMustBeOne">입력 차원이 2개 이상 있는 함수는 MATLAB LUT 생성에 지원되지 않습니다.</entry>
    <entry key="mlutDirectInterpolationNotSupported">Interpolation method 'None' not supported for MATLAB LUT generation.</entry>
    <entry key="cfitLibraryNotSupported">Given curve fitting object is not supported for approximation.</entry>
    <entry key="invalidDataTypeStructClassreg">Invalid data type struct.</entry>
    <entry key="invalidMatFileClassreg">Invalid MAT-file.</entry>
    <entry key="floatingPointOnly">부동소수점 룩업 테이블 해를 구하는 중입니다.</entry>
    <entry key="searchForFloatingPoint">부동소수점 해를 탐색하는 중입니다.</entry>
    <entry key="searchForFixedPoint">고정소수점 해를 탐색하는 중입니다.</entry>
    <entry key="performLosslessCompression">무손실 압축을 수행하는 중입니다.</entry>
    <entry key="approximateSubsystemName">Approximation</entry>
    <entry key="cannotReplaceBlock">Unable to replace block.</entry>
    <entry key="blockInterfaceMismatch">Number of inputs and/or outputs of the original and replacement blocks do not match.</entry>
    <entry key="originalPathIsInvalid">Path of block to replace is invalid.</entry>
    <entry key="substitutePathIsInvalid">Path of replacement block is invalid.</entry>
    <entry key="isNotASubSystem">Selected block is not a subsystem.</entry>
    <entry key="invalidFunctionUnderEncapsulatingSubsystem">Selected block is under an encapsulating subsystem but is not a valid function to approximate.</entry>
    <entry key="blockIsNotEncapsulated">Selected block is not under an encapsulating subsystem.</entry>
    <entry key="maxSuccessAttemptsReached">Maximum number of attempts for successfully finding breakpoints satisfying constraints is reached.</entry>
    <entry key="autosarComplianceLUTDBUnit">LUT database unit is not AUTOSAR compliant.</entry>
    <entry key="autosarComplianceDoubleNotAllowed">Storage types of a lookup table can not be double.</entry>
    <entry key="autosarComplianceTableTypeMustBeSameAsOutputType">Table data type must be equal to the output type of a lookup table.</entry>
    <entry key="rfabBlockType">Function Approximation Solution</entry>
    <entry key="mlutSlopeBiasStripped">% Values with slope and bias stripped away</entry>
    <entry key="mlutCastToInputValue">% Values cast to input values type</entry>
    <entry key="idHeader">ID</entry>
    <entry key="memoryHeader">Memory</entry>
    <entry key="feasibleHeader">Feasible</entry>
    <entry key="tableSizeHeader">Table Size</entry>
    <entry key="breakpointWLHeader">Breakpoints WLs</entry>
    <entry key="tableDataWLHeader">TableData WL</entry>
    <entry key="intermediateWLHeader">Intermediate WLs</entry>
    <entry key="breakpointSpecificationHeader">BreakpointSpecification</entry>
    <entry key="errorHeader">Error(Max,Current)</entry>
  </message>
</rsccat>
