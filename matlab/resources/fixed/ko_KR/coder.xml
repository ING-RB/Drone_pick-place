<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2024 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ko_KR" product="fixed" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="abs_X_Var1_Var1MustBeConstant">abs(x,var1)에서 var1은 상수여야 합니다.</entry>
    <entry key="abs_X_Var1_Var2_VarsMustBeConstant">abs(x,var1,var2)에서 var1 및 var2는 상수여야 합니다.</entry>
    <entry key="absComplexFiBooleanUnsupported">abs 함수는 fi 객체 또는 지정된 numerictype 객체가 부울인 경우 복소수 fi 객체를 지원하지 않습니다.</entry>
    <entry key="absFIFixPtBPSOnly">abs 함수는 이진 소수점 스케일링을 지원합니다. abs 함수에 사용되는 모든 numerictype 객체 또는 fi 객체에 대해 소수부 기울기는 1이고 편향은 0이어야 합니다.</entry>
    <entry key="argMustBeConstant">''{1}''에 대한 {0} 인수는 상수여야 합니다.</entry>
    <entry key="autoDimIncompatibility">작업 차원은 자동으로 선택되었으며, 가변 길이이고 런타임에 길이가 1입니다. 이는 지원되지 않습니다. DIM 인수를 제공하여 작업 차원을 수동으로 선택하십시오.</entry>
    <entry key="bitOpsIndexArgsNotSameClass">인덱스 인수는 클래스가 동일해야 합니다.</entry>
    <entry key="bitOpsLeftIdxNotCnstSclrGTZ">왼쪽 인덱스는 0보다 큰 상수 스칼라여야 합니다.</entry>
    <entry key="bitOpsLeftIdxNotGTEqRightIdx">왼쪽 인덱스 값은 오른쪽 인덱스 값보다 크거나 같아야 합니다.</entry>
    <entry key="bitOpsLeftIdxNotLTEqWordLength">왼쪽 인덱스는 입력 피연산자의 워드 길이보다 작거나 같아야 합니다.</entry>
    <entry key="bitOpsLeftIndexArgTypeInvalid">왼쪽 인덱스 인수는 숫자형이어야 합니다.</entry>
    <entry key="bitOpsRightIndexArgTypeInvalid">오른쪽 인덱스 인수는 숫자형이어야 합니다.</entry>
    <entry key="bitOpsRightIndexNotCnstSclrGTZ">오른쪽 인덱스는 0보다 큰 상수 스칼라여야 합니다.</entry>
    <entry key="bitRepCannotRepBits">비트를 {0, number, integer}비트보다 크게 복제할 수 없습니다.</entry>
    <entry key="bitRepInvalid2ndInpArg">두 번째 입력 인수(복제 상수)는 내장된 숫자형의 실수형 스칼라 상수여야 합니다.</entry>
    <entry key="bitsraInpWLMustBeGTOne">bitsra 입력 피연산자 워드 길이는 1보다 커야 합니다.</entry>
    <entry key="bitsxxInpWLMustBeGTOne">{0} 입력 피연산자 워드 길이는 1보다 커야 합니다.</entry>
    <entry key="dimArgMustBeAConstant">차원 인수는 상수여야 합니다.</entry>
    <entry key="divide_T_a_b_aMustBeNumeric">divide(T,a,b)에서 a는 숫자형이어야 합니다.</entry>
    <entry key="divide_T_a_b_bMustBeNumeric">divide(T,a,b)에서 b는 숫자형이어야 합니다.</entry>
    <entry key="divideFi_NonFi_NonFiMustBeConstant">divide(t,fi,non-fi)에서 non-fi는 상수여야 합니다.</entry>
    <entry key="divideNonFi_Fi_NonFiMustBeConstant">divide(t,non-fi,fi)에서 non-fi는 상수여야 합니다.</entry>
    <entry key="divideNotDefinedFor1stArgType">{0} 클래스의 첫 번째 인수에 대해 함수 divide가 정의되지 않았습니다. 이는 embedded.numerictype이어야 합니다.</entry>
    <entry key="eml_FcnNameArgMustBeConst">{0} 함수 이름 인수는 상수여야 합니다.</entry>
    <entry key="eml_FcnNameArgUnsupported">지원되지 않는 {0} funstr 인수임: {1}.</entry>
    <entry key="fiFilterNumeratorSizeNotConst">분자의 차원은 변경되어서는 안 됩니다.</entry>
    <entry key="fiFilterZiLeadingDimNotConst">초기 조건의 선행 차원은 변경되어서는 안 됩니다.</entry>
    <entry key="fiFilterAllInpArgsMustBeFiObjects">필터 계수, 입력 데이터, 초기 조건(있는 경우)은 모두 FI 객체여야 합니다.</entry>
    <entry key="fiFilterAllInpArgsMustHaveSameDType">필터 계수, 입력 데이터, 초기 조건(있는 경우)은 데이터형이 모두 동일해야 합니다.</entry>
    <entry key="fiFilterZiDTypeMustMatchOutput">상태는 출력 numerictype, 즉 DataType = {0}, Signedness = {1}, WordLength = {2, number, integer}, FractionLength = {3, number, integer}과(와) 일치하는 FI 객체여야 합니다.</entry>
    <entry key="fiFilterZiCplxMustMatchOutput">초기 조건의 실수/복소수 여부는 출력값의 실수/복소수 여부와 일치해야 합니다.</entry>
    <entry key="fiFunctionDataTypeError">{0} 함수는 고정소수점, 스케일링된 double형, double형 또는 single형 데이터형을 가지는 fi 객체와만 사용할 수 있습니다.</entry>
    <entry key="fiFunctionScalarInputOnly">스칼라가 아닌 fi 입력값에 대해서는 고정소수점 {0} 함수를 사용할 수 없습니다.</entry>
    <entry key="fiFcnDTypeErrorOnlyFixBPSDblSgl">{0} 함수는 고정소수점(이진 소수점 스케일링), double형 또는 single형 데이터형을 가지는 fi 객체와만 사용할 수 있습니다.</entry>
    <entry key="fiFcnDTypeErrorFixPtOnly">The {0} function can only be used with fi objects that have a fixed-point data type.</entry>
    <entry key="fiFcnDTypeErrNumericOnly">{0} 함수는 숫자 데이터형을 가지는 fi 객체와만 사용할 수 있습니다.</entry>
    <entry key="fiCompareNonFI_NonFIMustBeConst">fi와 non-fi를 비교할 경우 non-fi는 상수여야 합니다.</entry>
    <entry key="fiInputArgMustBeConstant">fi(var1, var2,..varN)에 대한 호출에서 입력값 var2,..varN은 상수여야 합니다. 입력값 {0}은(는) 상수가 아닙니다.</entry>
    <entry key="fiInvalidMethodSignature">embedded.fi 클래스에 대해 시그니처가 일치하는 메서드 {0}을(를) 찾을 수 없습니다.</entry>
    <entry key="fimathInvalidArgs">FIMATH 인수는 유효하지 않습니다.</entry>
    <entry key="fimathInvalidMethodSignature">embedded.fimath 클래스에 대해 시그니처가 일치하는 메서드 {0}을(를) 찾을 수 없습니다.</entry>
    <entry key="fimathMustBeConst">Fimath는 상수여야 합니다.</entry>
    <entry key="fiMathOpsFullPrecisionCastBeforeSum">fi math operations require CastBeforeSum to be true when SumMode is not FullPrecision.</entry>
    <entry key="fiMethodNotSupportedForCodegen">코드 생성에는 FI 객체에 대한 {0} 메서드가 지원되지 않습니다.</entry>
    <entry key="fiNonFiFcnForm_NonFiMustBeConstant">{0}(fi,non-fi) 또는 {1}(non-fi,fi)에서 non-fi는 상수여야 합니다.</entry>
    <entry key="fiNonFiOpForm_NonFiMustBeConstant">fi {0} non-fi 또는 non-fi {1} fi에서 non-fi는 상수여야 합니다.</entry>
    <entry key="fiPVPairsDataPropSizeMustMatchFIFirstInpArgSize">If the first input to the fi constructor is numeric and you use property value pairs to specify the stored-data property of the fi object, the size of the corresponding stored-data property value must match the size of the first input to the fi constructor.</entry>
    <entry key="fiShiftArgDataTypeUnsupported">{0}에서 지원되지 않는 시프트 인수 데이터형입니다.</entry>
    <entry key="fixedBinaryPointOnlyCodegen"> The {0} function only supports code generation for binary point scaled fixed point inputs.</entry>
    <entry key="fiVar1InpMustBeNumericOrAConstant">fi(var1,...)에서 입력값 var1은 숫자형이거나 상수여야 합니다.</entry>
    <entry key="fiVar2toNInpArgsMustBeConstant">fi(var1,var2,...varN)에서 var1이 상수가 아닌 경우 var2,...varN은 완전한 numerictype이거나 완전한 numerictype을 지정해야 합니다.</entry>
    <entry key="fiVar2MustBeConstant">fi(var1,var2)에서 입력값 var2는 상수여야 합니다.</entry>
    <entry key="fiVar2MustBeTorF">fi(var1,var2)에서 var1이 상수가 아닌 경우 입력값 var2는 numerictype이거나 fimath여야 합니다.</entry>
    <entry key="fiVar2TofUnspecifiedScalingNotSupported">fi(var1,var2)에서 var1이 상수가 아닌 경우 입력값 var2는 지정되지 않은 스케일링의 numerictype일 수 없습니다.</entry>
    <entry key="fitoolNotSupportedForCodegen">코드 생성에는 FITOOL이 지원되지 않습니다.</entry>
    <entry key="functionNotDefinedFor1stArgType">{1} 클래스의 첫 번째 인수에 대해 함수 ''{0}''이(가) 정의되지 않았습니다.</entry>
    <entry key="fxpUArgValsMustBeNumericNonemptyFinite">u 인수 값은 비어 있지 않은 유한한 숫자형이어야 합니다.</entry>
    <entry key="globalfimathFcnNotSupportedForCodegen">코드 생성에는 GLOBALFIMATH 함수가 지원되지 않습니다.</entry>
    <entry key="incorrectNumberOfInputs">입력값 개수가 올바르지 않습니다.</entry>
    <entry key="incorrectNumberOfInputsGet">입력값 개수가 올바르지 않습니다. 구문 get(a)는 지원되지 않습니다.</entry>
    <entry key="inputMustBeConstant">{1}의 입력값 {0}은(는) 상수여야 합니다.</entry>
    <entry key="inputMustBeConstantOrAFI">{1}의 입력값 {0}은(는) 상수 또는 fi여야 합니다.</entry>
    <entry key="inputMustBeNumeric">입력값은 숫자형이어야 합니다.</entry>
    <entry key="inputTypeUnsupported">{1}에 대해서는 유형 {0}의 입력값이 지원되지 않습니다.</entry>
    <entry key="invalidEnumValue">Argument {0} must have a value belonging to the set {1}.</entry>
    <entry key="invalidInputArg">유효하지 않은 입력 인수입니다.</entry>
    <entry key="invalidUseGet">Function ''get'' is resolved in the MATLAB workspace. Please call this function using coder.extrinsic(''get'') or feval when the input is not a fi, numerictype or a fimath.</entry>
    <entry key="mpowerProductModeForNonConstExponent">입력값 a가 스칼라이고 mpower 지수 입력값이 상수가 아닌 경우 ProductMode는 SpecifyPrecision이어야 합니다. 이렇게 하면 컴파일할 때 출력 데이터형을 결정할 수 있습니다.</entry>
    <entry key="mpowerSumModeForNonConstExponent">입력값 a가 스칼라가 아니고 mpower 지수 입력값이 상수가 아닌 경우 SumMode는 SpecifyPrecision이어야 합니다. 이렇게 하면 컴파일할 때 출력 데이터형을 결정할 수 있습니다.</entry>
    <entry key="mustBeConstant">{0}은(는) 상수여야 합니다.</entry>
    <entry key="notEnoughInputArguments">입력 인수가 부족합니다.</entry>
    <entry key="numerictypeMustBeConst">numerictype은 상수여야 합니다.</entry>
    <entry key="onlyDotForProperty">{0} is not a property of the {1} object: X.{2}.  In code generation, only properties of the {3} object can be used with dot notation.  For methods of {4} objects, use function notation instead: {5}(X).</entry>
    <entry key="outputWLExceedsMaxWLLimit">출력 유형이 최대 비트 수({0, number, integer})를 초과합니다.</entry>
    <entry key="powerProductModeForNonConstExponent">거듭제곱 지수 입력값이 상수가 아닌 경우 ProductMode는 SpecifyPrecision이어야 합니다. 이렇게 하면 컴파일할 때 출력 데이터형을 결정할 수 있습니다.</entry>
    <entry key="reinterpretcastWordLengthMismatch">숫자형의 워드 길이는 형변환하는 fi 객체의 워드 길이와 같아야 합니다.</entry>
    <entry key="reinterpretcastFirstInputInvalidDType">첫 번째 입력값은 고정소수점 또는 스케일링된 double형 fi 객체여야 합니다.</entry>
    <entry key="reinterpretcastSecondInputNotNumerictype">두 번째 입력값은 numerictype이어야 합니다.</entry>
    <entry key="relOpArgsHaveUnequalBias">편향 값이 다른 경우 관계 연산자가 지원되지 않습니다.</entry>
    <entry key="rescaleFiDoubleSingleBooleanInvalidPropChange">데이터형 모드가 double형, single형 또는 부울인 경우 지정된 속성을 변경할 수 없습니다. 이 속성이 변경되지 않았습니다.</entry>
    <entry key="slopeBiasInputsNotSupported">기울기 편향 스케일링된 입력값은 지원되지 않습니다.</entry>
    <entry key="sqrtSlopeBiasInputsNotSupported">SQRT(A) 또는 SQRT(A,T)는 FI 객체 A 및 NumericType T에 대해서만 계산할 수 있습니다. 이때 A 및 T의 스케일링은 소수부 기울기가 1이고 편향은 0입니다(이진 소수점 스케일링).</entry>
    <entry key="sumModeRestrictedForVarS">코드 생성 시, SumMode는 ''{0}''에 대해 ''SpecifyPrecision'' 또는 ''KeepLSB''여야 합니다. 이때 입력값의 크기는 런타임에 달라질 수 있습니다.</entry>
    <entry key="unsupportedBooleanNumerictype">A fixed-point numeric object (fi) of DataTypeMode = ''Boolean'' is not supported in MATLAB for code generation. You should use a MATLAB logical variable instead.</entry>
    <entry key="unsupportedSumMode">코드 생성 시, SumMode는 ''{0}''에 대해 ''SpecifyPrecision'' 또는 ''KeepLSB''여야 합니다. 이때 입력값의 크기는 런타임에 달라질 수 있습니다.</entry>
    <entry key="wordLengthExceedsMaxWL">The specified word length exceeds the maximum number of bits ({0, number, integer}).</entry>
    <entry key="wordLengthMustBeLTEQ32">Wordlength는 32보다 작거나 같아야 합니다.</entry>
    <entry key="colonBitWidthMax64">코드 생성 시, colon 출력값의 비트 너비는 64를 초과할 수 없습니다.</entry>
    <entry key="sqrt_X_Var1_Var1MustBeConstant">sqrt(x,var1)에서 var1은 상수여야 합니다.</entry>
  </message>
</rsccat>
