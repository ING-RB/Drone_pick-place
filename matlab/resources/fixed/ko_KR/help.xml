<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2024 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ko_KR" product="fixed" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="SystolicQRDescription">수식 AX = B에서 행렬 A와 B가 주어진 경우 이 블록은 효율적 크기의 QR 분해 R 및 C=Q'B를 반환합니다 \n여기서 A는 m×n이고 B는 m×p입니다.\n \n시스템 대기 시간을 최소화하고 처리량을 높이려면 시스톨릭 구현을 사용하십시오. 시스톨릭 구현에는 버스트 구현 또는 부분 시스톨릭 구현보다 더 많은 하드웨어 리소스가 필요합니다.
    </entry>
    <entry key="ComplexPartialSystolicQRDescription">수식 AX = B에서 
        복소수 행렬 A와 B의 행이 주어진 경우 이 블록은
        효율적 크기의 QR 분해 R 및 C=Q'B를 반환합니다.\n
	\n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
        다음에 대해 효율적 크기의 QR 분해를 계산합니다.\n
	\n[lambda*eye(n);A]X = [zeros(n,p);B],\n
	\n여기서 A는 m×n이고 B는 m×p입니다.\n
	\n시스템 대기 시간을 최소화하고 처리량을 높이려면 부분 시스톨릭 구현을 사용하십시오. 부분 시스톨릭 구현에는 버스트 구현보다 더 많은 하드웨어 리소스가 필요합니다.
    </entry>
    <entry key="RealPartialSystolicQRDescription">수식 AX = B에서
        실수 행렬 A와 B의 행이 주어진 경우 이 블록은
        효율적 크기의 QR 분해 R 및 C=Q'B를 반환합니다.\n
	\n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
        다음에 대해 효율적 크기의 QR 분해를 계산합니다.\n
	\n[lambda*eye(n);A]X = [zeros(n,p);B],\n
	\n여기서 A는 m×n이고 B는 m×p입니다.\n
	\n시스템 대기 시간을 최소화하고 처리량을 높이려면 부분 시스톨릭 구현을 사용하십시오. 부분 시스톨릭 구현에는 버스트 구현보다 더 많은 하드웨어 리소스가 필요합니다.
    </entry>
    <entry key="ComplexPartialSystolicQlessQRDescription">복소수 행렬 A의 행이 주어진 경우, 이 블록은
    효율적 크기의 QR 분해의 상부 삼각 행렬 R을 반환합니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
    다음에 대해 효율적 크기의 QR 분해를 계산합니다.\n
    \n[lambda*eye(n);A]\n
    \n시스템 대기 시간을 최소화하고 처리량을 높이려면 부분 시스톨릭 구현을 사용하십시오. 부분 시스톨릭 구현에는 버스트 구현보다 더 많은 하드웨어 리소스가 필요합니다.
    </entry>
    <entry key="RealPartialSystolicQlessQRDescription">실수 행렬 A의 행이 주어진 경우, 이 블록은
    효율적 크기의 QR 분해의 상부 삼각 행렬 R을 반환합니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
    다음에 대해 효율적 크기의 QR 분해를 계산합니다.\n
    \n[lambda*eye(n);A]\n
    \n시스템 대기 시간을 최소화하고 처리량을 높이려면 부분 시스톨릭 구현을 사용하십시오. 부분 시스톨릭 구현에는 버스트 구현보다 더 많은 하드웨어 리소스가 필요합니다.
    </entry>
    <entry key="ComplexPartialSystolicQlessQRwithForgettingFactorDescription">이 블록은 새 복소수 데이터 벡터가 주어지면 상부 삼각 행렬을 업데이트합니다.
    이 블록은 행렬의 각 행이 분해된 후 망각 인자가 적용된, 무한한 tall형 행렬의 Q-less QR 분해와 동일합니다.
    출력은 망각 인자에 업데이트된 상부 삼각 R을 곱한 값입니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
    상부 삼각 인수 R을 lambda*eye(n)으로 초기화합니다.\n
    \n시스템 대기 시간을 최소화하고 처리량을 높이려면 부분 시스톨릭 구현을 사용하십시오. 부분 시스톨릭 구현에는 버스트 구현보다 더 많은 하드웨어 리소스가 필요합니다.
    </entry>
    <entry key="RealPartialSystolicQlessQRwithForgettingFactorDescription">이 블록은 새 실수 데이터 벡터가 주어지면 상부 삼각 행렬을 업데이트합니다.
    이 블록은 행렬의 각 행이 분해된 후 망각 인자가 적용된, 무한한 tall형 행렬의 Q-less QR 분해와 동일합니다.
    출력은 망각 인자에 업데이트된 상부 삼각 R을 곱한 값입니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
    상부 삼각 인수 R을 lambda*eye(n)으로 초기화합니다.\n
    \n시스템 대기 시간을 최소화하고 처리량을 높이려면 부분 시스톨릭 구현을 사용하십시오. 부분 시스톨릭 구현에는 버스트 구현보다 더 많은 하드웨어 리소스가 필요합니다.
    </entry>
    <entry key="ComplexBurstQRDescription">수식 AX = B에서 복소수 행렬 A와 B의 행이 주어지면 이 블록은
        효율적 크기의 QR 분해 R 및 C=Q'B의 행을 반환합니다. 여기서 R은 상부 삼각 행렬이고, C는 행 수가 같은
        행렬입니다.\n
	\n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
        다음에 대해 효율적 크기의 QR 분해를 계산합니다.\n
	\n[lambda*eye(n);A]X = [zeros(n,p);B],\n
	\n여기서 A는 m×n이고 B는 m×p입니다.\n
	\n필수 하드웨어 리소스를 최소화하려면 버스트 구현을 사용하십시오. 버스트 구현에서는 시스템 대기 시간이 증가하므로 블록 처리량이 줄어듭니다.
    </entry>
    <entry key="RealBurstQRDescription">수식 AX = B에서 실수 행렬 A와 B의 행이 주어지면 이 블록은
        효율적 크기의 QR 분해 R 및 C=Q'B의 행을 반환합니다. 여기서 R은 상부 삼각 행렬이고, C는 행 수가 같은
        행렬입니다.\n
	\n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
        다음에 대해 효율적 크기의 QR 분해를 계산합니다.\n
	\n[lambda*eye(n);A]X = [zeros(n,p);B],\n
	\n여기서 A는 m×n이고 B는 m×p입니다.\n
	\n필수 하드웨어 리소스를 최소화하려면 버스트 구현을 사용하십시오. 버스트 구현에서는 시스템 대기 시간이 증가하므로 블록 처리량이 줄어듭니다.
    </entry>
    <entry key="ComplexBurstQlessQRDescription">복소수 행렬 A의 행이 주어지면 이 블록은
    효율적 크기의 QR 분해의 상부 삼각 행렬 R의 행을 반환합니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
    다음에 대해 효율적 크기의 QR 분해를 계산합니다.\n
    \n[lambda*eye(n);A]\n
    \n필수 하드웨어 리소스를 최소화하려면 버스트 구현을 사용하십시오. 버스트 구현에서는 시스템 대기 시간이 증가하므로 블록 처리량이 줄어듭니다.
    </entry>
    <entry key="ComplexBurstQlessQRWholeROutputDescription">복소수 행렬 A의 행이 주어지면 이 블록은
    효율적 크기의 QR 분해의 상부 삼각 행렬 R을 반환합니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
    다음에 대해 효율적 크기의 QR 분해를 계산합니다.\n
    \n[lambda*eye(n);A]\n
    \n필수 하드웨어 리소스를 최소화하려면 버스트 구현을 사용하십시오. 버스트 구현에서는 시스템 대기 시간이 증가하므로 블록 처리량이 줄어듭니다.
    </entry>
    <entry key="RealBurstQlessQRDescription">실수 행렬 A의 행이 주어지면 이 블록은
    효율적 크기의 QR 분해의 상부 삼각 행렬 R의 행을 반환합니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
    다음에 대해 효율적 크기의 QR 분해를 계산합니다.\n
    \n[lambda*eye(n);A]\n
    \n필수 하드웨어 리소스를 최소화하려면 버스트 구현을 사용하십시오. 버스트 구현에서는 시스템 대기 시간이 증가하므로 블록 처리량이 줄어듭니다.
    </entry>
    <entry key="RealBurstQlessQRWholeROutputDescription">실수 행렬 A의 행이 주어지면 이 블록은
    효율적 크기의 QR 분해의 상부 삼각 행렬 R을 반환합니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
    다음에 대해 효율적 크기의 QR 분해를 계산합니다.\n
    \n[lambda*eye(n);A]\n
    \n필수 하드웨어 리소스를 최소화하려면 버스트 구현을 사용하십시오. 버스트 구현에서는 시스템 대기 시간이 증가하므로 블록 처리량이 줄어듭니다.
    </entry>
    <entry key="ComplexBurstQlessQRwithForgettingFactorDescription">이 블록은 새 복소수 데이터 벡터가 주어지면 상부 삼각 행렬을 업데이트합니다.
    이 블록은 행렬의 각 행이 분해된 후 망각 인자가 적용된, 무한한 tall형 행렬의 Q-less QR 분해와 동일합니다.
    출력은 망각 인자에 업데이트된 상부 삼각 R을 곱한 값입니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
    상부 삼각 인수 R을 lambda*eye(n)으로 초기화합니다.\n
    \n필수 하드웨어 리소스를 최소화하려면 버스트 구현을 사용하십시오. 버스트 구현에서는 시스템 대기 시간이 증가하므로 블록 처리량이 줄어듭니다.
    </entry>
    <entry key="RealBurstQlessQRwithForgettingFactorDescription">이 블록은 새 실수 데이터 벡터가 주어지면 상부 삼각 행렬을 업데이트합니다.
    이 블록은 행렬의 각 행이 분해된 후 망각 인자가 적용된, 무한한 tall형 행렬의 Q-less QR 분해와 동일합니다.
    출력은 망각 인자에 업데이트된 상부 삼각 R을 곱한 값입니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
    상부 삼각 인수 R을 lambda*eye(n)으로 초기화합니다.\n
    \n필수 하드웨어 리소스를 최소화하려면 버스트 구현을 사용하십시오. 버스트 구현에서는 시스템 대기 시간이 증가하므로 블록 처리량이 줄어듭니다.
    </entry>
    <entry key="ComplexBurstMatrixSolveDescription">수식 AX = B에서 X의 값을 계산합니다. 여기서 A와 B는 복소수 값 행렬입니다.\n
	\n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
        다음 수식에서 X의 값을 계산합니다.\n
	\n[lambda*eye(n);A]X = [zeros(n,p);B],\n
	\n여기서 A는 m×n이고 B는 m×p입니다.\n
	\n필수 하드웨어 리소스를 최소화하려면 버스트 구현을 사용하십시오. 버스트 구현에서는 시스템 대기 시간이 증가하므로 블록 처리량이 줄어듭니다.
    </entry>
    <entry key="RealBurstMatrixSolveDescription">수식 AX = B에서 X의 값을 계산합니다. 여기서 A와 B는 실수 값 행렬입니다.\n
	\n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
        다음 수식에서 X의 값을 계산합니다.\n
	\n[lambda*eye(n);A]X = [zeros(n,p);B],\n
	\n여기서 A는 m×n이고 B는 m×p입니다.\n
	\n필수 하드웨어 리소스를 최소화하려면 버스트 구현을 사용하십시오. 버스트 구현에서는 시스템 대기 시간이 증가하므로 블록 처리량이 줄어듭니다.
    </entry>
    <entry key="ComplexBurstQlessQRMatrixSolveDescription">수식 A'AX = B에서 X의 값을 계산합니다. 여기서 A와 B는 복소수 값 행렬입니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
    다음 수식에서 X의 값을 계산합니다.
    \n(lambda^2*eye(n) + A'A)X = B\n
    \n필수 하드웨어 리소스를 최소화하려면 버스트 구현을 사용하십시오. 버스트 구현에서는 시스템 대기 시간이 증가하므로 블록 처리량이 줄어듭니다.
    </entry>
    <entry key="ComplexBurstAsynchronousQlessQRMatrixSolveDescription">수식 A'AX = B에서 X의 값을 계산합니다. 여기서 A와 B는 복소수 값 행렬입니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
    다음 수식에서 X의 값을 계산합니다.
    \n(lambda^2*eye(n) + A'A)X = B\n
    \n이 블록은 비동기식으로 동작합니다. 전진 대입과 역대입 및 Q-less QR 분해는 최신 R 행렬과 B 행렬을 사용하여 개별적으로 실행됩니다.\n
    \n필수 하드웨어 리소스를 최소화하려면 버스트 구현을 사용하십시오. 버스트 구현에서는 시스템 대기 시간이 증가하므로 블록 처리량이 줄어듭니다.
    </entry>
    <entry key="RealBurstQlessQRMatrixSolveDescription">수식 A'AX = B에서 X의 값을 계산합니다. 여기서 A와 B는 실수 값 행렬입니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
    다음 수식에서 X의 값을 계산합니다.
    \n(lambda^2*eye(n) + A'A)X = B\n
    \n필수 하드웨어 리소스를 최소화하려면 버스트 구현을 사용하십시오. 버스트 구현에서는 시스템 대기 시간이 증가하므로 블록 처리량이 줄어듭니다.
    </entry>
    <entry key="RealBurstAsynchronousQlessQRMatrixSolveDescription">수식 A'AX = B에서 X의 값을 계산합니다. 여기서 A와 B는 실수 값 행렬입니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
    다음 수식에서 X의 값을 계산합니다.
    \n(lambda^2*eye(n) + A'A)X = B\n
    \n이 블록은 비동기식으로 동작합니다. 전진 대입과 역대입 및 Q-less QR 분해는 최신 R 행렬과 B 행렬을 사용하여 개별적으로 실행됩니다.\n
    \n필수 하드웨어 리소스를 최소화하려면 버스트 구현을 사용하십시오. 버스트 구현에서는 시스템 대기 시간이 증가하므로 블록 처리량이 줄어듭니다.
    </entry>
    <entry key="ComplexBurstQlessQRMatrixSolveWithForgettingFactorDescription">수식 A'AX = B에서 X의 값을 계산합니다. 여기서 A와 B는 복소수 값 행렬입니다.
    행렬의 각 행이 분해된 후 망각 인자가 적용되어 A의 각 행이 무한정으로 입력됨에 따라 해가 업데이트됩니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
    A의 상부 삼각 인수 R을 lambda*eye(n)으로 초기화합니다.\n
    \n필수 하드웨어 리소스를 최소화하려면 버스트 구현을 사용하십시오. 버스트 구현에서는 시스템 대기 시간이 증가하므로 블록 처리량이 줄어듭니다.
    </entry>
    <entry key="RealBurstQlessQRMatrixSolveWithForgettingFactorDescription">수식 A'AX = B에서 X의 값을 계산합니다. 여기서 A와 B는 실수 값 행렬입니다.
    행렬의 각 행이 분해된 후 망각 인자가 적용되어 A의 각 행이 무한정으로 입력됨에 따라 해가 업데이트됩니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
    A의 상부 삼각 인수 R을 lambda*eye(n)으로 초기화합니다.\n
    \n필수 하드웨어 리소스를 최소화하려면 버스트 구현을 사용하십시오. 버스트 구현에서는 시스템 대기 시간이 증가하므로 블록 처리량이 줄어듭니다.
    </entry>
    <entry key="ComplexPartialSystolicMatrixSolveDescription">수식 AX = B에서 X의 값을 계산합니다. 여기서 A와 B는 복소수 값 행렬입니다.\n
	\n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
        다음 수식에서 X의 값을 계산합니다.\n
	\n[lambda*eye(n);A]X = [zeros(n,p);B],\n
	\n여기서 A는 m×n이고 B는 m×p입니다.\n
    \n시스템 대기 시간을 최소화하고 처리량을 높이려면 부분 시스톨릭 구현을 사용하십시오. 부분 시스톨릭 구현에는 버스트 구현보다 더 많은 하드웨어 리소스가 필요합니다.
    </entry>
    <entry key="RealPartialSystolicMatrixSolveDescription">수식 AX = B에서 X의 값을 계산합니다. 여기서 A와 B는 실수 값 행렬입니다.\n
	\n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
        다음 수식에서 X의 값을 계산합니다.\n
	\n[lambda*eye(n);A]X = [zeros(n,p);B],\n
	\n여기서 A는 m×n이고 B는 m×p입니다.\n
    \n시스템 대기 시간을 최소화하고 처리량을 높이려면 부분 시스톨릭 구현을 사용하십시오. 부분 시스톨릭 구현에는 버스트 구현보다 더 많은 하드웨어 리소스가 필요합니다.
    </entry>
    <entry key="ComplexPartialSystolicQlessQRMatrixSolveDescription">수식 A'AX = B에서 X의 값을 계산합니다. 여기서 A와 B는 복소수 값 행렬입니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
        다음 수식에서 X의 값을 계산합니다.
    \n(lambda^2*eye(n) + A'A)X = B\n
    \n시스템 대기 시간을 최소화하고 처리량을 높이려면 부분 시스톨릭 구현을 사용하십시오. 부분 시스톨릭 구현에는 버스트 구현보다 더 많은 하드웨어 리소스가 필요합니다.
    </entry>
    <entry key="RealPartialSystolicQlessQRMatrixSolveDescription">수식 A'AX = B에서 X의 값을 계산합니다. 여기서 A와 B는 실수 값 행렬입니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
        다음 수식에서 X의 값을 계산합니다.
    \n(lambda^2*eye(n) + A'A)X = B\n
    \n시스템 대기 시간을 최소화하고 처리량을 높이려면 부분 시스톨릭 구현을 사용하십시오. 부분 시스톨릭 구현에는 버스트 구현보다 더 많은 하드웨어 리소스가 필요합니다.
    </entry>
    <entry key="ComplexPartialSystolicQlessQRMatrixSolveWithForgettingFactorDescription">수식 A'AX = B에서 X의 값을 계산합니다. 여기서 A와 B는 복소수 값 행렬입니다.
    행렬의 각 행이 분해된 후 망각 인자가 적용되어 A의 각 행이 무한정으로 입력되므로 해가 업데이트됩니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
    A의 상부 삼각 인수 R을 lambda*eye(n)으로 초기화합니다.\n
    \n시스템 대기 시간을 최소화하고 처리량을 높이려면 부분 시스톨릭 구현을 사용하십시오. 부분 시스톨릭 구현에는 버스트 구현보다 더 많은 하드웨어 리소스가 필요합니다.
    </entry>
    <entry key="RealPartialSystolicQlessQRMatrixSolveWithForgettingFactorDescription">수식 A'AX = B에서 X의 값을 계산합니다. 여기서 A와 B는 실수 값 행렬입니다.
    행렬의 각 행이 분해된 후 망각 인자가 적용되어 A의 각 행이 무한정으로 입력되므로 해가 업데이트됩니다.\n
    \n정규화 파라미터 람다가 0이 아닌 경우 이 블록은 
    A의 상부 삼각 인수 R을 lambda*eye(n)으로 초기화합니다.\n
    \n시스템 대기 시간을 최소화하고 처리량을 높이려면 부분 시스톨릭 구현을 사용하십시오. 부분 시스톨릭 구현에는 버스트 구현보다 더 많은 하드웨어 리소스가 필요합니다.
    </entry>
    <entry key="SystolicMatrixSolveDescription">수식 AX = B에서 X의 값을 계산합니다. 여기서 A와 B는 행렬입니다. A는 m×n이고 B는 m×p입니다.\n \n시스템 대기 시간을 최소화하고 처리량을 높이려면 시스톨릭 구현을 사용하십시오. 시스톨릭 구현에는 버스트 구현 또는 부분 시스톨릭 구현보다 더 많은 하드웨어 리소스가 필요합니다.
    </entry>
    <entry key="BackSubstituteDescription">역대입을 사용하여 수식 RX = C에서 X의 값을 계산합니다. 여기서 R은 상부 삼각 행렬입니다.</entry>
    <entry key="RealBackSubstituteDescription">역대입을 사용하여 수식 RX = C에서 X의 값을 계산합니다. 여기서 R은 실수 값 상부 삼각 행렬이고 C는 실수 값 행렬입니다.</entry>
    <entry key="ComplexBackSubstituteDescription">역대입을 사용하여 수식 RX = C에서 X의 값을 계산합니다. 여기서 R은 복소수 값 상부 삼각 행렬이고 C는 복소수 값 행렬입니다.</entry>
    <entry key="RealForwardSubstituteDescription">전진 대입을 사용하여 수식 LX = C에서 X의 값을 계산합니다. 여기서 L은 실수 값 하부 삼각 행렬이고 C는 실수 값 행렬입니다.</entry>
    <entry key="ComplexForwardSubstituteDescription">전진 대입을 사용하여 수식 LX = C에서 X의 값을 계산합니다. 여기서 L은 복소수 값 하부 삼각 행렬이고 C는 복소수 값 행렬입니다.</entry>
    <entry key="RealForwardBackwardSubstituteDescription">수식 R'RX = B에서 X의 값을 계산합니다. 여기서 R은 실수 값 상부 삼각 행렬이고 B는 실수 값 행렬입니다. </entry>
    <entry key="ComplexCombinedSubstituteDescription">수식 R'RX = B에서 X의 값을 계산합니다. 여기서 R은 복소수 값 상부 삼각 행렬이고 B는 복소수 값 행렬입니다.</entry>
    <entry key="SquareJacobiSVDDescriptionDescription">정사각 행렬 A가 주어지면 이 블록은 양측 야코비 방법을 사용하여 A = U*diag(s)*V'이 되도록 음이 아닌 요소로 구성된 벡터 s와 유니타리 행렬 U 및 V를 생성합니다.</entry>
    <entry key="NonSquareJacobiSVDDescriptionDescription">행이 열보다 더 많은 행렬 A가 주어지면 이 블록은 양측 야코비 방법을 사용하여 A = U*diag(s)*V'이 되도록 음이 아닌 요소로 구성된 벡터 s와 유니타리 행렬 U 및 V를 생성합니다.</entry>
    <entry key="EulerNEDTransformation">각도 Angle In만큼 3×1 벡터 U In을 회전합니다. Angle In은 3×1 실수형 벡터로, x축, y축, z축을 중심으로 한 회전 각도를 각각 지정합니다.</entry>
  </message>
</rsccat>
