<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2024 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="zh_CN" product="fixed" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="SystolicQRDescription">给定方程 AX = B 中的矩阵 A 和 B，此模块返回精简 QR 分解后所得的 R 和 C=Q'B\n其中 A 为 m×n，B 为 m×p。\n \n使用 Systolic 实现来最小化系统延迟并增大吞吐量。Systolic 实现比 Burst 或 Partial-systolic 实现需要更多硬件资源。
    </entry>
    <entry key="ComplexPartialSystolicQRDescription">给定方程 AX = B 中的复矩阵 A 和 B 的行，此模块返回进行精简 QR 分解后所得的 R 和 C=Q'B。\n\n如果正则化参数 Lambda 为非零值，则此模块计算 \n[lambda*eye(n);A]X = [zeros(n,p);B] \n的精简 QR 分解，\n其中 A 为 m×n，B 为 m×p。\n使用 Partial-systolic 实现来最小化系统延迟并增大吞吐量。Partial-systolic 实现比 Burst 实现需要更多硬件资源。
    </entry>
    <entry key="RealPartialSystolicQRDescription">给定方程 AX = B 中的实矩阵 A 和 B 的行，此模块返回进行精简 QR 分解后所得的 R 和 C=Q'B。\n\n如果正则化参数 lambda 为非零值，则此模块计算 \n[lambda*eye(n);A]X = [zeros(n,p);B] \n的精简 QR 分解，\n其中 A 为 m×n，B 为 m×p。\n使用 Partial-systolic 实现来最小化系统延迟并增大吞吐量。Partial-systolic 实现比 Burst 实现需要更多硬件资源。
    </entry>
    <entry key="ComplexPartialSystolicQlessQRDescription">给定复矩阵 A 的行，此模块返回进行精简 QR 分解后所得的上三角矩阵 R。\n\n如果正则化参数 lambda 为非零值，则此模块计算\n[lambda*eye(n);A] \n的精简 QR 分解\n\n使用 Partial-systolic 实现来最小化系统延迟并增大吞吐量。Partial-systolic 实现比 Burst 实现需要更多硬件资源。
    </entry>
    <entry key="RealPartialSystolicQlessQRDescription">给定实矩阵 A 的行，此模块返回精简 QR 分解的上三角矩阵 R。\n\n如果正则化参数 lambda 为非零值，则此模块计算\n[lambda*eye(n);A] \n的精简 QR 分解\n\n使用 Partial-systolic 实现来最小化系统延迟并增大吞吐量。Partial-systolic 实现比 Burst 实现需要更多硬件资源。
    </entry>
    <entry key="ComplexPartialSystolicQlessQRwithForgettingFactorDescription">此模块在给定新复数据向量时更新上三角矩阵。此模块等效于对一个无限 tall 矩阵进行 Q-less QR 分解，在分解矩阵的每行后应用一个遗忘因子。输出是遗忘因子乘以更新后的上三角 R。\n\n如果正则化参数 lambda 为非零值，则此模块将上三角因子 R 初始化为 lambda*eye(n)。\n\n使用 Partial-systolic 实现来最小化系统延迟并增大吞吐量。Partial-systolic 实现比 Burst 实现需要更多硬件资源。
    </entry>
    <entry key="RealPartialSystolicQlessQRwithForgettingFactorDescription">此模块在给定新实数数据向量时更新上三角矩阵。此模块等效于对一个无限 tall 矩阵进行 Q-less QR 分解，在分解矩阵的每行后应用一个遗忘因子。输出是遗忘因子乘以更新后的上三角 R。\n\n如果正则化参数 lambda 为非零值，则此模块将上三角因子 R 初始化为 lambda*eye(n)。\n\n使用 Partial-systolic 实现来最小化系统延迟并增大吞吐量。Partial-systolic 实现比 Burst 实现需要更多硬件资源。
    </entry>
    <entry key="ComplexBurstQRDescription">给定方程 AX = B 中复矩阵 A 和 B 的行，此模块返回进行精简 QR 分解后所得的 R 和 C=Q'B 的行。此处 R 为上三角矩阵，C 是与它行数相同的矩阵。\n\n如果正则化参数 lambda 为非零值，则此模块计算 \n[lambda*eye(n);A]X = [zeros(n,p);B] \n的精简 QR 分解，\n\n其中 A 为 m×n，B 为 m×p。\n\n使用 Burst 实现来最小化所需的硬件资源。Burst 实现导致系统延迟增加，因此降低了模块的吞吐量。
    </entry>
    <entry key="RealBurstQRDescription">给定方程 AX = B 中实矩阵 A 和 B 的行，此模块返回进行精简 QR 分解后所得的 R 和 C=Q'B 的行。此处 R 为上三角矩阵，C 是与它行数相同的矩阵。\n\n如果正则化参数 lambda 为非零值，则此模块计算 \n[lambda*eye(n);A]X = [zeros(n,p);B] \n的精简 QR 分解，\n\n其中 A 为 m×n，B 为 m×p。\n\n使用 Burst 实现来最小化所需的硬件资源。Burst 实现导致系统延迟增加，因此降低了模块的吞吐量。
    </entry>
    <entry key="ComplexBurstQlessQRDescription">给定复矩阵 A 的行，此模块返回进行精简 QR 分解后所得的上三角矩阵 R 的行。\n\n如果正则化参数 lambda 为非零值，则此模块计算\n[lambda*eye(n);A] \n的精简 QR 分解\n\n使用 Burst 实现来最小化所需的硬件资源。Burst 实现导致系统延迟增加，因此降低了模块的吞吐量。
    </entry>
    <entry key="ComplexBurstQlessQRWholeROutputDescription">给定复矩阵 A 的行，此模块返回精简 QR 分解的上三角矩阵 R。\n\n如果正则化参数 lambda 为非零值，则此模块计算\n[lambda*eye(n);A] \n的精简 QR 分解\n\n使用 Burst 实现来最小化所需的硬件资源。Burst 实现导致系统延迟增加，因此降低了模块的吞吐量。
    </entry>
    <entry key="RealBurstQlessQRDescription">给定实矩阵 A 的行，此模块返回进行精简 QR 分解后所得的上三角矩阵 R 的行。\n\n如果正则化参数 lambda 为非零值，则此模块计算\n[lambda*eye(n);A] \n的精简 QR 分解\n\n使用 Burst 实现来最小化所需的硬件资源。Burst 实现导致系统延迟增加，因此降低了模块的吞吐量。
    </entry>
    <entry key="RealBurstQlessQRWholeROutputDescription">给定实矩阵 A 的行，此模块返回进行精简 QR 分解后所得的上三角矩阵 R。\n\n如果正则化参数 lambda 为非零值，则此模块计算\n[lambda*eye(n);A] \n的精简 QR 分解\n\n使用 Burst 实现来最小化所需的硬件资源。Burst 实现导致系统延迟增加，因此降低了模块的吞吐量。
    </entry>
    <entry key="ComplexBurstQlessQRwithForgettingFactorDescription">此模块在给定新复数据向量时更新上三角矩阵。此模块等效于对一个无限 tall 矩阵进行 Q-less QR 分解，在分解矩阵的每行后应用一个遗忘因子。输出为遗忘因子乘以更新后的上三角 R。\n\n如果正则化参数 lambda 为非零值，则此模块将上三角因子 R 初始化为 lambda*eye(n)。\n\n使用 Burst 实现来最小化所需的硬件资源。Burst 实现导致系统延迟增加，因此降低了模块的吞吐量。
    </entry>
    <entry key="RealBurstQlessQRwithForgettingFactorDescription">此模块在给定新实数数据向量时更新上三角矩阵。此模块等效于对一个无限 tall 矩阵进行 Q-less QR 分解，在分解矩阵的每行后应用一个遗忘因子。输出为遗忘因子乘以更新后的上三角 R。\n\n如果正则化参数 lambda 为非零值，则此模块将上三角因子 R 初始化为 lambda*eye(n)。\n\n使用 Burst 实现来最小化所需的硬件资源。Burst 实现导致系统延迟增加，因此降低了模块的吞吐量。
    </entry>
    <entry key="ComplexBurstMatrixSolveDescription">计算方程 AX = B 中 X 的值，其中 A 和 B 为复数值矩阵。\n\n如果正则化参数 lambda 为非零值，则此模块计算方程\n\n[lambda*eye(n);A]X = [zeros(n,p);B] 中 X 的值，\n\n其中 A 为 m×n，B 为 m×p。\n\n使用 Burst 实现来最小化所需的硬件资源。Burst 实现导致系统延迟增加，因此降低了模块的吞吐量。
    </entry>
    <entry key="RealBurstMatrixSolveDescription">计算方程 AX = B 中 X 的值，其中 A 和 B 为实数值矩阵。\n\n如果正则化参数 lambda 为非零值，则此模块计算方程\n\n[lambda*eye(n);A]X = [zeros(n,p);B] 中 X 的值，\n\n其中 A 为 m×n，B 为 m×p。\n\n使用 Burst 实现来最小化所需的硬件资源。Burst 实现导致系统延迟增加，因此降低了模块的吞吐量。
    </entry>
    <entry key="ComplexBurstQlessQRMatrixSolveDescription">计算方程 A'AX = B 中 X 的值，其中 A 和 B 为复数值矩阵。\n\n如果正则化参数 lambda 为非零值，则此模块计算方程\n\n(lambda^2*eye(n) + A'A)X = B 中 X 的值\n\n使用 Burst 实现来最小化所需的硬件资源。Burst 实现导致系统延迟增加，因此降低了模块的吞吐量。
    </entry>
    <entry key="ComplexBurstAsynchronousQlessQRMatrixSolveDescription">计算方程 A'AX = B 中 X 的值，其中 A 和 B 为复数值矩阵。\n\n如果正则化参数 lambda 为非零值，则此模块计算方程\n\n(lambda^2*eye(n) + A'A)X = B 中 X 的值\n\n此模块异步操作。前代和后代以及 Q-less QR 分解使用最新的 R 和 B 矩阵独立运行。\n\n使用 Burst 实现来最小化所需的硬件资源。Burst 实现导致系统延迟增加，因此降低了模块的吞吐量。
    </entry>
    <entry key="RealBurstQlessQRMatrixSolveDescription">计算方程 A'AX = B 中 X 的值，其中 A 和 B 为实数值矩阵。\n\n如果正则化参数 lambda 为非零值，则此模块计算方程\n\n(lambda^2*eye(n) + A'A)X = B 中 X 的值\n\n使用 Burst 实现来最小化所需的硬件资源。Burst 实现导致系统延迟增加，因此降低了模块的吞吐量。
    </entry>
    <entry key="RealBurstAsynchronousQlessQRMatrixSolveDescription">计算方程 A'AX = B 中 X 的值，其中 A 和 B 为实数值矩阵。\n\n如果正则化参数 lambda 为非零值，则此模块计算方程\n\n(lambda^2*eye(n) + A'A)X = B 中 X 的值\n\n此模块异步操作。前代和后代以及 Q-less QR 分解使用最新的 R 和 B 矩阵独立运行。\n\n使用 Burst 实现来最小化所需的硬件资源。Burst 实现导致系统延迟增加，因此降低了模块的吞吐量。
    </entry>
    <entry key="ComplexBurstQlessQRMatrixSolveWithForgettingFactorDescription">计算方程 A'AX = B 中 X 的值，其中 A 和 B 为复数值矩阵。解会随着 A 的每行不断地输入进行更新，在每行分解后对其应用遗忘因子。\n\n如果正则化参数 lambda 为非零值，则此模块将 A 的上三角因子 R 初始化为 lambda*eye(n)。\n\n使用 Burst 实现来最小化所需的硬件资源。Burst 实现导致系统延迟增加，因此降低了模块的吞吐量。
    </entry>
    <entry key="RealBurstQlessQRMatrixSolveWithForgettingFactorDescription">计算方程 A'AX = B 中 X 的值，其中 A 和 B 为实数值矩阵。解会随着 A 的每行不断地输入进行更新，在每行分解后对其应用遗忘因子。\n\n如果正则化参数 lambda 为非零值，则此模块将 A 的上三角因子 R 初始化为 lambda*eye(n)。\n\n使用 Burst 实现来最小化所需的硬件资源。Burst 实现导致系统延迟增加，因此降低了模块的吞吐量。
    </entry>
    <entry key="ComplexPartialSystolicMatrixSolveDescription">计算方程 AX = B 中 X 的值，其中 A 和 B 为复数值矩阵。\n\n如果正则化参数 lambda 为非零值，则此模块计算方程\n\n[lambda*eye(n);A]X = [zeros(n,p);B] 中 X 的值，\n\n其中 A 为 m×n，B 为 m×p。\n\n使用 Partial-systolic 实现来最小化系统延迟并增加吞吐量。Partial-systolic 实现比 Burst 实现需要更多硬件资源。
    </entry>
    <entry key="RealPartialSystolicMatrixSolveDescription">计算方程 AX = B 中 X 的值，其中 A 和 B 为实数值矩阵。\n\n如果正则化参数 lambda 为非零值，则此模块计算方程\n\n[lambda*eye(n);A]X = [zeros(n,p);B] 中 X 的值，\n\n其中 A 为 m×n，B 为 m×p。\n\n使用 Partial-systolic 实现来最小化系统延迟并增加吞吐量。Partial-systolic 实现比 Burst 实现需要更多硬件资源。
    </entry>
    <entry key="ComplexPartialSystolicQlessQRMatrixSolveDescription">计算方程 A'AX = B 中 X 的值，其中 A 和 B 为复数值矩阵。\n\n如果正则化参数 lambda 为非零值，则此模块计算方程\n\n(lambda^2*eye(n) + A'A)X = B 中 X 的值\n\n使用 Partial-systolic 实现来最小化系统延迟并增加吞吐量。Partial-systolic 实现比 Burst 实现需要更多硬件资源。
    </entry>
    <entry key="RealPartialSystolicQlessQRMatrixSolveDescription">计算方程 A'AX = B 中 X 的值，其中 A 和 B 为实数值矩阵。\n\n如果正则化参数 lambda 为非零值，则此模块计算方程\n\n(lambda^2*eye(n) + A'A)X = B 中 X 的值\n\n使用 Partial-systolic 实现来最小化系统延迟并增加吞吐量。Partial-systolic 实现比 Burst 实现需要更多硬件资源。
    </entry>
    <entry key="ComplexPartialSystolicQlessQRMatrixSolveWithForgettingFactorDescription">计算方程 A'AX = B 中 X 的值，其中 A 和 B 为复数值矩阵。解会随着 A 的每行不断地输入进行更新，在每行分解后对其应用遗忘因子。\n\n如果正则化参数 lambda 为非零值，则此模块将 A 的上三角因子 R 初始化为 lambda*eye(n)。\n\n使用 Partial-systolic 实现来最小化系统延迟并增加吞吐量。Partial-systolic 实现比 Burst 实现需要更多硬件资源。
    </entry>
    <entry key="RealPartialSystolicQlessQRMatrixSolveWithForgettingFactorDescription">计算方程 A'AX = B 中 X 的值，其中 A 和 B 为实数值矩阵。解会随着 A 的每行不断地输入进行更新，在每行分解后对其应用遗忘因子。\n\n如果正则化参数 lambda 为非零值，则此模块将 A 的上三角因子 R 初始化为 lambda*eye(n)。\n\n使用 Partial-systolic 实现来最小化系统延迟并增加吞吐量。Partial-systolic 实现比 Burst 实现需要更多硬件资源。
    </entry>
    <entry key="SystolicMatrixSolveDescription">计算方程 AX = B 中 X 的值，其中 A 和 B 是矩阵。A 为 m×n，B 为 m×p。\n \n使用 Systolic 实现来最小化系统延迟并增大吞吐量。Systolic 实现比 Burst 或 Partial-systolic 实现需要更多硬件资源。
    </entry>
    <entry key="BackSubstituteDescription">使用回代计算方程 RX = C 中 X 的值，其中 R 为上三角矩阵。</entry>
    <entry key="RealBackSubstituteDescription">使用回代计算方程 RX = C 中 X 的值，其中 R 为实数值上三角矩阵，C 为任何实数值矩阵。</entry>
    <entry key="ComplexBackSubstituteDescription">使用回代计算方程 RX = C 中 X 的值，其中 R 为复数值上三角矩阵，C 为任何复数值矩阵。</entry>
    <entry key="RealForwardSubstituteDescription">使用前代计算方程 LX = C 中 X 的值，其中 L 为实数值下三角矩阵，C 为任何实数值矩阵。</entry>
    <entry key="ComplexForwardSubstituteDescription">使用前代计算方程 LX = C 中 X 的值，其中 L 为复数值下三角矩阵，C 为任何复数值矩阵。</entry>
    <entry key="RealForwardBackwardSubstituteDescription">计算方程 R'RX = B 中 X 的值，其中 R 为实数值上三角矩阵，B 为任意实数值矩阵。 </entry>
    <entry key="ComplexCombinedSubstituteDescription">计算方程 R'RX = B 中 X 的值，其中 R 为复数值上三角矩阵，B 为任意复数值矩阵。</entry>
    <entry key="SquareJacobiSVDDescriptionDescription">给定方阵 A，此模块使用双边雅可比法产生由非负元素组成的向量 s 以及酉矩阵 U 和 V，使得 that A = U*diag(s)*V'。</entry>
    <entry key="NonSquareJacobiSVDDescriptionDescription">给定行数大于列数的矩阵 A，此模块使用双边雅可比法产生由非负元素组成的向量 s 以及酉矩阵 U 和 V，使得 A = U*diag(s)*V'。</entry>
    <entry key="EulerNEDTransformation">将一个 3×1 向量 U In 按角度 Angle In 旋转。Angle In 是一个 3×1 实数向量，分别指定绕 x 轴、y 轴和 z 轴的旋转角度。</entry>
  </message>
</rsccat>
