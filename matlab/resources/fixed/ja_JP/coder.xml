<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2024 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ja_JP" product="fixed" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="abs_X_Var1_Var1MustBeConstant">abs(x,var1) では、var1 を定数にしなければなりません。</entry>
    <entry key="abs_X_Var1_Var2_VarsMustBeConstant">abs(x,var1,var2) では、var1 と var2 を定数にしなければなりません。</entry>
    <entry key="absComplexFiBooleanUnsupported">fi オブジェクトまたは指定された numerictype オブジェクトが Boolean である場合、関数 abs は複素数 fi オブジェクトをサポートしません。</entry>
    <entry key="absFIFixPtBPSOnly">関数 abs は 2 進小数点のスケーリングのみをサポートします。関数 abs と併用される任意の numerictype オブジェクトまたは fi オブジェクトでは、小数部の傾き は 1、バイアスは 0 でなければなりません。</entry>
    <entry key="argMustBeConstant">''{1}'' に対する {0} の引数は定数でなければなりません。</entry>
    <entry key="autoDimIncompatibility">使用する次元は自動的に選択されます。可変長で実行時の長さは 1 です。これはサポートされていません。DIM の引数を指定して、使用する次元を手動で選択します。</entry>
    <entry key="bitOpsIndexArgsNotSameClass">インデックス引数は同じクラスでなければなりません。</entry>
    <entry key="bitOpsLeftIdxNotCnstSclrGTZ">左のインデックスは定数のスカラーで、0 より大きくなければなりません。</entry>
    <entry key="bitOpsLeftIdxNotGTEqRightIdx">左のインデックス値は、右のインデックス値以上でなければなりません。</entry>
    <entry key="bitOpsLeftIdxNotLTEqWordLength">左のインデックスは、入力オペランドの語長以下でなければなりません。</entry>
    <entry key="bitOpsLeftIndexArgTypeInvalid">左のインデックス引数は数値でなければなりません。</entry>
    <entry key="bitOpsRightIndexArgTypeInvalid">右のインデックス引数は数値でなければなりません。</entry>
    <entry key="bitOpsRightIndexNotCnstSclrGTZ">右のインデックスは定数のスカラーで、0 より大きくなければなりません。</entry>
    <entry key="bitRepCannotRepBits">{0, number, integer} を超えるビットを複製することはできません。</entry>
    <entry key="bitRepInvalid2ndInpArg">2 番目の入力引数 (複製定数) は、定数、実数、スカラー、組み込みの数値タイプでなければなりません。</entry>
    <entry key="bitsraInpWLMustBeGTOne">bitsra 入力オペランドの語長は 1 より大きくなければなりません。</entry>
    <entry key="bitsxxInpWLMustBeGTOne">{0} 入力オペランドの語長は 1 より大きくなければなりません。</entry>
    <entry key="dimArgMustBeAConstant">次元の引数は定数でなければなりません。</entry>
    <entry key="divide_T_a_b_aMustBeNumeric">divide(T,a,b) では、a を数値にしなければなりません。</entry>
    <entry key="divide_T_a_b_bMustBeNumeric">divide(T,a,b) では、b を数値にしなければなりません。</entry>
    <entry key="divideFi_NonFi_NonFiMustBeConstant">divide(t,fi,non-fi) では、non-fi を定数にしなければなりません。</entry>
    <entry key="divideNonFi_Fi_NonFiMustBeConstant">divide(t,non-fi,fi) では、non-fi を定数にしなければなりません。</entry>
    <entry key="divideNotDefinedFor1stArgType">関数 divide は、クラス {0} の最初の引数に定義されていません。これは embedded.numerictype でなければなりません。</entry>
    <entry key="eml_FcnNameArgMustBeConst">関数 {0} の名前引数は定数でなければなりません。</entry>
    <entry key="eml_FcnNameArgUnsupported">{0} funstr 引数 {1} はサポートされていません。</entry>
    <entry key="fiFilterNumeratorSizeNotConst">分子の次元を変更しないでください。</entry>
    <entry key="fiFilterZiLeadingDimNotConst">初期条件の最初の次元を変更しないでください。</entry>
    <entry key="fiFilterAllInpArgsMustBeFiObjects">フィルター係数、入力データおよび初期条件 (ある場合) はすべて FI オブジェクトでなければなりません。</entry>
    <entry key="fiFilterAllInpArgsMustHaveSameDType">フィルター係数、入力データおよび初期条件 (ある場合) はすべて同じデータ型でなければなりません。</entry>
    <entry key="fiFilterZiDTypeMustMatchOutput">状態は FI オブジェクトであり、出力 numerictype (DataType = {0}、Signedness = {1}、WordLength = {2, number, integer}、FractionLength = {3, number, integer}) と一致しなければなりません。</entry>
    <entry key="fiFilterZiCplxMustMatchOutput">初期条件の実数/複素数は出力と一致しなければなりません。</entry>
    <entry key="fiFunctionDataTypeError">関数 {0} は、固定小数点、スケーリングされた double、double または single のデータ型をもつ fi オブジェクトのみで使用できます。</entry>
    <entry key="fiFunctionScalarInputOnly">固定小数点の関数 {0} は、スカラーでない fi の入力ではサポートされません。</entry>
    <entry key="fiFcnDTypeErrorOnlyFixBPSDblSgl">関数 {0} は、固定小数点 (2 進小数点スケーリング)、double または single のデータ型をもつ fi オブジェクトのみで使用できます。</entry>
    <entry key="fiFcnDTypeErrorFixPtOnly">関数 {0} は、固定小数点データ型をもつ fi オブジェクトとのみ併用できます。</entry>
    <entry key="fiFcnDTypeErrNumericOnly">関数 {0} は、数値データ型をもつ fi オブジェクトとのみ併用できます。</entry>
    <entry key="fiCompareNonFI_NonFIMustBeConst">fi を non-fi と比較する際、non-fi は定数でなければなりません。</entry>
    <entry key="fiInputArgMustBeConstant">fi(var1, var2,..varN) の呼び出しする場合、入力 var2..varN は定数でなければなりません。入力 {0} は定数ではありません。</entry>
    <entry key="fiInvalidMethodSignature">クラス embedded.fi には、一致するシグネチャをもつメソッド {0} が見つかりません。</entry>
    <entry key="fimathInvalidArgs">FIMATH 引数が無効です。</entry>
    <entry key="fimathInvalidMethodSignature">クラス embedded.fimath には、一致するシグネチャをもつメソッド {0} が見つかりません。</entry>
    <entry key="fimathMustBeConst">Fimath は定数でなければなりません。</entry>
    <entry key="fiMathOpsFullPrecisionCastBeforeSum">fi の数学演算では、SumMode が FullPrecision でない場合は CastBeforeSum が true であることが必要です。</entry>
    <entry key="fiMethodNotSupportedForCodegen">FI オブジェクトの {0} メソッドはコード生成にサポートされていません。</entry>
    <entry key="fiNonFiFcnForm_NonFiMustBeConstant">{0}(fi,non-fi) または {1}(non-fi,fi) では、non-fi を定数にしなければなりません。</entry>
    <entry key="fiNonFiOpForm_NonFiMustBeConstant">fi {0} non-fi または non-fi {1} fi では、non-fi を定数にしなければなりません。</entry>
    <entry key="fiPVPairsDataPropSizeMustMatchFIFirstInpArgSize">fi コンストラクターへの最初の入力が数値であり、プロパティ値のペアを使用して fi オブジェクトの stored-data プロパティを指定する場合、対応する stored-data プロパティ値のサイズは fi コンストラクターへの最初の入力のサイズと一致しなければなりません。</entry>
    <entry key="fiShiftArgDataTypeUnsupported">サポートされない shift 引数のデータ型が {0} にあります。</entry>
    <entry key="fixedBinaryPointOnlyCodegen"> 関数 {0} は、2 進小数点でスケーリングされた固定小数点入力のコード生成のみをサポートしています。</entry>
    <entry key="fiVar1InpMustBeNumericOrAConstant">fi(var1,...) での入力 var1 は数値または定数でなければなりません。</entry>
    <entry key="fiVar2toNInpArgsMustBeConstant">fi(var1,var2,...varN) で var1 が定数でない場合、var2 から varN までは完全な numerictype であるか、完全な numerictype を指定しなければなりません。</entry>
    <entry key="fiVar2MustBeConstant">fi(var1,var2) では、入力 var2 を定数にしなければなりません。</entry>
    <entry key="fiVar2MustBeTorF">fi(var1,var2) で var1 が定数でない場合、入力 var2 は numerictype または fimath でなければなりません。</entry>
    <entry key="fiVar2TofUnspecifiedScalingNotSupported">fi(var1,var2) で var1 が定数でない場合、入力 var2 を無指定スケーリングの numerictype にすることはできません。</entry>
    <entry key="fitoolNotSupportedForCodegen">FITOOL はコード生成でサポートされていません。</entry>
    <entry key="functionNotDefinedFor1stArgType">関数 ''{0}'' は、クラス {1} の最初の引数に対して定義されません。</entry>
    <entry key="fxpUArgValsMustBeNumericNonemptyFinite">引数 u の値は数値で、空白以外の有限値でなければなりません。</entry>
    <entry key="globalfimathFcnNotSupportedForCodegen">関数 GLOBALFIMATH はコード生成でサポートされていません。</entry>
    <entry key="incorrectNumberOfInputs">入力数が正しくありません。</entry>
    <entry key="incorrectNumberOfInputsGet">入力数が正しくありません。構文 get(a) はサポートされていません。</entry>
    <entry key="inputMustBeConstant">{1} における入力 {0} は定数でなければなりません。</entry>
    <entry key="inputMustBeConstantOrAFI">{1} における入力 {0} は定数か fi でなければなりません。</entry>
    <entry key="inputMustBeNumeric">入力は数値でなければなりません。</entry>
    <entry key="inputTypeUnsupported">{0} 型の入力は {1} でサポートされていません。</entry>
    <entry key="invalidEnumValue">Argument {0} must have a value belonging to the set {1}.</entry>
    <entry key="invalidInputArg">入力引数が無効です。</entry>
    <entry key="invalidUseGet">関数 ''get'' は MATLAB ワークスペース内で関連付けられます。この関数の呼び出しには coder.extrinsic(''get'') を使用するか、入力が fi、numerictype、fimath のいずれかでない場合は feval を使用してください。</entry>
    <entry key="mpowerProductModeForNonConstExponent">入力がスカラーで mpower 指数入力が定数でない場合、ProductMode は SpecifyPrecision でなければなりません。これにより、コンパイル時に出力データ型を決定できます。</entry>
    <entry key="mpowerSumModeForNonConstExponent">入力がスカラーでなく mpower 指数入力が定数でない場合、SumMode は SpecifyPrecision でなければなりません。これにより、コンパイル時に出力データ型を決定できます。</entry>
    <entry key="mustBeConstant">{0} は定数でなければなりません。</entry>
    <entry key="notEnoughInputArguments">入力引数が不足しています。</entry>
    <entry key="numerictypeMustBeConst">numerictype は定数でなければなりません。</entry>
    <entry key="onlyDotForProperty">{0} は {1} オブジェクトのプロパティではありません: X.{2}。コード生成時にドット表記を使用できるのは {3} オブジェクトのプロパティのみです。{4} オブジェクトのメソッドについては、代わりに関数表記を使用します: {5}(X)。</entry>
    <entry key="outputWLExceedsMaxWLLimit">出力タイプが最大ビット数 ({0, number, integer}) を超えています。</entry>
    <entry key="powerProductModeForNonConstExponent">べき指数入力が定数でない場合、ProductMode は SpecifyPrecision でなければなりません。これにより、コンパイル時に出力データ型を決定できます。</entry>
    <entry key="reinterpretcastWordLengthMismatch">数値型の語長は、キャストされる fi オブジェクトの語長と等しくなければなりません。</entry>
    <entry key="reinterpretcastFirstInputInvalidDType">最初の入力は、固定小数点かスケーリングされた double の fi オブジェクトでなければなりません。</entry>
    <entry key="reinterpretcastSecondInputNotNumerictype">2 番目の入力は numerictype でなければなりません。</entry>
    <entry key="relOpArgsHaveUnequalBias">関係演算子は、バイアス値が等しくない場合はサポートされません。</entry>
    <entry key="rescaleFiDoubleSingleBooleanInvalidPropChange">データ型モードが double、single または boolean の場合、指定されたプロパティは変更できません。このプロパティは変更されませんでした。</entry>
    <entry key="slopeBiasInputsNotSupported">傾きバイアスのスケーリングされた入力はサポートされていません。</entry>
    <entry key="sqrtSlopeBiasInputsNotSupported">SQRT(A) または SQRT(A,T) は、A と T のスケーリングに小数部の傾き 1 とバイアス 0 が含まれる場合 (2 進小数点のみのスケーリング) にのみ、FI オブジェクト A および NumericType T に対して計算できます。</entry>
    <entry key="sumModeRestrictedForVarS">コード生成では、入力のサイズが実行時に変化する可能性がある場合、SumModes は ''{0}'' に対して''SpecifyPrecision'' または ''KeepLSB'' でなければなりません。</entry>
    <entry key="unsupportedBooleanNumerictype">MATLAB のコード生成では、DataTypeMode = ''Boolean'' の固定小数点数値オブジェクト (fi) はサポートされません。代わりに、MATLAB logical 変数を使用する必要があります。</entry>
    <entry key="unsupportedSumMode">コード生成では、入力のサイズが実行時に変化する可能性がある場合、SumMode は ''{0}'' に対して ''SpecifyPrecision'' または ''KeepLSB'' でなければなりません。</entry>
    <entry key="wordLengthExceedsMaxWL">指定された語長が最大ビット数 ({0, number, integer}) を超えています。</entry>
    <entry key="wordLengthMustBeLTEQ32">語長は 32 以下でなければなりません。</entry>
    <entry key="colonBitWidthMax64">コード生成では、コロン出力のビット幅が 64 を超えることはできません。</entry>
    <entry key="sqrt_X_Var1_Var1MustBeConstant">sqrt(x,var1) では、var1 は定数でなければなりません。</entry>
  </message>
</rsccat>
