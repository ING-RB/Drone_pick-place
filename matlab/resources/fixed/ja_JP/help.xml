<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2024 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ja_JP" product="fixed" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="SystolicQRDescription">式 AX = B で行列 A および B の行が与えられると、このブロックはサイズを抑えた QR 分解 R および C=Q'B を返します。\nここで、A は m 行 n 列、B は m 行 p 列です。\n \nシステム レイテンシを最小限にしてスループットを最大化するには、シストリック実装を使用してください。シストリック実装には、バーストによる実装または部分的なシストリック実装よりも多くのハードウェア リソースが必要です。
    </entry>
    <entry key="ComplexPartialSystolicQRDescription">式 AX = B で複素行列 A および B の行が与えられると、このブロックはサイズを抑えた QR 分解 R および C=Q'B を返します。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次のサイズを抑えた QR 分解を計算します\n \n[lambda*eye(n);A]X = [zeros(n,p);B]。\n \nここで A は m 行 n 列、B は m 行 p 列です。\n \nシステムのレイテンシを最小限にしてスループットを上げるには、部分的なシストリック実装を使用してください。部分的なシストリック実装には、バーストによる実装よりも多くのハードウェア リソースが必要です。
</entry>
    <entry key="RealPartialSystolicQRDescription">式 AX = B で実数行列 A および B の行が与えられると、このブロックはサイズを抑えた QR 分解 R および C=Q'B を返します。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次のサイズを抑えた QR 分解を計算します\n \n[lambda*eye(n);A]X = [zeros(n,p);B]。\n \nここで A は m 行 n 列、B は m 行 p 列です。\n \nシステムのレイテンシを最小限にしてスループットを上げるには、部分的なシストリック実装を使用してください。部分的なシストリック実装には、バーストによる実装よりも多くのハードウェア リソースが必要です。
</entry>
    <entry key="ComplexPartialSystolicQlessQRDescription">複素行列 A の行が与えられると、このブロックはサイズを抑えた QR 分解の上三角行列 R を返します。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次のサイズを抑えた QR 分解を計算します\n \n[lambda*eye(n);A]\n \nシステムのレイテンシを最小限にしてスループットを上げるには、部分的なシストリック実装を使用してください。部分的なシストリック実装には、バーストによる実装よりも多くのハードウェア リソースが必要です。
</entry>
    <entry key="RealPartialSystolicQlessQRDescription">実数行列 A の行が与えられると、このブロックはサイズを抑えた QR 分解の上三角行列 R を返します。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次のサイズを抑えた QR 分解を計算します\n \n[lambda*eye(n);A]\n \nシステムのレイテンシを最小限にしてスループットを上げるには、部分的なシストリック実装を使用してください。部分的なシストリック実装には、バーストによる実装よりも多くのハードウェア リソースが必要です。
</entry>
    <entry key="ComplexPartialSystolicQlessQRwithForgettingFactorDescription">このブロックは、新しい複素数データ ベクトルが与えられると上三角行列を更新します。このブロックは、行列の各行を分解した後に忘却係数が適用される、無限大の tall 行列の Q-less QR 分解と等価です。出力は、忘却係数に、更新された上三角 R を乗算したものです。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは上三角因子 R を lambda*eye(n) に初期化します。\n \nシステムのレイテンシを最小限にしてスループットを上げるには、部分的なシストリック実装を使用してください。部分的なシストリック実装には、バーストによる実装よりも多くのハードウェア リソースが必要です。
</entry>
    <entry key="RealPartialSystolicQlessQRwithForgettingFactorDescription">このブロックは、新しい実数データ ベクトルが与えられると上三角行列を更新します。このブロックは、行列の各行を分解した後に忘却係数が適用される、無限大の tall 行列の Q-less QR 分解と等価です。出力は、忘却係数に、更新された上三角 R を乗算したものです。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは上三角因子 R を lambda*eye(n) に初期化します。\n \nシステムのレイテンシを最小限にしてスループットを上げるには、部分的なシストリック実装を使用してください。部分的なシストリック実装には、バーストによる実装よりも多くのハードウェア リソースが必要です。
</entry>
    <entry key="ComplexBurstQRDescription">式 AX = B で複素行列 A および B の行が与えられると、このブロックはサイズを抑えた QR 分解 R および C=Q'B の行を返します。ここで、R は上三角行列、C は同数の行をもつ行列です。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次のサイズを抑えた QR 分解を計算します\n \n[lambda*eye(n);A]X = [zeros(n,p);B]。\n \nここで A は m 行 n 列、B は m 行 p 列です。\n \n必要なハードウェア リソースを最小限にするには、バーストによる実装を使用してください。バーストによる実装ではシステムのレイテンシが増加するため、ブロックのスループットが低下します。
</entry>
    <entry key="RealBurstQRDescription">式 AX = B で実数行列 A および B の行が与えられると、このブロックはサイズを抑えた QR 分解 R および C=Q'B の行を返します。ここで、R は上三角行列、C は同数の行をもつ行列です。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次のサイズを抑えた QR 分解を計算します\n \n[lambda*eye(n);A]X = [zeros(n,p);B]。\n \nここで A は m 行 n 列、B は m 行 p 列です。\n \n必要なハードウェア リソースを最小限にするには、バーストによる実装を使用してください。バーストによる実装ではシステムのレイテンシが増加するため、ブロックのスループットが低下します。
</entry>
    <entry key="ComplexBurstQlessQRDescription">複素行列 A の行が与えられると、このブロックはサイズを抑えた QR 分解の上三角行列 R の行を返します。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次のサイズを抑えた QR 分解を計算します\n \n[lambda*eye(n);A]\n \n必要なハードウェア リソースを最小限にするには、バーストによる実装を使用してください。バーストによる実装ではシステムのレイテンシが増加するため、ブロックのスループットが低下します。
</entry>
    <entry key="ComplexBurstQlessQRWholeROutputDescription">複素行列 A の行が与えられると、このブロックはサイズを抑えた QR 分解の上三角行列 R を返します。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次のサイズを抑えた QR 分解を計算します\n \n[lambda*eye(n);A]\n \n必要なハードウェア リソースを最小限にするには、バーストによる実装を使用してください。バーストによる実装ではシステムのレイテンシが増加するため、ブロックのスループットが低下します。
    </entry>
    <entry key="RealBurstQlessQRDescription">実数行列 A の行が与えられると、このブロックはサイズを抑えた QR 分解の上三角行列 R の行を返します。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次のサイズを抑えた QR 分解を計算します\n \n[lambda*eye(n);A]\n \n必要なハードウェア リソースを最小限にするには、バーストによる実装を使用してください。バーストによる実装ではシステムのレイテンシが増加するため、ブロックのスループットが低下します。
</entry>
    <entry key="RealBurstQlessQRWholeROutputDescription">実数行列 A の行が与えられると、このブロックはサイズを抑えた QR 分解の上三角行列 R を返します。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次のサイズを抑えた QR 分解を計算します\n \n[lambda*eye(n);A]\n \n必要なハードウェア リソースを最小限にするには、バーストによる実装を使用してください。バーストによる実装ではシステムのレイテンシが増加するため、ブロックのスループットが低下します。
    </entry>
    <entry key="ComplexBurstQlessQRwithForgettingFactorDescription">このブロックは、新しい複素数データ ベクトルが与えられると上三角行列を更新します。このブロックは、行列の各行を分解した後に忘却係数が適用される、無限大の tall 行列の Q-less QR 分解と等価です。出力は、忘却係数に、更新された上三角 R を乗算したものです。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは上三角因子 R を lambda*eye(n) に初期化します。\n \n必要なハードウェア リソースを最小限にするには、バーストによる実装を使用してください。バーストによる実装ではシステムのレイテンシが増加するため、ブロックのスループットが低下します。
    </entry>
    <entry key="RealBurstQlessQRwithForgettingFactorDescription">このブロックは、新しい実数データ ベクトルが与えられると上三角行列を更新します。このブロックは、行列の各行を分解した後に忘却係数が適用される、無限大の tall 行列の Q-less QR 分解と等価です。出力は、忘却係数に、更新された上三角 R を乗算したものです。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは上三角因子 R を lambda*eye(n) に初期化します。\n \n必要なハードウェア リソースを最小限にするには、バーストによる実装を使用してください。バーストによる実装ではシステムのレイテンシが増加するため、ブロックのスループットが低下します。
    </entry>
    <entry key="ComplexBurstMatrixSolveDescription">式 AX = B で X の値を計算します。ここで A と B は複素数値の行列です。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次の式で X の値を計算します\n \n[lambda*eye(n);A]X = [zeros(n,p);B]。\n \nここで A は m 行 n 列、B は m 行 p 列です。\n \n必要なハードウェア リソースを最小限にするには、バーストによる実装を使用してください。バーストによる実装ではシステムのレイテンシが増加するため、ブロックのスループットが低下します。
</entry>
    <entry key="RealBurstMatrixSolveDescription">式 AX = B で X の値を計算します。ここで A と B は実数値の行列です。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次の式で X の値を計算します\n \n[lambda*eye(n);A]X = [zeros(n,p);B]。\n \nここで A は m 行 n 列、B は m 行 p 列です。\n \n必要なハードウェア リソースを最小限にするには、バーストによる実装を使用してください。バーストによる実装ではシステムのレイテンシが増加するため、ブロックのスループットが低下します。
</entry>
    <entry key="ComplexBurstQlessQRMatrixSolveDescription">式 A'AX = B で X の値を計算します。ここで A と B は複素数値の行列です。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次の式で X の値を計算します \n(lambda^2*eye(n) + A'A)X = B\n \n必要なハードウェア リソースを最小限にするには、バーストによる実装を使用してください。バーストによる実装ではシステムのレイテンシが増加するため、ブロックのスループットが低下します。
</entry>
    <entry key="ComplexBurstAsynchronousQlessQRMatrixSolveDescription">式 A'AX = B で X の値を計算します。ここで A と B は複素数値の行列です。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次の式で X の値を計算します \n(lambda^2*eye(n) + A'A)X = B\n \nこのブロックは非同期で動作します。前進代入および後退代入と Q-less QR 分解は、最新の R 行列と B 行列を使用して個別に実行されます。\n \n必要なハードウェア リソースを最小限にするには、バーストによる実装を使用してください。バーストによる実装ではシステムのレイテンシが増加するため、ブロックのスループットが低下します。
    </entry>
    <entry key="RealBurstQlessQRMatrixSolveDescription">式 A'AX = B で X の値を計算します。ここで A と B は実数値の行列です。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次の式で X の値を計算します \n(lambda^2*eye(n) + A'A)X = B\n \n必要なハードウェア リソースを最小限にするには、バーストによる実装を使用してください。バーストによる実装ではシステムのレイテンシが増加するため、ブロックのスループットが低下します。
</entry>
    <entry key="RealBurstAsynchronousQlessQRMatrixSolveDescription">式 A'AX = B で X の値を計算します。ここで A と B は実数値の行列です。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次の式で X の値を計算します \n(lambda^2*eye(n) + A'A)X = B\n \nこのブロックは非同期で動作します。前進代入および後退代入と Q-less QR 分解は、最新の R 行列と B 行列を使用して個別に実行されます。\n \n必要なハードウェア リソースを最小限にするには、バーストによる実装を使用してください。バーストによる実装ではシステムのレイテンシが増加するため、ブロックのスループットが低下します。
    </entry>
    <entry key="ComplexBurstQlessQRMatrixSolveWithForgettingFactorDescription">式 A'AX = B で X の値を計算します。ここで A と B は複素数値の行列です。行列の各行が因子分解された後に忘却係数が適用されて A の各行に無制限に入力されると、解が更新されます。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは A の上三角因子 R を lambda*eye(n) に初期化します。\n \n必要なハードウェア リソースを最小限にするには、バーストによる実装を使用してください。バーストによる実装ではシステムのレイテンシが増加するため、ブロックのスループットが低下します。
    </entry>
    <entry key="RealBurstQlessQRMatrixSolveWithForgettingFactorDescription">式 A'AX = B で X の値を計算します。ここで A と B は実数値の行列です。行列の各行が因子分解された後に忘却係数が適用されて A の各行に無制限に入力されると、解が更新されます。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは A の上三角因子 R を lambda*eye(n) に初期化します。\n \n必要なハードウェア リソースを最小限にするには、バーストによる実装を使用してください。バーストによる実装ではシステムのレイテンシが増加するため、ブロックのスループットが低下します。
    </entry>
    <entry key="ComplexPartialSystolicMatrixSolveDescription">式 AX = B で X の値を計算します。ここで A と B は複素数値の行列です。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次の式で X の値を計算します\n \n[lambda*eye(n);A]X = [zeros(n,p);B]。\n \nここで A は m 行 n 列、B は m 行 p 列です。\n \nシステムのレイテンシを最小限にしてスループットを上げるには、部分的なシストリック実装を使用してください。部分的なシストリック実装には、バーストによる実装よりも多くのハードウェア リソースが必要です。
</entry>
    <entry key="RealPartialSystolicMatrixSolveDescription">式 AX = B で X の値を計算します。ここで A と B は実数値の行列です。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次の式で X の値を計算します\n \n[lambda*eye(n);A]X = [zeros(n,p);B]。\n \nここで A は m 行 n 列、B は m 行 p 列です。\n \nシステムのレイテンシを最小限にしてスループットを上げるには、部分的なシストリック実装を使用してください。部分的なシストリック実装には、バーストによる実装よりも多くのハードウェア リソースが必要です。
</entry>
    <entry key="ComplexPartialSystolicQlessQRMatrixSolveDescription">式 A'AX = B で X の値を計算します。ここで A と B は複素数値の行列です。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次の式で X の値を計算します \n(lambda^2*eye(n) + A'A)X = B\n \nシステムのレイテンシを最小限にしてスループットを上げるには、部分的なシストリック実装を使用してください。部分的なシストリック実装には、バーストによる実装よりも多くのハードウェア リソースが必要です。
</entry>
    <entry key="RealPartialSystolicQlessQRMatrixSolveDescription">式 A'AX = B で X の値を計算します。ここで A と B は実数値の行列です。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは次の式で X の値を計算します \n(lambda^2*eye(n) + A'A)X = B\n \nシステムのレイテンシを最小限にしてスループットを上げるには、部分的なシストリック実装を使用してください。部分的なシストリック実装には、バーストによる実装よりも多くのハードウェア リソースが必要です。
</entry>
    <entry key="ComplexPartialSystolicQlessQRMatrixSolveWithForgettingFactorDescription">式 A'AX = B で X の値を計算します。ここで A と B は複素数値の行列です。行列の各行が因子分解された後に忘却係数が適用されて A の各行に無制限に入力されると、解が更新されます。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは A の上三角因子 R を lambda*eye(n) に初期化します。\n \nシステムのレイテンシを最小限にしてスループットを上げるには、部分的なシストリック実装を使用してください。部分的なシストリック実装には、バーストによる実装よりも多くのハードウェア リソースが必要です。
</entry>
    <entry key="RealPartialSystolicQlessQRMatrixSolveWithForgettingFactorDescription">式 A'AX = B で X の値を計算します。ここで A と B は実数値の行列です。行列の各行が因子分解された後に忘却係数が適用されて A の各行に無制限に入力されると、解が更新されます。\n \n正則化パラメーター lambda がゼロ以外の場合、このブロックは A の上三角因子 R を lambda*eye(n) に初期化します。\n \nシステムのレイテンシを最小限にしてスループットを上げるには、部分的なシストリック実装を使用してください。部分的なシストリック実装には、バーストによる実装よりも多くのハードウェア リソースが必要です。
</entry>
    <entry key="SystolicMatrixSolveDescription">式 AX = B で X の値を計算します。ここで A と B は行列です。A は m 行 n 列、B は m 行 p 列です。\n \nシステム レイテンシを最小限にしてスループットを最大化するには、シストリック実装を使用してください。シストリック実装には、バーストによる実装または部分的なシストリック実装よりも多くのハードウェア リソースが必要です。
    </entry>
    <entry key="BackSubstituteDescription">後退代入を使用して、式 RX = C で X の値を計算します。ここで R は上三角行列です。</entry>
    <entry key="RealBackSubstituteDescription">後退代入を使用して、式 RX = C で X の値を計算します。ここで R は実数値上三角行列、C は任意の実数値行列です。</entry>
    <entry key="ComplexBackSubstituteDescription">後退代入を使用して、式 RX = C で X の値を計算します。ここで R は複素数値上三角行列、C は任意の複素数値行列です。</entry>
    <entry key="RealForwardSubstituteDescription">前進代入を使用して、式 LX = C で X の値を計算します。ここで L は実数値下三角行列、C は任意の実数値行列です。</entry>
    <entry key="ComplexForwardSubstituteDescription">前進代入を使用して、式 LX = C で X の値を計算します。ここで L は複素数値下三角行列、C は任意の複素数値行列です。</entry>
    <entry key="RealForwardBackwardSubstituteDescription">式 R'RX = B で X の値を計算します。ここで R は実数値上三角行列、B は任意の実数値行列です。 </entry>
    <entry key="ComplexCombinedSubstituteDescription">式 R'RX = B で X の値を計算します。ここで R は複素数値上三角行列、B は任意の複素数値行列です。</entry>
    <entry key="SquareJacobiSVDDescriptionDescription">正方行列 A が与えられた場合、このブロックは両側ヤコビ法を使用して非負要素からなるベクトル s と、A = U*diag(s)*V' を満たすユニタリ行列 U および V を生成します。</entry>
    <entry key="NonSquareJacobiSVDDescriptionDescription">行数が列数より多い行列 A が与えられた場合、このブロックは両側ヤコビ法を使用して非負要素からなるベクトル s と、A = U*diag(s)*V' を満たすユニタリ行列 U および V を生成します。</entry>
    <entry key="EulerNEDTransformation">3 行 1 列のベクトル [U In] を [Angle In] の角度だけ回転させます。[Angle In] は、それぞれ x 軸、y 軸、z 軸を中心とした回転の角度を指定する 3 行 1 列の実数ベクトルです。</entry>
  </message>
</rsccat>
