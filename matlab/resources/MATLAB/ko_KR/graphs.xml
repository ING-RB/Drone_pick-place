<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2024 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ko_KR" product="MATLAB" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="BadVertexID">
ID가 {0,number,integer}인 정점이 해당 그래프에 존재하지 않습니다. 제거된 것 같습니다.
 </entry>
    <entry key="OrphanVertex">
이 정점이 속해 있는 그래프가 더 이상 존재하지 않습니다.
 </entry>
    <entry key="OrphanEdge">
이 간선가 속해 있는 그래프가 더 이상 존재하지 않습니다.
 </entry>
    <entry key="NoVertexData">
정점에 데이터가 없습니다.
 </entry>
    <entry key="NoEdgeData">
간선에 데이터가 없습니다.
 </entry>
    <entry key="BadEdgeTarget">
유효하지 않은 간선입니다. 타깃 정점이 존재하지 않습니다.
 </entry>
    <entry key="BadEdgeSource">
유효하지 않은 간선입니다. 소스 정점이 존재하지 않습니다.
 </entry>
    <entry key="InvalidEdge">
해당 그래프의 정점 ID {0,number,integer}에서 정점 ID {1,number,integer} 사이에 간선가 없습니다.
 </entry>
    <entry key="BadVertexDescriptor">
설명자(Descriptor)가 {0,number,integer}인 정점이 해당 그래프에 존재하지 않습니다. 제거된 것 같습니다.
 </entry>
    <entry key="VertexIDOutOfRange">
정점 ID {0,number,integer}이(가) 범위를 벗어났습니다. 유효 범위: {1,number,integer} ~ {2,number,integer}
 </entry>
    <entry key="RemoveEmptyVertex">
그래프에서 빈 정점을 제거할 수 없습니다. Graph.vertex()를 사용하여 유효한 Vertex 객체를 가져오거나 유효한 정점 ID를 제공하십시오.
 </entry>
    <entry key="RemoveEmptyEdge">
그래프에서 빈 간선를 제거할 수 없습니다. Graph.edge()를 사용하여 유효한 Vertex 객체를 가져오거나 유효한 소스 및 타깃 정점 ID를 제공하십시오.
 </entry>
    <entry key="BadVertexIDSize">
예기치 않은 크기의 정점 식별자임: {0,number,integer}바이트. 유효한 바이트 수를 지정하십시오. {1}
 </entry>
    <entry key="EmptyVertexID">
정점 ID는 비어 있을 수 없습니다. double 또는 int32 등의 숫자형을 사용하십시오.
 </entry>
    <entry key="BadVertexIDType">
{0} 유형의 데이터에서 정점 ID를 만들 수 없습니다. double 또는 int32 등의 숫자형을 사용하십시오.
 </entry>
    <entry key="BadEdgeVertex">
정점 {0,number,integer}과(와) {1,number,integer} 중 하나가 유효하지 않은 정점이어서 둘 사이에 간선를 만들 수 없습니다. 유효한 정점 ID 범위: {2,number,integer} ~ {3,number,integer}.
 </entry>
    <entry key="PropertyCountWrong">
속성의 개수가 올바르지 않습니다. 받은 개수: {0,number,integer}. 필요한 개수: {1,number,integer} 또는 1.
 </entry>
    <entry key="ValueCountWrong">
값의 개수가 올바르지 않습니다. 받은 개수: {0,number,integer}. 필요한 개수: {1,number,integer} 또는 1.
 </entry>
    <entry key="EmptyGraph">
그래프가 비어 있습니다. 정점과 간선를 추가하십시오.
 </entry>
    <entry key="DullGraph">
그래프의 정점 {0,number,integer}에서 정점 {1,number,integer} 사이에 간선가 없습니다. 참조를 시도하기 전에 그래프 add_edge 함수를 호출하여 이 간선를 추가하십시오.
 </entry>
    <entry key="ArgMustBeScalar">
{0,number,integer}번째 인수는 스칼라여야 합니다. 현재는 {1,number,integer}차원 배열로 되어 있습니다.
 </entry>
    <entry key="ArgMustBeNumeric">
{0,number,integer}번째 인수는 숫자형이어야 합니다. 현재는 {1}(으)로 되어 있습니다.
 </entry>
    <entry key="SearchEventRequired">
순회 이벤트를 지정하십시오. 가능한 값으로는 'DiscoverVertex'(정점을 처음 방문할 때)와 'BackEdge'(순환이 발견된 경우) 등이 있습니다. 도움말 문서에서 전체 목록을 참조하십시오. 현재 데이터를 사용할 수 있는 이벤트 목록에 대해서는 이 방문자(Visitor)의 ActiveEvents 속성을 참조하십시오. </entry>
    <entry key="SearchEventMustBeChar">
순회 이벤트 이름에는 문자형 벡터가 와야 하는데 {0} 유형의 객체가 지정되었습니다.
 </entry>
    <entry key="PartPropertyMustBeChar">
파트 속성의 이름에는 문자형 벡터가 와야 하는데 {0} 유형의 객체가 지정되었습니다.
 </entry>
    <entry key="PartPropertyMustBeVector">
파트 속성의 이름에는 1xN 또는 Nx1 문자(문자형 벡터)가 와야 하는데, 처음 두 개 차원이 {1,number,integer}x{2,number,integer}인 {0,number,integer}차원 배열이 지정되었습니다.
 </entry>
    <entry key="InvalidPartReferant">
{0} 유형의 데이터는 그래프 정점 또는 간선를 식별하는 데 사용할 수 없습니다. ID, Vertex, Edge 중 한 객체를 사용하거나 연결된 해당 사용자 데이터를 사용하여 그래프 정점과 간선를 지정하십시오. 
 </entry>
    <entry key="PartIdMustBeNumeric">
간선 식별자와 정점 식별자는 숫자형이어야 하는데 {0} 유형의 데이터가 지정되었습니다.
 </entry>
    <entry key="PartIdMustBeNumericOrChar">
파트 지정자는 숫자형 배열(정점의 경우 Mx1, 간선의 경우 Mx2) 또는 문자형 벡터('Edge' 또는 'Vertex')여야 하는데 {0} 유형의 객체가 지정되었습니다.
 </entry>
    <entry key="PartIdMustBeMatrix">
파트 ID 목록은 행렬(VertexID의 경우 Mx1, EdgeID의 경우 Mx2)이어야 하는데, 처음 두 개 차원이 {1,number,integer}x{2,number,integer}인 {0,number,integer}차원 배열이 지정되었습니다.
 </entry>
    <entry key="InvalidPropertyName">
속성 이름은 'value' 또는 'data'여야 하는데 {0}이(가) 지정되었습니다.
 </entry>
    <entry key="PartTypeMustBeChar">
파트 유형의 이름에는 문자형 벡터가 와야 하는데 {0} 유형의 객체가 지정되었습니다.
 </entry>
    <entry key="InternalNullPredicate">
내부 오류: 정점 또는 간선 술어가 예기치 않게 NULL입니다. 작업이 취소되었습니다.
 </entry>
    <entry key="PredicateMustBeFcn">술어 인수는 부울 값을 반환하는 함수여야 하는데 {0} 유형의 객체가 지정되었습니다.
 </entry>
    <entry key="PredicateArgSizeMismatch">
술어 함수에 {0,number,integer}개의 입력값이 필요한데 파트에는 {1,number,integer}개만 사용 가능합니다. 입력값이 최대 {2,number,integer}개가 되도록 술어를 수정하십시오.
 </entry>
    <entry key="DataAlreadySet">
인수 목록에 MATLAB 구조체형 배열이 너무 많습니다. 인수 목록에는 최대 1개의 MATLAB 구조체형 배열이 있을 수 있는데 이는 사용자 데이터를 설정하는 데 사용됩니다. {0,number,integer}번째 인수는 구조체형 배열이 될 수 없으니 제거하거나 데이터형을 변경하십시오.
 </entry>
    <entry key="ValueAlreadySet">
인수 목록에 MATLAB double형 배열이 너무 많습니다. 인수 목록에는 최대 1개의 MATLAB double형 배열이 있을 수 있는데 이는 값을 설정하는 데 사용됩니다. {0,number,integer}번째 인수는 double형 배열이 될 수 없으니 제거하거나 데이터형을 변경하십시오.
 </entry>
    <entry key="FindIfSearchDataAlreadySet">
인수 유형 불일치: findIf 탐색 데이터가 이미 설정되어 있는데 {0,number,integer}번째 입력 인수가 셀형 배열로 입력되었습니다. findIf에는 하나의 입력값만 셀형 배열일 수 있습니다.
 </entry>
    <entry key="FindIfPartAlreadySet">
인수 유형 불일치: findIf 파트 유형이 이미 설정되어 있는데 {0,number,integer}번째 입력 인수가 문자형 벡터로 입력되었습니다. findIf에는 하나의 입력값만 문자형 벡터일 수 있으며, 그 값은 'edge' 또는 'vertex'여야 합니다.
 </entry>
    <entry key="FindIfCountMustBeScalar">
인수 유형 불일치: {0,number,integer}번째 입력 인수가 스칼라가 아닌 숫자형입니다({1,number,integer}개의 요소를 가짐). FindIf에는 하나의 입력값만 숫자형일 수 있으며, 해당 값은 반환할 최대 파트 개수를 명시하는 스칼라여야 합니다.
 </entry>
    <entry key="FindIfCountAlreadySet">
인수 유형 불일치: findIf 반환 개수가 이미 설정되어 있는데 {0,number,integer}번째 입력 인수가 숫자형으로 입력되었습니다. findIf에는 하나의 입력값만 숫자형일 수 있으며, 해당 값은 반환할 최대 파트 개수를 명시해야 합니다.
 </entry>
    <entry key="FindIfCountOutOfBounds">
찾을 파트 개수는 {0,number,integer}과(와) {1,number,integer} 사이여야 하는데 {2,number,integer}개로 요청되었습니다.
 </entry>
    <entry key="InvalidPartType">
그래프 파트 유형은 'vertex' 또는 'edge'여야 하는데 "{0}"이(가) 지정되었습니다.
 </entry>
    <entry key="SourceAndTargetSizeMismatch">
시작 정점 목록과 종료 정점 목록은 스칼라 또는 벡터(1xN 또는 Mx1)일 수 있습니다. 둘 다 스칼라가 아닐 경우에는 정확하게 동일한 개수의 요소를 가져야 하는데 현재 동일하지 않습니다. length(start): {0,number,integer}. length(finish): {1,number,integer}.
 </entry>
    <entry key="ValueAndDataSizeMismatch">
값 배열과 데이터 배열은 스칼라 또는 벡터(1xN 또는 Mx1)일 수 있습니다. 둘 다 스칼라가 아닐 경우에는 크기가 정확하게 동일해야 하는데 현재 동일하지 않습니다. length(values): {0,number,integer}. length(data): {1,number,integer}.
 </entry>
    <entry key="DataMustBeStructVector">
새 정점의 사용자 데이터에는 1xN 또는 Nx1 구조체형 배열이 와야 하는데, 처음 두 개 차원이 {2,number,integer}x{3,number,integer}인 {1} 유형의 {0,number,integer}차원 배열이 지정되었습니다.
 </entry>
    <entry key="ValuesMustBeDoubleVector">
새 정점의 값에는 1xN 또는 Nx1 double형 벡터가 와야 하는데, 처음 두 개 차원이 {2,number,integer}x{3,number,integer}인 {1} 유형의 {0,number,integer}차원 배열이 지정되었습니다.
 </entry>
    <entry key="PartTypeMustBeVector">
파트 유형의 이름에는 1xN 또는 Nx1 문자(문자형 벡터)가 와야 하는데, 처음 두 개 차원이 {1,number,integer}x{2,number,integer}인 {0,number,integer}차원 배열이 지정되었습니다.
 </entry>
    <entry key="SearchEventMustBeVector">
순회 이벤트 이름에는 1xN 또는 Nx1 문자형 벡터가 와야 하는데, 처음 두 개 차원이 {1,number,integer}x{2,number,integer}인 {0,number,integer}차원 배열이 지정되었습니다.
 </entry>
    <entry key="NumericMustBeNumeric">
숫자가 와야 하는데 {0} 유형의 객체가 지정되었습니다.
 </entry>
    <entry key="LogicalMustBeLogical">
논리형(부울)이 와야 하는데 {0} 유형의 객체가 지정되었습니다.
 </entry>
    <entry key="LogicalMustBeScalar">
논리형 스칼라(부울)가 와야 하는데 {0,number,integer}개 요소를 가진 배열이 지정되었습니다.
 </entry>
    <entry key="NumericMustBeScalar">
스칼라 숫자가 와야 하는데 {0,number,integer}개 요소를 가진 숫자형 배열이 지정되었습니다.
 </entry>
    <entry key="StringMustBeString">
문자형 벡터가 와야 하는데 {0} 유형의 객체가 지정되었습니다.
 </entry>
    <entry key="StringMustBeVector">
1xN 문자형 벡터나 Nx1 문자형 벡터가 와야 하는데, 처음 두 개 차원이 {1,number,integer}x{2,number,integer}인 {0,number,integer}차원 배열이 지정되었습니다.
 </entry>
    <entry key="ArgMustBeStruct">
{0,number,integer}번째 인수는 구조체형이어야 합니다.
 </entry>
    <entry key="UnexpectedArgType">
{1}의 {0,number,integer}번째 인수는 {2}이어야 하는데 {3}(으)로 지정되어 있습니다.
 </entry>
    <entry key="InvalidArgType">
{0,number,integer}번째 인수에서 유형이 일치하지 않습니다. 이 함수에는 {1} 유형의 인수가 허용되지 않습니다.
 </entry>
    <entry key="ArgMustBeStructOrNumeric">
{0,number,integer}번째 인수: 데이터를 지정하려면 구조체형 배열을, 값을 설정하려면 double형 배열을 사용하십시오. 잘못된 유형입니다. {1}.
 </entry>
    <entry key="InvalidVisitEvent">
{1} 그래프 순회에 해당 이벤트 {0}이(가) 없습니다. 유효한 이벤트를 지정하십시오.
 </entry>
    <entry key="VisitorRequiresGraph">
그래프를 방문하기 위해 {0}을(를) 전송할 경우 해당 그래프를 지정해야 합니다. 두 개의 인수(방문자(Visitor) 객체와 그래프)를 사용하여 visit()을 호출하십시오. 예: values = visit(visitor, graph).
 </entry>
    <entry key="VerticesRequireVisit">
방문자(Visitor)를 보내 그래프를 방문할 때까지는 그동안 방문자가 방문해 온 정점을 요청할 수 없습니다. 이 {0}은(는) 그래프를 방문한 적이 없습니다. 그래프 g와 방문자 v가 있을 경우 visit(v, g)를 호출하여 그래프 순회를 시작하십시오.
 </entry>
    <entry key="ValuesRequireVisit">
방문자(Visitor)를 보내 그래프를 방문할 때까지는 그래프 순회 중에 수집된 값을 방문자에게 요청할 수 없습니다. 이 {0}은(는) 그래프를 방문한 적이 없습니다. 그래프 g와 방문자 v가 있을 경우 visit(v, g)를 호출하여 그래프 순회를 시작하십시오.
 </entry>
    <entry key="VisitorRequiresCallbackStruct">
{0} 방문자(Visitor)를 생성할 때 콜백으로 구성된 배열을 지정할 수 있습니다. 방문자는 그래프 순회 중 사전 정의된 횟수만큼 이러한 콜백을 호출하게 됩니다.  콜백 배열은 'event', 'callback', 'state' 세 필드가 포함된 구조체여야 합니다. 'state'만 비어 있을 수 있습니다.
 </entry>
    <entry key="WrongNumberFcnArgs">
함수 {0}에는 {1}개의 인수가 필요한데 {2,number,integer}개가 지정되었습니다.
 </entry>
    <entry key="WrongNumberExeArgs">
프로그램 {0}에는 {1,number,integer}개의 인수가 필요한데 {2,number,integer}개가 지정되었습니다.
 </entry>
    <entry key="WrongNumberConstructorArgs">
{0}의 생성자에는 {1}개의 인수가 필요한데 {2,number,integer}개가 지정되었습니다.
 </entry>
    <entry key="NoDirection">
입력값에서 {0}에 대한 그래프 간선 방향(directed, undirected)을 결정할 수 없습니다. 유방향 그래프의 경우 ('directed', true), 무방향 그래프의 경우 ('directed', false)를 지정하십시오.
 </entry>
    <entry key="BadInputs">
{0}에 대한 입력 인수 목록이 유효하지 않습니다.
 </entry>
    <entry key="NotANumericType">
숫자 유형이 필요한 작업에 {0} 유형의 데이터가 지정되었습니다.
 </entry>
    <entry key="MissingVertexEdgeData">
{1,number,integer}개의 인수로 {0}이(가) 호출될 때는 정점들이 지정되거나 간선로 구성된 벡터가 지정되어야 하는데 인수 목록에서 둘 다 찾을 수 없습니다.
 </entry>
    <entry key="MissingUserData">
{1,number,integer}개의 인수로 {0}이(가) 호출될 때 그중 하나는 사용자 데이터를 지정하는 MATLAB 구조체여야 하는데, 인수 목록에 어떤 MATLAB 구조체도 포함되어 있지 않습니다.
 </entry>
    <entry key="MissingCallbackState">
상태 변화가 지속되도록 하기 위해 그래프 {0} 방문자(Visitor) 콜백은 상태 인수를 반환해야 합니다. 콜백의 형태는 [value, state] = @(part, graph, state)여야 합니다. (part는 콜백의 유형에 따라 vertex 또는 edge가 될 수 있습니다.)
 </entry>
    <entry key="NoCallbackData">
{0} 그래프 순회 콜백 {1}에 사용할 수 있는 데이터가 없습니다. 이 이벤트에 대한 콜백이 지정되지 않았을 수 있습니다.
 </entry>
    <entry key="GraphTooBigForTC">
메모리가 부족하여 {1,number,integer}개의 정점과 {2,number,integer}개의 간선가 있는 그래프의 {0,number,integer}조각 전이적 폐포(Transitive Closure)를 계산할 수 없습니다. 그래프를 더 많은 조각으로 분할해 보십시오.
 </entry>
    <entry key="CannotGrowResult">메모리가 부족하여 결과 벡터가 {0,number,integer}개 요소로 확장될 수 없습니다. 작업이 취소되었습니다.
 </entry>
    <entry key="CannotCreateGraphData">
메모리가 부족하여 {0,number,integer}개의 정점과 {1,number,integer}개의 간선가 있는 그래프의 그래프 데이터 배열을 생성할 수 없습니다. {2} 작업이 취소되었습니다.       
 </entry>
    <entry key="CannotCreateVertexData">
메모리가 부족하여 {0,number,integer}개의 정점에 대한 데이터 배열을 생성할 수 없습니다. 정점 #{1,number,integer}, 필드: {2}을(를) 처리하는 동안 실패했습니다.)
 </entry>
    <entry key="CannotCreateEdgeData">
메모리가 부족하여 {0,number,integer}개의 간선에 대한 데이터 배열을 생성할 수 없습니다. 간선 #{1,number,integer}, 필드: {2}을(를) 처리하는 동안 실패했습니다.)
 </entry>
    <entry key="EdgeTooLarge">
{0,number,integer}바이트의 간선 크기는 너무 커서 메모리({1,number,integer}바이트)에 들어가지 않습니다. 더 작은 크기를 선택하십시오. 보통 간선 크기는 64바이트 또는 128바이트입니다(두 정점의 크기임).
 </entry>
    <entry key="FailedToRetrieveSerializeData">
{0} 데이터를 찾을 수 없습니다. 그래프를 직렬화(저장)할 수 없습니다.
 </entry>
    <entry key="VertexInitRequiresEmptyGraph">
빈 그래프의 정점 데이터만 설정할 수 있습니다. 이 그래프에는 이미 {0,number,integer}개의 정점이 있습니다.
 </entry>
    <entry key="InitDataEmpty">
입력 구조체가 비어 있거나 NULL이어서 {0} 데이터를 초기화할 수 없습니다.
 </entry>
    <entry key="InitDataMustBeStruct">
{0} 초기화 데이터는 MATLAB 구조체여야 하는데 {1}(으)로 지정되었습니다.
 </entry>
    <entry key="InitDataMissingField">
{0} 데이터를 초기화할 수 없습니다. 입력 구조체에 필수 필드 {1}이(가) 누락되었습니다.
 </entry>
    <entry key="InitMatrixWrongDims">
그래프의 {0} 데이터를 초기화할 수 없습니다. {1} 행렬의 차원 수가 올바르지 않습니다. {2,number,integer}이어야 하는데 {3,number,integer}(으)로 되어 있습니다.
 </entry>
    <entry key="InitMatrixWrongShape">
그래프의 {0} 데이터를 초기화할 수 없습니다. {1} 행렬의 모양이 올바르지 않습니다. {2}x{3}이어야 하는데 {4,number,integer}x{5,number,integer}(으)로 되어 있습니다.
 </entry>
    <entry key="InitDataWrongSize">
그래프의 {0} 데이터를 초기화할 수 없습니다. {1} 목록의 크기가 올바르지 않습니다. {2,number,integer}개 요소가 있어야 하는데 {3,number,integer}개가 발견되었습니다.
 </entry>
    <entry key="NoSuchStructField">
존재하지 않는 구조체 필드 ''{0}''을(를) 참조하려고 했습니다.
 </entry>
    <entry key="InitDataBadStructure">
그래프의 {0} 데이터를 초기화할 수 없습니다. 입력 구조체에 {1,number,integer}개의 필드가 있어야 하는데 지정된 구조체에는 {2,number,integer}개의 필드가 있습니다.
 </entry>
    <entry key="EdgeInitRequiresUnconnectedGraph">
연결되지 않은 그래프의 간선 데이터만 설정할 수 있습니다. 이 그래프에는 이미 {0,number,integer}개의 간선가 있습니다.
 </entry>
    <entry key="EdgeInitRequiresVertices">
정점이 없는 그래프의 간선 데이터는 설정할 수 없습니다. 간선 데이터를 추가하기 전에 setVertexData를 호출하는 등의 방식으로 정점을 추가하십시오.
 </entry>
    <entry key="FieldTypeWrong">
{0} 구조체의 {1} 필드가 잘못된 유형입니다. 필요한 유형: {2}. 발견된 유형: {4,number,integer} {3}{5}.
 </entry>
    <entry key="UndirectedTopoSort">
무방향 그래프는 위상을 정렬할 수 없습니다.
 </entry>
    <entry key="InternalZeroEdgesToRead">
내부 오류: 그래프 간선 목록 파일 {0}에서 읽을 간선가 없습니다. 무한 루프가 방지됩니다. 버퍼 크기: {1,number,integer}, 간선 바이트: {2,number,integer}, 남은 간선: {3,number,integer}.
 </entry>
    <entry key="InternalBadFcnName">
내부 오류: 함수 이름 {0}에서 함수 핸들을 만들 수 없습니다.
 </entry>
    <entry key="InternalPairTypeMismatch">
내부 오류: 상이한 유형의 항목에서 쌍을 생성하려고 했습니다. 이러한 시도는 항상 실패하며 허용되지 않습니다.
 </entry>
    <entry key="InternalBadScalarIteratorType">
내부 오류: 스칼라 배열 리더(Reader)는 {0} 유형의 배열을 처리할 수 없습니다.
 </entry>
    <entry key="InternalBadIteratorType">
내부 오류: 배열 유형 {1}에서 C++ 값 유형 {0}을(를) 가진 이터레이터(Iterator)를 생성하려고 했습니다. 이러한 유형은 호환되지 않습니다.
 </entry>
    <entry key="InternalNoCallback">
내부 오류: 그래프 방문자(Visitor) 콜백 함수가 NULL입니다.
 </entry>
    <entry key="InternalBadListenerType">
내부 오류: 생성자가 잘못된 유형의 리스너 객체를 받았기 때문에 그래프 순회의 함수 연산자(Functor)를 생성할 수 없습니다.
 </entry>
    <entry key="InternalBadVisitorValueSize">
내부 오류: 그래프 방문자(Visitor) 값 셀형 배열의 크기가 잘못되었습니다. 요소가 {0,number,integer}개여야 하는데 {1,number,integer}(으)로 되어 있습니다.
 </entry>
    <entry key="InternalBadVertexListSize">
내부 오류: 정점 목록의 크기가 잘못되었습니다. 요소가 {0,number,integer}개여야 하는데 {1,number,integer}(으)로 되어 있습니다.
 </entry>
    <entry key="InternalPartitionBreach">
내부 오류: 연결성분의 무결성이 훼손되었습니다. {1,number,integer}번째 성분의 간선 소스 정점 {0,number,integer}이(가) {3,number,integer}번째 성분의 타깃 정점 {2,number,integer}에 연결되어 있습니다. 연결성분의 경계 간선이 겹쳐서는 안 됩니다.
 </entry>
    <entry key="InternalUnmappedVertex">
내부 오류: {1} 정점 맵에 정점 {0,number,integer}이(가) 있어야 합니다.
 </entry>
    <entry key="InternalBadEdgeListSize">
내부 오류: 간선 목록의 크기가 잘못되었습니다. 요소가 {0,number,integer}개여야 하는데 {1,number,integer}(으)로 되어 있습니다.
 </entry>
    <entry key="InternalBadEventNameSize">
내부 오류: 이벤트 이름 배열의 크기가 잘못되었습니다. 요소가 {0,number,integer}개여야 하는데 {1,number,integer}(으)로 되어 있습니다.
 </entry>
    <entry key="InternalNullPtr">
내부 오류: 예기치 않은 NULL 포인터입니다. 함수: {0}. 변수: {1}.
 </entry>
    <entry key="InternalNoFactoryFcn">
내부 오류: 함수 factory는 {1}과(와) {2}에서 {0}을(를) 만들 수 없습니다. 비트가 부족한 것일 수 있습니다.
 </entry>
    <entry key="InternalEmptyProduct2">
내부 오류: {1}과(와) {2}에서 {0}을(를) 생성해야 하는 함수 factory가 아무것도 생성하지 않았습니다. 
 </entry>
    <entry key="InternalBadVertexID">
내부 오류: 예기치 않은 정점 ID임: {0,number,integer}. 필요한 ID: {1,number,integer}.
 </entry>
    <entry key="InternalNoFields">
내부 오류: 비구조체형 배열의 필드를 참조하려고 했습니다. 입력 배열의 유형: {0}.
 </entry>
    <entry key="CannotOpenFile">
파일 "{0}"을(를) 열 수 없습니다. 파일이 존재하는지 그리고 해당 파일을 읽을 수 있는 권한이 있는지 확인하십시오. 이유: {1}.
 </entry>
    <entry key="CannotCreateFile">
파일 "{0}"을(를) 생성할 수 없습니다. 경로의 모든 폴더가 존재하는지, 지정한 디렉터리에 대한 쓰기 권한이 있는지, 파일이 존재하는 경우 해당 파일을 덮어쓸 수 있는지 확인하십시오. 이유: {1}.
 </entry>
    <entry key="CannotWriteFile">
파일 "{0}"에 쓸 수 없습니다. 파일이 존재하는지, 해당 파일에 대한 쓰기 권한이 있는지, 디스크가 가득 차 있는지 확인하십시오. 이유: {1}.
 </entry>
    <entry key="CannotCloseFile">
파일 "{0}"을(를) 닫을 수 없습니다. 파일이 존재하는지, 해당 파일에 대한 쓰기 권한이 있는지, 디스크가 가득 차 있는지 확인하십시오. 이유: {1}.
 </entry>
    <entry key="CannotReadFileNBytes">
파일 "{1}"에서 {0,number,integer}바이트를 읽는 중 오류가 발생했습니다. {2,number,integer}바이트를 읽었습니다. 파일이 존재하는지 그리고 해당 파일에 대한 읽기 권한이 있는지 확인하십시오. 이유: {3}.
 </entry>
    <entry key="CannotWriteFileNBytes">
파일 "{1}"에 {0,number,integer}바이트를 쓰는 중 오류가 발생했습니다. {2,number,integer}바이트를 썼습니다. 파일이 존재하는지 그리고 해당 파일에 대한 쓰기 권한이 있는지 확인하십시오. 이유: {3}.
 </entry>
    <entry key="CannotReadFile">
파일 "{0}"에서 읽을 수 없습니다. 파일이 존재하는지 그리고 해당 파일에 대한 읽기 권한이 있는지 확인하십시오. 이유: {1}.
 </entry>
  </message>
</rsccat>
