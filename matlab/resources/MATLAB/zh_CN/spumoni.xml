<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="zh_CN" product="MATLAB" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="yes">  是。\n</entry>
    <entry key="no">  否。\n</entry>
    <entry key="isTriangularQ">sp\\: A 是否为三角矩阵?</entry>
    <entry key="doTriangularSolve">sp\\: 执行三角矩阵求解。\n</entry>
    <entry key="isMorallyTriangularQ">sp\\: A 是否基本为三角矩阵?</entry>
    <entry key="permuteAndSolve">sp\\: 置换并求解。\n</entry>
    <entry key="isCholeskyCandidateQ">sp\\: A 是否可以进行乔列斯基分解(对称、正实数或负实数对角矩阵)?</entry>
    <entry key="notPositiveDefinite">sp\\: A 不是正定矩阵。\n</entry>
    <entry key="useOriginalLU">sp\\: 原始 LU 因子，并求两个三角方程组的解。\n</entry>
    <entry key="columnMinimumDegree">sp\\: 列最小度。\n</entry>
    <entry key="triangularSolveRealloc">sp\\: sptsolve 中的 sprealloc: {0} {1} {2} {3}</entry>
    <entry key="noTridiagonalFailedPivot"> 否，\n 三对角矩阵求解在主元 {0} 处失败。\n</entry>
    <entry key="isBandedSolveSuccessfulQ">sp\\: LAPACK 的带状矩阵求解器是否成功?</entry>
    <entry key="bandwidth">sp\\: 带宽 = {0}+1+{1}。\n</entry>
    <entry key="isBandDenseEnoughOrTridiagonalQ">sp\\: 是否带密度({0}) &gt; bandden ({1}) 以尝试带状矩阵求解器，\n或者矩阵是否为三对角矩阵?</entry>
    <entry key="isTridiagonalQ">sp\\: A 是否为三对角矩阵?</entry>
    <entry key="tryUsingTridiagonalNoPivotQ">sp\\: 是否可在没有主元消去的情况下对实数三对角矩阵 A 求解?</entry>
    <entry key="doTridiagonalSolve">sp\\: 用主元消去对三对角矩阵求解。\n</entry>
    <entry key="isDiagonalQ">sp\\: A 是否为对角矩阵? </entry>
    <entry key="doDiagonalSolve">sp\\: 执行对角矩阵求解。\n</entry>
    <entry key="isCHOLMODsymbolicAutoReorderSuccessQ">sp\\: CHOLMOD 的符号乔列斯基分解(自动重新排序)是否成功?</entry>
    <entry key="isCHOLMODsymbolicNoReorderSuccessQ">sp\\: CHOLMOD 的符号乔列斯基分解(不重新排序)是否成功?</entry>
    <entry key="isCHOLMODnumericSuccessQ">sp\\: CHOLMOD 的数值乔列斯基分解是否成功?</entry>
    <entry key="isCHOLMODsolveSuccessQ">sp\\: CHOLMOD 的三角矩阵求解是否成功?</entry>
    <entry key="useUMFPACKnoReorder">sp\\: 使用 Unsymmetric MultiFrontal PACKage(不重新排序)。</entry>
    <entry key="successUMFPACKfactorize">sp\\: UMFPACK 的分解成功。\n</entry>
    <entry key="successUMFPACKsolve">sp\\: UMFPACK 的求解成功。\n</entry>
    <entry key="noSuccessUMFPACK">sp\\: UMFPACK 未成功。\n</entry>
    <entry key="useSPQR">sp\\: 通过 SuiteSparseQR 的稀疏 QR 求解。\n</entry>
    <entry key="realSymmetricTryMA57">sp\\: 但 A 是实数型对称的；请尝试 MA57。\n</entry>
    <entry key="useUMFPACKwithReorder">sp\\: 使用 Unsymmetric MultiFrontal PACKage(自动重新排序)。\n</entry>
    <entry key="redoUMFPACK">sp\\: 但是，UMFPACK 可能未能生成正确的分解，\n 这可能是因为主元容差太严格或问题\n 是病态所致。\n</entry>
    <entry key="umfpackTolerances">sp\\: 这些容差是:\n\t主元容差: {0}\n\t对角主元容差: {1}\n我们将重新对矩阵进行分解，但使用标准的部分主元消去法。\n</entry>
    <entry key="refactorStandardPivoting">我们将重新对矩阵进行分解，但会使用标准的部分主元消去法。\n</entry>
    <entry key="spu57">CHOLMOD 的符号乔列斯基分解。\n</entry>
    <entry key="spu58">CHOLMOD 的数值乔列斯基分解。\n</entry>
    <entry key="spu59">从 CHOLMOD 提取 L'。\n</entry>
    <entry key="spu60">从 CHOLMOD 提取置换矩阵。\n</entry>
    <entry key="spu61">无穷矩阵(列 {0}):</entry>
    <entry key="spu62"> 对角线条元素 {0} &lt; {1} 容差\n</entry>
    <entry key="spu63">预测的非零值: {0}\n</entry>
    <entry key="spu64">预测的每秒浮点运算次数: {0}\n</entry>
    <entry key="spu65">预测的高度: {0}\n</entry>
    <entry key="spu66">预测的前端大小: {0}\n</entry>
    <entry key="spu67">从 SuiteSparseQR 提取 c。\n</entry>
    <entry key="spu68">通过 SuiteSparseQR 计算 QR 分解。\n</entry>
    <entry key="spu69">从 SuiteSparseQR 提取 Q。\n</entry>
    <entry key="spu70">从 SuiteSparseQR 提取 permutation。\n</entry>
    <entry key="spu71">从 SuiteSparseQR 提取 R。\n</entry>
    <entry key="spu72">spmlrcm: 根 = {0}\n</entry>
    <entry key="spu73">spmlrcm: 组件大小 = {0}，级别 = {1}\n</entry>
    <entry key="spu74">spmlrcm: 这是一个错误，维度为 n = {0} </entry>
    <entry key="spu75">但组件大小会添加到 num = {0}\n</entry>
    <entry key="spu76">组件: {0}\n</entry>
    <entry key="spu77">带宽: {0}\n</entry>
    <entry key="spu78">配置文件: {0}\n</entry>
    <entry key="spu79">伪直径: {0}\n</entry>
    <entry key="spu80">rootls: {0} 级别\n</entry>
    <entry key="spu81">colmmd: 保留 {0} 个稠密行。\n</entry>
    <entry key="spu82">阶段 0:  </entry>
    <entry key="spu84">阶段 {0}:  </entry>
    <entry key="spu87">已缩减 </entry>
    <entry key="spu89">已消除 </entry>
    <entry key="spu90">阈值 {0}</entry>
    <entry key="spu91">已选定 </entry>
    <entry key="spu94">\t在 A'*A 中使用精确度；\n</entry>
    <entry key="spu95">\t在 A'*A 中使用近似度；\n</entry>
    <entry key="spu96">\t从初始起并且每 {0} 个阶段进行超级节点合并；\n</entry>
    <entry key="spu97">\t仅在初始时进行超级节点合并；\n</entry>
    <entry key="spu98">\t每 {0} 个阶段后进行超级节点合并；\n</entry>
    <entry key="spu99">\t无超级节点合并；\n</entry>
    <entry key="spu100">\t从初始起并且每 {0} 个阶段执行行减少操作；\n</entry>
    <entry key="spu101">\t仅在初始时执行行减少操作；\n</entry>
    <entry key="spu102">\t每 {0} 个阶段后执行行减少操作；\n</entry>
    <entry key="spu103">\t无行减少；\n</entry>
    <entry key="spu104">\t在 colmmd 中保留稠密度至少为 {0} 的行；\n</entry>
    <entry key="spu105">\tcolmmd 中不保留任何行；\n</entry>
    <entry key="spu107">mmd: {0} 阶段。\n</entry>
    <entry key="spu108">调降容差: {0}\n</entry>
    <entry key="spu109">替换 U 的零对角线: </entry>
    <entry key="spu110">修正不完全 LU: </entry>
    <entry key="spu111">基准阈值: {0}\n</entry>
    <entry key="spu112">lu(V) 中的 sprealloc: {0} {1} {2}</entry>
    <entry key="spu114">lu(L) 中的 sprealloc: {0} {1} {2}</entry>
    <entry key="spu115">lu(U) 中的 sprealloc: {0} {1} {2}</entry>
    <entry key="spu116">删减的 nzs: {0}\n</entry>
    <entry key="spu117">L 非零值: {0}\n</entry>
    <entry key="spu118">U 非零值: {0}\n</entry>
    <entry key="spu119">spchol 中的错误: 分析操作未分配足够的存储空间\n</entry>
    <entry key="redoBackwardError">sp\\: 但是，UMFPACK 在求解时可能未满足指定的后向误差，\n这可能是因为主元容差太严格或问题\n是病态所致。\n</entry>
    <entry key="umfpackBackwardErrors">sp\\: 实现的后向误差是:\n\t稀疏后向误差 omega1: {0}\n\t稀疏后向误差 omega2: {1}\n</entry>
    <entry key="spu83">\n</entry>
    <entry key="spu85">amalgamated </entry>
    <entry key="spu86"> {0}  </entry>
    <entry key="spu93">mmd:  threshold = {0} * mindegree + {1};\n</entry>
    <entry key="spu113"> {0}\n</entry>
  </message>
</rsccat>
