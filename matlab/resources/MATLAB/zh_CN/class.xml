<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="zh_CN" product="MATLAB" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="AmbiguousEnumValue">''{0}'' 名称具有多义性。</entry>
    <entry key="AmbiguousEventException">''{1}'' 类中的 ''{0}'' 事件名称具有多义性。</entry>
    <entry key="AmbiguousNameException">名称具有多义性。</entry>
    <entry key="AmbiguousPropertyException">''{1}'' 类中的 ''{0}'' 属性名称具有多义性。</entry>
    <entry key="ApplicationRedefined">已存在名为 ''{0}'' 的应用程序。</entry>
    <entry key="ClassRedefined">已存在名为 ''{0}'' 的类。</entry>
    <entry key="ConstructionArgument">''{0}'' 类的构造参数无效。</entry>
    <entry key="ConstructorMissingArg">{0} 构造函数需要 {1}。</entry>
    <entry key="DatabaseRedefined">已存在名为 ''{0}'' 的数据库。</entry>
    <entry key="DefaultAccess">无法设置 ''{0}'' 属性的默认值。</entry>
    <entry key="EmptyParamCell">参数名称的元胞数组中不允许使用空元胞。</entry>
    <entry key="FactoryValueUndefined">''{0}'' 属性没有出厂默认值。</entry>
    <entry key="IndexRange">索引({0,number,integer})超出 ''{1}'' 属性的范围。</entry>
    <entry key="IndexedAccess">无法为对 ''{0}'' 属性值进行索引。</entry>
    <entry key="InterfaceLocked">尝试写入已锁定对象。</entry>
    <entry key="InvalidArg">{0} 参数必须为 {1}。</entry>
    <entry key="InvalidEvent">''{1}'' 类中没有 ''{0}'' 事件。</entry>
    <entry key="InvalidEnumValue">不存在名为 ''{0}'' 的枚举值。</entry>
    <entry key="MustBeEnumeration">输入参数必须为枚举成员或枚举类名。</entry>
    <entry key="InvalidTraversal">只有 DEPTH_ONLY 遍历才允许向后遍历。</entry>
    <entry key="MatlabConversion">''{0}'' 类型不支持从 MATLAB 数组进行转换。</entry>
    <entry key="NoSuchElement">没有此类元素</entry>
    <entry key="NonCurrentCommit">只能提交当前事务处理。</entry>
    <entry key="OverrideTypeNotFound">找不到数据类型基类: {0}。</entry>
    <entry key="ReadOnlyClass">无法修改 ''{0}'' 类(可能存在该类的实例)。</entry>
    <entry key="ReservedProperty">{1} 类已保留 ''{0}'' 属性名称。</entry>
    <entry key="StructSet">对象必须均为同一类的实例。</entry>
    <entry key="SetOpNoConstruct">无法实例化 handle.SetOp</entry>
    <entry key="InvalidEnumString">枚举的字符向量无效</entry>
    <entry key="SubPropNoConstruct">无法实例化子属性。</entry>
    <entry key="UnknownProp">未知属性。</entry>
    <entry key="PackageNeedsName">schema.package 构造函数需要一个名称。</entry>
    <entry key="ClassNeedsName">schema.class 构造函数需要一个命名空间和一个类名。</entry>
    <entry key="InvalidPackageHandle">命名空间句柄无效。</entry>
    <entry key="EmptyClass">类名不能为空。</entry>
    <entry key="InvalidSuperclass">超类句柄无效。</entry>
    <entry key="TooManyClassArgs">schema.class 构造函数的参数太多。</entry>
    <entry key="EmptyEnum">枚举的字符向量不能为空。</entry>
    <entry key="NonUniqueEnum">枚举的字符向量必须唯一(不区分大小写)。</entry>
    <entry key="UnknownEvent">未知事件。</entry>
    <entry key="EventNeedsName">schema.event 构造函数需要一个类和一个名称。</entry>
    <entry key="InvalidEventParent">父类无效。</entry>
    <entry key="UnknownMethod">未知方法。</entry>
    <entry key="MethodNeedsName">必须指定方法名称。</entry>
    <entry key="InvalidMethodParent">父类无效。</entry>
    <entry key="InvalidMethodOption">选项无效。</entry>
    <entry key="UnknownProperty">未知属性。</entry>
    <entry key="PropConstructorArgs">schema.prop 构造函数需要一个父级、一个名称和一个类型。</entry>
    <entry key="PropInvalidParentClass">父类或对象无效。</entry>
    <entry key="PropInvalidDataType">数据类型无效。</entry>
    <entry key="EmptyPropName">属性名称不能为空。</entry>
    <entry key="PropNameInUse">属性名称已被此类或其某个超类使用。</entry>
    <entry key="SaveobjInvalidObj">传递给 saveobj 方法的类型对象无效。</entry>
    <entry key="UnknownType">未知类型。</entry>
    <entry key="CannotConstruct">无法实例化指定的类。</entry>
    <entry key="InvalidEventName">事件名称无效。</entry>
    <entry key="ConnectRightEmpty">对象不能连接到没有内容的右侧。</entry>
    <entry key="ConnectLeftEmpty">对象不能连接到没有内容的左侧。</entry>
    <entry key="ConnectRequireParent">当连接到左侧或右侧时，被连接的对象必须具有一个父级。</entry>
    <entry key="CannotCopyObj">无法复制对象。</entry>
    <entry key="ModifyGet">无法修改此属性的 GetFunction。</entry>
    <entry key="ModifySet">无法修改此属性的 SetFunction。</entry>
    <entry key="MustCommitBeforeRedo">必须先提交事务处理，然后才能重新执行该事务处理。</entry>
    <entry key="MustCommitBeforeUndo">必须先提交事务处理，然后才能撤消该事务处理。</entry>
    <entry key="GetDenied">不允许获取 {1} 的 ''{0}'' 属性。</entry>
    <entry key="SetDenied">不允许更改 {1} 的 ''{0}'' 属性。</entry>
    <entry key="IllegalPropertyName">属性名称必须以字母开头，并且由字母、数字和下划线组成。</entry>
    <entry key="WrongObjectType">需要属于以下类的对象: {0}。</entry>
    <entry key="ClassInstancesExist">已存在 {0} 类的对象 - 未清除此类或其任何超类</entry>
    <entry key="errorParsingClass">解析类 {0}.{1} 时出错:\n{2}\n</entry>
    <entry key="IntOutOfRange">值超出范围或不是整数</entry>
    <entry key="StringExpected">需要字符串或字符向量。</entry>
    <entry key="GetJavaInterfacesMethodStringReturnExpected">类 ''{0}'' 的 getJavaInterfaces 方法必须返回字符串数组</entry>
    <entry key="IncompatibleJavaClass">对象属于不兼容的 Java 类。</entry>
    <entry key="ExpectedNumericVector">需要数值向量。</entry>
    <entry key="ExpectedNumericMatrix">需要数值矩阵。</entry>
    <entry key="ExpectedString">需要字符向量、字符串向量或 cellstr 向量。</entry>
    <entry key="CallOnInvalidObj">试图对无效对象调用方法。</entry>
    <entry key="JavaConstructorErr">调用 Java 构造函数时出错。</entry>
    <entry key="NoNewClassesInJavahandle">无法向 javahandle 包添加新类。</entry>
    <entry key="CannotConvertFromJava">无法为给定 java 对象创建句柄对象。</entry>
    <entry key="MustBeCallback">值必须为字符向量、函数句柄，或者为包含字符向量或函数句柄的元胞数组。</entry>
    <entry key="ListenerNeedsName">handle.listener 构造函数需要一个名称。</entry>
    <entry key="WrongNumberOfConstructorArgs">构造函数的参数数目不正确。</entry>
    <entry key="JavaAdapterError">无法初始化句柄对象的 Java 适配器接口。</entry>
    <entry key="ConstructorError">类构造函数失败或找不到类。</entry>
    <entry key="NoBaseType">不存在给定的基类型。</entry>
    <entry key="BaseTypeMustConvert">基类型必须支持在 MATLAB 数组之间来回转换。</entry>
    <entry key="UserTypeRequireFunctionHandle">第三个参数必须为函数句柄。</entry>
    <entry key="WrongJavaClass">Java 类错误。</entry>
    <entry key="MustBeScalar">参数必须为标量。</entry>
    <entry key="MustBeReal">参数必须为实数。</entry>
    <entry key="MustBeNumber">参数必须为数字。</entry>
    <entry key="MustBeFinite">参数必须为有限值。</entry>
    <entry key="MustBeNumeric">数组必须为数值或逻辑值。</entry>
    <entry key="MustBeRGB">RGB 向量包含 NaN，或者元素超出 0.0 &lt;= 值 &lt;= 1.0 这一范围</entry>
    <entry key="MustBeNonEmptyString">参数必须为非空字符向量。</entry>
    <entry key="MustBe0or1">参数必须为 0 或 1。</entry>
    <entry key="MustBeChar">参数必须为字符。</entry>
    <entry key="GetMustReturnValue">GetFunction 必须返回一个值。</entry>
    <entry key="InvalidGetFcn">GetFunction 必须为有效函数句柄。</entry>
    <entry key="SetMustReturnValue">SetFunction 必须返回一个值。</entry>
    <entry key="InvalidSetFcn">SetFunction 必须为有效函数句柄。</entry>
    <entry key="MustBeVector">矩阵必须为列向量或行向量。</entry>
    <entry key="MustBeCellStrings">字符向量元胞数组只能包含字符向量和数值矩阵。</entry>
    <entry key="MustBeCellStringsParameter">参数必须为字符向量元胞数组。</entry>
    <entry key="InvalidCellStrings">字符向量元胞数组无效。</entry>
    <entry key="MustBe1xN">矩阵必须为 1xN。</entry>
    <entry key="MustBeOnOff">参数必须为 ''on'' 或 ''off''。</entry>
    <entry key="MustBeOnOffScalar">参数必须为标量 {0} 枚举成员。</entry>
    <entry key="Point2Elements">点必须包含两个元素</entry>
    <entry key="MustBe2or3Vector">数组必须包含 2 个或 3 个元素。</entry>
    <entry key="MustBe2Vector">参数必须为包含两个元素的向量。</entry>
    <entry key="MustBe4Vector">矩阵必须包含 4 个元素。</entry>
    <entry key="MustBeString">参数必须为字符向量或字符串标量。</entry>
    <entry key="MustBeStrings">数组只能包含字符向量。</entry>
    <entry key="MustBeHandle">参数必须为句柄。</entry>
    <entry key="MustBeScalarHandle">参数必须为标量句柄。</entry>
    <entry key="ClassMustBeHandle">类 ''{0}'' 必须为句柄类。</entry>
    <entry key="UnhandledStringConversion">未处理从 mxArray 到字符的转换。</entry>
    <entry key="IncompletePVPair">属性-值对组不完整。</entry>
    <entry key="ArrayDimsMatch">数组维度必须匹配。</entry>
    <entry key="CopyRequiresNonEmpty">复制需要非空句柄。</entry>
    <entry key="ParentSizeMismatch">父级大小与要复制的句柄列表不匹配。</entry>
    <entry key="ConnectToEmpty">无法将句柄连接到空内容的上方、左侧或右侧。</entry>
    <entry key="ConnectToSelf">无法将句柄连接到其自身。</entry>
    <entry key="ConnectCycle">不允许连接，因为这会生成循环图。</entry>
    <entry key="MethodNotFound">未找到方法。</entry>
    <entry key="MethodAccess">不允许访问此方法。</entry>
    <entry key="RequireStaticMethod">无法将实例方法作为静态方法调用。</entry>
    <entry key="InvalidStaticMethodU">静态方法或命名空间函数无效。</entry>
    <entry key="NoMatchingSig">没有具有匹配签名的方法。</entry>
    <entry key="InvalidObjectFromConstructor">构造函数返回了无效的句柄对象。</entry>
    <entry key="MustBeStringOrNumber">元胞({0,number,integer})必须包含字符向量或数值。</entry>
    <entry key="MustBeHandleArray">参数必须为句柄数组。</entry>
    <entry key="MustBeScalarObject">只能将一个对象传递给 set 以获取有关可能的属性值的信息。</entry>
    <entry key="NotDefined">函数 ''{0}'' 没有定义为支持类 ''{1}'' 的值。</entry>
    <entry key="ConstructorReturnedWrongClass">构造函数返回了错误类型的对象。</entry>
    <entry key="FromJavaConversionError">无法将 Java 对象转换为属性的类型。</entry>
    <entry key="ToJavaConversionError">无法将属性转换为 Java 类型。</entry>
    <entry key="JavaConversionError">Java 对象不是 {0} 的实例。</entry>
    <entry key="InconsistentClassArray">Java 数组包含混合类的对象。</entry>
    <entry key="JavaSetHGProperty">未来版本中对 Java 布尔值属性执行 Get 命令将返回 true/false。</entry>
    <entry key="initFailed">初始化句柄数组失败。</entry>
    <entry key="packageMustBeString">命名空间名称必须为字符向量或字符串标量。</entry>
    <entry key="noConvertToHandle">无法转换为句柄。</entry>
    <entry key="Arg2mustBeString">第二个参数必须为字串向量或字符串标量。</entry>
    <entry key="typeMustBeString">类型名称必须为字符向量或字符串标量。</entry>
    <entry key="loadobj">由于类 {0} 的 loadobj 未返回对象，因此无法加载对象。</entry>
    <entry key="loadErrorSignature">由于发生以下错误，无法加载 {0} 对象:\n没有匹配的构造函数签名。</entry>
    <entry key="saveError">尝试保存 {0} 类型的对象时出错:\n{1}</entry>
    <entry key="LoadDefinitionUpdated">无法加载类 {0} 的实例。类 {1} 已更新，并且与旧定义不兼容。</entry>
    <entry key="loadErrFindingClass">尝试查找类 {0}{1}{2} 时出错:\n{3}</entry>
    <entry key="loadClassNotFoundU">无法加载 {0}{1}{2} 对象，因为找不到该对象的类</entry>
    <entry key="loadErrorWithErrorU">由于发生以下错误，无法加载 {0} 对象:\n{1}</entry>
    <entry key="UnableToLoadObject">对象无法加载，并且将被替换为空的双精度值。</entry>
    <entry key="loadErrorNoErrorU">无法加载 {0} 对象。</entry>
    <entry key="RGBColor">RGB 颜色必须为包含 3 个元素的数值向量。</entry>
    <entry key="ConnectionRefusedByParent">连接被父级拒绝。</entry>
    <entry key="ConnectionRefusedByChild">连接被子级拒绝。</entry>
    <entry key="SchemaPackageWarningWithPath">以后的版本将不支持基于架构的包。包 ''{0}'' 中定义的类和函数必须重写。请参阅&lt;a href="matlab: doc('classdef')"&gt;文档&lt;/a&gt;。\n包位置: {1}</entry>
    <entry key="SchemaPackageError">Schema-based packages are no longer supported. The classes and functions defined in package ''{0}'' must be rewritten.</entry>
    <entry key="SchemaPackageErrorWithPath">Schema-based packages are no longer supported. The classes and functions defined in package ''{0}'' must be rewritten.\nPackage location: {1}</entry>
    <entry key="abstractAttribute">Abstract 类无法实例化。类 ''{0}'' 被声明为 Abstract。 </entry>
    <entry key="inheritAbstractMember">抽象类无法实例化。类 ''{0}'' 继承抽象方法或属性，但不实现它们。如果您不想将类设置为 abstract 类，请参阅 ''{2}'' 必须实施的&lt;a href=\"matlab:matlab.metadata.abstractDetails(''{1}'')\"&gt;方法和属性列表&lt;/a&gt;。</entry>
    <entry key="inheritAbstractMemberNoLink">抽象类无法实例化。类 ''{0}'' 继承抽象方法或属性，但不实现它们。如果您不想将类设置为抽象类，请使用 matlab.metadata.abstractDetails 查看 ''{1}'' 必须实现的方法和属性列表。</entry>
    <entry key="defineAbstractMember">Abstract 类无法实例化。类 ''{0}'' 定义 abstract 方法和/或属性。</entry>
    <entry key="AbstractCannotInstantiate">抽象类无法实例化。类 ''{0}'' 是抽象类。</entry>
    <entry key="abstractConstructor">构造函数不能使用 Abstract 属性。该构造函数在 ''{0}'' 类中被定义为 Abstract 方法。</entry>
    <entry key="AbstractInvalidInput">输入必须为类名或 {0} 实例。</entry>
    <entry key="AbstractMember">类 ''{0}'' 是在 Abstract = false 的情况下声明的，并且包含 abstract 成员。如果类包含 abstract 成员，它不能设置 Abstract = false。</entry>
    <entry key="AbstractPrivateProperty">类 {0} 中的抽象属性 {1} 无效。抽象属性不能同时具有 private GetAccess 以及 private 或 immutable SetAccess。</entry>
    <entry key="AbstractPrivateMethod">类 {0} 中的方法 {1} 已定义为抽象私有方法。抽象方法不能具有私有 Access。</entry>
    <entry key="AbstractPropertyGet">不能为类 ''{1}'' 中的 Abstract 属性 ''{0}'' 指定 get 方法。</entry>
    <entry key="AbstractPropertyInconsistentAccess">属性 ''{0}'' 在类 ''{1}'' 中的定义不同于它在超类 ''{2}'' 中的定义。这可能是由于访问权限冲突或 Constant 属性的值不一致所致。</entry>
    <entry key="AbstractPropertyInitialValue">不能为类 ''{1}'' 中的 Abstract 属性 ''{0}'' 指定初始值。</entry>
    <entry key="AbstractPropertySet">不能为类 ''{1}'' 中的 Abstract 属性 ''{0}'' 指定 set 方法。</entry>
    <entry key="RemovedPropertySet">向属性 ''{0}'' 赋值时:\n无法验证 ''{0}'' 的值，因为类 ''{1}'' 不在 MATLAB 路径上。</entry>
    <entry key="abstractWithBody">在 ''{0}'' 类中，''{1}'' 方法同时具有 Abstract 属性和函数体。</entry>
    <entry key="AccessSetToImmutable">Access 属性不能设置为 ''immutable''。只有 SetAccess 才能被设置为 immutable。</entry>
    <entry key="ActionEventWillBeRenamed">以后的版本中将会删除指定的事件。对于 uicontrol 对象，请改用此事件: {0}。\n</entry>
    <entry key="EventWillBeRenamed">以后的版本中将会删除指定的事件。请改用此事件: {0}。\n</entry>
    <entry key="EventWillBeRemoved">在以后的版本中将会删除指定的事件。</entry>
    <entry key="AmbiguousProperty">{0} 属性具有多义性: ''{1}''。</entry>
    <entry key="attemptToShadowBuiltinClass">不允许命名类 ''{0}''，因为它已是内置类。</entry>
    <entry key="UnrecognizedAttribute">属性 ''{0}'' 非法。</entry>
    <entry key="BadAttributeValue">类 ''{1}'' 中属性 ''{0}'' 的值非法。{2}</entry>
    <entry key="NoCatBuiltinSubclassWithProperty">由于 ''{1}'' 定义了属性和子类 ''{2}''，因此无法串联类 ''{0}'' 的对象。{3}</entry>
    <entry key="NoCatDifferentBuiltinSubclasses">无法串联 ''{0}'' 和 ''{1}'' 两个不同类的对象。</entry>
    <entry key="NotOnPath">类 ''{0}'' 的父目录必须位于 MATLAB 的搜索路径中。</entry>
    <entry key="conflictingSuperClassProperty">不能同时在类 ''{1}'' 和 ''{2}'' 中定义属性 ''{0}''。</entry>
    <entry key="ConflictingAccessAttribute">使用 ''GetAccess'' 或 ''SetAccess'' 属性时，不能使用 ''Access'' 属性。</entry>
    <entry key="EnumConstructorRecursive">不能在枚举类的任何成员的定义中使用该枚举类的构造函数。类 ''{1}'' 中的枚举成员 ''{0}'' 违反此规则。</entry>
    <entry key="DeleteAbstract">删除方法不能为 Abstract。</entry>
    <entry key="DeleteSealed">删除方法不能为 Sealed。</entry>
    <entry key="DeleteStatic">删除方法不能为 Static。</entry>
    <entry key="DependentGet">在类 ''{0}'' 中，从属属性 ''{1}'' 的 get 方法试图访问存储的属性值。从属属性未存储值，因此无法通过其 get 方法访问。</entry>
    <entry key="noGetMethod">在类 ''{0}'' 中，没有为从属属性 ''{1}'' 定义 get 方法。从属属性需要 get 方法才能获取其值。</entry>
    <entry key="noSetMethod">在类 ''{0}'' 中，没有为从属属性 ''{1}'' 定义 set 方法。从属属性需要 set 方法才能为其赋值。</entry>
    <entry key="DependentSet">在类 ''{0}'' 中，从属属性 ''{1}'' 的 set 方法试图存储属性值。从属属性未存储值，因此无法在 set 方法中向其赋值。</entry>
    <entry key="DifferentBaseClassMethod">只能从同名子类方法显式调用基类方法。</entry>
    <entry key="ColonOnEnumNotSupported">冒号运算符没有定义为支持枚举类。</entry>
    <entry key="InvalidClassInDisplay">由于类无效，无法显示对象。</entry>
    <entry key="DuplicateCIProperty">''{0}'' 属性与 ''{1}'' 类中的另一个属性仅存在大小写差异。\n在设置 CaseInsensitiveProperties 属性的类中，这是非法的。</entry>
    <entry key="DuplicatePropertyInSetGet">''{0}'' 属性与 ''{1}'' 类中的另一个属性仅存在大小写差异。\n 在从 matlab.mixin.SetGet 划分子类的类中，这是非法的。</entry>
    <entry key="DuplicateAttribute">多次指定 ''{0}'' 属性。</entry>
    <entry key="DuplicateEnum">''{0}'' 只能作为 ''{1}'' 枚举类的成员定义一次。</entry>
    <entry key="DuplicateEvent">''{0}'' 已在 ''{1}'' 类中定义为事件。</entry>
    <entry key="DuplicateMethod">''{0}'' 已在 ''{1}'' 类中定义为方法。</entry>
    <entry key="duplicateNameEventEnum">''{0}'' 无法同时用作 ''{1}'' 枚举类的事件和成员。</entry>
    <entry key="duplicateNameMethodEnum">''{0}'' 无法同时用作 ''{1}'' 枚举类的方法和成员。</entry>
    <entry key="duplicateNameMethodEvent">名称 ''{0}'' 在同一类定义中同时用作方法和事件。此类名称必须唯一。</entry>
    <entry key="duplicateNamePropEnum">''{0}'' 无法同时用作 ''{1}'' 枚举类的属性和成员。</entry>
    <entry key="duplicateNamePropEvent">名称 ''{0}'' 在同一类定义中同时用作属性和事件。此类名称必须唯一。</entry>
    <entry key="duplicateNamePropMeth">名称 ''{0}'' 在同一类定义中同时用作属性和方法。此类名称必须唯一。</entry>
    <entry key="PropertyInUse">''{0}'' 已在 ''{1}'' 类中定义为属性。</entry>
    <entry key="DynPropDuplicatesMethod">名称 ''{0}'' 已用作方法名称。在未来的版本中，这将变为错误。</entry>
    <entry key="editDestroyedObject">不能从值对象的删除方法内修改值对象。</entry>
    <entry key="EmptyDynamicPropName">将动态属性添加到类 {0} 时出错: 动态属性名称不能为空。</entry>
    <entry key="emptyMustBeZero">至少要有一个维度为零。</entry>
    <entry key="CannotConvert">无法将类 ''{0}'' 的对象转换为枚举类 ''{1}''，因为没有可用的转换方法。</entry>
    <entry key="EnumMustBeScalar">在类 ''{0}'' 中，名为 ''{1}'' 的枚举成员必须为标量。</entry>
    <entry key="EnumerationNameMissing">无法将类 ''{0}'' 作为枚举加载，因为当前定义中缺少一个或多个枚举成员的名称。这些名称将作为结构体加载。</entry>
    <entry key="EnumNotCopyable">类 {0} 不能同时为枚举类和 matlab.mixin.Copyable 的子类。</entry>
    <entry key="EnumNotLoadableAsEnum">无法将类 ''{0}'' 作为枚举加载，因为该类不再是枚举。枚举成员的名称将作为结构体加载。</entry>
    <entry key="EnumerationValueChanged">枚举成员 ''{0}'' 的值不同于保存该枚举时的值。将使用新值加载 ''{1}''。</entry>
    <entry key="EnumValueMissing">当创建类 ''{0}'' 的实例时:\n没有为名为 ''{1}'' 的枚举成员提供任何值。对于派生于内置类的枚举，必须为每个枚举成员提供一个值。</entry>
    <entry key="FailedUnsharePrivateData">当取消共享私有数据 mxArray 时，无法分配内存。</entry>
    <entry key="BadParamValuePairs">参数/值对组参数无效。</entry>
    <entry key="InvalidParamCell">参数名称元胞数组中的元胞必须为非空的字符向量或字符串标量。</entry>
    <entry key="InvalidArgumentPVP">形参-值对组实参必须为字符向量、结构体、字符串标量或字符向量元胞数组</entry>
    <entry key="FindOperatorPrecedence">''{0}'' 运算符不能后跟逻辑运算符。</entry>
    <entry key="ParamValueCellMismatch">参数元胞/值元胞对组中的大小不匹配。</entry>
    <entry key="ValueCellDimension">值元胞数组句柄维度必须与句柄向量长度匹配。</entry>
    <entry key="ValueCellValue">值元胞数组的每个指定属性必须具有一个值。</entry>
    <entry key="GetAccessSetToImmutable">GetAccess 属性不能设置为 ''immutable''。只有 SetAccess 才能被设置为 immutable。</entry>
    <entry key="GetProhibited">类 ''{1}'' 没有公共属性 ''{0}''。</entry>
    <entry key="GetProhibitedDynamic">您无法获取动态属性 ''{0}''。</entry>
    <entry key="ArrayMustBeHomogeneous">在对 GET 的调用(格式为 "v = get(h)")中，h 的所有元素必须属于同一类。</entry>
    <entry key="MustReturnValue">在对 GET 的调用(属性 ''{0}'' 具有多义性或未知)中，\n查找值失败，以致无法返回有效结果。</entry>
    <entry key="NonHandleCompatibleSuperclass">''{1}'' 将其 HandleCompatible 属性显式设置为 true 后，类 ''{0}'' 的所有超类必须与句柄兼容。</entry>
    <entry key="AmbiguousSuperclass">无法构成异构数组: 无法根据输入确定唯一的超类。</entry>
    <entry key="InvalidConversionResult">从 ''{0}'' 进行转换时:\n转换返回了类 ''{1}'' 的值，该值无法插入到类 ''{2}'' 的数组中。</entry>
    <entry key="DefaultMethodInvalid">在扩展数组期间:\n无法获取类 ''{0}'' 的默认实例。类 {1} 中缺少方法 ''getDefaultScalarElement''，或者方法定义错误。</entry>
    <entry key="InvalidHeterogeneousArray">无法构成异构数组: 两个或更多个元素无法组合到一个有效的异构数组中。</entry>
    <entry key="InvalidDefaultElement">为类 ''{0}'' 定义的默认实例并非派生于类 ''{1}''。</entry>
    <entry key="MethodNotAllowed">不允许类 ''{0}'' 定义 ''{1}'' 方法。</entry>
    <entry key="InheritedMethodNotAllowed">类 ''{0}'' 不能为 ''{1}'' 的子类，也无法从类 ''{3}'' 继承 ''{2}'' 方法。</entry>
    <entry key="MultipleHeterogeneousSuperclasses">类 ''{0}'' 具有两个或更多个派生于 matlab.mixin.Heterogeneous 的直接超类，这是不允许的。</entry>
    <entry key="NoConversionDefined">无法从 ''{0}'' 转换为异构类 ''{1}''。''{2}'' 未定义静态方法 ''convertObject''，或其 ''convertObject'' 方法不支持将 ''{0}'' 转换为 ''{1}''。</entry>
    <entry key="MissingGetDefaultScalarElement">在扩展数组期间:\n没有为类 ''{0}'' 定义默认值。\n超类 {1} 中缺少方法 ''getDefaultScalarElement''，或者方法定义错误。</entry>
    <entry key="UnsealedMethodNoName">由于类为 ''{1}'' 的一个或多个输入是异构输入，并且 ''{2}'' 不为 sealed，因此无法调用方法 ''{0}''。有关详细信息，请参阅异构数组的&lt;a href="matlab: helpview ([docroot '/matlab/ref/ref.map'],'method_dispatching')"&gt;方法调度&lt;/a&gt;规则。</entry>
    <entry key="UnsealedMethodNoNameNoLink">由于类为 ''{1}'' 的一个或多个输入是异构输入，并且 ''{2}'' 不为 sealed，因此无法调用方法 ''{0}''。有关详细信息，请参阅异构数组的方法调度规则。</entry>
    <entry key="UnsealedMethod">由于 ''{1}'' 是异构的，并且 ''{2}'' 不为 sealed，因此无法调用方法 ''{0}''。有关详细信息，请参阅异构数组的&lt;a href="matlab: helpview ([docroot '/matlab/ref/ref.map'],'method_dispatching')"&gt;方法调度&lt;/a&gt;规则。</entry>
    <entry key="IllegalInitialValue">类 ''{1}'' 中的属性 ''{0}'' 的默认值无效:\n{2}</entry>
    <entry key="inconsistentSuperclasses">如果类定义了超类，则所有超类必须均为句柄类，或者所有超类均不为句柄类。</entry>
    <entry key="inconsistentSuperclassConnectivity">类的所有支持连接的超类必须支持同一类型的连接。</entry>
    <entry key="InvalidArgument">''{0}'' 的输入参数类型无效。请键入 ''help {1}'' 查看选项。</entry>
    <entry key="InvalidInputArgumentTypeSizeOrValue">函数 ''{0}'' 的输入参数无效。</entry>
    <entry key="InvalidBaseClass">''{0}'' 不是有效的基类。</entry>
    <entry key="InvalidBaseClassCall">基类方法只能从子类中的同一方法调用。</entry>
    <entry key="InvalidBaseClassMethod">''{0}'' 不是基类 ''{1}'' 的可访问方法。</entry>
    <entry key="InvalidClass">''{0}'' 类包含解析错误，无法在 MATLAB 的搜索路径中找到，或者被具有相同名称的其他文件遮蔽了。</entry>
    <entry key="InvalidEnum">找不到 ''{0}'' 枚举类中与给定输入参数的每个元素相对应的成员。</entry>
    <entry key="invalidEvent">没有为类 ''{1}'' 定义事件 ''{0}''。</entry>
    <entry key="InvalidHandle">对象无效或已删除。</entry>
    <entry key="InvalidCustomMetaClass">自定义元类 ''{0}'' 必须派生于元类 ''{1}''。</entry>
    <entry key="InvalidProperty">名称 ''{0}'' 不是类 ''{1}'' 的实例可以访问的属性。</entry>
    <entry key="InvalidPropertyGet">无法为类 ''{1}'' 中的属性 ''{0}'' 指定 get 函数，因为该类未定义该属性。</entry>
    <entry key="InvalidPropertySet">无法为类 ''{1}'' 中的属性 ''{0}'' 指定 set 函数，因为该类未定义该属性。</entry>
    <entry key="InvalidReturnValue">{0} 方法返回的值属于类 {1}，而非预期的类 {2}。</entry>
    <entry key="InvalidStaticMethod">类 ''{1}'' 中没有 Static 方法 ''{0}''。</entry>
    <entry key="InvalidStaticProperty">必须从类实例访问类 ''{1}'' 中的属性 ''{0}''，因为该属性不是 Constant 属性。</entry>
    <entry key="InvalidSuperClass">指定的 ''{0}'' 超类包含解析错误，无法在 MATLAB 的搜索路径中找到，或者被具有相同名称的其他文件遮蔽了。</entry>
    <entry key="InvalidSuperClassBeingDestroyed">无法实例化类 ''{0}''，因为超类 ''{1}'' 正在销毁。</entry>
    <entry key="InvalidType">''{0}'' 不是有效类名。</entry>
    <entry key="PropertyAddedWithNonexistingType">无法将属性 ''{0}'' 添加到类 ''{1}''，因为类型 ''{2}'' 不存在。请确保类型名称是已加载的注册类型或类。</entry>
    <entry key="ListenRestricted">无法侦听类 ''{1}'' 中的事件 ''{0}''。</entry>
    <entry key="methodAmbiguous">类 ''{1}'' 中定义的方法 ''{0}'' 具有 2 个或更多个冲突定义。</entry>
    <entry key="methodOverrideAccess">类 ''{1}'' 中的方法 ''{0}'' 和其超类 ''{2}''中的方法使用不同的访问权限。请将 ''{3}'' 访问权限设置为 ''{4}'' 以匹配超类。</entry>
    <entry key="methodOverrideAccessList">类 ''{1}'' 中的方法 ''{0}'' 和其超类 ''{2}''中的方法使用不同的访问权限。请设置 ''{3}'' 访问列表以匹配超类访问列表。</entry>
    <entry key="methodOverrideSealed">类 ''{1}'' 中的方法 ''{0}'' 与超类 ''{2}'' 中的 sealed 方法冲突。不支持覆盖 sealed 方法。</entry>
    <entry key="methodMultipleInheritanceAccess">Method ''{0}'' in superclasses ''{1}'' and ''{2}'' uses conflicting access permissions. Set ''{3}'' access to match in all superclasses.</entry>
    <entry key="MethodRestricted">无法访问类 ''{1}'' 中的方法 ''{0}''。</entry>
    <entry key="MissingType">属性 ''{0}'' 中的类无效或缺少类。</entry>
    <entry key="MultipleCustomMetaClasses">试图从超类 {1} 为类 ''{0}'' 继承不同元类。</entry>
    <entry key="inputMustBeScalar">''function_handle'' 的输入参数必须为标量。</entry>
    <entry key="mustReturnObject">构造类 ''{0}'' 的实例时，构造函数必须保留返回的对象的类。</entry>
    <entry key="memberHasClassName">属性或事件不能使用与类({0})的名称相同的名称。</entry>
    <entry key="nonHandleClassWithEvents">类 ''{0}'' 不能定义事件，因为只有句柄的子类才能定义事件。</entry>
    <entry key="defaultObjectMustBeScalar">类 ''{0}'' 的默认对象是非标量。可能的原因包括: 构造函数返回非标量对象，或者为类定义的默认值是非标量。</entry>
    <entry key="NotifyRestricted">无法通知类 ''{1}'' 中事件 ''{0}'' 的侦听器。</entry>
    <entry key="CheckListenerRestricted">NotifyAccess 需要确定类 ''{1}'' 中的事件 ''{0}'' 是否存在侦听程序。</entry>
    <entry key="HandleCompatibleFalse">类 ''{0}'' 不能同时是句柄的子类，并且同时将其 HandleCompatible 属性显式设置为 false。</entry>
    <entry key="internalNoclass">找不到要实例化的类 ''{0}''。</entry>
    <entry key="NoDefaultDefined">未为属性 {0} 定义默认值。</entry>
    <entry key="NoDefaultPermitted">属性 {0} 为 {1}，因此不能具有默认值。</entry>
    <entry key="noEnum">''{0}'' 枚举类必须至少定义一个成员。</entry>
    <entry key="ActualEnumHidden">在枚举类 ''{0}'' 中，成员 ''{1}'' 和 ''{2}'' 具有相同的基础值，并且 ''{1}'' 被隐藏。如果主成员被隐藏，则别名成员也必须隐藏。</entry>
    <entry key="NoMatchingSuperConstructor">没有找到关于超类 ''{0}'' 的匹配构造函数。</entry>
    <entry key="OutsideEnumBlock">输入与枚举类 ''{0}'' 的成员不对应。</entry>
    <entry key="ParseError">类定义存在解析错误。</entry>
    <entry key="PropertyNotFound">类 ''{1}'' 中没有 ''{0}'' 属性。</entry>
    <entry key="RedefinedProperty">不能在类 ''{1}'' 中定义属性 ''{0}''，因为已在超类 ''{2}'' 中定义该属性。</entry>
    <entry key="EnumWithProps">不能在 ''{0}'' 枚举类中定义或继承属性，因为该类派生于内置类 ''{1}''。</entry>
    <entry key="PropertyTypeMismatch">类 ''{1}'' 中定义的属性 ''{0}'' 限制必须与基类 ''{2}'' 中的属性定义匹配。</entry>
    <entry key="InvalidDatatypeRestriction">Datatypes in the ''matlab.internal.datatype'' namespace do not support size restrictions and validation functions.</entry>
    <entry key="InternalDatatypeUsesClass">Using ''matlab.internal.datatype'' namespace with class ''{0}'' is not supported. Use ''{1}'' instead.</entry>
    <entry key="customSaveRecursionLimit">超出了递归限制: 类 {0} 的 saveobj 方法间接与一个或多个其他类的 saveobj 方法递归。</entry>
    <entry key="RecursiveEnumDefinition">不能在枚举类成员 ''{0}'' 自身的定义中使用该成员。</entry>
    <entry key="RecursiveConstPropDefinition">不能在类 {1} 的常量属性 ''{0}'' 自身的定义中使用该属性。</entry>
    <entry key="RecursivePropDefinition">''{0}'' 类定义直接或间接使用自身的实例作为 ''{1}'' 属性的默认值。这是不允许的。</entry>
    <entry key="RecursiveSuperClass">类 ''{0}'' 指定了一个作为 ''{1}'' 的子类的超类。这是不允许的。</entry>
    <entry key="RecursiveDefinition">''{0}'' 类在其自身的类定义中用作基类、属性值或特性值。这是不允许的。</entry>
    <entry key="NotHandleCell">参数 ''{0}'' 必须为句柄数组或句柄元胞数组。</entry>
    <entry key="RequireCellStrings">值必须为字符向量元胞数组或字符串标量。</entry>
    <entry key="RequireNonScalarText">''{0}'' 值必须为字符向量元胞数组或字符串数组。</entry>
    <entry key="RequireChar">值必须为字符。</entry>
    <entry key="RequireEnumeration">值必须为 public、protected 或 private。</entry>
    <entry key="RequireClass">值必须为 ''{0}''。</entry>
    <entry key="RequireLogical">值必须为逻辑值(true 或 false)。</entry>
    <entry key="RequireMatrix">值必须为矩阵。</entry>
    <entry key="RequireNDims">值必须具有 {0,number,integer} 个维度。</entry>
    <entry key="RequireNumber">值必须为数值。</entry>
    <entry key="RequireNumeric">值必须为数值或逻辑值。</entry>
    <entry key="RequireReal">值必须为实数。</entry>
    <entry key="RequireScalar">值必须为标量。</entry>
    <entry key="RequireString">值必须为字符向量或字符串标量。</entry>
    <entry key="RequireStringOrScalarClass">值必须为字符向量、字符串标量或标量 ''{0}''。</entry>
    <entry key="RequireAscii">值必须包含 ASCII 字符。 </entry>
    <entry key="RequireScalarText">''{0}'' 值必须为字符向量或字符串标量。</entry>
    <entry key="RequireSuperClass">类 ''{0}'' 不是类 ''{1}'' 的超类，这是调用超类构造函数或方法所必需的。</entry>
    <entry key="RequireVector">值必须为向量。</entry>
    <entry key="ReservedClassName">类名称 ''{0}'' 是保留名称，不能用于定义类。</entry>
    <entry key="ReservedClassNameInPackage">包 ''{1}'' 中的类 ''{0}'' 使用保留名称，不能用于定义类。 </entry>
    <entry key="ScalarObjectRequired">传递到方法 ''{0}'' 的对象必须为标量。</entry>
    <entry key="ScalarOutputRequired">返回的值不是标量。类 {1} 的方法 {0} 必须返回同一类的标量对象。</entry>
    <entry key="sealed">类 ''{0}'' 为 Sealed，因此无法用作超类。</entry>
    <entry key="SetProhibited">不支持设置 ''{1}'' 类的 ''{0}'' 属性。</entry>
    <entry key="SetProhibitedDynamic">不支持设置动态属性 ''{0}''。</entry>
    <entry key="SetDynamicConstant"> 设置 meta.DynamicProperty 对象的 Constant 属性不起作用。在以后的版本中，该警告将变为错误。</entry>
    <entry key="SetDynamicAbstract"> 设置 meta.DynamicProperty 对象的 Abstract 属性不起作用。在以后的版本中，该警告将变为错误。</entry>
    <entry key="SetProhibitedReadOnly">无法设置 ''{1}'' 类的 ''{0}'' 属性，因为它为只读属性。</entry>
    <entry key="EnumPropertyNotSetImmutable">类 ''{1}'' 或其某个超类中属性 ''{0}'' 的 SetAccessor 必须为 immutable。</entry>
    <entry key="SetFunctionNoReturn">属性 ''{0}'' 的 set 函数必须返回类 ''{1}'' 的实例。</entry>
    <entry key="SetFunctionReturnWrongClass">在属性 ''{0}'' 的 set 函数中，输出对象的类为 ''{1}''；输入对象的类为 ''{2}''。二者应相同。</entry>
    <entry key="SetGetWithAttributes">必须在没有属性的方法块中定义类 ''{0}'' 中的属性 set 和 get 函数。</entry>
    <entry key="MustReturnCell">在对 SET 的调用(格式为 c = set(h, ''propname'')，并且属性 ''{0}'' 具有多义性或未知)中，查找所有可能的值失败，以致未能返回元胞数组。</entry>
    <entry key="SubclassOfEnum">''{0}'' 不能子类化 ''{1}''，因为 ''{2}'' 是枚举类。</entry>
    <entry key="InvalidSubsref">不能使用 ''('' 或 '''{''' 对类 ''{0}'' 的对象进行索引，因为 ''{1}'' 定义了属性和继承了 ''{2}''。{3}</entry>
    <entry key="TypeRedefined">定义类型 ''{0}'' 的尝试无效，因为已定义该类型。</entry>
    <entry key="UndefinedMethod">没有为类 ''{1}'' 找到具有匹配签名的方法 ''{0}''。</entry>
    <entry key="UndefinedCustomMetaClass">找不到元类 ''{0}''。</entry>
    <entry key="undefinedMethod">没有为类 ''{1}'' 定义方法 ''{0}''，或者该方法已从 MATLAB 的搜索路径中删除。</entry>
    <entry key="methodOfUnregisteredPackage">Method ''{0}'' is not defined for class ''{1}'' or the defining package ''{2}'' has been uninstalled.</entry>
    <entry key="UndefinedPackageForEnumType">用于定义定型枚举 {1} 的命名空间名称 {0} 无效或未定义。</entry>
    <entry key="UndefinedPackageRemovingEnumType">用于删除定型枚举 {1} 的命名空间名称 {0} 无效或未定义。</entry>
    <entry key="WrongReturnClass">返回的值属于类 {0}。类 {2} 的方法 {1} 必须返回同一类的标量对象。</entry>
    <entry key="InexactPropertyName">使用了不精确的属性名称 ''{0}'' 来访问属性 ''{1}''。未来的版本中将会删除对不精确的属性名称的支持。请改用确切名称。</entry>
    <entry key="AtFolderPrecedence">类 ''{0}'' 是在类文件夹中定义的，它优先于在 MATLAB 路径中较早出现的同名函数。在以后的版本中，类 ''{0}'' 将不再具有优先权。\n\n&lt;a href="matlab: matlab.internal.identifyClassPrecedenceConflicts(''{0}'')"&gt;点击此处获取冲突项的位置&lt;/a&gt;。\n&lt;a href="matlab: helpview('matlab','AtFolderPrecedence');"&gt;点击此处获取如何避免此警告的指南&lt;/a&gt;。</entry>
    <entry key="ClassPrecedenceIdentification">\n类 ''{0}'':\n\t{1}\n优先于以下项:\n{2}\n</entry>
    <entry key="EnumerableClassNotFound">无法加载类 ''{0}'' 的对象:\n找不到其类。</entry>
    <entry key="LoadInvalidDefaultElement">在加载期间:\n 加载类 {0} 的异构数组时检测到无效的默认对象。将返回类 {1} 的空数组。</entry>
    <entry key="DefaultObjectSubstitution">无法将类 {0} 的实例加载到异构数组中。可能缺少 {1} 的定义，或者该定义包含错误。将替换默认对象。</entry>
    <entry key="LoadedHetArrayInvalid">无法将最初作为类 {0} 的异构数组保存的数组加载为有效异构数组。可能原因包括类层次结构发生了更改或缺少类定义。</entry>
    <entry key="loadInconsistentClass">在加载期间:\n 属于不同类的对象无法放置到类 {0} 的数组中，因为 {1} 并非派生于 matlab.mixin.Heterogeneous。将返回类 {2} 的空数组。</entry>
    <entry key="PropSealed">在未来的版本中，将不支持在类 ''{0}'' 中将属性定义为 ''Sealed''。该属性(attribute)不会对属性(properties)产生任何影响。</entry>
    <entry key="PropNotHandleCell">创建属性侦听器时，不支持嵌套元胞数组。参数 ''Properties'' 必须为句柄数组或句柄元胞数组。</entry>
    <entry key="SourceNotHandleCell">创建属性侦听器时，不支持嵌套元胞数组。参数 ''Source'' 必须为句柄数组或句柄元胞数组。</entry>
    <entry key="nonGetObservableProp">添加 {0} 侦听器时，未将 ''{2}'' 类中的属性 ''{1}'' 定义为 GetObservable。</entry>
    <entry key="nonSetObservableProp">添加 {0} 侦听器时，未将 ''{2}'' 类中的属性 ''{1}'' 定义为 SetObservable。</entry>
    <entry key="PropNotMember">创建属性侦听器时，名为 ''{0}'' 的属性是 ''{1}'' 类的成员，但对象是 ''{2}'' 类的实例。</entry>
    <entry key="DynPropNotMember">为 ''{0}'' 类的对象创建属性侦听器时，名为 ''{1}'' 的动态属性属于不同对象。 </entry>
    <entry key="PropertyValidInputs">''Property'' 必须为字符串或字符串数组、字符向量或字符向量元胞数组，或者为 meta.property 标量或数组。</entry>
    <entry key="ConstantDependentProp">类 ''{1}'' 中的属性 ''{0}'' 已定义为从属常量。常量属性不能是从属属性。</entry>
    <entry key="ConstantPropObservable">类 ''{0}'' 将属性 ''{1}'' 定义为 Constant 和 GetObservable 或 SetObservable。为 Constant 属性指定 GetObservable 或 SetObservable 不起作用。在以后的版本中，该警告将变为错误。</entry>
    <entry key="InvalidPropAttributeCombination">类 ''{1}'' 中的属性 ''{0}'' 已同时使用特性 {2} 和 {3} 进行定义。不支持同时使用这些特性。</entry>
    <entry key="ConstantPropGetMethod">类 ''{0}'' 将属性 ''{1}'' 定义为 Constant，此外还为 ''{2}'' 定义了属性 get-method。常量属性无法定义属性 get-method。</entry>
    <entry key="ConstantPropSetMethod">类 ''{0}'' 将属性 ''{1}'' 定义为 Constant，此外还为 ''{2}'' 定义了属性 set-method。该方法不起作用，将被忽略。</entry>
    <entry key="ObjectMustBeScalar">不允许使用类 ''{0}'' 的对象组成数组和括号样式的编制索引功能。只能将类 ''{1}'' 的对象用作标量，或者用作元胞数组。</entry>
    <entry key="EmptyScalar">不允许创建类 ''{0}'' 的空数组。只能将类 ''{1}'' 的对象用作标量。</entry>
    <entry key="concatenationScalar">不支持串联 ''{0}'' 对象，因为 ''{0}'' 对象只能是标量。</entry>
    <entry key="emptyScalar">Creating an empty array of a scalar class is not supported.</entry>
    <entry key="parenAssignScalar">''{0}'' 对象不支持使用括号进行索引赋值。</entry>
    <entry key="parenDeleteScalar">不支持从 ''{0}'' 对象中删除元素。</entry>
    <entry key="parenReferenceScalar">不支持使用括号索引来访问 ''{0}'' 对象的元素。</entry>
    <entry key="SubclassNotAllowed">无法实例化类 ''{0}''，因为它不能从类 ''{1}'' 继承。类 ''{0}'' 未指定为类 ''{1}'' 的允许子类。请从类 ''{0}'' 的超类列表中删除类 ''{1}''。</entry>
    <entry key="SealedAndAllowedSubclasses">类 ''{0}'' 中的属性 sealed 与 AllowedSubclasses 列表冲突。应该将类设置为 Sealed，或者指定允许的子类的列表。</entry>
    <entry key="DefiningClassNotAllowedSubclass">不能将类 ''{0}'' 包含在其自己的 AllowedSubclasses 列表中。</entry>
    <entry key="SuperclassNotAllowedSubclass">类 ''{0}'' 是类 ''{1}'' 的超类，因此不能包含在类 ''{2}'' 的 AllowedSubclasses 列表中。</entry>
    <entry key="InvalidAllowedSubclassesValue">''{0}'' 必须为 meta.class 句柄或 meta.class 句柄的元胞数组。有关详细信息，请参阅&lt;a href="matlab: helpview ([docroot '/matlab/matlab_oop/matlab_oop.map'],'specify_allowed_subclasses')"&gt;指定允许的子类&lt;/a&gt;。</entry>
    <entry key="InvalidInferiorclassValue">''{0}'' 必须为 meta.class 句柄或 meta.class 句柄的元胞数组。</entry>
    <entry key="InvalidAccessValue">''{0}'' 必须为 public、protected、private 类或类的列表。有关详细信息，请参阅&lt;a href="matlab: helpview ([docroot '/matlab/matlab_oop/matlab_oop.map'],'specify_access_to_class_member')"&gt;指定对类成员的访问权限&lt;/a&gt;。</entry>
    <entry key="MethodOverrideWithoutAccess">不允许使用类 ''{0}'' 改写方法 ''{1}''，因为类 ''{2}'' 未向该类及其超类授予对此方法的访问权限。</entry>
    <entry key="UndefinedFunction">未找到具有匹配签名的方法 ''{0}''。</entry>
    <entry key="UndefinedFunctionInClass">没有为类 ''{1}'' 找到具有匹配签名的方法 ''{0}''。</entry>
    <entry key="UndefinedFunctionOrVariable">未定义函数或变量 ''{0}''。</entry>
    <entry key="InvalidIdBeforeAt">''@'' 前应是标识符。</entry>
    <entry key="InvalidClassName">类名无效。</entry>
    <entry key="PropertyGroupInvalidInput">输入必须为字符向量、字符向量元胞数组、字符串数组或标量结构体</entry>
    <entry key="BadPropertyGroup">无法显示类 ''{0}'' 的对象，因为 ''getPropertyGroups'' 未返回有效的 ''{1}''。</entry>
    <entry key="DefaultConstructorNotFound">不支持创建类 ''{0}'' 的默认对象。</entry>
    <entry key="ExplicitConversionOnly">无法将 ''{0}'' 对象转换为 ''{1}'' 对象。请显式构造类 ''{2}'' 的对象。</entry>
    <entry key="ExplicitConversionOnHeterogeneous">matlab.mixin.Heterogeneous 的子类中不支持使用 ''ExplicitConversion'' 属性。此属性在类 ''{0}'' 中不起作用</entry>
    <entry key="NonCopyableMustBeHandle">类 ''{1}'' 中的属性 ''{0}'' 不能是 NonCopyable。只能对句柄类的属性使用 NonCopyable 属性。</entry>
    <entry key="GetAllowedSubclassesInvalidInput">输入必须为类名或类的元对象</entry>
    <entry key="InvalidPropertyGroupConstructor">PropertyGroup 构造函数的 {0} 位置的输入无效。输入必须为属性名称。</entry>
    <entry key="InvalidPropertyGroupAlignValue">构造 PropertyGroup 时，'Aligned' 属性值的输入无效。输入必须为逻辑标量。</entry>
    <entry key="InvalidPropertyGroupTitleValue">构造 PropertyGroup 时，'Title' 属性值的输入无效。输入必须为字符向量或字符串标量。</entry>
    <entry key="AmbiguousInferiorClasses">类 ''{0}'' 不能低于类 ''{1}''，原因是 ''{2}'' 将 ''{3}'' 声明为低级类。</entry>
    <entry key="SetGetExactNamesandGraphicsClasses"> 类 ''{0}'' 中存在有冲突的超类。不支持子类化 matlab.mixin.SetGetExactNames 和派生自图形的任何类。</entry>
    <entry key="SetGetExactNamesandTruncatedCaseInsensitive">  ''{0}'' 中的超类和类属性有冲突。不支持从 matlab.mixin.SetGetExactNames 子类化时将 CaseInsensitiveProperties 或 TruncatedProperties 设置为 true。</entry>
    <entry key="PropFromPreviousClassDef">类 ''{0}'' 已更新。要为 ''{1}'' 添加属性侦听器，您必须检索更新的元类信息。</entry>
    <entry key="GetMethodDeletedObject">引用类 ''{1}'' 中的属性 ''{0}'' 失败，因为 ''{2}'' 的 get 方法删除了其对象。</entry>
    <entry key="DynPropGetMethodDeletedObject">引用类 ''{1}'' 中的动态属性 ''{0}'' 失败，因为 ''{2}'' 的 get 方法删除了其对象。</entry>
    <entry key="DynPropSetMethodDeletedObject">引用类 ''{1}'' 中的动态属性 ''{0}'' 失败，因为 ''{2}'' 的 set 方法删除了其对象。</entry>
    <entry key="PreGetCallbackDeletedObject">无法获取类 ''{1}'' 的对象中的属性 ''{0}''，因为 PreGet 侦听器函数删除了该对象。</entry>
    <entry key="ObjectUpdateFailureHandle2Value">无法更新对象，因为句柄类 ''{0}'' 现在是值类。</entry>
    <entry key="ObjectUpdateFailureTree2NoConnection">无法更新对象，因为树连接类 ''{0}'' 现在没有连接。</entry>
    <entry key="ObjectUpdateFailureAbstract">无法更新对象，因为类 ''{0}'' 现在是抽象类。</entry>
    <entry key="ObjectUpdateFailureEnum">无法更新对象，因为类 ''{0}'' 现在是有限的值枚举。</entry>
    <entry key="ObjectUpdateFailureHeterogeneous">无法在此异构数组中更新类 ''{0}'' 的对象，因为该对象不会共享同一超类。</entry>
    <entry key="ObjectUpdateFailureArrayFormation">无法更新类 ''{0}'' 的数组，因为其超类 ''{1}'' 已更改索引和数组结构规则。</entry>
    <entry key="CannotUpdateDelete">无法对 ''{0}'' 类的对象调用删除方法，因为该对象无法更新。该对象将使用默认删除方法删除。</entry>
    <entry key="UnableToSetProperty">设置类 ''{1}'' 的属性 ''{0}'' 时出现未知错误。</entry>
    <entry key="UnableToGetProperty">获取类 ''{1}'' 的属性 ''{0}'' 时出现未知错误。</entry>
    <entry key="InvalidEnumConversion">不支持从 ''{0}'' 转换为枚举 ''{1}''。</entry>
    <entry key="InvalidCellArrayEnumConversion">输入参数必须为字符向量元胞数组。</entry>
    <entry key="InvalidCharMatrixEnumConversion">输入参数必须为字符向量。</entry>
    <entry key="UnableToCompare">枚举类 ''{0}'' 派生自内置类。在以后的版本中，将不会逐字符测试派生自内置类的枚举与字符数组是否相等。</entry>
    <entry key="PartialMatchPriorityRealScalarInt">''{0}'' 的值无效。需要正整数值。</entry>
    <entry key="PartialMatchPriorityMaximumInt">''{0}'' 的值大于最大整数。</entry>
    <entry key="DoubleQuotesNotSupported">不支持在 access 属性值中使用双引号。</entry>
    <entry key="instanceCreationAtClassDestruction">不支持在销毁类 ''{0}'' 时为该类创建实例。</entry>
    <entry key="StaticIndexingFunction">系统将不会为索引操作调用类 ''{1}'' 中的方法 ''{0}''，因为该方法被声明为静态方法。</entry>
    <entry key="MethodAccessSetToImmutable">将方法的 Access 属性设置为 immutable 是不正确的。方法的有效访问权限值为 public、protected 和 private。</entry>
    <entry key="EventAccessSetToImmutable">将事件的 {0} 属性设置为 immutable 是不正确的。事件的有效访问权限值为 public、protected 和 private。</entry>
    <entry key="InvalidConverterMethod">只能通过子类构造函数来使用 method@superclass 语法调用超类构造函数 ''{0}''。</entry>
    <entry key="ExternalConstructor">不支持外部构造函数。请在 classdef 块中为类 ''{0}'' 定义构造函数。</entry>
    <entry key="ExternalConverter">不支持用于命名空间限定类的外部转换器方法。请在 classdef 块中为类 ''{1}'' 定义 ''{0}'' 转换器。</entry>
    <entry key="ExternalSetGet">不支持外部属性访问方法。请在 classdef 块中为类 ''{0}'' 定义属性访问方法。</entry>
    <entry key="DuplicateSuperClass">对类 {1} 多次指定了相同的基类 {0}。对于每个基类，请仅指定一次。</entry>
    <entry key="OffPathAndSuperclassChanged">类 ''{0}'' 的一个或多个超类已更改，需要更新类 ''{0}''。MATLAB 无法更新类 ''{0}''，因为它不在路径上。要访问此类的实例，请将其添加到路径中。</entry>
    <entry key="InvalidPropertyAttributeCallback">没有为类 ''{2}'' 的属性 ''{1}'' 定义自定义属性回调 ''{0}''。</entry>
    <entry key="PropertyAttributeCallbackNotFound">找不到类 ''{2}'' 的属性 ''{1}'' 的自定义属性回调 ''{0}''。</entry>
    <entry key="MatlabCallbackOnCppPropertyNotSupported">尝试对类 ''{1}'' 的属性 ''{0}'' 指定自定义属性失败。不支持对 C++ 定义的类属性使用具有 MATLAB 定义的回调的自定义特性。</entry>
    <entry key="UnknownPropertyForClass">尝试为类 ''{1}'' 上的属性 ''{0}'' 调用 turnOnCustomGet 方法或 turnOnCustomSet 方法。没有为此类定义此属性。</entry>
    <entry key="CustomAttributesInternalError">无法检索类 ''{0}'' 的属性 ''{1}'' 的当前属性值。对象或类无效或已删除。</entry>
    <entry key="NotHandleCellArray">参数 ''{0}'' 必须为句柄元胞数组。</entry>
    <entry key="CustomPropNotDependent">自定义属性 ''{0}'' 必须为从属属性。</entry>
    <entry key="DeletedValue">不支持为值类 ''{0}'' 创建已删除对象。</entry>
    <entry key="ConverterTypeMismatch">无法使用类 {0} 的对象创建类 {1} 的实例。{2} {3} 转换器不返回 {4} 值。</entry>
    <entry key="InvalidClassAttribute">类 ''{0}'' 无效，因为它既继承自 ''{1}''，又将属性 ''{2}'' 设置为 true。请从类 ''{0}'' 中删除属性 ''{2}''。</entry>
    <entry key="InvalidInheritance">类 ''{0}'' 无效，因为它继承自 ''{1}'' 和 ''{2}''。不支持同时使用这些超类。请从类 ''{0}'' 中删除其中之一。</entry>
    <entry key="ClassNotFoundOnPath">The class ''{0}'' cannot be found on MATLAB''s search path.</entry>
    <entry key="DeprecatedFunction">以后的版本中将会删除 ''{0}''。请改用 ''{1}''。</entry>
    <entry key="NonDefaultZeroEnumProperty">类 ''{1}'' 中属性 ''{0}'' 的当前默认值为 ''{2}''。在以后的版本中，隐式属性默认值将更改为 ''{4}'' 的第一个枚举成员 ''{3}''。\n通过为该属性指定显式值 ''{2}''，可以避免此警告消息和潜在的不兼容更改。</entry>
    <entry key="NullValueValidation">不支持验证不可构造的属性值。</entry>
    <entry key="UnableToSaveDueToSearchPathProblem">由于搜索路径问题，无法保存类 ''{0}'' 的对象。</entry>
    <entry key="GenericJavaException">{0}</entry>
    <entry key="SpinRun">Detected UDD or OOPS. Exclude testpoint from spin run.</entry>
    <entry key="NamespaceFeatureChangeAttempt">Turning the namespace feature on or off from within MATLAB is not permitted. Please restart MATLAB using matlab -namespace or -nonamespace.</entry>
    <entry key="ConvertToClassInvalidClassNameType">The first input argument must be a non-empty char vector.</entry>
    <entry key="ConvertToClassInvalidContext">The third input argument must be a scalar matlab.lang.ExecutionContext.</entry>
  </message>
</rsccat>
