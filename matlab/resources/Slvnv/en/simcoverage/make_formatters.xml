<?xml version="1.0"?>
<!-- Copyright 2013-2023 The MathWorks, Inc. -->
<rsccat version="1.0" locale="en_US" product="Slvnv">
  <message> 
    
    <!-- Stateflow -->
    <entry key="MSG_SF_HIST_CHILD_CALL_A">History test</entry>
    <entry key="MSG_SF_HIST_CHILD_CALL_S">History substate</entry>
    <entry key="MSG_SF_HIST_CHILD_CALL_D">Previously active substate entered due to history</entry>
    <!-- -->
    <entry key="MSG_SF_STATE_ON_DECISION_A">On Decision</entry>
    <entry key="MSG_SF_STATE_ON_DECISION_S">Event "{0}"</entry>
    <entry key="MSG_SF_STATE_ON_DECISION_D">Trigger event "{0}"</entry>
    <!-- -->
    <entry key="MSG_SF_TRANSITION_TEST_A">Test</entry>
    <entry key="MSG_SF_TRANSITION_TEST_S">Transition</entry>
    <entry key="MSG_SF_TRANSITION_TEST_D">Transition trigger expression</entry>
    <!-- -->
    <entry key="MSG_SF_TRANS_PRED_A" translate="false" note="TranslateFalseBatch;">CND({0})</entry>
    <entry key="MSG_SF_TRANS_PRED_S" translate="false" note="TranslateFalseBatch;">"{0}"</entry>
    <entry key="MSG_SF_TRANS_PRED_D">Condition {0}, "{1}"</entry>
    <!-- -->
    <entry key="MSG_SF_ACTIVE_CHILD_CALL_A">Child executed</entry>
    <entry key="MSG_SF_ACTIVE_CHILD_CALL_S">Executed substate</entry>
    <entry key="MSG_SF_ACTIVE_CHILD_CALL_D">Substate executed</entry>
    <!-- -->
    <entry key="MSG_SF_INACTIVE_BEFORE_EXIT_A">Child exit</entry>
    <entry key="MSG_SF_INACTIVE_BEFORE_EXIT_S">Indirectly exited substate</entry>
    <entry key="MSG_SF_INACTIVE_BEFORE_EXIT_D">Substate exited when parent exits</entry>
    <!-- -->
    <entry key="MSG_SF_ACTIVE_CHILD_AT_EXIT_A">Child exit</entry>
    <entry key="MSG_SF_ACTIVE_CHILD_AT_EXIT_S">Indirectly exited substate</entry>
    <entry key="MSG_SF_ACTIVE_CHILD_AT_EXIT_D">Substate exited when parent exits</entry>
    <!-- -->
    <entry key="MSG_SF_ACTIVE_CHILD_EXIT_A">Child exit</entry>
    <entry key="MSG_SF_ACTIVE_CHILD_EXIT_S">Indirectly exited substate</entry>
    <entry key="MSG_SF_ACTIVE_CHILD_EXIT_D">Substate exited when parent exits</entry>
    <!-- Test Objective -->
    <entry key="MSG_SL_TESTPOINT_A" translate="false" note="TranslateFalseBatch;">TP</entry>    
    <entry key="MSG_SL_TESTPOINT_S" translate="false" note="TranslateFalseBatch;">{0}</entry>    
    <entry key="MSG_SL_TESTPOINT_D" translate="false" note="TranslateFalseBatch;">{0}</entry>    
    <entry key="MSG_SL_TESTINTERVAL_A" translate="false" note="TranslateFalseBatch;">TI</entry>    
    <entry key="MSG_SL_TESTINTERVAL_S" translate="false" note="TranslateFalseBatch;">{0}</entry>    
    <entry key="MSG_SL_TESTINTERVAL_D" translate="false" note="TranslateFalseBatch;">{0}</entry>    
    <entry key="MSG_SL_TESTOBJECTIVE_SCAL_A" translate="false" note="TranslateFalseBatch;">TO</entry>    
    <entry key="MSG_SL_TESTOBJECTIVE_SCAL_S" translate="false" note="TranslateFalseBatch;">{0}</entry>    
    <entry key="MSG_SL_TESTOBJECTIVE_SCAL_D" translate="false" note="TranslateFalseBatch;">{0}</entry>    
    <entry key="MSG_SL_TESTOBJECTIVE_VECT_A" translate="false" note="TranslateFalseBatch;">U({0})</entry>    
    <entry key="MSG_SL_TESTOBJECTIVE_VECT_S" translate="false" note="TranslateFalseBatch;">U({0})</entry>    
    <entry key="MSG_SL_TESTOBJECTIVE_VECT_D">input({0})</entry>    
    
	<!-- All blocks with parameter Saturate on integer overflow -->
	<entry key="MSG_SL_SATURATE_ON_INTEGER_OVERFLOW_A" translate="false" note="TranslateFalseBatch;">SO</entry>
    <entry key="MSG_SL_SATURATE_ON_INTEGER_OVERFLOW_S">Saturate on integer overflow</entry>
    <entry key="MSG_SL_SATURATE_ON_INTEGER_OVERFLOW_D">Saturate on integer overflow</entry>

	<!-- All blocks in simulink -->
	<entry key="MSG_SL_BLOCK_COVERAGE_A" translate="false" note="TranslateFalseBatch;">BC</entry>
    <entry key="MSG_SL_BLOCK_COVERAGE_S">Block executed</entry>
    <entry key="MSG_SL_BLOCK_COVERAGE_D">Block executed</entry>
	
   <!-- Absolute value block -->
   <entry key="MSG_SL_ABSVAL_SCAL_A" translate="false" note="TranslateFalseBatch;">U&lt;0</entry>
   <entry key="MSG_SL_ABSVAL_VECT_A" translate="false" note="TranslateFalseBatch;">U&lt;0</entry>
   <entry key="MSG_SL_ABSVAL_VECTC_A" translate="false" note="TranslateFalseBatch;">U&lt;0</entry>
   <entry key="MSG_SL_ABSVAL_SCAL_S" translate="false" note="TranslateFalseBatch;">U {0} 0</entry>
   <entry key="MSG_SL_ABSVAL_VECT_S" translate="false" note="TranslateFalseBatch;">U({0}) {1} 0</entry>
   <entry key="MSG_SL_ABSVAL_VECTC_S" translate="false" note="TranslateFalseBatch;">U(:) {0} 0</entry>
   <entry key="MSG_SL_ABSVAL_SCAL_D">input {0} 0</entry>
   <entry key="MSG_SL_ABSVAL_VECT_D">input({0}) {1} 0</entry>
   <entry key="MSG_SL_ABSVAL_VECTC_D">input(:) {0} 0</entry>
 
 
    <!-- Relational Boundary-->
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_INT_LESS_A" translate="false" note="TranslateFalseBatch;">-1</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_INT_LESS_S" translate="false" note="TranslateFalseBatch;">-1</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_INT_LESS_D" translate="false" note="TranslateFalseBatch;">-1</entry>

    <entry key="MSG_SL_RELATIONALOP_OUTCOME_FIXPT_LESS_A" translate="false" note="TranslateFalseBatch;">-LSB</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_FIXPT_LESS_S" translate="false" note="TranslateFalseBatch;">-LSB</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_FIXPT_LESS_D" translate="false" note="TranslateFalseBatch;">-LSB</entry>

    <entry key="MSG_SL_RELATIONALOP_OUTCOME_REAL_LESS_A" translate="false" note="TranslateFalseBatch;">[-tol..0)</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_REAL_LESS_S" translate="false" note="TranslateFalseBatch;">[-tol..0)</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_REAL_LESS_D" translate="false" note="TranslateFalseBatch;">[-tol..0)</entry>
    
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_REAL_LESS_CLOSED_A" translate="false" note="TranslateFalseBatch;">[-tol..0]</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_REAL_LESS_CLOSED_S" translate="false" note="TranslateFalseBatch;">[-tol..0]</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_REAL_LESS_CLOSED_D" translate="false" note="TranslateFalseBatch;">[-tol..0]</entry>
    
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_INT_EQ_A" translate="false" note="TranslateFalseBatch;">0</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_INT_EQ_S" translate="false" note="TranslateFalseBatch;">0</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_INT_EQ_D" translate="false" note="TranslateFalseBatch;">0</entry>
    
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_FIXPT_EQ_A" translate="false" note="TranslateFalseBatch;">0</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_FIXPT_EQ_S" translate="false" note="TranslateFalseBatch;">0</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_FIXPT_EQ_D" translate="false" note="TranslateFalseBatch;">0</entry>
    
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_INT_GREATER_A" translate="false" note="TranslateFalseBatch;">+1</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_INT_GREATER_S" translate="false" note="TranslateFalseBatch;">+1</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_INT_GREATER_D" translate="false" note="TranslateFalseBatch;">+1</entry>

    <entry key="MSG_SL_RELATIONALOP_OUTCOME_FIXPT_GREATER_A" translate="false" note="TranslateFalseBatch;">+LSB</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_FIXPT_GREATER_S" translate="false" note="TranslateFalseBatch;">+LSB</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_FIXPT_GREATER_D" translate="false" note="TranslateFalseBatch;">+LSB</entry>
    
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_REAL_GREATER_A" translate="false" note="TranslateFalseBatch;">(0..tol]</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_REAL_GREATER_S" translate="false" note="TranslateFalseBatch;">(0..tol]</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_REAL_GREATER_D" translate="false" note="TranslateFalseBatch;">(0..tol]</entry>
    
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_REAL_GREATER_CLOSED_A" translate="false" note="TranslateFalseBatch;">[0..tol]</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_REAL_GREATER_CLOSED_S" translate="false" note="TranslateFalseBatch;">[0..tol]</entry>
    <entry key="MSG_SL_RELATIONALOP_OUTCOME_REAL_GREATER_CLOSED_D" translate="false" note="TranslateFalseBatch;">[0..tol]</entry>
    
    <!-- Relational Operator Block -->
    <entry key="MSG_SL_RELATIONALOP_SCAL_A" translate="false" note="TranslateFalseBatch;">{0}</entry>
    <entry key="MSG_SL_RELATIONALOP_SCAL_S">input1 {0} input2</entry>
    <entry key="MSG_SL_RELATIONALOP_SCAL_D">input1 {0} input2</entry>
    
    <entry key="MSG_SL_RELATIONALOP_VEC_A">input1({0}) {1} input2({2})</entry>
    <entry key="MSG_SL_RELATIONALOP_VEC_S">input1({0}) {1} input2({2})</entry>
    <entry key="MSG_SL_RELATIONALOP_VEC_D">input1({0}) {1} input2({2})</entry>
    
    <entry key="MSG_SL_RELATIONALOP_VEC_SCAL_A">input1({0}) {1} input2</entry>
    <entry key="MSG_SL_RELATIONALOP_VEC_SCAL_S">input1({0}) {1} input2</entry>
    <entry key="MSG_SL_RELATIONALOP_VEC_SCAL_D">input1({0}) {1} input2</entry>
    
    <entry key="MSG_SL_RELATIONALOP_SCAL_VEC_A">input1 {0} input2({1})</entry>
    <entry key="MSG_SL_RELATIONALOP_SCAL_VEC_S">input1 {0} input2({1})</entry>
    <entry key="MSG_SL_RELATIONALOP_SCAL_VEC_D">input1 {0} input2({1})</entry>
    
    <entry key="MSG_SL_RELATIONALOP_COND_UNARY_A">input1 {0}</entry>
    <entry key="MSG_SL_RELATIONALOP_COND_UNARY_S">input1 {0}</entry>
    <entry key="MSG_SL_RELATIONALOP_COND_UNARY_D">input1 {0}</entry>
    
    <entry key="MSG_SL_RELATIONALOP_COND_UNARY_VEC_A">input1({0}) {1}</entry>
    <entry key="MSG_SL_RELATIONALOP_COND_UNARY_VEC_S">input1({0}) {1}</entry>
    <entry key="MSG_SL_RELATIONALOP_COND_UNARY_VEC_D">input1({0}) {1}</entry>
    
    
    <!-- Relay block-->
    <entry key="MSG_SL_RELAY_ON_SCAL_A">Turn On</entry>
    <entry key="MSG_SL_RELAY_ON_SCAL_S" translate="false" note="TranslateFalseBatch;">U {0} OnThresh</entry>
    <entry key="MSG_SL_RELAY_ON_SCAL_D">input {0} on threshold</entry>
    
    <entry key="MSG_SL_RELAY_ON_VECTU_A">Turn On</entry>
    <entry key="MSG_SL_RELAY_ON_VECTU_S" translate="false" note="TranslateFalseBatch;">U[{0}] {1} OnThresh</entry>
    <entry key="MSG_SL_RELAY_ON_VECTU_D">input({0}) {1} on threshold</entry>
    
    <entry key="MSG_SL_RELAY_ON_VECTP_A">Turn On</entry>
    <entry key="MSG_SL_RELAY_ON_VECTP_S" translate="false" note="TranslateFalseBatch;">U {0} OnThresh[{1}]</entry>
    <entry key="MSG_SL_RELAY_ON_VECTP_D">input {0} on threshold({1})</entry>
    
    <entry key="MSG_SL_RELAY_ON_VECTUP_A">Turn On</entry>
    <entry key="MSG_SL_RELAY_ON_VECTUP_S" translate="false" note="TranslateFalseBatch;">U[{0}] {1} OnThresh[{2}]</entry>
    <entry key="MSG_SL_RELAY_ON_VECTUP_D">input({0}) {1} on threshold({2})</entry>
    
    <entry key="MSG_SL_RELAY_OFF_SCAL_A">Turn Off</entry>
    <entry key="MSG_SL_RELAY_OFF_SCAL_S" translate="false" note="TranslateFalseBatch;">U {0} OffThresh</entry>
    <entry key="MSG_SL_RELAY_OFF_SCAL_D">input {0} off threshold</entry>
    
    <entry key="MSG_SL_RELAY_OFF_VECTU_A">Turn Off</entry>
    <entry key="MSG_SL_RELAY_OFF_VECTU_S" translate="false" note="TranslateFalseBatch;">U[{0}] {1} OffThresh</entry>
    <entry key="MSG_SL_RELAY_OFF_VECTU_D">input({0}) {1} off threshold</entry>
    
    <entry key="MSG_SL_RELAY_OFF_VECTP_A">Turn Off</entry>
    <entry key="MSG_SL_RELAY_OFF_VECTP_S" translate="false" note="TranslateFalseBatch;">U {0} OffThresh[{1}]</entry>
    <entry key="MSG_SL_RELAY_OFF_VECTP_D">input {0} off threshold({1})</entry>
    
    <entry key="MSG_SL_RELAY_OFF_VECTUP_A">Turn Off</entry>
    <entry key="MSG_SL_RELAY_OFF_VECTUP_S" translate="false" note="TranslateFalseBatch;">U[{0}] {1} OffThresh[{2}]</entry>
    <entry key="MSG_SL_RELAY_OFF_VECTUP_D">input({0}) {1} off threshold({2})</entry>
    
    
    <!-- Saturate block-->    
    <entry key="MSG_SL_SATURATE_UL_SCAL_A">Above UL</entry>
    <entry key="MSG_SL_SATURATE_UL_SCAL_S" translate="false" note="TranslateFalseBatch;">U {0} UL</entry>
    <entry key="MSG_SL_SATURATE_UL_SCAL_D">input {0} upper limit</entry>
    
    <entry key="MSG_SL_SATURATE_UL_VECTU_A">Above UL</entry>
    <entry key="MSG_SL_SATURATE_UL_VECTU_S" translate="false" note="TranslateFalseBatch;">U[{0}] {1} UL</entry>
    <entry key="MSG_SL_SATURATE_UL_VECTU_D">input({0}) {1} upper limit</entry>
    
    <entry key="MSG_SL_SATURATE_UL_VECTP_A">Above UL</entry>
    <entry key="MSG_SL_SATURATE_UL_VECTP_S" translate="false" note="TranslateFalseBatch;">U {0} UL[{1}]</entry>
    <entry key="MSG_SL_SATURATE_UL_VECTP_D">input {0} upper limit({1})</entry>
    
    <entry key="MSG_SL_SATURATE_UL_VECTUP_A">Above UL</entry>
    <entry key="MSG_SL_SATURATE_UL_VECTUP_S" translate="false" note="TranslateFalseBatch;">U[{0}] {1} UL[{2}]</entry>
    <entry key="MSG_SL_SATURATE_UL_VECTUP_D">input({0}) {1} upper limit({2})</entry>
    
    <entry key="MSG_SL_SATURATE_LL_SCAL_A">Above LL</entry>
    <entry key="MSG_SL_SATURATE_LL_SCAL_S" translate="false" note="TranslateFalseBatch;">U {0} LL</entry>
    <entry key="MSG_SL_SATURATE_LL_SCAL_D">input {0} lower limit</entry>
    
    <entry key="MSG_SL_SATURATE_LL_VECTU_A">Above LL</entry>
    <entry key="MSG_SL_SATURATE_LL_VECTU_S" translate="false" note="TranslateFalseBatch;">U[{0}] {1} LL</entry>
    <entry key="MSG_SL_SATURATE_LL_VECTU_D">input({0}) {1} lower limit</entry>
    
    <entry key="MSG_SL_SATURATE_LL_VECTP_A">Above LL</entry>
    <entry key="MSG_SL_SATURATE_LL_VECTP_S" translate="false" note="TranslateFalseBatch;">U {0} LL[{1}]</entry>
    <entry key="MSG_SL_SATURATE_LL_VECTP_D">input {0} lower limit({1})</entry>
    
    <entry key="MSG_SL_SATURATE_LL_VECTUP_A">Above LL</entry>
    <entry key="MSG_SL_SATURATE_LL_VECTUP_S" translate="false" note="TranslateFalseBatch;">U[{0}] {1} LL[{2}]</entry>
    <entry key="MSG_SL_SATURATE_LL_VECTUP_D">input({0}) {1} lower limit({2})</entry>
  
    <!-- DeadZone block-->  
    <entry key="MSG_SL_DEADZONE_UL_SCAL_A">Above UL</entry>
    <entry key="MSG_SL_DEADZONE_UL_SCAL_S" translate="false" note="TranslateFalseBatch;">U {0} UL</entry>
    <entry key="MSG_SL_DEADZONE_UL_SCAL_D">input {0} upper limit</entry>
    
    <entry key="MSG_SL_DEADZONE_UL_VECTU_A">Above UL</entry>
    <entry key="MSG_SL_DEADZONE_UL_VECTU_S" translate="false" note="TranslateFalseBatch;">U[{0}] {1} UL</entry>
    <entry key="MSG_SL_DEADZONE_UL_VECTU_D">input({0}) {1} upper limit</entry>
    
    <entry key="MSG_SL_DEADZONE_UL_VECTP_A">Above UL</entry>
    <entry key="MSG_SL_DEADZONE_UL_VECTP_S" translate="false" note="TranslateFalseBatch;">U {0} UL[{1}]</entry>
    <entry key="MSG_SL_DEADZONE_UL_VECTP_D">input {0} upper limit({1})</entry>
    
    <entry key="MSG_SL_DEADZONE_UL_VECTUP_A">Above UL</entry>
    <entry key="MSG_SL_DEADZONE_UL_VECTUP_S" translate="false" note="TranslateFalseBatch;">U[{0}] {1} UL[{2}]</entry>
    <entry key="MSG_SL_DEADZONE_UL_VECTUP_D">input({0}) {1} upper limit({2})</entry>
    
    <entry key="MSG_SL_DEADZONE_LL_SCAL_A">Above LL</entry>
    <entry key="MSG_SL_DEADZONE_LL_SCAL_S" translate="false" note="TranslateFalseBatch;">U {0} LL</entry>
    <entry key="MSG_SL_DEADZONE_LL_SCAL_D">input {0} lower limit</entry>
    
    <entry key="MSG_SL_DEADZONE_LL_VECTU_A">Above LL</entry>
    <entry key="MSG_SL_DEADZONE_LL_VECTU_S" translate="false" note="TranslateFalseBatch;">U[{0}] {1} LL</entry>
    <entry key="MSG_SL_DEADZONE_LL_VECTU_D">input({0}) {1} lower limit</entry>
    
    <entry key="MSG_SL_DEADZONE_LL_VECTP_A">Above LL</entry>
    <entry key="MSG_SL_DEADZONE_LL_VECTP_S" translate="false" note="TranslateFalseBatch;">U {0} LL[{1}]</entry>
    <entry key="MSG_SL_DEADZONE_LL_VECTP_D">input {0} lower limit({1})</entry>
    
    <entry key="MSG_SL_DEADZONE_LL_VECTUP_A">Above LL</entry>
    <entry key="MSG_SL_DEADZONE_LL_VECTUP_S" translate="false" note="TranslateFalseBatch;">U[{0}] {1} LL[{2}]</entry>
    <entry key="MSG_SL_DEADZONE_LL_VECTUP_D">input({0}) {1} lower limit({2})</entry>
   
 
    <!-- Discrete-Time Integrator block-->
    <entry key="MSG_SL_DINTEGRATOR_RESET_SCAL_A">Reset</entry>
    <entry key="MSG_SL_DINTEGRATOR_RESET_SCAL_S">Reset</entry>
    <entry key="MSG_SL_DINTEGRATOR_RESET_SCAL_D">Reset</entry>
 
    <entry key="MSG_SL_DINTEGRATOR_RESET_VECT_A">Reset[i]</entry>
    <entry key="MSG_SL_DINTEGRATOR_RESET_VECT_S">Reset[{0}]</entry>
    <entry key="MSG_SL_DINTEGRATOR_RESET_VECT_D">Reset({0})</entry>
  
  
  
    <entry key="MSG_SL_DINTEGRATOR_UL_SCAL_A">Above UL</entry>
    <entry key="MSG_SL_DINTEGRATOR_UL_SCAL_S" translate="false" note="TranslateFalseBatch;">X &gt;= UL</entry>
    <entry key="MSG_SL_DINTEGRATOR_UL_SCAL_D">integration result &gt;= upper limit</entry>
    
    <entry key="MSG_SL_DINTEGRATOR_UL_VECTU_A">Above UL</entry>
    <entry key="MSG_SL_DINTEGRATOR_UL_VECTU_S" translate="false" note="TranslateFalseBatch;">X({0}) &gt;= UL</entry>
    <entry key="MSG_SL_DINTEGRATOR_UL_VECTU_D">integration result({0}) &gt;= upper limit</entry>
    
    
    <entry key="MSG_SL_DINTEGRATOR_UL_VECTP_A">Above UL</entry>
    <entry key="MSG_SL_DINTEGRATOR_UL_VECTP_S" translate="false" note="TranslateFalseBatch;">X &gt;= UL({0})</entry>
    <entry key="MSG_SL_DINTEGRATOR_UL_VECTP_D">integration result &gt;= upper limit({0})</entry>
        
    <entry key="MSG_SL_DINTEGRATOR_UL_VECTUP_A">Above UL</entry>
    <entry key="MSG_SL_DINTEGRATOR_UL_VECTUP_S" translate="false" note="TranslateFalseBatch;">X({0}) &gt;= UL({1})</entry>
    <entry key="MSG_SL_DINTEGRATOR_UL_VECTUP_D">integration result({0}) &gt;= upper limit({1})</entry>
    
    <entry key="MSG_SL_DINTEGRATOR_LL_SCAL_A">Below LL</entry>
    <entry key="MSG_SL_DINTEGRATOR_LL_SCAL_S" translate="false" note="TranslateFalseBatch;">X &lt;= LL</entry>
    <entry key="MSG_SL_DINTEGRATOR_LL_SCAL_D">integration result &lt;= lower limit</entry>
    
    <entry key="MSG_SL_DINTEGRATOR_LL_VECTU_A">Below LL</entry>
    <entry key="MSG_SL_DINTEGRATOR_LL_VECTU_S" translate="false" note="TranslateFalseBatch;">X({0}) &lt;= LL</entry>
    <entry key="MSG_SL_DINTEGRATOR_LL_VECTU_D">integration result({0}) &lt;= lower limit</entry>
    
    <entry key="MSG_SL_DINTEGRATOR_LL_VECTP_A">Below LL</entry>
    <entry key="MSG_SL_DINTEGRATOR_LL_VECTP_S" translate="false" note="TranslateFalseBatch;">X &lt;= LL({0})</entry>
    <entry key="MSG_SL_DINTEGRATOR_LL_VECTP_D">integration result &lt;= lower limit({0})</entry>
    
    <entry key="MSG_SL_DINTEGRATOR_LL_VECTUP_A">Below LL</entry>
    <entry key="MSG_SL_DINTEGRATOR_LL_VECTUP_S" translate="false" note="TranslateFalseBatch;">X({0}) &lt;= LL({1})</entry>
    <entry key="MSG_SL_DINTEGRATOR_LL_VECTUP_D">integration result({0}) &lt;= lower limit({1})</entry>

    <!-- Strict limit DTI-->
    <entry key="MSG_SL_DINTEGRATOR_UL_STRICT_SCAL_A">Above UL</entry>
    <entry key="MSG_SL_DINTEGRATOR_UL_STRICT_SCAL_S" translate="false" note="TranslateFalseBatch;">X &gt; UL</entry>
    <entry key="MSG_SL_DINTEGRATOR_UL_STRICT_SCAL_D">integration result &gt; upper limit</entry>
    
    <entry key="MSG_SL_DINTEGRATOR_UL_STRICT_VECTU_A">Above UL</entry>
    <entry key="MSG_SL_DINTEGRATOR_UL_STRICT_VECTU_S" translate="false" note="TranslateFalseBatch;">X({0}) &gt; UL</entry>
    <entry key="MSG_SL_DINTEGRATOR_UL_STRICT_VECTU_D">integration result({0}) &gt; upper limit</entry>
    
    
    <entry key="MSG_SL_DINTEGRATOR_UL_STRICT_VECTP_A">Above UL</entry>
    <entry key="MSG_SL_DINTEGRATOR_UL_STRICT_VECTP_S" translate="false" note="TranslateFalseBatch;">X &gt; UL({0})</entry>
    <entry key="MSG_SL_DINTEGRATOR_UL_STRICT_VECTP_D">integration result &gt; upper limit({0})</entry>
        
    <entry key="MSG_SL_DINTEGRATOR_UL_STRICT_VECTUP_A">Above UL</entry>
    <entry key="MSG_SL_DINTEGRATOR_UL_STRICT_VECTUP_S" translate="false" note="TranslateFalseBatch;">X({0}) &gt; UL({1})</entry>
    <entry key="MSG_SL_DINTEGRATOR_UL_STRICT_VECTUP_D">integration result({0}) &gt; upper limit({1})</entry>
    
    <entry key="MSG_SL_DINTEGRATOR_LL_STRICT_SCAL_A">Below LL</entry>
    <entry key="MSG_SL_DINTEGRATOR_LL_STRICT_SCAL_S" translate="false" note="TranslateFalseBatch;">X &lt; LL</entry>
    <entry key="MSG_SL_DINTEGRATOR_LL_STRICT_SCAL_D">integration result &lt; lower limit</entry>
    
    <entry key="MSG_SL_DINTEGRATOR_LL_STRICT_VECTU_A">Below LL</entry>
    <entry key="MSG_SL_DINTEGRATOR_LL_STRICT_VECTU_S" translate="false" note="TranslateFalseBatch;">X({0}) &lt; LL</entry>
    <entry key="MSG_SL_DINTEGRATOR_LL_STRICT_VECTU_D">integration result({0}) &lt; lower limit</entry>
    
    <entry key="MSG_SL_DINTEGRATOR_LL_STRICT_VECTP_A">Below LL</entry>
    <entry key="MSG_SL_DINTEGRATOR_LL_STRICT_VECTP_S" translate="false" note="TranslateFalseBatch;">X &lt; LL({0})</entry>
    <entry key="MSG_SL_DINTEGRATOR_LL_STRICT_VECTP_D">integration result &lt; lower limit({0})</entry>
    
    <entry key="MSG_SL_DINTEGRATOR_LL_STRICT_VECTUP_A">Below LL</entry>
    <entry key="MSG_SL_DINTEGRATOR_LL_STRICT_VECTUP_S" translate="false" note="TranslateFalseBatch;">X({0}) &lt; LL({1})</entry>
    <entry key="MSG_SL_DINTEGRATOR_LL_STRICT_VECTUP_D">integration result({0}) &lt; lower limit({1})</entry>
    
    <!-- Rate Limiter block-->
    <entry key="MSG_SL_RATELIMITER_UL_SCAL_A">Above UL</entry>
    <entry key="MSG_SL_RATELIMITER_UL_SCAL_S" translate="false" note="TranslateFalseBatch;">X {0} UL</entry>
    <entry key="MSG_SL_RATELIMITER_UL_SCAL_D">slew rate {0} upper limit</entry>
    
    <entry key="MSG_SL_RATELIMITER_UL_VECTU_A">Above UL</entry>
    <entry key="MSG_SL_RATELIMITER_UL_VECTU_S" translate="false" note="TranslateFalseBatch;">X[{0}] {1} UL</entry>
    <entry key="MSG_SL_RATELIMITER_UL_VECTU_D">slew rate({0}) {1} upper limit</entry>
    
    <entry key="MSG_SL_RATELIMITER_UL_VECTP_A">Above UL</entry>
    <entry key="MSG_SL_RATELIMITER_UL_VECTP_S" translate="false" note="TranslateFalseBatch;">X {0} UL[{1}]</entry>
    <entry key="MSG_SL_RATELIMITER_UL_VECTP_D">slew rate {0} upper limit({1})</entry>
    
    <entry key="MSG_SL_RATELIMITER_UL_VECTUP_A">Above UL</entry>
    <entry key="MSG_SL_RATELIMITER_UL_VECTUP_S" translate="false" note="TranslateFalseBatch;">X[{0}] {1} UL[{2}]</entry>
    <entry key="MSG_SL_RATELIMITER_UL_VECTUP_D">slew rate({0}) {1} upper limit({2})</entry>
    
    <entry key="MSG_SL_RATELIMITER_LL_SCAL_A">Above LL</entry>
    <entry key="MSG_SL_RATELIMITER_LL_SCAL_S" translate="false" note="TranslateFalseBatch;">X {0} LL</entry>
    <entry key="MSG_SL_RATELIMITER_LL_SCAL_D">slew rate {0} lower limit</entry>
    
    <entry key="MSG_SL_RATELIMITER_LL_VECTU_A">Above LL</entry>
    <entry key="MSG_SL_RATELIMITER_LL_VECTU_S" translate="false" note="TranslateFalseBatch;">X[{0}] {1} LL</entry>
    <entry key="MSG_SL_RATELIMITER_LL_VECTU_D">slew rate({0}) {1} lower limit</entry>
    
    <entry key="MSG_SL_RATELIMITER_LL_VECTP_A">Above LL</entry>
    <entry key="MSG_SL_RATELIMITER_LL_VECTP_S" translate="false" note="TranslateFalseBatch;">X {0} LL[{1}]</entry>
    <entry key="MSG_SL_RATELIMITER_LL_VECTP_D">slew rate {0} lower limit({1})</entry>
    
    <entry key="MSG_SL_RATELIMITER_LL_VECTUP_A">Above LL</entry>
    <entry key="MSG_SL_RATELIMITER_LL_VECTUP_S" translate="false" note="TranslateFalseBatch;">X[{0}] {1} LL[{2}]</entry>
    <entry key="MSG_SL_RATELIMITER_LL_VECTUP_D">slew rate({0}) {1} lower limit({2})</entry>
   
     <!-- fcn block-->
     
    <entry key="MSG_SL_FCN_CONDITION_A">condition</entry>
    <entry key="MSG_SL_FCN_CONDITION_S" translate="false" note="TranslateFalseBatch;">"{0}"</entry>
    <entry key="MSG_SL_FCN_CONDITION_D" translate="false" note="TranslateFalseBatch;">"{0}"</entry>
    
    <entry key="MSG_SL_FCN_TEST_A">expression</entry>
    <entry key="MSG_SL_FCN_TEST_S">Expression</entry>
    <entry key="MSG_SL_FCN_TEST_D">Logical expression value</entry>
    
    <!-- Logic Block-->
    <entry key="MSG_SL_LOGIC_SCAL_A">Porti</entry>
    <entry key="MSG_SL_LOGIC_SCAL_S">port{0}</entry>
    <entry key="MSG_SL_LOGIC_SCAL_D">input port {0}</entry>

    <entry key="MSG_SL_LOGIC_VECT_A" translate="false" note="TranslateFalseBatch;">INi[J]</entry>
    <entry key="MSG_SL_LOGIC_VECT_S">port{0}[{1}]</entry>
    <entry key="MSG_SL_LOGIC_VECT_D">input port{0}({1})</entry>
    
    <entry key="MSG_SL_LOGIC_SCAL_OUT_A" translate="false" note="TranslateFalseBatch;">OUT</entry>
    <entry key="MSG_SL_LOGIC_SCAL_OUT_S">Output</entry>
    <entry key="MSG_SL_LOGIC_SCAL_OUT_D">expression for output</entry>
    
    <entry key="MSG_SL_LOGIC_VECT_OUT_A" translate="false" note="TranslateFalseBatch;">OUT[i]</entry>
    <entry key="MSG_SL_LOGIC_VECT_OUT_S">Output[{0}]</entry>
    <entry key="MSG_SL_LOGIC_VECT_OUT_D">expression for output({0})</entry>

    <entry key="MSG_SL_LOGIC_DEC_SCAL_OUT_A" translate="false" note="TranslateFalseBatch;">OUT</entry>
    <entry key="MSG_SL_LOGIC_DEC_SCAL_OUT_S">Output</entry>
    <entry key="MSG_SL_LOGIC_DEC_SCAL_OUT_D">Output</entry>

    <entry key="MSG_SL_LOGIC_DEC_VECT_OUT_A" translate="false" note="TranslateFalseBatch;">OUT[i]</entry>
    <entry key="MSG_SL_LOGIC_DEC_VECT_OUT_S">Output[{0}]</entry>
    <entry key="MSG_SL_LOGIC_DEC_VECT_OUT_D">Output({0})</entry>

    <entry key="MSG_SL_LOGIC_CASCMCDC_CONDITION">C{0} ({1} In{2})</entry>
    
    <!-- Combinatoric Logic Block-->
    <entry key="MSG_SL_CMBLOGIC_SCAL_A" translate="false" note="TranslateFalseBatch;">IF (in)</entry>
    <entry key="MSG_SL_CMBLOGIC_SCAL_S">IF (input)</entry>
    <entry key="MSG_SL_CMBLOGIC_SCAL_D">input logical value</entry>
    
    <entry key="MSG_SL_CMBLOGIC_VECT_A" translate="false" note="TranslateFalseBatch;">SWITCH (IN)</entry>
    <entry key="MSG_SL_CMBLOGIC_VECT_S">Equivalent index</entry>
    <entry key="MSG_SL_CMBLOGIC_VECT_D">integer index value</entry>
    
    <entry key="MSG_SL_CMBLOGIC_ELM_A" translate="false" note="TranslateFalseBatch;">IN[i]</entry>
    <entry key="MSG_SL_CMBLOGIC_ELM_S">input[{0}]</entry>
    <entry key="MSG_SL_CMBLOGIC_ELM_D">input({0})</entry>
    
    <entry key="MSG_SL_CMBLOGIC_OUT_A">Case i</entry>
    <entry key="MSG_SL_CMBLOGIC_OUT_S">{0} (input={1})</entry>
    <entry key="MSG_SL_CMBLOGIC_OUT_D">calculated to {0} based on inputs {1}</entry>
       
    
    <!-- If Block-->
    <entry key="MSG_SL_IF_SING_IF_A" translate="false" note="TranslateFalseBatch;">IF</entry>
    <entry key="MSG_SL_IF_SING_IF_S" translate="false" note="TranslateFalseBatch;">IF</entry>
    <entry key="MSG_SL_IF_SING_IF_D">input logical value</entry>

    <entry key="MSG_SL_IF_MULT_IF_A" translate="false" note="TranslateFalseBatch;">IF</entry>
    <entry key="MSG_SL_IF_MULT_IF_S">Input{0}</entry>
    <entry key="MSG_SL_IF_MULT_IF_D">input {0} "if" condition</entry>
    
    <entry key="MSG_SL_IF_MULT_ELSEIF_A" translate="false" note="TranslateFalseBatch;">ElseIF</entry>
    <entry key="MSG_SL_IF_MULT_ELSEIF_S" translate="false" note="TranslateFalseBatch;">Else IF #{0}</entry>
    <entry key="MSG_SL_IF_MULT_ELSEIF_D">input {0} "elseif" condition</entry>
    
    <!-- For Block-->
    
    <entry key="MSG_SL_FOR_CHECK_A" translate="false" note="TranslateFalseBatch;">FOR</entry>
    <entry key="MSG_SL_FOR_CHECK_S">Loop test</entry>
    <entry key="MSG_SL_FOR_CHECK_D">loop condition</entry>
    
    <entry key="MSG_SL_LOOPEXEC_A">executed</entry>
    <entry key="MSG_SL_LOOPEXEC_S">executed</entry>
    <entry key="MSG_SL_LOOPEXEC_D">executed</entry>
    
    <!-- While Block -->
    <entry key="MSG_SL_WHILE_WHILETEST_A" translate="false" note="TranslateFalseBatch;">WHILE</entry>
    <entry key="MSG_SL_WHILE_WHILETEST_S">While condition</entry>
    <entry key="MSG_SL_WHILE_WHILETEST_D">While loop condition</entry>

    <entry key="MSG_SL_WHILE_DOWHILETEST_A" translate="false" note="TranslateFalseBatch;">DO-WHILE</entry>
    <entry key="MSG_SL_WHILE_DOWHILETEST_S">Do-While condition</entry>
    <entry key="MSG_SL_WHILE_DOWHILETEST_D">Do-While loop condition</entry>
    
    <entry key="MGG_SL_WHILE_MAXITERS_A" translate="false" note="TranslateFalseBatch;">MX ITER</entry>
    <entry key="MGG_SL_WHILE_MAXITERS_S">Max iterations</entry>
    <entry key="MGG_SL_WHILE_MAXITERS_D">maximum iterations exceeded</entry>
    
    <!-- Min/Max Block -->
    <entry key="MSG_SL_MINMAX_SCAL_A" translate="false" note="TranslateFalseBatch;">Out LGC</entry>
    <entry key="MSG_SL_MINMAX_SCAL_S">Output</entry>
    <entry key="MSG_SL_MINMAX_SCAL_D">Logic to determine output</entry>
    
    <entry key="MSG_SL_MINMAX_VECT_A" translate="false" note="TranslateFalseBatch;">OUTi LGC</entry>
    <entry key="MSG_SL_MINMAX_VECT_S">Output[{0}]</entry>
    <entry key="MSG_SL_MINMAX_VECT_D">Logic to determine output element {0}</entry>
    
    <entry key="MSG_SL_MIN_IDX_A" translate="false" note="TranslateFalseBatch;">INi</entry>
    <entry key="MSG_SL_MIN_IDX_S">input {0}</entry>
    <entry key="MSG_SL_MIN_IDX_D">input {0} is the minimum</entry>
    
    <entry key="MSG_SL_MAX_IDX_A" translate="false" note="TranslateFalseBatch;">INi</entry>
    <entry key="MSG_SL_MAX_IDX_S">input {0}</entry>
    <entry key="MSG_SL_MAX_IDX_D">input {0} is the maximum</entry>
      
    <entry key="MSG_SL_MIN_ELEM_IDX_A" translate="false" note="TranslateFalseBatch;">INELEMi</entry>
    <entry key="MSG_SL_MIN_ELEM_IDX_S">input element {0}</entry>
    <entry key="MSG_SL_MIN_ELEM_IDX_D">input element {0} is the minimum</entry>
    
    <entry key="MSG_SL_MAX_ELEM_IDX_A" translate="false" note="TranslateFalseBatch;">INELEMi</entry>
    <entry key="MSG_SL_MAX_ELEM_IDX_S">input element {0}</entry>
    <entry key="MSG_SL_MAX_ELEM_IDX_D">input element {0} is the maximum</entry>

    <entry key="MSG_SL_MIN_IDX_COLLAPSED_A" translate="false" note="TranslateFalseBatch;">INCOLLAPSEDi</entry>
    <entry key="MSG_SL_MIN_IDX_COLLAPSED_S">input {0} across collapsed dimension</entry>
    <entry key="MSG_SL_MIN_IDX_COLLAPSED_D">input {0} across collapsed dimension is the minimum</entry>
    
    <entry key="MSG_SL_MAX_IDX_COLLAPSED_A" translate="false" note="TranslateFalseBatch;">INCOLLAPSEDi</entry>
    <entry key="MSG_SL_MAX_IDX_COLLAPSED_S">input {0} across collapsed dimension</entry>
    <entry key="MSG_SL_MAX_IDX_COLLAPSED_D">input {0} across collapsed dimension is the maximum</entry>

    <entry key="MSG_SL_MIN_RELBOUNDARY_SCAL_BEFORE_A" translate="false" note="TranslateFalseBatch;">in - min(before)</entry>
    <entry key="MSG_SL_MIN_RELBOUNDARY_SCAL_BEFORE_S">input {0} - min(inputs before input {0})</entry>
    <entry key="MSG_SL_MIN_RELBOUNDARY_SCAL_BEFORE_D">input {0} - min(inputs before input {0})</entry>

    <entry key="MSG_SL_MIN_RELBOUNDARY_SCAL_AFTER_A" translate="false" note="TranslateFalseBatch;">in - min(after)</entry>
    <entry key="MSG_SL_MIN_RELBOUNDARY_SCAL_AFTER_S">input {0} - min(inputs after input {0})</entry>
    <entry key="MSG_SL_MIN_RELBOUNDARY_SCAL_AFTER_D">input {0} - min(inputs after input {0})</entry>

    <entry key="MSG_SL_MIN_RELBOUNDARY_SCAL_VECT_BEFORE_A" translate="false" note="TranslateFalseBatch;">in - min(input elements i before)</entry>
    <entry key="MSG_SL_MIN_RELBOUNDARY_SCAL_VECT_BEFORE_S">input {0} - min(input elements {1} before input {0})</entry>
    <entry key="MSG_SL_MIN_RELBOUNDARY_SCAL_VECT_BEFORE_D">input {0} - min(input elements {1} before input {0})</entry>

    <entry key="MSG_SL_MIN_RELBOUNDARY_SCAL_VECT_AFTER_A" translate="false" note="TranslateFalseBatch;">in - min(input elements i after)</entry>
    <entry key="MSG_SL_MIN_RELBOUNDARY_SCAL_VECT_AFTER_S">input {0} - min(input elements {1} after input {0})</entry>
    <entry key="MSG_SL_MIN_RELBOUNDARY_SCAL_VECT_AFTER_D">input {0} - min(input elements {1} after input {0})</entry>

    <entry key="MSG_SL_MIN_RELBOUNDARY_VECT_VECT_BEFORE_A" translate="false" note="TranslateFalseBatch;">in i - min(input elements i before)</entry>
    <entry key="MSG_SL_MIN_RELBOUNDARY_VECT_VECT_BEFORE_S">input {0}({1}) - min(input elements {1} before input {0})</entry>
    <entry key="MSG_SL_MIN_RELBOUNDARY_VECT_VECT_BEFORE_D">input {0}({1}) - min(input elements {1} before input {0})</entry>

    <entry key="MSG_SL_MIN_RELBOUNDARY_VECT_VECT_AFTER_A" translate="false" note="TranslateFalseBatch;">in i - min(input elements i after)</entry>
    <entry key="MSG_SL_MIN_RELBOUNDARY_VECT_VECT_AFTER_S">input {0}({1}) - min(input elements {1} after input {0})</entry>
    <entry key="MSG_SL_MIN_RELBOUNDARY_VECT_VECT_AFTER_D">input {0}({1}) - min(input elements {1} after input {0})</entry>

    <entry key="MSG_SL_MAX_RELBOUNDARY_SCAL_BEFORE_A" translate="false" note="TranslateFalseBatch;">in - max(before)</entry>
    <entry key="MSG_SL_MAX_RELBOUNDARY_SCAL_BEFORE_S">input {0} - max(inputs before input {0})</entry>
    <entry key="MSG_SL_MAX_RELBOUNDARY_SCAL_BEFORE_D">input {0} - max(inputs before input {0})</entry>

    <entry key="MSG_SL_MAX_RELBOUNDARY_SCAL_AFTER_A" translate="false" note="TranslateFalseBatch;">in - max(after)</entry>
    <entry key="MSG_SL_MAX_RELBOUNDARY_SCAL_AFTER_S">input {0} - max(inputs after input {0})</entry>
    <entry key="MSG_SL_MAX_RELBOUNDARY_SCAL_AFTER_D">input {0} - max(inputs after input {0})</entry>

    <entry key="MSG_SL_MAX_RELBOUNDARY_SCAL_VECT_BEFORE_A" translate="false" note="TranslateFalseBatch;">in - max(input elements i before)</entry>
    <entry key="MSG_SL_MAX_RELBOUNDARY_SCAL_VECT_BEFORE_S">input {0} - max(input elements {1} before input {0})</entry>
    <entry key="MSG_SL_MAX_RELBOUNDARY_SCAL_VECT_BEFORE_D">input {0} - max(input elements {1} before input {0})</entry>

    <entry key="MSG_SL_MAX_RELBOUNDARY_SCAL_VECT_AFTER_A" translate="false" note="TranslateFalseBatch;">in - max(input elements i after)</entry>
    <entry key="MSG_SL_MAX_RELBOUNDARY_SCAL_VECT_AFTER_S">input {0} - max(input elements {1} after input {0})</entry>
    <entry key="MSG_SL_MAX_RELBOUNDARY_SCAL_VECT_AFTER_D">input {0} - max(input elements {1} after input {0})</entry>

    <entry key="MSG_SL_MAX_RELBOUNDARY_VECT_VECT_BEFORE_A" translate="false" note="TranslateFalseBatch;">in i - max(input elements i before)</entry>
    <entry key="MSG_SL_MAX_RELBOUNDARY_VECT_VECT_BEFORE_S">input {0}({1}) - max(input elements {1} before input {0})</entry>
    <entry key="MSG_SL_MAX_RELBOUNDARY_VECT_VECT_BEFORE_D">input {0}({1}) - max(input elements {1} before input {0})</entry>

    <entry key="MSG_SL_MAX_RELBOUNDARY_VECT_VECT_AFTER_A" translate="false" note="TranslateFalseBatch;">in i - max(input elements i after)</entry>
    <entry key="MSG_SL_MAX_RELBOUNDARY_VECT_VECT_AFTER_S">input {0}({1}) - max(input elements {1} after input {0})</entry>
    <entry key="MSG_SL_MAX_RELBOUNDARY_VECT_VECT_AFTER_D">input {0}({1}) - max(input elements {1} after input {0})</entry>

    <entry key="MSG_SL_MIN_RELBOUNDARY_AFTER_COLLAPSED_A" translate="false" note="TranslateFalseBatch;">in i - min(input elements i after collapsed)</entry>
    <entry key="MSG_SL_MIN_RELBOUNDARY_AFTER_COLLAPSED_S">input element {0} - min(input elements after input element {0} across collapsed dimension)</entry>
    <entry key="MSG_SL_MIN_RELBOUNDARY_AFTER_COLLAPSED_D">input element {0} - min(input elements after input element {0} across collapsed dimension)</entry>

    <entry key="MSG_SL_MIN_RELBOUNDARY_BEFORE_COLLAPSED_A" translate="false" note="TranslateFalseBatch;">in i - min(input elements i before collapsed)</entry>
    <entry key="MSG_SL_MIN_RELBOUNDARY_BEFORE_COLLAPSED_S">input element {0} - min(input elements before input element {0} across collapsed dimension)</entry>
    <entry key="MSG_SL_MIN_RELBOUNDARY_BEFORE_COLLAPSED_D">input element {0} - min(input elements before input element {0} across collapsed dimension)</entry>

    <entry key="MSG_SL_MAX_RELBOUNDARY_AFTER_COLLAPSED_A" translate="false" note="TranslateFalseBatch;">in i - max(input elements i after collapsed)</entry>
    <entry key="MSG_SL_MAX_RELBOUNDARY_AFTER_COLLAPSED_S">input element {0} - max(input elements after input element {0} across collapsed dimension)</entry>
    <entry key="MSG_SL_MAX_RELBOUNDARY_AFTER_COLLAPSED_D">input element {0} - max(input elements after input element {0} across collapsed dimension)</entry>

    <entry key="MSG_SL_MAX_RELBOUNDARY_BEFORE_COLLAPSED_A" translate="false" note="TranslateFalseBatch;">in i - max(input elements i before collapsed)</entry>
    <entry key="MSG_SL_MAX_RELBOUNDARY_BEFORE_COLLAPSED_S">input element {0} - max(input elements before input element {0} across collapsed dimension)</entry>
    <entry key="MSG_SL_MAX_RELBOUNDARY_BEFORE_COLLAPSED_D">input element {0} - max(input elements before input element {0} across collapsed dimension)</entry>
    
    

    <!-- Signum Block -->
    <entry key="MSG_SL_SIGNUM_SCAL_A" translate="false" note="TranslateFalseBatch;">Out LGC</entry>
    <entry key="MSG_SL_SIGNUM_SCAL_S">Output</entry>
    <entry key="MSG_SL_SIGNUM_SCAL_D">Logic to determine output</entry>
    
    <entry key="MSG_SL_SIGNUM_VECT_A" translate="false" note="TranslateFalseBatch;">OUTi LGC</entry>
    <entry key="MSG_SL_SIGNUM_VECT_S">Output[{0}]</entry>
    <entry key="MSG_SL_SIGNUM_VECT_D">Logic to determine output element {0}</entry>
      
    <entry key="MSG_SL_SIGNUM_OUTCOME_NEGATIVE_A" translate="false" note="TranslateFalseBatch;">INPUT NEGATIVE</entry>
    <entry key="MSG_SL_SIGNUM_OUTCOME_NEGATIVE_S">-1</entry>
    <entry key="MSG_SL_SIGNUM_OUTCOME_NEGATIVE_D">input is negative</entry>
      
    <entry key="MSG_SL_SIGNUM_OUTCOME_ZERO_A" translate="false" note="TranslateFalseBatch;">INPUT ZERO</entry>
    <entry key="MSG_SL_SIGNUM_OUTCOME_ZERO_S">0</entry>
    <entry key="MSG_SL_SIGNUM_OUTCOME_ZERO_D">input is zero</entry>

    <entry key="MSG_SL_SIGNUM_OUTCOME_POSITIVE_A" translate="false" note="TranslateFalseBatch;">INPUT POSITIVE</entry>
    <entry key="MSG_SL_SIGNUM_OUTCOME_POSITIVE_S">1</entry>
    <entry key="MSG_SL_SIGNUM_OUTCOME_POSITIVE_D">input is positive</entry>

    <entry key="MSG_SL_SIGNUM_REL_SCAL_A" translate="false" note="TranslateFalseBatch;">input - 0 </entry>
    <entry key="MSG_SL_SIGNUM_REL_SCAL_S">input {0} 0 </entry>
    <entry key="MSG_SL_SIGNUM_REL_SCAL_D">input {0} 0</entry>

    <entry key="MSG_SL_SIGNUM_REL_VECT_A" translate="false" note="TranslateFalseBatch;">input[i] - 0 </entry>
    <entry key="MSG_SL_SIGNUM_REL_VECT_S">input({0}) {1} 0 </entry>
    <entry key="MSG_SL_SIGNUM_REL_VECT_D">input({0}) {1} 0</entry>

    <!-- ASIN ACOS Block -->
    <entry key="MSG_SL_ASINACOS_SCAL_A" translate="false" note="TranslateFalseBatch;">Out LGC</entry>
    <entry key="MSG_SL_ASINACOS_SCAL_S">Output</entry>
    <entry key="MSG_SL_ASINACOS_SCAL_D">Logic to determine output</entry>

    <entry key="MSG_SL_ASINACOS_VECT_A" translate="false" note="TranslateFalseBatch;">OUTi LGC</entry>
    <entry key="MSG_SL_ASINACOS_VECT_S">Output[{0}]</entry>
    <entry key="MSG_SL_ASINACOS_VECT_D">Logic to determine output element {0}</entry>

    <entry key="MSG_SL_ASINACOS_OUTCOME_MINUSONE_A" translate="false" note="TranslateFalseBatch;">INPUT IS LESS THAN -1</entry>
    <entry key="MSG_SL_ASINACOS_OUTCOME_MINUSONE_S">less than -1</entry>
    <entry key="MSG_SL_ASINACOS_OUTCOME_MINUSONE_D">input is less than -1</entry>

    <entry key="MSG_SL_ASINACOS_OUTCOME_NUMBER_A" translate="false" note="TranslateFalseBatch;">INPUT IS BETWEEN -1 AND 1</entry>
    <entry key="MSG_SL_ASINACOS_OUTCOME_NUMBER_S">between -1 and 1</entry>
    <entry key="MSG_SL_ASINACOS_OUTCOME_NUMBER_D">input is between -1 and 1</entry>

    <entry key="MSG_SL_ASINACOS_OUTCOME_PLUSONE_A" translate="false" note="TranslateFalseBatch;">INPUT IS GREATER THAN 1</entry>
    <entry key="MSG_SL_ASINACOS_OUTCOME_PLUSONE_S">greater than 1</entry>
    <entry key="MSG_SL_ASINACOS_OUTCOME_PLUSONE_D">input is greater than 1</entry>

    <entry key="MSG_SL_ASINACOS_REL_SCAL_MINUSONE_A" translate="false" note="TranslateFalseBatch;">input - (-1) </entry>
    <entry key="MSG_SL_ASINACOS_REL_SCAL_MINUSONE_S">input {0} (-1) </entry>
    <entry key="MSG_SL_ASINACOS_REL_SCAL_MINUSONE_D">input {0} (-1)</entry>

    <entry key="MSG_SL_ASINACOS_REL_SCAL_PLUSONE_A" translate="false" note="TranslateFalseBatch;">input - 1 </entry>
    <entry key="MSG_SL_ASINACOS_REL_SCAL_PLUSONE_S">input {0} 1 </entry>
    <entry key="MSG_SL_ASINACOS_REL_SCAL_PLUSONE_D">input {0} 1</entry>

    <entry key="MSG_SL_ASINACOS_REL_VECT_MINUSONE_A" translate="false" note="TranslateFalseBatch;">input[i] - (-1) </entry>
    <entry key="MSG_SL_ASINACOS_REL_VECT_MINUSONE_S">input({0}) {1} (-1) </entry>
    <entry key="MSG_SL_ASINACOS_REL_VECT_MINUSONE_D">input({0}) {1} (-1)</entry>

    <entry key="MSG_SL_ASINACOS_REL_VECT_PLUSONE_A" translate="false" note="TranslateFalseBatch;">input[i] - 1 </entry>
    <entry key="MSG_SL_ASINACOS_REL_VECT_PLUSONE_S">input({0}) {1} 1 </entry>
    <entry key="MSG_SL_ASINACOS_REL_VECT_PLUSONE_D">input({0}) {1} 1</entry>

    <!-- Subsystem Block -->
    <entry key="MSG_SL_SUBSYS_FCALL_A" translate="false" note="TranslateFalseBatch;">FCALL</entry>
    <entry key="MSG_SL_SUBSYS_FCALL_S">Function call</entry>
    <entry key="MSG_SL_SUBSYS_FCALL_D">Function call</entry>
    
    <entry key="MSG_SL_SUBSYS_ENBLS_A" translate="false" note="TranslateFalseBatch;">IF (ENBL)</entry>
    <entry key="MSG_SL_SUBSYS_ENBLS_S">Enable</entry>
    <entry key="MSG_SL_SUBSYS_ENBLS_D">Enable control activated</entry>
    
    <entry key="MSG_SL_SUBSYS_ENBLV_A" translate="false" note="TranslateFalseBatch;">IF (ENBL)</entry>
    <entry key="MSG_SL_SUBSYS_ENBLV_S">Vector enable</entry>
    <entry key="MSG_SL_SUBSYS_ENBLV_D">subsystem enable expression, (enable(1) || enable(2) || ...)</entry>
    
    <entry key="MSG_SL_SUBSYS_RESETS_A" translate="false" note="TranslateFalseBatch;">IF (RESET)</entry>
    <entry key="MSG_SL_SUBSYS_RESETS_S">Reset</entry>
    <entry key="MSG_SL_SUBSYS_RESETS_D">Reset control activated</entry>

    <entry key="MSG_SL_SUBSYS_TRIGS_A" translate="false" note="TranslateFalseBatch;">IF (TRIG)</entry>
    <entry key="MSG_SL_SUBSYS_TRIGS_S">Trigger</entry>
    <entry key="MSG_SL_SUBSYS_TRIGS_D">trigger edge occurred</entry>

    <entry key="MSG_SL_SUBSYS_TRIGV_A" translate="false" note="TranslateFalseBatch;">IF (TRIG)</entry>
    <entry key="MSG_SL_SUBSYS_TRIGV_S">Vector trigger</entry>
    <entry key="MSG_SL_SUBSYS_TRIGV_D">trigger edge occurred</entry>

    <entry key="MSG_SL_SUBSYS_ENBLS_TRIGS_A" translate="false" note="TranslateFalseBatch;">IF (TRIG &amp; ENBL)</entry>
    <entry key="MSG_SL_SUBSYS_ENBLS_TRIGS_S" translate="false" note="TranslateFalseBatch;">IF (TRIG &amp; ENBL)</entry>
    <entry key="MSG_SL_SUBSYS_ENBLS_TRIGS_D">trigger edge occurred while enabled</entry>

    <entry key="MSG_SL_SUBSYS_ENBLS_TRIGV_A" translate="false" note="TranslateFalseBatch;">IF (TRIG &amp; ENBL)</entry>
    <entry key="MSG_SL_SUBSYS_ENBLS_TRIGV_S">IF (any TRIG &amp;&amp; ENBL)</entry>
    <entry key="MSG_SL_SUBSYS_ENBLS_TRIGV_D">trigger edge occurred while enabled</entry>
    
    <entry key="MSG_SL_SUBSYS_ENBLV_TRIGS_A" translate="false" note="TranslateFalseBatch;">IF (TRIG &amp; ENBL)</entry>
    <entry key="MSG_SL_SUBSYS_ENBLV_TRIGS_S">IF (TRIG &amp;&amp; any ENBL)</entry>
    <entry key="MSG_SL_SUBSYS_ENBLV_TRIGS_D">trigger edge occurred while (enable(1) || enable(2) || ...) is true</entry>

    <entry key="MSG_SL_SUBSYS_ENBLV_TRIGV_A" translate="false" note="TranslateFalseBatch;">IF (TRIG &amp; ENBL)</entry>
    <entry key="MSG_SL_SUBSYS_ENBLV_TRIGV_S">IF (any TRIG &amp;&amp; any ENBL)</entry>
    <entry key="MSG_SL_SUBSYS_ENBLV_TRIGV_D">trigger edge occurred while (enable(1) || enable(2) || ...) is true</entry>
    
    <entry key="MSG_SL_SUBSYS_ENBL_COND_A" translate="false" note="TranslateFalseBatch;">ENBL</entry>
    <entry key="MSG_SL_SUBSYS_ENBL_COND_S">Enable</entry>
    <entry key="MSG_SL_SUBSYS_ENBL_COND_D">enable</entry>

    <entry key="MSG_SL_SUBSYS_ENBLV_COND_A" translate="false" note="TranslateFalseBatch;">ENBL[i]</entry>
    <entry key="MSG_SL_SUBSYS_ENBLV_COND_S">Enable[{0}]</entry>
    <entry key="MSG_SL_SUBSYS_ENBLV_COND_D">enable({0})</entry>

    <entry key="MSG_SL_SUBSYS_TRIG_COND_A" translate="false" note="TranslateFalseBatch;">TRIG</entry>
    <entry key="MSG_SL_SUBSYS_TRIG_COND_S">Trigger</entry>
    <entry key="MSG_SL_SUBSYS_TRIG_COND_D">trigger edge occurred</entry>

    <entry key="MSG_SL_SUBSYS_TRIGV_COND_A" translate="false" note="TranslateFalseBatch;">TRIG[i]</entry>
    <entry key="MSG_SL_SUBSYS_TRIGV_COND_S">Trigger[{0}]</entry>
    <entry key="MSG_SL_SUBSYS_TRIGV_COND_D">trigger({0}) edge occurred</entry>
   
    
     <!-- Switch Block -->
    <entry key="MSG_SL_SWITCH_BOOL_SCAL_A" translate="false" note="TranslateFalseBatch;">IF TRIG</entry>
    <entry key="MSG_SL_SWITCH_BOOL_SCAL_S">Switch trigger</entry>
    <entry key="MSG_SL_SWITCH_BOOL_SCAL_D">logical trigger input</entry>
    
    <entry key="MSG_SL_SWITCH_BOOL_VECT_A" translate="false" note="TranslateFalseBatch;">If TRIG[i]</entry>
    <entry key="MSG_SL_SWITCH_BOOL_VECT_S">Switch trigger {0}</entry>
    <entry key="MSG_SL_SWITCH_BOOL_VECT_D">logical trigger input({0})</entry>
    
    <entry key="MSG_SL_SWITCH_REAL_SCAL_A" translate="false" note="TranslateFalseBatch;">TRIG >= THRESH</entry>
    <entry key="MSG_SL_SWITCH_REAL_SCAL_S">TRIGGER {0} THRESHOLD</entry>
    <entry key="MSG_SL_SWITCH_REAL_SCAL_D">trigger {0} threshold</entry>
    
    <entry key="MSG_SL_SWITCH_REAL_VECTU_A" translate="false" note="TranslateFalseBatch;">TRIG[i] >= THRESH</entry>
    <entry key="MSG_SL_SWITCH_REAL_VECTU_S">TRIGGER[{0}] {1} THRESHOLD</entry>
    <entry key="MSG_SL_SWITCH_REAL_VECTU_D">trigger({0}) {1} threshold</entry>
        
    <entry key="MSG_SL_SWITCH_REAL_VECTP_A" translate="false" note="TranslateFalseBatch;">TRIG >= THRESH[i]</entry>
    <entry key="MSG_SL_SWITCH_REAL_VECTP_S">TRIGGER {0} THRESHOLD[{1}]</entry>
    <entry key="MSG_SL_SWITCH_REAL_VECTP_D">trigger {0} threshold({1})</entry>
    
    <entry key="MSG_SL_SWITCH_REAL_VECTUP_A" translate="false" note="TranslateFalseBatch;">TRIG[i] >= THRESH[i]</entry>
    <entry key="MSG_SL_SWITCH_REAL_VECTUP_S">TRIGGER[{0}] {1} THRESHOLD[{2}]</entry>
    <entry key="MSG_SL_SWITCH_REAL_VECTUP_D">trigger({0}) {1} threshold({2})</entry>

    <entry key="MSG_SL_SWITCH_REAL_GT_SCAL_A" translate="false" note="TranslateFalseBatch;">TRIG > THRESH</entry>
    <entry key="MSG_SL_SWITCH_REAL_GT_SCAL_S">TRIGGER {0} THRESHOLD</entry>
    <entry key="MSG_SL_SWITCH_REAL_GT_SCAL_D">trigger {0} threshold</entry>
    
    <entry key="MSG_SL_SWITCH_REAL_GT_VECTU_A" translate="false" note="TranslateFalseBatch;">TRIG[i] > THRESH</entry>
    <entry key="MSG_SL_SWITCH_REAL_GT_VECTU_S">TRIGGER[{0}] {1} THRESHOLD</entry>
    <entry key="MSG_SL_SWITCH_REAL_GT_VECTU_D">trigger({0}) {1} threshold</entry>
        
    <entry key="MSG_SL_SWITCH_REAL_GT_VECTP_A" translate="false" note="TranslateFalseBatch;">TRIG > THRESH[i]</entry>
    <entry key="MSG_SL_SWITCH_REAL_GT_VECTP_S">TRIGGER {0} THRESHOLD[{1}]</entry>
    <entry key="MSG_SL_SWITCH_REAL_GT_VECTP_D">trigger {0} threshold({1})</entry>
    
    <entry key="MSG_SL_SWITCH_REAL_GT_VECTUP_A" translate="false" note="TranslateFalseBatch;">TRIG[i] > THRESH[i]</entry>
    <entry key="MSG_SL_SWITCH_REAL_GT_VECTUP_S">TRIGGER[{0}] {1} THRESHOLD[{2}]</entry>
    <entry key="MSG_SL_SWITCH_REAL_GT_VECTUP_D">trigger({0}) {1} threshold({2})</entry>
    
    <entry key="MSG_SL_SWITCH_OUTCOME_T_A" translate="false" note="TranslateFalseBatch;">T => IN1</entry>
    <entry key="MSG_SL_SWITCH_OUTCOME_T_S" translate="false" note="TranslateFalseBatch;">true (out = in1)</entry>
    <entry key="MSG_SL_SWITCH_OUTCOME_T_D">true (output is from 1st input port)</entry>
    
    <entry key="MSG_SL_SWITCH_OUTCOME_F_A" translate="false" note="TranslateFalseBatch;">F => IN3</entry>     
    <entry key="MSG_SL_SWITCH_OUTCOME_F_S" translate="false" note="TranslateFalseBatch;">false (out = in3)</entry> 
    <entry key="MSG_SL_SWITCH_OUTCOME_F_D">false (output is from 3rd input port)</entry>     
    
    <entry key="MSG_SL_SWITCH_REAL_SCAL_0_A" translate="false" note="TranslateFalseBatch;">TRIG - 0 </entry>
    <entry key="MSG_SL_SWITCH_REAL_SCAL_0_S">TRIGGER {0} 0</entry>
    <entry key="MSG_SL_SWITCH_REAL_SCAL_0_D">trigger {0} 0</entry>
    
    <entry key="MSG_SL_SWITCH_REAL_VECTU_0_A" translate="false" note="TranslateFalseBatch;">TRIG[i] - 0</entry>
    <entry key="MSG_SL_SWITCH_REAL_VECTU_0_S">TRIGGER[{0}] {1} 0</entry>
    <entry key="MSG_SL_SWITCH_REAL_VECTU_0_D">trigger({0}) {1} 0</entry>
        
    <entry key="MSG_SL_SWITCH_REAL_VECTP_0_A" translate="false" note="TranslateFalseBatch;">TRIG - 0[i]</entry>
    <entry key="MSG_SL_SWITCH_REAL_VECTP_0_S">TRIGGER {0} 0[{1}]</entry>
    <entry key="MSG_SL_SWITCH_REAL_VECTP_0_D">trigger {0} 0({1})</entry>
    
    <entry key="MSG_SL_SWITCH_REAL_VECTUP_0_A" translate="false" note="TranslateFalseBatch;">TRIG[i] - 0[i]</entry>
    <entry key="MSG_SL_SWITCH_REAL_VECTUP_0_S">TRIGGER[{0}] {1} 0[{2}]</entry>
    <entry key="MSG_SL_SWITCH_REAL_VECTUP_0_D">trigger({0}) {1} 0({2})</entry>
    
    <!-- Switch-Case Block-->
    <entry key="MSG_SL_SWTCHCASE_A" translate="false" note="TranslateFalseBatch;">Switch(in)</entry>
    <entry key="MSG_SL_SWTCHCASE_S">Switch input</entry>
    <entry key="MSG_SL_SWTCHCASE_D">truncated input</entry>   
    
    <entry key="MCG_SL_SWTCHCASE_OUTI_A">Case i</entry>   
    <entry key="MCG_SL_SWTCHCASE_OUTI_S" translate="false" note="TranslateFalseBatch;">{0}</entry>   
    <entry key="MCG_SL_SWTCHCASE_OUTI_D" translate="false" note="TranslateFalseBatch;">= {0}</entry>   

     <!-- Simscape Blocks-->
     <entry key="MSG_SC_MODE_A">Mode {0}</entry>
     <entry key="MSG_SC_MODE_S">Mode {0}</entry>
     <entry key="MSG_SC_MODE_D">Mode {0}</entry>

     <entry key="MSG_SC_MODE_OUTI_A">Mode m</entry>   
     <entry key="MSG_SC_MODE_OUTI_S">{0}</entry>   
     <entry key="MSG_SC_MODE_OUTI_D">{0}</entry>   
    
    <!-- Multiport Switch Block-->
    <entry key="MSG_SL_MPSWITCH_OUTCOME_PORT_A">Case i</entry>
    <entry key="MSG_SL_MPSWITCH_OUTCOME_PORT_S">Case {0} (out = in{1})</entry>
    <entry key="MSG_SL_MPSWITCH_OUTCOME_PORT_D">= {0} (output is from input port {1})</entry>
    
    <entry key="MSG_SL_MPSWITCH_OUTCOME_ELMNT_A">Case i</entry>
    <entry key="MSG_SL_MPSWITCH_OUTCOME_ELMNT_S">Case {0} (out = in[{1}])</entry>
    <entry key="MSG_SL_MPSWITCH_OUTCOME_ELMNT_D">= {0} (output is from input({1}))</entry>
    
    <entry key="MSG_SL_MPSWITCH_INT_SCAL_PORT_A" translate="false" note="TranslateFalseBatch;">SWITCH(IN0)</entry>
    <entry key="MSG_SL_MPSWITCH_INT_SCAL_PORT_S">Control input</entry>
    <entry key="MSG_SL_MPSWITCH_INT_SCAL_PORT_D">integer input value</entry>

    <entry key="MSG_SL_MPSWITCH_INT_SCAL_ELMNT_A" translate="false" note="TranslateFalseBatch;">SWITCH(IN0)</entry>
    <entry key="MSG_SL_MPSWITCH_INT_SCAL_ELMNT_S">Control input</entry>
    <entry key="MSG_SL_MPSWITCH_INT_SCAL_ELMNT_D">integer input value</entry>
    
    <entry key="MSG_SL_MPSWITCH_INT_VECT_A" translate="false" note="TranslateFalseBatch;">SWITCH(IN0[i])</entry>
    <entry key="MSG_SL_MPSWITCH_INT_VECT_S">Control input[{0}]</entry>
    <entry key="MSG_SL_MPSWITCH_INT_VECT_D">integer input({0}) value</entry>
    
    <entry key="MSG_SL_MPSWITCH_REAL_SCAL_PORT_A" translate="false" note="TranslateFalseBatch;">SWITCH(IN0)</entry>
    <entry key="MSG_SL_MPSWITCH_REAL_SCAL_PORT_S">Control input</entry>
    <entry key="MSG_SL_MPSWITCH_REAL_SCAL_PORT_D">truncated input value</entry>

    <entry key="MSG_SL_MPSWITCH_REAL_SCAL_ELMNT_A" translate="false" note="TranslateFalseBatch;">SWITCH(IN0)</entry>
    <entry key="MSG_SL_MPSWITCH_REAL_SCAL_ELMNT_S">Control input</entry>
    <entry key="MSG_SL_MPSWITCH_REAL_SCAL_ELMNT_D">truncated input value</entry>
        
    <entry key="MSG_SL_MPSWITCH_REAL_VECT_A" translate="false" note="TranslateFalseBatch;">SWITCH(IN0[i])</entry>
    <entry key="MSG_SL_MPSWITCH_REAL_VECT_S">Control input[{0}]</entry>
    <entry key="MSG_SL_MPSWITCH_REAL_VECT_D">truncated input({0}) value</entry>
    
    <!-- Generic Outcome Messages -->    
    
    <entry key="MSG_OUT_CALL_A">executed</entry>
    <entry key="MSG_OUT_CALL_S">executed</entry>
    <entry key="MSG_OUT_CALL_D">executed</entry>
    
    <!-- do not translate, it is MATLAB keyword  -->
    <entry key="MSG_OUT_IMPLICIT_DFLT_A"> implicit default</entry>
    <entry key="MSG_OUT_IMPLICIT_DFLT_S"> implicit default</entry>
    <entry key="MSG_OUT_IMPLICIT_DFLT_D"> implicit default</entry>
    
    <!-- do not translate, it is MATLAB keyword  -->
    <entry key="MSG_OUT_EXPLICIT_A"> otherwise</entry>
    <entry key="MSG_OUT_EXPLICIT_S"> otherwise</entry>
    <entry key="MSG_OUT_EXPLICIT_D"> otherwise</entry>
    
    <entry key="MSG_OUT_CASE_A" translate="false" note="TranslateFalseBatch;"> </entry>
    <entry key="MSG_OUT_CASE_S">Case {0}</entry>
    <entry key="MSG_OUT_CASE_D">Case {0}</entry>
    
    <entry key="MSG_OUT_GENERIC_TXT_A" translate="false" note="TranslateFalseBatch;">{0}</entry>
    <entry key="MSG_OUT_GENERIC_TXT_S" translate="false" note="TranslateFalseBatch;">{0}</entry>
    <entry key="MSG_OUT_GENERIC_TXT_D" translate="false" note="TranslateFalseBatch;">{0}</entry>
    
    <entry key="MSG_OUT_T_A" translate="false" note="TranslateFalseBatch;">T</entry>
    <entry key="MSG_OUT_T_S" translate="false" note="TranslateFalseBatch;">true</entry>
    <entry key="MSG_OUT_T_D" translate="false" note="TranslateFalseBatch;">true</entry>
    
    <entry key="MSG_OUT_F_A" translate="false" note="TranslateFalseBatch;">F</entry>
    <entry key="MSG_OUT_F_S" translate="false" note="TranslateFalseBatch;">false</entry>
    <entry key="MSG_OUT_F_D" translate="false" note="TranslateFalseBatch;">false</entry>
    
    <entry key="MSG_OUT_STATE_A">State i</entry>
    <entry key="MSG_OUT_STATE_S" translate="false" note="TranslateFalseBatch;">{0}</entry>
    <entry key="MSG_OUT_STATE_D">State {0}</entry>
    
    <entry key="MSG_CUSTOM_TXT_A" translate="false" note="TranslateFalseBatch;">{0}</entry>
    <entry key="MSG_CUSTOM_TXT_S" translate="false" note="TranslateFalseBatch;">{0}</entry>
    <entry key="MSG_CUSTOM_TXT_D" translate="false" note="TranslateFalseBatch;">{0}</entry>
    
    <!-- All blocks with parameter Saturate on integer overflow -->
	<entry key="MSG_SL_SATURATE_ON_INTEGER_OVERFLOW">Saturate on integer overflow</entry>


  </message>
</rsccat>
