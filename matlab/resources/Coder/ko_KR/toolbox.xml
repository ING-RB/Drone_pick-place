<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ko_KR" product="Coder" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="andOrXor_sizeMismatch">입력값은 크기가 동일해야 합니다.</entry>
    <entry key="sxfun_arrayDimensionsMustMatch">스칼라가 아닌 입력 배열은 차원이 서로 일치해야 합니다.</entry>
    <entry key="dimNotConst">차원 인수는 상수여야 합니다.</entry>
    <entry key="autoDimIncompatibility">Generated code expects a variable-size matrix but receives a variable-length vector. Specify the operating dimension explicitly or specify a variable-length vector at code generation time.</entry>
    <entry key="unsupportedClass">''{1}'' 클래스 값에 대해 함수 ''{0}''이(가) 정의되지 않았습니다.</entry>
    <entry key="eml_primes_core_InputOutOfRange">입력값이 너무 큽니다. 입력 클래스 ''{0}''에 허용되는 최댓값은 {1}입니다.</entry>
    <entry key="conv_2">입력값은 최대 하나의 가변 길이 차원을 갖는 벡터여야 하며, 그 차원은 첫 번째 또는 두 번째 차원이어야 합니다. 다른 모든 차원은 고정 길이 1을 가져야 합니다.</entry>
    <entry key="conv_3">A와 B는 벡터여야 합니다.</entry>
    <entry key="conv_6">SHAPE는 ''full'', ''same'', ''valid'' 중 하나여야 합니다.</entry>
    <entry key="conv_8">SHAPE는 ''full'', ''same'', ''valid'' 중 하나여야 합니다.</entry>
    <entry key="conv_dynamicVectorOrientation">출력 벡터 방향은 변경할 수 없습니다. 이 오류를 방지하려면 두 입력 벡터가 동일한 방향이 되도록 하십시오.</entry>
    <entry key="conv2_3">SHAPE는 ''full'', ''same'', ''valid'' 중 하나여야 합니다.</entry>
    <entry key="convn_2">SHAPE는 ''full'', ''same'', ''valid'' 중 하나여야 합니다.</entry>
    <entry key="corrcoef_2">파라미터 이름이 필요합니다.</entry>
    <entry key="corrcoef_3">입력값은 2차원이어야 합니다.</entry>
    <entry key="corrcoef_5">입력값은 2차원이어야 합니다.</entry>
    <entry key="corrcoef_7">복소수 입력값에 대한 p-값을 계산할 수 없습니다.</entry>
    <entry key="corrcoef_unsupportedRowVector">행 벡터 입력값은 처음 두 입력값이 벡터이고 비 스칼라인 경우에만 지원됩니다.</entry>
    <entry key="corrcoef_xyMismatch">X 입력값과 Y 입력값은 요소의 개수가 동일해야 합니다.</entry>
    <entry key="cov_3">세 번째 입력값은 고정 크기 스칼라여야 합니다.</entry>
    <entry key="cov_thirdInputRequired">스칼라 x와 스칼라 y의 공분산에 세 번째 입력값이 필요합니다. ''cov(x,y,0)''을 사용하십시오.</entry>
    <entry key="cov_vsizeMatrixIsVector">COV에 대한 가변 크기 행렬 입력값은 런타임에 벡터 입력값이 되지 않아야 합니다. 가변 길이 벡터를 대신 사용하십시오.</entry>
    <entry key="cumtrapz_6">DIM 인수는 상수여야 합니다.</entry>
    <entry key="Dec2HexInvalidDecimalArg">10진수 입력 인수는 숫자형이어야 합니다.</entry>
    <entry key="Dec2HexDecimalArgMustBeReal">10진수 입력 인수는 실수여야 합니다.</entry>
    <entry key="Dec2HexInvalidBitArg">두 번째 입력 인수는 양의 스칼라 숫자형 값이어야 합니다.</entry>
    <entry key="deconv_3">첫 번째 인수는 최대 하나의 가변 길이 차원을 갖는 벡터여야 하며, 그 차원은 첫 번째 또는 두 번째 차원이어야 합니다. 다른 모든 차원은 고정 길이 1을 가져야 합니다.</entry>
    <entry key="deconv_4">첫 번째 인수는 벡터여야 합니다.</entry>
    <entry key="deconv_6">두 번째 인수는 최대 하나의 가변 길이 차원을 갖는 벡터여야 하며, 그 차원은 첫 번째 또는 두 번째 차원이어야 합니다. 다른 모든 차원은 고정 길이 1을 가져야 합니다.</entry>
    <entry key="deconv_7">두 번째 인수는 벡터여야 합니다.</entry>
    <entry key="deconv_secondInputNotVector">두 번째 인수는 비어 있지 않은 벡터여야 합니다.</entry>
    <entry key="del2_2">첫 번째 입력값은 ''double'' 또는 ''single''이어야 합니다.</entry>
    <entry key="detrend_5">BP 벡터는 실수 숫자형이어야 합니다.</entry>
    <entry key="detrend_inputsMustBe2D">입력 인수는 2차원이어야 합니다.</entry>
    <entry key="detrend_rowVecSpecialCase">입력값이 가변 크기 행렬인데 런타임에 행 벡터가 되었습니다. 가변 길이 행 벡터를 대신 사용하십시오.</entry>
    <entry key="diff_2">입력값은 숫자형, 논리형, 문자형 중 하나여야 합니다.</entry>
    <entry key="diff_3">N은 상수여야 합니다.</entry>
    <entry key="diff_differenceOrderMustBePositiveInteger">Difference order N must be a positive integer scalar in the range 1 to intmax(''{0}'').</entry>
    <entry key="diff_orderLimitForVariableSizedX">입력값이 가변 크기이거나 차분 차수가 상수가 아닌 경우 작업 차원의 길이는 차분 차수보다 커야 합니다.</entry>
    <entry key="fft_2">입력 인수가 너무 많습니다.</entry>
    <entry key="fft2_2">MROWS를 지정할 경우, NCOLS도 지정해야 합니다.</entry>
    <entry key="filter_3">첫 번째 인수는 최대 하나의 가변 길이 차원을 갖는 벡터여야 하며, 그 차원은 첫 번째 또는 두 번째 차원이어야 합니다. 다른 모든 차원은 고정 길이 1을 가져야 합니다.</entry>
    <entry key="filter_4">첫 번째 인수는 벡터여야 합니다.</entry>
    <entry key="filter_7">두 번째 인수는 최대 하나의 가변 길이 차원을 갖는 벡터여야 하며, 그 차원은 첫 번째 또는 두 번째 차원이어야 합니다. 다른 모든 차원은 고정 길이 1을 가져야 합니다.</entry>
    <entry key="filter_8">두 번째 인수는 벡터여야 합니다.</entry>
    <entry key="filter_notVectorInputB">첫 번째 인수는 비어 있지 않은 벡터여야 합니다.</entry>
    <entry key="filter_secondInputNotVector">두 번째 인수는 비어 있지 않은 벡터여야 합니다.</entry>
    <entry key="filter2_2">알 수 없는 shape 파라미터입니다.</entry>
    <entry key="fscanfConstFormat">코드 생성 시 형식 지정자는 상수여야 합니다.</entry>
    <entry key="fscanfTooLong">64비트 숫자를 위한 공간이 부족하기 때문에 타깃 하드웨어에서 형식 접두사 'l'가 지원되지 않습니다.</entry>
    <entry key="fscanfInvalidConversion">코드 생성에는 형식 변환 지정자 ''{0}''이(가) 지원되지 않습니다.</entry>
    <entry key="fscanfRecommendChar">Format conversion specifier ''{0}'' is not supported for code generation. Use %c.</entry>
    <entry key="fscanfIncompltete"> 불완전한 형식입니다. 코드 생성 시 형식 지정자에 변환 지정자가 포함되어 있어야 합니다.</entry>
    <entry key="fscanfDollar">코드 생성 시 ''$''는 형식 지정자 내에서 지원되지 않습니다.</entry>
    <entry key="fscanfIllegalL">코드 생성 시 형식 접두사 ''l''는 변환 지정자 d, i, u, o, x와만 사용하십시오.</entry>
    <entry key="getfieldConstFields">코드 생성 시 상수가 아닌 필드 이름은 지원되지 않습니다. 코드를 생성하려면 상수 필드 이름을 대신 사용하십시오.</entry>
    <entry key="gradient_2">첫 번째 입력값은 ''double'' 또는 ''single''이어야 합니다.</entry>
    <entry key="gradient_tooManyOutputArguments">출력 인수 개수가 입력 배열의 차원 개수를 초과합니다.</entry>
    <entry key="hist_2">출력 인수가 부족합니다. 히스토그램 막대 플롯이 지원되지 않습니다.</entry>
    <entry key="hist_4">X는 고정 크기 스칼라 또는 벡터여야 합니다. X가 벡터인 경우, 최대 하나의 가변 길이 차원을 가질 수 있으며 그 차원은 첫 번째 또는 두 번째 차원이어야 합니다. 다른 모든 차원은 고정 길이 1을 가져야 합니다.</entry>
    <entry key="hist_5">X는 스칼라 또는 벡터여야 합니다.</entry>
    <entry key="hist_6">입력 인수는 ''double'', ''single'', ''logical'' 중 하나여야 합니다.</entry>
    <entry key="hist_7">입력값은 실수여야 합니다.</entry>
    <entry key="hist_8">스칼라 X는 상수여야 합니다.</entry>
    <entry key="hist_variableSizeScalarX">X가 가변 길이 벡터인 경우, 길이는 1이 아니어야 합니다. 스칼라 X는 고정 크기여야 합니다.</entry>
    <entry key="hist_vsizeMatrixBecameRowVec">가변 크기 입력 행렬 또는 N차원 배열은 런타임에 행 벡터가 되지 않아야 합니다.</entry>
    <entry key="histc_2">모든 입력값은 실수여야 합니다.</entry>
    <entry key="histc_3">첫 번째 입력값은 비희소 형식의 숫자형 배열이어야 합니다.</entry>
    <entry key="histc_4">두 번째 입력값은 숫자형이어야 합니다.</entry>
    <entry key="histc_6">두 번째 입력값은 열거형을 허용하지 않습니다</entry>
    <entry key="ifft_2">입력 인수가 너무 많습니다.</entry>
    <entry key="ifft_4">MATLAB 코드 생성에서는 ''nonsymmetric'' 옵션만 지원됩니다.</entry>
    <entry key="ifft2_2">입력 인수가 너무 많습니다.</entry>
    <entry key="ifft2_3">MATLAB 코드 생성에서는 ''nonsymmetric'' 옵션만 지원됩니다.</entry>
    <entry key="ifft2_4">MROWS를 지정할 경우, NCOLS도 지정해야 합니다.</entry>
    <entry key="ifftn_2">입력 인수가 너무 많습니다.</entry>
    <entry key="ifftn_3">MATLAB 코드 생성에서는 ''nonsymmetric'' 옵션만 지원됩니다.</entry>
    <entry key="issorted_2">''rows''를 지정하지 않은 경우, 입력값은 최대 하나의 가변 길이 차원을 갖는 벡터여야 하며 그 차원은 첫 번째 또는 두 번째 차원이어야 합니다. 다른 모든 차원은 고정 길이 1을 가져야 합니다.</entry>
    <entry key="issorted_3">입력값이 벡터이거나, ''rows''가 지정되어야 합니다.</entry>
    <entry key="issorted_4">알 수 없는 플래그</entry>
    <entry key="InvalidTypeNameInFAV">''{0}''은(는) 데이터형 또는 클래스 이름이 아니므로 함수 또는 속성 유효성 검사에 사용할 수 없습니다.</entry>
    <entry key="max_2">입력 인수가 너무 많습니다.</entry>
    <entry key="mean_specialEmpty">MEAN에 하나의 가변 크기 행렬 입력값 []을 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="MeanFlagNotSupported">코드 생성 시 MEAN에 ''flag'' 인수를 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="median_specialEmpty">MEDIAN에 하나의 가변 크기 행렬 입력값 []을 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="min_2">입력 인수가 너무 많습니다.</entry>
    <entry key="mode_2">세 번째 입력값은 지원되지 않습니다.</entry>
    <entry key="mode_specialEmpty">MODE에 하나의 가변 크기 행렬 인수 []을 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="now_unsupported">NOW is not supported in code generation. Use datetime('now') instead.</entry>
    <entry key="prod_6">''native'' 플래그와 ''double'' 플래그는 지원되지 않습니다.</entry>
    <entry key="prod_7">복소수형 정수 곱셈은 지원되지 않습니다.</entry>
    <entry key="prod_8">후행 입력값은 ''double'' 또는 ''native''여야 합니다.</entry>
    <entry key="prod_specialEmpty">PROD에는 하나의 가변 크기 행렬 입력값 []을 사용하는 것이 지원되지 않습니다.</entry>
    <entry key="setfieldConstFields">코드 생성 시 상수가 아닌 필드 이름은 지원되지 않습니다. 코드를 생성하려면 상수 필드 이름을 대신 사용하십시오.</entry>
    <entry key="sort_2">입력 인수가 너무 많습니다.</entry>
    <entry key="sort_4">SORT에 대한 복소수 입력값은 ''double'' 또는 ''single''이어야 합니다.</entry>
    <entry key="sortrows_3">SORTROWS에 대한 복소수 입력값은 ''double'' 또는 ''single''이어야 합니다.</entry>
    <entry key="sortrows_5">COL 입력값에는 열거형이 지원되지 않습니다.</entry>
    <entry key="sortrows_6">COL은 숫자형이어야 합니다.</entry>
    <entry key="std_2">입력 인수가 너무 많습니다.</entry>
    <entry key="inputSizeError">입력값은 행 수가 동일한 2차원 행렬이어야 합니다.</entry>
    <entry key="sum_6">문자형 배열에서는 네이티브 누적이 지원되지 않습니다.</entry>
    <entry key="sum_7">복소수형 정수 합은 지원되지 않습니다.</entry>
    <entry key="sum_8">후행 입력값은 ''double'' 또는 ''native''여야 합니다.</entry>
    <entry key="sum_specialEmpty">SUM에 하나의 가변 크기 행렬 입력값 []을 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="trapz_specialEmpty">TRAPZ에 하나의 가변 크기 행렬 입력값 []을 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="var_specialEmpty">VAR에 하나의 가변 크기 행렬 입력값 []을 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="int64_1">MATLAB 코드 생성에서는 ''Int64'' 클래스로의 형변환이 지원되지 않습니다.</entry>
    <entry key="typecast_2">첫 번째 입력 인수는 비희소(Full) 형식이어야 하며, 복소수가 아닌 숫자형 값이어야 합니다.</entry>
    <entry key="typecast_3">첫 번째 인수는 최대 하나의 가변 길이 차원을 갖는 벡터여야 하며, 그 차원은 첫 번째 또는 두 번째 차원이어야 합니다. 다른 모든 차원은 고정 길이 1을 가져야 합니다.</entry>
    <entry key="typecast_4">첫 번째 입력 인수는 벡터여야 합니다.</entry>
    <entry key="typecast_6">지원되지 않는 클래스입니다.</entry>
    <entry key="TypecastNativeType">Class {1} does not map to a {0,number,integer}-bit C type.</entry>
    <entry key="uint64_1">MATLAB 코드 생성에서는 ''unit64'' 클래스로의 형변환이 지원되지 않습니다.</entry>
    <entry key="ElFunDomainError">도메인 오류입니다. 실수 x로부터 복소수 결과를 계산하려면 ''{0}(complex(x))''를 사용하십시오.</entry>
    <entry key="reallog_3">입력값은 실수여야 합니다.</entry>
    <entry key="realpow_4">입력값은 실수여야 합니다.</entry>
    <entry key="realsqrt_3">입력값은 실수여야 합니다.</entry>
    <entry key="unwrap_2">첫 번째 입력값은 ''double'' 또는 ''single''이어야 합니다.</entry>
    <entry key="unwrap_3">두 번째 입력값은 부동소수점 스칼라 또는 []이어야 합니다.</entry>
    <entry key="bsxfun_2">첫 번째 인수는 함수 핸들이어야 합니다.</entry>
    <entry key="bsxfun_dynamicExpansion">확장은 두 입력 인수 중 하나가 고정 길이 1인 차원에서만 지원됩니다.</entry>
    <entry key="cat_10">열거형 클래스로의 묵시적 변환은 지원되지 않습니다. 모든 입력값은 동일한 유형의 열거형이어야 합니다.</entry>
    <entry key="cat_6">열거형인 입력값이 하나라도 있으면, 모든 입력값이 동일한 유형의 열거형이어야 합니다.</entry>
    <entry key="cat_8">논리형에서 문자형으로 변환할 수 없습니다.</entry>
    <entry key="cat_9">열거형에서 문자형으로 변환하는 것은 지원되지 않습니다.</entry>
    <entry key="cat_UnsupportedEmptyEnumArray">이 함수는 빈 열거형 배열 생성을 지원하지 않습니다.</entry>
    <entry key="cat_UnsupportedVariableSizeEmpty">CAT 인수는 가변 크기의 빈 배열일 수 없습니다.</entry>
    <entry key="cat_IncompatibleTypes">Variable-size cell array types must be compatible for concatenation.</entry>
    <entry key="cat_cellAndRuntimeEmptyNonCell"> In code generation, when a cell array and a variable-size non cell argument are concatenated, the non cell argument must not become an empty array at runtime.</entry>
    <entry key="circshift_InvalidShiftType">유효하지 않은 시프트 인수입니다. -intmax(''{0}'')과(와) intmax(''{1}'') 사이의 요소를 갖는 유한한 실수형 정수 벡터여야 합니다.</entry>
    <entry key="compan_2">compan에 대한 입력값은 부동소수점, 즉 single형 또는 double형이어야 합니다.</entry>
    <entry key="diag_2">첫 번째 입력값은 2차원이어야 합니다.</entry>
    <entry key="diag_3">첫 번째 입력값은 숫자형, 논리형, 문자형 중 하나여야 합니다.</entry>
    <entry key="diag_4">K번째 대각선 입력값은 상수여야 합니다.</entry>
    <entry key="diag_KmustBeRealIntScalar">K번째 대각선 입력값은 실수형 정수 스칼라여야 합니다.</entry>
    <entry key="diag_varsizedMatrixVector">Vector input to DIAG can only have one variable-length dimension. All other dimensions must have a fixed length of 1.</entry>
    <entry key="spdiagsScalarSize">Output dimension ''{0}'' must be a scalar.</entry>
    <entry key="spdiagsBadSize">Output dimension ''{0}'' must be a real, nonnegative integer.</entry>
    <entry key="eps_1">클래스는 ''single'' 또는 ''double''이어야 함</entry>
    <entry key="eye_1">인수가 너무 많습니다.</entry>
    <entry key="eye_3">이 입력값은 유효한 숫자형 클래스 이름이어야 합니다.</entry>
    <entry key="eye_rowVectorMustBeLength2">크기 벡터 입력은 길이가 2인 행 벡터여야 합니다</entry>
    <entry key="find_1">To use 'find', enable variable sizing.</entry>
    <entry key="find_4">유효하지 않은 검색 옵션입니다. ''first'' 또는 ''last''여야 합니다.</entry>
    <entry key="FindVectorOrientationMismatch">FIND에 대한 가변 크기 배열 입력값이 런타임에 행 벡터로 축소되었습니다. 코드 생성에서 FIND의 출력값은 열 벡터입니다.</entry>
    <entry key="flipdim_1">인수가 두 개 필요합니다.</entry>
    <entry key="freqspace_2">N이 고정 크기를 가져야 합니다.</entry>
    <entry key="freqspace_3">N은 스칼라 또는 요소를 2개 가진 벡터여야 합니다.</entry>
    <entry key="freqspace_4">단일 출력값의 경우 입력값 N은 스칼라여야 합니다.</entry>
    <entry key="freqspace_5">첫 번째 입력값은 상수여야 합니다.</entry>
    <entry key="freqspace_6">N은 실수여야 합니다.</entry>
    <entry key="freqspace_8">두 번째 인수는 문자형 벡터여야 합니다.</entry>
    <entry key="hadamard_2">첫 번째 인수는 상수여야 합니다.</entry>
    <entry key="hadamard_3">첫 번째 인수는 스칼라여야 합니다.</entry>
    <entry key="hadamard_NmustBePosInt">첫 번째 인수는 인덱싱 범위 내에 있는 양의 정수여야 합니다.</entry>
    <entry key="hankel_2">첫 번째 입력값은 숫자형이어야 합니다.</entry>
    <entry key="hankel_4">두 번째 입력값은 숫자형이어야 합니다.</entry>
    <entry key="hankel_5">정수는 같은 클래스의 정수나 double형 스칼라와만 결합될 수 있습니다.</entry>
    <entry key="hankel_emptyC">첫 번째 입력값은 비어 있지 않아야 합니다.</entry>
    <entry key="hankel_emptyR">두 번째 입력값은 비어 있지 않아야 합니다.</entry>
    <entry key="hilb_2">첫 번째 인수는 상수여야 합니다.</entry>
    <entry key="hilb_3">첫 번째 인수는 실수형 정수 스칼라여야 합니다.</entry>
    <entry key="hilb_5">두 번째 입력값은 ''double'' 또는 ''single''이어야 합니다.</entry>
    <entry key="hilb_argMustBeRealIntScalar">첫 번째 인수는 실수형 정수 스칼라여야 합니다.</entry>
    <entry key="ind2sub_2">첫 번째 입력값은 고정 크기여야 합니다.</entry>
    <entry key="ind2sub_3">크기 인수는 숫자형이어야 합니다.</entry>
    <entry key="ind2sub_4">출력 인수가 너무 많습니다.</entry>
    <entry key="intmax_1">입력값은 정수 클래스의 이름이어야 합니다.</entry>
    <entry key="intmax_2">유효하지 않은 클래스 이름입니다.</entry>
    <entry key="intmin_1">입력값은 정수 클래스의 이름이어야 합니다.</entry>
    <entry key="intmin_2">유효하지 않은 클래스 이름입니다.</entry>
    <entry key="invhilb_2">첫 번째 인수는 상수여야 합니다.</entry>
    <entry key="invhilb_3">첫 번째 인수는 실수형 정수 스칼라여야 합니다.</entry>
    <entry key="invhilb_5">두 번째 입력값은 ''double'' 또는 ''single''이어야 합니다.</entry>
    <entry key="invhilb_argMustBeRealIntScalar">첫 번째 인수는 실수형 정수 스칼라여야 합니다.</entry>
    <entry key="ipermute_2">유효하지 않은 데이터형입니다. 차원 순서 벡터에서는 열거형이 지원되지 않습니다.</entry>
    <entry key="ipermute_3">차원 순서는 상수여야 합니다.</entry>
    <entry key="ipermute_invalidPermutation">차원 순서 벡터에 유효하지 않은 치환 인덱스가 포함되어 있습니다. 차원 순서는 정수 1:N의 치환이어야 합니다. 여기서 N은 입력 배열의 차원 수보다 크거나 같습니다.</entry>
    <entry key="ipermute_orderNeedsNElements">차원 순서 벡터는 N차원 배열에 대해 최소 N개 요소를 가져야 합니다.</entry>
    <entry key="linspace_2">입력값 d1은 스칼라 부동소수점 값이어야 합니다.</entry>
    <entry key="linspace_3">입력값 d2는 스칼라 부동소수점 값이어야 합니다.</entry>
    <entry key="linspace_4">Number of points must be constant when variable sizing is disabled.</entry>
    <entry key="linspace_5">N must be a real, numeric scalar.</entry>
    <entry key="logspace_2">입력값 d1은 스칼라 부동소수점 값이어야 합니다.</entry>
    <entry key="logspace_3">입력값 d2는 스칼라 부동소수점 값이어야 합니다.</entry>
    <entry key="logspace_4">점의 개수 N은 상수여야 합니다.</entry>
    <entry key="logspace_invalidN">점의 개수 N은 양의 실수형 정수여야 합니다.</entry>
    <entry key="piSpecialSupported">pi의 특수한 사례는 지원되지 않습니다. 원하는 경우 logspace(a,log10(pi),n)을 사용하십시오.</entry>
    <entry key="ltitr_inputsMustBe2D">입력 인수는 2차원이어야 합니다.</entry>
    <entry key="magic_2">인수는 상수여야 합니다. MAGIC은 가변 크기 출력값을 지원하지 않습니다.</entry>
    <entry key="magic_3">인수는 상수여야 합니다.</entry>
    <entry key="magic_argMustBeRealIntScalar">인수는 실수형 정수 스칼라여야 합니다.</entry>
    <entry key="ndgrid_2">출력 인수가 너무 많습니다.</entry>
    <entry key="pascal_2">세 번째 입력값은 ''double'' 또는 ''single''이어야 합니다.</entry>
    <entry key="pascal_nMustBeNonNegativeInteger">''pascal''에 대한 첫 번째 인수는 음이 아닌 정수여야 합니다.</entry>
    <entry key="permute_2">유효하지 않은 데이터형입니다. 차원 순서 벡터에서는 열거형이 지원되지 않습니다.</entry>
    <entry key="permute_3">차원 순서는 상수여야 합니다.</entry>
    <entry key="permute_4">Dimension order vector must be fixed size.</entry>
    <entry key="permute_5">차원 순서 벡터는 N차원 배열에 대해 최소 N개 요소를 가져야 합니다.</entry>
    <entry key="permute_invalidPermutation">Dimension order vector contains an invalid permutation index. Dimension order must be a permutation of the integers 1:N, where N is greater than or equal to the number of dimensions of the input array.</entry>
    <entry key="permute_heterogenousCell">차원 순서는 이종 셀형 배열 입력값에 대해 상수여야 합니다.</entry>
    <entry key="rand_1">입력 인수가 너무 많습니다.</entry>
    <entry key="rand_10">출력값 클래스는 ''single'' 또는 ''double''이어야 합니다.</entry>
    <entry key="rand_2">출력 인수가 너무 많습니다.</entry>
    <entry key="rand_3">입력값은 숫자형이어야 합니다.</entry>
    <entry key="rand_4">명령 옵션은 상수 문자형 벡터여야 합니다.</entry>
    <entry key="rand_5">코드 생성 시 swb2712(''state'') 균일 난수 생성기는 지원되지 않습니다.</entry>
    <entry key="rand_6">상태는 고정 크기여야 합니다.</entry>
    <entry key="rand_8">알 수 없는 명령 옵션입니다.</entry>
    <entry key="rand_9">후행 출력값 클래스 인수는 상수 문자형 벡터여야 합니다.</entry>
    <entry key="randn_1">입력 인수가 너무 많습니다.</entry>
    <entry key="randn_10">출력값 클래스는 ''single'' 또는 ''double''이어야 합니다.</entry>
    <entry key="randn_2">출력 인수가 너무 많습니다.</entry>
    <entry key="randn_3">입력값은 숫자형이어야 합니다.</entry>
    <entry key="randn_4">명령 옵션은 상수 문자형 벡터여야 합니다.</entry>
    <entry key="randn_5">시드(Seed) 또는 상태 입력값은 고정 크기여야 합니다.</entry>
    <entry key="randn_6">시드(Seed)는 double형 스칼라여야 합니다.</entry>
    <entry key="randn_7">상태는 double형 스칼라 또는 RANDN(''state'')의 출력값이어야 합니다.</entry>
    <entry key="randn_8">알 수 없는 명령 옵션입니다.</entry>
    <entry key="randn_9">후행 출력값 클래스 인수는 상수 문자형 벡터여야 합니다.</entry>
    <entry key="RandStreamPropNotImplemented">Code generation does not support the RandStream property ''{0}''.</entry>
    <entry key="RandStreamConstType">''Type'' 인수는 상수 문자형 벡터여야 합니다.</entry>
    <entry key="RandStreamConstNormalTransform">''NormalTransform'' 인수는 상수 문자형 벡터여야 합니다.</entry>
    <entry key="RandStreamNoShuffle">코드 생성 시 ''Seed''를 ''shuffle''로 지정하여 RandStream 객체를 만들 수 없습니다.</entry>
    <entry key="RandStreamUndefined">유형이 RandStream인 입력값에 메서드 ''{0}''을(를) 호출하는 것은 허용되지 않습니다.</entry>
    <entry key="RandStreamFixedSizeState">코드 생성 시 RandStream ''State'' 속성을 가변 크기 배열로 설정하는 것은 지원되지 않습니다. 해당 상태를 또다른 RandStream 인스턴스로부터 얻은 고정 크기 배열로 설정하십시오.</entry>
    <entry key="realmax_1">입력값은 클래스 이름이어야 합니다.</entry>
    <entry key="realmax_2">입력값은 ''single'' 또는 ''double''이어야 합니다.</entry>
    <entry key="realmin_1">입력값은 클래스 이름이어야 합니다.</entry>
    <entry key="realmin_2">입력값은 ''single'' 또는 ''double''이어야 합니다.</entry>
    <entry key="reshape_4">크기 인수는 정수 스칼라여야 합니다.</entry>
    <entry key="reshape_emptyReshapeLimit">To RESHAPE the number of elements must not change, and if the input is empty, the maximum dimension length cannot be increased unless the output size is fixed.</entry>
    <entry key="rot90_2">k 입력값에는 열거형이 지원되지 않습니다.</entry>
    <entry key="rot90_3">k는 스칼라여야 합니다.</entry>
    <entry key="rot90_4">k는 상수여야 합니다.</entry>
    <entry key="shiftdim_3">두 번째 입력 인수에는 열거형이 지원되지 않습니다.</entry>
    <entry key="shiftdim_4">두 번째 인수는 상수여야 합니다.</entry>
    <entry key="shiftdim_autoDimIncompatibility">생성된 코드에는 가변 크기의 행렬이 필요한데 가변 길이의 벡터를 받고 있습니다. 이동할 위치의 개수를 명시적으로 지정하십시오.</entry>
    <entry key="shiftdim_invalidNshifts">두 번째 인수는 비어 있거나 실수형 정수 스칼라여야 합니다.</entry>
    <entry key="shiftdim_wrongNDims">시프트 수가 제공되었고 그 수가 양수일 경우 첫 번째 입력 인수는 항상 차원 수가 동일해야 합니다.</entry>
    <entry key="sub2ind_2">크기 인수는 숫자형이어야 합니다.</entry>
    <entry key="sub2ind_3">첫 번째 입력값은 고정 크기여야 합니다.</entry>
    <entry key="vander_argNotVector">인수는 벡터여야 합니다.</entry>
    <entry key="wilkinson_2">첫 번째 인수는 상수여야 합니다.</entry>
    <entry key="wilkinson_3">첫 번째 인수는 실수형 정수 스칼라여야 합니다.</entry>
    <entry key="wilkinson_5">두 번째 입력값은 ''double'' 또는 ''single''이어야 합니다.</entry>
    <entry key="wilkinson_argMustBeRealIntScalar">첫 번째 인수는 실수형 정수 스칼라여야 합니다.</entry>
    <entry key="eml_refblas_xgemv_2">EML_REFBLAS_XGEMV: 복소수인 입력값이 하나라도 있으면 Y는 복소수여야 합니다.</entry>
    <entry key="eml_refblas_xrotg_2">A and B must be of the same class and complexness.</entry>
    <entry key="eml_reflapack_xzlartg_1">F and G must be of the same class.</entry>
    <entry key="eml_all_or_any_2">첫 번째 입력값은 ''all'' 또는 ''any''여야 합니다.</entry>
    <entry key="eml_all_or_any_6">HDL 타깃에는 행렬 입력값이 지원되지 않습니다.</entry>
    <entry key="eml_all_or_any_autoDimIncompatibility">Generated code expects a variable-size matrix but receives a variable-length vector. Specify the operating dimension explicitly or specify a variable-length vector at code generation time.</entry>
    <entry key="eml_all_or_any_specialEmpty">ALL or ANY with one variable-size matrix input of [] is not supported.</entry>
    <entry key="AllConstInputs">모든 입력값은 상수여야 합니다.</entry>
    <entry key="eml_assert_valid_dim_1">Enumeration types are not supported for dimension arguments.</entry>
    <entry key="eml_assert_valid_dim_2">Dimension must be a fixed-size scalar.</entry>
    <entry key="eml_assert_valid_dim_dimTooLarge">차원이 intmax(''{0}'')을(를) 초과합니다.</entry>
    <entry key="eml_assert_valid_size_arg_1">크기 인수에는 열거형이 지원되지 않습니다.</entry>
    <entry key="eml_assert_valid_size_arg_2">크기 인수는 상수여야 합니다.</entry>
    <entry key="eml_assert_valid_size_arg_3">크기 인수는 숫자형이어야 합니다.</entry>
    <entry key="eml_assert_valid_size_arg_4">크기 인수는 복소수일 수 없습니다.</entry>
    <entry key="eml_assert_valid_size_arg_6">크기 인수는 스칼라여야 합니다.</entry>
    <entry key="eml_assert_valid_size_nohalf">크기 인수는 half 유형일 수 없습니다. 다른 숫자형을 사용하십시오.</entry>
    <entry key="eml_assert_valid_size_nonsparse">크기 인수는 희소 형식이 아니라 비희소(Full) 형식이어야 합니다.</entry>
    <entry key="eml_assert_valid_size_arg_invalidSizeVector">크기 벡터는 {0,number,integer}~{1,number,integer} 범위의 유한한 정수 요소로 구성된 행 벡터여야 합니다.</entry>
    <entry key="AssertValidSizeArgFixedSize">코드 생성 시 크기 벡터는 가변 길이가 될 수 없습니다.</entry>
    <entry key="eml_div_1">복소수형 정수 연산은 지원되지 않습니다.</entry>
    <entry key="eml_div_2">정수는 같은 클래스의 정수나 double형 스칼라와만 결합될 수 있습니다.</entry>
    <entry key="eml_fft_4">DIM은 상수여야 합니다.</entry>
    <entry key="eml_fft_sizeMustBePower2">변환 차원의 길이는 2의 거듭제곱이어야 합니다.</entry>
    <entry key="FFTInvalidAlgorithmString">유효하지 않은 알고리즘 이름입니다. ''radix2'', ''bluestein'', ''rader'', ''auto'' 중 하나여야 합니다</entry>
    <entry key="FFTRaderNonPrime">Rader 알고리즘의 경우 변환 길이가 소수여야 합니다.</entry>
    <entry key="eml_guarded_inf_1">지원되지 않는 클래스입니다.</entry>
    <entry key="eml_guarded_nan_1">지원되지 않는 클래스입니다.</entry>
    <entry key="eml_int_nbits_1">Not a recognized integer class.</entry>
    <entry key="eml_isequal_core_2">첫 번째 입력값은 ''logical'' 스칼라여야 합니다.</entry>
    <entry key="eml_min_or_max_2">복소수형 정수 ''{0}''은(는) 지원되지 않습니다</entry>
    <entry key="eml_min_or_max_4">함수 ''{0}''에 비교할 행렬 두 개를 지정하고 두 개의 출력 인수를 지정하는 것은 지원되지 않습니다.</entry>
    <entry key="eml_min_or_max_5">복소수형 정수 ''{0}''은(는) 지원되지 않습니다</entry>
    <entry key="eml_min_or_max_6">혼합 입력값은 single형과 double형의 혼합이거나 정수와 double형 스칼라의 혼합이어야 합니다. 다른 모든 조합은 더 이상 허용되지 않습니다.</entry>
    <entry key="eml_min_or_max_7">함수 ''{0}''에 비교할 행렬 두 개를 지정하고 작업 차원을 지정하는 것은 지원되지 않습니다.</entry>
    <entry key="eml_min_or_max_varDimZero">If the working dimension of MAX or MIN is variable in length, it must not have zero length at runtime.</entry>
    <entry key="eml_ndims_varsized_1">내부 오류</entry>
    <entry key="eml_pad_array_2">PADVAL 입력값은 스칼라여야 합니다.</entry>
    <entry key="eml_pad_or_truncate_matrix_NMustBeConst">N은 상수여야 합니다.</entry>
    <entry key="eml_pad_or_truncate_matrix_XMustBe2D">X must be a non-empty two-dimensional numeric matrix.</entry>
    <entry key="eml_parse_parameter_inputs_10">Parse options input must be [] or a struct.</entry>
    <entry key="eml_parse_parameter_inputs_11">CaseSensitivity must be true or false.</entry>
    <entry key="eml_parse_parameter_inputs_12">StructExpand must be true or false.</entry>
    <entry key="eml_parse_parameter_inputs_13">PartialMatching must be ''first'', ''none'', or ''unique''.</entry>
    <entry key="eml_parse_parameter_inputs_14">Options input must be [] or a struct with fields selected from ''CaseSensitivity'', ''StructExpand'', ''IgnoreNulls'', and ''PartialMatching''.</entry>
    <entry key="ParameterNamesMustBeConstant">Parameter names must be constant character vectors or string scalars.</entry>
    <entry key="UnmatchedParameter">''{0}''은(는) 인식할 수 없는 파라미터입니다. 유효한 이름-값 쌍의 인수 목록은 이 함수에 대한 문서를 참조하십시오.</entry>
    <entry key="eml_parse_parameter_inputs_2">The {0} input must be a structure or a constant cell array of character vectors or string scalars.</entry>
    <entry key="eml_parse_parameter_inputs_3">The length of VARARGIN cannot exceed 65535.</entry>
    <entry key="eml_parse_parameter_inputs_4">Too many parameter names. The maximum supported number of optional arguments and parameter names is 65535.</entry>
    <entry key="eml_parse_parameter_inputs_5">NVPairNames 입력 구조체의 각 필드 값은 실수형 스칼라 ''uint32''여야 합니다.</entry>
    <entry key="ParamMissingValue">No value was given for ''{0}''. Name-value pair arguments require a name followed by a value.</entry>
    <entry key="ExpectedParameterNameOrOptionStruct">파라미터 이름 또는 파라미터 이름과 값으로 구성된 구조체가 필요합니다.</entry>
    <entry key="ExpectedParameterName">파라미터 이름이 필요합니다.</entry>
    <entry key="eml_parse_parameter_inputs_9">구문 분석 옵션(Parse options) 입력값은 상수여야 합니다. 구조체(...)를 사용하여 정의해 보십시오.</entry>
    <entry key="UnmatchedOption">''{0}'' is not a valid input in this context.</entry>
    <entry key="eml_rand_mcg16807_1">시드(seed)는 double형 스칼라여야 합니다.</entry>
    <entry key="eml_rand_mcg16807_2">범위 입력값은 고정 크기여야 합니다.</entry>
    <entry key="eml_rand_mcg16807_3">범위 입력값은 스칼라이거나 2개의 요소가 있어야 합니다.</entry>
    <entry key="eml_rand_mt19937ar_3">시드(Seed) 값은 고정 크기의 double형 스칼라여야 합니다.</entry>
    <entry key="eml_rand_mt19937ar_4">범위 입력값은 고정 크기여야 합니다.</entry>
    <entry key="eml_rand_mt19937ar_5">범위 입력값은 스칼라이거나 2개의 요소가 있어야 합니다.</entry>
    <entry key="eml_rand_shr3cong_1">시드(seed)는 double형 스칼라여야 합니다.</entry>
    <entry key="eml_rand_shr3cong_2">범위 입력값은 고정 크기여야 합니다.</entry>
    <entry key="eml_rand_shr3cong_3">범위 입력값은 스칼라이거나 2개의 요소가 있어야 합니다.</entry>
    <entry key="eml_rcond_1">입력값은 single형 또는 double형이어야 합니다.</entry>
    <entry key="eml_safe_eq_1">첫 번째 입력값은 부동소수점이 아니어야 합니다.</entry>
    <entry key="eml_safe_eq_2">지원되지 않는 클래스임: ''{0}''.</entry>
    <entry key="UnsupportedEmptyArrayType">불투명(Opaque) 구조체 유형의 빈 배열은 지원되지 않습니다.</entry>
    <entry key="eml_scalar_eg_2">If any argument is an enumeration, all arguments must be enumerations of the same type.</entry>
    <entry key="eml_sort_2">정렬 방향은 ''ascend'' 또는 ''descend''여야 합니다.</entry>
    <entry key="SortDirMustBeConstant">Sorting direction must be constant, either ''ascend'' or ''descend''.</entry>
    <entry key="SortCellstrHomogenizationFailed"> 입력 셀형 배열을 동종 유형으로 만들 수 없습니다. coder.varsize를 사용하여 'X'를 동종 유형으로 만드십시오.</entry>
    <entry key="eml_unsigned_class_1">Not a recognized integer class.</entry>
    <entry key="fzero_11">사용자 함수는 항상 실수 값을 반환해야 합니다.</entry>
    <entry key="fzero_14">사용자 함수는 항상 실수 값을 반환해야 합니다.</entry>
    <entry key="fzero_2">출력 인수가 너무 많습니다. 코드 생성 시 FZERO는 출력 구조체 인수를 지원하지 않습니다.</entry>
    <entry key="fzero_4">첫 번째 입력값은 함수 핸들이어야 합니다.</entry>
    <entry key="fzero_5">FZERO를 사용하려면 최소 두 개의 입력 인수가 필요합니다.</entry>
    <entry key="fzero_6">FZERO는 double형 입력값만 받습니다.</entry>
    <entry key="fzero_7">두 번째 인수는 고정 크기여야 합니다.</entry>
    <entry key="fzero_8">두 번째 인수의 길이는 1 또는 2여야 합니다.</entry>
    <entry key="fzero_9">세 번째 인수는 옵션 구조체 또는 []이어야 합니다.</entry>
    <entry key="quad2d_2">첫 번째 입력 인수는 함수 핸들이어야 합니다.</entry>
    <entry key="quad2d_7">MATLAB:quad2d:invalidSingularSingular 옵션은 true 또는 false여야 합니다.</entry>
    <entry key="quad2d_invalidFailurePlot">MATLAB 코드 생성에서는 FailurePlot 옵션이 지원되지 않습니다.</entry>
    <entry key="quadgk_2">첫 번째 입력 인수는 함수 핸들이어야 합니다.</entry>
    <entry key="quadgk_3">A와 B는 스칼라 부동소수점이어야 합니다.</entry>
    <entry key="quadgk_4">지원되는 클래스는 ''double'' 및 ''single''입니다.</entry>
    <entry key="quadgk_8">MaxIntervalCount는 상수여야 합니다.</entry>
    <entry key="quadgk_9">MaxIntervalCount는 인덱싱 범위 내에 있는 양의 정수 스칼라여야 합니다.</entry>
    <entry key="quadgk_MaxIntervalCountTooSmall">MaxIntervalCount is too small for the first iteration.</entry>
    <entry key="quadgk_WaypointsTypeMismatch">MATLAB 코드 생성 시 중간점(Waypoints)이 ''single''이면 적어도 하나의 끝점이 ''single''이어야 합니다.</entry>
    <entry key="mustBeAInput">''ClassNames'' 인수는 비어 있지 않은 상수 string형, 문자형 벡터, 또는 문자형 벡터로 구성된 셀형 배열이어야 합니다.</entry>
    <entry key="mustBeLike">2개의 입력 인수가 지정된 경우, 첫 번째 인수는 ''like''여야 합니다.</entry>
    <entry key="constTypename">유형 이름을 지정하는 문자형 인수 또는 string형 인수는 상수여야 합니다.</entry>
    <entry key="nargchk_2">입력값이 상수여야 함</entry>
    <entry key="nargchk_3">네 번째 입력값은 ''struct'' 또는 ''string''이어야 합니다.</entry>
    <entry key="nargchk_4">처음 3개의 입력값은 스칼라여야 합니다.</entry>
    <entry key="nargchk_5">처음 3개의 입력값은 숫자형이어야 합니다.</entry>
    <entry key="nargchk_6">정수 스칼라 값이 필요한데 현재 값은 정수가 아닙니다.</entry>
    <entry key="nargoutchk_2">입력값이 상수여야 함</entry>
    <entry key="nargoutchk_3">네 번째 입력값은 ''struct'' 또는 ''string''이어야 합니다.</entry>
    <entry key="nargoutchk_4">처음 3개의 입력값은 스칼라여야 합니다.</entry>
    <entry key="nargoutchk_5">처음 3개의 입력값은 숫자형이어야 합니다.</entry>
    <entry key="nargoutchk_6">정수 스칼라 값이 필요한데 현재 값은 정수가 아닙니다.</entry>
    <entry key="chol_3">Second input must be a constant ''upper'' or ''lower''.</entry>
    <entry key="chol_4">nargout == 2인 경우 입력 행렬은 두 차원 모두에서 가변 크기여야 합니다.</entry>
    <entry key="cond_3">사용할 수 있는 유일한 행렬 노름은 1, 2, inf, ''fro''입니다.</entry>
    <entry key="cond_inputMustBe2D">입력 행렬은 2차원이어야 합니다.</entry>
    <entry key="qr_inputMustBe2D">인수 A는 2차원 행렬이어야 합니다.</entry>
    <entry key="qr_invalidArguments">유효하지 않은 옵션 조합입니다.</entry>
    <entry key="expm_3">입력값은 single형 또는 double형이어야 합니다.</entry>
    <entry key="linsolve_2">MATLAB 코드 생성 시 하나의 옵션 구조체 인수만 지원됩니다.</entry>
    <entry key="linsolve_5">세 번째 인수는 구조체형 배열이어야 합니다.</entry>
    <entry key="linsolve_6">MATLAB 코드 생성 시 스칼라 구조체 입력값만 지원됩니다.</entry>
    <entry key="linsolve_7">세 번째 인수는 상수여야 합니다. STRUCT 함수를 사용하여 옵션 구조체를 만들어 보십시오.</entry>
    <entry key="linsolve_8">구조체 필드는 논리형 스칼라를 포함해야 합니다.</entry>
    <entry key="lsqminnormInputTypes">첫 번째 인수와 두 번째 인수는 double형 행렬 또는 single형 행렬이어야 합니다.</entry>
    <entry key="lsqminnormInvalidTol">허용오차는 double형 또는 single형의 음이 아닌 스칼라 숫자여야 합니다.</entry>
    <entry key="lsqminnormInvalidReg">정규화 인자는 음이 아닌 스칼라여야 함</entry>
    <entry key="lsqminnormUnrecognizedInput">Option inputs must be either "warn", "nowarn", a real numeric scalar tolerance, or "RegularizationFactor" followed by a corresponding value.</entry>
    <entry key="lu_4">두 번째 인수는 ''vector'' 또는 ''matrix''여야 합니다</entry>
    <entry key="lu_inputMustBe2D">행렬은 2차원이어야 합니다.</entry>
    <entry key="norm_4">사용할 수 있는 유일한 행렬 노름은 1, 2, inf, ''fro''입니다.</entry>
    <entry key="norm_inputMustBe2D">입력값 x는 벡터 또는 2차원 행렬이어야 합니다.</entry>
    <entry key="normest_5">허용오차는 실수여야 합니다.</entry>
    <entry key="normest_inputMustBe2D">입력 행렬은 2차원이어야 합니다.</entry>
    <entry key="null_2">두 번째 입력값(유리 기저 옵션)은 지원되지 않습니다.</entry>
    <entry key="pinv_4">TOL은 부동소수점 스칼라여야 합니다.</entry>
    <entry key="pinv_inputMustBe2D">입력 행렬은 2차원이어야 합니다.</entry>
    <entry key="planerot_4">입력값은 요소를 2개 가진 열 벡터여야 합니다.</entry>
    <entry key="qr_2">효율적인 크기로 분해하기 위해서는 qr(X,0)을 사용하십시오.</entry>
    <entry key="rank_4">tol이 제공되는 경우 이는 스칼라여야 합니다.</entry>
    <entry key="rcond_2">입력값은 single형 또는 double형이어야 합니다.</entry>
    <entry key="rsf2csf_2">입력값은 ''double'' 또는 ''single''이어야 합니다.</entry>
    <entry key="rsf2csf_3">입력값은 실수여야 합니다.</entry>
    <entry key="schur_5">두 번째 인수는 ''real'' 또는 ''complex''여야 합니다.</entry>
    <entry key="schur_failed">SCHUR이 실패했습니다.</entry>
    <entry key="schur_input2D">입력값은 2차원이어야 합니다.</entry>
    <entry key="sqrtm_rootEigenCancel">2개 이상의 고유값의 주 제곱근이 근사적으로 상쇄됩니다. 결과값이 부정확할 수 있습니다.</entry>
    <entry key="svd_4">코드 생성 시 두 번째 인수는 상수여야 하며, 0 또는 ''econ''이어야 합니다.</entry>
    <entry key="svd_5">효율적인 크기로 분해하기 위해서는 svd(X,0) 또는 svd(X,''econ'')을 사용하십시오.</entry>
    <entry key="bitAndXorOrUnsupportedClasses">입력값들이 동일한 클래스의 부호 있는 정수 또는 부호 없는 정수이어야 합니다. 또는 한 입력값이 double형 스칼라일 수 있습니다.</entry>
    <entry key="bitIntegersOnly">첫 번째 인수는 부호 있는 정수이거나 부호 없는 정수여야 합니다.</entry>
    <entry key="bitshiftAssumedTypeMustBeConstant">Assumedtype 입력값은 상수여야 합니다.</entry>
    <entry key="colon_6">피연산자는 상수여야 합니다.</entry>
    <entry key="colon_7">콜론 피연산자는 실수형 스칼라여야 합니다.</entry>
    <entry key="colon_8">콜론 피연산자는 모두 유형이 동일하거나 double형의 실수형 스칼라와 혼용되어야 합니다.</entry>
    <entry key="colon_9">문자형 피연산자를 사용하는 콜론 연산자의 경우 처음과 끝의 피연산자는 문자형이어야 합니다.</entry>
    <entry key="colon_10">문자형 피연산자를 사용하는 콜론 연산자의 경우 두 번째 피연산자는 문자형이거나 double형의 실수형 스칼라여야 합니다.</entry>
    <entry key="expectHomogeneousHalfInputs">한 입력값이 반정밀도이면 모든 입력값이 반정밀도여야 합니다.</entry>
    <entry key="colon_operandsMustBeScalars">콜론 피연산자는 실수형 스칼라여야 합니다.</entry>
    <entry key="eml_setop_12">입력값은 2차원이어야 합니다.</entry>
    <entry key="eml_setop_2">입력 인수가 너무 많습니다.</entry>
    <entry key="eml_setop_3">첫 번째 입력값은 연산 이름이어야 합니다.</entry>
    <entry key="eml_setop_4">복소수 입력값은 ''single'' 또는 ''double''이어야 합니다.</entry>
    <entry key="eml_setop_5">처음 2개의 입력값은 동일한 열거형 클래스에 속해야 합니다.</entry>
    <entry key="eml_setop_6">OP는 ''intersect'', ''setdiff'', ''setxor'', ''union'' 중 하나여야 합니다.</entry>
    <entry key="eml_setop_7">입력값은 숫자형, 논리형, 문자형 중 하나여야 합니다.</entry>
    <entry key="eml_setop_8">알 수 없는 플래그입니다.</entry>
    <entry key="eml_setop_9">''rows''가 지정되지 않은 경우 입력값은 행 벡터여야 합니다. 가변 크기 입력값의 경우 첫 번째 차원은 상수 길이 1을 가져야 합니다. 입력값 []은 지원되지 않습니다. 1×0 입력값(예: zeros(1,0))을 사용하여 공집합을 표현하십시오.</entry>
    <entry key="eml_setop_10">{0} 클래스의 입력 인수 A와 {1} 클래스의 입력 인수 B는 둘 중 하나가 double형이 아닌 한, 동일한 클래스를 가져야 합니다.</entry>
    <entry key="setopInputsMustBeVectors">''rows''가 지정되지 않은 경우 입력값은 벡터여야 합니다. 가변 크기 입력값의 경우 첫 번째 또는 두 번째 차원은 상수 길이 1을 가져야 합니다. 입력값 []은 지원되지 않습니다. 1×0 또는 0×1 입력값(예: zeros(1,0) 또는 zeros(0,1))을 사용하여 공집합을 표현하십시오.</entry>
    <entry key="vectorOrientationMustMatch">두 입력값 모두 행 벡터이거나 두 입력값 모두 열 벡터여야 합니다.</entry>
    <entry key="eml_setop_unsortedA">The first operand is not sorted in ascending order. Use SORT first.</entry>
    <entry key="eml_setop_unsortedB">The second operand is not sorted in ascending order. Use SORT first.</entry>
    <entry key="eml_setop_unsortedRowsA">The first operand is not sorted in ascending order. Use SORTROWS first.</entry>
    <entry key="eml_setop_unsortedRowsB">The second operand is not sorted in ascending order. Use SORTROWS first.</entry>
    <entry key="idivide_2">반올림 옵션을 인식할 수 없습니다. 소문자 ''fix'', ''floor'', ''round'', ''ceil'' 중 하나를 사용하십시오.</entry>
    <entry key="idivide_3">적어도 하나의 인수는 정수형 클래스에 속해야 합니다.</entry>
    <entry key="idivide_4">복소수형 정수 연산은 지원되지 않습니다.</entry>
    <entry key="idivide_5">정수는 같은 클래스의 정수나 double형 스칼라와만 결합될 수 있습니다.</entry>
    <entry key="idivide_divideByZero">Divide by zero.</entry>
    <entry key="intersect_2">입력 인수가 너무 많습니다.</entry>
    <entry key="ismember_2">입력 인수가 너무 많습니다.</entry>
    <entry key="ismember_3">처음 2개의 입력값은 동일한 열거형 클래스에 속해야 합니다.</entry>
    <entry key="ismember_4">입력값은 숫자형, 논리형, 문자형 중 하나여야 합니다.</entry>
    <entry key="ismember_5">복소수 입력값은 ''single'' 또는 ''double''이어야 합니다.</entry>
    <entry key="ismember_6">알 수 없는 플래그입니다.</entry>
    <entry key="ismember_7">입력값은 2차원이어야 합니다.</entry>
    <entry key="ismember_unsortedRowsS">두 번째 피연산자가 오름차순으로 정렬되지 않았습니다. 먼저 SORTROWS를 사용하십시오.</entry>
    <entry key="ismember_unsortedS">두 번째 피연산자가 오름차순으로 정렬되지 않았습니다. 먼저 SORT를 사용하십시오.</entry>
    <entry key="kron_1">입력 인수 ''A''가 정의되지 않았습니다.</entry>
    <entry key="kron_2">입력 인수 ''B''가 정의되지 않았습니다.</entry>
    <entry key="mpower_4">두 피연산자는 모두 스칼라여야 합니다.</entry>
    <entry key="mpower_5">정수는 같은 클래스의 정수나 double형 스칼라와만 결합될 수 있습니다.</entry>
    <entry key="mpower_6">최소 하나의 피연산자가 스칼라여야 합니다.</entry>
    <entry key="mpower_inputsMustBe2D">입력 인수는 2차원이어야 합니다.</entry>
    <entry key="mpower_needComplexInput">At least one argument must be complex when raising a matrix to a non-integer, scalar power.</entry>
    <entry key="mtimes_noDynamicScalarExpansion">내부 차원이 동일하지 않으므로 스칼라 값에 스칼라가 아닌 값을 곱할 수 없습니다. 스칼라 확장을 사용하려면 코드 생성 시 스칼라를 고정된 크기로 지정하십시오.</entry>
    <entry key="power_4">복소수형 정수 연산은 지원되지 않습니다.</entry>
    <entry key="power_5">정수는 같은 클래스의 정수나 double형 스칼라와만 결합될 수 있습니다.</entry>
    <entry key="power_7">정수는 같은 클래스의 정수나 double형 스칼라와만 결합될 수 있습니다.</entry>
    <entry key="power_9">HDL 타깃의 경우 두 입력값 모두 동일한 정수 클래스에 속해야 합니다.</entry>
    <entry key="power_domainError">도메인 오류입니다. 복소수 결과를 계산하려면 적어도 하나의 입력값을 복소수로 만드십시오(예: ''power(complex(a),b)'').</entry>
    <entry key="unique_3">첫 번째 입력값은 숫자형, 논리형, 문자형 중 하나여야 합니다.</entry>
    <entry key="unique_4">복소수 입력값은 ''single'' 또는 ''double''이어야 합니다.</entry>
    <entry key="unique_5">Options must be constant character vectors.</entry>
    <entry key="unique_6">인식할 수 없는 옵션입니다.</entry>
    <entry key="unique_7">동일한 옵션에 대해 둘 이상의 값을 지정할 수 없습니다.</entry>
    <entry key="unique_8">''rows''가 지정되지 않은 경우 첫 번째 입력값은 행 벡터여야 합니다. 벡터가 가변 크기인 경우 첫 번째 차원은 고정 길이 1을 가져야 합니다. 입력값 []은 지원되지 않습니다. 1×0 입력값(예: zeros(1,0))을 사용하여 공집합을 표현하십시오.</entry>
    <entry key="unique_9">입력값은 2차원이어야 합니다.</entry>
    <entry key="unique_InputMustBeVector">First or second dimension of input array must have a fixed size of 1 when "rows" option is not specified.</entry>
    <entry key="unique_cellInputMustBeVector">입력 셀형 배열은 벡터여야 합니다. 벡터가 가변 크기인 경우 첫 번째 차원과 두 번째 차원 중 하나는 고정 길이 1을 가져야 합니다. 입력값 '{}'은 지원되지 않습니다. cell(1,0) 또는 cell(0,1)을 사용하여 공집합을 표현하십시오.</entry>
    <entry key="unique_cellInputMustBeRowForLegacyOption">unique 함수에 대해 옵션 'legacy'가 지정된 경우 입력 셀형 배열은 행 벡터여야 합니다. 벡터가 가변 크기인 경우 첫 번째 차원은 고정 길이 1을 가져야 합니다. 입력값 '{}'은 지원되지 않습니다. cell(1,0)을 사용하여 공집합을 표현하십시오.</entry>
    <entry key="xor_2">피연산자는 실수여야 합니다.</entry>
    <entry key="interp1_14">지원되지 않는 메서드입니다. 지원되는 메서드는 ''cubic'', ''linear'', ''nearest'', ''next'', ''pchip'', ''previous'', ''spline'', ''v5cubic''입니다.</entry>
    <entry key="interp1_2">테이블 V는 숫자만 포함해야 합니다</entry>
    <entry key="interp1_3">데이터 abscissae는 실수여야 합니다.</entry>
    <entry key="interp1_5">유효하지 않은 외삽 방법입니다.</entry>
    <entry key="interp1_6">인덱스 Xq는 실수만 포함해야 합니다</entry>
    <entry key="interp1_arrayXItoVector">가변 크기 Xq는 항상 벡터이거나, 절대 벡터가 아니어야 합니다.</entry>
    <entry key="interp1_nonMonotonicX">The data abscissae must be distinct and strictly monotonic.</entry>
    <entry key="interp1_vsizeMatrixBecameRowVec">가변 크기 입력 행렬 또는 N차원 배열은 런타임에 행 벡터가 되지 않아야 합니다.</entry>
    <entry key="interp1q_1">입력 인수 Xq가 정의되지 않았습니다.</entry>
    <entry key="interp1q_2">데이터 abscissae는 실수여야 합니다.</entry>
    <entry key="interp1q_3">테이블 V는 숫자만 포함해야 합니다.</entry>
    <entry key="interp1q_4">인덱스 Xq는 실수만 포함해야 합니다.</entry>
    <entry key="interp1q_5">입력 인수 X는 열 벡터여야 합니다.</entry>
    <entry key="interp1q_6">입력 인수 Xq는 열 벡터여야 합니다.</entry>
    <entry key="interp1q_7">Y는 length(X)개 행을 가져야 합니다.</entry>
    <entry key="nMustBeRealPosIntScalar">N은 양의 실수형 정수 스칼라여야 합니다.</entry>
    <entry key="padecoef_2">N은 상수여야 합니다.</entry>
    <entry key="padecoef_4">T는 스칼라여야 합니다.</entry>
    <entry key="padecoef_5">T는 부동소수점이어야 합니다.</entry>
    <entry key="nonfiniteValuesNotSupported">X must not contain Infs or NaNs.</entry>
    <entry key="poly_3">입력값은 2차원이어야 합니다.</entry>
    <entry key="poly_vsizeMatrixIsVector">POLY에 대한 가변 크기 행렬 입력값은 런타임에 벡터 입력값이 되어서는 안 됩니다. 가변 길이 벡터를 대신 사용하십시오.</entry>
    <entry key="polyfit_2">N은 상수여야 합니다.</entry>
    <entry key="polyfit_3">N은 실수 숫자형 스칼라여야 합니다.</entry>
    <entry key="polyfit_4">X와 Y는 최대 하나의 가변 길이 차원을 갖는 벡터여야 하며, 그 차원은 첫 번째 또는 두 번째 차원이어야 합니다. 다른 모든 차원은 고정 길이 1을 가져야 합니다.</entry>
    <entry key="polyfit_5">POLYFIT 데이터 입력값은 벡터여야 합니다.</entry>
    <entry key="polyval_6">오차 추정값을 계산하는 데 S가 필요합니다.</entry>
    <entry key="polyval_7">S는 POLYFIT에서 반환되는 구조체여야 합니다.</entry>
    <entry key="polyval_invalidMu">MU는 적어도 2개 요소를 가진 부동소수점 배열이어야 합니다.</entry>
    <entry key="roots_1">ROOTS에 가변 크기 설정이 필요합니다.</entry>
    <entry key="roots_3">입력값은 ''double'' 또는 ''single''이어야 합니다.</entry>
    <entry key="roots_4">입력값은 최대 하나의 가변 길이 차원을 갖는 벡터여야 하며, 그 차원은 첫 번째 또는 두 번째 차원이어야 합니다. 다른 모든 차원은 고정 길이 1을 가져야 합니다.</entry>
    <entry key="roots_5">입력값은 벡터여야 합니다.</entry>
    <entry key="nnz_2">입력값은 숫자형, 문자형, 논리형 중 하나여야 합니다.</entry>
    <entry key="nonzeros_2">입력값은 숫자형, 문자형, 논리형 중 하나여야 합니다.</entry>
    <entry key="betainc_2">입력값은 single형 또는 double형이어야 합니다.</entry>
    <entry key="betainc_3">입력값은 실수여야 합니다.</entry>
    <entry key="betainc_4">TAIL은 ''lower'' 또는 ''upper''여야 합니다.</entry>
    <entry key="betaincinv_2">입력값은 single형 또는 double형이어야 합니다.</entry>
    <entry key="betaincinv_3">입력값은 실수여야 합니다.</entry>
    <entry key="betaincinv_4">TAIL은 ''lower'' 또는 ''upper''여야 합니다.</entry>
    <entry key="cross_1">입력 인수 A가 정의되지 않았습니다.</entry>
    <entry key="cross_2">입력 인수 B가 정의되지 않았습니다.</entry>
    <entry key="cross_4">지원되지 않는 입력값 클래스입니다. single형 또는 double형이어야 합니다.</entry>
    <entry key="variableSizeMatrixToVector">런타임에 벡터가 되는 가변 크기 배열 입력값은 방향이 같아야 합니다.</entry>
    <entry key="ellipke_4">입력 인수는 실수여야 합니다.</entry>
    <entry key="ellipke_5">TOL은 부동소수점 스칼라여야 합니다.</entry>
    <entry key="eml_erfcore_2">입력값은 single형 또는 double형이어야 합니다.</entry>
    <entry key="eml_erfcore_3">입력값은 실수여야 합니다.</entry>
    <entry key="eml_erfcore_4">두 번째 입력값은 상수여야 합니다.</entry>
    <entry key="eml_primes_core_1">첫 번째 입력값은 상수여야 합니다.</entry>
    <entry key="eml_primes_core_4">지원되지 않는 클래스입니다.</entry>
    <entry key="expint_2">입력값은 single형 또는 double형이어야 합니다.</entry>
    <entry key="factor_2">N은 부동소수점 스칼라여야 합니다.</entry>
    <entry key="factor_3">FACTOR에 가변 크기 설정이 필요합니다. 이 옵션은 현재 꺼져 있습니다.</entry>
    <entry key="factorial_1">N은 음이 아닌 부동소수점 정수로 구성된 행렬이어야 합니다.</entry>
    <entry key="gamma_2">입력값은 single형 또는 double형이어야 합니다.</entry>
    <entry key="gamma_3">입력값은 실수여야 합니다.</entry>
    <entry key="gammainc_2">입력값은 비희소(Full) 형식의 실수로, double형 또는 single형이어야 합니다.</entry>
    <entry key="gammainc_3">TAIL은 ''lower'' 또는 ''upper''여야 합니다.</entry>
    <entry key="gammaincinv_1">입력값이 부족합니다.</entry>
    <entry key="gammaincinv_2">입력값은 비희소(Full) 형식의 실수로, double형 또는 single형이어야 합니다.</entry>
    <entry key="gammaln_2">입력값은 single형 또는 double형이어야 합니다.</entry>
    <entry key="gcd_4">입력값은 실수형 정수여야 합니다.</entry>
    <entry key="isprime_2">입력값은 ''double'' 또는 ''single''이어야 합니다.</entry>
    <entry key="isprime_3">ISPRIME에 가변 크기 설정이 필요합니다. 이 옵션은 현재 꺼져 있습니다.</entry>
    <entry key="lcm_4">입력값은 실수여야 합니다.</entry>
    <entry key="nchoosek_3">첫 번째 인수는 스칼라 또는 벡터여야 합니다.</entry>
    <entry key="nchoosek_4">두 번째 입력값은 음이 아닌 정수여야 합니다.</entry>
    <entry key="primes_2">N은 부동소수점 스칼라여야 합니다.</entry>
    <entry key="primes_3">PRIMES에 가변 크기 설정이 필요합니다. 이 옵션은 현재 꺼져 있습니다.</entry>
    <entry key="bin2dec_InputOutOfRange">입력값은 {0}비트 이하여야 합니다.</entry>
    <entry key="bin2dec_inputMustBe2D">입력값은 2차원이어야 합니다.</entry>
    <entry key="blanks_2">입력값은 숫자형이어야 합니다.</entry>
    <entry key="hex2dec_inputMustBe2D">입력값은 2차원이어야 합니다.</entry>
    <entry key="structfun_maxrhs">코드 생성 시 structfun은 최대 3개의 출력값을 지원합니다.</entry>
    <entry key="structfun_noErrorHandler">코드 생성 시 ErrorHandler 옵션은 지원되지 않습니다.</entry>
    <entry key="int_forloop_overflow">The loop variable of class {0} might overflow on the last iteration of the for loop. This could lead to an infinite loop.</entry>
    <entry key="colonIndexOverflow">Numerical overflow occurred when performing colon operation on values of class {0}.</entry>
    <entry key="internal_invariant_arg1">조건 입력 인수는 유효한 논리형 스칼라여야 합니다.</entry>
    <entry key="internal_invariant_arg2">두 번째 입력값은 메시지 ID여야 합니다.</entry>
    <entry key="rng_stringInputNotConst">이 입력값은 상수여야 합니다.</entry>
    <entry key="rng_shuffleNotSupported">'shuffle' 입력값은 지원되지 않습니다.</entry>
    <entry key="rng_unsupportedGenerator">생성기는 'twister', 'v5normal', 'v4' 중 하나여야 합니다.</entry>
    <entry key="badGeneratorState">생성기 상태가 유효하지 않습니다.</entry>
    <entry key="sum_hdlRequiresFlag">입력값이 ''{0}''이고 타깃이 ''hdl''인 경우 ''native'' 또는 ''double'' 플래그를 지정해야 합니다.</entry>
    <entry key="indexIntRelop_unsupportedInput">에뮬레이션 정수 유형을 클래스 ''{0}''과(와) 비교하는 것은 지원되지 않습니다. 피연산자를 에뮬레이션 정수 유형과 유사한 내장 정수 유형으로 형변환해 보십시오.</entry>
    <entry key="indexIntRelop_floatOverflow">에뮬레이션 정수 유형이 클래스 ''{0}''의 범위를 초과합니다. 부동소수점 피연산자를 적절한 정수 클래스로 형변환해 보십시오.</entry>
    <entry key="unsupportedString">이 입력값은 0에서 {0,number,integer} 사이의 문자만 포함할 수 있습니다.</entry>
    <entry key="hex2num_invalidInput">입력값은 문자형 벡터 또는 최대 {0,number,integer}개의 열을 갖는 행렬이어야 합니다.</entry>
    <entry key="environmentUnknown">''{1}'' 타깃에는 ''{0}'' 함수가 지원되지 않습니다.</entry>
    <entry key="mfmt2cfmt_unsupportedChar">Escape sequence must encode a character in the range 0 to 127.</entry>
    <entry key="mfmt2cfmt_invalidFormat">Invalid format string.</entry>
    <entry key="mfmt2cfmt_dollarNotSupported">The conversion specification, ''{0}'', uses ''$'' as a variable identifier. This is not supported for code generation. Omit its use from the ''formatSpec'' parameter.</entry>
    <entry key="mfmt2cfmt_btNotSupported">The conversion specification, ''{0}'', uses subtype modifiers ''b'' and/or ''t'', which are not supported for code generation. Omit them from the ''formatSpec'' parameter.</entry>
    <entry key="NothingToRead">File has nothing left to read. To avoid this error, call 'feof' to check if you have reached the end of the file before using 'fgets' or 'fgetl'.</entry>
    <entry key="fgetslIllegalCharacter">Read illegal non-ASCII character with integer value {0}. For code generation, all characters must have value less than 128.</entry>
    <entry key="fopenFidInputNotSupported">코드 생성 시 FID 입력값은 지원되지 않습니다.</entry>
    <entry key="fopenMsgOutputNotSupported">코드 생성 시 MESSAGE 출력값은 지원되지 않습니다.</entry>
    <entry key="fopenAllNotSupported">fopen(''all'') is not supported for code generation.</entry>
    <entry key="fopenMfNotSupported">코드 생성 시 MACHINEFORMAT 입력값과 ENCODING 입력값은 지원되지 않습니다.</entry>
    <entry key="FopenNoTextMode">Code generation does not support passing a 't' in the permission to fopen to open files in text mode.</entry>
    <entry key="FopenInvalidPerm">For code generation, the permission to fopen must be at most 3 characters with the second and third characters chosen from '+' and 'b' without repetition.</entry>
    <entry key="xprintfCharFmt">''{0}''에 제공된 ''formatSpec'' 파라미터가 ''{1}'' 유형입니다. 문자형 벡터여야 합니다.</entry>
    <entry key="xprintfConstFmt">''{0}''에 제공된 ''formatSpec'' 파라미터는 상수여야 합니다.</entry>
    <entry key="xprintfFixedSzFid">''{0}''에 제공된 ''fileID'' 파라미터가 가변 크기입니다. 고정 크기여야 합니다.</entry>
    <entry key="xprintfFmtTypeMismatchChar">유형 ''{1}''의 입력 인수는 ''formatSpec''의 변환 문자 ''{0}''과(와) 일치하지 않습니다. 코드 생성 시 이 입력 인수의 유형은 ''char'' 또는 ''string''이어야 합니다.</entry>
    <entry key="xprintfFmtTypeMismatchFloat">유형 ''{1}''의 입력 인수는 ''formatSpec''의 변환 문자 ''{0}''과(와) 일치하지 않습니다. 코드 생성 시 이 입력 인수의 유형은 ''single'' 또는 ''double''이어야 합니다.</entry>
    <entry key="xprintfFmtTypeMismatchSigned">유형 ''{1}''의 입력 인수는 ''formatSpec''의 변환 문자 ''{0}''과(와) 일치하지 않습니다. 코드 생성 시 이 입력 인수의 유형은 ''int8'', ''int16'', ''int32'', ''int64'' 중 하나여야 합니다.</entry>
    <entry key="xprintfFmtTypeMismatchUnsigned">유형 ''{1}''의 입력 인수는 ''formatSpec''의 변환 문자 ''{0}''과(와) 일치하지 않습니다. 코드 생성 시 이 입력 인수의 유형은 ''uint8'', ''uint16'', ''uint32'', ''uint64'' 중 하나여야 합니다.</entry>
    <entry key="xprintfNumericStar">코드 생성 시 sprintf 또는 fprintf에 대한 ''*'' 인수는 코드 생성 시점에 고정 크기 스칼라 또는 상수여야 합니다.</entry>
    <entry key="xprintfScalarArg">코드 생성 시 sprintf 또는 fprintf에 대한 ''{0}'' 인수는 코드 생성 시점에 고정 크기 스칼라 또는 상수여야 합니다.</entry>
    <entry key="XprintfIntegerTypeTooLarge">For code generation, integer arguments corresponding to the conversion character ''%{0}'' must be representable in the target hardware.  The provided argument is {1,number,integer} bits while the largest integer in the specified hardware is {2,number,integer} bits.</entry>
    <entry key="sprintfErrmsg">코드 생성 시 오류 메시지 출력값은 지원되지 않습니다.</entry>
    <entry key="fixedSzFid">The ''fileID'' parameter provided is variable size. It must be a fixed size scalar.</entry>
    <entry key="unrecognizedRelop">The relop name, ''{0}'' is not supported.  It must be one of the following: ''lt'', ''gt'', ''le'', ''ge'', ''eq'', ''ne''.</entry>
    <entry key="eml_i64relops_need64BitInt">''a''와 ''b'' 중 하나는 uint64 또는 int64여야 하며 다른 하나는 프리미티브 숫자형이어야 합니다. 그러나 전달된 유형은 a: {0}, b: {1}입니다.</entry>
    <entry key="int64DoubleDivisionNotSupported">코드 생성 시 ''{0}''을(를) ''{1}''(으)로 나누는 것은 지원되지 않습니다. 나누기 전에 피연산자 중 하나를 형변환하여 유형을 일치시키십시오.</entry>
    <entry key="InputMustBeConstant">The {0} input must be a constant.</entry>
    <entry key="CodegenOnly">이 함수는 코드 생성 타깃에 대해서만 지원됩니다.</entry>
    <entry key="NotSupportedForCodegen">The input {0} is not supported for code generation.</entry>
    <entry key="randgIterLimitExceeded">RANDG가 기각 반복 한도에 도달했습니다.</entry>
    <entry key="mod_int64MixedDoubleNotSupported">함수 ''{0}''은(는) ''{1}'' 및 ''{2}'' 유형이 결합된 입력값을 지원하지 않습니다. ''{3}''을(를) 호출하기 전에 이 중 한 인수를 형변환하여 유형을 일치시키십시오.</entry>
    <entry key="Int64NotSupported">이 함수는 ''uint64'' 또는 ''int64'' 유형의 입력값을 지원하지 않습니다. 함수 호출 전에 인수를 다른 정수 유형 또는 부동소수점 유형으로 형변환하십시오.</entry>
    <entry key="InputMustBeFixedSizeScalar">입력값 {0}은(는) 고정 크기 스칼라여야 합니다</entry>
    <entry key="bitAndXorOrMustBeIntegers">코드 생성 시 최소 하나의 입력값은 정수형 클래스에 속해야 합니다.</entry>
    <entry key="SetOpUnsortedRealAWithComplexB">A must be sorted in complex ascending order when B is complex. Use sort(complex(A)), or use the ''stable'' option.</entry>
    <entry key="SetOpUnsortedRealBWithComplexA">B must be sorted in complex ascending order when A is complex. Use sort(complex(B)), or use the ''stable'' option.</entry>
    <entry key="SetOpUnsortedRowsRealAWithComplexB">A must be sorted in complex ascending order when B is complex. Use sortrows(complex(A)), or use the ''stable'' option.</entry>
    <entry key="SetOpUnsortedRowsRealBWithComplexA">B must be sorted in complex ascending order when A is complex. Use sortrows(complex(B)), or use the ''stable'' option.</entry>
    <entry key="PolyderNeedsVariableSizing">출력 배열에 선행 0이 있고 EnableVariableSizing이 false로 설정되어 있습니다. 선행 0을 제거하기 위해 POLIDER에 가변 크기를 설정해야 합니다.</entry>
    <entry key="InputsMustBeFloats">입력값은 부동소수점, 즉 single형이나 double형이어야 합니다.</entry>
    <entry key="InputsMustBeFourColumnRealMatrices">입력값은 4개의 열을 가진 실수 숫자형 행렬이어야 합니다.</entry>
    <entry key="FileReadBadFile">파일 {0}을(를) 열 수 없습니다.</entry>
    <entry key="FreadMachineFormatNotSupported">For code generation, you cannot use the ''machineformat'' input argument.</entry>
    <entry key="FreadReadTruncated">코드 생성 시 ''sizeA''가 유한한 경우 FREAD는 ''sizeA''에 의해 지정된 개수의 요소를 읽어야 합니다. 이 호출은 {0, number, integer}개 요소를 요청했지만 실제 읽힌 요소는 {1, number, integer}개입니다.</entry>
    <entry key="FreadConstPrecision">코드 생성 시 ''precision'' 인수는 상수여야 합니다.</entry>
    <entry key="FreadBitNUnsupported">For code generation, you cannot specify ''bitN'' or 'ubitN' in the precision.</entry>
    <entry key="FreadLongUnsupported">For code generation, you cannot use types ''long'', ''ulong'', or ''unsigned long'' in the precision parameter.</entry>
    <entry key="IntNbitsUnknownNbits">MATLAB 정수는 8, 16, 32, 64비트 중 하나여야 합니다. 하지만 {0, number, integer}비트의 정수가 요청되었습니다.</entry>
    <entry key="FreadCSizeMismatch">For code generation, when you specify a C type in the precision, the target and production hardware sizes for that type must match. Type {0} is {1, number, integer} bits on the target hardware, but {2, number, integer} bits on the production hardware.</entry>
    <entry key="FreadNonStandardInteger">For code generation, when you specify a C type in the precision, the hardware size of that type must match a built-in MATLAB integer. The specified size of {0, number, integer} does not match a built-in MATLAB integer.</entry>
    <entry key="FreadUseMalloc">코드 생성 시 sizeA가 상수가 아니거나 non-finite 값을 포함하는 경우 FREAD에 동적 메모리 할당이 필요합니다.</entry>
    <entry key="FreadNativeSrcType">코드 생성 시 FREAD의 소스 유형이 타깃 하드웨어의 유형에 직접 매핑되어야 합니다. 클래스 {1}이(가) {0,number,integer}비트 C 유형에 매핑되지 않습니다.</entry>
    <entry key="FgetsTooBig">코드 생성 시, 두 번째 fgets 입력값은 Inf로 설정되거나 타깃 하드웨어에서 표현 가능한 최대 배열 크기인 intmax보다 작아야 합니다.</entry>
    <entry key="InputMustBeFixedSize">입력값 {0}은(는) 고정 크기여야 합니다.</entry>
    <entry key="NoVarSizeInputs">입력값 {0}은(는) 고정 크기 차원을 가져야 합니다.</entry>
    <entry key="OptimsetPrintFieldUnsupported">코드 생성 시, OPTIMSET에 입력값과 출력값이 없는 구문을 지정하여 사용 가능한 필드를 나열하는 것은 지원되지 않습니다.</entry>
    <entry key="OptimFunctionUnsupported">코드 생성 시, OPTIMFUNCTION 입력값에 지정된 함수가 코드 생성에 대해 지원되어야 합니다. ''{0}''은(는) 그러한 함수가 아닙니다.</entry>
    <entry key="OptimsetgetFixedSizeFields">파라미터 ''{0}''에 지정된 값이 가변 크기입니다. 코드 생성 시, OPTIMSET 또는 OPTIMGET으로 전달되는 구조체 필드는 고정 크기를 가져야 합니다.</entry>
    <entry key="OptimgetConstName">코드 생성 시 OPTIMGET에 대한 ''name'' 인수는 상수여야 합니다. 제공된 값은 상수가 아닙니다.</entry>
    <entry key="OptimNoProblemStruct">MATLAB 코드 생성 시 {0}의 첫 번째 입력 인수에는 구조체가 지원되지 않습니다.</entry>
    <entry key="OptimfunFcnOrStr">코드 생성 시 {0}에 대한 첫 번째 인수는 함수 핸들 또는 함수 이름이어야 합니다.</entry>
    <entry key="OptimfunFixedSizeX">두 번째 인수는 고정 크기여야 합니다.</entry>
    <entry key="OptimfunOptArg">세 번째 인수는 옵션 구조체 또는 []이어야 합니다.</entry>
    <entry key="OptimfunCheckFunNaNVal">The user function returned NaN when evaluated at {0};\n {1} cannot continue.</entry>
    <entry key="OptimfunCheckFunComplexVal">The user function returned a complex value when evaluated at {0};\n {1} cannot continue.</entry>
    <entry key="OptimfunConstStr">코드 생성 시 함수 이름 입력값이 상수여야 합니다.</entry>
    <entry key="OptimfunRealX">코드 생성 시 {0}은(는) 시작점 ''x0''이 실수여야 합니다.</entry>
    <entry key="OptimFunScalarObjFcn">코드 생성 시 {0}이(가) 고정 크기 스칼라를 반환하려면 FUN이 필요합니다. 이를 해결하기 위해 FUN의 출력값으로 ''y(1)''을 할당해 보십시오.</entry>
    <entry key="MustBeFiniteAndStrictlyIncreasing">X must be finite and strictly increasing.</entry>
    <entry key="NDIMSError">ndims(Y)={0}이어야 하는데, ndims(Y)={1}(으)로 되어 있습니다. 코드 생성 시 ndims(Y)가 변경되어서는 안 됩니다.</entry>
    <entry key="NDIMSSizeConstantLength">코드 생성 시, 클래스 ''{0}''의 메서드 ''size''에서 반환되는 값은 상수 길이를 가져야 합니다.</entry>
    <entry key="UnsupportedNaN">NaN values in Y are not supported for code generation.</entry>
    <entry key="InvalidD">D는 고정 크기이면서 음이 아닌 요소를 갖는 숫자형 행 벡터여야 합니다.</entry>
    <entry key="PPNumberMismatchCoeffs">입력값이 일치하지 않습니다.</entry>
    <entry key="MKPPSizeMismatch">입력 인수의 크기가 일치하지 않습니다.</entry>
    <entry key="InputStructNotPP">입력 구조체가 유효한 PP 구조체가 아닙니다. MKPP를 사용하여 유효한 PP 구조체를 만드십시오.</entry>
    <entry key="PPDataMustBeNumeric">pp.breaks 필드와 pp.coefs 필드는 숫자형이어야 합니다.</entry>
    <entry key="PWCHSizeMismatch">입력 인수의 크기가 일치하지 않습니다.</entry>
    <entry key="OrderOneRequiresColumnVector">To define a piecewise constant polynomial, make the second input coefs(:).</entry>
    <entry key="OrderDimMustBeFixed">차수를 결정하는 COEFS의 차원은 고정 크기여야 합니다.</entry>
    <entry key="SizeCoefsAndDNotConsistent">COEFS에 N차원 입력값을 사용하는 경우, 세 번째 입력값 D가 제공되어야 하며 size(COEFS)의 선행 요소와 일치해야 합니다.</entry>
    <entry key="PWCHInvalidX">첫 번째 입력값 X는 부동소수점 벡터여야 합니다.</entry>
    <entry key="MATLABPPNotSupported">MATLAB에서 생성되는 PP 형식은 코드 생성 시 PPVAL에서 직접 사용할 수 없습니다. UNMKPP를 사용하여 데이터를 추출하고 MKPP를 사용하여 MATLAB Coder와 호환되는 PP 형식을 만드십시오.</entry>
    <entry key="InputMustBeNumeric">{0}은(는) 숫자형이어야 합니다.</entry>
    <entry key="interp2_minrhs">코드 생성 시 INTERP2는 최소 5개의 입력값이 필요합니다.</entry>
    <entry key="interp3_minrhs">코드 생성 시 INTERP3은 최소 7개의 입력값이 필요합니다.</entry>
    <entry key="interp2_invalidXYClass">입력값 X, Y, Xq, Yq는 ''double'' 또는 ''single''이어야 합니다.</entry>
    <entry key="interp3_invalidXYZClass">입력값 X, Y, Z, Xq, Yq, Zq는 ''double'' 또는 ''single''이어야 합니다.</entry>
    <entry key="interp2_nonrealXY">입력값 X, Y, Xq, Yq는 실수여야 합니다.</entry>
    <entry key="interp3_nonrealXYZ">입력값 X, Y, Z, Xq, Yq, Zq는 실수여야 합니다.</entry>
    <entry key="interp2_sizeXIandYIMustMatch">Arguments Xq and Yq must be the same size.</entry>
    <entry key="interp3_sizeXIYIandZIMustMatch">Arguments Xq, Yq, and Zq must be the same size.</entry>
    <entry key="interp2_ZMustBeFloat">입력값 V는 ''double'' 또는 ''single''이어야 합니다.</entry>
    <entry key="interp3_VMustBeFloat">입력값 V는 ''double'' 또는 ''single''이어야 합니다.</entry>
    <entry key="interp2_extrapvalNotReal">V가 복소수가 아닌 경우 외삽 값 extrapval은 복소수일 수 없습니다.</entry>
    <entry key="interp3_extrapvalNotReal">V가 복소수가 아닌 경우 외삽 값 extrapval은 복소수일 수 없습니다.</entry>
    <entry key="interpn_extrapvalNotReal">V가 복소수가 아닌 경우 외삽 값 extrapval은 복소수일 수 없습니다.</entry>
    <entry key="NonIncreasing">Grid values must be strictly increasing.</entry>
    <entry key="NotEnoughPoints">보간에는 각 차원별로 적어도 2개의 샘플 점이 필요합니다.</entry>
    <entry key="interp2_mixedTypeGrid">그리드 좌표는 single형 또는 double형의 동일한 유형이어야 합니다.</entry>
    <entry key="interp3_mixedTypeGrid">그리드 좌표는 single형 또는 double형의 동일한 유형이어야 합니다.</entry>
    <entry key="interp2_classXIandYIMustMatch">입력값 Xq, Yq는 모두 ''double''이거나 모두 ''single''이어야 합니다.</entry>
    <entry key="interp3_classXIYIandZIMustMatch">입력값 Xq, Yq, Zq는 모두 ''double''이거나 모두 ''single''이어야 합니다.</entry>
    <entry key="interp2_unsupportedMethod">보간 방법은 다음 중 하나여야 함: ''cubic'', ''linear'', ''nearest'', ''spline''.</entry>
    <entry key="interp3_unsupportedMethod">보간 방법은 다음 중 하나여야 함: ''cubic'', ''linear'', ''nearest'', ''spline''.</entry>
    <entry key="interp3_gridToValuesSizeMismatch">The size of V must be consistent with the sizes of X, Y, and Z.</entry>
    <entry key="interp2_VMustBe2D">V는 행렬이어야 합니다.</entry>
    <entry key="interp3_VMustBe3D">V는 3차원 배열이어야 합니다.</entry>
    <entry key="IsStrProp">Code generation does not support the 'ForceCellOutput' option for 'isstrprop'.</entry>
    <entry key="GridMustBeVectorsOrPlaid">Grid inputs must be vectors or the output of MESHGRID.</entry>
    <entry key="ExtrapvalNotNumeric">외삽 값은 숫자형이어야 합니다.</entry>
    <entry key="ExtrapvalRequired">출력 유형이 ''single'' 또는 ''double''이 아닌 경우 외삽 값을 제공해야 합니다</entry>
    <entry key="CubicGridMustBeUniform">''cubic'' 메서드의 경우 그리드 데이터는 간격이 균일해야 합니다. 균일하지 않은 그리드에는 ''spline'' 메서드를 사용하십시오.</entry>
    <entry key="MethodMustBeConstant">메서드 입력값은 상수 문자형 벡터여야 합니다.</entry>
    <entry key="NMustBeANumericScalar">N은 숫자형 스칼라여야 합니다</entry>
    <entry key="AmbiguousPartialMatch">모호한 속성 이름임: ''{0}''({1}).</entry>
    <entry key="NonNegativeRequiresReal">해 성분의 비음(non-negativity)을 적용할 때는 출력 데이터형이 실수여야 합니다. y0이 실수이고 ode 함수가 항상 실수 결과를 반환하는지 확인하십시오.</entry>
    <entry key="MassMustBeConstant">Mass 옵션은 상수 문자형 벡터 또는 함수 핸들이어야 합니다.</entry>
    <entry key="RequiresNInputs">코드 생성 시 {0}에는 최소 {1,number,integer}개의 입력값이 필요합니다. 더 적은 개수의 입력값에 해당하는 옵션은 지원되지 않습니다.</entry>
    <entry key="RequiresNOutputs">코드 생성 시 {0}에는 최소 {1,number,integer}개의 출력값이 필요합니다. 더 적은 개수의 출력값에 해당하는 옵션은 지원되지 않습니다.</entry>
    <entry key="OdegetConstName">코드 생성 시 ODEGET에 대한 ''name'' 인수는 상수여야 합니다. 제공된 값은 상수가 아닙니다.</entry>
    <entry key="OdeprintRequiresMATLAB">ODEPRINT 함수는 mex 타깃에 대해서만 또는 Simulink에서 실행되는 경우에만 지원됩니다.</entry>
    <entry key="RequiresAllConstantInputs">모든 입력값은 상수여야 합니다.</entry>
    <entry key="DynamicMemoryNeeded">이벤트 위치에는 동적 메모리 할당이 필요합니다. 동적 메모리 할당을 활성화하거나 이벤트 함수를 제거하십시오.</entry>
    <entry key="InconsistentTypes">tspan 입력값, y0 입력값과 ode 함수의 출력값은 유형이 동일해야 합니다. 즉, 모두 single형이거나 모두 double형이어야 합니다.</entry>
    <entry key="UnsupportedSolver">솔버 이름은 ''ode23'' 또는 ''ode45''여야 합니다.</entry>
    <entry key="UnsupportedODEFunction">코드 생성 시 첫 번째 입력값은 함수 핸들 또는 문자형 벡터여야 합니다.</entry>
    <entry key="TspanMustBeReal">tspan 입력값은 실수여야 합니다.</entry>
    <entry key="RequiresVariableSizing">{0}에 대한 코드를 생성하려면 가변 크기를 활성화해야 합니다.</entry>
    <entry key="ODEInconsistentTypes">tspan 입력값, y0 입력값과 ode 함수의 출력값은 유형이 동일해야 합니다. 즉, 모두 single형이거나 모두 double형이어야 합니다.</entry>
    <entry key="FOMustReturnCol">ODE 함수의 출력값은 열 벡터여야 합니다.</entry>
    <entry key="SizeIC">The size of y0 and the size of the output of the ODE function must match.</entry>
    <entry key="SizeAbsTol">AbsTol은 스칼라이거나, 길이가 {0,number,integer}인 벡터여야 합니다.</entry>
    <entry key="EventsRequireDynamicMemoryAllocation">{0}과(와) 함께 이벤트 함수를 사용하려면 가변 크기와 동적 메모리 할당을 활성화해야 합니다.</entry>
    <entry key="VarsizeTspanHasLengthTwo">tspan 입력값은 가변 크기인데, 런타임에 요소가 2개인 배열이 되었습니다. 이 경우 결과가 MATLAB과 일치하지 않습니다.</entry>
    <entry key="NoPrintStats">코드 생성 시 출력값 통계량을 출력하는 것은 지원되지 않습니다.</entry>
    <entry key="ODEOptionMustBeConstant">코드 생성 중에 옵션 {0}은(는) 상수여야 합니다.</entry>
    <entry key="ODEJacobianMustBeMatrixOrFunction">야코비 행렬은 행렬이거나 함수 핸들이어야 합니다.</entry>
    <entry key="CellArraysNotSupported">For code generation, cell array inputs to ''{0}'' are not supported.</entry>
    <entry key="LeftEigenvectorsNotSupported">코드 생성 시 좌고유벡터는 지원되지 않습니다.</entry>
    <entry key="EigCholUnsupported">코드 생성 시 ''chol'' 옵션은 지원되지 않습니다.</entry>
    <entry key="EigNobalanceNotSupported">코드 생성 시 ''nobalance'' 옵션은 지원되지 않습니다.</entry>
    <entry key="UnsupportedSpecialEmpty">If the input is a variable-size array, it cannot be 0-by-0 at run time.</entry>
    <entry key="UnsupportedNativeIntegerMean">코드 생성 시 정수 유형에는 ''native'' 플래그가 지원되지 않습니다.</entry>
    <entry key="UnknownSumProdMeanFlag">이 입력값은 다음 중 하나여야 함: ''double'',''native'', ''default''.</entry>
    <entry key="TrailingStringInputMustBeConstant">후행 문자열 입력값은 상수여야 합니다.</entry>
    <entry key="UnsupportedCharWithNative">문자형 입력값에서는 ''native'' 플래그가 지원되지 않습니다.</entry>
    <entry key="InvalidOutputSel">odeset(''OutputSel'',idx)에 지정되는 모든 인덱스는 1 &lt;= idx &lt;= neq 범위 내 정수여야 합니다.</entry>
    <entry key="FieldNamesConstStringOpt">FIELDNAMES의 옵션 인수는 상수 string형 또는 문자형 벡터여야 합니다.</entry>
    <entry key="FieldNamesStructOnly">코드 생성 시 FIELDNAMES에 대한 인수는 구조체여야 합니다.</entry>
    <entry key="HalfWithUnsupportedType">함수 ''{0}''에서, 인수 중 하나가 반정밀도 데이터형일 경우 다른 인수는 half, double, single 중 하나여야 합니다.</entry>
    <entry key="HeterogeneousCellConstSize">코드 생성 시, 입력값이 셀형 배열이면서 이 배열의 모든 요소가 동일한 유형이 아닌 경우 ''{0}''에 대한 크기 입력값이 상수여야 합니다.</entry>
    <entry key="ReshapeEmptyCellConst">코드 생성 시 ''{0}''에 대한 입력값이 빈 셀형 배열인 경우 크기 입력값은 상수 또는 []이어야 합니다.</entry>
    <entry key="NullAssignHomogeneousCell">코드 생성 시, 셀형 배열의 모든 요소가 동일한 유형이 아닌 경우 해당 요소를 삭제할 수 없습니다.</entry>
    <entry key="NullAssignNDCell">코드 생성 시, 셀형 배열이 2차원을 초과하는 경우 해당 요소를 삭제할 수 없으며 N차원 인덱싱을 사용하여 셀형 배열의 요소를 삭제할 수 없습니다.</entry>
    <entry key="NullAssignSparse">코드 생성 시 빈 행렬에 희소 행렬 요소를 할당하는 것은 지원되지 않습니다. 요소를 삭제하려면 값 0을 할당하십시오.</entry>
    <entry key="pcaInvalidAlgorithm">''{0}''은(는) ''Algorithm'' 인수에 유효한 값이 아닙니다. 값은 ''svd'', ''eig'', ''als'' 중 하나여야 합니다.</entry>
    <entry key="pcaInvalidRows">''{0}''은(는) ''Rows'' 인수에 유효한 값이 아닙니다. 값은 ''complete'', ''pairwise'', ''all'' 중 하나여야 합니다.</entry>
    <entry key="pcaWeightsMustBeReal">Weights와 VariableWeights는 실수여야 합니다.</entry>
    <entry key="pcaDisplayNotSupported">코드 생성 시 Display 옵션은 ''off''로 설정되어야 합니다.</entry>
    <entry key="statgetConstName">코드 생성 시 ''Name'' 입력값은 상수여야 합니다.</entry>
    <entry key="STATSFUNCTIONMustBeConstant">STATSFUNCTION 인수는 상수 함수 핸들이거나 상수 string형 또는 문자형 벡터여야 합니다.</entry>
    <entry key="Struct2cellHomogeneousVarsize">코드 생성 시, STRUCT2CELL에 대한 입력값이 가변 크기 배열인 경우 모든 필드가 동일한 유형이어야 합니다.</entry>
    <entry key="Struct2cellHeterogeneousLimit">코드 생성 시, STRUCT2CELL에 대한 입력 구조체형 배열이 서로 다른 유형의 필드를 갖는 경우, 결과로 생성되는 셀형 배열의 요소는 {0,number,integer}개를 넘을 수 없습니다. 이 호출은 {1,number,integer}개 요소를 갖는 셀형 배열을 만들려고 시도합니다.</entry>
    <entry key="CoderdataNoEdit">Opening coderdata files using the edit command is not supported. Use coder.read to read coderdata files and coder.write to write them.</entry>
    <entry key="CoderReadBigEndian">coder.read는 리틀 엔디안 타깃에 대해서만 지원됩니다. 지정된 HardwareImplementation은 빅 엔디안입니다.</entry>
    <entry key="CoderReadBadTypeHeader">The type header contains a {0}. Reading data of this type using coder.read is not supported.</entry>
    <entry key="CoderReadCouldNotOpen">coderdata 파일 ''{0}''을(를) 열 수 없습니다.</entry>
    <entry key="CoderReadCouldNotOpenTypeHeader">파일 ''{0}''을(를) 열 수 없습니다. 이 파일은 coder.read 함수 호출의 출력 유형을 컴파일타임에 결정합니다.</entry>
    <entry key="CoderReadProblemReading">coderdata 파일에서 읽어오는 중에 문제가 발생했습니다.</entry>
    <entry key="CoderReadUnexpectedValue">coderdata 파일에 예기치 않은 값이 있습니다.</entry>
    <entry key="CoderReadWrongHeader">Coderdata file did not contain the expected metadata, might be corrupted, or is not a coderdata file. Use ''coder.write'' to create coderdata files.</entry>
    <entry key="CoderReadUnexpectedComplex">.coderdata 파일에 실수 값이 필요한데 복소수 값이 포함되어 있었습니다. 복소수 값을 읽어오려면 복소수 유형 헤더를 사용해야 합니다</entry>
    <entry key="CoderReadWrongVersion">.coderdata 파일이 이 릴리스의 MATLAB Coder와 호환되지 않습니다. 이 버전의 MATLAB에서 데이터를 다시 저장하여 호환 파일을 생성하십시오.</entry>
    <entry key="CoderReadTypeOnly">지정된 .coderdata 파일에 유형 헤더만 들어 있고 데이터가 없기 때문에 이 파일을 읽어올 수 없습니다. coder.write를 사용하여 이 파일을 만들 때 TypeHeaderOnly 인수를 true로 설정했을 수 있습니다.</entry>
    <entry key="CoderReadMATFile">''coder.read'' only reads .coderdata files. To convert your .mat file to .coderdata format, run this command in MATLAB: coder.write(''myFile.coderdata'', load(''{0}''))</entry>
    <entry key="CoderReadWrongType">coder.read는 .coderdata 파일에 ''{1}''이(가) 필요한데 대신 ''{0}''이(가) 있습니다. 이 파일을 읽어오려면 다른 유형 헤더를 사용하십시오. 주어진 .coderdata 파일이 유형 헤더와 호환되는지 확인하려면 파일을 쓸 때 TypeHeader 이름-값 쌍을 지정하십시오.</entry>
    <entry key="CoderReadWrongNdims">.coderdata 파일에 {0}개 차원을 갖는 행렬이 포함되어 있지만, 필요한 차원 개수는 {1}개입니다.</entry>
    <entry key="FileSpecFilepathType">coder.FileSpec에 대한 모든 파일 이름 입력값은 문자형 행 벡터 또는 string형 스칼라여야 합니다</entry>
    <entry key="FileSpecMerge">제공된 .coderdata 파일의 유형을 병합할 수 없습니다.</entry>
    <entry key="FileSpecType">TypeInfo 속성은 coder.Type이어야 합니다</entry>
    <entry key="CoderWriteMustBeTypeIsh">TypeHeader input arguments must be coder.Type objects</entry>
    <entry key="CoderWriteDiscardingConstant">TypeHeader 입력 인수에 coder.Constant 객체가 포함되어 있습니다. 연결된 상수 값이 v인 경우, coder.write는 생성된 .coderdata 파일의 유형 헤더에서 이 상수 유형을 coder.typeof(v)에 의해 반환되는 상수가 아닌 유형으로 대체합니다.</entry>
    <entry key="CoderWriteDiscardingStructInfo">TypeHeader 입력 인수에 coder.StructType 객체가 포함되어 있는데, 이 객체의 정보를 coder.read 함수에서 무시합니다. coder.read 함수는 .coderdata 파일에서 구조체 데이터를 읽어올 때 유형 헤더에 있는 coder.StructType 객체의 필드 이름과 필드 유형만 사용합니다. coder.read는 StructName, Extern, Alignment, HeaderFile 속성을 무시합니다.</entry>
    <entry key="CoderWriteEnum">The enumeration class ''{0}'' is not supported for coder.write. All enumerations must inherit from one of int8, uint8, int16, uint16, or int32.</entry>
    <entry key="CoderWriteNonASCII">.coderdata files cannot contain non-ASCII characters. The following non-ASCII characters were detected: ''{0}''. They were found in the string: ''{1}''.</entry>
    <entry key="CoderWriteObject">Objects are not supported in coder.write.</entry>
    <entry key="CoderWriteExtension">File name must end in '.coderdata' or omit file extension.</entry>
    <entry key="CoderWriteNotify">파일 ''{0}''을(를) 썼습니다. 이 파일을 ''coder.read''를 사용하여 읽어올 수 있습니다.</entry>
    <entry key="CoderWriteFileType">coder.write에 대한 파일 이름 입력값은 문자형 행 벡터 또는 string형 스칼라여야 합니다.</entry>
    <entry key="CoderWriteWrongHeader">''TypeHeader''에 의해 지정된 유형이 쓰려는 데이터와 일치하지 않습니다. 데이터와 일치하도록 ''TypeHeader'' 인수를 조정하거나, ''TypeHeaderOnly=true''를 사용하여 파일을 만들 때 이 데이터를 무시하도록 하십시오.</entry>
    <entry key="CoderWriteNoName">File name cannot be empty.</entry>
    <entry key="CoderReadFname">coder.read에 대한 첫 번째 입력값은 문자형 행 벡터이거나 string형 스칼라여야 합니다.</entry>
    <entry key="CoderReadNotConst">coder.read에 파일 이름만 지정하는 경우 파일 이름은 상수여야 합니다. 상수가 아닌 파일 이름에서 읽어오려면 ''TypeHeaderFrom'' 이름-값 쌍을 사용하십시오.</entry>
    <entry key="CoderReadTypeHeader">유형 헤더 파일 이름은 상수 문자형 행 벡터이거나 string형 스칼라여야 합니다.</entry>
    <entry key="RepmatCellHeterogeneousLimit">코드 생성 시, REPMAT에 대한 입력값이 이종 셀형 배열인 경우, 결과로 생성되는 셀형 배열의 요소는 {0,number,integer}개를 넘을 수 없습니다. 이 호출은 {1,number,integer}개 요소를 갖는 셀형 배열을 만들려고 시도합니다.</entry>
    <entry key="StructConversionDimensionMismatchArray">입력값 ''{0,number,integer}'' 배열의 차원과 입력값 ''{1,number,integer}'' 배열의 차원이 일치하거나, 스칼라여야 합니다.</entry>
    <entry key="StrjoinRowVectorString">코드 생성 시 STRJOIN으로 전달되는 비어 있지 않은 문자형 벡터는 모두 행 벡터여야 합니다. 인수 {1,number,integer}의 요소 {0,number,integer}은(는) 행 벡터가 아닙니다.</entry>
    <entry key="strjust_inputMustBe2D">입력값은 2차원이어야 합니다.</entry>
    <entry key="LAPACKNoStandaloneReplacement">함수 ''{0}''에 상응하는 독립 실행형 대체가 없습니다. coder.internal.use_lapack을 사용하여 이 호출을 조건화하십시오.</entry>
    <entry key="LAPACKCallErrorInfo">The LAPACK call to ''{0}'' failed with info {1,number,integer}. Please contact MathWorks Technical Support if you can reproduce this error.</entry>
    <entry key="LAPACKOnlyComplex">''{0}''에 대한 배열 입력값은 복소수여야 합니다.</entry>
    <entry key="LAPACKOnlyReal">''{0}''에 대한 배열 입력값은 실수여야 합니다.</entry>
    <entry key="LAPACKXunormqrArgTypes">Inputs to ''{0}'' must have the same complexness except for the case that Q is real and C is complex.</entry>
    <entry key="StrcmpCharMatrix">코드 생성 시, {0}에 대한 한 입력값은 셀형 배열이고 다른 입력값은 문자형 배열인 경우 문자형 배열의 첫 번째 차원은 고정 길이 1을 가져야 합니다. 여러 문자형 벡터를 비교하려면 문자형 배열 대신 문자형 행 벡터로 구성된 셀형 배열을 전달하십시오.</entry>
    <entry key="UnsupBesNegNonIntNu">코드 생성 시 {0}에 대한 음의 NU 입력값은 정수 값이어야 합니다.</entry>
    <entry key="invalidCovNormOption">코드 생성 시, 두 번째 입력값이 고정 크기의 스칼라 값이면 항상 정규화 옵션으로 해석됩니다. 값은 0 또는 1이어야 합니다.</entry>
    <entry key="FlagMustBeConst">Flag inputs must be constant character vectors.</entry>
    <entry key="InterpnUnsupportedMethod">For code generation, INTERPN supports only the ''linear'', ''nearest'', ''spline'' and ''cubic'' methods.</entry>
    <entry key="gInterpNdUnsupportedMethod">For code generation, griddedInterpolant supports the ''makima'' method only for 1-dimensional interpolation.</entry>
    <entry key="QueryPointsMustBeReal">쿼리 점은 실수여야 합니다.</entry>
    <entry key="GridPointsMustBeReal">그리드 점은 실수여야 합니다.</entry>
    <entry key="OutOfTargetRange">Value is not within the supported target type range {0,number,integer}-{1,number,integer}.</entry>
    <entry key="OutOfTargetRangeNoBounds">지원되는 타깃 유형 범위 내에 값이 있지 않습니다.</entry>
    <entry key="StringClassNotSupported">코드 생성 시 string형 클래스는 지원되지 않습니다.</entry>
    <entry key="SparseNotSupported">For code generation, sparse matrices not supported for ''{0}''.</entry>
    <entry key="ValidateattributesBadClassList">클래스는 문자형 벡터, string형, 또는 문자형 벡터로 구성된 셀형 배열이어야 합니다.</entry>
    <entry key="ValidateattributesNeedConstClasses">클래스는 상수 문자형 벡터로 구성된 셀형 배열이어야 합니다.</entry>
    <entry key="ValidateattributesNeedFunctionName">코드 생성 시 네 번째 인수는 문자형 벡터로 지정된 함수 이름이어야 합니다.</entry>
    <entry key="ValidateattributesNeedConstFunctionName">함수 이름은 상수여야 합니다.</entry>
    <entry key="ValidateattributesNeedConstVariableName">변수 이름은 상수여야 합니다.</entry>
    <entry key="ValidateattributesNeedConstAttributes">특성은 상수여야 합니다.</entry>
    <entry key="ValidateattributesBadVariableName">다섯 번째 인수는 문자형 벡터로 지정된 입력 변수 이름이어야 합니다.</entry>
    <entry key="ValidateattributesNeedConstArgumentPosition">입력 인수의 위치는 상수여야 합니다.</entry>
    <entry key="Validateattributesexpected2D">{0}은(는) 2차원이어야 합니다.</entry>
    <entry key="Validateattributesexpected3D">{0}은(는) 3차원이어야 합니다.</entry>
    <entry key="ValidateattributesexpectedSquare">{0}은(는) 정사각 행렬이어야 합니다.</entry>
    <entry key="ValidateattributesexpectedDiag">{0}은(는) 대각 행렬이어야 합니다.</entry>
    <entry key="ValidateattributesexpectedScalar">{0}은(는) 스칼라여야 합니다.</entry>
    <entry key="ValidateattributesexpectedScalartext">{0}은(는) string형 스칼라이거나 문자형 벡터여야 합니다.</entry>
    <entry key="ValidateattributesexpectedVector">{0}은(는) 벡터여야 합니다.</entry>
    <entry key="ValidateattributesexpectedRow">{0}은(는) 행 벡터여야 합니다.</entry>
    <entry key="ValidateattributesexpectedColumn">{0}은(는) 열 벡터여야 합니다.</entry>
    <entry key="ValidateattributesexpectedNonempty">{0}은(는) 비어 있지 않아야 합니다.</entry>
    <entry key="ValidateattributesexpectedNonsparse">{0}은(는) 비희소 형식이어야 합니다.</entry>
    <entry key="ValidateattributesexpectedNonZero">{0}은(는) 0이 아니어야 합니다.</entry>
    <entry key="ValidateattributesexpectedBinary">{0}은(는) 이진이어야 합니다.</entry>
    <entry key="ValidateattributesexpectedInteger">{0}은(는) 정수 값이어야 합니다.</entry>
    <entry key="ValidateattributesexpectedReal">{0}은(는) 실수여야 합니다.</entry>
    <entry key="ValidateattributesexpectedIncreasing">{0}은(는) 증가하는 값이어야 합니다.</entry>
    <entry key="ValidateattributesexpectedNonIncreasing">{0}은(는) 증가하지 않는 값이어야 합니다.</entry>
    <entry key="ValidateattributesexpectedDecreasing">{0}은(는) 감소하는 값이어야 합니다.</entry>
    <entry key="ValidateattributesexpectedNonDecreasing">{0}은(는) 감소하지 않는 값이어야 합니다.</entry>
    <entry key="ValidateattributesexpectedOdd">{0}은(는) 홀수여야 합니다.</entry>
    <entry key="ValidateattributesexpectedEven">{0}은(는) 짝수여야 합니다.</entry>
    <entry key="ValidateattributesexpectedPositive">{0}은(는) 양수여야 합니다.</entry>
    <entry key="ValidateattributesexpectedNonnegative">{0}은(는) 음수가 아니어야 합니다.</entry>
    <entry key="ValidateattributesexpectedFinite">{0}은(는) 유한해야 합니다.</entry>
    <entry key="ValidateattributesexpectedNonNaN">{0}은(는) NaN이 아니어야 합니다.</entry>
    <entry key="ValidateattributesincorrectSize">{0}이(가) 필요한 크기를 갖고 있지 않습니다.</entry>
    <entry key="ValidateattributesBadNumel">인수 numel 다음에는 음이 아닌 실수형 정수 스칼라가 와야 합니다.</entry>
    <entry key="ValidateattributesincorrectNumel">{0}은(는) 요소가 {1, number, integer}개인 배열이어야 합니다.</entry>
    <entry key="ValidateattributesBadNrows">인수 nrows 다음에는 음이 아닌 실수형 정수 스칼라가 와야 합니다.</entry>
    <entry key="ValidateattributesincorrectNumrows">{0}은(는) 행 개수가 {1, number, integer}개인 배열이어야 합니다.</entry>
    <entry key="ValidateattributesBadNcols">인수 ncols 다음에는 음이 아닌 실수형 정수 스칼라가 와야 합니다.</entry>
    <entry key="ValidateattributesincorrectNumcols">{0}은(는) 열 개수가 {1, number, integer}개인 배열이어야 합니다.</entry>
    <entry key="ValidateattributesBadNDims">인수 ''ndims'' 다음에는 1보다 큰 실수형 정수 값이 와야 합니다.</entry>
    <entry key="ValidateattributesincorrectNDims">{0}은(는) 차원이 {1, number, integer}개인 배열이어야 합니다.</entry>
    <entry key="ValidatestringInvalidStringList">VALID_STRINGS는 string형으로 구성된 셀형 배열이어야 합니다.</entry>
    <entry key="ValidatestringNeedConstStrings">VALID_STRINGS는 상수 string형으로 구성된 셀형 배열이어야 합니다.</entry>
    <entry key="ValidatestringNeedFunctionName">코드 생성 시 세 번째 입력 인수는 함수 이름 문자열이어야 합니다.</entry>
    <entry key="ValidatestringNeedConstFunctionName">함수 이름은 상수여야 합니다.</entry>
    <entry key="ValidatestringBadFunctionName">함수 이름은 문자형 벡터여야 합니다.</entry>
    <entry key="ValidatestringNeedConstVariableName">VARIABLE_NAME은 상수여야 합니다.</entry>
    <entry key="ValidatestringBadVariableName">VARIABLE_NAME은 string형이거나 문자형 벡터여야 합니다.</entry>
    <entry key="ValidatestringNeedConstArgumentPosition">ARGUMENT_POSITION은 상수여야 합니다.</entry>
    <entry key="ValidatestringBadArgumentPosition">ARGUMENT_POSITION은 양의 정수여야 합니다.</entry>
    <entry key="ValidatestringAmbiguousStringChoice">Expected {0} to match one of these strings: {1}. The input{2} matched more than one valid string.</entry>
    <entry key="ValidatestringUnrecognizedStringChoice">Expected {0} to match one of these strings: {1}. The input{2} did not match any of the valid strings.</entry>
    <entry key="ValidatestringUnrecogonizedStringChoiceExpectedChar">{0}은(는) 다음 문자열 중 하나와 일치해야 합니다: {1}. 입력값 {2}은(는) 어떠한 유효한 문자열과도 일치하지 않습니다. 입력값은 문자형, string형 중 하나여야 합니다. 현재는 유형이 {3}입니다.</entry>
    <entry key="ValidatestringUnrecognizedStringChoiceExpectedRow">{0}은(는) 다음 문자열 중 하나와 일치해야 합니다: {1}. 입력값 {2}은(는) 어떠한 유효한 문자열과도 일치하지 않습니다. 입력값은 행 벡터여야 합니다.</entry>
    <entry key="RepelemUnsupportedND">코드 생성 시 요소 배열은 2차원이어야 합니다.</entry>
    <entry key="TooManyFilesOpen">For code generation, maximum number of open files is {0, number, integer}.</entry>
    <entry key="SparseNumelTooBig">Number of elements exceeds maximum representable value.</entry>
    <entry key="SparseNzmaxTooSmall">0이 아닌 요소의 개수가 적어도 sparse의 처음 3개 인수에 의해 지정된 요소 개수와 같아야 합니다.</entry>
    <entry key="SparseNeedsMalloc">희소 행렬을 만들려면 동적 메모리 할당이 활성화되어야 합니다.</entry>
    <entry key="SparseC99">TargetLangStandard가 ''{0}''입니다. 코드 생성 시, 희소 행렬 분해 함수와 mldivide에는 C99 이상이 필요합니다. 생성 코드가 일부 희소 형식 입력값에 대해 컴파일되지 않을 수 있습니다.</entry>
    <entry key="SparseDoubleBackslash">코드 생성 시 희소 행렬의 백슬래시에 대한 입력값은 double형이어야 합니다.</entry>
    <entry key="SparseCholOption">코드 생성 시 희소 행렬에 대해 지원되는 유일한 chol 구문 옵션은 'upper' 및 'lower'입니다.</entry>
    <entry key="SparseCholSyntax">코드 생성 시, 희소 행렬에 'chol'을 사용할 때는 하나의 출력 인수만 지원하며 'vector' 옵션은 허용하지 않습니다.</entry>
    <entry key="scalarSizeDims">차원 인수 ''{0}''이(가) 스칼라가 아닙니다. 크기에 여러 차원을 개별 인수로 제공하는 경우 이러한 인수는 모두 스칼라여야 합니다.</entry>
    <entry key="StringUnsupportedType">코드 생성 시 입력 인수는 string형 스칼라, 문자형 행 벡터 또는 단일 문자형 행 벡터를 포함하는 셀형 배열이어야 합니다.</entry>
    <entry key="StringMustBeRowVector">코드 생성 시 입력 문자형 배열은 행 벡터여야 합니다.</entry>
    <entry key="StringMustBeRowVectorInCell">코드 생성 시 입력 셀형 배열 내의 문자형 배열은 행 벡터여야 합니다.</entry>
    <entry key="StringMustBeScalarCellArray">코드 생성 시 입력 셀형 배열은 단일 문자형 행 벡터를 포함해야 합니다.</entry>
    <entry key="StringUnrecognizedParameterName">파라미터 이름은 ''{0}''이어야 합니다.</entry>
    <entry key="StringParameterNameMustBeRightType">파라미터 이름은 string형 스칼라이거나 문자형 벡터여야 합니다.</entry>
    <entry key="StringParameterMustHaveAssociatedValue">입력 인수의 개수가 올바르지 않습니다. 각 파라미터 이름 다음에는 대응값이 와야 합니다.</entry>
    <entry key="StringValueArgMustBeScalar">''{0}'' 값은 스칼라 논리값이어야 합니다.</entry>
    <entry key="StringValueArgMustBeChar">''{0}'' 값은 ''{1}'' 또는 ''{2}''이어야 합니다.</entry>
    <entry key="StringIndexMustBePositiveInteger">숫자형 위치는 양의 정수 스칼라여야 합니다.</entry>
    <entry key="StringIndexMustNotExceedLength">숫자형 위치가 입력 문자열의 길이를 초과합니다.</entry>
    <entry key="StringOptionMustBeOneOf">옵션은 ''left'', ''right'', ''both'' 중 하나이거나 정확히 하나의 문자여야 합니다.</entry>
    <entry key="StringOptionMustBeOneOfSideOnly">옵션은 ''left'', ''right'', ''both'' 중 하나여야 합니다.</entry>
    <entry key="StringStripCharOrString">제거할 문자는 string형 스칼라이거나 문자형 벡터여야 합니다.</entry>
    <entry key="StringStripCharacterSize">제거할 문자는 정확히 하나의 문자여야 합니다.</entry>
    <entry key="StringStartPositionAfterEndPosition">숫자형 시작 위치는 숫자형 끝 위치 앞에 와야 합니다.</entry>
    <entry key="SscanfTwoOutputs">출력 인수가 너무 많습니다. 코드 생성 시, 형식이 지정된 배열에 대한 sscanf 출력값을 제한하고 이 배열로 성공적으로 읽어올 요소의 개수를 제한하십시오. </entry>
    <entry key="SscanfInvalidInput">첫 번째 인수는 텍스트 스칼라여야 합니다.</entry>
    <entry key="TooManyElementsToIndex">현재 인덱싱 클래스에서는 배열의 최대 요소 개수가 {0,number,integer}개로 제한됩니다.</entry>
    <entry key="EnumMustBeScalar">코드 생성 시 ''{0}''에 대한 열거형 입력값은 컴파일타임 스칼라여야 합니다.</entry>
    <entry key="MustBeCharOrString">Input number {0} must be a string scalar, character vector, or cell array with one character vector.</entry>
    <entry key="MustBeCharCellArrayOrString">Input number {0} must be a string scalar, character vector, or cell array of character vectors.</entry>
    <entry key="StringScalarsOnly">For code generation, {0} inputs to ''{1}'' must be compile-time scalars.</entry>
    <entry key="SprintfCallFailed">C sprintf에 대한 호출이 실패했습니다(상태: {0,number,integer}).</entry>
    <entry key="StringNumericIntegerInf">For code generation, numeric values being converted to string arrays must have an integer value or be infinity.</entry>
    <entry key="StringNumericNoNaN">For code generation, numeric values being converted to string arrays must be non-NaN.</entry>
    <entry key="StringNoMissing">Code generation does not support missing values in strings.</entry>
    <entry key="StringReturnMissing">Function {0} attempted to return a missing string value, which is not supported by code generation.</entry>
    <entry key="SamplePointsNotSupported">코드 생성 시 {0}에서 ''SamplePoints''는 지원되지 않습니다.</entry>
    <entry key="SamplePointsMustBeFloat">코드 생성 시 ''SamplePoints''는 double형 또는 single형이어야 합니다.</entry>
    <entry key="AmbiguousName">이름이 다음 값 중 하나와 일치해야 합니다:\n\n{1}\n\n입력값 ''{0}''은(는) 둘 이상의 유효한 값과 일치합니다.</entry>
    <entry key="InvalidName">이름이 다음 값 중 하나와 일치해야 합니다:\n\n{1}\n\n입력값 ''{0}''은(는) 어떠한 유효한 값과도 일치하지 않습니다.</entry>
    <entry key="BadIgnoreNulls">IgnoreNulls value must be true or false.</entry>
    <entry key="BadSupportOverrides">SupportOverrides value must be true or false.</entry>
    <entry key="InvalidMixedOptions">The chosen options are incompatible.</entry>
    <entry key="InvalidSparseDimensions">''sparse'' 함수에 대한 배열 인수는 2차원이어야 합니다.</entry>
    <entry key="PWSHostTargetIntegerSize">printf, fprintf 등에 대한 호출에서 형식 지정자 ''%{0}''과(와) 함께 제공되는 데이터는 타깃 하드웨어에서 C/C++ 유형 ''{1}''(으)로, 호스트 하드웨어에서 유형 ''{2}''(으)로 처리됩니다. 이식 가능한 워드 크기 기능을 활성화한 경우 호스트 하드웨어와 타깃 하드웨어 모두에서 데이터가 유사하게 해석되어야 합니다. 입력값을 부동소수점 유형으로 형변환하거나, 타깃 하드웨어와 호스트 하드웨어 모두에서 동일하게 해석되는 MATLAB 정수 유형으로 형변환하십시오. 정수 유형 ''char'', ''short'', ''int'' 및 이들의 부호 없는 버전은 모두 ''int''로 해석됩니다. 유형 ''long'', ''long long'' 및 이들의 부호 없는 버전은 각각 구별하여 처리됩니다.</entry>
    <entry key="InvalidDimInput">차원 입력값은 입력 데이터의 차원 개수를 초과할 수 없습니다.</entry>
    <entry key="SortedBufferFull">버퍼가 꽉 찼습니다. 값이 삽입되지 않았습니다.</entry>
    <entry key="RandLikeConst">코드 생성 시 ''like'' 인수는 상수 문자형 벡터이거나 string형 스칼라여야 합니다.</entry>
    <entry key="FFTWPlanMethodMustBeConst">fftw의 planning 방법은 상수여야 합니다.</entry>
    <entry key="FFTWLargeRankWithoutMalloc">동적 메모리 할당이 비활성화된 경우 차원이 {0,number,integer}(fft/ifft 경우), {1,number,integer}(fft2/ifft2 경우) 또는 {2,number,integer}(fftn/ifftn 경우)보다 큰 입력 배열에 대해 FFTW를 사용하여 FFT를 계산하는 것은 지원되지 않습니다. 높은 차원의 입력 배열에 대해 연산하는 FFT 함수의 코드를 생성하려면 먼저 동적 메모리 할당을 활성화하십시오.</entry>
    <entry key="NarginNargoutMismatch">출력 인수의 개수는 입력 인수의 개수와 일치해야 합니다.</entry>
    <entry key="DataVariablesNotSupported">코드 생성 시 DataVariables 입력값은 지원되지 않습니다.</entry>
    <entry key="OptionStringsMustBeConstant">String scalar and character vector inputs must be constant.</entry>
    <entry key="mustBeMember">Value must be a member of the specified set.</entry>
    <entry key="SparseConcatenation2D">희소 행렬을 2차원을 초과하는 배열과 결합하는 것은 지원되지 않습니다.</entry>
    <entry key="ConcatenationDimensionMismatch">결합을 위한 입력 행렬 {1,number,integer}의 차원({0,number,integer})이 이전 피연산자의 상응하는 크기({2,number,integer})와 일치하지 않습니다.</entry>
    <entry key="SparseConcatenationUnsupportedType">유형 {0}의 희소 행렬은 지원되지 않습니다.</entry>
    <entry key="SparseSanityCheckPropError">Internal error: Sparse matrix property ''{0}'' must be {1}.</entry>
    <entry key="SparseSanityCheckZeros">Detected 0 in data vector at index {0} of {1}(=nzmax), 0's are not allowed after index nnz ({2}).</entry>
    <entry key="StackPopEmpty">Cannot pop from an empty stack.</entry>
    <entry key="StackPeekEmpty">Cannot peek into an empty stack.</entry>
    <entry key="StackPushLimit">고정 크기 스택이 용량에 도달하여 밀어넣을 수 없습니다.</entry>
    <entry key="SparseConstructor2D">희소 형식 생성자에 대한 입력값은 2차원이어야 합니다.</entry>
    <entry key="SparseNot">0이 아닌 요소가 너무 많이 포함되어 있기 때문에 ''~''의 결과를 나타낼 수 없습니다.</entry>
    <entry key="SparseNegativeSize">희소 행렬 크기는 음이 아닌 정수여야 합니다.</entry>
    <entry key="SparseMaxSize">코드 생성 시 희소 행렬 크기는 intmax(''int32'')보다 작고 타깃 하드웨어에 지정된 ''int''의 최댓값({0,number,integer})보다 작아야 합니다.</entry>
    <entry key="ShapeParameterMustBeConstant">형태 인수는 상수여야 합니다.</entry>
    <entry key="SparseAssertTrailing">''assert'' 함수에 대한 조건 인수만 희소 형식일 수 있습니다.</entry>
    <entry key="SparseColonOverflow">선형 인덱싱 연산을 수행할 수 없습니다. 결과로 생성된 행렬이 표현 가능한 최대 크기를 초과합니다.</entry>
    <entry key="SparseFuncAlmostFull">이 연산의 결과는 표현 가능한 최대 배열 크기를 초과할 수 있습니다.</entry>
    <entry key="SparseTooBig">결과로 생성된 희소 행렬 크기가 최대 열 개수인 intmax를 초과합니다.</entry>
    <entry key="SparseCatTooBig">Result of concatenation exceeds the maximum representable number of {0}, intmax.</entry>
    <entry key="SparseLogicalIndexingNotSupported">코드 생성 시 논리형 배열을 사용하여 희소 행렬로 인덱싱하는 것은 지원되지 않습니다. FIND를 사용하여 논리형을 숫자형으로 변환해 보십시오.</entry>
    <entry key="FunctionDoesNotSupportDatatype">The function {0} does not support {1} inputs for code generation.</entry>
    <entry key="MinMaxFullDim">Code generation does not support sparse matrix inputs for the DIM argument to ''{0}''.</entry>
    <entry key="RankDefVarSizeRequired">랭크 부족 입력값이 감지되었습니다. 이 문제를 해결하려면 가변 크기 조정을 활성화하십시오.</entry>
    <entry key="Num2CellDim">코드 생성 시 num2cell에 대한 ''dim'' 인수는 지원되지 않습니다.</entry>
    <entry key="Str2NumNotSupported">Code generation does not support STR2NUM. Use STR2DOUBLE instead.</entry>
    <entry key="ClearNoEffect">코드 생성 시 ''clear''는 무시됩니다.</entry>
    <entry key="CovAmbiguousMLEArg">Unable to determine whether the second input is Y data or a normalization input.</entry>
    <entry key="SparseOptionMustBeConstant">여섯 번째 입력값 ISSPARSE는 상수여야 합니다.</entry>
    <entry key="ArrayfunUnequalSize">Previous inputs had size {0,number,integer} in dimension {1,number,integer}. Input {2,number,integer} has size {3,number,integer}.</entry>
    <entry key="UniformOutputMustBeTrue">코드 생성 시 UniformOutput은 true여야 합니다.</entry>
    <entry key="FullDims">코드 생성 시 차원 인수는 full(비희소 형식)이어야 합니다.</entry>
    <entry key="DimMustBeConstant">For code generation, the dimension argument must be constant.</entry>
    <entry key="NotAScalarOutput">코드 생성 시 입력값이 고정 크기 스칼라일 경우 arrayfun에 제공되는 함수는 고정 크기 스칼라 출력값을 반환해야 합니다. 출력값 {0,number,integer}은(는) 이 요구 사항을 충족하지 않습니다.</entry>
    <entry key="QRUpdateChangesComplexity">코드 생성 시 업데이트 벡터 중 하나가 복소수일 경우 qrupdate에 대한 Q 입력값과 R 입력값도 모두 복소수여야 합니다.</entry>
    <entry key="QRUpdateChangesClass">코드 생성 시 업데이트 벡터 중 하나가 single형일 경우 qrupdate에 대한 Q 입력값과 R 입력값도 모두 single형이어야 합니다.</entry>
    <entry key="QRUpdateRequiresSameClass">코드 생성 시 qrupdate에 대한 Q 입력값과 R 입력값은 동일한 클래스에 속해야 합니다. 즉, 모두 single형이거나 모두 double형이어야 합니다.</entry>
    <entry key="QRUpdateRequiresSameComplexity">코드 생성 시 qrupdate에 대한 Q 입력값과 R 입력값은 둘 다 실수이거나 둘 다 복소수여야 합니다.</entry>
    <entry key="InputsMustBe2D">입력값은 2차원이어야 합니다.</entry>
    <entry key="InvalidTolInput">tol 입력값은 음이 아닌 부동소수점 스칼라여야 합니다.</entry>
    <entry key="InvalidColumnSortingVector">열 정렬 입력값은 벡터여야 합니다.</entry>
    <entry key="InputMustBe2DFloat">입력값 {0}은(는) single형 행렬 또는 double형 행렬이어야 합니다.</entry>
    <entry key="FillValueRequired">코드 생성 시 ''fun''이 셀형 배열을 반환하는 경우 accumarray에 대한 fillval 입력값이 필요합니다.</entry>
    <entry key="InconsistentCellArrays">For code generation, the output of fun and the fillval input must be consistent types.</entry>
    <entry key="PausePARFOR">For MEX code generation or simulation, the PAUSE function is not supported inside parfor loops.</entry>
    <entry key="CoderTimeCallFailed">Call to ''{0}'' failed with return value {1,number,integer}.</entry>
    <entry key="CellInputNotSupported">Cell array inputs to ''{0}'' are not supported for code generation.</entry>
    <entry key="SizeSubs2MustBeConstant">코드 생성 시 size(SUBS,2)는 상수여야 합니다.</entry>
    <entry key="SizeSZMustBeConstant">코드 생성 시 SZ 입력값은 고정 크기 행 벡터여야 합니다.</entry>
    <entry key="CoderInternalRandstreamNoGlobalStream">코드 생성 시 전역 RandStream을 설정하거나 가져오는 것은 지원되지 않습니다.</entry>
    <entry key="TocInputType">코드 생성 시 toc는 uint64 입력값을 지원하지 않습니다. tic에 대한 이전 호출의 출력값을 toc에 대한 입력값으로 전달하십시오.</entry>
    <entry key="TypeCastDataTypeMustBeConstant">코드 생성 시 데이터형 입력값은 상수여야 합니다.</entry>
    <entry key="SVDParametersMustBeConstant">내부 SVD 함수에 대한 Job 파라미터는 상수여야 합니다.</entry>
    <entry key="BuildConfigCacheNoConfig">The current BuildConfig has not been set.</entry>
    <entry key="BuildConfigCacheInconsitentConfig">불일치하는 BuildConfig를 사용하여 BuildConfig 캐시를 업데이트하려고 합니다.</entry>
    <entry key="DimCannotBeHalf">코드 생성 시 DIM 인수의 유형은 half일 수 없습니다.</entry>
    <entry key="XzgetrsUnimplemented">LAPACK 루틴 xGETRS의 호출 위치는 참조 구현의 구현되지 않은 기능을 필요로 합니다. 현재 ia0=1, lda=size(A,1), ib0=1, ldb=size(B,1)만 지원됩니다.</entry>
    <entry key="FunctionNotSupportedForStandalone">독립 실행형 코드 생성 시 함수 ''{0}''은(는) 지원되지 않습니다.</entry>
    <entry key="IschangeVarSizeNeeded">ischange의 방법이 ''linear''인 경우 두 번째 출력값과 세 번째 출력값을 계산하려면 가변 크기가 지원되어야 합니다.</entry>
    <entry key="IschangeTableNotSupported">코드 생성 시 table형 입력값은 지원되지 않습니다.</entry>
    <entry key="ListCannotBeExpanded">The new element cannot be added because the list is statically-sized and is full.</entry>
    <entry key="FixedCapPropertyMustBeConstant">FixedCapacity 값이 제공되는 경우에는 상수여야 하며, true 또는 false여야 합니다.</entry>
    <entry key="FixedCapListRequiresInitCap">고정 용량의 목록 객체를 생성하려면 초기 용량을 제공해야 합니다.</entry>
    <entry key="DataVarsMustBeConstant">코드 생성 시 ''DataVariables''와 관련된 값은 상수여야 합니다.</entry>
    <entry key="TablesNotSupported">코드 생성 시 ''{0}''에 대한 table형 입력값은 지원되지 않습니다.</entry>
    <entry key="SupportPackageNotInstalledCRL">''{0}''이(가) 설치되지 않았습니다. 생성 코드에서 코드 대체가 비활성화되었습니다.</entry>
    <entry key="ConvhullUnsupportedDim">For code generation, convhull supports only 2D inputs.</entry>
    <entry key="MustBeSameClass">{0}과(와) {1}은(는) 동일한 클래스에 속해야 합니다.</entry>
    <entry key="IfComplexBThenComplexA">{0}이(가) 복소수인 경우 {1}도 복소수여야 합니다.</entry>
    <entry key="MustBeUpperTriangular">{0}은(는) 상부 삼각이어야 합니다.</entry>
    <entry key="EigOptionRequiresLAPACK">독립 실행형 코드 생성에서 옵션 ''{0}''을(를) 사용하려면 LAPACK 라이브러리를 구성해야 합니다. LAPACK 콜백 클래스를 지정하십시오.</entry>
    <entry key="LeftEigVecRequiresLAPACK">독립 실행형 코드 생성에서 좌고유벡터를 계산하려면 LAPACK 라이브러리를 구성해야 합니다. LAPACK 콜백 클래스를 지정하십시오. </entry>
    <entry key="PcgInvalidInput">인수는 배정밀도 행렬 또는 함수 핸들이어야 합니다.</entry>
    <entry key="PcgRHSInvalidType">우변은 비희소 형식의 배정밀도 열 벡터여야 합니다.</entry>
    <entry key="PcgInitGuessInvalidType">초기 추측값은 비희소 형식의 배정밀도 열 벡터여야 합니다.</entry>
    <entry key="PcgNonSparsePreconditioner">선조건자 행렬은 비희소 형식이어야 합니다.</entry>
    <entry key="PcgVarSizeInputEmpty">A variable sized input to pcg should not become empty at runtime.</entry>
    <entry key="PcgInvalidTolerance">입력값 허용오차는 실수형 스칼라여야 합니다.</entry>
    <entry key="PcgInvalidMaxit">입력 행렬은 실수형 스칼라여야 합니다.</entry>
    <entry key="MustNotBeNaN">For code generation, {0} must not be NaN.</entry>
    <entry key="BoundedStr2FuncUnexpectedInput">Function name ''{0}'' is not in the list of supported functions.</entry>
    <entry key="BoundedStr2FuncNamesNotCellString">두 번째 인수(함수 이름)는 문자형 벡터로 구성된 셀형 배열이어야 합니다.</entry>
    <entry key="BoundedStr2FuncNamesNotConstant">두 번째 인수(함수 이름)는 상수여야 합니다.</entry>
    <entry key="ParameterSuppliedTwice">The parameter ''{0}'' is defined more than once.</entry>
    <entry key="FirstArgumentMustBeLessThan">First argument must be less than {0}.</entry>
    <entry key="OptionInputsMustBeConstant">For code generation, option inputs to {0} must be constants.</entry>
    <entry key="SetEnvPARFOR">setenv function is not supported inside parfor loops.</entry>
    <entry key="InvalidOrNonConstantNaNFlag">Invalid option combination. Option must be ''omitnan'' or ''includenan'', and for code generation it must be a constant.</entry>
    <entry key="LimitedExpansionWithTarget">코드 생성 타깃이 ''{1}''인 경우 ''{0}'' 함수는 고정 크기 1×1 입력값의 확장만 지원합니다. 입력값들의 크기가 서로 다른 경우 이 중 하나는 스칼라여야 합니다.</entry>
    <entry key="QhullInternalError">An internal error occurred calling Qhull.</entry>
    <entry key="ParallelNotSupported">Code generation does not support function ''{0}'' in parallel regions.</entry>
    <entry key="IntegralWayPointsTypeMismatch">코드 생성 시 중간점(Waypoints)이 ''single''이면 적어도 하나의 끝점이 ''single''이어야 합니다.</entry>
    <entry key="IntegralArrayValuedMustBeConstant">옵션 ''ArrayValued''는 상수여야 합니다.</entry>
    <entry key="IntegralOutputSizeOfFunMustBeConstant">코드 생성 시 FUN은 고정 크기의 배열을 반환해야 합니다.</entry>
    <entry key="IntegralTooManyInitialIntervals">Integration cannot start as the number of intervals exceeds the limit allowed by static memory allocation. Consider enabling dynamic memory allocation.</entry>
    <entry key="IntegralSparseNotSupported">Code generation for integral does not support function handles that return sparse matrix outputs.</entry>
    <entry key="NullInvalidTolerance"> 코드 생성 시 null에 대한 두 번째 입력값은 실수 숫자형 스칼라 허용오차여야 합니다.</entry>
    <entry key="InterpftDimMustBeConst">DIM은 상수여야 합니다.</entry>
    <entry key="InterpftNyMustBePositiveInteger"> 입력값 ''ny''는 양의 정수 스칼라여야 합니다.</entry>
    <entry key="EncodingInvalidEncoding">Invalid encoding name.</entry>
    <entry key="EncodingConversionError">Unable to convert string from UTF-16 to the MATLAB code generation character encoding ''{0}''.</entry>
    <entry key="EncodingSizeConsistencyError">Conversion of string from UTF-16 to MATLAB code generation character encoding (''{0}'') changes the number of characters. This behavior is not supported for code generation.</entry>
    <entry key="EncodingUnknown">An unknown error occurred while changing the encoding of a string.</entry>
    <entry key="EncodingVarsize">문자열 ''{0}''을(를) UTF-8 인코딩으로 변환하는 과정에서 문자열의 바이트 수가 변경되었습니다. 가변 크기 배열 지원이 비활성화되어 있으면 코드 생성 시 이 동작이 지원되지 않습니다. 가변 크기 배열 지원을 활성화하거나(동적 메모리 할당은 계속 비활성으로 유지할 수 있음), 127보다 큰 문자 값으로 문자열을 인코딩하지 마십시오.</entry>
    <entry key="Integral2maxRectanglesFail">사각형 개수가 정적 메모리 할당이 허용하는 한도를 초과했습니다. 메시를 더 미세하게 조정하려면 동적 메모리 할당을 활성화해 보십시오. 결과가 전역 오차 테스트를 통과하지 못했습니다.</entry>
    <entry key="Integral2maxRectanglesPass">사각형 개수가 정적 메모리 할당이 허용하는 한도를 초과했습니다. 메시를 더 미세하게 조정하려면 동적 메모리 할당을 활성화해 보십시오. 결과가 전역 오차 테스트를 통과했습니다.</entry>
    <entry key="Integral3UnsupportedClass">입력 함수는 ''double''형 또는 ''single''형 값을 반환해야 합니다. ''{0}''을(를) 발견했습니다.</entry>
    <entry key="Integral3InvalidXMin">XMIN은 부동소수점 스칼라여야 합니다.</entry>
    <entry key="Integral3InvalidXMax">XMAX는 부동소수점 스칼라여야 합니다.</entry>
    <entry key="PolySimplifyNotSupported">코드 생성 시 polyshape에 대해 'simplify'를 true로 설정하는 것은 지원되지 않습니다.</entry>
    <entry key="WarnPolyDefaultSimplifyFalse">코드 생성에서는 'simplify' 플래그가 기본적으로 'false'로 설정됩니다. 코드 생성 시 polyshape에 대해 'simplify'를 true로 설정하는 것은 지원되지 않습니다.</entry>
    <entry key="PolyVertDotAssgnFail">Code generation does not allow setting vertices using dot assign.</entry>
    <entry key="PolyUnsupportedMethod">Function ''{0}'' in class polyshape is not supported for code generation.</entry>
    <entry key="EmptyInteroplantObjectErr">Creation of empty griddedInterpolant objects is not supported for code generation.</entry>
    <entry key="gridInterp1Donly">코드 생성 시 샘플 점은 1차원이어야 합니다.</entry>
    <entry key="Next1Donly">Sample points must be 1-dimensional for ''next'' method.</entry>
    <entry key="Pchip1Donly">Sample points must be 1-dimensional for ''pchip'' method.</entry>
    <entry key="Previous1Donly">Sample points must be 1-dimensional for ''previous'' method.</entry>
    <entry key="CannotUseSetOnMethod">코드 생성에서는 속성 설정 메서드를 사용하여 ''Method''와 ''ExtrapolationMethod''에 값을 할당할 수 없습니다. ''Method''와 ''ExtrapolationMethod'' 속성을 설정하려면 값을 생성자에 전달하십시오.</entry>
    <entry key="griddedInterpolantCannotBeEntryPoint">코드 생성 시 griddedInterpolant 클래스의 객체를 진입점 함수에 대한 입력 인수로 전달할 수 없습니다.</entry>
    <entry key="MessageStringNotSupported">코드 생성 시 메시지 클래스의 string 메서드는 지원되지 않습니다.</entry>
    <entry key="MessageGetStringNotSupported">코드 생성 시 메시지 클래스의 getString 메서드는 지원되지 않습니다.</entry>
    <entry key="IssueWarningsWithNoOutputs">Code generation does not support an output to the ''warning'' function when issuing a warning.</entry>
    <entry key="FirstInputMustBeAConstant">''{0}''에 대한 첫 번째 입력값은 상수여야 합니다.</entry>
    <entry key="CdInputMustBeEmpty">Code generation for ''cd'' with inputs is not supported.</entry>
    <entry key="FuncNeedsDynamic">To generate code, in configuration settings, enable dynamic memory allocation and support for variable-size arrays/signals. To perform Simulink simulation, enable dynamic memory allocation only. Alternately, remove the function ''{0}''.</entry>
    <entry key="mustBeFile">입력 경로는 파일이어야 합니다.</entry>
    <entry key="mustBeFolder">입력 경로는 폴더여야 합니다.</entry>
    <entry key="PolyCPP03">TargetLangStandard가 ''{0}''입니다. 코드 생성 시 polyshape 클래스는 C++11 이상이 필요합니다. 생성 코드가 일부 객체 함수에 대해 컴파일되지 않을 수 있습니다.</entry>
    <entry key="CurrentDirDeleted">Unable to access current directory or directory no longer exists.</entry>
    <entry key="AppendStringCellArray">''append''에 대한 셀 입력값 중에 비 스칼라가 있으면 어떠한 입력값도 string형이 될 수 없습니다. 코드 생성 시 string형 배열은 출력값으로 지원되지 않습니다. char()을 사용하여 string형을 문자형 배열로 변환하십시오.</entry>
    <entry key="Cell2StructConstFields">''cell2struct''에 대한 코드 생성 시 ''fields'' 입력값은 상수여야 합니다. </entry>
    <entry key="Cell2StructdimNotConst">이종 셀 입력값인 경우 차원 인수는 상수여야 합니다.</entry>
    <entry key="Cell2StructHeterogeneousLimit">''cell2struct''에 대한 코드 생성 시, cell2struct에 대한 입력 셀형 배열이 이종인 경우 그 셀형 배열의 요소는 {0,number,integer}개를 넘을 수 없습니다.</entry>
    <entry key="Cell2StructUnsupportedSpecialEmpty">입력값이 가변 크기인 경우 런타임에 비어 있을 수 없습니다.</entry>
    <entry key="Cell2MatCellInput">''cell2mat''에 대한 입력값은 셀형이어야 합니다.</entry>
    <entry key="PolyIndexError">Boundary index elements must be positive integers.</entry>
    <entry key="mustBeUnderlyingType">Value must have one of the specified underlying types.</entry>
    <entry key="mustBeUnderlyingTypeInput">''ClassNames'' 인수는 비어 있지 않은 string형, 문자형 벡터, 또는 문자형 벡터로 구성된 셀형 배열이어야 합니다.</entry>
    <entry key="ClockTwoOutUnsupported">Code generation is not supported for ''clock'' with two output arguments.</entry>
    <entry key="Cell2MatSparseUnboundInput">Code generation not supported for ''cell2mat'' with unbounded or variable-size cell containing sparse arrays.</entry>
    <entry key="Cell2MatNdUnboundInput">Code generation not supported for ''cell2mat'' with unbounded or variable-sized cell with dimension greater than 2.</entry>
    <entry key="assigninOnlyBaseSupported">C/C++ 코드 생성 시 입력 작업 공간의 값은 ''base''여야 합니다.</entry>
    <entry key="AssigninPARFOR">For C/C++ code generation, ''assignin'' function is not supported inside parfor loops.</entry>
    <entry key="FilepartsMustBeChar">입력값은 문자로 구성된 행 벡터, string형 스칼라, cellstr 중 하나여야 합니다.</entry>
    <entry key="CellfunNoErrorHandler">''ErrorHandler''가 지정된 경우 ''cellfun''에 대해서는 코드 생성이 지원되지 않습니다.</entry>
    <entry key="CellfunAtleastOneInput">''cellfun'' 함수 시그니처에는 최소 하나의 입력 셀형 배열이 필요합니다.</entry>
    <entry key="CellfunExpectCell">Input #{0} is expected to be a cell array, but {1} was found instead.</entry>
    <entry key="CellfunStructFieldClassMismatch">출력값 {2}의 인덱스 {1}에 해당하는 필드 ''{0}''에서 데이터형 불일치가 있습니다({3} 대 {4}).</entry>
    <entry key="CellfunNonConstInput">C/C++ 코드 생성 시 ''UniformOutput'' 옵션 값은 상수여야 합니다.</entry>
    <entry key="CellfunOutputMxArray">외재적 함수에서 ''cellfun''의 출력값(#{0})을 반환할 수 없습니다.</entry>
    <entry key="iofunURLInputsNotSupported">Standalone code generation does not support URL inputs.</entry>
    <entry key="iofunNonEmptyInput">모든 인수는 비어 있지 않은 문자형 벡터이거나 string형 스칼라여야 합니다.</entry>
    <entry key="iofunWritePermissionError">Cannot write to destination. Use the 'f' option to attempt an override.</entry>
    <entry key="iofunPermissionError">Permission denied error. One or more permissions missing from source or destination.</entry>
    <entry key="iofunFilePathTooLong">The filename or extension is too long.</entry>
    <entry key="iofunResourceNotFound">The specified location was not found.</entry>
    <entry key="iofunDirNotEmpty">The specified path is a non-empty folder.</entry>
    <entry key="iofunResourceIsDir">Destination is not a folder. When moving a source folder, the destination must also be a folder.</entry>
    <entry key="iofunErrorInPlatformAPI">Error occurred while performing move or copy operation.</entry>
    <entry key="iofunWildcardOpsNotSupported">Wildcard operations are not supported for standalone code generation of movefile and copyfile.</entry>
    <entry key="iofunCrossVolumeDirMoveNotSupported">Standalone code generation does not supporting moving folder across volumes.</entry>
    <entry key="iofunForceFlagMustBeCompileTimeConstant">독립 실행형 코드 생성 시 선택적 플래그 ''f''는 컴파일타임 상수여야 합니다.</entry>
    <entry key="FunctionNeedsNonFiniteSupport">코드를 생성하려면 구성 옵션 'SupportNonFinite'를 true로 설정하거나 함수 ''{0}''을(를) 제거하십시오.</entry>
    <entry key="SystemMissingValue">Expected a value following environment variable name. '-echo' flag must be a compile-time constant for standalone code generation. If not, it is treated as the name of an environment variable.</entry>
    <entry key="coderPadResizeFixedSizeM">M은 고정 크기여야 합니다.</entry>
    <entry key="coderPadResizeNeedNonEmptyInput">{0} input must be non-empty.</entry>
    <entry key="coderPadResizeDefaultFillValNotSupportedForStruct">구조체 입력값에는 디폴트 채우기 값을 사용할 수 없습니다. 대신 적절한 채우기 값을 지정하십시오.</entry>
    <entry key="coderPadResizeTrimTabularUnknownNumberOfVariables">코드 생성 시 출력 {0}의 변수 개수는 상수여야 합니다.</entry>
    <entry key="coderPadResizeTimeTableWithUserData">{0}에 대한 코드 생성은 사용자 데이터를 갖는 테이블 형식 입력값을 지원하지 않습니다.</entry>
    <entry key="coderPadResizeNeedConstantString">''{0}''은(는) 상수 문자형 벡터 또는 상수 string형 스칼라여야 합니다.</entry>
    <entry key="dictionaryConstFormat">entries 함수의 형식 옵션은 상수여야 합니다.</entry>
    <entry key="dictionaryTableEmpty">코드 생성 시 entries 함수는 빈 테이블을 반환할 수 없습니다.</entry>
    <entry key="dictionaryEQ">코드 생성에서는 사전 인수가 있는 함수 isequal가 지원되지 않습니다. entries 함수의 출력값을 사용하여 사전을 비교하십시오.</entry>
    <entry key="dictionaryEQN">코드 생성에서는 사전 인수가 있는 함수 isequaln가 지원되지 않습니다. entries 함수의 출력값을 사용하여 사전을 비교하십시오.</entry>
    <entry key="dictionaryStringArrayLookup">Code generation does not support non-scalar arrays of objects, including strings. Return scalar objects only.</entry>
    <entry key="dictionaryEmptyCell">For code generation, cell inputs to the dictionary function cannot be both constant and empty.</entry>
    <entry key="dictionaryCharRow">코드 생성 시 dictionary 함수에 대한 모든 문자형 입력값은 행 벡터여야 합니다.</entry>
    <entry key="dictionaryParfor">코드 생성 시 parfor 루프 내에서 사전을 만들거나 수정하는 것은 지원되지 않습니다.</entry>
    <entry key="dictionaryCharRowIsKey">코드 생성 시 isKey 함수에 대한 모든 문자형 입력값은 행 벡터여야 합니다.</entry>
    <entry key="dictionaryTableEntries">To generate code for the entries function when the key or value is an object, string, or enumeration, specify struct format using the "struct" argument.</entry>
    <entry key="dictionaryCellEntries">Code generation does not support the "cell" argument to the entries function when keys and values are of different types.</entry>
    <entry key="dictionaryEntriesFormat">'format' 인수는 'cell', 'struct' 또는 'table'이어야 합니다.</entry>
    <entry key="dictionaryUnconfiguredEntries">설정되지 않은 키와 값 유형을 갖는 사전에서 항목을 반환할 수 없습니다. 사전에 항목을 추가하십시오.</entry>
    <entry key="dictionaryUnconfiguredKeys">설정되지 않은 키와 값 유형을 갖는 사전에서 키를 반환할 수 없습니다. 사전에 항목을 추가하십시오.</entry>
    <entry key="dictionaryUnconfiguredValues">설정되지 않은 키와 값 유형을 갖는 사전에서 값을 반환할 수 없습니다. 사전에 항목을 추가하십시오.</entry>
    <entry key="dictionaryUnconfiguredTypes">설정되지 않은 키와 값 유형을 갖는 사전에서 유형을 반환할 수 없습니다. 사전에 항목을 추가하십시오.</entry>
    <entry key="dictionaryUnconfiguredRedirect">구성되지 않은 사전을 진입점 함수에 대한 입력값으로 사용하거나 coder.typeof, 외재적 함수 호출, coder.load에 대한 인수로 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="dictionaryCastFailedLookup">코드 생성기가 {0} 유형의 변수를 {1} 유형으로 변환할 수 없으므로 {1} 클래스의 키를 갖는 사전에서 {0} 클래스의 키를 조회할 수 없습니다.</entry>
    <entry key="dictionaryCastFailedRemove">코드 생성기가 {0} 유형의 변수를 {1} 유형으로 변환할 수 없으므로 {1} 클래스의 키를 갖는 사전에서 {0} 클래스의 키를 제거할 수 없습니다.</entry>
    <entry key="dictionaryCastFailedInsert">코드 생성기가 {0} 유형의 변수를 {1} 유형으로 변환할 수 없으므로 {0} 클래스의 키 또는 값을 갖는 항목을 {1} 클래스의 키 또는 값을 갖는 사전에 삽입할 수 없습니다.</entry>
    <entry key="dictionaryStringArrayCastLookup">string형 키를 갖는 사전에서 {0} 클래스의 키를 조회할 수 없습니다. 코드 생성 시, string형 키를 갖는 사전에서 키를 찾으려면 키가 {0} 클래스의 문자형 행 벡터 또는 스칼라여야 합니다.</entry>
    <entry key="dictionaryStringArrayCastRemove">string형 키를 갖는 사전에서 {0} 클래스의 키를 제거할 수 없습니다. 코드 생성 시, string형 키를 갖는 사전에서 제거하려면 키가 {0} 클래스의 문자형 행 벡터 또는 스칼라여야 합니다.</entry>
    <entry key="dictionaryStringArrayCastInsert">{0} 클래스의 키 또는 값을 갖는 항목을 string형 키 또는 값을 갖는 사전에 삽입할 수 없습니다. 코드 생성 시, string형 키 또는 값을 갖는 사전에 삽입된 키 또는 값은 {0} 클래스의 문자형 행 벡터 또는 스칼라여야 합니다.</entry>
    <entry key="dictionaryComplexLookup">코드 생성 시, 실수 숫자형 키를 갖는 사전에서 복소수 키를 찾는 것은 지원되지 않습니다. 허수부가 있는 키를 사용하여 복소수 사전을 생성하십시오.</entry>
    <entry key="dictionaryComplexRemove">코드 생성 시, 실수 숫자형 키를 갖는 사전에서 복소수 키를 제거하는 것은 지원되지 않습니다. 허수부가 있는 키를 사용하여 복소수 사전을 생성하십시오.</entry>
    <entry key="dictionaryComplexInsert">코드 생성 시, 복소수 키 또는 값을 실수 숫자형 사전에 삽입하는 것은 지원되지 않습니다. 허수부가 있는 키 또는 값을 사용하여 복소수 사전을 생성하십시오.</entry>
    <entry key="dictionaryKeysArg">''{0}'' 유형의 키로 구성된 배열을 반환할 수 없습니다. 이러한 키를 셀형 배열로 반환하려면 "cell"을 지정하십시오.</entry>
    <entry key="dictionaryKeysArgCell">인식할 수 없는 인수입니다. 사용된 경우 keys 함수에 대한 두 번째 인수는 상수 string형 "cell"이어야 합니다.</entry>
    <entry key="dictionaryValuesArg">''{0}'' 유형의 값으로 구성된 배열을 반환할 수 없습니다. 이러한 값을 셀형 배열로 반환하려면 "cell"을 지정하십시오.</entry>
    <entry key="dictionaryValuesArgCell">인식할 수 없는 인수입니다. values 함수에 대해 두 번째 인수가 사용되었다면 그 인수는 상수 string형 "cell"이어야 합니다.</entry>
    <entry key="dictionaryBadKeytype">Invalid key type. For code generation, key must be a string, enumeration, logical, cell, structure, or non-fi numeric value. Aggregate types can only contain other valid types.</entry>
    <entry key="dictionaryAggregateNonscalar">코드 생성 시 사전 함수에 대한 모든 {0} 입력값은 스칼라여야 합니다.</entry>
    <entry key="dictionaryFunctionHandle">코드 생성 시 함수 핸들을 사전의 키 또는 값으로 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="dictionaryCategorical">코드 생성 시 categorical형 키 또는 값은 지원되지 않습니다.</entry>
    <entry key="dictionaryHetKeys">코드 생성 시 모든 셀형 배열 키는 동일한 패턴의 데이터형을 포함해야 합니다.</entry>
    <entry key="dictionaryHetValues">코드 생성 시 모든 셀형 배열 값은 동일한 패턴의 데이터형을 포함해야 합니다.</entry>
    <entry key="dictionaryEnum">코드 생성 시 사전 키로 사용되거나 사전 키 안에서 사용되는 모든 열거형의 기본 유형은 int8, uint8, int16, uint16, int32 또는 uint32여야 합니다.</entry>
    <entry key="dictionaryTypeScalar">모든 사전 키와 값은 스칼라여야 합니다.</entry>
    <entry key="dictionaryNoCurly">사전에 대한 중괄호 인덱싱 '{}'은 지원되지 않습니다.</entry>
    <entry key="dictionaryNeedsMalloc">사전을 만들 수 없습니다. 동적 메모리 할당을 활성화하십시오.</entry>
    <entry key="KeyValueDimsMustMatch">키와 값의 크기가 호환되지 않습니다([{0}×{1}] 및 [{2}×{3}]). 키와 값 차원이 호환되거나 값이 스칼라여야 합니다.</entry>
    <entry key="configureDictionaryConst">코드 생성 시 configureDictionary에 대한 모든 입력값은 상수여야 합니다.</entry>
    <entry key="configureDictionaryText">configureDictionary에 대한 모든 입력값은 문자형 행 벡터 또는 string형 스칼라여야 합니다</entry>
    <entry key="configureDictionaryUnsupportedType">코드 생성 시 configureDictionary는 ''{0}'' 유형의 입력값을 지원하지 않습니다. 구성되지 않은 사전에 ''{0}'' 유형의 요소를 삽입하거나 ''{0}'' 유형의 입력값으로 dictionary 함수를 호출하여 이 유형의 사전을 생성하십시오.</entry>
    <entry key="pagelsqminnormInvalidTolerance">허용오차를 모든 페이지에 대해 음이 아닌 스칼라로 지정하거나, 입력 행렬 A의 각 페이지에 대해 다른 허용오차를 지정하는 크기 [1 1 size(A,3:ndims(A)]의 음이 아닌 허용오차로 구성된 배열로 지정하십시오.</entry>
    <entry key="lsNotSupportedUseSystem">코드 생성 시 ''ls''는 지원되지 않습니다. 대신 ''system'' 함수를 사용하여 운영 체제를 호출하고 ''ls'' 명령을 실행하십시오.</entry>
    <entry key="partialParamParsertRuntimeEmpty">옵션 ''{0}''은(는) 비어 있지 않아야 합니다. ''{1}''에 전달된 구조체 입력값의 가변 크기 필드는 런타임에 빈 배열로 축소되면 안 됩니다.</entry>
    <entry key="indexIntRelop_unrecognizedRelop">The first argument of ''coder.internal.indexIntRelop'' must be one of the following: ''eq'', ''neq'', ''lt'', ''le'', ''gt'' or ''ge''.</entry>
    <entry key="indexIntRelop_neitherIsIndexInt">Neither of the operands to coder.internal.indexIntRelop is ''coder.internal.indexInt''. Expected one of them to be an indexInt.</entry>
    <entry key="indexIntRelop_bothAreIndexInt">Both of the operands to coder.internal.indexIntRelop are ''coder.internal.indexInt''. This routine relies on built-in support for indexInt to indexInt comparisons.</entry>
    <entry key="indexIntRelop_nonBinaryFP">Non-binary floating-point types are not supported in coder.internal.indexIntRelop. Found base = {0,number,integer} for class ''{1}''.</entry>
    <entry key="testErrorId">{0}: {1,number,integer}: {2,number,integer}: {3,number,integer}: {4,number,integer}: {5,number,integer}: {6,number,integer}</entry>
    <entry key="TestMsgWithPercent">This is just a test message that contains an fprintf format specifier: %f to verify that we don't format the text passed to it.</entry>
  </message>
</rsccat>
