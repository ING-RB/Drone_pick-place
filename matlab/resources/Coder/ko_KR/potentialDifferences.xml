<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2024 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ko_KR" product="Coder" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="DomainError">생성 코드는 입력값이 실수이면 출력값도 실수라고 가정합니다. 복소수 출력값이 예상된다면, 'complex' 함수를 사용하여 입력값에 허수부 0을 제공하십시오.</entry>
    <entry key="UnsupportedSpecialEmpty">생성 코드는 가변 크기 행렬의 입력값 크기가 0x0이 아니라고 가정합니다.</entry>
    <entry key="diag_varsizedMatrixVector">생성 코드는 행렬 X의 대각을 추출하여 벡터를 반환합니다. 입력값 X가 벡터여야 한다면 X 대신 X(:)을 전달하십시오.</entry>
    <entry key="UnsupportedNaN">생성 코드에서 NaN 값은 입력값에서 제거되지 않습니다.</entry>
    <entry key="eml_all_or_any_specialEmpty">생성 코드는 가변 크기 행렬의 입력값 크기가 0x0이 아니라고 가정합니다.</entry>
    <entry key="eml_min_or_max_varDimZero">생성 코드는 연산을 수행할 차원의 길이가 0이 아니라고 가정합니다.</entry>
    <entry key="NonIncreasing">생성 코드는 그리드 값이 순증가한다고 가정합니다.</entry>
    <entry key="eml_assert_valid_dim_dimTooLarge">생성 코드는 C 유형 'int'를 사용하여 크기를 표현할 수 있다고 가정합니다.</entry>
    <entry key="MustBeFiniteAndStrictlyIncreasing">생성 코드는 입력값 X가 유한하고 순증가한다고 가정합니다.</entry>
    <entry key="mtimes_noDynamicScalarExpansion">생성 코드는 일반 행렬 곱셈을 수행합니다. 가변 크기 행렬 피연산자가 런타임에 스칼라가 되는 경우에도 차원은 일치해야 합니다. 스칼라 곱셈으로 자동 전환은 이루어지지 않습니다.</entry>
    <entry key="autoDimIncompatibility">생성 코드에서는 연산을 수행할 차원이 자동으로 선택되며, MATLAB과 다를 수 있습니다. 작업 차원을 상수 값으로 명시적으로 지정해 보십시오.</entry>
    <entry key="VectorVector">벡터를 벡터로 인덱싱하는 경우, 즉 vector1(vector2)이면 코드 생성기는 결과가 vector1과 방향이 동일할 것으로 가정했습니다. vector1이 런타임에 스칼라이면 vector2의 방향은 vector1과 일치해야 합니다.</entry>
    <entry key="MatrixMatrix">행렬로 행렬을 인덱싱하는 경우, 즉 matrix1(matrix2)이면 코드 생성기는 결과가 matrix2와 크기가 동일할 것으로 가정했습니다. matrix1과 matrix2가 런타임에 벡터이면 이 둘의 방향은 일치해야 합니다.</entry>
    <entry key="OutOfTargetRangeTruncated">생성 코드는 인덱스 값이 유효한 범위 내에 있다고 가정합니다.</entry>
    <entry key="SizesOverflowOnDim">생성 코드는 배열 연산이 각 차원의 상한 내에 있다고 가정합니다.</entry>
    <entry key="OutOfBoundRange">생성 코드는 인덱스가 배열 경계 내에 있다고 가정합니다. 인덱스가 경계를 초과하면 배열이 확장되지 않습니다. 배열을 확장하려면 메모리를 사전 할당하거나 결합을 사용해 보십시오. 예를 들어 [X A]를 사용합니다.</entry>
    <entry key="NontunableHandleProp">생성 코드는 조정 불가형 속성의 값이 런타임에 변경되지 않는다고 가정합니다.</entry>
    <entry key="ForLoopVector">생성 코드는 C 유형 'int'를 사용하여 루프의 반복 횟수를 표현할 수 있다고 가정합니다.</entry>
    <entry key="ValueIsNonInteger">생성 코드는 C 유형 'int'를 사용하여 값을 표현할 수 있다고 가정합니다.</entry>
    <entry key="SizesMismatch">생성 코드는 왼쪽과 오른쪽의 크기가 일치한다고 가정합니다.</entry>
    <entry key="eml_assert_valid_size_arg_invalidSizeVector">생성 코드는 크기 벡터가 행 벡터이고 그 요소는 intmax('int32')보다 작은 유한한 정수이며 타깃 하드웨어에서 C 데이터형 'int'에 맞는다고 가정합니다.</entry>
    <entry key="int_forloop_overflow">생성 코드는 루프의 마지막 반복에서 루프 인덱스가 오버플로되지 않는다고 가정합니다. 루프 인덱스가 오버플로되면 무한 루프가 발생할 수 있습니다.</entry>
  </message>
</rsccat>
