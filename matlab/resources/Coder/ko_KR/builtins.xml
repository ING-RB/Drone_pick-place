<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ko_KR" product="Coder" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="AggregateClass">Non-scalars of class ''{0}'' are not supported.</entry>
    <entry key="Arg2D">입력 인수는 2차원이어야 합니다.</entry>
    <entry key="ImageDataUnderlyingMustHaveThreeDimensions">이미지는 3차원이어야 합니다.</entry>
    <entry key="ArgumentMClassMismatch">알려진 MATLAB 클래스를 입력값으로 가진 함수에 알 수 없는 MATLAB 클래스를 가진 인수를 전달할 수 없습니다.</entry>
    <entry key="ArityInput">함수 ''{0}''에 대한 입력값이 너무 많습니다.</entry>
    <entry key="ArityInputCausedBy">''{0}''을(를) 호출하는 중에 오류가 발생했습니다. 이 함수 호출 위치에서는 함수가 받을 수 있는 것보다 더 많은 입력값이 함수에 전달됩니다. 가능한 원인: {1}</entry>
    <entry key="ArityInputFunctionCallEvent">함수 인수를 함수 호출의 이벤트 트리거에 전달할 수 없습니다.</entry>
    <entry key="IllegalUseOfFunctionCallEvent">이 컨텍스트에서 함수 호출의 출력 이벤트 사용이 부적절합니다.</entry>
    <entry key="ArityInputSF">이 Simulink 함수 또는 Stateflow 함수에 필요한 입력값의 개수가 호출 위치에서 일치하지 않습니다.</entry>
    <entry key="ArityOutput">''{0}''을(를) 호출하는 중에 오류가 발생했습니다. 이 호출 위치에는 이 함수가 제공할 수 있는 것보다 많은 출력이 필요합니다.</entry>
    <entry key="ArrayDeletionOnFixedSizeDimension">차원 {0,number,integer}은(는) 고정 크기 {1,number,integer}을(를) 갖기 때문에 이 배열에서 요소를 삭제할 수 없습니다.</entry>
    <entry key="AssertMustBeTopLevel">assert()는 명령문이어야 합니다. 표현식 안에 중첩되어 있으면 안 됩니다.</entry>
    <entry key="AssertionFailed">어설션 결과: 실패.</entry>
    <entry key="AssignmentFromMatlabTypeAmbiguousSSS">변수 ''{0}''에 충돌하는 유형 정의가 있습니다. 해결하려면 ''{1}''의 이전 정의가 모두 일관적인지 확인하십시오.</entry>
    <entry key="BuiltinInvalidFcn">내장 함수 {0}을(를) 해석할 수 없습니다.</entry>
    <entry key="BuiltinMustBeInFOR">coder.unroll은 단독으로 for 루프 바로 앞 라인에 있거나 for 루프 헤더 안에 있어야 합니다.</entry>
    <entry key="BuiltinDuplicateCall">coder.unroll은 for 루프 헤더 또는 for 루프 헤더 안에서 지원됩니다. 동일한 for 루프에 대해 두 가지를 모두 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="BuiltinMustBeBeforeFOR">coder.unroll을 for 루프 헤더 밖에서 사용하는 경우 for 루프 문 바로 앞에 와야 합니다.</entry>
    <entry key="BuiltinMustBeBeforeTryCatch">coder.ignoreTryCatch는 try-catch 블록 바로 앞에 배치해야 합니다.</entry>
    <entry key="IllegalInvocationInternalBuiltin">사용자 함수 ''{1}''에서 코드 생성 구현 함수 ''{0}''을(를) 호출하는 것은 지원되지 않습니다. 도움이 필요하면 기술 지원팀에 문의하십시오.</entry>
    <entry key="BifAtExitSyntax">내장 함수 ''{0}''에는 void/void 함수에 대한 함수 핸들인 인수 하나가 필요합니다.</entry>
    <entry key="BifAtExitThreadArgument">유효하지 않은 플래그 인수: ''{0}''. 유효한 입력값은 "OnEachThread"와 "OnMainThread"입니다.</entry>
    <entry key="BifAtExitRuntimeArguments">내장 함수 ''{1}''에 등록된 함수 핸들 ''{0}''은(는) 런타임 인수를 가진 것으로 추론됩니다. 등록된 atexit 함수는 컴파일타임 인수만 가져야 합니다.</entry>
    <entry key="BifNeedsLValue">내장 함수 ''{0}''에는 할당 가능한 위치가 필요합니다(예: 변수).</entry>
    <entry key="BifRequiresNTBeforeFimath">내장 연산자에는 fimath 앞에 numerictype이 필요합니다.</entry>
    <entry key="BifUnrecognizedOption">내장 연산자에 대한 유형 ''{0}''을 가진 옵션을 인식할 수 없습니다.</entry>
    <entry key="BifUnsupported">이 내장 함수는 아직 지원되지 않습니다.</entry>
    <entry key="BitConcatArg1">EML_BIT_CONCAT의 첫 번째 인수는 고정소수점 또는 정수여야 합니다.</entry>
    <entry key="BitConcatArg2">EML_BIT_CONCAT의 두 번째 인수는 고정소수점 또는 정수여야 합니다.</entry>
    <entry key="BitSliceNegative">비트 슬라이스의 너비는 양수여야 합니다.</entry>
    <entry key="BitopArg">EML_BIT_OP의 첫 번째 인수는 고정소수점 또는 정수여야 합니다.</entry>
    <entry key="BitwiseOperatorClass">비트별 연산자의 두 입력값 모두 클래스가 동일해야 합니다.</entry>
    <entry key="BreakMisplaced">BREAK 문이 루프 외부에 나타났습니다. 대신 RETURN을 사용하십시오.</entry>
    <entry key="BuiltinSizeQualifier">\n이 내장 함수에 대한 모든 입력값은 크기가 동일해야 합니다. 예상 크기는 첫 번째 입력값의 크기입니다.</entry>
    <entry key="CClassUnrecognized">인식할 수 없는 C 클래스입니다.</entry>
    <entry key="CDeclDuplicateDeclaration">EML_CDECL, 선언되고 있는 변수는 이미 선언이 있습니다.</entry>
    <entry key="CDeclFirstArg">EML_CDECL, 첫 번째 인수는 변수여야 합니다.</entry>
    <entry key="BadCatalogID">'CatalogID'를 사용하려면 'CatalogID', 'My:Catalog:ID', 'ReportedID', 'My:Reported:ID'의 형식을 가진 입력값이 필요합니다</entry>
    <entry key="CannotBeCalledHere">함수 ''{0}''은(는) 여기서 호출할 수 없습니다.</entry>
    <entry key="CellArgsMustBeNonEmpty">''{0}''에 대한 셀형 인수는 비어 있을 수 없습니다.</entry>
    <entry key="CEvalHeaderFileMissing">''{0}'' 인수 뒤에는 헤더 파일 이름이 와야 합니다.</entry>
    <entry key="CEvalHeaderFileMultiple">''{1}''(으)로 호출할 때마다 ''{0}'' 인수를 한 번씩만 사용합니다. 추가 헤더를 포함하려면 ''{2}''을(를) 사용하십시오.</entry>
    <entry key="CEvalUnrecognizedOption">인식할 수 없는 ''coder.ceval'' 옵션 ''{0}''입니다.</entry>
    <entry key="CEvalMissingFunction">호출할 함수 이름이 누락되었습니다. 첫 번째 필수 인수로 함수 이름이 필요합니다.</entry>
    <entry key="CEvalAmbiguousTypeSSS">''{1}''에 대한 이전 할당에 충돌하는 유형이 있으므로 ''coder.ceval''에서 ''{0}''을(를) 할당할 수 없습니다. 고치려면 ''{2}''을(를) 사전 초기화하십시오.</entry>
    <entry key="CEvalNoTypeSSS">''{1}''의 유형과 크기를 알 수 없으므로 ''coder.ceval''에서 ''{0}''을(를) 할당할 수 없습니다. 고치려면 ''{2}''을(를) 사전 초기화하십시오.</entry>
    <entry key="CEvalType">''coder.ceval''의 출력값은 알 수 없는 유형입니다. 바깥쪽 표현식을 계산할 수 없습니다.\n알려진 유형이 있는 변수에 ''coder.ceval'' 출력값을 할당하여 출력 유형을 지정하십시오.</entry>
    <entry key="CEvalWithoutCstructname">지정된 C 구조체 이름이 없습니다. coder.ceval에서 외부 C 함수로 전달되는 구조체의 이름을 지정하기 위해 coder.cstructname을 사용합니다.</entry>
    <entry key="CEvalPropSetterGetter">속성 ''{0}''은(는) setter 메서드, getter 메서드 또는 특성을 가지고 있으므로 코드 생성 시 속성의 주소를 가져오는 것이 지원되지 않습니다.</entry>
    <entry key="CEvalTypeDisplay">''coder.ceval''의 출력값은 알려진 유형이 아니므로 값을 표시할 수 없습니다. 출력을 표시하려면 먼저 알려진 유형의 변수에 결과를 할당하십시오.</entry>
    <entry key="CHelperMisapplied">''{0}''은(는) V 또는 V(E)의 유형을 가진 표현식에만 적용할 수 있으며, 여기서 V는 변수이고 E는 숫자형 표현식입니다.</entry>
    <entry key="CInterfaceMisuse">''{0}''은(는) C 호출 경우에만 사용할 수 있습니다.</entry>
    <entry key="CScalarReturn">C 함수 호출은 항상 스칼라 값을 반환하지만 여기서는 스칼라가 아닌 값이 필요합니다.</entry>
    <entry key="CevalReturnDynamicMatrix">C 함수 호출의 반환 값 ''{0}''은(는) 허용되지 않는 가변 크기 행렬입니다. 이를 C 함수에 대한 인수로 전달해 보십시오.</entry>
    <entry key="CevalExtrinsicParadox">함수 ''{0}''이(가) 외재적 함수로 선언되었지만 C 함수로 호출되고 있습니다.</entry>
    <entry key="CevalGpuMultipleFunctionTypes">coder.ceval에 대해 여러 gpu 함수 유형을 지정할 수 없습니다. ''-gpudevicefcn'' 또는 ''-gpuhostdevicefcn''처럼 허용 가능한 값 중 하나의 옵션만 사용하십시오.</entry>
    <entry key="CStructNameArg1">''{0}''에 대한 첫 번째 인수는 변수 또는 하위 구조체 표현식(예: ''s.sub.two'')이어야 합니다.</entry>
    <entry key="CStructNameEmptyTypeName">Structure name for ''{0}'' must be a nonempty string scalar or character vector.</entry>
    <entry key="CstructNameContainsSpace">''{0}'' 구조체는 외부에서 정의되지 않았기 때문에 구조체 이름에 공백이 들어가는 것이 지원되지 않습니다.</entry>
    <entry key="CStructNameArg1Class">First argument to ''{0}'' must be a structure or cell array.</entry>
    <entry key="CStructNameArg3">The optional third argument to ''{0}'' must be ''extern''.</entry>
    <entry key="CStructNameArgExtern">The optional ''extern'' argument to ''{0}'' is not supported for class ''{1}''.</entry>
    <entry key="CStructNameArg">''{1}''에 대한 선택적 인수 번호 {0,number,integer}은(는) ''HeaderFile'' 또는 ''Alignment''여야 합니다.</entry>
    <entry key="CStructNameHomogeneousCellUnsupported">''{0}''은(는) 동종 셀형 배열을 지원하지 않습니다.</entry>
    <entry key="CStructNameMissingAlignmentValue">입력값이 부족함: ''{0}''의 ''Alignment'' 속성에 정수 값을 지정해야 합니다.</entry>
    <entry key="CStructNameMissingHeaderFileValue">입력 인수가 부족합니다. ''{0}''에 있는 ''HeaderFile'' 속성의 파일 이름을 지정하십시오.</entry>
    <entry key="CStructNameInvalidAlignmentValue">{0,number,integer}은(는) 유효한 정렬 경계가 아닙니다. 유효한 정렬 경계는 128 이하인 2의 거듭제곱이어야 합니다.</entry>
    <entry key="CStructNameHeaderNeedsExtern">''{0}''에 대한 네 번째 선택적 인수를 사용하려면 세 번째 인수가 ''extern''이어야 합니다.</entry>
    <entry key="CStructNameDefined">이름 ''{0}''은(는) 이미 다른 유형을 사용하여 정의되어 있습니다. ''{1}''(으)로 정의되어 있는데, ''{2}''(으)로 재정의하려고 시도했습니다.</entry>
    <entry key="CStructNameGlobal">coder.cstructname은 전역 변수에 직접 적용할 수 없습니다. 대신 전역 변수에 할당된 유형과 함께 사용할 C 유형 이름을 지정하십시오.</entry>
    <entry key="CStructNameEntryPointInput">진입점 함수가 있는 coder.cstructname은 런타임 제어 흐름 전에 적용해야 합니다. coder.cstructname은 MATLAB Function 블록의 최상위 함수 입력값에 대해 지원되지 않습니다.</entry>
    <entry key="CStructNameInput">진입점이 아닌 함수에 대한 입력값이 있는 coder.cstructname은 함수를 호출하기 전에 적용해야 합니다.</entry>
    <entry key="CStructNameLocked">coder.cstructname은 사용 전에 변수에 적용해야 합니다.</entry>
    <entry key="CStructNameRedefinition">충돌하는 coder.cstructname 지시문이 동일한 객체 {0}에 적용되었습니다.</entry>
    <entry key="CStructNameTypeName">이 변수의 유형 이름은 이미 ''{0}''입니다.</entry>
    <entry key="CStructNameInconsistentUseOfExtern">구조체 ''{0}''은(는) 외부에서 정의된 구조체의 필드 유형이므로 외부에서 정의해야 합니다. coder.cstructname을 ''extern'' 옵션과 함께 사용하십시오.</entry>
    <entry key="CStructNameInconsistentUseOfExternForEnum">열거형 ''{0}''은(는) 외부에서 정의된 구조체의 필드 유형이므로 외부에서 정의해야 합니다. ''{1}''에 대한 열거형 classdef에서 정적 메서드 ''getHeaderFile()''을 사용하십시오.</entry>
    <entry key="CStructNameNestedFunction">coder.cstructname은 다른 함수의 변수에 적용할 수 없습니다. 이 coder.cstructname을 변수가 처음 할당되는 함수로 이동하십시오.</entry>
    <entry key="CStructNameVarSizeCellArray">Using coder.cstructname to name the C structure type for a variable-size cell array is not supported.</entry>
    <entry key="CStructNameCellParenIndexingUnsupported">coder.cstructname은 ''()''를 사용하여 셀형 배열을 인덱싱하는 것을 지원하지 않습니다. 요소에 액세스하려면 '''{}''' 인덱싱을 사용하고 셀형 배열 자체에 액세스하려면 인덱싱을 사용하지 마십시오.</entry>
    <entry key="CStructNameCellTypeAlignmentUnsupported">Alignment property not supported for coder.CellType objects.</entry>
    <entry key="CoderVarsizeNestedFunction">coder.varsize는 다른 함수의 변수에 적용할 수 없습니다. 이 coder.varsize를 변수가 처음 할당되는 함수로 이동하십시오.</entry>
    <entry key="CVariableUntyped">정의된 것이 명시적으로 선언된 변수의 데이터형이 지정되지 않았습니다.</entry>
    <entry key="CanNotUseEndInVarargoutAssign">대입식의 왼쪽에 있는 반복되는 출력 변수 ''{0}''을(를) ''end''로 인덱싱하는 것은 코드 생성 시 지원되지 않습니다.\n명시적인 인덱스 표현식을 대신 사용하십시오.</entry>
    <entry key="CaseInsensitiveMatch">''{0}''과(와) 정확하게(대/소문자 구분) 일치하는 항목을 찾을 수 없습니다. 가장 가깝게 일치하는 항목은 ''{1}''입니다.</entry>
    <entry key="CaseSensitiveMatlabResolution">MATLAB 작업 공간에서 함수 ''{0}''이(가) ''{1}''(으)로 해석되었습니다. 코드 생성 시에는 MATLAB 함수를 대/소문자 구분해서 해석하는 것만 가능합니다.</entry>
    <entry key="CastToUnknown">알 수 없는 클래스의 값을 형변환할 수 없습니다.</entry>
    <entry key="CastOpaqueComplex">코드 생성 시 coder.opaque 유형과 복소수형 간 변환이 지원되지 않으므로 유형 ''{0}''을(를) 유형 ''{1}''(으)로 형변환할 수 없습니다. 변환하기 전에 real 또는 imag를 사용하여 복소 변수의 실수부 또는 허수부를 추출하십시오.</entry>
    <entry key="CastOpaqueMultiword">코드 생성 시 크기가 너무 커서 타깃 하드웨어로 표현할 수 없는 유형과 coder.opaque 유형 간 변환이 지원되지 않으므로 유형 ''{0}''을(를) 유형 ''{1}''(으)로 형변환할 수 없습니다. 타깃 하드웨어로 표현할 수 있는 유형만 coder.opaque 유형으로(부터) 변환할 수 있습니다.</entry>
    <entry key="CastOpaqueToUnsupportedType">코드 생성 시 coder.opaque 유형을 유형 ''{0}''(으)로 형변환하는 것은 지원되지 않습니다. 불투명 값을 형변환할 때 타깃 유형은 int8형, uint8형, int16형, uint16형, int32형, uint32형, int64형, uint64형, double형 또는 single형이어야 합니다. 먼저 coder.opaque 값을 이러한 유형 중 하나로 형변환한 후 유형 ''{1}''(으)로 형변환하십시오.</entry>
    <entry key="CatArgsInconsisent">CAT 인수 차원이 일치하지 않습니다. 인수 {0,number,integer}의 크기는 {1}입니다. 인수 {2,number,integer}의 크기는 {3}입니다.</entry>
    <entry key="CatResultDynamicEmpty">CAT 결과는 정해지지 않은 형태의 빈 가변 크기 배열입니다.</entry>
    <entry key="CatRiskyEmpty">크기가 {0}인 빈 행렬은 크기를 알 수 없는 행렬과 결합할 수 없습니다.</entry>
    <entry key="CatRiskyEmptyGrow">빈 배열 {0}을(를) 크기가 {1}인 배열로 확장하는 것은 지원되지 않습니다. 확장되지 않는 차원이 일치하지 않습니다.</entry>
    <entry key="Ccast">C 형변환</entry>
    <entry key="LogicalToChar">논리형에서 문자형으로의 변환은 허용되지 않습니다.</entry>
    <entry key="ClassDoesNotHaveMethodOrProperty">''{0}'' 클래스에 이름이 ''{1}''인 속성이나 메서드가 없습니다.</entry>
    <entry key="ClassDoesNotHaveProperty">Class ''{0}'' does not have a property with name ''{1}''.</entry>
    <entry key="ClassMismatch">''{1}'' 클래스를 갖는 값을 ''{0}'' 클래스를 갖는 변수에 할당할 수 없습니다.</entry>
    <entry key="ClassMismatchAssign">{0} 유형의 값을 {1} 유형의 변수에 쓸 수 없습니다. 코드 생성 시 할당을 통한 유형 변경은 지원되지 않습니다. 유형 불일치 문제가 발생한 원인을 조사하려면 이전 할당 또는 입력 유형 지정을 확인하십시오.</entry>
    <entry key="EntryPointIOClassMismatchAssign">진입점 함수 ''{1}''의 입력값 ''{0}''은(는) {2}이지만 {3}이(가) 할당되었습니다. 코드 생성 시 동일한 변수를 입력값과 출력값으로 사용하는 경우 함수 본문 전체에서 해당 변수의 유형과 크기가 일관되어야 합니다.</entry>
    <entry key="EntryPointIOSizeMismatchAssign">진입점 함수 ''{1}''의 입력값 ''{0}''은(는) 크기가 {2}이지만 크기 {3}이(가) 할당되었습니다. 코드 생성 시 동일한 변수를 입력값과 출력값으로 사용하는 경우 함수 본문 전체에서 해당 변수의 유형과 크기가 일관되어야 합니다.</entry>
    <entry key="NonWebrenamedBuiltinClassMismatchAssign">변수 ''{0}''은(는) {1}이지만 {2}이(가) 할당되었습니다. 코드 생성 시 변수가 {3}(으)로 전달되는 경우 함수 본문 전체에서 해당 변수의 유형과 크기가 일관되어야 합니다.</entry>
    <entry key="NonWebrenamedBuiltinSizeMismatchAssign">변수 ''{0}''은(는) 크기가 {1}이지만 크기 {2}이(가) 할당되었습니다. 코드 생성 시 변수가 {3}(으)로 전달되는 경우 함수 본문 전체에서 해당 변수의 유형과 크기가 일관되어야 합니다.</entry>
    <entry key="NonWebrenamedVectorVarsizeMismatchAssign">변수 {0}은(는) coder.varsize에 의해 크기 {1}(으)로 제한되었지만, 크기가 {2}인 값이 할당되었습니다. 한원소 차원의 크기를 조정하려면 상한을 명시적으로 지정하십시오.</entry>
    <entry key="NonWebrenamedVarsizeMismatchAssign">변수 {0}은(는) coder.varsize에 의해 크기 {1}(으)로 제한되었지만, 크기가 {2}인 값이 할당되었습니다.</entry>
    <entry key="ClassMismatchAssignOnField">이 할당은 필드 ''{2}''에서 ''{1}'' 유형으로 ''{0}'' 값을 씁니다. 코드 생성 시 할당을 통한 유형 변경은 지원되지 않습니다. 이전 할당 또는 입력 유형 지정에서 유형 불일치가 있는지 확인하십시오.</entry>
    <entry key="ClassMismatchAssignOnCell">이 할당은 요소 ''{2}''에서 ''{1}'' 유형으로 ''{0}'' 값을 씁니다. 코드 생성 시 할당을 통한 유형 변경은 지원되지 않습니다. 이전 할당 또는 입력 유형 지정에서 유형 불일치가 있는지 확인하십시오.</entry>
    <entry key="ClassMismatchOnField">필드 ''{2}''에서, ''{1}'' 클래스를 갖는 값을 ''{0}'' 클래스를 갖는 변수에 할당할 수 없습니다.</entry>
    <entry key="ClassdefInvalidEnumeration">''{0}''에 대한 정의를 불러올 수 없음: {1}</entry>
    <entry key="ClassdefNotAnEnumeration">''{0}'' is not a supported enumeration. For code generation, enumerations must inherit from one of: ''int8'', ''uint8'', ''int16'', ''uint16'', ''int32'', ''uint32'' or ''Simulink.IntEnumType''.</entry>
    <entry key="TunableEnumerationNotImported">조정 가능 열거형 ''{0}''은(는) 가져온 조정 가능 열거형이 아닙니다. 코드를 생성하려면 조정 가능한 열거형은 가져와야 합니다.</entry>
    <entry key="EnumerationDataScopeInvalid">''{0}.getDataScope''에서 반환된 데이터 범위가 유효하지 않습니다: ''{1}''. 데이터 범위는 "Auto", "Imported" 또는 "Exported"여야 합니다.</entry>
    <entry key="UnsupportedExportedEnumerationHeaderPath">''{0}.getHeaderFile''에서 반환된 헤더 파일이 유효하지 않습니다: ''{1}''. 내보낸 열거형에 대해서 ''getHeaderFile''은 경로 없이 헤더 파일의 이름을 반환해야 합니다.</entry>
    <entry key="ExportedEnumerationHeaderInvalid">''{0}.getHeaderFile''에서 반환된 헤더 파일이 유효하지 않습니다: {1}. 헤더 파일의 확장자는 ''.h''여야 합니다.</entry>
    <entry key="ImportedEnumerationNoHeader">헤더 파일이 지정되지 않았으므로 열거형 ''{0}''을(를) 가져올 수 없습니다. ''{0}.getHeaderFile''을 사용하여 헤더 파일을 지정하십시오.</entry>
    <entry key="EnumClassdefNotfound">Enumeration class definition is missing. Enumeration class ''{0}'' must have a definition for code generation.</entry>
    <entry key="ClassdefBadEnumDefaultValue">The default value returned by ''{0}.getDefaultValue'' must be one of the enumerated values defined in the class definition for ''{1}''. Found a ''{2}'' with {3,number,integer} element(s) instead.</entry>
    <entry key="ClassdefEnumBadHeader">The value returned by ''{0}.getHeaderFile'' must be a file name.</entry>
    <entry key="ClassdefEnumBadPrefixFlag">The value returned by ''{0}.addClassNameToEnumNames'' must be scalar logical.</entry>
    <entry key="ClassdefEnumLoad">코드 생성 시 열거형 ''{0}''을(를) 불러오는 중 오류 발생: {1}</entry>
    <entry key="ClassdefEnumStaticMethod">Error invoking the enumeration static method ''{0}.{1}'': {2}</entry>
    <entry key="EnumElementValueDoesNotFitInTargetInt">값이 ''{1,number,integer}''인 열거형 요소 ''{0}''이(가) 프로덕션 및/또는 테스트 하드웨어 정수에 맞지 않습니다. 이 유형은 C 열거형으로 구현되므로 각 요소는 현재 테스트와 프로덕션 "int" 유형(범위 {2,number,integer}-{3,number,integer})에 맞아야 합니다</entry>
    <entry key="ColonLogical">함수 ''colon''은 ''logical'' 클래스의 값에 대해 정의되지 않았습니다.</entry>
    <entry key="ColonMixed">콜론 피연산자는 모두 유형이 동일하거나 double형의 실수형 스칼라와 혼용되어야 합니다.</entry>
    <entry key="ColonNaN">NaN을 사용한 콜론 표현식은 지원되지 않습니다.</entry>
    <entry key="ColonObjEnum">코드 생성 시 콜론 표현식에서 열거형은 지원되지 않습니다. 사용 전에 열거형 ''{0}''을(를) 정수형으로 형변환하십시오.</entry>
    <entry key="ColonStride">이 콜론 표현식의 스트라이드는 상수가 아닌 것으로 보입니다. 코드 생성 시 상수 스트라이드만 지원됩니다.</entry>
    <entry key="ColonInput">함수에 대한 입력 인수는 콜론 연산자를 포함합니다. 콜론 문자를 입력하려면 '':''을 대신 사용하십시오.</entry>
    <entry key="CommandDuality">명령-쌍대성(Command-duality)은 지원되지 않습니다.</entry>
    <entry key="ComplexIntegerArithmetic">코드 생성 시 복소수형 정수 연산은 지원되지 않습니다.</entry>
    <entry key="ComplexIntegerRelational">복소수형 정수에 대한 비교 연산은 지원되지 않습니다.</entry>
    <entry key="ComplexSlopeBiasFiUnsupported">복소수 FI 객체는 기울기가 2의 정수 거듭제곱이어야 하고 편향이 0이어야 합니다.</entry>
    <entry key="ComplexToCharOrLogical">복소수 값을 논리형 값이나 문자형 값으로 변환할 수 없습니다.</entry>
    <entry key="ComplexToLogical">복소수 값을 논리형 값으로 변환할 수 없습니다.</entry>
    <entry key="NonNumericToComplex">{0}에서 복소수로의 변환은 지원되지 않습니다.</entry>
    <entry key="ConditionMustBeScalarLogical">조건 입력 인수는 유효한 논리형 스칼라여야 합니다.</entry>
    <entry key="ConditionMustBeScalar">조건 입력 인수는 스칼라여야 합니다.</entry>
    <entry key="ConditionMustBeConvertibleToLogical">조건 입력 인수는 논리형으로 변환 가능해야 합니다.</entry>
    <entry key="AssertAlwaysFalse">어설션이 항상 실패합니다. 런타임까지 감지를 지연시키려면 조건에 coder.ignoreConst를 사용하십시오.</entry>
    <entry key="AssertMithMsgIDAlwaysFalseRuntimeParams">내부 오류: 어설션은 컴파일할 때 실패하지만 런타임 파라미터를 가집니다. 오류를 제대로 생성하려면 조건이 컴파일타임 false인 경우 모든 메시지 파라미터가 컴파일타임 상수인지 확인하십시오.\n오류 ID: ''{0}''\n파라미터 없는 오류 텍스트: {1}</entry>
    <entry key="ConflictingDirectives">함수 ''{0}''에 충돌하는 ''{1}'' 지시문과 ''{2}'' 지시문이 포함되어 있습니다.</entry>
    <entry key="Conjugate">이 클래스에서 켤레 복소수는 정의되지 않았습니다.</entry>
    <entry key="ConstantFoldingOverFlow">상수 폴딩 동안 오버플로 또는 포화가 발생했습니다. 이 표현식의 값을 해당 유형으로 정확하게 표현할 수 없습니다.</entry>
    <entry key="ConstantNotEliminated">이 ''{0}'' 상수는 제거할 수 없습니다.</entry>
    <entry key="CoderLoadUnassignedNotSupported">코드 생성 시 ''{0}''을(를) 사용하여 할당되지 않은 요소를 불러오는 것은 지원되지 않습니다. ''{1}''은(는) 할당되지 않았습니다.</entry>
    <entry key="CoderLoadConstructedOnLoadNotSupported">코드 생성 시 ''{0}''을(를) 사용하여 ConstructOnLoad 특성을 갖는 클래스를 불러오는 것은 지원되지 않습니다. ''{1}''은(는) ConstructOnLoad로 표시된 클래스입니다.</entry>
    <entry key="CoderLoadSparseMatrixNotSupported">코드 생성 시 희소 행렬을 불러오는 것은 지원되지 않습니다. ''{0}''은(는) 희소 행렬입니다.</entry>
    <entry key="ConflictingMethodAttributesWarning">메서드 ''{0}''은(는) 동시에 {1}과(와) {2}입니다.</entry>
    <entry key="ConflictingMethodAttributesWarningSecondAttrIgnored">메서드 ''{0}''은(는) 동시에 {1}과(와) {2}입니다. {2}은(는) 무시됩니다.</entry>
    <entry key="ConstantNotFunction">이 상수는 호출할 수 없습니다. 함수가 아닙니다.</entry>
    <entry key="ConstantNotLValue">상수 ''{0}''이(가) 대입식의 좌변에서 발견되었습니다. 이러한 컨텍스트에서는 변수만 허용됩니다.</entry>
    <entry key="ConstantRequired">상수가 아닌 표현식이거나 빈 행렬입니다. 이 표현식의 값은 어떤 표현식의 크기 또는 클래스를 결정하므로 상수여야 합니다.</entry>
    <entry key="ConstantCellValuelistIndexRequired">상수가 아닌 표현식입니다. 이 표현식의 값은 어떤 표현식의 크기 또는 클래스를 결정하므로 상수여야 합니다.</entry>
    <entry key="ContainsDynamicMatrixType">동적 행렬 유형을 찾았습니다.</entry>
    <entry key="ContinueMisplaced">CONTINUE는 FOR 또는 WHILE 루프 내에서만 사용할 수 있습니다.</entry>
    <entry key="ConversionNotPossible">{1}에서 {0}(으)로 변환될 수 없습니다.</entry>
    <entry key="CouldNotReduceToConstant">\n표현식을 상수로 축약하지 못했습니다.</entry>
    <entry key="CreateThroughIndexing">필드 액세스를 통해 변수 ''{0}''을(를) 처음 정의하는 경우, 좌변 구성요소는 인덱싱 괄호를 포함할 수 없으며, 최종 필드를 제외한 모든 좌변 구성요소는 스칼라여야 합니다. 구조체로 구성된 배열을 만들려면 ''repmat'' 함수 또는 ''struct'' 함수를 사용하십시오.</entry>
    <entry key="CreateArrayLikeStringNoFillValue">createArray를 사용하여 스칼라 string형 배열을 생성할 때는 'FillValue' 인수가 필요합니다.</entry>
    <entry key="CreateArrayAbstractClassname">createArray에 대한 코드를 생성할 때는 classname 인수가 구체 클래스여야 합니다.</entry>
    <entry key="CreateArrayInvalidClassname">createArray에 대한 코드를 생성할 경우 classname 인수는 ''{0}'' 유형을 지원하지 않습니다.</entry>
    <entry key="CreateArrayInvalidDefaultCtorLikeArg">'Like' 인수가 객체인 경우 createArray에 대한 코드를 생성하려면 객체 클래스가 createArrayLike 메서드를 구현해야 합니다. 또는 객체 클래스가 스칼라 값을 반환하는 디폴트 생성자를 가져야 합니다.</entry>
    <entry key="CreateArrayInvalidDefaultCtorClassnameArg">classname 인수가 객체 클래스인 경우 createArray에 대한 코드를 생성하려면 이 클래스가 createArray 메서드를 구현해야 합니다. 또는 객체 클래스가 스칼라 값을 반환하는 디폴트 생성자를 가져야 합니다.</entry>
    <entry key="CreateArrayLikeStruct">createArray에 대한 코드를 생성할 경우 'Like' 인수는 구조체형 값을 지원하지 않습니다. 대신 'FillValue' 인수를 사용하거나, classname 인수를 사용하여 배열 요소의 클래스를 지정하십시오.</entry>
    <entry key="CreateArrayLikeUnsupportedType">createArray에 대한 코드를 생성할 경우 'Like' 인수는 유형 ''{0}''의 값을 지원하지 않습니다.</entry>
    <entry key="CreateArrayLikeUnsupportedSuperclassLikeArg">createArray에 대한 코드를 생성할 경우 'Like' 인수는 ''{0}''에서 상속되는 클래스의 인스턴스를 지원하지 않습니다.</entry>
    <entry key="CreateArrayLikeUnsupportedSuperclassClassnameArg">createArray에 대한 코드를 생성할 경우 classname 인수는 ''{0}''에서 상속되는 클래스를 지원하지 않습니다.</entry>
    <entry key="CreateArrayLikeUnsupportedMethodLikeArg">createArray에 대한 코드를 생성할 경우 'Like' 인수는 메서드 ''{0}''을(를) 구현하는 클래스의 인스턴스를 지원하지 않습니다.</entry>
    <entry key="CreateArrayLikeUnsupportedMethodClassnameArg">createArray에 대한 코드를 생성할 경우 classname 인수는 메서드 ''{0}''을(를) 구현하는 클래스를 지원하지 않습니다.</entry>
    <entry key="CSizeOfInvalidType">유형으로 유효한 인수는 ''char'', ''short'', ''int'', ''long'', ''long long''이지만 전달된 인수는 ''{0}''입니다.</entry>
    <entry key="DefBeforeUsePropertyUndefined">Property ''{0}'' is undefined on some execution paths. For code generation, all variables must be fully defined before use.</entry>
    <entry key="DefBeforeUseFieldUndefined">Structure field ''{0}'' is undefined on some execution paths. For code generation, all variables must be fully defined before use.</entry>
    <entry key="DefBeforeUsePropertyUndefinedSub">속성 ''{1}''이(가) 일부 실행 경로에서 정의되지 않았기 때문에 속성 ''{0}''에 대해 첨자를 사용한 대입을 수행할 수 없습니다. 코드를 생성하려면 모든 변수를 사용 전에 완전히 정의해야 합니다.</entry>
    <entry key="DefBeforeUseFieldUndefinedSub">Unable to perform subscripted assignment of structure field ''{0}'' because field ''{1}'' is undefined on some execution paths. For code generation, all variables must be fully defined before use.</entry>
    <entry key="DefBeforeUsePropUndefinedFcnCall">Property ''{0}'' is undefined on some execution paths but is used inside the called function. For code generation, all variables must be fully defined before use.</entry>
    <entry key="DefBeforeUseInitalValueTypeMismatch">속성 ''{0}''의 경우 초기값 ''{1}''의 유형이 할당된 값 ''{2}''의 유형과 일치하지 않습니다.</entry>
    <entry key="DefBeforeUseInitalValueContainsUnassigned">속성 ''{0}''은(는) 할당되지 않은 셀형 배열 요소를 포함하는 초기값을 가집니다. 코드를 생성하려면 모든 셀형 배열 요소를 사용 전에 완전히 정의해야 합니다.</entry>
    <entry key="DefBeforeUseInitalValueValueMismatch">조정 불가형 속성 ''{0}''의 값이 모든 경로에서 동일하지 않습니다. 코드를 생성하려면 모든 실행 경로에서 조정 불가형 속성에 동일한 상수 값을 할당해야 합니다.</entry>
    <entry key="DefBeforeUseDeleterPreconditionNotMetByConstructor">코드를 생성하려면 핸들 클래스 소멸자 함수 ''{1}''에 사용된 속성 ''{0}''이(가) 생성자 함수 ''{2}''의 모든 실행 경로에서 초기화되어야 합니다.</entry>
    <entry key="DefBeforeUseFieldUsedFromFcnOutput">함수 ''{1}''에서 반환된 속성 ''{0}''이(가) 일부 실행 경로에서 정의되지 않았습니다. 코드를 생성하려면 모든 변수를 사용 전에 완전히 정의해야 합니다.</entry>
    <entry key="DesignRangeInvalidTargetVariable">coder.designRange에 대한 첫 번째 인수는 현재 함수의 인수여야 합니다.</entry>
    <entry key="DesignRangeMustAppearBelowSignature">coder.designRange 요소는 함수 시그니처 바로 뒤에 배치해야 합니다.</entry>
    <entry key="DesignRangeMustApplyToNumericData">coder.designRange supports only variables containing numeric data.</entry>
    <entry key="DesignRangeRedefinition">또 다른 설계 범위 제약 조건이 이미 이 변수에 적용됩니다.</entry>
    <entry key="DesignRangeBoundsMustBeConstants">설계 범위 최솟값과 최댓값은 컴파일타임 상수여야 합니다.</entry>
    <entry key="DesignRangeBoundsMustBeScalarDouble">Design range minimum and maximum must be scalar doubles.</entry>
    <entry key="DesignRangeBoundsCannotBeNaN">Design range minimum and maximum must not be NaN.</entry>
    <entry key="DesignRangeUpperBoundBelowLowerBound">Design range maximum must be greater than or equal to the design range minimum.</entry>
    <entry key="PersistentVariableSometimesUndefined">영속 변수 ''{0}''이(가) 일부 실행 경로에서 정의되지 않았습니다. 코드를 생성하려면 모든 변수를 사용 전에 완전히 정의해야 합니다.</entry>
    <entry key="FunctionOutputNotAlwaysAssigned">출력 인수 ''{0}''이(가) 일부 실행 경로에서 정의되지 않았습니다. 코드를 생성하려면 모든 변수를 사용 전에 완전히 정의해야 합니다.</entry>
    <entry key="SEAOneDefinition">코드를 생성하려면 System object를 생성하고 저장할 때 ''if isempty'' 코드 블록을 사용해야 합니다.</entry>
    <entry key="SEAPersistentAssign">코드를 생성하려면 System object를 영속 변수에 할당해야 합니다.</entry>
    <entry key="SubVariableSometimesUndefined">변수 {0}이(가) 일부 실행 경로에서 정의되지 않았기 때문에 변수 {0}에 대해 첨자를 사용한 대입을 수행할 수 없습니다. 코드를 생성하려면 모든 변수를 사용 전에 완전히 정의해야 합니다.</entry>
    <entry key="VariableSometimesUndefined">변수 ''{0}''이(가) 일부 실행 경로에서 완전히 정의되지 않았습니다. 코드를 생성하려면 모든 변수를 사용 전에 완전히 정의해야 합니다.</entry>
    <entry key="VariableUndefined">변수 ''{0}''이(가) 정의되지 않았습니다. 코드를 생성하려면 모든 변수를 사용 전에 완전히 정의해야 합니다.</entry>
    <entry key="DynamicCellArrayNotProvedFullyDefined">셀형 배열 ''{0}''의 모든 요소가 이 라인 앞에서 할당되었는지 확인할 수 없습니다. 코드를 생성하려면 모든 셀형 배열 요소를 사용 전에 정의해야 합니다.</entry>
    <entry key="DynamicCellArrayNotProvedFullyDefinedExitingEntryPoint">함수를 종료하기 전에 셀형 배열 ''{0}''의 모든 요소가 할당되었는지 확인할 수 없습니다. 코드를 생성하려면 모든 셀형 배열 요소를 사용 전에 정의해야 합니다.</entry>
    <entry key="DynamicCellArrayNotProvedFullyDefinedInRecursiveFunction">셀형 배열 ''{0}''의 모든 요소가 재귀적으로 호출되는 함수에서 할당되었는지 확인할 수 없습니다. 코드를 생성하려면 모든 셀형 배열 요소를 사용 전에 정의해야 합니다.</entry>
    <entry key="IllegalEntryPointMatlabString">진입점 함수 ''{0}''의 변수 ''{1}''이(가) 코드 생성 시 지원되지 않는 연산을 사용하는 문자열을 포함합니다.</entry>
    <entry key="IllegalGlobalMatlabString">전역 변수 ''{0}''이(가) 코드 생성 시 지원되지 않는 연산을 사용하는 문자열이거나 이 문자열을 포함합니다.</entry>
    <entry key="IllegalSimulinkBusWithMatlabString">Simulink 버스 유형 변수 ''{0}''이(가) 코드 생성 시 지원되지 않는 연산에 사용되는 문자열을 포함합니다.</entry>
    <entry key="PersistentSimulinkStringsNotSupported">MATLAB Function 블록에서 Simulink 문자열을 포함하는 영속 변수는 지원되지 않습니다.</entry>
    <entry key="VariableSizingSimulinkStringNotSupported">MATLAB Function 블록에서 가변 크기 데이터에 대한 지원이 비활성화된 경우 Simulink 문자열은 지원되지 않습니다.</entry>
    <entry key="IsmethodDoesNotSupportChar">코드 생성 시 첫 번째 입력값이 객체인 경우에만 ismethod에 대한 호출이 지원됩니다. 여기서 첫 번째 입력값은 ''{0}''입니다.</entry>
    <entry key="IsmethodDoesNotSupportHalf">코드 생성 시 첫 번째 입력값의 유형이 ''{0}''인 경우 ismethod에 대한 호출이 지원되지 않습니다.</entry>
    <entry key="IncompatibleEmptyAssignment">이후의 할당과 일치시키기 위해 크기 0×0의 표현식을 {0} {1}(으)로 처리합니다.</entry>
    <entry key="IncompatibleEmptyCellArray">'{}'을 cell({0})로 처리하여 이후의 할당과 일치시킵니다.</entry>
    <entry key="DMTUnknownUpperBound">계산된 최대 크기는 제한이 없습니다.</entry>
    <entry key="DMTUnknownUpperBoundCall">함수 ''{0}''의 출력값의 계산된 최대 크기는 제한이 없습니다.</entry>
    <entry key="DMTUnknownUpperBoundMultiCall">함수 ''{1}''의 출력값 #{0, number, integer}의 계산된 최대 크기는 제한이 없습니다.</entry>
    <entry key="DMTUnknownUpperBoundVar">변수 ''{0}''의 계산된 최대 크기는 제한이 없습니다.</entry>
    <entry key="DMTUnknownUpperBoundExplanation">\n정적 메모리 할당에서는 모든 크기에 제한이 있습니다..</entry>
    <entry key="DMTUnknownUpperBoundForStrings">계산된 최대 크기는 제한이 없습니다.</entry>
    <entry key="DMTUnknownUpperBoundHDLExplanation">\nHDL 코드를 생성하려면 모든 차원의 크기가 고정되어야 합니다.</entry>
    <entry key="DMTExceedMaxSize">계산된 최대 크기가, 허용되는 최대 요소 개수({0, number, integer})를 초과합니다.</entry>
    <entry key="DMTExceedMaxSize2">계산된 배열 크기 {0}이(가), 허용되는 최대 요소 개수 {1}을(를) 초과합니다.</entry>
    <entry key="DMTExceedMaxSizeCall">함수 ''{0}''의 출력값의 계산된 최대 크기가, 허용되는 최대 요소 개수({1, number, integer})를 초과합니다.</entry>
    <entry key="DMTExceedMaxSizeMultiCall">함수 ''{1}''의 출력값 #{0, number, integer}의 계산된 최대 크기가, 허용되는 최대 요소 개수({2, number, integer})를 초과합니다.</entry>
    <entry key="DMTStructFdErr">\n구조체 필드 ''{0}''의 계산된 크기는 {1}입니다.</entry>
    <entry key="DMTClassPropErr">\n클래스 속성 ''{0}''의 계산된 크기는 {1}입니다.</entry>
    <entry key="DMTCellElemErr">\n셀 요소 ''{0}''의 계산된 크기는 {1}입니다.</entry>
    <entry key="DMTExceedMaxSizeVar">변수 ''{0}''의 계산된 최대 크기가, 허용되는 최대 요소 개수({1, number, integer})를 초과합니다.</entry>
    <entry key="DMTErrWoPath">\n계산된 크기는 {0}입니다.</entry>
    <entry key="ArrayDimensionExceedMaxSize">배열 차원 수 {1, number, integer}의 크기 {0}이(가), 지원되는 최댓값({2, number, integer})을 초과합니다.</entry>
    <entry key="DMTErrorUnknownSrc">\n이 오류는 기본 분석의 한계로 인해 보고될 수 있습니다.</entry>
    <entry key="DSPLicense">여기에는 DSP System Toolbox 라이선스가 필요합니다.</entry>
    <entry key="DimSubMismatchFewer">대입식의 비한원소 우변 차원 수가 비한원소 첨자 수보다 적습니다.</entry>
    <entry key="DimSubMismatchMore">대입식의 비한원소 우변 차원 수가 비한원소 첨자 수보다 많습니다.</entry>
    <entry key="DimensionIsStaticCanNotMakeDynamic">\n차원 {0,number,integer}을(를) 동적으로 만들 수 없습니다. 이전에 고정 크기 {1,number,integer}을(를) 갖도록 설정된 상태입니다.</entry>
    <entry key="DuplicateFunctionAttributesTag">coder.preserveFunction 또는 coder.MethodAttributes는 함수 또는 메서드마다 한 번만 지정할 수 있습니다.</entry>
    <entry key="DuplicateStructFieldName">''{0}''은(는) 중복된 필드 이름입니다</entry>
    <entry key="DynamicMemoryAllocationOptionOff">\n제한 없는 크기를 허용하도록 동적 메모리 할당을 활성화해 보십시오.</entry>
    <entry key="EMLAssert">EML_ASSERT는 ''error'' 및 ''warning'' 메시지 유형만 인식합니다.</entry>
    <entry key="EMLInvariantIllegalInputs">eml_invariant에 대한 호출은 다음 형식 중 하나를 사용해야 함: \n eml_invariant(cond, eml_message(...)) \n eml_invariant(cond, eml_message(...), "IfNotConst", "CheckAtRunTime") \n eml_invariant(cond, eml_message(...), "IfNotConst", "Fail").</entry>
    <entry key="EMLInvariantStringMsgId">두 번째 입력값은 메시지 ID여야 합니다.</entry>
    <entry key="EMLMessageIllegalInput">eml_message를 사용하는 중 오류가 발생했습니다. 메시지의 빈 자리는 문자형 벡터 또는 정수여야 합니다.</entry>
    <entry key="EmbeddedComponentsConcatenationUndefined">결합 연산이 System object에 대해 정의되지 않았습니다.</entry>
    <entry key="EmbeddedComponentsNotSupported">이 System object는 코드 생성을 지원하지 않습니다.</entry>
    <entry key="EmbeddedComponentsmxArrayInput">입력값은 mxArray여야 합니다.</entry>
    <entry key="EmlCInterfaceNotAvailable">FIACCEL은 {0}을(를) 지원하지 않습니다. C 함수를 호출하려면 CODEGEN(MATLAB Coder 라이선스 필요)을 사용하십시오.</entry>
    <entry key="EmlCInterfaceNotAvailableDV">{0}은(는) Simulink Design Verifier에서 지원되지 않습니다.</entry>
    <entry key="EmlCInterfaceAnyLayoutNotAvailableDV"> 'coder.ceval'의 '-layout:any' 플래그는 Simulink Design Verifier에서 지원되지 않습니다.</entry>
    <entry key="EmlUpdateBuildInfoNotSupported">{0}은(는) Simulink Design Verifier에서 지원되지 않습니다. '구성 파라미터' 창의 '시뮬레이션 타깃' 탭에서 사용자 지정 코드 정보를 업데이트하고 '사용자 지정 코드 분석 활성화' 옵션을 대신 선택합니다.</entry>
    <entry key="CannotComputeConstantValue">표현식을 상수로 축약할 수 없습니다.</entry>
    <entry key="CannotComputeConstantValue_WithReason">표현식을 상수로 축약할 수 없음: {0}</entry>
    <entry key="CannotComputeConstantValue_SeeNextError">표현식을 상수로 축약할 수 없습니다. 자세한 내용은 다음 오류를 참조하십시오.</entry>
    <entry key="CannotComputeConstantValue_NextError">이전 오류의 원인: {0}</entry>
    <entry key="CoderConstWrongMultipleOutputs">함수 fcn이 여러 출력값을 반환하는 경우 구문 [a,b,...] = coder.const(@fcn,x,y,...)를 사용합니다.</entry>
    <entry key="EmlNamespaceFunctionName">{0}은(는) 인식할 수 없는 키워드입니다.</entry>
    <entry key="EmlPlaceVarsizeBeforeUse">\n{0}을(를) 처음 사용하기 전에 coder.varsize() 선언을 배치합니다.</entry>
    <entry key="EmlPlaceVarsizeAfterDef">{0}에 대한 첫 번째 할당 후 {1} 선언을 배치합니다.</entry>
    <entry key="EmlUpperboundsNotDynamicMatrix">eml_upperbounds()은(는) 가변 크기 배열에만 적용할 수 있습니다.</entry>
    <entry key="EmlUpperboundsWrongDimensions">이 배열의 차원은 {0,number,integer}개이지만 크기 벡터의 요소는 {1,number,integer}개입니다.</entry>
    <entry key="EmlUpperboundsNonReal">크기 벡터는 실수 숫자형 값을 가져야 합니다.</entry>
    <entry key="EmlUpperboundsSizeNotConst">크기 벡터는 상수여야 합니다.</entry>
    <entry key="EmlVarsizeDimensionCanNotBeFixed">\n{1}의 차원 {0,number,integer}이(가) 가변 크기를 가지므로 크기를 고정할 수 없습니다.</entry>
    <entry key="EmlVarsizeHasNoEffectOnGlobals">coder.varsize()는 전역 변수에 영향을 주지 않습니다.\n 명령줄 -globals 스위치에서 coder.Type을 사용하여 가변 크기 전역을 정의하십시오.</entry>
    <entry key="EmlVarsizeInfFixedDimSize">고정 크기 차원 {0,number,integer}의 상한은 Inf입니다. 이는 지원되지 않습니다.</entry>
    <entry key="EmlVarsizeLargeFixedDimSize">차원 {1,number,integer}의 고정 크기 {0,number,integer}이(가) intmax()보다 크거나 같습니다. 이는 지원되지 않습니다.</entry>
    <entry key="EmlVarsizeLargeStaticMatrix">numel이 intmax()보다 크거나 같은 고정 크기 행렬입니다. 이는 지원되지 않습니다.</entry>
    <entry key="EmlVarsizeOnlyColonIndexAllowed">coder.varsize()의 입력값에는 콜론 인덱싱만 허용됩니다: coder.varsize(''variable.field1(:).field2'')는 허용되지만 coder.varsize(''var.field1(1).field2'')는 허용되지 않습니다.</entry>
    <entry key="EmlVarsizeRedefinition">충돌하는 coder.varsize() 지시문이 동일한 객체 {0}에 적용되었습니다.</entry>
    <entry key="EmlVarsizeSuggestedUpperBoundDiffersFromPresetOne">차원 {0,number,integer}의 미리 정의된 상한을 변경할 수 없습니다. 미리 정의된 상한은 {1,number,integer}이고, 요청된 상한은 {2,number,integer}입니다.</entry>
    <entry key="EmlVarsizeSyntaxErrorInPath">coder.varsize()에 대한 입력값에 구문 오류가 있습니다.</entry>
    <entry key="EmlVarsizeThirdInputMustBeLogicalVector">coder.varsize()의 마지막 입력값은 논리값으로 구성된 벡터여야 합니다.</entry>
    <entry key="EmlVarsizeThirdInputSizeMismatch">변수의 차원 개수(첫 번째 입력값)와 마지막 입력값의 크기가 일치해야 합니다.</entry>
    <entry key="EmlVarsizeTooFewDimensionsGiven">객체 ''{0}''의 차원이 coder.varsize()에 제공된 차원보다 많음: {1,number,integer} &gt; {2,number,integer}.</entry>
    <entry key="EmlVarsizeUseInfWithoutMalloc">상한 크기를 Inf로 선언하려면 동적 메모리 할당을 사용해야 합니다. 제한 없는 크기를 허용하려면 동적 메모리 할당을 활성화하십시오.</entry>
    <entry key="EmlVarsizeVariableIsLocked">변수 ''{1}''이(가) 이미 잠겨 있으므로 {0}의 크기를 수정할 수 없습니다.</entry>
    <entry key="EmlVarsizeZeroUpperBoundUnsupported">차원 {0,number,integer}에 대해 상한 0이 지정되었습니다.</entry>
    <entry key="EmlVarsizeUnsupportedClass">coder.varsize()는 ''{0}''에 적용할 수 없습니다.</entry>
    <entry key="EmlVarsizeHeterogeneousCellUnsupported">coder.varsize()는 이종 셀형 배열을 지원하지 않습니다.</entry>
    <entry key="EmlVarsizeCellParenIndexingUnsupported">coder.varsize()는 ''()''를 사용하여 셀형 배열로 인덱싱하는 것을 지원하지 않습니다. 요소에 액세스하려면 '''{}''' 인덱싱을 사용하고 셀형 배열 자체에 액세스하려면 인덱싱을 사용하지 마십시오.</entry>
    <entry key="EmptyIndexStructArray">인덱싱을 사용하면 구조체로 구성된 빈 배열이 나옵니다. 구조체로 구성된 빈 배열은 지원되지 않습니다.</entry>
    <entry key="EmptyPersistent">영속 변수에 빈 배열을 할당하는 것은 지원되지 않습니다.</entry>
    <entry key="EmptyStructArray">구조체로 구성된 빈 배열은 지원되지 않습니다.</entry>
    <entry key="EnumCannotConvert">열거된 목록에 모든 요소가 포함되어 있지 않기 때문에 입력 배열을 ''{0}'' 열거형 클래스로 변환할 수 없습니다.</entry>
    <entry key="EnumEmptyConstructorCall">''{0}''은(는) 열거형이며 빈 함수 호출로 사용할 수 없습니다.</entry>
    <entry key="EnumInvalidConst">열거형 값 ''{0}''이(가) ''{1}''에 정의되지 않았습니다.</entry>
    <entry key="EnumInvalidUse">요소 참조 없이 열거형 ''{0}''을(를) 사용하려고 시도했습니다.</entry>
    <entry key="EnumsNotAllowed">열거형은 여기에 허용되지 않습니다. 이 표현식은 열거형인 클래스 ''{0}''입니다.</entry>
    <entry key="EnumsNotAllowedForLibraryFcn">Function ''{0}'' does not allow enumeration types. The argument is of class ''{1}'' which is an enumeration.</entry>
    <entry key="HalfNotAllowedForLibraryFcn">함수 ''{0}''은(는) half 유형을 허용하지 않습니다.</entry>
    <entry key="HalfComplexSupport">코드 생성 시 half 복소수 유형은 지원되지 않습니다.</entry>
    <entry key="NativeHalfTypeCPPSupport">네이티브 Half 유형은 C 타깃에 대해서만 지원됩니다. C++ 타깃은 Emulated Half Library를 사용하여 지원됩니다.</entry>
    <entry key="HalfArithmeticOperationUnsupported">half 유형의 경우 코드 생성 시 산술 연산은 숫자형에 대해서만 지원됩니다. 피연산자 중 하나의 유형이 ''{0}''입니다.</entry>
    <entry key="HalfRelationalOperationUnsupported">half 유형의 경우 코드 생성 시 관계 연산은 숫자형 또는 논리형에 대해서만 지원됩니다. 피연산자 중 하나의 유형이 ''{0}''입니다.</entry>
    <entry key="EntryPointMustBeExported">''{0}''은(는) 진입점 함수이며 내보내야 합니다.</entry>
    <entry key="EnumCompareString">Code generation does not support comparing an enumeration to a character array, string, or cell array with the operators '==', '~=', or 'isequal'.</entry>
    <entry key="EnumOverloadedRelop">열거형 ''{0}''이(가) 코드 생성 시 지원되지 않는 연산자 ''{1}''을(를) 오버로드하고 있습니다.</entry>
    <entry key="ErrorLimitReached">오류 한도에 도달했습니다. 추가 오류 메시지가 차단되는 중입니다.</entry>
    <entry key="ExpectedAnEnum">열거형이 필요합니다.</entry>
    <entry key="ExpectedCharString">Expected a character vector.</entry>
    <entry key="ExpectedCellstr">문자형 벡터로 구성된 셀형 배열이 필요합니다.</entry>
    <entry key="ExpectedFIMATH">FIMATH 객체가 필요하지만 찾지 못했습니다.</entry>
    <entry key="ExpectedFunctionHandle">함수 핸들이 필요합니다. {0}을(를) 찾았습니다.</entry>
    <entry key="ExpectedFunctionHandleOrDirectCall">함수 핸들 또는 괄호를 사용한 직접 호출이 필요합니다.</entry>
    <entry key="AmbiguousCallInMatlabExecution">인수가 없는 하나의 함수 핸들인 이 호출 구문은 MATLAB 실행에서 모호한 구문입니다. 괄호를 사용하여 함수 인수를 직접 호출하십시오.</entry>
    <entry key="Unexpected">예기치 않은 {0}입니다.</entry>
    <entry key="ExpectedNonEnumerationClass">열거형이 아닌 클래스가 필요합니다. {0}을(를) 찾았습니다.</entry>
    <entry key="ExpectedInteger">정수가 필요합니다. 클래스 {0}을(를) 찾았습니다.</entry>
    <entry key="ExpectedIntegerValue">''int32''형으로 표현 가능한 정수 값이 필요합니다.</entry>
    <entry key="ExpectedIntegerValueInRangeOf">범위 {0,number,integer}-{1,number,integer}의 정수 값이 필요합니다.</entry>
    <entry key="ExpectedNonnegativeIntegerValue">음이 아닌 정수 값이 필요합니다.</entry>
    <entry key="ExpectedNonComplex">Found a complex value. A real value was expected. Use the functions REAL or IMAG to make this value real if appropriate.</entry>
    <entry key="ExpectedNumeric">숫자형 값이 필요합니다. {0}을(를) 찾았습니다.</entry>
    <entry key="ExpectedNumericType">숫자형이어야 합니다.</entry>
    <entry key="ExpectedNumericVector">숫자형 벡터여야 합니다.</entry>
    <entry key="ExpectedScalarBoolean">스칼라 부울 값이 필요합니다.</entry>
    <entry key="ExpectedScalarNumeric">스칼라 숫자형 값이 필요합니다.</entry>
    <entry key="ExpectedScalarStruct">스칼라 구조체가 필요합니다.</entry>
    <entry key="ExpectedScalarNumericAsDouble">Expected a scalar numeric value representable as double.</entry>
    <entry key="OutOfIndexingRange">유형 ''{1}''인 인덱싱에 대한 값 ''{0}''이(가) 범위를 벗어났습니다.</entry>
    <entry key="ExpectedScalarString">Expected a vector not a matrix of characters.</entry>
    <entry key="ExpectedScalarVerbose">스칼라 값이 필요합니다. 이 표현식의 크기는 {0}입니다.</entry>
    <entry key="ExpectedTargetIntegerValue">타깃 ''int'' 유형으로 표현 가능한 정수 값이 필요합니다.</entry>
    <entry key="ExpectedUnsignedInteger">부호 없는 정수가 필요합니다. 클래스 {0}을(를) 찾았습니다.</entry>
    <entry key="ExpectedVector">벡터 표현식이 필요합니다.</entry>
    <entry key="ExpectedVectorOfPositiveIntegers">양의 정수로 구성된 벡터가 필요합니다.</entry>
    <entry key="ExpressionTooLarge">표현식이 너무 큽니다. 부분 결과를 임시 변수에 저장하여 표현식을 더 작은 부분으로 분할합니다.</entry>
    <entry key="ExpressionUnsupported">This kind of expression is not supported.</entry>
    <entry key="ExtrinsicArg">coder.extrinsic에 대한 인수는 함수 이름이어야 합니다.</entry>
    <entry key="ExtrinsicCallInsideParallelRegion">병렬 FOR 루프 내에서 외재적 함수에 대한 호출은 지원되지 않습니다.</entry>
    <entry key="ExtrinsicMisplaced">사용 후에 함수 ''{0}''이(가) coder.extrinsic으로 표시되었습니다.</entry>
    <entry key="ExtrinsicTopLevel">coder.extrinsic에 대한 호출은 최상위 수준에만 나타날 수 있습니다.</entry>
    <entry key="FailSharedRestricted">호출자 ''{0}''은(는) 제한된 리소스 ''{1}''을(를) 공유할 권한이 없습니다.</entry>
    <entry key="FailSharedRestrictedCallerPath">공유된 제한된 리소스 ''{0}''의 호출자 경로: ''{1}''.</entry>
    <entry key="FailSharedRestrictedCalleePath">공유된 제한된 리소스 ''{0}''의 경로: ''{1}''.</entry>
    <entry key="FailSharedRestrictedNoDispatcher">제한된 리소스 ''{0}''을(를) 공유할 수 없음: MATLAB 디스패처가 없습니다.</entry>
    <entry key="FailSharedRestrictedNotOnMATLABPath">제한된 리소스 ''{0}''을(를) 공유할 수 없음: ''{1}''이(가) MATLAB 경로에 없습니다.</entry>
    <entry key="FailSharedRestrictedNotValidDirectory">제한된 리소스 ''{0}''을(를) 공유할 수 없음: 경로 ''{1}''에 유효한 디렉터리가 포함되어 있지 않습니다.</entry>
    <entry key="FailSharedRestrictedNotDirCaller">제한된 리소스 ''{0}''을(를) 공유할 수 없음: 경로 ''{1}''에 라이선스가 있는 디렉터리가 포함되어 있지 않습니다.</entry>
    <entry key="FcnNeedsRuntime">''{0}''은(는) EMLRT를 사용해야 하며 MEX 타깃과 S-Function 타깃에만 사용할 수 있습니다.</entry>
    <entry key="FieldNameConstantQualifier">\n필드 이름은 상수여야 합니다.</entry>
    <entry key="FieldValuePair">필드와 값 입력 인수는 쌍으로 있어야 합니다.</entry>
    <entry key="FileMgrCmdNotConst">제공된 연산이 유효하지 않습니다. ''open'', ''close'', ''filestar'', ''autoflush'', ''list'', ''closeall' 중 하나여야 합니다.</entry>
    <entry key="FileMgrCmdNotFound">제공된 연산 ''{0}''이(가) 유효하지 않습니다. open, close, filestar, autoflush, list, closeall 중 하나여야 합니다.</entry>
    <entry key="FileMgrNargin">제공된 연산 ''{0}''에는 ''{1}''개의 인수가 필요합니다.</entry>
    <entry key="FimathIsLocalArg1">EML_FIMATHISLOCAL에 대한 첫 번째 인수는 고정소수점이어야 합니다.</entry>
    <entry key="FimathMismatch">fimath 객체의 속성이 일치해야 합니다.</entry>
    <entry key="FimathMismatchOnField">필드 ''{0}''에서 fimath 객체의 속성이 일치해야 합니다.</entry>
    <entry key="FimathMismatchOnCell">셀 ''{0}''에서 fimath 객체의 속성이 일치해야 합니다.</entry>
    <entry key="FixedPointLicense">여기에는 Fixed-Point Designer 라이선스가 필요합니다.</entry>
    <entry key="FixedPointSize">고정소수점 데이터형은 {0,number,integer}비트를 초과할 수 없는데, {1,number,integer}비트가 제공됐습니다.</entry>
    <entry key="FixedPointSubsAsgnLhsFIRhsEnum">subsasgn 연산에서 연산자 ''=''의 우변에 있는 피연산자는 열거형일 수 없습니다.</entry>
    <entry key="EndPlus1SubsAsgnLhsNdVectorNotSupported">2차원 이상의 벡터에 ''end + 1''로 첨자를 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="EndPlus1RequiresVariableSizing">''end + 1''로 셀형 배열 또는 배열에 첨자를 사용하려면 코드 생성 시 가변 크기 배열 지원을 활성화하십시오. 코드 구성 속성 EnableVariableSizing을 true로 설정하거나 MATLAB Coder 앱에서 "가변 크기 조정 활성화" 파라미터를 활성화하십시오.</entry>
    <entry key="EndPlus1ConflictsWithCoderVarsize">coder.varsize 지시문이 {0}의 모든 차원이 고정 크기임을 나타내므로 (end + 1)을 사용하여 배열 {0}을(를) 확장할 수 없습니다. coder.varsize 지시문을 수정하여 적어도 하나의 {0} 차원을 가변 크기로 설정하십시오.</entry>
    <entry key="EndPlus1SubsAsgnLhsMultiIndexingNotSupported">''end+1''로 셀형 배열 또는 배열에 다차원 인덱싱하는 것은 지원되지 않습니다.</entry>
    <entry key="EndPlus1SubsAsgnLhsMultiOutputNotSupported">여러 출력값을 반환하는 함수에서 할당할 때 ''end+1''로 첨자를 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="EndPlus1SubsAsgnLhsModularIndexingNotSupported">코드 생성 시 ''end + 1''로 ''{0}''에 첨자를 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="EndPlus1SubsAsgnLhsNonVectorNotSupported">비벡터 셀형 배열 또는 배열에 ''end + 1''로 첨자를 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="EndPlus1SubsAsgnLhsFieldOrClosureNotSupported">구조체 필드, 객체 속성 또는 상위 함수의 작업 공간에 속하는 중첩 함수의 변수에 ''end + 1''로 첨자를 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="EndPlus1SubsAsgnLhsNonVariableNotSupported">''end + 1''로 첨자를 사용하는 것은 변수에 대해서만 지원됩니다.</entry>
    <entry key="EndPlus1GrowColumnAsRow">변수 ''{0}''은(는) 크기가 {1}인 열 벡터로 지정되어 있지만, 이렇게 ''end + 1''로 첨자를 사용하면 크기가 {2}인 행 벡터가 생성됩니다. ''{0}''에 열로 추가하려면 ''{0} = [{0}; newValue];''를 사용하십시오.</entry>
    <entry key="EnumerationDataScopeIncorrecValue">''{0}.getDataScope''에서 반환된 데이터 범위가 유효하지 않습니다. 데이터 범위는 "Auto", "Imported" 또는 "Exported"여야 합니다.</entry>
    <entry key="FixedPointType">지원되지 않는 고정소수점 데이터형입니다.</entry>
    <entry key="FixedVariableSizeMismatch">\n일치하지 않는 가변 크기와 고정 크기는 런타임 오류의 가능성을 나타냅니다. 이 진단이 잘못된 경우 인덱싱을 사용하여 가변 크기를 명시적으로 고정하십시오.</entry>
    <entry key="ForLoopIndexMCOS">MATLAB 클래스에 대한 FOR 루프 반복은 지원되지 않습니다.</entry>
    <entry key="ForLoopCellOneRow">코드 생성 시 셀형 배열에 대해 FOR 루프 반복을 사용하려면 셀형 배열의 첫 번째 차원 크기가 정확히 1이어야 합니다.</entry>
    <entry key="ForLoopCellUnassignedElement">코드 생성 시 셀형 배열에 대해 FOR 루프 반복을 사용하는 경우, 모든 요소가 할당된 셀형 배열을 사용하는 것만 지원됩니다.</entry>
    <entry key="ForLoopCellHeterogeneousRequireUnroll">이종 셀형 배열에 대해 FOR 루프 반복을 사용하는 경우 ''coder.unroll''을 사용하여 루프를 푸십시오.</entry>
    <entry key="ForLoopIndexFi">embedded.fi 객체에 대한 FOR 루프 반복은 지원되지 않습니다. 독립 인덱스 변수를 사용하여 embedded.fi 객체의 데이터에 액세스하도록 루프를 다시 작성하십시오.</entry>
    <entry key="ForLoopIndexFunctionHandle">함수 핸들에 대한 FOR 루프 반복은 지원되지 않습니다.</entry>
    <entry key="ForLoopIndexIncompatible">인덱스 변수 {0}은(는) 대응하는 FOR 루프 외부에서 사용됩니다. 루프가 실행되지 않으면 런타임 동작이 MATLAB과 달라집니다.</entry>
    <entry key="ForLoopIndexGlobalIncompatible">인덱스 변수 {0}은(는) 전역 변수이므로 대응하는 FOR 루프 외부에서 사용될 수 있습니다. 루프가 실행되지 않으면 런타임 동작이 MATLAB과 달라집니다.</entry>
    <entry key="ForLoopIndexMxArray">mxArray 인덱스를 가진 FOR 루프는 지원되지 않습니다.</entry>
    <entry key="ForLoopIndexOutputIncompatibility">출력값 {0}이(가) FOR 루프 인덱스 변수로 사용됩니다. 루프가 실행되지 않으면 런타임 동작이 MATLAB과 달라집니다.</entry>
    <entry key="ForLoopIndexRowsUnknown">FOR 루프 인덱스 표현식에 알 수 없는 행 개수가 있습니다.</entry>
    <entry key="ForLoopIndexUnknown">FOR 루프 인덱스 표현식에 알 수 없는 클래스가 있습니다.</entry>
    <entry key="ForLoopUnknownSpecial">크기를 알 수 없는 FOR 루프 인덱스 표현식은 표현식 형식이 A:B 또는 A:B:C인 경우에만 지원됩니다.</entry>
    <entry key="FunctionCallFailed">함수 호출에 실패했습니다.</entry>
    <entry key="FunctionCallFailedFAV">함수 호출 실패: 위치 {0,number,integer}의 인수가 유효하지 않습니다.</entry>
    <entry key="FunctionCallFailedFAVDefault">함수 호출 실패: 위치 {0,number,integer}의 디폴트 값이 유효하지 않습니다.</entry>
    <entry key="FunctionCallFailedName">함수 ''{0}'' 호출에 실패했습니다.</entry>
    <entry key="FunctionCallWarned">호출된 함수에서 경고가 발생했습니다.</entry>
    <entry key="FunctionHandleCanNotBeUsedHere">여기서는 함수 핸들을 사용할 수 없습니다.</entry>
    <entry key="FunctionHandleTypeMismatch">유형 불일치: MATLAB Coder에서 함수 핸들 {0}과(와) {1}의 동등성을 확인할 수 없습니다.</entry>
    <entry key="FunctionHandleUnsupportedForCcalls">함수 핸들은 C 호출에서 지원되지 않습니다.</entry>
    <entry key="FunctionHandleUnsupportedForCcallsWithin">함수 핸들을 포함하는 {0}은(는) C 호출에서 지원되지 않습니다.</entry>
    <entry key="FunctionHandleUnsupportedForCeval">함수 핸들은 ''coder.ceval''에서 지원되지 않습니다</entry>
    <entry key="FunctionHandleUnsupportedForCevalWithin">함수 핸들을 포함하는 {0}은(는) ''coder.ceval''에서 지원되지 않습니다.</entry>
    <entry key="FunctionHandleUnsupportedForMATLABCalls">함수 핸들은 외재적 함수에 전달할 수 없습니다.</entry>
    <entry key="FunctionHandleUnsupportedForMATLABCallsWithin">함수 핸들을 포함하는 {0}은(는) 외재적 함수에 전달할 수 없습니다.</entry>
    <entry key="FunctionHandleUnsupportedForMxArrayValues">함수 핸들과 mxArray 값은 서로 상호 변환될 수 없습니다.</entry>
    <entry key="FunctionHandleUnsupportedForMxArrayValuesWithin">함수 핸들을 포함하는 {0}과(와) mxArray 값은 서로 상호 변환될 수 없습니다.</entry>
    <entry key="FunctionHandleUnsupportedForOutput">함수 출력값 ''{0}''은(는) 함수 핸들일 수 없습니다.</entry>
    <entry key="FunctionHandleUnsupportedForOutputWithin">함수 출력값 ''{0}''은(는) 함수 핸들을 포함하는 {1}일 수 없습니다.</entry>
    <entry key="FunctionHandleUnsupportedForSave">함수 핸들은 ''save''로 전달할 수 없습니다.</entry>
    <entry key="FunctionHandleUnsupportedForSaveWithin">함수 핸들을 포함하는 {0}은(는) ''save''로 전달할 수 없습니다.</entry>
    <entry key="FunctionHandleUnsupportedForStateflowCalls">함수 핸들은 Stateflow 호출에서 지원되지 않습니다.</entry>
    <entry key="FunctionHandleUnsupportedForStateflowCallsWithin">함수 핸들을 포함하는 {0}은(는) Stateflow 호출에서 지원되지 않습니다.</entry>
    <entry key="FunctionPointerNotSupportedHere">여기서는 함수 포인터가 지원되지 않습니다.</entry>
    <entry key="FunctionPointerNotSupported">코드 생성 시 함수 포인터는 지원되지 않습니다.</entry>
    <entry key="FunctionHasNoVararg">이 함수에는 ''{0}''이(가) 없습니다.</entry>
    <entry key="FunctionInputArity">함수 ''{0}''은(는) {1,number,integer}개의 입력값이 필요하지만, {2,number,integer}개가 발견되었습니다.</entry>
    <entry key="FunctionNotLValue">함수 ''{0}''이(가) 대입식의 좌변에서 발견되었습니다. 이러한 컨텍스트에서는 변수만 허용됩니다.</entry>
    <entry key="FunctionNotSupportedForCodeGeneration">코드 생성에는 함수 ''{0}''이(가) 지원되지 않습니다.</entry>
    <entry key="FunctionOutputMxArray">코드 생성 시, 이 컨텍스트에서 이 함수의 mxArray 출력값은 지원되지 않습니다. 출력 변수 {0}을(를) 알려진 유형으로 초기화하십시오.</entry>
    <entry key="FunctionOutputSEA">함수 출력값 ''{0}''은(는) System object일 수 없습니다.</entry>
    <entry key="FunctionSizeQualifier">\n왼쪽에 있는 크기는 함수 입력값의 지정된 크기입니다.</entry>
    <entry key="FunctionStructClassQualifier">\n왼쪽에 있는 구조체는 함수 입력값의 지정된 클래스입니다.</entry>
    <entry key="GetFieldIndex">인덱스 ''{0,number,integer}''은(는) 유효한 필드 인덱스가 아닙니다.</entry>
    <entry key="GetfieldArg1">첫 번째 인수는 구조체 유형이어야 합니다.</entry>
    <entry key="GlobalMisplaced">사용하기 전에 ''{0}''을(를) 전역 변수로 선언하십시오.</entry>
    <entry key="GlobalTopLevel">GLOBAL 선언은 최상위 수준에만 나타날 수 있습니다.</entry>
    <entry key="GlobalUnexpectedValue">Found unsupported global data initialization class for global variable ''{0}''.</entry>
    <entry key="GlobalUninitialized">전역 변수 ''{0}''의 초기값을 찾을 수 없습니다.</entry>
    <entry key="GlobalUnsupported">지원되지 않음: GLOBAL 변수.</entry>
    <entry key="GlobalMCOSUnsupported">코드 생성 시 MATLAB 클래스의 인스턴스를 보유하는 전역 변수는 지원되지 않습니다.</entry>
    <entry key="GlobalHandleSEAUnsupported">코드 생성 시 핸들 클래스 또는 System object를 포함하는 전역 변수는 지원되지 않습니다.</entry>
    <entry key="MultiInheritanceSameNamedPropertyAbstractUnsupported">각 슈퍼클래스가 이름이 동일한 속성을 가지고 있고 그 속성이 슈퍼클래스 중 하나에서 추상인 경우, 코드 생성 시 슈퍼클래스의 다중 상속이 지원되지 않습니다. 속성 ''{0}''은(는) 슈퍼클래스 ''{1}''에서 추상이고 슈퍼클래스 ''{2}''에서는 추상이 아닙니다.</entry>
    <entry key="GlobalSparseUnsupported">코드 생성 시 희소 행렬이거나 희소 행렬을 포함하는 전역 변수는 지원되지 않습니다.</entry>
    <entry key="GlobalOpaqueUnsupported">코드 생성 시 coder.opaque 유형의 전역 변수는 지원되지 않습니다.</entry>
    <entry key="GlobalIncompatibleValue">전역 변수 ''{0}''의 초기값이 해당 유형과 일치하지 않습니다.</entry>
    <entry key="LoadFailed">파일 ''{0}''을(를) 불러오지 못했습니다.</entry>
    <entry key="LoadFailedWithCause">파일 ''{0}''을(를) 불러오지 못함: {1}</entry>
    <entry key="HalfPrecisionLicense">반정밀도 데이터형을 사용하려면 Fixed-Point Designer 라이선스나 MATLAB Coder 라이선스가 필요합니다.</entry>
    <entry key="HalfTypeNotSupportedForTarget">현재 코드 생성 타깃은 'half' 유형을 지원하지 않습니다.</entry>
    <entry key="BuiltInFcnConstArg">''{0}'' 함수에 대한 모든 인수는 컴파일타임 상수여야 합니다.</entry>
    <entry key="UpdateBuildInfoFailed">BuildInfo에 ''{0}'' 메서드를 적용하지 못했습니다.</entry>
    <entry key="UpdateBuildInfoFailedWithCause">BuildInfo에 ''{0}'' 메서드를 적용하지 못함: {1}</entry>
    <entry key="LoadFileNotFound">불러오기 함수에서 지정된 파일 ''{0}''을(를) 찾지 못했습니다.</entry>
    <entry key="LoadNeedsMATLAB">독립 실행형 코드 생성 시 함수 {0}은(는) 지원되지 않습니다. 외재적 호출이 활성화된 MEX 또는 S-Function을 생성하도록 타깃을 변경하거나 {1}을(를) 사용하여 컴파일타임에 MAT 파일을 불러오십시오.</entry>
    <entry key="LoadFileNameNotConstant">''load''에 대한 파일 이름 인수는 상수 string형이거나 문자형 벡터여야 합니다.</entry>
    <entry key="LoadSimpleAssignment">함수 ''{0}''은(는) 구조체 또는 배열 변수에 대한, 첨자를 사용하지 않은 단순한 대입문의 우변에만 사용할 수 있습니다.</entry>
    <entry key="LoadSingleOutput">''{0}'' 호출의 출력값이 변수에 할당되지 않았습니다. 첨자를 사용하지 않고 변수에 이 출력값을 할당하십시오.</entry>
    <entry key="LoadUnexpectedValue">함수 ''{0}''을(를) 사용하는 변수에 지원되지 않는 클래스를 찾았습니다.</entry>
    <entry key="LoadUnexpectedValueHint">MAT 파일의 변수를 보기 위해 명령 ''whos -file {0}''을(를) 사용하십시오.</entry>
    <entry key="CoderHardwareSettingsUndefined">현재 컨텍스트에서는 코더 하드웨어 설정에 대한 정보를 사용할 수 없습니다.</entry>
    <entry key="CoderHardwareSettingUndefined">The coder hardware setting ''{0}'' is not available in the current context.</entry>
    <entry key="CoderHardwareFailedWithCause">코더 하드웨어 설정 ''{0}''을(를) 가져오지 못함: {1}</entry>
    <entry key="CoderHardwareFailed">코더 하드웨어 설정 ''{0}''을(를) 가져오지 못했습니다.</entry>
    <entry key="IBifUnsupported">이 내장 함수는 아직 지원되지 않습니다.</entry>
    <entry key="IDPCountMismatch">Incorrect number of input arguments for ''{0}''. Expected {1,number,integer}, but found {2,number,integer}.</entry>
    <entry key="IDPCountMismatchCausedBy">진입점 ''{0}''에 너무 많은 입력 인수가 지정되었습니다. 가능한 원인: {1}</entry>
    <entry key="ODPCountMismatch">''{0}''에 대한 출력 인수의 개수가 잘못되었습니다. {1,number,integer}개여야 하는데 {2,number,integer}개가 발견되었습니다.</entry>
    <entry key="IfWhileNonScalar">코드 생성 시 비 스칼라에 대한 논리 연산은 지원되지 않습니다. 함수 ''any'' 또는 ''all''을 사용하여 논리형 행렬을 이에 상응하는 스칼라 행렬로 축소하십시오.</entry>
    <entry key="IllegalBaseTypeConversion">이 두 기본 유형 간에 형변환할 수 없습니다.</entry>
    <entry key="IllegalExtrinsic">{0} 지시문을 ''{1}''에 적용할 수 없습니다. 이 함수에서 {2}에 대한 호출을 제거하십시오.</entry>
    <entry key="IllegalLogicalType">논리형, 문자형, int, single형, double형, 또는 0을 표현할 수 있는 fi 중 하나가 필요합니다. {0}을(를) 찾았습니다.</entry>
    <entry key="IllegalMatlabType">논리형, 문자형, int, fi, single형, double형 중 하나가 필요합니다. mxArray를 찾았습니다. MxArray는 MATLAB 인터프리터 호출 시 반환되며 표현식 내부에서는 지원되지 않습니다. MxArray는 대입식의 우변에 사용하거나 외재적 함수에 대한 인수로만 사용할 수 있습니다.</entry>
    <entry key="IllegalMultiOutput">함수 ''{0}''은(는) 여러 출력값을 반환할 수 없습니다.</entry>
    <entry key="IllegalMultiOutputUnknown">이 함수는 여러 출력값을 반환할 수 없습니다.</entry>
    <entry key="IllegalSizeVector">크기 벡터는 정수 요소를 가진 행 벡터여야 합니다.</entry>
    <entry key="IllegalType">논리형, 문자형, int, fi, single형, double형 중 하나가 필요합니다. {0}을(를) 찾았습니다.</entry>
    <entry key="IllegalTypeConversion">이 두 유형 간에 형변환할 수 없습니다.</entry>
    <entry key="IllegalUseOfEnd">예약된 키워드 ''end''의 사용이 부적절합니다.</entry>
    <entry key="IllegalUseOfStrcmp">STRCMP는 문자형 값에만 적용할 수 있습니다.</entry>
    <entry key="ImplicitMatlabResolution">코드 생성에는 함수 {0}이(가) 지원되지 않습니다. 이 함수의 코드 생성을 건너뛰려면 coder.extrinsic(''{1}'')을 사용하십시오.</entry>
    <entry key="ImplicitMatlabMethodResolution">코드 생성 시 클래스 {1}의 메서드 {0}이(가) 지원되지 않습니다. 이 함수의 코드 생성을 건너뛰려면 coder.extrinsic(''{2}'')을 사용하십시오.</entry>
    <entry key="ImplicitMatlabEnumMethodResolution">코드 생성 시 열거형 {1}의 메서드 {0}이(가) 지원되지 않습니다. 이 함수의 코드 생성을 건너뛰려면 coder.extrinsic(''{2}'')을 사용하십시오.</entry>
    <entry key="ImplicitMatlabResolutionUnsupported">코드 생성 시 함수 ''{0}''이(가) 지원되지 않으며 {1} 지시문은 ''{2}''에 적용할 수 없습니다.</entry>
    <entry key="ImportNotAllowedHere">import 문은 함수 정의 뒤의 선행 문으로만 허용됩니다.</entry>
    <entry key="ImportNamespaceMustBeEmlpkg">emlpkg.*만 import 문의 네임스페이스로 지원됩니다.</entry>
    <entry key="ImportNamespaceNotConstant">\nImport 네임스페이스는 상수 표현식이어야 합니다.</entry>
    <entry key="ImportUnsupported">import 문은 현재 지원되지 않습니다.</entry>
    <entry key="ImproperOperarorUse">연산자가 잘못 사용되었습니다.</entry>
    <entry key="IncorrectInputArgumentCounts">입력 인수의 개수가 올바르지 않습니다. {0}은(는) 정확히 {1,number,integer}개의 입력값을 받습니다({2,number,integer}개 발견됨).</entry>
    <entry key="IndexComplex">첨자 인덱스는 복소수일 수 없습니다.</entry>
    <entry key="IndexLogical">논리형 인덱싱을 하기 위해서는 가변 크기 배열의 지원이 필요한데 현재 비활성화되어 있습니다.</entry>
    <entry key="IndexLogicalVarsizeBlocked">논리형 인덱싱을 사용하려면 가변 크기 배열을 활성화하십시오.</entry>
    <entry key="IndexMatrixDynamic">첨자를 사용한 행렬의 크기는 정적으로 알 수 없습니다.</entry>
    <entry key="IndexMxArray">mxArray 인덱스는 지원되지 않습니다. 인덱스 표현식을 알려진 유형의 변수에 할당한 후 이 변수를 사용하여 배열의 요소를 참조하십시오.</entry>
    <entry key="IndexNonNumeric">첨자 인덱스는 내장 숫자형 클래스여야 합니다. 이 인덱스의 클래스는 ''{0}''입니다.</entry>
    <entry key="IndexOutOfBounds">{0,number,integer}번째 배열 요소가 범위를 벗어났습니다. 범위 {1,number,integer}-{2,number,integer}의 요소에 액세스하도록 인덱스 표현식을 수정하십시오.</entry>
    <entry key="IndexOutOfBoundsLhs">코드 생성 시 이 방식으로 인덱싱을 사용하여 배열을 확장할 수 없으므로 {0,number,integer}번째 배열 요소가 범위를 벗어났습니다. 범위 {1,number,integer}~{2,number,integer} 내에 있는 요소에 액세스하도록 인덱스 표현식을 수정하거나, 배열을 가변 크기로 명시적으로 정의하십시오.</entry>
    <entry key="VariableCreatedByIndexing">변수 ''{0}''이(가) 할당되지 않았습니다. 변수를 할당하려면 첨자가 아닌 전체 대입식을 사용하십시오. 코드 생성 시 인덱싱을 통한 배열 생성은 지원되지 않습니다.</entry>
    <entry key="VariableCreatedByIndexingConst">변수 ''{0}''이(가) 할당되지 않았습니다. 변수를 할당하려면 첨자가 아닌 전체 대입식을 사용하십시오. 코드 생성 시 인덱싱을 통한 배열 생성은 지원되지 않습니다.</entry>
    <entry key="IndexIntOutOfBounds">인덱스 표현식이 범위를 벗어났습니다. 요소 {0,number,integer}에 액세스하려고 시도했습니다. 타깃 정수 유형으로 표현 가능한 최댓값은 {1}입니다.</entry>
    <entry key="IndexSizeDimensionMismatch">이 인덱싱 표현식의 차원은 {0,number,integer}개이지만 크기 벡터의 요소는 {1,number,integer}개입니다.</entry>
    <entry key="IndexSizeDynamic">인덱스 표현식의 크기를 정적으로 알 수 없습니다.</entry>
    <entry key="InlineParadox">상충되는 지시문들이 이 함수의 인라인 처리를 강제로 요구하는 동시에 방지하고 있습니다. 마지막 설정이 적용됩니다.</entry>
    <entry key="ExportParadox">상충되는 지시문들이 이 함수의 내보내기를 강제로 요구하는 동시에 방지하고 있습니다. 마지막 설정이 적용됩니다.</entry>
    <entry key="MajorityParadox">함수의 배열 레이아웃을 두 번 이상 지정할 수 없습니다.</entry>
    <entry key="MajoritySetAfterCheck">coder.isRowMajor 또는 coder.isColumnMajor에 대한 호출 이후에 함수에서 배열 레이아웃을 지정할 수 없습니다.</entry>
    <entry key="MajorityNoClasses">클래스는 행 우선 함수에 대해 지원되지 않습니다.</entry>
    <entry key="MajorityCevalMultipleDefinitions">동일한 coder.ceval 선언에 대해 여러 배열 레이아웃 정의를 사용할 수 없습니다.</entry>
    <entry key="MajorityWrongExternalFcnMajority">Invalid global array layout mode for the external functions ''{0}''. Supported modes are : ''column'', ''row'' or ''any''.</entry>
    <entry key="MajorityUnsupportedClient">Current code generation workflow does not support row-major data types in {0}.</entry>
    <entry key="ImageUnsupportedClient">현재 코드 생성 워크플로는 {0}의 행 우선 이미지 데이터형을 지원하지 않습니다.</entry>
    <entry key="MajorityNoVarSizeIOWhenHaveRowMajor">{0}에 행 우선 데이터형이 포함되기 때문에 가변 크기 행렬이나 기호 차원을 포함하는 진입점 파라미터는 지원되지 않습니다.</entry>
    <entry key="MajorityHeterogenousVarRow">변수 ''{0}''은(는) 행 우선 배열 레이아웃으로 저장된 데이터를 포함합니다. 이는 첫 번째 진입점 함수에 지정된 열 우선 배열 레이아웃과 충돌합니다. 이 변수에 포함된 모든 데이터에 대해 열 우선 레이아웃을 사용하십시오.</entry>
    <entry key="MajorityHeterogenousVarColumn">변수 ''{0}''은(는) 열 우선 배열 레이아웃으로 저장된 데이터를 포함합니다. 이는 첫 번째 진입점 함수에 지정된 행 우선 배열 레이아웃과 충돌합니다. 이 변수에 포함된 모든 데이터에 대해 행 우선 레이아웃을 사용하십시오.</entry>
    <entry key="MajorityHeterogenousFcnRow">함수 ''{0}''은(는) 열 우선 배열 레이아웃을 사용해야 합니다. 모든 진입점 함수의 배열 레이아웃 사양은 첫 번째 진입점 함수와 동일해야 합니다.</entry>
    <entry key="MajorityHeterogenousFcnColumn">함수 ''{0}''은(는) 행 우선 배열 레이아웃을 사용해야 합니다. 모든 진입점 함수의 배열 레이아웃 사양은 첫 번째 진입점 함수와 동일해야 합니다.</entry>
    <entry key="MajorityAliasBreakForOverlaps">인수 {0,number,integer}과(와) {1,number,integer}이(가) 메모리에서 중첩될 가능성이 있는 경우 해당 배열 레이아웃의 변경은 지원되지 않습니다. 인수들을 하나의 인수로 결합하십시오.</entry>
    <entry key="MethodAttributesOutsideClass">''{0}''은(는) 클래스 메서드 내에서만 사용할 수 있습니다.</entry>
    <entry key="MethodMajorityNotAllowed">메서드에는 coder.rowMajor 지시문 또는 coder.columnMajor 지시문이 있을 수 없습니다.</entry>
    <entry key="MaxNumberDimensions">코드 생성 시 {0,number,integer}개를 초과하는 차원을 가진 배열은 지원되지 않습니다. 이 배열의 차원은 {1,number,integer}입니다.</entry>
    <entry key="ClassMajorityMismatch">기본 배열 레이아웃과 서브클래스 배열 레이아웃이 일치하지 않습니다.</entry>
    <entry key="MajorityCheckOnNonMatrixVar">coder.isRowMajor와 coder.isColumnMajor에 대한 인수는 행렬 변수여야 합니다.</entry>
    <entry key="GlobalTopMajorityMismatch">최상위 함수의 행/열 우선성은 전역 행/열 우선성과 다를 수 없습니다.</entry>
    <entry key="IndexRangeError">인덱스 {0,number,integer}이(가) 요소 개수({1,number,integer})을(를) 초과합니다.</entry>
    <entry key="InputSizeMismatch">크기가 불일치합니다. 입력값 {0,number,integer}은(는) 크기 {1}을(를) 가진 값을 필요로 합니다. 크기 {2}이(가) 발견되었습니다.</entry>
    <entry key="InrecognizedOperatorOption">연산자에 대한 옵션을 인식할 수 없습니다.</entry>
    <entry key="IntegerCombination">''{0}''을(를) ''{1}''과(와) 결합할 수 없습니다. 정수는 같은 클래스의 정수나 double형 스칼라와만 결합될 수 있습니다.</entry>
    <entry key="InternalError">\n내부 오류: 이 오류는 MathWorks 함수 내부에서 발생했습니다.</entry>
    <entry key="InvalidCClassName">유효하지 않은 C 클래스 이름입니다.</entry>
    <entry key="InvalidClassName">Invalid value ''{0}'' for the last argument.</entry>
    <entry key="InvalidComplexToNonComplexAssignment">복소수가 아닌 위치에 복소수 값을 할당할 수 없습니다.</entry>
    <entry key="InvalidEnumField">열거형 클래스 ''{1}''에 이름이 ''{0}''인 멤버가 없습니다.</entry>
    <entry key="InvalidEnumAccess">변수에서 열거형 상수 ''{0}''에 액세스할 수 없습니다. 다음의 열거형 이름을 사용하십시오: ''{1}.{0}''.</entry>
    <entry key="InvalidFloatClassName">후행 입력값은 ''single'' 또는 ''double''이어야 합니다.</entry>
    <entry key="InvalidInlineMode">인라인 모드 ''{0}''이(가) 유효하지 않습니다. ''always'', ''never'', ''default''만 지원됩니다.</entry>
    <entry key="InvalidAttributeName">''{0}''은(는) ''{1}''에 대해 유효한 옵션 이름이 아닙니다.</entry>
    <entry key="ConflictingMethodAttributes">메서드 ''{0}''이(가) ''{1}''이므로 특성 ''{1}''을(를) 적용할 수 없습니다.</entry>
    <entry key="InvalidPropertyMode">''{0}''은(는) 유효하지 않은 속성 모드입니다. ''associative''와 ''commutative''만 지원됩니다.</entry>
    <entry key="InvalidReductionOperation">유효하지 않은 축소 연산입니다.</entry>
    <entry key="DifferentReductionTypes">축소는 다른 유형을 사용합니다. 현재 유형은 ''{0}''입니다. 이전 유형은 ''{1}''이었습니다.</entry>
    <entry key="InvalidReductionOperationCommAssoc">지원되지 않는 축소 연산입니다.</entry>
    <entry key="InvalidReductionOperationNonBinary">유효하지 않은 축소 연산입니다. 이항 연산만 지원됩니다.</entry>
    <entry key="InvalidReductionOperationConcat">유효하지 않은 축소 연산입니다. MATLAB Coder에서 결합은 축소로 지원되지 않습니다.</entry>
    <entry key="InvalidNonComplexToComplexAssignment">중첩된 복소수 위치(필드 ''{0}'')에 복소수가 아닌 값을 묵시적으로 할당하는 것은 지원되지 않습니다.</entry>
    <entry key="InvalidOption">코드 생성 옵션 ''{0}''의 값이 유효하지 않습니다.</entry>
    <entry key="InvalidStructFieldName">Invalid field name ''{0}''</entry>
    <entry key="IsDefinedExpectsObjectProperty">이 내장 함수에 대한 입력값은 ''object.property''여야 합니다.</entry>
    <entry key="MCOSBuiltinRequiresNontunableProperty">이 내장 함수는 조정 불가형 속성만 지원합니다.</entry>
    <entry key="LhsClassQualifier">\n왼쪽에 있는 클래스는 대입식 좌변의 클래스입니다.</entry>
    <entry key="LhsRhsComplexMismatch">좌변은 복소수가 아닌 값으로 제한되었는데 우변은 복소수입니다. 이 문제를 해결하려면 함수 REAL을 사용하여 우변을 실수로 설정하거나 COMPLEX 함수를 사용하여 좌변 변수에 대한 초기 할당을 복소수 값으로 변경하십시오.</entry>
    <entry key="LhsRhsSizeMismatch">우변과 좌변은 요소 개수가 동일해야 합니다.</entry>
    <entry key="LhsSizeQualifier">\n왼쪽에 있는 크기는 대입식 좌변의 크기입니다.</entry>
    <entry key="LhsStructClassQualifier">\n왼쪽에 있는 구조체는 대입식 좌변의 클래스입니다.</entry>
    <entry key="LibAssertRequiresExactlyThreeInputs">eml_lib_assert()에는 3개의 입력값(조건, 메시지 ID, 메시지 텍스트)이 필요합니다.</entry>
    <entry key="LicenseCheck">이 함수를 컴파일하려면 기능 ''{0}''에 대한 라이선스가 필요합니다.</entry>
    <entry key="LicenseCheckoutFailed">함수 ''{1}''에 필요한 라이선스 ''{0}''을(를) 가져오지 못했습니다.</entry>
    <entry key="LicenseMode">coder.license에 대한 첫 번째 입력값은 'checkout'이어야 합니다.</entry>
    <entry key="LicenseListMustBeConstant">라이선스 목록은 상수여야 합니다.</entry>
    <entry key="LockedOption">옵션 ''{0}''이(가) 잠겨 있어 변경할 수 없습니다.</entry>
    <entry key="LooksLikeScript">코드 생성 시 스크립트는 지원되지 않습니다. 진입점 함수를 정의하십시오.</entry>
    <entry key="LoopTooBigForAutomaticUnroll">풀린 루프 본문의 크기가 자동 풀기의 최대 크기를 초과하여 루프 풀기에 실패했습니다. 원하는 경우 coder.unroll()을 사용하여 강제로 풀기 동작을 수행하십시오.</entry>
    <entry key="LoopUnrollParforVararg">parfor 루프에 대한 루프 풀기는 지원되지 않습니다.</entry>
    <entry key="LoopUnrollCountUnknown">반복 횟수를 알 수 없기 때문에 루프 풀기에 실패했습니다.</entry>
    <entry key="LoopUnrollCountUnknownOrNegative">반복 횟수를 알 수 없거나 음수이기 때문에 루프 풀기에 실패했습니다.</entry>
    <entry key="LoopUnrollCountUnreasonable">{1,number,integer}회의 반복 횟수가 허용된 최대 횟수 {0,number,integer}회를 초과하여 루프 풀기에 실패했습니다.</entry>
    <entry key="VarargIndex">루프 풀기에 실패하여 반복되는 변수 ''{0}''의 인덱스 값을 확인할 수 없습니다.</entry>
    <entry key="DynamicField">루프 풀기에 실패하여 동적 필드 이름을 확인할 수 없습니다.</entry>
    <entry key="UndefinedProp">루프 풀기에 실패하여 속성 ''{0}''이(가) 모든 요소에 대해 초기화되었는지 확인할 수 없습니다.</entry>
    <entry key="LoopUnrollCommonCellType">루프 풀기에 실패하여 모든 셀 요소에 대한 공통 유형을 확인할 수 없습니다.</entry>
    <entry key="MCOSCloningRequiredOnInput">함수 {1}을(를) 수행할 서로 다른 호출 위치에서 입력값 #{0,number,integer}의 유형이 {2}과(와) {3}(으)로 서로 다릅니다.</entry>
    <entry key="MCOSCloningRequiredOnOutput">{1} 함수를 수행할 서로 다른 호출 위치에서 출력값 #{0,number,integer}의 유형이 {2}과(와) {3}(으)로 서로 다릅니다.</entry>
    <entry key="MCOSOperationUnsupportedHere">MATLAB 클래스의 사용이 감지되었습니다. 클래스는 코드 생성 시 지원되지 않습니다.</entry>
    <entry key="MCOSOperationUnsupportedInThisFunction">MATLAB 클래스의 사용이 감지되었습니다. 이들은 코드 생성 시 지원되지 않습니다.</entry>
    <entry key="MCOSOperationUnsupportedNearHere">이 위치 주변에서 MATLAB 클래스의 사용이 감지되었습니다. 이는 코드 생성 시 지원되지 않습니다.</entry>
    <entry key="MCOSOperationUnsupported">이 연산은 코드 생성 시 지원되지 않습니다.</entry>
    <entry key="MCOSPropertyDoesNotExist">클래스 ''{0}''에 속성 ''{1}''이(가) 없습니다.</entry>
    <entry key="MCOSPropertyNotDefined">속성 ''{0}''이(가) 정의되지 않았습니다.</entry>
    <entry key="MCOSPropertyInitialValueUnsupportedType">속성 ''{0}''에 지원되지 않는 유형의 초기값이 있습니다.</entry>
    <entry key="MCOSPropertyInitialPropertyUnsupportedType">클래스 ''{0}''의 속성 ''{1}''의 초기값에 대해 코드를 생성할 수 없습니다.</entry>
    <entry key="MCOSNoClass">{0} 클래스가 없습니다.</entry>
    <entry key="MCOSNonConstPropertyInitialValueClassType">코드 생성 시 상수 속성에 대해서만 클래스 유형의 초기값이 지원됩니다. 클래스 ''{1}''의 속성 ''{0}''이(가) 상수가 아닙니다.</entry>
    <entry key="MCOSPropertyInitialValueClassTypeUnsupportedUse">Invalid constant property access. Use ''{0}.{1}.someProp'', but not ''{0}.{1}'' or ''{0}.{1}.getProp()''.</entry>
    <entry key="MCOSPropertyMismatchUnassigned">이 명령문으로 속성 ''{0}''을(를) 할당되지 않은 상태로 두거나 들어오는 모든 실행 경로로 속성 ''{0}''에 유형 ''{1}''을 가진 값으로 할당해야 합니다.</entry>
    <entry key="MCOSCannotCallProtectedMethod">보호 메서드 ''{0}''을(를) 호출할 수 없습니다.</entry>
    <entry key="MCOSTunablePropertyNoRuntimeValue">코드 생성 시 ''{0}''을(를) 포함하는 모든 속성은 조정 불가형으로 표시되어야 합니다.</entry>
    <entry key="MCOSCannotCallPrivateMethod">프라이빗 메서드 ''{0}''을(를) 호출할 수 없습니다.</entry>
    <entry key="MCOSConstructorCannotHaveTwoOutputs">Class constructor cannot have more than one output.</entry>
    <entry key="MCOSCannotCreateAbstractClassInstance">추상 클래스 ''{0}''의 인스턴스를 만들 수 없습니다.</entry>
    <entry key="MCOSUnsupportedFunctionOutputsUsed">This function or method is not supported for code generation but its outputs are used.</entry>
    <entry key="MCOSMethodNotFound">Method ''{0}'' is not found in class ''{1}''.</entry>
    <entry key="MCOSClassNotFound">클래스 ''{0}''을(를) 찾을 수 없습니다.</entry>
    <entry key="MCOSMethodIsStatic">클래스 ''{0}''의 메서드 ''{1}''은(는) 정적 메서드입니다.</entry>
    <entry key="MCOSMethodIsNotStatic">클래스 ''{0}''의 메서드 ''{1}''은(는) 정적 메서드가 아닙니다.</entry>
    <entry key="MCOSNonscalar">Code generation does not support {0} arrays.</entry>
    <entry key="MCOSCannotSetProtected">보호 속성 ''{0}''을(를) 설정할 수 없습니다.</entry>
    <entry key="MCOSCannotGetProtected">보호 속성 ''{0}''을(를) 가져올 수 없습니다.</entry>
    <entry key="MCOSCannotSetPrivate">프라이빗 속성 ''{0}''을(를) 설정할 수 없습니다.</entry>
    <entry key="MCOSCannotGetPrivate">프라이빗 속성 ''{0}''을(를) 가져올 수 없습니다.</entry>
    <entry key="MCOSCannotSetImmutable">Cannot set immutable property ''{0}'' outside the constructor of class ''{1}''.</entry>
    <entry key="MCOSSetPropUnsupportedValueClasses">코드 생성 시 set.prop 메서드가 있는 값 클래스는 지원되지 않습니다.</entry>
    <entry key="MCOSSetMethodPropertyAccess">클래스 ''{0}''에서, Dependent 속성 ''{1}''에 대한 set 메서드가 저장된 속성값에 액세스하려고 시도합니다. Dependent 속성에는 값이 저장되지 않으며 해당 set 메서드로 액세스할 수 없습니다.</entry>
    <entry key="MCOSGetMethodPropertyAccess">''{0}'' 클래스에서, Dependent 속성 ''{1}''에 대한 get 메서드가 저장된 속성값에 액세스하려고 합니다. Dependent 속성에는 값이 저장되지 않으며 해당 get 메서드로 액세스할 수 없습니다.</entry>
    <entry key="MCOSNoSetMethod">''{0}'' 클래스에서 Dependent 속성 ''{1}''에 대해 set 메서드가 정의되지 않았습니다. Dependent 속성의 값을 수정하려면 set 메서드가 필요합니다.</entry>
    <entry key="MCOSNoGetMethod">''{0}'' 클래스에서 Dependent 속성 ''{1}''에 대해 get 메서드가 정의되지 않았습니다. Dependent 속성의 값에 액세스하려면 get 메서드가 필요합니다.</entry>
    <entry key="MCOSNontunableUsedBeforeAssigned">조정 불가형 속성이 아직 할당되지 않았습니다. 조정 불가형 속성은 처음 사용하기 전에 완전히 할당해야 합니다.</entry>
    <entry key="MCOSNontunableDependentNotAllowed">코드 생성 시 조정 불가형 Dependent 속성은 지원되지 않습니다. 속성 ''{0}''은(는) 종속적이며 조정이 불가능합니다.</entry>
    <entry key="MCOSNontunablePropertyValueMismatch">조정 불가형 속성 ''{0}''의 값이 일치하지 않습니다.</entry>
    <entry key="MCOSNontunablePropertyValueMismatchLeftHasValue">조정 불가형 속성 ''{0}''의 값이 일치하지 않습니다. 속성의 좌변에는 상수 값이 할당되고 우변에는 상수 값이 할당되지 않습니다.</entry>
    <entry key="MCOSNontunablePropertyValueMismatchRightHasValue">조정 불가형 속성 ''{0}''의 값이 일치하지 않습니다. 속성의 우변에는 상수 값이 할당되고 좌변에는 상수 값이 할당되지 않습니다.</entry>
    <entry key="MCOSMajorityPropertyValueMismatch">배열 레이아웃이 일치하지 않습니다.</entry>
    <entry key="MCOSAssignmentToConstantProperty">Setting the constant property ''{0}'' of the ''{1}'' class is not allowed.</entry>
    <entry key="MCOSAssignmentToMethodName">메서드 호출은 대입식의 타깃이 될 수 없습니다.</entry>
    <entry key="MCOSTwoMethodsSameNameInClass">클래스 ''{1}''에 이름이 ''{0}''인 메서드가 2개 이상 있습니다.</entry>
    <entry key="MCOSExtrinsicMethodCallWithDotNotsupported">코드 생성 시 점 표기법을 사용한 외재적 메서드 호출은 지원되지 않습니다. ''{0}''은(는) 외재적 메서드입니다.</entry>
    <entry key="MCOSStaticPropertyNoDefaultValue">속성 ''{0}''에 디폴트 값이 없습니다. 코드 생성 시 디폴트 값이 없는 상수 속성은 지원되지 않습니다.</entry>
    <entry key="MCOSBaseConstructorCallMustBeFirst">코드 생성 시 기본 생성자에 대한 호출 앞에 DISP, FOR, WHILE, SWITCH, IF 또는 RETURN이 올 수 없습니다.</entry>
    <entry key="MCOSClassConstructorMustHaveOneOutput">클래스 생성자는 정확히 하나의 출력값을 가져야 합니다.</entry>
    <entry key="MCOSBaseClassCannotBeLoaded">기본 클래스 ''{0}''을(를) 불러올 수 없습니다.</entry>
    <entry key="MCOSClassCannotBeLoaded">클래스 ''{0}''을(를) 불러올 수 없습니다.</entry>
    <entry key="MCOSInputNonTunablePropertyUnupported">클래스 ''{0}''에 조정 불가형 속성 ''{1}''이(가) 있습니다. 조정 불가형 속성을 가진 클래스는 진입점 함수에 대한 입력값으로 지원되지 않습니다.</entry>
    <entry key="MCOSNonTunablePropertyCannotBeImported">클래스 ''{0}''에 조정 불가형 속성 ''{1}''이(가) 있습니다. 조정 불가형 속성을 가진 클래스는 외재적 함수의 출력값으로 지원되지 않습니다.</entry>
    <entry key="MCOSEnumerationBlocksUnsupported">코드 생성 시 클래스의 enumeration 블록은 지원되지 않습니다.</entry>
    <entry key="MCOSEventsUnsupported">코드 생성 시 이벤트는 지원되지 않습니다.</entry>
    <entry key="MCOSMethodUnsupported">The method ''{0}'' is not supported for code generation.</entry>
    <entry key="MCOSOverloadingUnsupported">코드 생성 시 메서드 ''{0}''을(를) 오버로드하는 것은 지원되지 않습니다.</entry>
    <entry key="MCOSDeleteUnsupported">코드 생성 시 ''delete'' 메서드는 지원되지 않습니다. 핸들 객체는 프로그램 실행이 종료될 때만 소멸되며, 소멸자는 절대 호출되지 않습니다.</entry>
    <entry key="MCOSExplicitDeleteUnsupported">코드 생성 시 ''delete'' 메서드에 대한 명시적 호출은 지원되지 않습니다.</entry>
    <entry key="MCOSMethodNotFoundInRTTI">이 함수는 유효한 MATLAB 메서드가 아닙니다.</entry>
    <entry key="MCOSTwoMethodsSameName">코드 생성 시 이름이 동일한 2개 이상의 클래스 메서드는 지원되지 않습니다.</entry>
    <entry key="MCOSClassDoesnotHaveProperty">클래스 ''{0}''에 속성 ''{1}''이(가) 없습니다.</entry>
    <entry key="MCOSConstructorAssignToPersistentOrProperty">코드 생성 시 핸들 클래스의 새 인스턴스는 영속 변수 또는 영속 변수 내부의 속성에 할당해야 합니다.</entry>
    <entry key="MCOSAliasedAssignmentExplanation">코드 생성 시 핸들 클래스 핸들 값의 기존 인스턴스는 지역 변수 또는 함수 출력값에만 할당할 수 있습니다.</entry>
    <entry key="MCOSHandleInValue">코드 생성 시 값 클래스 내부의 핸들 클래스는 지원되지 않습니다.</entry>
    <entry key="SharedMCOSHandleInParfor">변수 ''{0}''은(는) PARFOR 외부에 할당된 핸들 클래스를 포함하므로 PARFOR 내부에서 사용할 수 없습니다.</entry>
    <entry key="PersistentMCOSHandleInParfor">영속 변수 ''{0}''은(는) 핸들 클래스를 포함하므로 PARFOR 내부에서 사용할 수 없습니다.</entry>
    <entry key="MCOSUsedAtEntryPoint">{0}을(를) 포함하는 최상위 출력 파라미터는 {1}에서 지원되지 않습니다. 출력 파라미터 ''{2}''은(는) {0}을(를) 포함합니다.</entry>
    <entry key="MCOSHandleUsedAtEntryPoint">최상위 출력값의 핸들 클래스는 {1}에서 지원되지 않습니다. 출력 파라미터 ''{0}''은(는) 핸들 클래스를 포함합니다.</entry>
    <entry key="MCOSUsedAtBoundary">클래스를 외재적 MATLAB 함수 또는 C 함수나 Stateflow 함수로 전달할 수 없습니다.</entry>
    <entry key="MCOSStringNotSupportedHere">문자열은 여기에서 지원되지 않습니다.</entry>
    <entry key="MCOSStringAsForeignFunctionArg">이 함수의 인수로 지원되지 않는 연산을 사용하여 문자열을 만들었습니다.</entry>
    <entry key="MCOSNotSupportedHere">MATLAB 클래스는 여기에서 지원되지 않습니다.</entry>
    <entry key="MCOSHandleNotSupportedHere">MATLAB 핸들 클래스는 여기에서 지원되지 않습니다.</entry>
    <entry key="MCOSHandleUnsupportedForMxArrayValues">MATLAB 핸들 클래스는 외재적 함수에 대한 입력값 또는 출력값으로 지원되지 않습니다.</entry>
    <entry key="MCOSHandleNotSupportedSave">''save''에 대해 MATLAB 핸들 클래스가 지원되지 않으므로 클래스 ''{0}''의 객체를 ''save''로 전달할 수 없습니다.</entry>
    <entry key="MCOSCannotPassClassesToMATLABFunction">클래스 ''{0}''의 객체를 외재적 MATLAB 함수 ''{1}''(으)로 전달할 수 없음</entry>
    <entry key="MCOSCannotPassHandleClassesToMATLABFunction">핸들 클래스 ''{0}''의 객체를 외재적 MATLAB 함수 ''{1}''(으)로 전달할 수 없음</entry>
    <entry key="MCOSMxArrayNotAllowedForInternal">mxArray를 ''{0}''(으)로 전달할 수 없습니다.</entry>
    <entry key="MCOSCannotLoadClassWithMsg">클래스 ''{0}''을(를) 불러올 수 없음: {1}</entry>
    <entry key="MCOSPropertyInitialValueLoadFailed">속성 ''{0}''의 초기값을 불러올 수 없음: {1}</entry>
    <entry key="MCOSPropertyAssignmentInConstructorOnly">코드 생성 시 바깥쪽 클래스의 생성자 내부의 핸들 속성에 대한 할당만 지원됩니다.</entry>
    <entry key="MCOSPropertyAssignmentInConstructorOnlyOnce">코드 생성 시 각 핸들 속성은 정확히 한 번만 할당되어야 합니다. 이 할당은 0회 실행되거나 2회 이상 실행될 수도 있습니다.</entry>
    <entry key="MCOSHandlePropertyAssignmentCannotBeNested">코드 생성 시 바깥쪽 클래스의 생성자 내부의 핸들 속성에 대한 할당만 지원됩니다. 클래스 ''{0}''의 속성 ''{1}''이(가) 클래스 생성자 외부에서 할당되었습니다.</entry>
    <entry key="MCOSHandlePropertyAssignedTwice">코드 생성 시 각 핸들 속성은 정확히 한 번만 할당되어야 합니다. 이 속성에 대해 2개 이상의 할당이 있습니다.</entry>
    <entry key="MCOSDiamondInheritanceNotSupported">코드 생성 시 다이아몬드 형태 상속은 지원되지 않습니다. 클래스 ''{0}''은(는) 두 개 이상의 경로를 통해 기본 클래스 ''{1}''에서 상속됩니다.</entry>
    <entry key="MCOSCallInDefaultConstructorFailed">''{1}''의 디폴트 생성자에서 ''{0}''에 대한 호출에 실패했습니다.</entry>
    <entry key="MCOSAccessListAttrNotSupported">코드 생성 시, ''{0}'' 선언에 사용된 것처럼 'Access' 특성에서 메타클래스나 함수 핸들은 지원되지 않습니다.</entry>
    <entry key="MCOSOnceSentinelPropertyMustBePrivate">'once' 센티널 속성 ''{0}''은(는) 프라이빗이어야 합니다.</entry>
    <entry key="MCOSOnceMethodMustBeProtectedOrPublic">'once {0}' 메서드 ''{1}''은(는) 보호되거나 퍼블릭이어야 합니다.</entry>
    <entry key="MCOSOnceSentinelPropertyMustHaveInitialValueOfFalse">'once' 센티널 속성 ''{0}''은(는) 초기값이 'false'여야 합니다.</entry>
    <entry key="MCOSOnceSentinelAndSetupMustBeInSameClass">코드 생성 시 setup()을 재정의하는 것은 지원되지 않습니다. isInitialized와 setup()은 동일한 클래스에서 선언해야 합니다.</entry>
    <entry key="MCOSUnsupportedPropertyTypeFunctionHandle">코드 생성 시 클래스 속성에서 함수 핸들은 지원되지 않습니다.</entry>
    <entry key="MCOSUnsupportedPropertyTypeMxArray">코드 생성 시 mxArray 유형의 조정 가능형 클래스 속성은 지원되지 않습니다.</entry>
    <entry key="EntryPointNontunableMxArrayProperty">코드 생성 시 진입점에서 mxArray 유형의 조정 불가형 클래스 속성은 지원되지 않습니다.</entry>
    <entry key="ExtrinsicNontunableMxArrayProperty">코드 생성 시, 외재적 함수로 전달되거나 외재적 함수에서 반환된 mxArray 유형의 조정 불가형 클래스 속성은 지원되지 않습니다.</entry>
    <entry key="SaveNontunableMxArrayProperty">코드 생성 시, ''save''로 전달된 mxArray 유형의 조정 불가형 클래스 속성은 지원되지 않습니다.</entry>
    <entry key="MCOSConstructorNameConflict">클래스 생성자의 입력값과 출력값은 이름이 동일할 수 없습니다. 입력값 #''{1, number, integer}''의 이름과 출력값 #''{2, number, integer}''의 이름이 모두 ''{0}''입니다.</entry>
    <entry key="MCOSClassDoesNotSupportCodeGeneration">''{0}'' 클래스는 코드 생성을 지원하지 않습니다.</entry>
    <entry key="MCOSMethodDoesNotSupportCodeGeneration">The ''{0}'' method does not support code generation.</entry>
    <entry key="MCOSClassIsNotSupportedAsInitialValue">코드 생성 시 ''{1}''은(는) 속성의 초기값으로 지원되지 않습니다. 속성 ''{0}''이(가) 상수일 필요가 없으면 초기값을 제거하고 이를 생성자에서 대신 할당하십시오.</entry>
    <entry key="MCOSSeaLimitationNew">함수 ''{1}''의 영속 변수 ''{0}''과(와) 함수 ''{3}''의 변수 ''{2}''은(는) 클래스 ''{4}''의 동일한 인스턴스를 참조할 수 있습니다. 내부 제한으로 인해 2개의 영속 변수는 이 클래스의 동일한 인스턴스를 가리킬 수 없습니다.</entry>
    <entry key="MCOSSeaLimitationInstance">이 표현식과 표현식의 속성 ''{0}''은(는) 클래스가 동일합니다. 코드 생성 시 재귀적 데이터 구조체는 지원되지 않습니다.</entry>
    <entry key="MCOSSeaLimitationInstanceNamedVar">''{0}''과(와) ''{1}''은(는) 클래스가 동일합니다. 코드 생성 시 재귀적 데이터 구조체는 지원되지 않습니다.</entry>
    <entry key="MCOSSeaLimitationInstanceProp">이 표현식의 속성 ''{0}''과(와) 속성 ''{1}''은(는) 클래스가 동일합니다. 코드 생성 시 재귀적 데이터 구조체는 지원되지 않습니다.</entry>
    <entry key="MCOSHandlePropertyAssignmentNonHandleHost">코드 생성 시 비핸들 클래스 내부의 핸들 속성은 지원되지 않습니다. 비핸들 클래스 ''{1}''의 속성 ''{0}''에는 핸들 클래스 ''{2}''에 대한 참조를 할당할 수 없습니다.</entry>
    <entry key="MCOSNontunableValueClassProperty">코드 생성 시 값 클래스의 객체를 조정 불가형 속성에 할당하는 것은 지원되지 않습니다.</entry>
    <entry key="MCOSNontunableMCOSInCell">코드 생성 시 객체를 포함하는 셀형 배열을 조정 불가형 속성에 할당하는 것은 지원되지 않습니다.</entry>
    <entry key="MCOSClassNotSupportedHereMissingFromRedirect">코드 생성 시 이 컨텍스트에서는 MATLAB 클래스 ''{0}''이(가) 지원되지 않는데, 그 이유는 이 클래스가 toRedirect() 메서드 및/또는 fromRedirect() 메서드를 구현하지 않기 때문입니다.</entry>
    <entry key="ThisTypeCannotBeDisplayed">''{0}''을(를) 표시할 수 없습니다.</entry>
    <entry key="DisplayNotSupportedForHandleClasses">코드 생성 시 핸들 클래스에 대한 표시는 지원되지 않습니다. ''{0}''은(는) 핸들 클래스입니다.</entry>
    <entry key="MCOSFcnHandleNonStaticMethod">코드 생성 시 비정적 메서드를 가리키는 함수 핸들은 지원되지 않습니다. 함수 핸들 @obj.method를 동등한 익명 함수 @(varargin)obj.method(varargin'{:}')으로 바꾸십시오.</entry>
    <entry key="MCOSAbortSetUnsupported">코드 생성 시 AbortSet 특성이 있는 속성은 지원되지 않습니다. 속성 ''{0}''은(는) AbortSet 특성을 가집니다.</entry>
    <entry key="MCOSInputParserUnsupported">코드 생성 시 inputParser 객체는 지원되지 않습니다. arguments 블록을 사용하여 인수 유효성 검사를 수행하십시오.</entry>
    <entry key="MCOSInputTransientPropertyUnsupported">코드 생성 시 과도 속성을 가진 클래스는 진입점 함수에 대한 입력값으로 지원되지 않습니다. 클래스 ''{1}''의 속성 ''{0}''에 대한 과도 특성은 true입니다.</entry>
    <entry key="MCOSOutputTransientPropertyUnsupported">코드 생성 시 과도 속성을 가진 클래스는 진입점 함수의 출력값으로 지원되지 않습니다. 클래스 ''{1}''의 속성 ''{0}''에 대한 과도 특성은 true입니다.</entry>
    <entry key="MCOSTransientPropertyCannotBeExported">코드 생성 시 과도 속성을 가진 클래스는 외재적 호출에 대한 입력값으로 지원되지 않습니다. 클래스 ''{1}''의 속성 ''{0}''에 대한 과도 특성은 true입니다.</entry>
    <entry key="MCOSTransientPropertyCannotBeImported">코드 생성 시 과도 속성을 가진 클래스는 외재적 호출의 출력값으로 지원되지 않습니다. 클래스 ''{1}''의 속성 ''{0}''에 대한 과도 특성은 true입니다.</entry>
    <entry key="MCOSTransientPropertyUnsupportedForMxArrayValues">과도 속성을 가진 클래스는 mxArray 값으로 상호 변환할 수 없습니다. 클래스 ''{1}''의 속성 ''{0}''에 대한 과도 특성은 true입니다.</entry>
    <entry key="MxArrayNotEliminated">외재적 함수 호출에서 반환된 mxArray를 제거할 수 없습니다. 독립 실행형 코드를 생성하려면 코드 생성기가 MATLAB 코드에서 모든 mxArray를 제거할 수 있어야 합니다.</entry>
    <entry key="MatlabFunctionNotEliminated">외재적 함수 ''{0}''의 출력값이 호출하는 함수에 영향을 미치는 것처럼 보이므로 독립 실행형 코드를 생성할 수 없습니다. ''{1}''에 대한 호출을 제거하거나 해당 출력값이 사용되지 않도록 하십시오.</entry>
    <entry key="MatlibInputUnknown">MATLAB 함수 호출에 대한 입력값은 알려진 크기와 클래스여야 합니다.</entry>
    <entry key="MatrixDeletion">행렬에서 요소를 제거하는 것은 지원되지 않습니다.</entry>
    <entry key="MatrixMulSize">크기가 {0}인 행렬에 크기가 {1}인 행렬을 곱할 수 없습니다. 행렬 곱셈 A * B의 경우, A의 열 개수는 B의 행 개수와 일치해야 합니다.</entry>
    <entry key="MexInterceptionActivationConstructor">''{0}''이(가) 클래스 생성자이므로, 이에 대해 인터셉션을 활성화할 수 없습니다.</entry>
    <entry key="MexInterceptionActivationDuplicateInterception">이 이름을 가진 기호에 대해 이미 인터셉션이 활성화되어 있으므로, ''{0}''에 대해 인터셉션을 활성화할 수 없습니다.</entry>
    <entry key="MexInterceptionActivationFileNotFound">기호를 찾을 수 없음: {0}. 파일의 전체 경로를 제공하십시오.</entry>
    <entry key="MexInterceptionActivationFileAlreadyExists">충돌하는 파일이 이미 있으므로 기호 ''{0}''에 대해 인터셉션을 활성화할 수 없습니다: {1}</entry>
    <entry key="MexInterceptionActivationNamespace">''{0}''이(가) 네임스페이스에 있으므로 이에 대해 인터셉션을 활성화할 수 없습니다.</entry>
    <entry key="MexInterceptionActivationNonAbsolutePath">경로가 절대 경로가 아님: {0}. 절대 경로를 제공하십시오.</entry>
    <entry key="MexInterceptionActivationNotOnPath">''{0}''이(가) MATLAB 경로에 없으므로 이에 대해 인터셉션을 활성화할 수 없습니다.</entry>
    <entry key="MexInterceptionActivationSymbolShadowed">''{0}''이(가) ''{1}''에 의해 가려져 있으므로 이에 대해 인터셉션을 활성화할 수 없습니다</entry>
    <entry key="MexInterceptionDeactivationNotActive">인터셉션이 활성화되어 있지 않으므로 ''{0}''에 대해 인터셉션을 비활성화할 수 없습니다.</entry>
    <entry key="MexInterceptionDectivationSymbolShadowed">''{0}''이(가) ''{1}''에 의해 가려져 있으므로 이에 대해 인터셉션을 비활성화할 수 없습니다</entry>
    <entry key="MexInterceptionGenerationFileNotFound">MEX 파일을 찾을 수 없음: {0}</entry>
    <entry key="MexInterceptionGenerationMexNotOnPath">coder.internal.GeneratedMexInterception에 대한 입력값은 MATLAB 경로에 있는 유효한 MEX 파일이어야 함: {0}</entry>
    <entry key="MexInterceptionGenerationInvalidMex">''{0}''은(는) 유효하지 않은 MEX 파일입니다. MEX는 이 플랫폼의 현재 릴리스에 있는 MATLAB Coder에 의해 생성되어야 합니다.</entry>
    <entry key="MissingEMLPragma">''{0}''에 %#codegen이 누락되었습니다. \n이 파일에 %#codegen을 추가하여 코드 생성에 적합함을 나타내십시오. \n(''{1}''의 전체 경로는 ''{2}''입니다.)</entry>
    <entry key="MixedDoubleInteger">정수형 피연산자와 상호 작용하는 double형 피연산자는 정수 값을 가져야 합니다.</entry>
    <entry key="MixedInputs">혼합 입력값은 single형과 double형의 혼합이거나 정수와 double형 스칼라의 혼합이어야 합니다. 다른 모든 조합은 더 이상 허용되지 않습니다.</entry>
    <entry key="MultOutputOperator">이 연산자에는 여러 출력값이 없습니다</entry>
    <entry key="MultipleReturnValuesFromStateflow">Stateflow 함수는 여러 출력값을 반환할 수 없습니다.</entry>
    <entry key="MustBeConst">값은 상수여야 합니다.</entry>
    <entry key="MxArrayInput">입력값은 mxArray입니다.</entry>
    <entry key="MxArraySubscript">2개의 mxArray 간에 첨자를 사용한 대입식은 지원되지 않습니다.</entry>
    <entry key="MxEmptyStructure">코드 생성 시 빈 구조체는 지원되지 않습니다. ''{0}''에서 빈 구조체를 발견했습니다.</entry>
    <entry key="MxMixedStructureFieldTypes">Mixed field types in structure arrays not supported for code generation. Type at ''{0}'' must match type at ''{1}''.</entry>
    <entry key="MxStructureWithEmptyMatrix">구조체 내부의 빈 행렬은 지원되지 않습니다. ''{0}''에서 빈 행렬이 발견되었습니다.</entry>
    <entry key="MxStructureWithCell">Codegen은 구조체에 셀형 배열이 있는 MATLAB에서 변수를 가져오는 것을 지원하지 않습니다. ''{0}''에서 셀형 배열이 발견되었습니다.</entry>
    <entry key="MxUnsupportedClass">MATLAB class ''{0}'' found at ''{1}'' not supported for code generation.</entry>
    <entry key="MxUnsupportedFixedPointType">''{0}''에 사용된 고정소수점 데이터형은 지원되지 않습니다.</entry>
    <entry key="MxUnsupportedFixedPointWordLength">지원되지 않는 고정소수점 데이터형이 ''{0}''에 사용되었습니다. 유형의 워드 길이가 128비트보다 큽니다.</entry>
    <entry key="MxUnsupportedSparseMatrix">''{0}''에서 발견된 희소 행렬은 지원되지 않습니다.</entry>
    <entry key="MxVariableSizeConst">필드 {0}이(가) 배열 요소에 따라 크기가 다르기 때문에 코드 생성 시 이 구조체형 배열을 상수로 정의하는 것은 지원되지 않습니다. 이 필드를 배열에 있는 구조체의 모든 인스턴스에서 같은 크기가 되도록 만들거나, 구조체형 배열을 구조체형 스칼라로 구성된 셀형 배열로 다시 생성하십시오.</entry>
    <entry key="MxErrorLoadingClass">MATLAB 객체 ''{0}''을(를) 불러오는 중에 오류가 발생했습니다. 클래스 생성자에서 오류가 발생하여 비정상적으로 종료되었을 가능성이 큽니다.</entry>
    <entry key="MxUnsupportedMCOSArrays">Element ''{0}'' is an array of objects. Code generation does not support constants containing arrays of objects. </entry>
    <entry key="MxUnsupportedValue">Value at ''{0}'' unsupported for code generation.</entry>
    <entry key="MxUnsupportedMCOSConstant">코드 생성 시 클래스 ''{1}''의 상수는 지원되지 않습니다. 변수 ''{0}''의 값은 클래스 ''{1}''의 객체입니다.</entry>
    <entry key="MxIncompatibleValue">''{0}''에 있는 값이 필요한 유형 ''{1}''과(와) 일치하지 않습니다.</entry>
    <entry key="MxIncompatibleEnum">''{0}''에 있는 값이 ''int8'', ''uint8'', ''int16'', ''uint16'', ''int32'', ''uint32'', ''Simulink.IntEnumType'' 중 하나를 기준으로 하는 열거형 클래스가 아닙니다.</entry>
    <entry key="MxStringEncodingConversionError">MATLAB 코드 생성 문자 인코딩(''{1}'')을 사용하여 8비트 문자로 ''{0}''을(를) 나타낼 수 없습니다. 코드 생성 시 8비트로 표현할 수 있는 문자만 지원됩니다.</entry>
    <entry key="MxStringEncodingSizeConsistencyError">MATLAB 코드 생성 문자 인코딩(''{1}'')으로 ''{0}''을(를) 변환하여 문자 수가 변경되었습니다. 코드 생성 시 이 변화는 지원되지 않습니다.</entry>
    <entry key="MxStringDecodingConversionError">string형 배열 또는 문자형 배열은 MATLAB 코드 생성 문자 인코딩(''{0}'')에서 변환할 수 없습니다.</entry>
    <entry key="MxStringDecodingSizeConsistencyError">MATLAB 코드 생성 문자 인코딩(''{0}'')에서 string형 배열 또는 문자형 배열을 변환하여 문자 수가 변경되었습니다. 코드 생성 시 이 변화는 지원되지 않습니다.</entry>
    <entry key="MxFiSimulinkIncompatible">''{0}''에 있는 값은 {1,number,integer}비트보다 큰 고정소수점 숫자이며, 이는 지원되지 않습니다.</entry>
    <entry key="MxNontunableParamsNotSupported">코드 생성 시 MATLAB에서 ''{0}'' 인스턴스를 가져오는 것은 지원되지 않습니다.</entry>
    <entry key="MxHandleClassesNotSupported">Importing handle classes from MATLAB not supported for code generation.</entry>
    <entry key="NestedFunctionsInConstructor">코드 생성 시 생성자 내부의 중첩 함수는 지원되지 않습니다.</entry>
    <entry key="NoConversionPossible">지원되는 유형으로 변환할 수 없습니다.</entry>
    <entry key="NoFixedPoint">''embedded.fi''는 여기에서 허용되지 않습니다.</entry>
    <entry key="NoImplicitCast">이 두 클래스 간에 묵시적 형변환을 수행할 수 없습니다.</entry>
    <entry key="NoNargoutSpecified">반복되는 출력 변수 ''{0}''을(를) 사용하려면 nargout 지정이 필요합니다. '-nargout'을 사용하여 함수 ''{1}''에서 원하는 출력값 개수를 지정하십시오.</entry>
    <entry key="NoVararg">현재 함수에 {2} 파라미터가 없는 상태에서 {0}'{'{1,number,integer}'}'에 액세스하려고 시도했습니다.</entry>
    <entry key="NonConstantBraceListAssignRhsCount">braceListAssign에 일정한 수의 값이 할당되어야 합니다.</entry>
    <entry key="NonFinites">타깃은 nonfinite 값(Inf와 NaN)을 지원하지 않습니다. 이 표현식을 허용하려면 코드 생성 구성 파라미터를 변경하십시오.</entry>
    <entry key="NonIntegerIndexExpr">값 {0}을(를) 갖는, 정수가 아닌 인덱스 표현식입니다.</entry>
    <entry key="NonIntegerSizeVector">정수가 아닌 크기 벡터가 발견되었습니다.</entry>
    <entry key="NonScalarSubsRefInRef">{0} 내부에는 스칼라 첨자를 사용하는 것만 허용됩니다. 이 첨자식은 크기가 {1}인 행렬을 반환합니다.</entry>
    <entry key="NonTunableVariableHasMultipleAssignments">coder.nontunable()로 표시된 변수에 대한 대입식이 하나만 있을 수도 있습니다.</entry>
    <entry key="NonTunablePropertyHasMultipleAssignments">Nontunable property ''{0}'' may only be assigned once.</entry>
    <entry key="NonTunablePropertyMustBeCompletelyAssigned">클래스 ''{1}''의 조정 불가형 속성 ''{0}''은(는) 첨자를 사용한 대입식으로 정의할 수 없습니다. 대신 완전한 대입식을 사용하십시오.</entry>
    <entry key="NonTunablePropertyNotConst">Failed to compute constant value for nontunable property ''{0}''. In code generation, nontunable properties can only be assigned constant values.</entry>
    <entry key="NonZeroImag">The imaginary part must be zero. Expected a scalar numeric value.</entry>
    <entry key="NotSupportedInMATLAB">함수 {0}은(는) MATLAB에서 지원되지 않습니다. coder.target을 사용하여 {0}의 사용을 코드 생성으로 제한합니다.</entry>
    <entry key="NullCharacter">이 string형 또는 문자형 벡터에 null 문자 char(0)이 포함되어 있습니다. 코드 생성 시 이 컨텍스트에서는 null 문자가 지원되지 않습니다.</entry>
    <entry key="NullCopyDoesNotSupportClass">coder.nullcopy는 클래스 ''{0}''의 입력값을 지원하지 않습니다.</entry>
    <entry key="NullCopyNotOnRhsOfAssignment">coder. nullcopy는 대입식의 우변에만 나타날 수 있습니다.</entry>
    <entry key="NullCopyOnRhsOfSubscriptedAssignment">coder. nullcopy는 첨자를 사용하지 않은 대입식에서만 나타날 수 있습니다.</entry>
    <entry key="InvalidLHS">이 표현식의 정의가 유효하지 않습니다.</entry>
    <entry key="NullInput">입력 표현식이 누락되었습니다.</entry>
    <entry key="NumDimsMismatchInAssignment">대입식의 좌변이 우변보다 차원이 적습니다. {0}은(는) {1}에서 할당될 수 없습니다.</entry>
    <entry key="NumDimsMismatchInAssignmentOnField">대입식의 좌변에 있는 필드 ''{0}''이(가) 우변의 필드보다 차원이 적습니다: {1}은(는) {2}에서 할당될 수 없습니다.</entry>
    <entry key="NumDimsMismatchInAssignmentOnCell">할당의 좌변에 있는 요소 ''{0}''이(가) 우변의 요소보다 차원이 적습니다: {1}은(는) {2}에서 할당될 수 없습니다.</entry>
    <entry key="CannotDetermineNumberOfElements">요소 개수를 확인할 수 없습니다.</entry>
    <entry key="NumericTypeLocked">연산자에서 숫자형을 두 번 설정하려고 시도했습니다.</entry>
    <entry key="NumerictypeMismatch">embedded.numerictype 객체의 속성이 일치해야 합니다.</entry>
    <entry key="NumerictypeMismatchOnCell">요소 ''{0}''에서 embedded.numerictype 객체의 속성이 일치해야 합니다.</entry>
    <entry key="NumerictypeMismatchOnField">필드 ''{0}''에서 embedded.numerictype 객체의 속성이 일치해야 합니다.</entry>
    <entry key="NumfieldsArg">인수의 유형은 구조체여야 합니다.</entry>
    <entry key="OpGeneratingComplexSlopeBiasFiUnsupported">Fixed-Point Designer 작업으로 생성된 모든 복소수 FI 객체는 기울기가 2의 정수 거듭제곱이어야 하고 편향이 0이어야 합니다.</entry>
    <entry key="OpaqueCannotBeDisplayed">불투명(Opaque) 값은 자동으로 표시할 수 없습니다. 자동 표시를 하지 않으려면 세미콜론으로 명령문을 종료하십시오.</entry>
    <entry key="OpaqueCannotBeExported">불투명(Opaque) 값은 MATLAB에 대한 호출로 전달될 수 없습니다.</entry>
    <entry key="OpaqueCannotBeImported">불투명(Opaque) 값은 MATLAB에 대한 호출로부터 반환될 수 없습니다.</entry>
    <entry key="OpaqueCannotBeSaved">불투명(Opaque) 값은 ''save''로 전달될 수 없습니다.</entry>
    <entry key="UnassignedMClassCannotBeImported">할당되지 않은 셀을 포함하는 셀형 배열은 MATLAB에 대한 호출로부터 반환될 수 없습니다.</entry>
    <entry key="OpaqueInitialValue">함수 호출에 초기값 없이 함수 coder.opaque가 사용되었습니다. 함수 호출에 coder.opaque를 사용하려면 초기값을 두 번째 인수로 제공하십시오.</entry>
    <entry key="OpaqueEmptyType">coder.opaque의 첫 번째 파라미터는 유효한 C 유형이어야 합니다.</entry>
    <entry key="OpaqueMissingHeaderFile">''{1}''에 대한 위치 {0,number,integer}에 있는 선택적 파라미터 이름은 ''HeaderFile'' 또는 ''Size''여야 합니다.</entry>
    <entry key="OpaqueMissingHeaderFileValue">입력 인수가 부족합니다. ''{1}''의 ''{0}'' 파라미터에 대한 값을 지정해야 합니다.</entry>
    <entry key="OperandSizesMustBeKnown">{0}의 비 스칼라 피연산자는 알려진 크기여야 함: 피연산자 {1,number,integer}의 크기를 알 수 없습니다.</entry>
    <entry key="OperandSizesMustBeEqual">{0}의 비 스칼라 피연산자는 크기가 같아야 함: 피연산자 {1,number,integer}은(는) {2}이지만 피연산자 {3,number,integer}은(는) {4}입니다.</entry>
    <entry key="OperatorOutsideExpr">{0}이(가) 표현식 안에서 나타나지 않을 수 있습니다. 최상위 수준에서만 나타날 수 있습니다.</entry>
    <entry key="OperatorMustBeOutsideControlFlow">''{0}''은(는) IF 문, SWITCH 문, FOR 문 또는 WHILE 문 안에 중첩되거나 조건부 RETURN 문을 따라야 합니다.</entry>
    <entry key="OverflowModeLocked">연산자에서 오버플로 모드를 두 번 설정하려고 시도했습니다.</entry>
    <entry key="ElementDeletionUnsupported">For code generation, class ''{0}'' does not support element deletion.</entry>
    <entry key="PCodeMessageSuppressed">P 코드 파일 문제가 감지되었습니다. 대응하는 MATLAB 코드를 컴파일하여 문제를 진단하십시오.</entry>
    <entry key="PCodeMode">{1} 함수에 대한 인수 ''{0}''은(는) 지원되지 않습니다.</entry>
    <entry key="ParCallToCustomCCode">병렬 FOR 루프 내부의 사용자 지정 C 코드로 호출합니다.</entry>
    <entry key="ParCallToSideEffectFcn">병렬 FOR 루프 내부에서 부수 효과가 있는 함수를 호출합니다.</entry>
    <entry key="ParforTooManyArguments">이 PARFOR 문에는 너무 많은 인수가 포함되어 있습니다.</entry>
    <entry key="ParGlobalPersistentAccess">GLOBAL 변수 또는 PERSISTENT 변수 ''{0}''은(는) PARFOR 루프 내에 설정하면 안 됩니다.</entry>
    <entry key="ParIndexRangeError">PARFOR 문의 범위는 연속으로 증가하는 부호 있는 정수여야 합니다.</entry>
    <entry key="ParIndexVariableUseError">인덱스 변수 ''{0}''이(가) PARFOR 루프 이후에 사용되었을 수 있는데, 이 변수는 루프 이후에 사용할 수 없습니다.</entry>
    <entry key="ParIndexVariableDefError">PARFOR 루프 내에서는 루프 인덱스 ''{0}''을(를) 변경할 수 없습니다.</entry>
    <entry key="ParIndexMultiWordError">코드 생성 시 PARFOR 인덱스 변수의 유형을 타깃 하드웨어에서 표현할 수 있어야 합니다. 유형 ''{0}''은 네이티브 표현이 없습니다.</entry>
    <entry key="ParReductionUnsupportedType">변수 ''{0}''은(는) 축소 변수로 사용되지만, 구조체, 클래스 또는 셀 유형이 포함되어 있습니다.</entry>
    <entry key="ParReductionConflictingOps">동일한 축소 변수(''{0}'')에 대해 충돌하는 축소 연산이 발견되었습니다.</entry>
    <entry key="ParReductionConflictingPosn">변수 ''{0}''에 비가환 축소 함수가 있으나,\n이 변수가 모든 축소 대입식에서 동일한 인수 위치에 나오지는 않습니다.</entry>
    <entry key="ParPersistentError">{0}에서 PARFOR 루프 내부에 PERSISTENT 변수를 사용하는 것이 지원되지 않음</entry>
    <entry key="ParCrossLoopDependence">배열 액세스 간에 루프에 예속된 종속성(loop carried dependencies)이 없음을 증명할 수 없습니다.</entry>
    <entry key="ParParforUnclassifiable">parfor에 있는 변수를 분류할 수 없습니다.</entry>
    <entry key="ParForLoopWithInfiniteLoopUnpported">코드 생성 시 내부에 무한 루프가 있는 PARFOR 루프는 지원되지 않습니다.</entry>
    <entry key="ParReductionIllegalOp">변수 ''{0}''에 대해 지원되지 않는 축소 연산입니다. 지원되는 연산은 +,-,*,&amp; 또는 |입니다.</entry>
    <entry key="ParReductionIllegalForm">병렬 루프의 변수 ''{0}''을(를) 분류할 수 없습니다.</entry>
    <entry key="ParReductionIllegalExpr">축소 변수는 스칼라 변수여야 합니다. 구조체 필드 또는 배열 요소는 지원되지 않습니다.</entry>
    <entry key="ParReductionIllegalStmt">''{0}''은(는) 축소 변수입니다. 축소 변수를 포함하는 명령문은 축소 대입식이어야 합니다.</entry>
    <entry key="ParallelForLoopIndexExpressionComplex">병렬 FOR 루프 인덱스 표현식은 복소수 유형이 아니어야 합니다.</entry>
    <entry key="ParallelForLoopRangeMustBeRowVector">parfor 루프 변수 ''{0}''의 범위는 결과적으로 행 벡터여야 합니다.</entry>
    <entry key="ParallelForLoopRangeMustBeNumeric">parfor 루프 변수 ''{0}''의 범위는 결과적으로 숫자형 값으로 구성된 행 벡터여야 합니다.</entry>
    <entry key="ParallelForLoopIndexExpression">병렬 FOR 루프 인덱스 표현식은 형식이 A:B인 경우에만 지원됩니다.</entry>
    <entry key="ParallelForLoopUnrollUnsupported">병렬 FOR 루프에서는 ''{0}'' 함수를 사용할 수 없습니다.</entry>
    <entry key="ParallelForLoopUnrecognizedFlag">인식할 수 없는 플래그 ''{0}''을(를) 병렬 FOR 루프 구문으로 전달했습니다.</entry>
    <entry key="ParallelForLoopWithBreak">병렬 FOR 루프는 BREAK 문 또는 RETURN 문을 통해 종료될 수 없습니다.</entry>
    <entry key="ParallelForLoopDebuggingEnabled">병렬 실행 중 디버깅은 허용되지 않습니다. 병렬 기능을 끄는 중입니다.</entry>
    <entry key="ParallelBodyDisplayRemoved">PARFOR 루프에서 세미콜론이 없는 표현식의 출력은 억제됩니다.</entry>
    <entry key="ParallelNumThreads">최대 스레드 개수는 0, 양의 정수, Inf 중 하나여야 합니다.</entry>
    <entry key="NoCompilerOpenMPSupport">선택한 컴파일러는 OpenMP 라이브러리를 지원하지 않습니다. 이 루프는 병렬화되지 않습니다.</entry>
    <entry key="JITOpenMPSupport">JIT 기술은 OpenMP 라이브러리의 사용을 지원하지 않습니다. 이 루프는 병렬화되지 않습니다.</entry>
    <entry key="ProfilingOpenMPSupport">MEX 프로파일링에서는 OpenMP 라이브러리가 지원되지 않기 때문에 루프가 병렬화되지 않습니다.</entry>
    <entry key="ParameterClassMismatch">파라미터의 유형 ''{0}''이(가) 지정된 유형 ''{1}''과(와) 일치하지 않습니다.</entry>
    <entry key="ParameterCouldNotBeComputed">컴파일타임에 파라미터 {0}의 값을 계산할 수 없습니다.</entry>
    <entry key="ParameterSizeMismatch">\n파라미터가 지정된 크기와 일치하지 않습니다.</entry>
    <entry key="ParameterTypeMismatch">파라미터 ''{0}''에 유형 {1}이(가) 있으며, 이 유형이 지정된 유형 {2}과(와) 일치하지 않습니다.</entry>
    <entry key="ParameterTypeUnsupported">최상위 입력 파라미터 {0}에 지원되지 않는 유형 {1}이(가) 있습니다.</entry>
    <entry key="ParseErrorAssignmentsMayOnlyAppearAtTopLevel">구문 분석 오류: 대입식은 최상위 수준에만 나타날 수 있습니다.</entry>
    <entry key="ParseErrorBuiltinTakesFunctionInputAsOnlyArgument">구문 분석 오류: 이 내장 함수는 함수 입력값을 유일한 인수로 사용합니다.</entry>
    <entry key="ParseErrorEmlConstExpectsExactlyOneInput">구문 분석 오류: EML_CONST에는 정확히 하나의 입력값이 필요합니다.</entry>
    <entry key="ParseErrorFunctionCallExpectedOnRhs">구문 분석 오류: 이 대입식의 우변에 함수 호출이 필요합니다.</entry>
    <entry key="ParseErrorInvalidArgumentToBuiltin">구문 분석 오류: 내장 함수에 대한 인수가 유효하지 않습니다.</entry>
    <entry key="ParseErrorTooFewArgumentsForBuiltin">구문 분석 오류: 내장 함수에 대한 인수가 너무 적습니다.</entry>
    <entry key="ParseErrorFatal">''{0}''의 구문 분석 중 치명적인 오류 발생: {1}</entry>
    <entry key="ParsingErrorMessage">구문 분석 오류: {0}</entry>
    <entry key="ParsingFailed">구문 분석에 실패했습니다.</entry>
    <entry key="PersistentTopLevel">PERSISTENT 선언은 최상위 수준에만 나타날 수 있습니다.</entry>
    <entry key="PossibleError">\n위 오류는 실제 오류 조건이 아니라 제한으로 인해 보고될 수 있습니다. 오류를 감지할 때 복잡한 제어 흐름 때문에 거짓양성 오류가 생성되는 경우가 있습니다.</entry>
    <entry key="PossibleErrorSimulink">\n위 오류는 실제 오류 조건이 아니라 제한으로 인해 보고될 수 있습니다. 오류를 감지할 때 Simulink 입력값과 조정 가능형 Simulink 파라미터 값은 사용되지 않습니다. 복잡한 제어 흐름이 처리되지 못할 때가 있습니다.</entry>
    <entry key="PropertyNotEqualTo">속성 ''{0}''이(가) 대입식의 좌변에서는 ''{1}''이지만 우변에서는 ''{2}''입니다.</entry>
    <entry key="PropertyNotEqualToUnspecified">속성 ''{0}''이(가) 대입식의 좌변에서는 ''{1}''이지만 우변에는 지정되지 않았습니다.</entry>
    <entry key="PropertyUnknown">알 수 없는 속성</entry>
    <entry key="PropertyUnspecifiedNotEqualTo">속성 ''{0}''이(가) 대입식의 좌변에는 지정되지 않았지만 우변에서는 ''{1}''입니다.</entry>
    <entry key="Recursion">재귀적 호출은 허용되지 않습니다. 함수 ''{0}''이(가) 재귀적 호출에 참여했습니다.</entry>
    <entry key="RecursionLimit">컴파일타임 재귀 제한에 도달했습니다.</entry>
    <entry key="RecursionLimitInput">컴파일타임 재귀 제한에 도달했습니다. 함수 ''{0}''의 입력 #{1,number,integer}의 크기 또는 유형은 호출할 때마다 변경될 수 있습니다.</entry>
    <entry key="RecursionLimitConstInput">컴파일타임 재귀 제한에 도달했습니다. 함수 ''{0}''의 입력 #{1,number,integer}의 값은 호출할 때마다 변경될 수 있습니다.</entry>
    <entry key="RuntimeRecursionDisabled"> 런타임 재귀가 비활성화되었습니다. 함수 ''{0}''은(는) 재귀 함수입니다.</entry>
    <entry key="RecursiveFunctionUndefinedOutput">런타임 재귀 호출 전에 모든 출력값을 할당해야 합니다. 여기서 출력값 ''{0}''이(가) 할당되지 않았습니다.</entry>
    <entry key="NoConstantFoldDirectCallExplicit">''{0}''에는 직접적인 상수 폴딩이 명시적으로 금지되므로 이에 대한 호출을 직접적으로 상수 폴딩할 수 없습니다.</entry>
    <entry key="NoConstantFoldDirectCallUninitialized">''{0}''이(가) 출력 ''{1}''에 대해 초기화되지 않은 데이터를 반환하므로 이에 대한 호출을 직접적으로 상수 폴딩할 수 없습니다.</entry>
    <entry key="NoConstantFoldRecursiveCall">함수 ''{1}'' 내부의 런타임 재귀 함수 ''{0}''에 대한 호출을 상수 폴딩할 수 없습니다.</entry>
    <entry key="ReinterpretSizeMismatch">{0,number,integer}비트를 {1,number,integer}비트로 재해석하려고 시도했습니다. 크기를 변경하려면 EML_CAST가 필요합니다.</entry>
    <entry key="ReinterpretUnrecognizedType">EML_REINTERPRET에 인식할 수 없는 유형이 있습니다.</entry>
    <entry key="Relop">이 비교는 지원할 수 있는 비트({1,number,integer})보다 더 많은 비트({0,number,integer})를 사용합니다. 이 제한을 극복하려면 양변을 공통된 숫자형으로 형변환하십시오.</entry>
    <entry key="RequireEmlMessage">이 표현식은 eml_message 객체여야 합니다.</entry>
    <entry key="RequireNumeric">표현식은 숫자형이어야 합니다. {0}인 것으로 확인되었습니다.</entry>
    <entry key="RequireNumericUnknown">표현식은 숫자형이어야 합니다. 유형에 대해 아무것도 확인하지 못했습니다.</entry>
    <entry key="ReservedProperty">속성 이름 ''{0}''은(는) 예약되어 있습니다. 이 속성의 이름을 바꾸십시오.</entry>
    <entry key="ReservedWord">예약어 {0}의 사용이 부적절합니다.</entry>
    <entry key="ResultRange">입력값 {0}이(가) 결과 클래스 {1}의 범위를 초과합니다.</entry>
    <entry key="RoundingModeLocked">연산자에서 반올림 모드를 설정하려고 두 번 시도했습니다.</entry>
    <entry key="RtErrorMxArray">함수 eml_lib_assert, eml_invariant, coder.internal.assert, coder.internal.errorIf, coder.internal.error는 ''{0}'' 인수를 포함하는 런타임 오류 보고를 지원하지 않습니다. 이들 중 하나를 호출하기 전에 모든 인수를 문자형 벡터 또는 내장 숫자형으로 변환하십시오. 또는 외재적으로 ASSERT 또는 ERROR를 호출하십시오.</entry>
    <entry key="SEAStaticReference">코드 생성 시 이 객체의 정적 메서드 및 속성에 대한 액세스는 지원되지 않습니다.</entry>
    <entry key="SysObjSameInstanceRequired">System object 클래스 ''{0}''의 다른 구성입니다.</entry>
    <entry key="SEAUnsupportedForCcalls">System object는 C 호출에서 지원되지 않습니다.</entry>
    <entry key="SEAUnsupportedForCeval">System object는 ''coder.ceval''에서 지원되지 않습니다</entry>
    <entry key="SEAUnsupportedForMATLABCalls">System object는 외재적 호출에서 지원되지 않습니다.</entry>
    <entry key="SEAUnsupportedForMxArrayValues">System object는 mxArray 값에서 지원되지 않습니다.</entry>
    <entry key="SEAUnsupportedForSave">코드 생성 시 저장 명령을 사용하여 System object를 저장하는 것은 지원되지 않습니다.</entry>
    <entry key="SameNameRepeatingInputAndOutput">코드 생성 시 가변 길이 입력값 ''{0}''을(를) 출력값으로 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="SameNameInputAndRepeatingOutput">코드 생성 시 가변 길이 출력값 ''{0}''을(를) 입력값으로 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="SaveSpecialVarName">코드 생성 시 ''save''는 변수 ''{0}''을(를) 저장하는 것을 지원하지 않습니다. 대체 변수 이름을 사용하십시오.</entry>
    <entry key="SaveFileNameInvalidType">''save''에 대한 파일 이름 인수는 문자형 벡터이거나 string형 스칼라여야 합니다.</entry>
    <entry key="SaveNonLiteral">코드 생성 시 ''save''로 전달되는 모든 변수 이름과 옵션은 문자형 벡터 또는 string형 리터럴이어야 합니다. 예를 들어 ''save a.mat b c'' 또는 ''save(파일 이름, ''a'', "b")''을 사용할 수 있습니다.</entry>
    <entry key="SaveRequiresVariableNames">코드 생성 시 ''save''를 호출할 때 저장할 변수를 명시적으로 나열해야 합니다.</entry>
    <entry key="SaveStandaloneIgnored">독립 실행형 코드 생성 시 ''save''는 무시되며, 외재적 호출이 활성화된 MEX 또는 S-Function을 생성할 때만 활성화됩니다.</entry>
    <entry key="SaveUnsupportedOptionStruct">코드 생성 시 ''save''에 대한 ''-struct'' 인수는 지원되지 않습니다.</entry>
    <entry key="SaveUnsupportedOptionRegexp">코드 생성 시 ''save''에 대한 ''-regexp'' 인수는 지원되지 않습니다.</entry>
    <entry key="SaveUnsupportedWildcard">코드 생성 시 ''save''를 호출할 때 와일드카드 ''*''를 사용하는 것은 지원되지 않습니다. 저장할 모든 변수의 이름을 명시적으로 나열하십시오.</entry>
    <entry key="SaveInvalidVariable">변수 ''{0}''을(를) 찾을 수 없습니다.</entry>
    <entry key="SaveIndirectUnsupported">코드 생성 시 함수 핸들을 통한 ''save''의 간접 사용은 지원되지 않습니다. ''save fileName x y -option''을 사용하십시오.</entry>
    <entry key="ShellEscape">셸 이스케이프(!)는 지원되지 않습니다.</entry>
    <entry key="ShiftIndexOutOfBounds">{0,number,integer}비트만큼 시프트하는 것은 허용되지 않습니다. 이 시프트의 유효한 범위는 {1,number,integer}-{2,number,integer}입니다.</entry>
    <entry key="SimulinkStringInBusesUnsupported">MATLAB Function 블록은 내부에 문자열을 포함하는 버스를 지원하지 않습니다.</entry>
    <entry key="SizeArg2">SIZE에 대한 두 번째 입력값은 숫자형이어야 합니다.</entry>
    <entry key="SizeInputNumeric">{0}에 대한 크기 입력값은 숫자형이어야 합니다.</entry>
    <entry key="SizeDimen">차원 인수는 1과 2^31 사이에 있는 양의 정수 스칼라여야 합니다.</entry>
    <entry key="SizeIO">입력값이 2개 이상인 SIZE는 출력값을 1개만 반환합니다.</entry>
    <entry key="SizeMismatch">배열 크기가 호환되지 않습니다({0} 및 {1}).</entry>
    <entry key="SizeMismatchOnField">필드 ''{2}''의 배열 크기가 호환되지 않습니다({0} 및 {1}).</entry>
    <entry key="SizeMismatchOnCell">Arrays in element ''{2}'' have incompatible sizes ({0} and {1}).</entry>
    <entry key="SizeOverflow">\n차원 {0,number,integer}의 고정 크기 {1,number,integer}이(가) 상한 크기 {2,number,integer}을(를) 초과합니다.</entry>
    <entry key="SizesIncompatibleForImplicitExpansion">배열의 크기가 호환되지 않기 때문에(크기 {0} 및 크기 {1}) 이 연산을 수행할 수 없습니다.</entry>
    <entry key="SizesIncompatibleForImplicitExpansionOnDim">\n차원 {0,number,integer}의 크기가 호환되지 않습니다({1,number,integer} 및 {2,number,integer}).</entry>
    <entry key="SizeVectorConstantQualifier">크기 벡터는 상수 표현식이어야 합니다.</entry>
    <entry key="SizeCannotBeScalar">''{0}''에 대한 크기 인수는 최소 2개의 요소를 가져야 합니다.</entry>
    <entry key="SizeVectorSizeLimit">프로그램에서 허용하는 최대 변수 크기를 초과했습니다.</entry>
    <entry key="SliceLeftConstantQualifier">\n왼쪽 슬라이스 인덱스는 상수여야 합니다.</entry>
    <entry key="SliceRightConstantQualifier">\n오른쪽 슬라이스인덱스는 상수여야 합니다.</entry>
    <entry key="StaticDynamicSizeMismatchOnAssignment">차원 {0,number,integer}이(가) 좌변에서는 고정 크기인데 우변에서는 가변 크기이므로({1} 및 {2}), 할당을 성립시킬 수 없습니다.</entry>
    <entry key="StaticDynamicSizeMismatchOnAssignmentOnField">Unable to make this assignment because dimension {0,number,integer} in field ''{1}'' is fixed size on the left side but variable size on the right ({2} and {3}).</entry>
    <entry key="StaticDynamicSizeMismatchOnAssignmentOnCell">Unable to make this assignment because dimension {0,number,integer} in element ''{1}'' is fixed size on the left side but variable size on the right ({2} and {3}).</entry>
    <entry key="Str2funcAnonymousFunctionStringNotSupported">코드 생성 시 str2func는 익명 함수 문자형 벡터를 지원하지 않습니다.</entry>
    <entry key="Str2funcInvalidFunctionName">str2func 입력값 "{0}"이(가) 유효한 함수 이름이 아닙니다.</entry>
    <entry key="StrcmpCellarrayUnsupported">코드 생성 시 varargin 또는 varargout처럼 반복되는 변수를 STRCMP로 전달하는 것은 지원되지 않습니다.</entry>
    <entry key="StrcmpEnumChar">For code generation, {0} does not support enumeration inputs.</entry>
    <entry key="StructArgMax">struct()에 너무 많은 인수가 지정되었습니다. 현재 제한은 {0,number,integer}개의 인수입니다.</entry>
    <entry key="StructField">''{1}'' 유형의 변수에서 필드 ''{0}''을(를) 추출할 수 없습니다. 이 변수는 구조체가 아니기 때문입니다.</entry>
    <entry key="StructFieldAssignOrder">''{0}''에 대한 이 대입식 앞에 ''{1}''에 대한 대입식이 없습니다. 구조체 필드는 모든 제어 흐름 경로에서 동일한 순서로 할당되어야 합니다.</entry>
    <entry key="StructFieldInherited">Simulink 버스 객체의 상속된 데이터형이 지원되지 않으므로 ''{1}''에서 필드 ''{0}''을(를) 추출할 수 없습니다. Simulink 버스에 액세스하려면 모델 탐색기에서 입력 유형을 명시적으로 설정하십시오.</entry>
    <entry key="StructFieldNameLength">필드 이름 ''{0}''이(가) MATLAB의 이름 길이인 {1,number,integer}개 문자를 초과합니다</entry>
    <entry key="StructFieldUndefined">''{0}''은(는) 유효하지 않은 구조체 필드입니다.</entry>
    <entry key="StructFieldUndefinedLocked">''{0}''은(는) 유효하지 않은 구조체 필드입니다. 코드 생성 시 구조체를 읽어오거나 사용한 후 새 필드를 추가하는 것은 지원되지 않습니다.</entry>
    <entry key="StructureExtraneousField">구조체가 일치하지 않습니다. 오른쪽 구조체에 필드 ''{0}''이(가) 추가적으로 있습니다.</entry>
    <entry key="StructureExtraneousFieldOnCell">구조체가 일치하지 않습니다. 오른쪽에 있는 요소 ''{0}''의 구조체에 필드 ''{1}''이(가) 추가적으로 있습니다.</entry>
    <entry key="StructureExtraneousFieldOnField">구조체가 일치하지 않습니다. 오른쪽에 있는 필드 ''{0}''의 구조체에 필드 ''{1}''이(가) 추가적으로 있습니다.</entry>
    <entry key="StructureFieldNameMismatch">구조체가 일치하지 않습니다. 왼쪽에 있는 구조체의 위치 {1,number,integer}에 있는 필드 이름 ''{0}''이(가) 오른쪽에 있는 구조체의 필드 이름 ''{2}''과(와) 일치하지 않습니다.</entry>
    <entry key="StructureFieldNameMismatchOnField">구조체가 일치하지 않습니다. 필드 ''{0}''의 위치 {2,number,integer}에 있는 필드 이름 ''{1}''이(가) 필드 이름 ''{3}''과(와) 일치하지 않습니다.</entry>
    <entry key="StructureFieldNameMismatchOnCell">구조체가 일치하지 않습니다. 요소 ''{0}''의 위치 {2,number,integer}에 있는 필드 이름 ''{1}''이(가) 필드 이름 ''{3}''과(와) 일치하지 않습니다.</entry>
    <entry key="StructureMismatchFieldDiffLhs">왼쪽 구조체의 필드가 오른쪽에 없음: {0}.</entry>
    <entry key="StructureMismatchFieldDiffRhs">오른쪽 구조체의 필드가 외쪽에 없음: {0}.</entry>
    <entry key="StructureMissingField">구조체가 일치하지 않습니다. 오른쪽 구조체에 필드 ''{0}''이(가) 누락되었습니다.</entry>
    <entry key="StructureMissingFieldOnCell">구조체가 일치하지 않습니다. 오른쪽 요소 ''{0}''의 구조체에 ''{1}''이(가) 누락되었습니다.</entry>
    <entry key="StructureMissingFieldOnField">구조체가 일치하지 않습니다. 오른쪽 필드 ''{0}''의 구조체에 ''{1}''이(가) 누락되었습니다.</entry>
    <entry key="StructureSizeMismatch">구조체가 일치하지 않습니다. 왼쪽에 있는 구조체에는 {0,number,integer}개의 필드가 있고, 오른쪽에 있는 구조체에는 {1,number,integer}개의 필드가 있습니다.</entry>
    <entry key="StructureSizeMismatchOnField">구조체가 일치하지 않습니다: 필드 ''{0}''의 구조체에는 {1,number,integer}개의 필드가 있고 오른쪽에 있는 구조체에는 {2,number,integer}개의 필드가 있습니다.</entry>
    <entry key="StructureSizeMismatchOnCell">구조체가 일치하지 않습니다: 요소 ''{0}''의 구조체에는 {1,number,integer}개의 필드가 있고 오른쪽에 있는 구조체에는 {2,number,integer}개의 필드가 있습니다.</entry>
    <entry key="StructureTypeMismatch">구조체 유형이 일치하지 않습니다. ''{0}''이(가) ''{1}''과(와) 일치하지 않습니다.</entry>
    <entry key="SubsAsgnSizeMismatch">배열 크기가 호환되지 않습니다({0} 및 {1}).</entry>
    <entry key="SubscriptAssignmentDissimilar">첨자를 사용한 대입식의 구조체가 서로 다릅니다.</entry>
    <entry key="SubscriptEmpty">빈 행렬에 첨자를 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="SubscriptMissing">행렬 첨자가 누락되었습니다. () 내부에 표현식이 필요합니다.</entry>
    <entry key="SubscriptIntoThisTypeIsNotSupported">코드 생성 시 ''{0}''에 첨자를 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="SubscriptedAssignmentIntoMxArray">코드 생성 시, 첨자를 사용한 대입식을 mxArray에 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="SwitchCaseFiWordLengthSupport">SWITCH 표현식에서 fi 객체의 지원되는 워드 길이는 {0,number,integer}비트 이하입니다.</entry>
    <entry key="SwitchCaseRange">SWITCH case {0}이(가) 클래스 {1}의 범위에 있지 않습니다.</entry>
    <entry key="SwitchCaseRedundant">중복된 SWITCH case입니다. 첫 번째만 실행됩니다.</entry>
    <entry key="SwitchCasesInteger">SWITCH case는 결과적으로 ''int32''로 표현 가능한 정수 값이어야 합니다.</entry>
    <entry key="SwitchExpression">Switch 표현식은 스칼라이거나 문자형 벡터여야 합니다.</entry>
    <entry key="SystemObjectsLibraryNotFound">System object 지원 라이브러리를 찾을 수 없습니다.</entry>
    <entry key="SystemObjectsTranslation">코드를 생성하는 중 오류 발생: {0}</entry>
    <entry key="ThisCast">이 형변환</entry>
    <entry key="TooFewInputArguments">입력 인수가 너무 적습니다. {0}에는 {1,number,integer}개 이상의 입력값이 필요합니다({2,number,integer}개 발견됨).</entry>
    <entry key="TooManyInputArguments">입력 인수가 너무 많습니다. {0}은(는) {1,number,integer}개 이하의 입력값을 받습니다({2,number,integer}개 발견됨).</entry>
    <entry key="TopLevelFunctionCanNotHaveVararg">코드 생성 시 {1}에서 최상위 함수에서 ''{0}''과(와) 같은 반복되는 입력값 또는 출력값은 지원되지 않습니다.</entry>
    <entry key="TopLevelOutputOfUnknownType">최상위 출력 파라미터 {0}에 알 수 없는 유형 또는 불투명(Opaque) 유형이 있습니다.</entry>
    <entry key="TransientEntryPoint">  과도 진입점 함수는 지원되지 않습니다.</entry>
    <entry key="TransientFunctionCall">비과도 함수에서 과도 함수를 호출할 수 없습니다.</entry>
    <entry key="TransposeND">N차원 배열의 전치가 정의되지 않았습니다.</entry>
    <entry key="TypeMismatch">변수 유형이 호환되지 않습니다(유형 ''{0}'' 및 유형 ''{1}'').</entry>
    <entry key="TypeMismatchOnField">In field ''{2}'', variable types are incompatible (type ''{0}'' and type ''{1}'').</entry>
    <entry key="TypeMismatchOnCell">요소 ''{2}''에서 변수 유형이 호환되지 않습니다(유형 ''{0}'' 및 유형 ''{1}'').</entry>
    <entry key="TypeNameMismatch">이 대입식은 좌변에 있는 변수의 사용자 정의 클래스가 우변에 있는 변수의 사용자 정의 클래스와 일치하지 않으므로(''{0}'' 및 ''{1}'') 수행할 수 없습니다.</entry>
    <entry key="UnSupportedEmbeddedComponent">이 System object는 지원되지 않습니다.</entry>
    <entry key="UnauthorizedPCode">P 파일 ''{0}''을(를) 컴파일할 권한이 없습니다. P 파일에 지시문 coder.allowpcode(''plain'')을 포함하십시오. </entry>
    <entry key="UndefinedFunctionOrVariable">{0}은(는) 정의되지 않은 함수 또는 변수입니다.</entry>
    <entry key="UndefinedInternalFunction">{0}은(는) 정의되지 않은 함수 또는 변수입니다.</entry>
    <entry key="UndefinedFunctionOrVariableNargIOInputFcn">{0}은(는) 정의되지 않은 함수 또는 변수입니다.</entry>
    <entry key="UndefinedFunctionOrVariableExtra">''{0}''은(는) 정의되지 않은 함수 또는 변수입니다. 지역 변수에 대한 첫 번째 할당에 따라 클래스가 결정됩니다.</entry>
    <entry key="UndefinedFunctionOrVariablePossibleClass">''{0}''은(는) 클래스이자 네임스페이스입니다. 이 모호성을 해결하려면 클래스 {0}의 속성 또는 메서드 ''{1}''을(를) 참조하는 경우 ''{0}.{1}'' 대신 ''var.{1}''을(를) 사용하십시오.</entry>
    <entry key="UnexpectedOperator">예기치 않은 MATLAB 연산자입니다.</entry>
    <entry key="Unimplemented">{0}: {1,number,integer}: 코드 생성 시 이 구성은 구현되지 않습니다.</entry>
    <entry key="UnknownCallInputClass">이 함수 호출 입력값의 클래스를 확인할 수 없습니다.</entry>
    <entry key="UnknownCallInputSize">이 함수 호출 입력값의 크기를 확인할 수 없습니다.</entry>
    <entry key="UnknownClass">이 표현식의 클래스를 확인할 수 없습니다.</entry>
    <entry key="UnknownError">알 수 없는 오류입니다.</entry>
    <entry key="UnknownInputClass">입력값의 클래스를 확인할 수 없습니다.</entry>
    <entry key="UnknownInputSize">입력값의 크기를 확인할 수 없습니다.</entry>
    <entry key="UnknownInputSizeAndClass">입력값의 크기나 클래스를 확인할 수 없습니다.</entry>
    <entry key="UnknownSize">이 표현식의 크기를 확인할 수 없습니다.</entry>
    <entry key="UnknownSizedSizeVector">차원 수를 확인할 수 없습니다. 주어진 크기 벡터의 길이가 다양하기 때문일 수 있습니다.</entry>
    <entry key="UnknownType">논리형, 문자형, int, fi, single형, double형 중 하나가 필요합니다. 유형에 대해 아무것도 확인하지 못했습니다.</entry>
    <entry key="UnrecognizedEMLPragmaAnnotation">%#codegen 프라그마에 대한 주석이 인식되지 않으므로 무시됩니다. 지원되는 주석은 %#codegen&lt;AUTO&gt; 및 %#codegen&lt;PRE&gt;입니다.</entry>
    <entry key="UnrecognizedOption">''{0}''은(는) 인식할 수 없는 옵션입니다.</entry>
    <entry key="UnrecognizedOptionEnumValue">''{0}''은(는) 인식할 수 없는 열거형 값입니다. 유효한 열거형 옵션은 ''{1}''입니다.</entry>
    <entry key="UnsupportedClass">''{0}''은(는) 형변환할 피연산자로 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureCallThroughNonConstantFunction">코드 생성 시 상수 함수가 아닌 함수를 통한 호출은 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureClass">코드 생성 시 ''Class''는 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureDotNotationOnEmbeddedFi">''embedded.fi''에서 점 표기법은 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureEmptyMatricesInStructures">구조체의 빈 행렬은 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureEmptyStructures">빈 구조체는 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureForLoopsWithNonRealIndices">실수가 아닌 인덱스를 가진 FOR 루프입니다.</entry>
    <entry key="UnsupportedFeatureFunnyLHS">좌변의 형식이 A(X), A(X,Y), A가 아닌 대입식은 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureInt64">숫자형 클래스 ''int64''와 ''uint64''는 Stateflow에서 지원되지 않습니다.</entry>
    <entry key="UnsupportedTypeHalf">Code generation for half-precision is not supported in this workflow. Contact halfprecisionfeedback@groups.mathworks.com and tell us why it is important to you.</entry>
    <entry key="UnsupportedTypeHalfLocationLogging">반정밀도 데이터형은 buildInstrumentedMex에 대해 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureInverseDivision">역나눗셈은 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureInverseMatrixDivision">코드 생성 시 역행렬 나눗셈은 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureMATLABTypeInStructures">코드 생성 시 구조체 내부의 MxArrays는 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureMatrixDeletion">코드 생성 시 행렬 삭제는 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureMatrixDivision">코드 생성 시 행렬 나눗셈은 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureMatrixPower">코드 생성 시 행렬 거듭제곱은 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureMethodDotNotationOnEmbeddedComponent">코드 생성 시 System object의 메서드에 대한 점 표기법은 지원되지 않습니다. 대신 메서드에 대한 첫 번째 인수로 객체를 전달하십시오.</entry>
    <entry key="UnsupportedFeatureMixingOpaqueAndNonOpaqueTypes">불투명(Opaque) 유형과 불투명하지 않은 유형의 혼합은 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureNonScalarFunctionHandles">코드 생성 시 비 스칼라 함수 핸들은 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeaturePower">코드 생성 시 거듭제곱은 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureReferencingAComponentFromNonScalarArray">코드 생성 시 비 스칼라 구조체의 필드에 직접 액세스하는 것은 지원되지 않습니다. 이 제한은 비 스칼라 객체의 속성에도 적용됩니다.</entry>
    <entry key="ReferencingAComponentWhenGrowing">''end+1''로 구조체형 배열을 확장할 때 필드에 직접 액세스하는 것은 코드 생성 시 지원되지 않습니다. 구조체형 배열을 확장시킨 후에 필드를 수정하십시오. 이 제한은 객체의 속성에도 적용됩니다.</entry>
    <entry key="UnsupportedFeatureReferencingAComponentFromScalarBeingGrown">점 표기법을 사용하여 구조체 필드를 정의한 다음 (end+1) 인덱싱을 사용하여 구조체를 확장하는 것은 코드 생성 시 지원되지 않습니다. (end + 1)을 사용하여 구조체 배열을 확장하려면 구조체 생성자를 사용하여 구조체 필드를 정의하십시오.</entry>
    <entry key="UnsupportedFeatureReturningStructuresFromMATLABFunctions">MATLAB 함수에서 구조체를 반환합니다.</entry>
    <entry key="UnsupportedFeatureSEAInValueClass">코드 생성 시 값 클래스의 System object는 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureSetDotNotationOnEmbeddedComponent">System object를 생성한 후에 속성을 설정하는 것은 코드 생성 시 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureSpmd">코드 생성 시 spmd는 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureStructFromClass">코드 생성 시 객체에서 구조체를 생성하는 것은 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureStructValues">코드 생성 시 구조체 값은 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureStructureArray">코드 생성 시 GETFIELDNAME은 구조체형 배열을 지원하지 않습니다.</entry>
    <entry key="UnsupportedFeatureTryCatch">Try 및 catch는 코드 생성 시 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureThrow">코드 생성 시 throw는 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureTypeInStructures">코드 생성 시 구조체에서 ''{0}'' 유형은 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureWritingPropertiesToEmbeddedFimath">코드 생성 시 ''embedded.fimath''에 속성을 쓰는 것은 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureWritingPropertiesToEmbeddedNumerictype">코드 생성 시 ''embedded.numerictype''에 속성을 쓰는 것은 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureWritingPropertiesToFi">코드 생성 시 ''embedded.fi''에 속성을 쓰는 것은 지원되지 않습니다.</entry>
    <entry key="UnsupportedFileExtension">코드 생성 시 MATLAB 파일만 지원됩니다. ''{0}''은(는) ''{1}''에 대해 지원되지 않는 파일 확장자입니다.</entry>
    <entry key="UnsupportedMexCall">함수 호출이 MEX 파일 ''{0}''(으)로 해석되었습니다. 코드 생성 시 MATLAB 파일만 지원됩니다. coder.extrinsic을 사용하여 이 MEX 함수를 외재적 함수로 선언하십시오.</entry>
    <entry key="UnsupportedMultiOutput">여러 출력값은 지원되지 않습니다.</entry>
    <entry key="UnsupportedTerminal">구문 분석 오류 감지됨: 지원되지 않는 터미널 기호입니다.</entry>
    <entry key="UpperBoundDoesNotMatch">차원 {0,number,integer}에 상한 {1,number,integer}이(가) 있으며, 이 상한이 예상 상한 {2,number,integer}과(와) 일치하지 않습니다.</entry>
    <entry key="UseCurlyBracesIndexingForVarargs">이 연산은 셀형 배열을 지원하지 않습니다. 대신 중괄호를 사용하십시오.</entry>
    <entry key="ValuelistUnknownParent">{0}은(는) 이 컨텍스트에서 사용할 수 없습니다.</entry>
    <entry key="NamedArgsUnavailableDueToFunctionDirective">''{0}''은(는) 명명된 인수를 지원하지 않습니다.</entry>
    <entry key="ValueUnavailableDueToFunctionDirective">함수 입력값을 사용하기 전에 ''{0}''을(를) 배치해야 합니다. 변수 ''{1}''이(가) 이 라인 앞에 사용되었습니다.</entry>
    <entry key="ValueUnavailableDueToOptimization">최적화로 인해 값을 사용할 수 없습니다.</entry>
    <entry key="VarargArrayIsEmpty">''{0}''은(는) 0개의 요소를 포함합니다. 요소 {1,number,integer}이(가) 요청됩니다.</entry>
    <entry key="VarargoutCanNotGrowInLoop">반복되는 출력값 변수 ''{0}''은(는) FOR 문 또는 WHILE 문 내에서 증가할 수 없습니다.</entry>
    <entry key="VariableExpected">변수 이름이 필요합니다.</entry>
    <entry key="CellArrayIndexingNotSupported">코드 생성 시 소괄호 ()를 사용한 셀형 배열의 인덱싱은 지원되지 않습니다. 대신 중괄호 '{}'를 사용하십시오.</entry>
    <entry key="VarsizeBlocked">코드 생성 시 가변 크기 배열이 현재 비활성화되어 있습니다.</entry>
    <entry key="VarsizeDimSizeMismatch">\n차원 {0,number,integer}의 크기가 호환되지 않습니다({1,number,integer} 및 {2,number,integer}).</entry>
    <entry key="VarsizeRequiresVariableSizing">To use coder.varsize, enable support for variable-size arrays.</entry>
    <entry key="VarsizeVariableNameExpected">coder.varsize()에 대한 입력값은 변수 이름 또는 ''variable.field1.field2'' 시퀀스여야 합니다.</entry>
    <entry key="VectorNonNumeric">숫자형이 아닌 벡터 표현식은 지원되지 않습니다.</entry>
    <entry key="VectorNotDouble">double형이 아닌 벡터 표현식은 지원되지 않습니다.</entry>
    <entry key="VectorStride">스트라이드가 없는 벡터 표현식은 지원되지 않습니다.</entry>
    <entry key="VisibilityChangeToField">필드 ''{0}''의 가시성이 ''{1}''에서 ''{2}''(으)로 변경되었습니다.</entry>
    <entry key="VisibilityChangeToMethod">메서드 ''{0}''의 가시성이 ''{1}''에서 ''{2}''(으)로 변경되었습니다.</entry>
    <entry key="VoidInExpr">출력값을 반환하지 않는 함수 호출은 표현식에 포함될 수 없습니다.</entry>
    <entry key="WarningLimitReached">경고 제한에 도달했습니다. 추가 경고 메시지가 차단되는 중입니다.</entry>
    <entry key="XCatMixingEnumAndNonEnumTypes">코드 생성 시 horzcat/vertcat에서 열거형 클래스와 비열거형 클래스를 혼합하는 것은 지원되지 않습니다.</entry>
    <entry key="XCatMixingEnumTypes">두 개의 서로 다른 클래스 ''{0}''과(와) ''{1}''의 객체를 결합(Concatenate)할 수 없습니다.</entry>
    <entry key="XRefUnknownOption">인식할 수 없는 옵션이 ''{0}''(으)로 전달되었습니다.</entry>
    <entry key="NestedParallelForLoops">parfor 루프는 중첩할 수 없습니다.</entry>
    <entry key="MissingIsEmptyForHandleObjects">코드 생성 시 핸들 객체는 'if isempty' 코드 블록을 사용하여 영속 변수로 생성되고 저장되어야 합니다.</entry>
    <entry key="Suppressed">오류가 표시되지 않습니다.</entry>
    <entry key="DebugError">내부 디버깅 오류 메시지입니다.</entry>
    <entry key="NullAssignmentOneNonColonOnly">null 대입식에는 콜론이 아닌 인덱스가 하나만 있을 수 있습니다.</entry>
    <entry key="InvalidIntClassName">유효하지 않은 클래스 이름입니다.</entry>
    <entry key="SysObjUnboundedInput">이 System object 메서드는 제한 없는 크기를 가진 입력값을 지원하지 않습니다.</entry>
    <entry key="SysObjUnboundedInputMallocAll">이 System object 메서드는 제한 없는 크기의 입력값을 지원하지 않습니다.\n자동 크기 전파를 허용하려면 'DynamicMemoryAllocation'을 'AllVariableSizeArrays'가 아닌 다른 모드로 구성하십시오.</entry>
    <entry key="SysObjUnboundedOutput">이 System object 메서드는 제한 없는 크기의 출력값을 지원하지 않습니다.</entry>
    <entry key="SysObjUnboundedOutputMallocAll">이 System object 메서드는 제한 없는 크기의 출력값을 지원하지 않습니다.\n자동 크기 전파를 허용하려면 'DynamicMemoryAllocation'을 'AllVariableSizeArrays'가 아닌 다른 모드로 구성하십시오.</entry>
    <entry key="Int64InSizePropagation">조건식의 int64/uint64 유형 때문에 이 블록의 출력값 크기를 확인할 수 없습니다.</entry>
    <entry key="MCOSVarSizeHandleProp">핸들 클래스의 가변 크기 속성은 동적 메모리 할당이 활성화된 경우에만 지원됩니다.</entry>
    <entry key="MCOSVarSizeHandlePropFromJoin">\n이 연산은 ''{1}.{0}''의 크기를 {2}에서 {3}(으)로 변경합니다.</entry>
    <entry key="MCOSVarSizeHandlePropFromJoinOnField">\n연산은 ''{2}''의 핸들 클래스 ''{1}''에 있는 속성 ''{0}''의 크기를 {3}에서 {4}(으)로 변경하고, 속성 크기를 가변으로 바꿉니다.</entry>
    <entry key="MCOSVarSizeHandlePropFromRhs">\n이 연산은 ''{1}.{0}''을(를) {2}(으)로 정의합니다.</entry>
    <entry key="MCOSVarSizeHandlePropDynamicAllocation">\n동적 메모리 할당을 활성화하십시오.</entry>
    <entry key="MCOSUnsupportedOnProp">''{0}''은(는) 클래스 속성에 대해 지원되지 않습니다.</entry>
    <entry key="MCOSCoderVarSizeOnClass">coder.varsize()는 클래스를 지원하지 않습니다.</entry>
    <entry key="MCOSCoderVarSizeOnString">coder.varsize is not supported for string variables.</entry>
    <entry key="MCOSUnsupportedCallToSetupImpl">코드 생성 시 메서드 ''setupImpl''은 지원되지 않습니다. ''setup'' 함수를 대신 사용하십시오.</entry>
    <entry key="MCOSCstrDefineHPropNotDeclaredInThisCls">클래스 ''{0}''의 생성자는 클래스 내에서 선언된 핸들 속성만 정의할 수 있습니다. 그러나 속성 ''{1}''은(는) ''{2}''에서 선언됩니다.</entry>
    <entry key="MCOSSetupImplDefineHPropNotDeclaredInThisCls">클래스 ''{1}''의 메서드 ''{0}''은(는) 클래스 ''{2}''에서 선언된 핸들 속성만 정의할 수 있습니다. 그러나 속성 ''{3}''은(는) ''{4}''에서 선언됩니다.</entry>
    <entry key="MCOSHPropAssignOverlapInCstrAndSetupImpl">코드 생성 시 핸들 속성은 최대 한 번만 할당해야 합니다. 속성 ''{0}''은(는) 잠재적으로 ''{1}''의 생성자에서 할당될 수 있습니다.</entry>
    <entry key="MCOSSetupImplCalledTwice">코드 생성 시 이 메서드는 정확히 한 번만 호출되어야 합니다. 이 메서드에 대한 호출이 2개 이상 있습니다.</entry>
    <entry key="MCOSSetupImplCalledOnlyOnce">코드 생성 시 이 메서드는 정확히 한 번만 호출되어야 합니다. 이 호출은 잠재적으로 0회 실행되거나 2회 이상 실행될 수 있습니다.</entry>
    <entry key="MCOSSetupImplFirstArgThisPtr">'setupImpl'의 첫 번째 인수는 변수 ''{0}''만 될 수 있습니다.</entry>
    <entry key="MCOSCallSetupImplOfBaseCls">클래스 ''{0}''의 메서드 'setupImpl'은 해당 직속 슈퍼클래스에서 선언된 'setupImpl' 메서드만 호출할 수 있습니다.</entry>
    <entry key="MCOSSetPropOnHandle">코드 생성 시 ''{0}''을(를) 사용하여 핸들 속성을 정의하는 것은 지원되지 않습니다.</entry>
    <entry key="InternalSetPropNotProperlyAssigned">coder.internal.setprop를 인스턴스 변수에 할당해야 합니다(예: obj = coder.internal.setprop(obj,...);)</entry>
    <entry key="InternalSetPropObjNotInstanceVariable">coder.internal.setprop에 대한 첫 번째 인수는 인스턴스 변수여야 합니다.</entry>
    <entry key="RecursiveFunctionExtraInput">코드 생성 시 바깥쪽 함수에도 사용되는 변수를 사용하는 중첩 런타임 재귀 함수는 지원되지 않습니다. ''{0}''은(는) 중첩 런타임 재귀 함수 ''{1}''과(와) 바깥쪽 함수에 모두 사용됩니다.</entry>
    <entry key="RecursiveFunctionInput">코드 생성 시 {0}개의 입력값을 가진 런타임 재귀 함수는 지원되지 않습니다. 입력값 ''{1}''은(는) {0}을(를) 포함합니다.</entry>
    <entry key="RecursiveDestructorNotSupported">코드 생성 시 재귀적 delete 메서드는 지원되지 않습니다.</entry>
    <entry key="RecursiveFunctionOutput">코드 생성 시 {0}개의 출력값을 가진 런타임 재귀 함수는 지원되지 않습니다. 출력값 ''{1}''은(는) {0}을(를) 포함합니다.</entry>
    <entry key="CannotConvertToIndexInt">값을 coder.internal.indexInt로 변환할 수 없습니다. 바깥쪽 연산을 수행하려면 모든 피연산자가 coder.internal.indexInt여야 합니다.</entry>
    <entry key="MCOSEscapingHandleObjectInLoopUnsupported">이 핸들 객체를 할당할 수 없습니다. 코드 생성 시 루프 내부에 할당된 핸들 객체는 루프 외부에서 참조할 수 없습니다.</entry>
    <entry key="MCOSEscapingHandleObjectInRecursionUnsupported">핸들 객체가 여러 번 생성되기 때문에 이 핸들 객체를 할당할 수 없습니다. 코드 생성 시 재귀 함수를 한 번만 호출해야 핸들 객체를 만들 수 있습니다.</entry>
    <entry key="MCOSEscapingHandleObjectPersistentUnsupported">핸들 객체가 여러 번 생성되기 때문에 영속 변수에서 참조하는 핸들 객체를 다시 할당할 수 없습니다. 코드 생성 시 영속 변수가 참조하는 핸들 객체가 한 번만 생성되는지 확인하십시오.</entry>
    <entry key="AutoExtrinsicUsage">이 호출(다른 호출도 포함될 수 있음)은 MATLAB 환경 내에서만 지원됩니다. 지원이 제한된 호출은 모두 리포트에서 구별됩니다.</entry>
    <entry key="AutoExtrinsicDisabledUsage">이 호출은 MATLAB 환경 내에서만 지원됩니다.</entry>
    <entry key="CoderReplaceInEntryPoint">'coder.replace'는 진입점 함수에서 지원되지 않습니다.</entry>
    <entry key="CoderReplaceNoVarargoutSupport">출력값 수가 가변적인 함수에서는 'coder.replace'가 지원되지 않습니다.</entry>
    <entry key="CoderReplaceVariableSizedInput">'coder.replace'는 가변 크기 입력값과 호환되지 않습니다. 함수 입력값 #{0,number,integer}은(는) 가변 크기를 가집니다.</entry>
    <entry key="CoderReplaceVariableSizedOutput">'coder.replace'는 가변 크기 출력값과 호환되지 않습니다. 함수 출력값 #{0,number,integer}은(는) 가변 크기를 가집니다.</entry>
    <entry key="CoderReplaceGlobalVar">전역 변수에 액세스하는 함수에는 'coder.replace'가 지원되지 않습니다. 전역 변수를 대체하고 이를 인수로 전달하도록 함수를 업데이트하십시오.</entry>
    <entry key="CoderReplacePersistVar">영속 변수에 액세스하는 함수와 함께 'coder.replace'가 사용되었습니다. 이렇게 사용하면 잘못된 코드가 발생하기 쉬워 향후 릴리스에서 더 이상 지원되지 않을 예정입니다. 영속 변수를 대체하고 이를 인수로 전달하도록 함수를 업데이트하십시오.</entry>
    <entry key="CoderReplaceSyntaxError">'coder.replace'에 대한 인수가 유효하지 않습니다. '-errorifnoreplacement'와 '-warnifnoreplacement'만 지원됩니다.</entry>
    <entry key="CoderReplaceReplacementNotFound">함수 ''{0}''를 대체할 함수를 찾을 수 없습니다.</entry>
    <entry key="MultipleInstancesOfCoderReplace">동일한 함수 안에 ''coder.replace''의 인스턴스가 여러 개 있는 것은 허용되지 않습니다.</entry>
    <entry key="MCOSSimulinkCoderLimitationPointers">영속 변수 ''{0}''에 포인터 유형이 있기 때문에 코드를 생성할 수 없습니다.</entry>
    <entry key="MCOSPersistentPropertyMismatch">영속 변수 ''{2}''은(는) 함수 ''{0}''에 대한 이전 호출에서 유형 ''{3}''이(가) 할당되었으므로 이 변수의 속성 ''{1}''에 유형 ''{4}''의 값을 할당할 수 없습니다.</entry>
    <entry key="MCOSPersistentPropertyValueMismatch">함수 ''{0}''이(가) 여러 번 호출되며, 이러한 호출 중 일부는 영속 변수 ''{2}''의 조정 불가형 속성 ''{1}''에 서로 다른 값을 할당합니다.</entry>
    <entry key="ControlC">사용자가 컴파일을 중단했습니다.</entry>
    <entry key="MCOSMethodAccessListRestricted">''{1}'' 클래스의 메서드 ''{0}''에 액세스할 수 없습니다.</entry>
    <entry key="MCOSPropertyAccessListRestricted">{1}의 속성 {0}에 대한 액세스가 제한되어 있기 때문에 속성을 가져올 수 없습니다.</entry>
    <entry key="CellarrayUsedAtEntryPoint">최상위 함수 출력값으로 사용되는 셀형 배열은 {1}에서 지원되지 않습니다. 출력값 ''{0}''은(는) 셀형 배열입니다.</entry>
    <entry key="CellarrayHCatOnly">코드 생성 시 행 벡터 셀형 배열만 지원됩니다.</entry>
    <entry key="VararginAssignNotSupported">코드 생성 시 ''{0}''(으)로의 할당은 지원되지 않습니다.</entry>
    <entry key="CellSubscriptMustBeScalarOrVector">셀 첨자 인덱스는 스칼라 또는 벡터여야 합니다.</entry>
    <entry key="CellarraysAreNotSupportedHere">셀형 배열은 여기에서 지원되지 않습니다.</entry>
    <entry key="VarargsAreNotSupportedHere">varargin 및 varargout과 같은 반복되는 변수는 여기에서 지원되지 않습니다.</entry>
    <entry key="CellsubMultiIndexNotSupported">셀형 배열로의 다차원 인덱싱은 지원되지 않습니다.</entry>
    <entry key="CellConstructorSizeMismatch">사각형 셀형 배열이 아닙니다. 모든 행의 크기가 일치해야 합니다.</entry>
    <entry key="CellConstructorTooManyElements">요소 개수가 {0, number, integer}을(를) 초과합니다.</entry>
    <entry key="CellIdxHeterogeneousNonConst">코드 생성 시 이종 셀형 배열로의 상수가 아닌 인덱싱은 지원되지 않습니다.</entry>
    <entry key="UnsupportedFeatureNestedFunctions">중첩 함수는 {0}에서 지원되지 않습니다.</entry>
    <entry key="CellSubscriptEmpty">Index is out of bounds because the cell array is empty.</entry>
    <entry key="CStructNameCell">충돌하는 구조체 정보를 가진 셀형 배열에 셀형 배열을 할당하거나 그러한 셀형 배열로부터 셀형 배열을 할당할 수 없습니다.</entry>
    <entry key="CannotConvertToHeteroGeneous">이 셀형 배열은 이종으로 만들 수 없습니다.</entry>
    <entry key="BadMessageIdentifier">''{0}''은(는) 유효한 메시지 ID가 아닙니다.</entry>
    <entry key="OpaqueCastOpaqueArg">''fromOpaqueCast''의 첫 번째 인수는 불투명(Opaque) 유형이어야 합니다.</entry>
    <entry key="ConstantSizeRequiredOnDmension">'':'' 또는 ''end''를 사용하려면 차원 ''{0, number, integer}''이 상수 크기를 가진 셀형 배열이 필요합니다.</entry>
    <entry key="CellTooManyOutputsRequested">너무 많은 출력값이 요청되었습니다. 가장 가능성 있는 원인은 좌변에서 쉼표로 구분된 목록 확장을 감싸는 []가 누락된 것입니다.</entry>
    <entry key="CellLhsValueListEmpty">좌변이 초기화되고 인덱스 범위가 비어 있습니다. 그러나 우변은 하나 이상의 결과를 반환했습니다.</entry>
    <entry key="CellCatNotRectangular">결합(Concatenate)된 행렬의 차원이 일치하지 않습니다.</entry>
    <entry key="CellIndexingNDFewerIndices">코드 생성 시 차원 개수보다 적은 인덱스를 가진 셀형 배열로의 인덱싱은 지원되지 않습니다.</entry>
    <entry key="CellIndexingNonScalar">코드 생성 시 셀형 배열로의 비 스칼라 인덱싱을 이렇게 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="CellIndexingLogical">코드 생성 시 셀형 배열로의 논리형 인덱싱은 지원되지 않습니다.</entry>
    <entry key="NonScalarCellRefIndex">대입식의 왼쪽에서 셀형 배열로의 인덱싱은 정확히 하나의 요소를 추출해야 합니다.</entry>
    <entry key="MxArrayInCellNotSupported">코드 생성 시 셀형 배열 내부의 mxArray는 지원되지 않습니다.</entry>
    <entry key="VarargAssignmentNeedsFixedSizeVector">반복되는 변수 ''{0}''에 할당하려면 우변이 고정 크기의 행 벡터여야 합니다.</entry>
    <entry key="VarargAssignmentToCellFunction">코드 생성 시 "cell" 함수에서 반복되는 변수 ''{0}''을(를) 할당하는 것은 지원되지 않습니다. ''{0}''의 개별 요소를 직접 할당하십시오.</entry>
    <entry key="CellUsageOfUnassignedElement">이 작업은 정의되지 않은 셀형 배열 요소를 사용하려고 합니다. 코드를 생성하려면 모든 셀형 배열 요소를 사용 전에 정의해야 합니다.</entry>
    <entry key="CellUsageOfUnassignedElementWithPath">Elements ''{0}'' not fully defined. For code generation, all cell array must be defined before use.</entry>
    <entry key="CellFunctionNoArgs">셀 함수에 전달되는 입력 인수가 부족합니다.</entry>
    <entry key="CellFunctionSingleArgMistyped">셀 함수에 전달되는 단일 인수는 스칼라, 스칼라로 구성된 벡터, 또는 셀형 배열이어야 합니다.</entry>
    <entry key="CellFunctionMultipleNonScalarInts">여러 개의 비 스칼라 정수 인수가 셀 함수에 전달됨</entry>
    <entry key="InputFollowingLikeIsNotANumericArray">''like'' 뒤에 오는 입력 인수는 숫자형 배열이어야 합니다.</entry>
    <entry key="InputFollowingLikeIsNotALogicalArray">''like'' 뒤에 오는 입력 인수는 논리형 배열이어야 합니다.</entry>
    <entry key="CellEntryPointOutputWithUnassignedElement">진입점 함수가 반환한 셀형 배열의 요소 ''{0}''이(가) 완전히 정의되지 않았습니다. 코드를 생성하려면 모든 셀형 배열 요소를 사용 전에 정의해야 합니다.</entry>
    <entry key="CellRecursiveOutputWithUnassignedElement">런타임 재귀 함수가 반환한 요소 ''{0}''이(가) 완전히 정의되지 않았습니다. 코드를 생성하려면 모든 셀형 배열 요소를 사용 전에 정의해야 합니다.</entry>
    <entry key="CellUseOfElementLockedAsUnassigned">사용 후 셀형 배열 요소를 초기화할 수 없습니다. 코드를 생성하려면 모든 셀형 배열 요소를 사용 전에 정의해야 합니다.</entry>
    <entry key="CellUseOfElementLockedAsUnassignedWithPath">셀형 배열 요소 ''{0}''이(가) 정의 전에 사용되었습니다. 코드를 생성하려면 모든 셀형 배열 요소를 사용 전에 정의해야 합니다.</entry>
    <entry key="CellHomogeneousCellAssignedNonCompatibleHeterogeneous">대입식의 좌변에 있는 동종 셀형 배열을 이종 셀형 배열에 재할당할 수 없습니다.</entry>
    <entry key="CellHeterogeneousCellAssignedNonCompatibleHomogeneous">대입식의 좌변에 있는 이종 셀형 배열을 동종 셀형 배열에 재할당할 수 없습니다.</entry>
    <entry key="OneElementCellArrayExpected">여기에는 요소가 1개인 셀형 배열이 필요합니다.</entry>
    <entry key="StorageClassGlobalVarNotDefined">변수 ''{0}''은(는) 전역 변수가 아닙니다. ''{1}''에 대한 스토리지 클래스를 선언하기 전에 전역 변수로 설정하십시오.</entry>
    <entry key="StorageClassUnsupportedSC">스토리지 클래스 이름 ''{0}''은(는) 지원되지 않습니다.</entry>
    <entry key="StorageClassMultiAssignAttempt">스토리지 클래스를 변수 ''{0}''(으)로 재할당하려고 합니다.</entry>
    <entry key="StorageClassNotSupported">이 컨텍스트에서는 'storageClass' 함수에 대한 호출이 지원되지 않습니다.</entry>
    <entry key="StorageClassConstGlobalNotSupported">'constant' 전역 변수 ''{0}''에 스토리지 클래스를 할당하려고 했습니다. 스토리지 클래스를 'constant' 전역 변수에 할당하는 것은 지원되지 않습니다.</entry>
    <entry key="StorageClassReservedKeyword">변수 ''{0}''의 이름이 표준 라이브러리의 예약된 키워드와 충돌합니다.</entry>
    <entry key="StorageClassWritableGlobalNoDefine">쓰기 가능한 전역 변수 ''{0}''에 'ExportedDefine' 스토리지 클래스를 할당하려고 했습니다. 이 스토리지 클래스를 읽기 전용 전역 변수에 할당하십시오.</entry>
    <entry key="StorageClassMultiWordNoDefine">멀티워드 변수 ''{0}''에 'ExportedDefine' 스토리지 클래스를 할당하려고 했습니다. 멀티워드 변수는 일반적으로 구조체 형태로 표현되므로 'ExportedDefine' 스토리지 클래스에는 적합하지 않습니다.</entry>
    <entry key="StorageClassNonScalarNoDefine">비 스칼라 변수 ''{0}''에 'ExportedDefine' 스토리지 클래스를 할당하려고 했습니다. 이 스토리지 클래스를 실수형 스칼라 변수에 할당하십시오.</entry>
    <entry key="StorageClassDynamicNotSupported">가변 크기 전역 변수 ''{0}''에 스토리지 클래스를 할당하려고 합니다. 고정 크기 변수만 지원됩니다.</entry>
    <entry key="InvalidDataAlignmentValue">정렬 값은 2의 거듭제곱인 양의 정수여야 합니다.</entry>
    <entry key="DataAlignmentVarNotFound">''{0}''은(는) 데이터 정렬에 대해 지원되지 않습니다. 전역 변수 또는 I/O 변수를 사용하십시오.</entry>
    <entry key="DataAlignmentDynamicNotSupported">''{0}'' 가변 크기 변수는 데이터 정렬에 대해 지원되지 않습니다.</entry>
    <entry key="DataAlignmentScalarNotSupported">''{0}'' scalar variable not supported for data alignment.</entry>
    <entry key="DataAlignmentComplexTypeNotSupported">''{0}'' 복소 변수는 데이터 정렬에 대해 지원되지 않습니다.</entry>
    <entry key="DataAlignmentMultiAssignAttempt">데이터 정렬 값이 ''{0}''에 이미 할당되었습니다. 재할당은 지원되지 않습니다.</entry>
    <entry key="ExpectedCellArray">셀형 배열이 필요합니다.</entry>
    <entry key="ExpectedVariable">변수가 필요합니다.</entry>
    <entry key="CellTopLevelOutputNotFullyDefined">최상위 출력 변수 ''{0}''은(는) 완전히 할당되어야 합니다.</entry>
    <entry key="ValueReturnedFromFuncNotFullyDefined">''{0}''에서 반환된 값은 완전히 할당되어야 합니다.</entry>
    <entry key="CellArrayVarSizeIndexingIntoHeterogeneous">인덱스의 크기를 알 수 없고 기본 셀형 배열이 동종이 아닌 경우 인덱싱 표현식에 대한 코드를 생성할 수 없습니다.</entry>
    <entry key="UnsupportedDataTypeConversion">지원되지 않는 데이터형 변환: ''{0}''</entry>
    <entry key="CellTypeMismatchGeneric">왼쪽 유형과 오른쪽 유형이 관련이 없으므로 할당을 수행할 수 없습니다.</entry>
    <entry key="StructArrayViaCellHomogeneous">''{0,number,integer}''번째 인수는 요소 유형이 모두 동일하지는 않은 셀형 배열입니다. 코드 생성 시 셀형 배열을 사용하여 구조체형 배열을 생성하려면 셀형 배열의 요소가 동일한 유형을 가져야 합니다.</entry>
    <entry key="CellConstructedCellNotFullyDefined">생성된 셀형 배열이 완전히 정의되지 않았습니다. 코드를 생성하려면 모든 셀형 배열 요소를 사용 전에 정의해야 합니다.</entry>
    <entry key="CellPassedToFuncNotFullyDefined__generic">Cell array input to function ''{0}'' not fully defined. For code generation, all cell array elements must be defined before use.</entry>
    <entry key="CellPassedToFuncNotFullyDefined__namedCell_unknownVals">함수 ''{1}''(으)로 전달된 셀형 배열 ''{0}''의 요소가 완전히 정의되지 않았습니다. 코드를 생성하려면 모든 셀형 배열 요소를 사용 전에 정의해야 합니다.</entry>
    <entry key="CellPassedToFuncNotFullyDefined__namedCell_knownVals">Elements ''{2}'' of cell array ''{0}'' passed to function ''{1}'' not fully defined. For code generation, all cell array elements must be defined before use.</entry>
    <entry key="CellPassedToFuncNotFullyDefined__returnedCell_knownVals">함수 ''{0}''이(가) 반환한 셀형 배열을 함수 ''{1}''의 입력값으로 사용하기 전에 셀형 배열의 요소 ''{2}''이(가) 완전히 정의되지 않았습니다. 코드를 생성하려면 모든 셀형 배열 요소를 사용 전에 정의해야 합니다.</entry>
    <entry key="CellPassedToFuncNotFullyDefined__returnedCell_unknownVals">함수 ''{0}''이(가) 반환한 셀형 배열을 함수 ''{1}''의 입력값으로 사용하기 전에 셀형 배열이 완전히 정의되지 않았습니다. 코드를 생성하려면 모든 셀형 배열 요소를 사용 전에 정의해야 합니다.</entry>
    <entry key="VarsizeOnInputVar">coder.varsize는 함수 입력 변수 ''{0}''에 대해 지원되지 않습니다. 대신, 호출된 함수에 대한 입력값인 변수와 함께 coder.varsize를 사용하십시오.</entry>
    <entry key="VarsizeOnByRefExtraVar">coder.varsize는 중첩 함수와 그 함수가 포함된 함수 모두에 사용되는 변수에 대해 지원되지 않습니다.</entry>
    <entry key="InfiniteLoop">무한 루프 때문에 함수 ''{0}''이(가) 종료되지 않습니다.</entry>
    <entry key="MCOSTypedPropertyUnsupported">속성 ''{0}''은(는) 해당 값의 클래스를 제한합니다. 코드 생성 시 속성값의 클래스를 제한하는 것은 지원되지 않습니다.</entry>
    <entry key="Db4uNestedFunction">Variable ''{0}'' not defined on all execution paths before it is used in a nested function. For code generation, all variables must be fully defined before use.</entry>
    <entry key="Db4uOverflow">Codegen이 함수 ''{0}''을(를) 분석하는 동안 내부 리소스 제한에 부딪혔습니다. 함수의 입력 변수에서 도달할 수 있는 ''{1}''의 인스턴스가 많습니다.</entry>
    <entry key="RelopOnCellNotSupported">이 연산자는 유형이 'cell'인 입력 인수에 대해 정의되지 않았습니다.</entry>
    <entry key="CatOnCellAndValuelistNotSupported">코드 생성 시 셀형 배열과 쉼표로 구분된 목록의 결합은 지원되지 않습니다.</entry>
    <entry key="CatOnStructValuelistOfCellNotSupported">코드 생성 시 구조체형 배열에서 생성된 셀에 대한 쉼표로 구분된 목록의 결합은 지원되지 않습니다.</entry>
    <entry key="CatOnCellVarargNotSupported">코드 생성 시 varargin 및 varargout과 같은 반복되는 변수의 결합은 지원되지 않습니다. 반복되는 변수를 다른 임시 변수에 복사한 다음 이 임시 변수를 결합에 사용하십시오.</entry>
    <entry key="CEvalOnCellNotSupported">coder.ceval()은 유형 'cell'의 입력값 또는 출력값을 지원하지 않습니다.</entry>
    <entry key="ForeignFcnOnCellNotSupported">이 함수는 유형 'cell'의 입력값 또는 출력값을 지원하지 않습니다.</entry>
    <entry key="ValidatorSizeMismatch">Invalid argument. Input dimension {2} is size {0} but is constrained to size {1} by argument validation.</entry>
    <entry key="CannotValidateMxArray">코드 생성 시 mxArray 객체에 대한 유효성 검사는 지원되지 않습니다.</entry>
    <entry key="TabularSizeValidator">코드 생성 시 table형 객체 또는 timetable형 객체에 대한 크기 유효성 검사는 지원되지 않습니다.</entry>
    <entry key="CincludeUnknownParam">{0}은(는) 인식할 수 없는 파라미터 이름입니다.</entry>
    <entry key="CincludeInvalidInput">유효하지 않은 파라미터 이름-값 쌍입니다.</entry>
    <entry key="BinaryOperationsOnEnumsNotSupported">코드 생성 시 열거형에 대한 이항 연산은 지원되지 않습니다. 이 표현식은 열거형입니다.</entry>
    <entry key="StringsAreNotSupported">{0}에서는 문자열이 지원되지 않습니다.</entry>
    <entry key="StringArraysNotSupported">코드 생성 시 string형 배열은 지원되지 않습니다. 문자형 벡터로 구성된 셀형 배열을 사용하십시오.</entry>
    <entry key="DeferInferenceRequiresNoOutputs">지연 함수는 출력값을 가질 수 없습니다.</entry>
    <entry key="ColonOperatorResultTooLarge">배열이 너무 커서 이 연산을 수행할 수 없습니다. 콜론 연산자를 사용하여 배열을 만들거나 배열에 첨자를 추가하려면 배열의 요소 개수가 intmax보다 작아야 합니다.</entry>
    <entry key="CellsPassedToStructMustBeFullyAssigned">구조체로 전달된 셀형 배열은 완전히 할당되어야 합니다.</entry>
    <entry key="GetMCOSFailure">클래스 ''{0}''을(를) 불러올 수 없습니다.</entry>
    <entry key="UndefinedPersistentVariable">영속 변수 ''{0}''은(는) 사용하기 전에 먼저 할당해야 합니다. 유일한 예외는 할당 전에 수행할 수 있는 ''isempty({1})''를 사용한 검사입니다.</entry>
    <entry key="UnsupportedConversionFromToEnum">''{0}''에서 열거형 ''{1}''(으)로의 변환은 지원하지 않습니다.</entry>
    <entry key="SxfunFirstArgumentExtrinsic">coder.internal.sxfun 첫 번째 인수는 외재적 함수가 아니어야 합니다.</entry>
    <entry key="UnsupportedSparseType">Returning sparse matrices of class ''{0}'' to MATLAB is not supported.</entry>
    <entry key="InputMustBeSparse">Input argument must be sparse.</entry>
    <entry key="SparseNotSupported">''{0}'' does not support sparse matrix inputs.</entry>
    <entry key="ValidateattributesNeedConstAttributes">특성은 상수여야 합니다.</entry>
    <entry key="InvalidParamToCoderInternalReferenceParameter">coder.internal.reference_parameter에는 단일 인수가 전달되어야 하며, 이 인수는 호출하는 함수의 스칼라 입력 및 출력 변수여야 합니다.</entry>
    <entry key="ReferenceParameterCannotBeCell">함수 ''{0}''의 경우 입력값 ''{1}''이(가) 셀형 배열이 아니어야 합니다.</entry>
    <entry key="InvalidCallToRefParamFcn">The function ''{0}'' requires that the variable ''{1}'' be passed to it as both an input and output argument.</entry>
    <entry key="RefereneceParameterEntryPoint">''coder.internal.reference_parameter''를 사용하는 함수는 진입점이 될 수 없습니다. ''{0}''을(를) 호출하는 래퍼 함수를 사용하십시오.</entry>
    <entry key="CallToRefParamFcnNotDirectlyInAssign">coder.internal.reference_parameter를 사용하는 함수는, 대응하는 입력 변수와 출력 변수의 이름과 유형이 동일한 대입식 표현식에서 직접 사용해야 합니다. 호출 위치 이후 출력 변수 유형이 변경되지 않도록 합니다.</entry>
    <entry key="ReferenceParameterInputAndOutputTypesDisagree">coder.internal.reference_parameter의 경우 변수 ''{0}''의 입력 유형과 출력 유형이 동일해야 합니다.</entry>
    <entry key="CoderVarsizeCannotChangeBlockInputVar">coder.varsize는 블록 입력값 ''{0}''의 크기를 변경할 수 없습니다. 블록 구성 대화 상자를 사용하여 입력값 크기를 수정하십시오.</entry>
    <entry key="CoderVarsizeCannotChangeBlockOutputVar">coder.varsize는 블록 출력값 ''{0}''의 크기를 변경할 수 없습니다. 블록 구성 대화 상자를 사용하여 출력값 크기를 수정하십시오.</entry>
    <entry key="CoderVarsizeCannotChangeEntryPointInputVar">coder.varsize는 진입점 입력값 ''{0}''의 크기를 변경할 수 없습니다. coder.typeof 또는 Coder 앱을 사용하여 입력값의 크기를 수정하십시오.</entry>
    <entry key="FunctionArgumentValidationAttributeNotSupported">코드 생성 시 인수 블록 특성 ''{0}''은(는) 지원되지 않습니다.</entry>
    <entry key="FunctionArgumentValidationRepeatingEntryPointNotSupported">코드 생성 시, 진입점 함수의 varargin(Input 블록의 경우) 및 varargout(Output 블록의 경우) 이외의 인수에 대해서는 반복되는 인수 블록이 지원되지 않습니다.</entry>
    <entry key="FunctionArgumentValidationMultipleRepeatingInputs">코드 생성 시 함수에서 2개 이상의 반복되는 입력 인수는 지원되지 않습니다.</entry>
    <entry key="FunctionArgumentValidationRepeatingTildeNotSupported">코드 생성 시, 무시된 반복되는 인수는 지원되지 않습니다.</entry>
    <entry key="FunctionArgumentValidationNamedEntryPoint">코드 생성 시 진입점 함수의 이름-값 인수에 대한 함수 인수 유효성 검사는 지원되지 않습니다.</entry>
    <entry key="FunctionArgumentValidationRepeatingValidatorsNotSupported">코드 생성 시 ''{0}''과(와) 같은 반복되는 입력값/출력값에 대한 인수 유효성 검사는 지원되지 않습니다. 클래스 유효성 검사, 크기 유효성 검사, 유효성 검사 함수를 모두 제거하십시오.</entry>
    <entry key="FunctionArgumentValidationNotEnoughInputArguments">유효하지 않은 인수 목록입니다. 함수에 {0,number,integer}개의 입력값이 더 필요합니다.</entry>
    <entry key="FunctionArgumentValidationNamedMissingInput">''{1}''에 대한 이름-값 인수 ''{0}''이(가) 이 함수에 대한 입력값으로 제공되지 않았습니다.</entry>
    <entry key="FunctionArgumentValidationNamedVariableLHS">코드 생성 시, 명명된 필드를 포함하는 인수에 할당하는 것은 지원되지 않습니다. ''{0}''의 개별 필드를 이름으로 할당하십시오.</entry>
    <entry key="FunctionArgumentValidationNamedVariableRHSLoop">코드 생성 시, FOR 루프 또는 WHILE 루프 안에 중첩된 명명된 필드를 포함하는 인수에 액세스하는 것은 지원되지 않습니다. ''coder.unroll''을 사용하여 루프를 풀거나 ''{0}''의 개별 필드에 이름으로 액세스하거나 ''{0}''을(를) 지역 변수에 복사하고 지역 변수를 대신 사용하십시오.</entry>
    <entry key="FunctionArgumentValidationNamedVariableNestedAnon">코드 생성 시 중첩 함수 또는 익명 함수의 명명된 필드를 포함하는 인수를 참조하는 것은 지원되지 않습니다. ''{0}''의 개별 필드를 사용하거나, ''{0}''을(를) 중첩/익명 함수의 입력값으로 전달하십시오.</entry>
    <entry key="FunctionArgumentValidationNamedInvalid">''{0}''은(는) 유효하지 않은 인수 이름입니다. 유효한 이름은 {1}입니다.</entry>
    <entry key="FunctionArgumentValidationNamedAmbiguous">모호한 인수 이름 ''{0}''이(가) 여러 개와 일치할 수 있음: {1}.</entry>
    <entry key="FunctionArgumentValidationNamedNonConst">이 인수는 상수가 아니므로 코드 생성 중 ''{0}'' 내부의 이름-값 인수와 일치하지 않습니다. 코드 생성 중에 호출 위치에서 전달된 이름을 알 수 없는 경우 코드 생성에 실패하거나 MATLAB과 일치하지 않는 결과를 생성할 수 있습니다.</entry>
    <entry key="FunctionArgumentValidationNamedUnknownIfRow">이 인수가 행 벡터인지 여부는 런타임에 결정되므로 코드 생성 중 ''{0}'' 내부의 이름-값 인수와 일치하지 않습니다. 코드 생성 중에 호출 위치에서 전달된 이름을 알 수 없는 경우 코드 생성에 실패하거나 MATLAB과 일치하지 않는 결과를 생성할 수 있습니다.</entry>
    <entry key="FunctionArgumentValidationNamedInvalidBuiltin">명명된 필드를 포함하는 인수에 ''{0}''을(를) 적용하는 것은 코드 생성 시 지원되지 않습니다.</entry>
    <entry key="FunctionArgumentValidationNamedClassNotFound">''{0}'' 클래스를 찾을 수 없습니다.</entry>
    <entry key="ExistVariableLoop">코드 생성 시 for 루프, while 루프, 중첩 함수, 익명 함수 내부의 변수 존재 여부에 대한 검사는 지원되지 않습니다.</entry>
    <entry key="ExistNoMode">코드 생성 시 exist를 사용하려면 검색 유형을 두 번째 인수로 제공하십시오.</entry>
    <entry key="ExistBuiltinMode">코드 생성 시 'builtin'을 검색 유형으로 사용하여 exist를 호출하는 것은 지원되지 않습니다.</entry>
    <entry key="ExistClassMode">코드 생성 시 'class'를 검색 유형으로 사용하여 exist를 호출하는 것은 지원되지 않습니다.</entry>
    <entry key="ExistDirMode">코드 생성 시 'dir'를 검색 유형으로 사용하여 exist를 호출하는 것은 지원되지 않습니다. isfolder를 사용해 보십시오.</entry>
    <entry key="ExistFileMode">코드 생성 시 'file'을 검색 유형으로 사용하여 exist를 호출하는 것은 지원되지 않습니다. isfile을 사용해 보십시오.</entry>
    <entry key="ExistVariableNotPatternMatched">코드 생성 시 'var'을 검색 유형으로 사용해서 exist를 호출하는 경우, 리터럴 인수만 전달할 수 있습니다. 또한 이 검색 유형의 경우, 함수 핸들을 통해 exist를 호출하는 것은 코드 생성 시 지원되지 않습니다.</entry>
    <entry key="ExistVariableSometimesUndefined">변수 ''{0}''의 존재 여부가 런타임 입력에 좌우됩니다. exist 함수를 호출하기 전에 먼저 모든 실행 경로에 ''{0}''을(를) 정의하십시오. 또는 exist 함수를 호출하기 전에 어떤 실행 경로에도 ''{0}''이(가) 정의되어 있지 않도록 하십시오.</entry>
    <entry key="ExistVarargout">코드 생성 시 ''{0}'' 존재 여부에 대한 검사는 지원되지 않습니다.</entry>
    <entry key="ErrorThrownFromDestructorWithLangTargetCpp">클래스 소멸자를 실행하는 중 다음 오류가 발생함:\n''{0}''(line {1,number,integer})을(를) 사용하는 중 오류 발생\n{2}</entry>
    <entry key="OutOfMemoryInFcn">내부 오류: ''{0}''을(를) 컴파일하는 동안 메모리 부족 문제가 발생했습니다.</entry>
    <entry key="OutOfMemory">내부 오류: 메모리가 부족합니다.</entry>
    <entry key="McosClassExpected">입력값은 MATLAB 객체여야 합니다.</entry>
    <entry key="IsMatlabThreadDeprecated">함수 coder.ismatlabthread는 향후 릴리스에서 제거될 예정입니다.</entry>
    <entry key="MissingInputVariable">입력 인수가 부족합니다. 입력 ''{0}''이(가) 이 함수 또는 메서드에 제공되지 않았습니다.</entry>
    <entry key="EmptyClassName">The input class name cannot be empty.</entry>
    <entry key="BoundedArrayUnimplementedOperation">This operation is not implemented on coder.internal.BoundedArray.</entry>
    <entry key="BoundedArrayInvalidSizeVector">유효하지 않은 크기 벡터입니다.</entry>
    <entry key="BoundedArraySizeNotBounded">데이터 크기가 UpperBounds로 제한되어 있지 않습니다.</entry>
    <entry key="BoundedArrayOutOfBoundsIndex">인덱스 표현식이 범위를 벗어났습니다. 차원 {1,number,integer}을(를) 따라 요소 {0,number,integer}에 액세스하려고 시도했습니다. 해당 차원의 최댓값은 {2,number,integer}입니다.</entry>
    <entry key="BoundedArrayCatIncompatibleDimensions">결합하려는 배열의 차원이 일치하지 않습니다.</entry>
    <entry key="BoundedArrayCatBoundsIncompatibleDimensions">호환되지 않는 유계 배열을 결합할 수 없습니다. 코드를 생성하려면 결합되지 않는 배열 차원의 상한이 동일해야 합니다.</entry>
    <entry key="InputMustBeConst">''{1}''에 대한 입력값 {0,number,integer}은(는) 상수여야 합니다.</entry>
    <entry key="HandleClassExpected">''{1}''에 대한 입력값 {0,number,integer}은(는) 핸들 객체여야 합니다.</entry>
    <entry key="MatlabInternalFeatureReadOnly">코드 생성 시, matlab.internal.feature를 사용할 때 하나의 입력값만 사용할 수 있습니다.</entry>
    <entry key="CannotComputeSizeOfVarargout">코드 생성 시 varargout의 size, numel 또는 length를 계산하는 것은 지원되지 않습니다. nargout을 대신 사용하십시오.</entry>
    <entry key="SubscriptedAssignmentToThisClassNotAllowedInParallelLoop">코드 생성 시 병렬 for 루프 내에서 ''{0}'' 유형의 공유 변수에 첨자를 사용하여 대입하는 것은 지원되지 않습니다.</entry>
    <entry key="MatrixDeletionNotSupportedInParallelLoop">병렬 for 루프 내에서 공유 변수의 요소를 제거하는 것은 지원되지 않습니다.</entry>
    <entry key="Empty"/>
    <entry key="Explicit">{0}</entry>
    <entry key="LineSeparator">\n</entry>
    <entry key="EmbeddedComponentPropagationError">{0}</entry>
    <entry key="GenericForAllErrors">{0}</entry>
    <entry key="MatlabInternalFeatureNotFound">Unknown foundation feature ''{0}''.</entry>
    <entry key="PreferStrongerSpecialization">Internal Error: Prefer stronger specialization</entry>
  </message>
</rsccat>
