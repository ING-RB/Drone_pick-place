<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ko_KR" product="Coder" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="MEXReportName">코드 생성 리포트 생성</entry>
    <entry key="MEXReportToolTip">생성 코드를 HTML 리포트에 문서화합니다.</entry>
    <entry key="MEXLaunchReportName">자동으로 리포트 시작</entry>
    <entry key="MEXLaunchReportToolTip">코드 생성 완료 후 자동으로 HTML 리포트를 엽니다.</entry>
    <entry key="MEXDebugBuildName">디버그 빌드 활성화</entry>
    <entry key="MEXDebugBuildToolTip">생성 코드를 디버그 모드로 컴파일합니다.</entry>
    <entry key="MEXEchoName">세미콜론이 없는 표현식 에코하기</entry>
    <entry key="MEXEchoToolTip">세미콜론이 없는 표현식을 에코합니다.</entry>
    <entry key="MEXBuildProName">코드 생성 옵션</entry>
    <entry key="MEXPageName">자동 C-MEX 생성</entry>
    <entry key="RTWAdvancedTabName">고급</entry>
    <entry key="CompilerOptionsTabName">MEX 구성</entry>
    <entry key="inlineThresholdName">인라인 임계값:</entry>
    <entry key="inlineThresholdToolTip">인라인 처리될 함수의 최대 크기를 지정합니다</entry>
    <entry key="inlineThresholdMaxName">인라인 임계값 최댓값:</entry>
    <entry key="inlineThresholdMaxToolTip">인라인 처리 후 함수의 최대 크기를 지정합니다</entry>
    <entry key="inlineStackLimitName">인라인 스택 제한:</entry>
    <entry key="inlineStackLimitToolTip">인라인 처리된 함수의 스택 크기 제한을 지정합니다</entry>
    <entry key="stackUsageMaxName">스택 사용량 최댓값:</entry>
    <entry key="stackUsageMaxToolTip">함수당 최대 스택 사용량을 지정합니다</entry>
    <entry key="constFoldTimeoutName">상수 폴딩 제한 시간:</entry>
    <entry key="constFoldTimeoutToolTip">constant folder(상수 폴딩 수행)에 의해 실행되는 명령어의 최대 개수를 지정합니다</entry>
    <entry key="inlineName">함수 인라인 처리 제어</entry>
    <entry key="miscName">기타 변환 제어</entry>
    <entry key="generalName">일반</entry>
    <entry key="SatOnIntOverflowName">정수 오버플로 시 포화</entry>
    <entry key="SatOnIntOverflowToolTip">생성 코드에 검사를 추가하여 정수 오버플로 또는 언더플로를 감지합니다.</entry>
    <entry key="VariableSizingName">가변 크기 조정 활성화</entry>
    <entry key="VariableSizingToolTip">가변 크기 배열에 대한 지원을 활성화합니다</entry>
    <entry key="DynamicMemoryName">동적 메모리 할당</entry>
    <entry key="DynamicMemoryTooltip">동적 메모리 할당을 사용할 시기를 선택합니다</entry>
    <entry key="DynamicMemoryOff">안 함</entry>
    <entry key="DynamicMemoryVariableSizeArrays">가변 크기 배열의 경우</entry>
    <entry key="DynamicMemoryUnknownUpperBoundsOnly">상한을 알 수 없는 가변 크기 배열의 경우만</entry>
    <entry key="DynamicMemoryAllVariableSizeArrays">모든 가변 크기 배열의 경우</entry>
    <entry key="DynamicMemoryThresholdName">동적 메모리 할당 임계값(단위: 바이트)</entry>
    <entry key="DynamicMemoryThresholdTooltip">데이터가 여기에 지정된 바이트 수를 초과할 경우 동적 메모리 할당을 사용합니다</entry>
    <entry key="RuntimeCheckName">런타임 검사</entry>
    <entry key="RuntimeCheckIntegrityName">메모리 무결성 보장</entry>
    <entry key="RuntimeCheckIntegrityToolTip">생성 코드의 메모리 무결성 위반을 감지하고 진단 결과를 제공하면서 실행을 중지합니다.\n이러한 검사를 하지 않으면 위반으로 인해 예기치 않은 동작이 발생하게 됩니다. 메모리 무결성 문제의 가장 흔한 원인은\n범위를 벗어난 배열에 액세스하는 것입니다.</entry>
    <entry key="RuntimeCheckExtrinsicName">외재적 호출</entry>
    <entry key="RuntimeCheckExtrinsicToolTip">MATLAB에 대한 외재적 호출을 허용합니다. 비활성화된 경우 외재적 호출을 제거하려고 시도합니다.</entry>
    <entry key="RuntimeCheckCtrlcName">반응 속도 보장</entry>
    <entry key="RuntimeCheckCtrlcToolTip">Ctrl+C 중단을 주기적으로 검사하고 그래픽스를 새로 고칩니다. 이러한 검사를 하지 않을 경우\nMATLAB을 종료하는 것만이 장시간 진행 중인 실행을 종료하는 유일한 방법일 수 있습니다.</entry>
    <entry key="RTWGeneralTabName">일반</entry>
    <entry key="RTWDescriptionName">설명:</entry>
    <entry key="RTWTargetLangName">언어:</entry>
    <entry key="RTWTargetLangToolTip">코드 생성 언어 선택</entry>
    <entry key="RTWCompOptsName">컴파일러 최적화 수준:</entry>
    <entry key="RTWCompOptsToolTip">컴파일러 최적화 수준을 선택합니다</entry>
    <entry key="RTWCompOptsLevelOff">최적화 끄기(더 빠른 빌드)</entry>
    <entry key="RTWCompOptsLevelOn">최적화 켜기(더 빠른 실행)</entry>
    <entry key="RTWCompOptsLevelCustom">사용자 지정</entry>
    <entry key="RTWCustomCompOptsName">사용자 지정 컴파일러 최적화 플래그:</entry>
    <entry key="RTWCustomCompOptsToolTip">컴파일러 최적화 플래그(예: -O2)를 지정합니다</entry>
    <entry key="RTWMakeCommName">Make 명령:</entry>
    <entry key="RTWMakeCommToolTip">선택적 인수를 갖는 Make 명령입니다.</entry>
    <entry key="RTWGenMakefileName">makefile 생성</entry>
    <entry key="RTWGenMakefileToolTip">생성 코드를 컴파일하기 위해 makefile의 생성을 활성화합니다.</entry>
    <entry key="RTWTempMakeName">템플릿 makefile:</entry>
    <entry key="RTWTempMakeToolTip">코드 생성 타깃을 빌드하기 위한 현재 템플릿 makefile입니다.</entry>
    <entry key="RTWBuildToolConfigName">구성:</entry>
    <entry key="RTWBuildToolConfigToolTip">생성 코드의 빌드에 사용할 구성을 선택합니다</entry>
    <entry key="RTWGenerateMainName">메인 생성</entry>
    <entry key="RTWGenerateMainToolTip">선택하면 "main" 함수가 만들어집니다.\n선택하지 않으면 사용자가 "main" 함수를 제공해야 합니다</entry>
    <entry key="RTWBuildToolCustomizeName">사용자 지정...</entry>
    <entry key="RTWBuildToolCustomizeToolTip">XMakefile 사용자 구성 대화 상자를 시작합니다</entry>
    <entry key="RTWGenCodeName">코드만 생성</entry>
    <entry key="RTWGenCodeToolTip">코드를 생성할 때 makefile을 실행하지 않습니다.</entry>
    <entry key="RTWCodeGenOptionsName">코드 생성 옵션</entry>
    <entry key="RTWFilePartitionName">생성 파일 분할 방법:</entry>
    <entry key="RTWFilePartitionToolTip">생성 파일을 분할하는 방법을 선택합니다</entry>
    <entry key="RTWFilePartitionMapMFileToCFile">각 MATLAB 파일에 대해 하나의 파일 생성</entry>
    <entry key="RTWFilePartitionSingleFile">모든 함수를 하나의 파일로 생성</entry>
    <entry key="RTWDebugTabName">디버그</entry>
    <entry key="RTWVerboseName">세부 정보 표시 빌드</entry>
    <entry key="RTWVerboseToolTip">코드 생성 단계와 컴파일러 출력값을 표시합니다.</entry>
    <entry key="RTWTargetSelName">타깃 선택</entry>
    <entry key="RTWBuildProName">빌드 프로세스</entry>
    <entry key="RTWMakefileConfigName">Makefile 구성</entry>
    <entry key="RTWRtwDebugName">빌드 프로세스</entry>
    <entry key="RTWReportTabName">리포트</entry>
    <entry key="RTWCommentTabName">주석</entry>
    <entry key="genCommentGroupName">전체 제어</entry>
    <entry key="genCommentName">주석 포함</entry>
    <entry key="genCommentToolTip">생성 코드에 주석을 포함합니다.</entry>
    <entry key="autoGenName">자동 생성되는 주석</entry>
    <entry key="MATLABSourceCommentsName">MATLAB 소스 코드를 주석으로 삽입</entry>
    <entry key="MATLABSourceCommentLineNumbersName">MATLAB 소스 코드를 주석으로 삽입</entry>
    <entry key="MATLABSourceCommentsToolTip">MATLAB 소스 코드를 생성 코드에 주석으로 삽입합니다.</entry>
    <entry key="customComments">사용자 지정 주석</entry>
    <entry key="MATLABFcnDescName">MATLAB 사용자 주석</entry>
    <entry key="MATLABFcnDescToolTip">MATLAB 함수 설명(도움말 텍스트)을\n함수 배너의 일부로 생성 코드에 삽입합니다</entry>
    <entry key="RTWReportGenerateReportName">코드 생성 리포트 만들기</entry>
    <entry key="RTWReportGenerateReportToolTip">생성된 C 코드를 코드 생성 리포트에 문서화합니다.</entry>
    <entry key="RTWReportLaunchReportName">자동으로 리포트 시작</entry>
    <entry key="RTWReportLaunchReportToolTip">빌드 프로세스 완료 후 자동으로 코드 생성 리포트를 엽니다.</entry>
    <entry key="srcCodeName">소스 파일:</entry>
    <entry key="srcCodeToolTip">생성된 &lt;project&gt;.c 소스 파일의 맨 위에 표시할 코드를 입력합니다.</entry>
    <entry key="headerCodeName">헤더 파일:</entry>
    <entry key="headerCodeToolTip">생성된 &lt;project&gt;.h 헤더 파일의 맨 위에 표시할 코드를 입력합니다.</entry>
    <entry key="includePathName">include 디렉터리:</entry>
    <entry key="includePathToolTip">생성 코드를 컴파일할 때 include 경로에 추가할 include 디렉터리\n목록을 공백으로 구분하여 입력합니다.</entry>
    <entry key="sourceFileName">소스 파일:</entry>
    <entry key="sourceFileToolTip">컴파일하고 생성 코드와 연결할 소스 파일의 목록을 공백으로\n구분하여 입력합니다.</entry>
    <entry key="libraryName">라이브러리:</entry>
    <entry key="libraryToolTip">생성 코드와 연결할 정적 라이브러리 파일의 목록을 공백으로\n구분하여 입력합니다.</entry>
    <entry key="initializerName">초기화 함수:</entry>
    <entry key="initializerToolTip">생성된 프로젝트 초기화 함수에 표시할 코드를 입력합니다.</entry>
    <entry key="terminatorName">종료 함수:</entry>
    <entry key="terminatorToolTip">생성된 프로젝트 종료 함수에 표시할 코드를 입력합니다.</entry>
    <entry key="customCodeListToolTip">오른쪽 패널에서 편집할 항목 중 하나를 선택합니다.</entry>
    <entry key="customCodeListSourceFile">소스 파일</entry>
    <entry key="customCodeListHeaderFile">헤더 파일</entry>
    <entry key="customCodeListInitializeFunction">초기화 함수</entry>
    <entry key="customCodeListTerminateFunction">종료 함수</entry>
    <entry key="customIncludeListIncludeDirectories">include 디렉터리</entry>
    <entry key="customIncludeListSourceFiles">소스 파일</entry>
    <entry key="customIncludeListLibraries">라이브러리</entry>
    <entry key="customCodeName">생성된 다음 파일에 사용자 지정 C 코드 포함:</entry>
    <entry key="customIncludeName">추가 목록 포함:</entry>
    <entry key="customCodeTabName">사용자 지정 코드</entry>
    <entry key="sfsGroupName">식별자 형식 제어</entry>
    <entry key="sfsglobalvarName">전역 변수:</entry>
    <entry key="sfsglobalvarToolTip">전역 변수에 대한 기호 형식 규칙입니다. 규칙은 유효한 C 식별자 문자와\n다음 매크로를 포함할 수 있습니다:\n$M - 변형\n$R - 루트 프로젝트 이름\n$N - 식별할 객체 이름</entry>
    <entry key="sfsLocalVarName">로컬 임시 변수:</entry>
    <entry key="sfsLocalVarToolTip">로컬 임시 변수에 대한 기호 형식 규칙입니다. 규칙은 유효한 C 식별자 문자와\n다음 매크로를 포함할 수 있습니다:\n$M - 변형\n$R - 루트 프로젝트 이름\n$N - 식별할 객체 이름</entry>
    <entry key="sfsConstMacroName">상수 매크로:</entry>
    <entry key="sfsConstMacroToolTip">상수 매크로에 대한 기호 형식 규칙입니다. 규칙은 유효한 C 식별자 문자와\n다음 매크로를 포함할 수 있습니다:\n$M - 변형\n$R - 루트 프로젝트 이름\n$N - 식별할 객체 이름</entry>
    <entry key="sfsGlobalTypeName">전역 유형:</entry>
    <entry key="sfsGlobalTypeToolTip">전역 유형에 대한 기호 형식 규칙입니다. 규칙은 유효한 C 식별자 문자와\n다음 매크로를 포함할 수 있습니다:\n$M - 변형\n$R - 루트 프로젝트 이름\n$N - 식별할 객체 이름</entry>
    <entry key="sfsGlobalFieldName">전역 유형의 필드 이름:</entry>
    <entry key="sfsGlobalFieldToolTip">전역 유형의 필드 이름에 대한 기호 형식 규칙입니다. 규칙은 유효한 C 식별자 문자와\n다음 매크로를 포함할 수 있습니다:\n$M - 변형\n$R - 루트 프로젝트 이름\n$N - 식별할 객체 이름</entry>
    <entry key="sfsLocalFunctionName">로컬 함수:</entry>
    <entry key="sfsLocalFunctionToolTip">로컬 함수에 대한 기호 형식 규칙입니다. 규칙은 유효한 C 식별자 문자와\n다음 매크로를 포함할 수 있습니다:\n$M - 변형\n$R - 루트 프로젝트 이름\n$N - 식별할 객체 이름</entry>
    <entry key="sfsEMXArrayName">EMX 배열:</entry>
    <entry key="sfsEMXArrayToolTip">EMX 배열에 대한 기호 형식 규칙입니다. 규칙은 유효한 C 식별자 문자와\n다음 매크로를 포함할 수 있습니다:\n$M - 변형\n$R - 루트 프로젝트 이름\n$N - 식별할 객체 이름</entry>
    <entry key="maxIdName">최대 식별자 길이:</entry>
    <entry key="maxIdToolTip">변수, typedef 및 함수 이름에 대한 최대 식별자 길이.</entry>
    <entry key="reservedName">예약된 이름:</entry>
    <entry key="reservedToolTip">생성 코드에서 제외할 예약된 이름의 목록을 공백으로 구분하여\n입력합니다.</entry>
    <entry key="autoIdName">자동 생성되는 식별자의 명명 규칙</entry>
    <entry key="reservedNames">예약된 이름</entry>
    <entry key="symbols">기호</entry>
    <entry key="hardwarePageName">하드웨어 구현</entry>
    <entry key="hardwareGroup1Name">임베디드 하드웨어(시뮬레이션 및 코드 생성)</entry>
    <entry key="hardwareGroup2Name">에뮬레이션 하드웨어(코드 생성만)</entry>
    <entry key="hardwareGroup3Name">최대 아토믹 크기</entry>
    <entry key="hardwareWProdVendorLblName">장치 공급업체:</entry>
    <entry key="hardwareWProdTypeLblName">장치 유형:</entry>
    <entry key="ProdHWToolTip">사용 중인 마이크로프로세서에 대한 C 언어 제약 조건을 지정하려면 미리 정의된 하드웨어 장치를 선택십시오. \n사용 중인 마이크로프로세서가 표시되지 않으면 "{0}"을(를) 선택하십시오. \n 제약 조건이 없는 경우 "{1}"을(를) 선택하십시오.</entry>
    <entry key="TargetHWToolTip">사용 중인 마이크로프로세서에 대한 C 언어 제약 조건을 지정하려면 미리 정의된 하드웨어 장치를 선택십시오. \n사용 중인 마이크로프로세서가 표시되지 않으면 "{0}"을(를) 선택하십시오. \n 현재 MATLAB 호스트 컴퓨터를 타깃으로 지정하려면 \n"{1}"을(를) 선택하십시오.</entry>
    <entry key="hardwareNumOfBitsName">비트 수</entry>
    <entry key="hardwareNumBitsName">하드웨어 워드 크기.</entry>
    <entry key="hardwareCharToolTip">C의 char형 표현에 사용하는 비트 수.</entry>
    <entry key="hardwareShortToolTip">C의 short형 표현에 사용하는 비트 수.</entry>
    <entry key="hardwareIntToolTip">C의 int형 표현에 사용하는 비트 수.</entry>
    <entry key="hardwareLongToolTip">C의 long형 표현에 사용하는 비트 수.</entry>
    <entry key="hardwareFloatToolTip">C의 부동소수점 표현에 사용하는 비트 수(참고 정보로만 제공, 설정 불가능).</entry>
    <entry key="hardwareDoubleToolTip">C의 double형 표현에 사용하는 비트 수(참고 정보로만 제공, 설정 불가능).</entry>
    <entry key="hardwarePointerToolTip">C의 포인터 유형 표현에 사용하는 비트 수(참고 정보로만 제공, 설정 불가능).</entry>
    <entry key="hardwareSizeTToolTip">C의 size_t 유형 표현에 사용하는 비트 수(참고 정보로만 제공, 설정 불가능).</entry>
    <entry key="hardwarePtrDiffTToolTip">C의 ptrdiff_t 유형 표현에 사용하는 비트 수(참고 정보로만 제공, 설정 불가능).</entry>
    <entry key="hardwareProdBitPerPointerName">포인터:   </entry>
    <entry key="hardwareIntegerAtomicLabelName">정수:   </entry>
    <entry key="hardwareFloatAtomicLabelName">부동소수점:   </entry>
    <entry key="hardwareLargestAtomicIntegerToolTip">아토믹 단위로 불러와서 저장할 수 있는 가장 큰 정수 데이터형을 지정합니다. 더 작은 정수 데이터형은 모두 아토믹으로 간주됩니다.</entry>
    <entry key="hardwareLargestAtomicFloatToolTip">아토믹 단위로 불러와서 저장할 수 있는 가장 큰 부동소수점 데이터형을 지정합니다. double형이 지정된 경우 float형도 아토믹으로 간주됩니다.</entry>
    <entry key="hardwareProdEndianName">바이트 순서:</entry>
    <entry key="hardwareProdWordName">네이티브 워드 크기:</entry>
    <entry key="hardwareIntDivRoundToName">부호 있는 정수 나눗셈의 반올림 방식:</entry>
    <entry key="hardwareIntDivisionToolTip">C 컴파일러가 2개의 부호 있는 정수를 나눈 결과를 반올림하는 방법을\n지정합니다. 이 정보를 사용하면 이 프로젝트에서 효율적인 C 코드를\n생성할 수 있습니다.</entry>
    <entry key="hardwareShiftRightName">산술 시프트로 부호 있는 정수에 대한 오른쪽 시프트 수행</entry>
    <entry key="hardwareArithmeticShiftToolTip">C 컴파일러가 산술 시프트로 부호 있는 정수에 대한 오른쪽 시프트를\n구현하도록 지정합니다. 거의 모든 컴파일러에서 이를 수행합니다.</entry>
    <entry key="hardwareEndianToolTip">타깃의 바이트 순서가 빅 엔디안인지(최상위 바이트 먼저)\n아니면 리틀 엔디안인지(최하위 바이트 먼저)\n지정합니다. 지정되지 않은 경우 생성 코드가 결과를 계산합니다.</entry>
    <entry key="hardwareNativeWordToolTip">타깃 프로세서에서 한 번에 처리할 수 있는 비트 수입니다.\n프로세서의 네이티브 워드 크기를 제공하면 데이터형의 엔디안 바이트 순서를\n변환할 때 더 효율적인 코드가 생성될 수 있습니다.</entry>
    <entry key="hardwareSyncWithAboveToolTip">이 프로젝트에서 생성된 코드를 테스트하는 데 사용되는 하드웨어와\n최종적으로 코드를 실행하는 하드웨어를 동일하게 지정합니다. 이 옵션을\n선택하지 않으면 테스트 하드웨어에서 최종 하드웨어를 에뮬레이션할 수 있도록\n추가 코드가 생성됩니다.</entry>
    <entry key="hardwareProdEqTargetName">없음</entry>
    <entry key="hardwareInstructionSetExtensionsText">타깃 하드웨어 확장 명령어 집합 활용</entry>
    <entry key="hardwareInstructionSetExtensions_Tooltip">확장 명령어 집합을 사용하여 생성 코드 최적화:</entry>
    <entry key="hardwareInstructionSetExtensionsDisabled_Tooltip">확장 명령어 집합을 사용하여 생성 코드 최적화: 비활성화됨</entry>
    <entry key="hardwareOptimizeReductionsText">축소 최적화</entry>
    <entry key="hardwareOptimizeReductions_Tooltip">축소 지원을 활성화하여 생성 코드 최적화</entry>
    <entry key="hardwareFMAText">FMA</entry>
    <entry key="hardwareFMA_Tooltip">FMA 확장자를 선택하면 FMA 내부 파라미터와 함께 코드가 생성됩니다</entry>
    <entry key="InstructionSets_None">없음</entry>
    <entry key="Hardware_Prod_CharGTShort">임베디드 하드웨어 설정 오류: "char"의 워드 길이가 "short"의 워드 길이보다 깁니다. "char"의 워드 길이는 {0,number,integer}인 반면 "short"의 워드 길이는 {1,number,integer}입니다</entry>
    <entry key="Hardware_Prod_CharNonPos">임베디드 하드웨어 설정 오류: "char"이 값 {0,number,integer}을(를) 지정하고 있으나, 양의 값이어야 합니다</entry>
    <entry key="Hardware_Prod_CharOutOfRange">임베디드 하드웨어 설정 오류: "char"이 값 {0,number,integer}을(를) 지정하고 있으나, 8에서 32 사이의 값이어야 합니다</entry>
    <entry key="Hardware_Prod_ShortOutOfRange">임베디드 하드웨어 설정 오류: "short"이 값 {0,number,integer}을(를) 지정하고 있으나, 8에서 32 사이의 값이어야 합니다</entry>
    <entry key="Hardware_Prod_IntOutOfRange">임베디드 하드웨어 설정 오류: "int"가 값 {0,number,integer}을 지정하고 있으나, 8에서 32 사이의 값이어야 합니다</entry>
    <entry key="Hardware_Prod_LongLongOutOfRange">임베디드 하드웨어 설정 오류: "long long"이 {0,number,integer}의 값을 지정하고 있으나, 64 이상이어야 합니다</entry>
    <entry key="Hardware_Prod_No32BitType">임베디드 하드웨어 설정 오류: "char", "short", "int", "long" 중 적어도 하나 이상의 값이 32이어야 합니다</entry>
    <entry key="Hardware_Prod_AtomicLongLongUnavailable">임베디드 하드웨어 설정 오류: ProdLargestAtomicInteger=''LongLong''인데 ProdLongLongMode는 ''off''입니다</entry>
    <entry key="Hardware_Prod_IntGTLong">임베디드 하드웨어 설정 오류: "int"의 워드 길이가 "long"의 워드 길이보다 깁니다. "int"의 워드 길이는 {0,number,integer}인 반면 "long"의 워드 길이는 {1,number,integer}입니다</entry>
    <entry key="Hardware_Prod_LongGTLongLong">임베디드 하드웨어 설정 오류: "long"의 워드 길이가 "long long"의 워드 길이보다 깁니다. "long"의 워드 길이는 {0,number,integer}인 반면 "long long"의 워드 길이는 {1,number,integer}입니다</entry>
    <entry key="Hardware_Prod_LongTooBig">임베디드 하드웨어 설정 오류: "long"이 값 {0,number,integer}을(를) 지정하고 있으나, 지원되는 최댓값은 {1,number,integer}입니다</entry>
    <entry key="Hardware_Prod_LongLongTooBig">임베디드 하드웨어 설정 오류: "long long"이 {0,number,integer}의 값을 지정하고 있으나, 지원되는 최댓값은 {1,number,integer}입니다</entry>
    <entry key="Hardware_Prod_ShortGTInt">임베디드 하드웨어 설정 오류: "short"의 워드 길이가 "int"의 워드 길이보다 깁니다. "short"의 워드 길이는 {0,number,integer}인 반면 "int"의 워드 길이는 {1,number,integer}입니다</entry>
    <entry key="Hardware_Prod_WordSizeNotMatch">임베디드 하드웨어 설정 오류: "네이티브 워드 크기"가 {0,number,integer}의 값을 지정하고 있으나, 이는 {1} 파라미터에서 지정한 값 중 하나와 일치해야 합니다.</entry>
    <entry key="Hardware_Prod_WordSizeNotMultipleOf8">임베디드 하드웨어 설정 오류: 모든 워드 크기는 8의 배수여야 합니다. 잘못된 워드 크기: {0,number,integer}.</entry>
    <entry key="Hardware_Target_CharGTShort">테스트 하드웨어 설정 오류: "char"의 워드 길이가 "short"의 워드 길이보다 깁니다. "char"의 워드 길이는 {0,number,integer}인 반면 "short"의 워드 길이는 {1,number,integer}입니다</entry>
    <entry key="Hardware_Target_CharNonPos">테스트 하드웨어 설정 오류: "char"은 {0,number,integer}의 값을 지정하지만 양의 값이어야 합니다</entry>
    <entry key="Hardware_Target_CharOutOfRange">테스트 하드웨어 설정 오류: "char"은 {0,number,integer}의 값을 지정하지만 8에서 32 사이의 값이어야 합니다</entry>
    <entry key="Hardware_Target_ShortOutOfRange">테스트 하드웨어 설정 오류: "short"는 {0,number,integer}의 값을 지정하지만 8에서 32 사이의 값이어야 합니다</entry>
    <entry key="Hardware_Target_IntOutOfRange">테스트 하드웨어 설정 오류: "int"는 {0,number,integer}의 값을 지정하지만 8에서 32 사이의 값이어야 합니다</entry>
    <entry key="Hardware_Target_No32BitType">테스트 하드웨어 설정 오류: "char", "short", "int", "long" 중 최소 하나 이상의 값이 32이어야 합니다</entry>
    <entry key="Hardware_Target_AtomicLongLongUnavailable">테스트 하드웨어 설정 오류: TargetLargestAtomicInteger=''LongLong''이지만 TargetLongLongMode는 ''off''입니다</entry>
    <entry key="Hardware_Target_IntGTLong">테스트 하드웨어 설정 오류: "int"의 워드 길이가 "long"의 워드 길이보다 깁니다. "int"의 워드 길이는 {0,number,integer}인 반면 "long"의 워드 길이는 {1,number,integer}입니다</entry>
    <entry key="Hardware_Target_LongGTLongLong">테스트 하드웨어 설정 오류: "long"의 워드 길이가 "long long"의 워드 길이보다 깁니다. "long"의 워드 길이는 {0,number,integer}인 반면 "long long"의 워드 길이는 {1,number,integer}입니다</entry>
    <entry key="Hardware_Target_LongTooBig">테스트 하드웨어 설정 오류: "long"은 {0,number,integer}의 값을 지정하지만 지원되는 최댓값은 {1,number,integer}입니다</entry>
    <entry key="Hardware_Target_LongLongTooBig">테스트 하드웨어 설정 오류: "long long"은 {0,number,integer}의 값을 지정하지만 지원되는 최댓값은 {1,number,integer}입니다</entry>
    <entry key="Hardware_Target_LongLongOutOfRange">테스트 하드웨어 설정 오류: "long long"은 {0,number,integer}의 값을 지정하지만 64 이상이어야 합니다</entry>
    <entry key="Hardware_Target_ShortGTInt">테스트 하드웨어 설정 오류: "short"의 워드 길이가 "int"의 워드 길이보다 깁니다. "short"의 워드 길이는 {0,number,integer}인 반면 "int"의 워드 길이는 {1,number,integer}입니다</entry>
    <entry key="Hardware_Target_WordSizeNotMatch">테스트 하드웨어 설정 오류: "네이티브 워드 크기"는 {0,number,integer}의 값을 지정하지만 {1} 파라미터에서 지정한 값 중 하나와 일치해야 합니다.</entry>
    <entry key="Hardware_Target_WordSizeNotMultipleOf8">테스트 하드웨어 설정 오류: 모든 워드 크기는 8의 배수여야 합니다. 잘못된 워드 크기: {0,number,integer}.</entry>
    <entry key="Hardware_RegisteredDevice">등록된 장치가 이 요구 사항을 충족하지 않으면 "{0}"을(를) '일반-&gt;사용자 지정'으로 업데이트하고 유효한 값을 지정하십시오. 또는 &lt;a href="matlab:helpview(fullfile(docroot,'toolbox','ecoder','helptargets.map'),'RegisterAdditionalDevice')"&gt;새 하드웨어 장치를 등록&lt;/a&gt;하십시오.</entry>
    <entry key="Hardware_SizeTPtrDiffTNotMatch">하드웨어 설정 오류: "{0}"은(는) {1,number,integer}의 값을 지정합니다. 값은 8, 16, 24, 32, 40, 64, 128 중 하나여야 합니다. {2}</entry>
    <entry key="Hardware_SizeTPtrDiffTLessThanInt">하드웨어 설정 오류: "{0}"은(는) {1,number,integer}의 값을 지정합니다. "{2}"의 값({3,number,integer})보다 크거나 같아야 합니다. {4}</entry>
    <entry key="HardwareDeviceVendorUnknown">Incorrect hardware device setting. Device vendor ''{0}'' is not supported.</entry>
    <entry key="HardwareDeviceUnknown">Incorrect hardware device settings. Device ''{0}'' is not supported.</entry>
    <entry key="UnsupportedHeliumISEForArchitecture">"{0}"은(는) "{1}"을(를) 지원하지 않습니다. "ARM Cortex-M55 (MPS3)" 또는 "None"을 선택하십시오.</entry>
    <entry key="RTWInterfaceTabName">인터페이스</entry>
    <entry key="targetSoftwareMathTargetName">코드 대체 라이브러리:</entry>
    <entry key="targetSoftwareMathTargetToolTip">타깃에 사용 가능한 코드 대체 라이브러리를 지정합니다.\n{0}\n선택한 코드 대체 라이브러리에는 다음과 같은 테이블이 포함됩니다:{1}\n</entry>
    <entry key="targetSoftwareMathTargetNoneToolTip">타깃에 사용 가능한 코드 대체 라이브러리를 지정합니다.</entry>
    <entry key="ERTDialogSupportName">지원:</entry>
    <entry key="ERTDialogSupportFloatToolTip">생성 코드에서 부동소수점 데이터형을 지원합니다.</entry>
    <entry key="ERTDialogSupportFloatName">부동소수점 숫자</entry>
    <entry key="ERTDialogSupportNonFiniteToolTip">생성 코드에서 non-finite 값(inf, nan, -inf)을 지원합니다.</entry>
    <entry key="ERTDialogSupportNonFinited1ToolTip">생성 코드에서 non-finite 값(inf, nan, -inf)을 지원합니다.\n이 옵션은 "부동소수점 숫자 지원"이 해제된 경우 강제로 해제됩니다.</entry>
    <entry key="ERTDialogSupportNonFiniteName">non-finite 숫자</entry>
    <entry key="GRTDialogSupportNonFiniteName">non-finite 숫자 지원</entry>
    <entry key="ERTDialogTermFunToolTip">프로젝트 종료 함수를 생성합니다.</entry>
    <entry key="ERTDialogTermFunName">종료 함수 필요함</entry>
    <entry key="ERTDialogCodeReuseName">재사용 가능한 코드 생성</entry>
    <entry key="ERTDialogCodeReuseToolTip">재사용 가능/재진입 코드를 생성합니다.</entry>
    <entry key="ERTDialogTargetName">소프트웨어 환경</entry>
    <entry key="ERTDialogInterfaceName">코드 인터페이스</entry>
    <entry key="RTWCodeStyleTabName">코드 스타일</entry>
    <entry key="ERTTargetcodeStyleParentLevelName">괄호 수준:</entry>
    <entry key="ERTTargetcodeStyleParentLevelToolTip">코드에 괄호 묶기 수준을 지정합니다.</entry>
    <entry key="ERTTargetcodeStyleParentLevelMinimum">최소(우선 순위는 C/C++ 연산자에 의존함)</entry>
    <entry key="ERTTargetcodeStyleParentLevelNominal">일반(가독성을 위해 최적화)</entry>
    <entry key="ERTTargetcodeStyleParentLevelMaximum">최대(괄호로 우선 순위 지정)</entry>
    <entry key="ERTTargetcodeStyleConvertIfToSwitch">if-elseif-else 패턴을 switch-case 문으로 변환</entry>
    <entry key="ErtTargetcodeStyleConvertIfToSwitchToolTip">가능한 경우 if-elseif-else 패턴을 switch-case 문으로 변환하여 가독성을 개선합니다.</entry>
    <entry key="ERTTargetcodeStylePreserveExternInFcnDeclsName">함수 선언에 extern 키워드 유지</entry>
    <entry key="ERTTargetcodeStylePreserveExternInFcnDeclsToolTip">MATLAB Coder에서 생성한 외부 함수의 선언에\n"extern" 키워드가 포함되는지 여부를 지정합니다.</entry>
    <entry key="OptimizationTabName">최적화</entry>
    <entry key="TgtSpecOptimization">타깃별 최적화</entry>
    <entry key="AdditionalExtensions">추가 확장자:</entry>
    <entry key="optCodeGenName">코드 생성</entry>
    <entry key="optMemcpyName">벡터 할당에 memcpy 사용</entry>
    <entry key="optMemcpyToolTip">벡터 할당을 위해 for 루프를 memcpy로 대체하여 코드를 최적화합니다.</entry>
    <entry key="optMemcpyThresholdName">memcpy 임계값(바이트):</entry>
    <entry key="optMemcpyThresholdToolTip">(요소 개수) * (요소당 바이트 수)가 이 임계값보다 크거나 같은 경우\nmemcpy를 사용합니다. 이 경우 1바이트가 한 문자의 너비입니다.\n  </entry>
    <entry key="optInitFloatDoubleName">memset를 사용하여 부동소수점 및 double형을 0.0으로 초기화</entry>
    <entry key="optInitFloatDoubleToolTip">부동소수점 및 double형에 대한 저장공간 초기화를 최적화합니다. 컴파일러와\n타깃 CPU에서 사용하는 부동소수점의 표현이 정수 비트 패턴 0과 동일한 경우\n이 옵션을 선택하십시오.</entry>
    <entry key="ExampleInputDynamicEmpty">{0}에서 크기가 0인 차원은 항상 정적으로 처리됩니다.</entry>
    <entry key="ExampleInputDynamicSizeNotVector">오류: 샘플 입력값 {0}: 가변 크기 차원은 벡터로 지정해야 합니다.</entry>
    <entry key="ExampleInputDynamicSizeNotReal">오류: 샘플 입력값 {0}: 가변 크기 차원은 실수로 지정해야 합니다.</entry>
    <entry key="ExampleInputDynamicSizeNotLogical">오류: 샘플 입력값 {0}: 가변 크기 차원은 논리형으로 지정해야 합니다.</entry>
    <entry key="ExampleInputSizeNaN">오류: 샘플 입력값 {0}: 차원 {2}의 크기 {1}입니다. 이는 지원되지 않습니다.</entry>
    <entry key="ExampleInputLargeDimSize">오류: 샘플 입력값 {0}: 차원 {2}의 고정 크기 {1}이(가) intmax()보다 크거나 같습니다. 이는 지원되지 않습니다.</entry>
    <entry key="ExampleInputLargeStaticMatrix">오류: 샘플 입력값 {0}: numel이 intmax()보다 크거나 같은 고정 크기 행렬입니다. 이는 지원되지 않습니다.</entry>
    <entry key="ExampleSparseNotSupported">함수 입력값 {0}은(는) 희소 형식일 수 없습니다. 희소 배열은 지원되지 않습니다.</entry>
    <entry key="ExampleSysObjNotSupported">{0}에서의 함수 입력값은 System object일 수 없습니다.</entry>
    <entry key="ExampleClassNotSupported">필요한 샘플 입력값: {1}에서 지원되지 않는 클래스 {0}을(를) 찾았습니다.</entry>
    <entry key="ExampleFiModeNotSupported">샘플 입력값 {0}에 지원되지 않는 ''{1}'' embedded.fi 객체가 포함되어 있습니다.</entry>
    <entry key="ExampleFiWordLength">샘플 입력값 {0} 고정소수점 데이터형이 {1}비트를 초과합니다. 이는 지원되지 않습니다.</entry>
    <entry key="ExampleEmptyStruct">샘플 입력값 {0}에 필드 없는 구조체가 포함되어 있습니다. 이는 지원되지 않습니다.</entry>
    <entry key="ExampleEmptyStructArray">샘플 입력값 {0}에 구조체로 구성된 빈 배열이 포함되어 있습니다. 이는 지원되지 않습니다.</entry>
    <entry key="ExampleSizeEmpty">샘플 입력값 {0} 크기에 비어 있지 않은 샘플 값이 없습니다.</entry>
    <entry key="ExampleSizeNumeric">샘플 입력값 {0}: 크기 차원은 숫자형으로 지정해야 합니다.</entry>
    <entry key="ExampleSizeReal">샘플 입력값 {0}: 크기 차원은 실수로 지정해야 합니다.</entry>
    <entry key="ExampleSizeVector">샘플 입력값 {0}: 크기 차원은 벡터로 지정해야 합니다.</entry>
    <entry key="ExampleSizeNegative">샘플 입력값 {0}: 차원 {2}에서 음의 크기 {1}입니다. 이는 지원되지 않습니다.</entry>
    <entry key="ExampleUnequalClasses">샘플 입력값 {0}({1})과(와) {2}({3})의 클래스가 같지 않습니다.</entry>
    <entry key="ExampleUnequalSizes">샘플 입력값 {0}과(와) {1}의 크기가 같지 않습니다.</entry>
    <entry key="ExampleUnequalComplexity">샘플 입력값 {0}과(와) {1}에 대해 실수 샘플과 복소수 샘플이 혼합되어 있습니다.</entry>
    <entry key="ExampleUnequalNumerictype">샘플 입력값 {0}과(와) {1}의 embedded.numericType이 같지 않습니다.</entry>
    <entry key="ExampleUnequalFimath">샘플 입력값 {0}과(와) {1}의 embedded.fimath가 같지 않습니다.</entry>
    <entry key="ExampleUnequalNumFields">샘플 입력값 {0}과(와) {1}의 필드 개수가 같지 않습니다.</entry>
    <entry key="ExampleUnequalFieldName">샘플 입력 필드 {0}.{1}의 이름이 {2}.{3}과(와) 다릅니다. 참고로 필드 순서가 중요합니다.</entry>
    <entry key="globalSyncName">전역 데이터 동기화 모드:</entry>
    <entry key="globalSyncToolTip">이 모드는 전역 데이터가 MATLAB 전역 작업 공간과 동기화되는 시기를 제어합니다.</entry>
    <entry key="globalSyncNever">비활성화됨</entry>
    <entry key="globalSyncEntryExit">MEX 함수 진입 및 종료 시</entry>
    <entry key="globalSyncFull">MEX 함수 진입, 종료, 외재적 호출 시</entry>
    <entry key="lccNotCPPcompiler">The specified code generation target is configured to generate C++, but the C-only compiler, LCC, is the default compiler. To allow code generation, you can deselect the ''Generate makefile'' option. Or, to specify a C++ compiler, enter ''mex -setup'' at the command prompt.  To generate C code, set the target language to C in the configuration object.</entry>
    <entry key="lccNotMexCPPcompiler">The specified MEX target is configured to generate C++, but the C-only compiler, LCC, is the default compiler.\nTo specify a C++ compiler, enter ''mex -setup'' at the command prompt.\nTo generate C code, set the target language to C in the configuration object.</entry>
    <entry key="watcomNotCPPDLLcompiler">The specified code generation target is configured to generate a C++ dynamic library, but Watcom is the default compiler. To specify a C++ compiler that supports dynamic library generation, enter ''mex -setup'' at the command prompt.  To generate a C dynamic library, set the target language to C in the configuration object.</entry>
    <entry key="MissingParameterOption">Missing parameter to option ''{0}''.</entry>
    <entry key="InvalidParameterOption">옵션 ''{0}''에 대한 유효하지 않은 파라미터입니다.</entry>
    <entry key="InvalidVarName">''{0}''은(는) 유효한 MATLAB 변수 이름이 아닙니다.</entry>
    <entry key="UnrecognizedOption">''{0}''은(는) 인식할 수 없는 옵션입니다.</entry>
    <entry key="NonScalarOption">옵션 ''{0}''은(는) 스칼라 텍스트여야 합니다. 여러 값을 지정하려면 이 옵션을 두 번 이상 전달하십시오.</entry>
    <entry key="UnsupportedOptionForCurrentConfig">옵션 ''{0}''은(는) 현재의 코드 생성 구성 객체에서 지원되지 않습니다.</entry>
    <entry key="UnsupportedClassForMultiSignatureMex">MEX function generation for multiple signatures does not support ''{0}''.</entry>
    <entry key="UnsupportedConfigForMultiSignatureMex">Multi-signature MEX function generation does not support the ''{0}'' value for the configuration property ''{1}''.</entry>
    <entry key="UnsupportedConstantInMultiSignatureMex">Multi-signature code generation does not support coder.Constant input arguments when constant input checking is disabled. For details, see config options ConstantInputs and SILPILCheckConstantInputs.</entry>
    <entry key="UnsupportedOutputTypeInMultiSignatureMex">Multi-signature code generation does not support coder.OutputType input arguments.</entry>
    <entry key="UnusedOption">Unused option ''{0}''.</entry>
    <entry key="DuplicateOption">Duplicate option ''{0}''.</entry>
    <entry key="UnrecognizedProject">파일 ''{0}''은(는) 인식할 수 있는 프로젝트가 아닙니다.</entry>
    <entry key="IncompatibleProjectPlatform">프로젝트 파일 ''{0}''은(는) 다른 플랫폼에서 생성되었으며, 처리할 수 없습니다.</entry>
    <entry key="CannotProcessOptions">Cannot process options.</entry>
    <entry key="CoderProjectIgnoresArgs">프로젝트 파일을 지정하는 호출은 지정된 다른 모든 옵션을 무시합니다.</entry>
    <entry key="NoFunctionNameSpecified">No function name specified.</entry>
    <entry key="CannotCreateDirectory">디렉터리 ''{0}''을(를) 만들 수 없음: {1}</entry>
    <entry key="CannotAccessDirectory">디렉터리 ''{0}''에 액세스할 수 없습니다.</entry>
    <entry key="DirectoryNameHasBadChar">디렉터리 이름 ''{0}''에 지원되지 않는 문자 ''{1}''이(가) 포함되어 있습니다.</entry>
    <entry key="FolderBadUTF162LCPCompat">폴더 이름 ''{0}''의 일부 문자를 로컬 코드 페이지로 변환할 수 없습니다.</entry>
    <entry key="UnrecognizedConfigArg">인식할 수 없는 구성 인수{0}</entry>
    <entry key="InvalidGlobalDataName">Invalid global data name in initialization argument.</entry>
    <entry key="GlobalInitOnlyHasType">전역 ''{0}''의 초기화 값이 누락되었습니다. \n초기화 값은 전역 작업 공간에서 지정하거나 명령줄에서 형식 ''-globals '{'name, '{'type, value'}}'''로 지정해야 합니다.</entry>
    <entry key="MissingGlobalInitialValue">전역 ''{0}''의 초기화 값이 누락되었습니다.</entry>
    <entry key="MultipleExampleInputs">하나의 함수에 여러 개의 샘플 입력값이 지정되었습니다.</entry>
    <entry key="EmptyCmdLineArgument">빈 명령줄 인수는 지원되지 않습니다.</entry>
    <entry key="FailedToEvalArgument">Failed to evaluate ''{0}'' to non-empty array in the base workspace.</entry>
    <entry key="UnrecognizedFileExtension">''{0}''은(는) 인식할 수 없는 파일 확장자입니다.</entry>
    <entry key="UnsupportedFileExtensionWithoutGPUCoder">'.cu' 또는 '.cuh'는 유효하지 않은 파일 확장자입니다.\nCUDA 파일은 GPU Coder에서만 지원됩니다.</entry>
    <entry key="UnsupportConfigObject">''{0}''은(는) 지원되지 않는 구성입니다.</entry>
    <entry key="InvalidFunctionNameType">Function name must be character vector or string scalar.</entry>
    <entry key="InvalidMethodNameWithNamespace">Invalid parameter name ''{0}''. First argument of addMethod must be a method name. Do not add the namespace name ''{1}''. </entry>
    <entry key="EntryPointNameInvalid">''{0}'' is not a valid MATLAB function name.</entry>
    <entry key="MissingFunctionName">No function name specified in ''{0}''.</entry>
    <entry key="ClientFixedPointConversion">고정소수점 변환</entry>
    <entry key="ClientSingleConversion">double형을 single형으로 변환</entry>
    <entry key="ClientDVO">도출된 범위</entry>
    <entry key="MultipleEntryPointsNotSupportedByClient">여러 개의 진입점 함수가 지정됨: ''{0}'' 및 ''{1}''. {2}에는 여러 개의 진입점 함수가 지원되지 않습니다.</entry>
    <entry key="MultipleEntryPointSignaturesNotSupportedByClient">함수 ''{0}''에 여러 개의 진입점 시그니처가 지정되었습니다. {1}에는 여러 개의 진입점 시그니처가 지원되지 않습니다.</entry>
    <entry key="BuildInstrumentedMexMultipleEntryPointsNotSupported">여러 개의 진입점 함수 또는 진입점 시그니처가 지정되었습니다. buildInstrumentedMex 명령을 사용하여 여러 개의 진입점 함수 또는 진입점 시그니처에 대한 코드를 생성하려면 -coder 옵션을 포함하십시오. 이 옵션을 사용하려면 MATLAB Coder 라이선스가 있어야 합니다.</entry>
    <entry key="EntryPointsInNamespacesNotSupportedByClient">진입점 함수 ''{0}''이(가) 네임스페이스에 있습니다. {1}에는 네임스페이스의 진입점 함수가 지원되지 않습니다.</entry>
    <entry key="UnsupportedExtension">출력 파일 확장자 ''{0}''은(는) 지원되지 않습니다.</entry>
    <entry key="OutputFileNameHasBadChar">출력 파일 이름 ''{0}''에 지원되지 않는 문자 ''{1}''이(가) 포함되어 있습니다.</entry>
    <entry key="OutputFileNameNotMexFcnName">출력값 이름 ''{0}''은(는) 유효한 MEX 함수 이름이 아닙니다.</entry>
    <entry key="DirectoryNotFound">출력값 파일 디렉터리 ''{0}''이(가) 없습니다.</entry>
    <entry key="InvalidCodingTarget">코딩 타깃 지정 ''{0}''이(가) 유효하지 않습니다.\n형식 ''-T type''을 사용하십시오. 여기서 ''type''은 ''mex'', ''rtw'', ''rtw:lib'', ''rtw:exe'' 중 하나입니다.</entry>
    <entry key="InvalidOptimizationRestrict">최적화 지정 ''{0}''이(가) 유효하지 않습니다.\n형식 ''enable:optimization'' 또는 ''disable:optimization''을 사용하십시오.\n여기서 ''optimization''은 ''inline''입니다.</entry>
    <entry key="InvalidOptimization">최적화 지정 ''{0}''이(가) 유효하지 않습니다.\n형식 ''enable:optimization'' 또는 ''disable:optimization''을 사용하십시오.\n여기서 ''optimization''은 ''inline'' 또는 ''openmp'' 중 하나입니다.</entry>
    <entry key="ProjectNumerictypeInvalid">Numerictype specification for ''{0}'' is not valid: ''{1}''</entry>
    <entry key="ProjectFimathInvalid">Fimath specification for ''{0}'' is not valid: ''{1}''</entry>
    <entry key="ProjectConstantInvalid">Constant specification for ''{0}'' is not valid: ''{1}''</entry>
    <entry key="GlobalInitialValueTypeMismatch">전역 변수 ''{0}''에 대해 지정된 초기값이 전역 변수의 유형에 포함되어 있지 않습니다.</entry>
    <entry key="DeprecatedOption">옵션 ''{0}''은(는) 지원되지 않습니다. 대신 ''{1}''을(를) 사용하십시오.</entry>
    <entry key="RequireFeatureControl">''-feature'' 옵션에는 특징 제어 객체가 필요합니다.</entry>
    <entry key="InvalidCodingTargetConfig">코딩 타깃 지정 ''{0}''이(가) 유효하지 않습니다.\n형식 ''-config type''을 사용하십시오. 여기서 ''type''은 구성 객체이거나 ''coder:mex'', ''coder:lib'', ''coder:exe'' 중 하나입니다.</entry>
    <entry key="NonScalarConfig">제공되는 구성 객체는 스칼라여야 합니다.</entry>
    <entry key="EntryPointNotSpecified">No entry-point functions specified.</entry>
    <entry key="EntryPointNotFound">The entry-point file ''{0}'' cannot be located.</entry>
    <entry key="MexFunctionNotFound">Unable to locate the generated MEX function ''{0}'' on the MATLAB path. Either add the directory containing this file to the path, or move this file to a location already on the path.</entry>
    <entry key="TestBenchNotFound">The test file ''{0}'' cannot be located.</entry>
    <entry key="InputTypesNotSpecified">Provide a test bench or input types for HDL code generation.</entry>
    <entry key="ProjectToScriptNoHDLSuport">MATLAB HDL Coder 프로젝트에서 스크립트 파일을 만드는 것은 지원되지 않습니다.</entry>
    <entry key="ExtractHelpTestUndef">Definition of ''{0}'' is not contained by matlabroot/toolbox/coder/coder or matlabroot/toolbox/coder/coder/+coder. No help is supposed to be extracted.</entry>
    <entry key="ExtractHelpTestNoMFile">파일 ''{0}''.p에 MATLAB 파일 정의가 없습니다.</entry>
    <entry key="ExtractHelpTestNoPCode">The definition of class/command/function ''{0}'' is not p-coded. No help is supposed to be extracted.</entry>
    <entry key="ExtractHelpTestNoDefn">The class/command/function ''{0}'' is not defined in ''{1}''. No help is supposed to be extracted.</entry>
    <entry key="InValid_CustomToolchainOptions">''{0}'' must be a cell array of tools and options specified in name-value pairs.</entry>
    <entry key="InValid_CustomToolchainOptions_EmptyCellWithSpecify">BuildConfiguration 속성이 ''{1}''(으)로 설정되어 있으면 ''{0}''을(를) 빈 셀형 배열로 설정할 수 없습니다.</entry>
    <entry key="Invalid_CustomToolchainOptions_NumberOfTools_Invalid">''{0}'' must be a cell array of tools and options specified in name-value pairs. Please specify valid configurations for the following build tools: {1}</entry>
    <entry key="InValid_CustomToolchainOptions_Name_Rep">''{0}'' is specified multiple times. Tool must not be specified more than once.</entry>
    <entry key="InValid_CustomToolchainOptions_Name_Unknown">''{0}'' is an unknown tool. Tool can be one of the following: {1}</entry>
    <entry key="Invalid_MultiSignatureMexSignature">Duplicate signatures encountered while generating multi-signature MEX function. Remove duplicate signatures.</entry>
    <entry key="NoBuildConfigurations">Could not get list of Build Configurations for the current toolchain. Check if the toolchain is registered.</entry>
    <entry key="BadBuildConfigurationString">Illegal characters in build configuration value.</entry>
    <entry key="Invalid_ToolchainName">''{0}'' is not a valid Toolchain name. Use one of the following: {1}</entry>
    <entry key="MultipleMatchingToolchainName">''{0}'' matches multiple Toolchain names. Specify one of these toolchains:\n{1}</entry>
    <entry key="NoToolchains">Could not get list of toolchains. Check if any toolchain is registered.</entry>
    <entry key="BadToolchainString">툴체인 값에 부적절한 문자가 있습니다.</entry>
    <entry key="BadCRLString">코드 대체 라이브러리 값에 부적절한 문자가 있습니다.</entry>
    <entry key="BadSymbolString">Illegal characters in custom symbol value.</entry>
    <entry key="crlsWithLangBaseTflDeprecated">''{0}'' 코드 대체 라이브러리는 향후 릴리스에서 제거될 예정입니다. ''{1}''을(를) 대신 선택하고 ''TargetLangStandard'' 설정을 사용하여 언어 표준 라이브러리를 지정하십시오.</entry>
    <entry key="crlDeprecatedGCCCortexA">''{0}'' 코드 대체 라이브러리는 권장되지 않습니다. 코드 대체 라이브러리를 'ARM Cortex-A CMSIS' CRL로 설정하십시오.</entry>
    <entry key="InvalidHardwareProperty">The Hardware property must have class ''{0}''.</entry>
    <entry key="UpdateHardwareFailed">Failed to apply the ''{0}'' method to the Hardware property.</entry>
    <entry key="UpdateHardwareFailedWithCause">Failed to apply the ''{0}'' method to the Hardware property: {1}</entry>
    <entry key="InvalidCustomReplacementType">''{0}'' is not a valid custom data type replacement name.</entry>
    <entry key="EditConfigObj">&lt;a href="matlab:open {0};"&gt;구성 객체 편집&lt;/a&gt;</entry>
    <entry key="EditTypeObj">&lt;a href="matlab:open {0};"&gt;유형 객체 편집&lt;/a&gt;</entry>
    <entry key="ecufRepTypeMustBeCIdentifier">대체 유형 ''{0}''은(는) 유효한 C 식별자여야 합니다.</entry>
    <entry key="ecufRepTypeIsCKeyword">''{0}''은(는) C 키워드이며 대체 유형으로 사용할 수 없습니다.</entry>
    <entry key="ecufRepTypeIsCppKeyword">''{0}''은(는) C++ 키워드이며 대체 유형으로 사용할 수 없습니다.</entry>
    <entry key="ecufRepTypeIsDefDataType">''{0}''은(는) 코드 생성용으로 예약된 키워드이며 대체 유형으로 사용할 수 없습니다. </entry>
    <entry key="ecufInvalidDupRepType">''{0}''은(는) ''{1}''에 대한 유효하지 않은 중복 대체 유형입니다</entry>
    <entry key="NoLangStandard">''{0}''에 대한 TargetLangStandard 파라미터가 없습니다.</entry>
    <entry key="NoLang">''{0}''에 대한 TargetLang C 파라미터 또는 C++ 파라미터가 없습니다.</entry>
    <entry key="BadFileNameStr">CustomFileNameStr value ''{0}'' is invalid.</entry>
    <entry key="InvalidEmptyInstructionSetExtensions">''InstructionSetExtensions'' 값은 ''None'' 또는 올바른 확장 명령어 집합이어야 하며, string형으로 지정됩니다.</entry>
    <entry key="InvalidMultipleInstructionSetExtensions">Array of multiple elements is not supported for ''InstructionSetExtensions''. The value must be a string or a character vector.</entry>
    <entry key="ConstantSerializationWithoutDma">LargeConstantGeneration 구성 설정을 'WriteOnlyDNNConstantsToDataFiles'로 설정하려면 동적 메모리 할당 구성 설정을 활성화해야 합니다.</entry>
    <entry key="MODialogError">MATLAB Online does not support the GUI for code generation configuration objects. Edit configuration properties from a command line or script.</entry>
    <entry key="InvalidLangStandard">타깃 언어 표준 ''{0}''이(가) 타깃 언어 ''{1}''과(와) 호환되지 않습니다.</entry>
    <entry key="InvalidNargoutParam">-nargout에 대한 입력 인수 ''{0}''이(가) 잘못되었습니다. 입력 인수는 음이 아닌 정수 또는 -1이어야 합니다.</entry>
    <entry key="FailedToPullBaseImage">Unable to pull Base Image ''{0}'':''{1}''.</entry>
    <entry key="BadPermissions">Unable to create docker file ''{0}''.</entry>
    <entry key="FailedToGenerateDockerImage">Unable to build docker image ''{0}'':''{1}''.</entry>
    <entry key="DockerIsMissing">To create a docker image, you must have Docker installed on your Linux machine.</entry>
    <entry key="OnlyInLinux">Code generation for docker is supported only in Linux platforms.</entry>
    <entry key="PermissionDenied">Authentication failed. Add yourself to the docker group.</entry>
    <entry key="SILDebuggingDeprecated">SILDebugging 구성 파라미터는 향후 릴리스에서 제거될 예정입니다. SILPILDebugging을 대신 사용하십시오.</entry>
    <entry key="DeprecateCppPackagesToNamespaces">CppPackagesToNamespaces 구성 파라미터는 향후 릴리스에서 제거될 예정입니다. CppPreserveNamespaces를 대신 사용하십시오.</entry>
    <entry key="hardwareProdBitPerCharName">char:   </entry>
    <entry key="hardwareProdBitPerShortName">short:  </entry>
    <entry key="hardwareProdBitPerIntName">int:    </entry>
    <entry key="hardwareProdBitPerLongName">long:   </entry>
    <entry key="hardwareProdBitPerFloatName">float:   </entry>
    <entry key="hardwareProdBitPerDoubleName">double:   </entry>
    <entry key="hardwareProdBitPerSizeTName">size_t:   </entry>
    <entry key="hardwareProdBitPerPtrDiffTName">ptrdiff_t:   </entry>
    <entry key="ClientFiaccel">fiaccel</entry>
    <entry key="ClientHDLCoder">HDL Coder</entry>
    <entry key="ClientGPUCoder">GPU Coder</entry>
    <entry key="ClientPLCCoder">PLC Coder</entry>
    <entry key="ClientBuildInstrumentedMex">buildInstrumentedMex</entry>
    <entry key="InvalidDataTypeAliasName">{0}</entry>
  </message>
</rsccat>
