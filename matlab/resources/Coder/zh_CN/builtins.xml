<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="zh_CN" product="Coder" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="AggregateClass">Non-scalars of class ''{0}'' are not supported.</entry>
    <entry key="Arg2D">输入参数必须为二维。</entry>
    <entry key="ImageDataUnderlyingMustHaveThreeDimensions">图像必须有三个维度。</entry>
    <entry key="ArgumentMClassMismatch">无法将具有未知 MATLAB 类的参数传递给其输入具有已知 MATLAB 类的函数。</entry>
    <entry key="ArityInput">函数 ''{0}'' 的输入太多。</entry>
    <entry key="ArityInputCausedBy">调用 ''{0}'' 时出错。此调用点传递给此函数的输入数超出它可以接受的数量。这可能是由以下原因引起的: {1}</entry>
    <entry key="ArityInputFunctionCallEvent">函数参数无法传递给函数调用事件触发器。</entry>
    <entry key="IllegalUseOfFunctionCallEvent">在此上下文中非法使用了函数调用输出事件。</entry>
    <entry key="ArityInputSF">此 Simulink 或 Stateflow 函数所需的输入数目与调用点不匹配。</entry>
    <entry key="ArityOutput">调用 ''{0}'' 时出错。此调用点需要的输出数目多于此函数能提供的数目。</entry>
    <entry key="ArrayDeletionOnFixedSizeDimension">无法从这个数组中删除元素，因为维度 {0,number,integer} 具有固定大小 {1,number,integer}。</entry>
    <entry key="AssertMustBeTopLevel">assert() 必须为语句；它不能嵌套在表达式中。</entry>
    <entry key="AssertionFailed">断言失败。</entry>
    <entry key="AssignmentFromMatlabTypeAmbiguousSSS">变量 ''{0}'' 有冲突的类型定义。要解决此问题，请验证 ''{1}'' 的所有先前定义是否一致。</entry>
    <entry key="BuiltinInvalidFcn">无法解析内置函数 {0}。</entry>
    <entry key="BuiltinMustBeInFOR">coder.unroll 必须位于紧挨 for 循环之前的一个单独行上，或在 for 循环标头中。</entry>
    <entry key="BuiltinDuplicateCall">coder.unroll 必须位于 for 循环之前或在 for 循环标头中。不支持在同一 for 循环中同时采用这两种用法。</entry>
    <entry key="BuiltinMustBeBeforeFOR">当 coder.unroll 在 for 循环标头之外使用时，它必须紧挨在 for 循环语句之前。</entry>
    <entry key="BuiltinMustBeBeforeTryCatch">coder.ignoreTryCatch 必须紧挨在 try-catch 代码块之前。</entry>
    <entry key="IllegalInvocationInternalBuiltin">不支持从用户函数 ''{1}'' 调用代码生成实现函数 ''{0}''。请与技术支持联系以获取帮助。</entry>
    <entry key="BifAtExitSyntax">内置 ''{0}'' 需要单一参数，该参数是 void/void 函数的函数句柄。</entry>
    <entry key="BifAtExitThreadArgument">无效的标志参数: ''{0}''。有效输入为: "OnEachThread" 和 "OnMainThread"。</entry>
    <entry key="BifAtExitRuntimeArguments">推断使用内置 ''{1}'' 注册的函数句柄 ''{0}'' 具有运行时参数。注册的 atexit 函数只能有编译时参数。</entry>
    <entry key="BifNeedsLValue">内置 ''{0}'' 需要可赋值的位置，例如变量。</entry>
    <entry key="BifRequiresNTBeforeFimath">内置运算符要求 fimath 前面有 numerictype。</entry>
    <entry key="BifUnrecognizedOption">内置运算符无法识别类型为 ''{0}'' 的选项。</entry>
    <entry key="BifUnsupported">尚不支持此内置函数。</entry>
    <entry key="BitConcatArg1">EML_BIT_CONCAT 的第一个参数必须为定点或整数。</entry>
    <entry key="BitConcatArg2">EML_BIT_CONCAT 的第二个参数必须为定点或整数。</entry>
    <entry key="BitSliceNegative">位切片必须具有正宽度。</entry>
    <entry key="BitopArg">EML_BIT_OP 的第一个参数必须为定点或整数。</entry>
    <entry key="BitwiseOperatorClass">按位运算符的两个输入必须具有相同的类。</entry>
    <entry key="BreakMisplaced">BREAK 语句显示在循环之外。请改用 RETURN。</entry>
    <entry key="BuiltinSizeQualifier">\n此内置函数的每个输入都必须具有相同的大小。预期大小是第一个输入的大小。</entry>
    <entry key="CClassUnrecognized">无法识别的 C 类。</entry>
    <entry key="CDeclDuplicateDeclaration">EML_CDECL，要声明的变量已有声明。</entry>
    <entry key="CDeclFirstArg">EML_CDECL，第一个参数应为变量。</entry>
    <entry key="BadCatalogID">使用 'CatalogID' 要求 'CatalogID'、'My:Catalog:ID'、'ReportedID' 和 'My:Reported:ID' 形式的输入</entry>
    <entry key="CannotBeCalledHere">无法在此处调用函数 ''{0}''。</entry>
    <entry key="CellArgsMustBeNonEmpty">''{0}'' 的元胞参数不能为空。</entry>
    <entry key="CEvalHeaderFileMissing">''{0}'' 参数必须后跟头文件名。</entry>
    <entry key="CEvalHeaderFileMultiple">在每个 ''{1}'' 调用中，请只使用一次 ''{0}'' 参数。要包括其他头文件，请使用 ''{2}''。</entry>
    <entry key="CEvalUnrecognizedOption">无法识别的 ''coder.ceval'' 选项 ''{0}''。</entry>
    <entry key="CEvalMissingFunction">缺失要调用的函数的名称。需要函数名称作为第一个非可选参数。</entry>
    <entry key="CEvalAmbiguousTypeSSS">无法从 ''coder.ceval'' 对 ''{0}'' 赋值，因为之前对 ''{1}'' 的赋值发生类型冲突。要修复，请预初始化 ''{2}''。</entry>
    <entry key="CEvalNoTypeSSS">无法从 ''coder.ceval'' 对 ''{0}'' 赋值，因为 ''{1}'' 的类型和大小未知。要修复，请预初始化 ''{2}''。</entry>
    <entry key="CEvalType">''coder.ceval'' 的输出具有未知类型。无法计算外围表达式。\n请将 ''coder.ceval'' 的输出赋给具有已知类型的变量来指定输出类型。</entry>
    <entry key="CEvalWithoutCstructname">未指定 C 结构体名称。请使用 coder.cstructname 命名通过 coder.ceval 传递给外部 C 函数的结构体。</entry>
    <entry key="CEvalPropSetterGetter">代码生成不支持获取属性 ''{0}'' 的地址，因为它有 setter 方法、getter 方法或特性。</entry>
    <entry key="CEvalTypeDisplay">无法显示值，因为 ''coder.ceval'' 的输出没有已知类型。要显示输出，请首先将结果赋给已知类型的变量。</entry>
    <entry key="CHelperMisapplied">''{0}'' 只能应用于 V 或 V(E) 类型的表达式，其中 V 是变量，E 是数值表达式。</entry>
    <entry key="CInterfaceMisuse">''{0}'' 只能在 C 调用上下文中使用。</entry>
    <entry key="CScalarReturn">C 函数调用始终返回标量值，但此处需要非标量值。</entry>
    <entry key="CevalReturnDynamicMatrix">C 函数调用的返回值 ''{0}'' 是可变大小矩阵，这是不允许的。请考虑将其作为参数传递给 C 函数。</entry>
    <entry key="CevalExtrinsicParadox">函数 ''{0}'' 已声明为外部函数，但正在被当做 C 函数调用。</entry>
    <entry key="CevalGpuMultipleFunctionTypes">无法为 coder.ceval 指定多个 gpu 函数类型。请仅使用下列可接受值中的一个选项: ''-gpudevicefcn'' 或 ''-gpuhostdevicefcn''。</entry>
    <entry key="CStructNameArg1">''{0}'' 的第一个参数必须为变量或子结构体表达式，例如 ''s.sub.two''。</entry>
    <entry key="CStructNameEmptyTypeName">Structure name for ''{0}'' must be a nonempty string scalar or character vector.</entry>
    <entry key="CstructNameContainsSpace">不支持在 ''{0}'' 的结构体名称中使用空格，因为结构体不是外部定义的。</entry>
    <entry key="CStructNameArg1Class">First argument to ''{0}'' must be a structure or cell array.</entry>
    <entry key="CStructNameArg3">The optional third argument to ''{0}'' must be ''extern''.</entry>
    <entry key="CStructNameArgExtern">The optional ''extern'' argument to ''{0}'' is not supported for class ''{1}''.</entry>
    <entry key="CStructNameArg">''{1}'' 的可选参数编号 {0,number,integer} 必须为 ''HeaderFile'' 或 ''Alignment''。</entry>
    <entry key="CStructNameHomogeneousCellUnsupported">''{0}'' 不支持同构的元胞数组。</entry>
    <entry key="CStructNameMissingAlignmentValue">输入数目不足: 必须为 ''{0}'' 中的 ''Alignment'' 属性指定整数值。</entry>
    <entry key="CStructNameMissingHeaderFileValue">输入参数的数目不足。在 ''{0}'' 中为 ''HeaderFile'' 属性指定文件名。</entry>
    <entry key="CStructNameInvalidAlignmentValue">{0,number,integer} 不是有效的对齐边界。有效的对齐边界必须为不超过 128 的 2 的幂。</entry>
    <entry key="CStructNameHeaderNeedsExtern">''{0}'' 的第四个参数(可选)要求第三个参数为 ''extern''。</entry>
    <entry key="CStructNameDefined">已使用不同类型定义名称 ''{0}''。定义为 ''{1}''；已尝试将其重新定义为 ''{2}''。</entry>
    <entry key="CStructNameGlobal">coder.cstructname 无法直接应用于全局变量。请改为指定 C 类型名称以与赋给全局变量的类型结合使用。</entry>
    <entry key="CStructNameEntryPointInput">具有入口函数的 coder.cstructname 必须在任何运行时控制流之前应用。MATLAB Function 模块中的顶层函数输入不支持 coder.cstructname。</entry>
    <entry key="CStructNameInput">具有非入口函数输入的 coder.cstructname 必须在调用函数之前应用。</entry>
    <entry key="CStructNameLocked">coder.cstructname 必须在使用某变量之前应用于该变量。</entry>
    <entry key="CStructNameRedefinition">相互冲突的 coder.cstructname 指令被应用于同一对象 {0}。</entry>
    <entry key="CStructNameTypeName">此变量已具有类型名称 ''{0}''。</entry>
    <entry key="CStructNameInconsistentUseOfExtern">结构体 ''{0}'' 必须在外部定义，因为它是外部定义的结构体的字段的类型。请将 coder.cstructname 与 ''extern'' 选项结合使用。</entry>
    <entry key="CStructNameInconsistentUseOfExternForEnum">枚举 ''{0}'' 必须在外部定义，因为它是外部定义的结构体的字段的类型。请在 ''{1}'' 的枚举 classdef 中使用静态方法 ''getHeaderFile()''。</entry>
    <entry key="CStructNameNestedFunction">coder.cstructname 无法应用于来自另一个函数的变量。请将此 coder.cstructname 移至首先赋值的变量所在的函数中。</entry>
    <entry key="CStructNameVarSizeCellArray">Using coder.cstructname to name the C structure type for a variable-size cell array is not supported.</entry>
    <entry key="CStructNameCellParenIndexingUnsupported">coder.cstructname 不支持使用 ''()'' 对元胞数组进行索引。请使用 '''{}''' 索引来访问元素，或不使用索引来访问元胞数组本身。</entry>
    <entry key="CStructNameCellTypeAlignmentUnsupported">Alignment property not supported for coder.CellType objects.</entry>
    <entry key="CoderVarsizeNestedFunction">coder.varsize 无法应用于来自另一个函数的变量。请将此 coder.varsize 移至首先赋值的变量所在的函数中。</entry>
    <entry key="CVariableUntyped">显式声明为已定义的变量已非类型化。</entry>
    <entry key="CanNotUseEndInVarargoutAssign">代码生成不支持使用 ''end'' 对赋值左侧的重复输出变量 ''{0}'' 进行索引。\n请改用显式索引表达式。</entry>
    <entry key="CaseInsensitiveMatch">找不到 ''{0}'' 的精确(区分大小写)匹配项。最接近的匹配项是 ''{1}''。</entry>
    <entry key="CaseSensitiveMatlabResolution">函数 ''{0}'' 在 MATLAB 工作区中解析为 ''{1}''。代码生成不支持 MATLAB 函数的不区分大小写的解析。</entry>
    <entry key="CastToUnknown">无法强制转换未知类的值。</entry>
    <entry key="CastOpaqueComplex">无法将类型 ''{0}'' 转换为类型 ''{1}''，因为代码生成不支持 coder.opaque 类型与复数类型之间的转换。请在转换前使用 real 或 imag 提取复变量的实部或虚部。</entry>
    <entry key="CastOpaqueMultiword">无法将类型 ''{0}'' 转换为类型 ''{1}''，因为代码生成不支持 coder.opaque 类型与目标硬件无法表示的过大类型之间的转换。只有目标硬件可以表示的类型才能与 coder.opaque 类型相互转换。</entry>
    <entry key="CastOpaqueToUnsupportedType">代码生成不支持将 coder.opaque 类型转换为 ''{0}'' 类型。转换不透明值时，目标类型必须为: int8、uint8、int16、uint16、int32、uint32、int64、uint64、double 或 single。请首先将 coder.opaque 值转换为这些类型之一，然后转换为类型 ''{1}''。</entry>
    <entry key="CatArgsInconsisent">CAT 参数维度不一致。参数 {0,number,integer} 的大小为 {1}。参数 {2,number,integer} 的大小为 {3}。</entry>
    <entry key="CatResultDynamicEmpty">CAT 结果是不确定形状的空可变大小数组。</entry>
    <entry key="CatRiskyEmpty">大小为 {0} 的空矩阵无法与大小未知的矩阵串联。</entry>
    <entry key="CatRiskyEmptyGrow">不支持将空数组 {0} 增长为大小为 {1} 的数组。非增长维度不匹配。</entry>
    <entry key="Ccast">C 强制转换</entry>
    <entry key="LogicalToChar">不允许从逻辑值转换为字符。</entry>
    <entry key="ClassDoesNotHaveMethodOrProperty">类 ''{0}'' 没有名为 ''{1}'' 的方法或属性。</entry>
    <entry key="ClassDoesNotHaveProperty">Class ''{0}'' does not have a property with name ''{1}''.</entry>
    <entry key="ClassMismatch">无法将具有类 ''{1}'' 的值赋给具有类 ''{0}'' 的变量。</entry>
    <entry key="ClassMismatchAssign">无法将类型为 {0} 的值写入类型为 {1} 的变量。代码生成不支持通过赋值来更改类型。要调查类型不匹配的原因，请检查前面的赋值或输入类型设定。</entry>
    <entry key="EntryPointIOClassMismatchAssign">入口函数 ''{1}'' 的输入 ''{0}'' 是 {2}，但被赋值 {3}。如果使用同一变量作为输入和输出，其类型和大小必须在整个函数体中保持一致才能生成代码。</entry>
    <entry key="EntryPointIOSizeMismatchAssign">入口函数 ''{1}'' 的输入 ''{0}'' 的大小为 {2}，但被赋值的大小为 {3}。如果使用同一变量作为输入和输出，其类型和大小必须在整个函数体中保持一致才能生成代码。</entry>
    <entry key="NonWebrenamedBuiltinClassMismatchAssign">变量 ''{0}'' 是 {1}，但被赋值 {2}。如果将变量传递给 {3}，其类型和大小必须在整个函数体中保持一致才能生成代码。</entry>
    <entry key="NonWebrenamedBuiltinSizeMismatchAssign">变量 ''{0}'' 的大小为 {1}，但被赋值的大小为 {2}。如果将变量传递给 {3}，其类型和大小必须在整个函数体中保持一致才能生成代码。</entry>
    <entry key="NonWebrenamedVectorVarsizeMismatchAssign">coder.varsize 将变量 {0} 的大小限制为 {1}，但此变量被赋予了大小值 {2}。要调整单一维度的大小，请显式指定上界。</entry>
    <entry key="NonWebrenamedVarsizeMismatchAssign">coder.varsize 将变量 {0} 的大小限制为 {1}，但此变量被赋予了大小值 {2}。</entry>
    <entry key="ClassMismatchAssignOnField">此赋值将 ''{0}'' 值写入字段 ''{2}'' 中的 ''{1}'' 类型。代码生成不支持通过赋值来更改类型。请检查前面的赋值或输入类型设定中是否存在类型不匹配的情况。</entry>
    <entry key="ClassMismatchAssignOnCell">此赋值将 ''{0}'' 值写入元素 ''{2}'' 中的 ''{1}'' 类型。代码生成不支持通过赋值来更改类型。请检查前面的赋值或输入类型设定中是否存在类型不匹配的情况。</entry>
    <entry key="ClassMismatchOnField">在字段 ''{2}'' 中，无法将具有类 ''{1}'' 的值分配给具有类 ''{0}'' 的变量。</entry>
    <entry key="ClassdefInvalidEnumeration">无法加载 ''{0}'' 的定义: {1}</entry>
    <entry key="ClassdefNotAnEnumeration">''{0}'' is not a supported enumeration. For code generation, enumerations must inherit from one of: ''int8'', ''uint8'', ''int16'', ''uint16'', ''int32'', ''uint32'' or ''Simulink.IntEnumType''.</entry>
    <entry key="TunableEnumerationNotImported">''{0}'' 不是导入的可调枚举。对于代码生成，必须导入可调枚举。</entry>
    <entry key="EnumerationDataScopeInvalid">''{0}.getDataScope'' 返回的数据作用域无效: ''{1}''。数据作用域必须为 "自动"、"导入" 或 "导出"。</entry>
    <entry key="UnsupportedExportedEnumerationHeaderPath">''{0}.getHeaderFile'' 返回的头文件无效: ''{1}''。对于导出的枚举，''getHeaderFile'' 必须返回不带路径的头文件名称。</entry>
    <entry key="ExportedEnumerationHeaderInvalid">''{0}.getHeaderFile'' 返回的头文件无效: {1}。头文件必须具有 ''.h'' 扩展名。</entry>
    <entry key="ImportedEnumerationNoHeader">无法导入枚举 ''{0}''，因为未指定头文件。请使用 ''{0}.getHeaderFile'' 来指定头文件。</entry>
    <entry key="EnumClassdefNotfound">Enumeration class definition is missing. Enumeration class ''{0}'' must have a definition for code generation.</entry>
    <entry key="ClassdefBadEnumDefaultValue">The default value returned by ''{0}.getDefaultValue'' must be one of the enumerated values defined in the class definition for ''{1}''. Found a ''{2}'' with {3,number,integer} element(s) instead.</entry>
    <entry key="ClassdefEnumBadHeader">The value returned by ''{0}.getHeaderFile'' must be a file name.</entry>
    <entry key="ClassdefEnumBadPrefixFlag">The value returned by ''{0}.addClassNameToEnumNames'' must be scalar logical.</entry>
    <entry key="ClassdefEnumLoad">为代码生成加载枚举 ''{0}'' 时出错: {1}</entry>
    <entry key="ClassdefEnumStaticMethod">Error invoking the enumeration static method ''{0}.{1}'': {2}</entry>
    <entry key="EnumElementValueDoesNotFitInTargetInt">生产和/或测试硬件的整数数据类型无法容纳值为 ''{1,number,integer}'' 的枚举元素 ''{0}''。由于此类型是作为 C 枚举类型实现的，因此每个元素都必须容纳在当前测试和生产 "int" 类型内(范围为 {2,number,integer}-{3,number,integer})</entry>
    <entry key="ColonLogical">函数 ''colon'' 没有定义为支持 ''logical'' 类的值。</entry>
    <entry key="ColonMixed">冒号操作数必须均为同一类型，或者与实数标量双精度值混合使用。</entry>
    <entry key="ColonNaN">不支持具有 NaN 的 COLON 表达式。</entry>
    <entry key="ColonObjEnum">代码生成不支持冒号表达式中的枚举。请在使用前将枚举 ''{0}'' 转换为整数类型。</entry>
    <entry key="ColonStride">此 COLON 表达式中的步幅似乎不是常量。代码生成仅支持常量步幅。</entry>
    <entry key="ColonInput">函数的输入参数包括冒号运算符。要输入冒号字符，请改用 '':''。</entry>
    <entry key="CommandDuality">不支持命令语法模式。</entry>
    <entry key="ComplexIntegerArithmetic">代码生成不支持复整数算术。</entry>
    <entry key="ComplexIntegerRelational">不支持对复整数执行比较操作。</entry>
    <entry key="ComplexSlopeBiasFiUnsupported">复数 FI 对象必须具有 2 的整数次幂斜率和 0 偏置。</entry>
    <entry key="ComplexToCharOrLogical">无法将复数值转换为逻辑值或字符值。</entry>
    <entry key="ComplexToLogical">无法将复数值转换为逻辑值。</entry>
    <entry key="NonNumericToComplex">不支持从 {0} 转换为复数。</entry>
    <entry key="ConditionMustBeScalarLogical">条件输入参量必须为标量逻辑值。</entry>
    <entry key="ConditionMustBeScalar">条件输入参数必须为标量。</entry>
    <entry key="ConditionMustBeConvertibleToLogical">条件输入参数必须可转换为逻辑值。</entry>
    <entry key="AssertAlwaysFalse">Assert will always fail. To delay detection until run time use coder.ignoreConst on the condition.</entry>
    <entry key="AssertMithMsgIDAlwaysFalseRuntimeParams">内部错误: 断言在编译时失败，但有运行时参数。要生成适当的错误，如果条件是在编译时为 false，请确保所有消息参数均为编译时常量。\n错误 ID: ''{0}''\n没有参数的错误文本: {1}</entry>
    <entry key="ConflictingDirectives">函数 ''{0}'' 包含冲突的 ''{1}'' 和 ''{2}'' 指令。</entry>
    <entry key="Conjugate">复共轭没有定义为支持此类。</entry>
    <entry key="ConstantFoldingOverFlow">Overflow or saturation occurred during constant folding. Value of this expression cannot be exactly represented in its type.</entry>
    <entry key="ConstantNotEliminated">无法消除此 ''{0}'' 常量。</entry>
    <entry key="CoderLoadUnassignedNotSupported">代码生成不支持使用 ''{0}'' 加载未赋值的元素。''{1}'' 未赋值。</entry>
    <entry key="CoderLoadConstructedOnLoadNotSupported">代码生成不支持使用 ''{0}'' 加载具有 ConstructOnLoad 属性的类。''{1}'' 是标记为 ConstructOnLoad 的类。</entry>
    <entry key="CoderLoadSparseMatrixNotSupported">代码生成不支持加载稀疏矩阵。''{0}'' 是稀疏矩阵。</entry>
    <entry key="ConflictingMethodAttributesWarning">方法 ''{0}'' 既是 {1}，也是 {2}。</entry>
    <entry key="ConflictingMethodAttributesWarningSecondAttrIgnored">方法 ''{0}'' 既是 {1}，也是 {2}。{2} 将被忽略。</entry>
    <entry key="ConstantNotFunction">无法调用此常量。它不是函数。</entry>
    <entry key="ConstantNotLValue">在赋值表达式的左侧发现常量 ''{0}''。在此上下文中只允许使用变量。</entry>
    <entry key="ConstantRequired">非常量表达式或空矩阵。此表达式必须为常量，因为其值用于确定某个表达式的大小或类。</entry>
    <entry key="ConstantCellValuelistIndexRequired">非常量表达式。此表达式必须为常量，因为其值用于确定某个表达式的大小或类。</entry>
    <entry key="ContainsDynamicMatrixType">发现动态矩阵类型。</entry>
    <entry key="ContinueMisplaced">CONTINUE 只能在 FOR 或 WHILE 循环内使用。</entry>
    <entry key="ConversionNotPossible">无法从 {1} 转换为 {0}。</entry>
    <entry key="CouldNotReduceToConstant">\n无法将表达式简化为常量。</entry>
    <entry key="CreateThroughIndexing">如果第一次通过字段访问定义变量 ''{0}''，左侧部分不能包含索引括号，除了最后一个字段之外，所有左侧部分都必须为标量。要创建结构体数组，请使用 ''repmat'' 或 ''struct'' 函数。</entry>
    <entry key="CreateArrayLikeStringNoFillValue">使用 createArray 创建标量字符串数组时，需要 'FillValue' 参量。</entry>
    <entry key="CreateArrayAbstractClassname">为 createArray 生成代码时，classname 参量必须为具体类。</entry>
    <entry key="CreateArrayInvalidClassname">为 createArray 生成代码时，classname 参量不支持类型 ''{0}''。</entry>
    <entry key="CreateArrayInvalidDefaultCtorLikeArg">要在 'Like' 参量是对象时为 createArray 生成代码，对象类必须实现 createArrayLike 方法。或者，对象类必须有返回标量值的默认构造函数。</entry>
    <entry key="CreateArrayInvalidDefaultCtorClassnameArg">要在 classname 参量是对象类时为 createArray 生成代码，此类必须实现 createArray 方法。或者，对象类必须有返回标量值的默认构造函数。</entry>
    <entry key="CreateArrayLikeStruct">为 createArray 生成代码时，'Like' 参量不支持结构体值。此时，请使用 'FillValue' 参量或使用 'classname' 参量指定数组元素的类。</entry>
    <entry key="CreateArrayLikeUnsupportedType">为 createArray 生成代码时，'Like' 参量不支持 ''{0}'' 类型的值。</entry>
    <entry key="CreateArrayLikeUnsupportedSuperclassLikeArg">为 createArray 生成代码时，'Like' 参量不支持从 ''{0}'' 继承的类的实例。</entry>
    <entry key="CreateArrayLikeUnsupportedSuperclassClassnameArg">为 createArray 生成代码时，'classname' 参量不支持从 ''{0}'' 继承的类。</entry>
    <entry key="CreateArrayLikeUnsupportedMethodLikeArg">为 createArray 生成代码时，'Like' 参量不支持实现方法 ''{0}'' 的类实例。</entry>
    <entry key="CreateArrayLikeUnsupportedMethodClassnameArg">为 createArray 生成代码时，'classname' 参量不支持实现方法 ''{0}'' 的类。</entry>
    <entry key="CSizeOfInvalidType">该类型的有效参数为: ''char''、''short''、''int''、''long''、''long long''，但传递的参数为 ''{0}''。</entry>
    <entry key="DefBeforeUsePropertyUndefined">Property ''{0}'' is undefined on some execution paths. For code generation, all variables must be fully defined before use.</entry>
    <entry key="DefBeforeUseFieldUndefined">Structure field ''{0}'' is undefined on some execution paths. For code generation, all variables must be fully defined before use.</entry>
    <entry key="DefBeforeUsePropertyUndefinedSub">无法对属性 ''{0}'' 执行下标赋值，因为属性 ''{1}'' 在某些执行路径中未定义。要进行代码生成，所有变量在使用前都必须完全定义。</entry>
    <entry key="DefBeforeUseFieldUndefinedSub">Unable to perform subscripted assignment of structure field ''{0}'' because field ''{1}'' is undefined on some execution paths. For code generation, all variables must be fully defined before use.</entry>
    <entry key="DefBeforeUsePropUndefinedFcnCall">Property ''{0}'' is undefined on some execution paths but is used inside the called function. For code generation, all variables must be fully defined before use.</entry>
    <entry key="DefBeforeUseInitalValueTypeMismatch">对于属性 ''{0}''，初始值 ''{1}'' 的类型与所赋的值 ''{2}'' 的类型不匹配。</entry>
    <entry key="DefBeforeUseInitalValueContainsUnassigned">属性 ''{0}'' 的初始值包含未赋值的元胞数组元素。对于代码生成，所有元胞数组元素在使用前必须完全定义。</entry>
    <entry key="DefBeforeUseInitalValueValueMismatch">不可调属性 ''{0}'' 的值并非在所有路径中都相同。代码生成要求在所有执行路径中为不可调属性赋予相同的常量值。</entry>
    <entry key="DefBeforeUseDeleterPreconditionNotMetByConstructor">代码生成要求在句柄类析构函数 ''{1}'' 中使用的属性 ''{0}'' 沿构造函数 ''{2}'' 的所有执行路径进行初始化。</entry>
    <entry key="DefBeforeUseFieldUsedFromFcnOutput">函数 ''{1}'' 返回的属性 ''{0}'' 在某些执行路径中未定义。要进行代码生成，所有变量在使用前都必须完全定义。</entry>
    <entry key="DesignRangeInvalidTargetVariable">coder.designRange 的第一个参数必须为当前函数的参数。</entry>
    <entry key="DesignRangeMustAppearBelowSignature">coder.designRange 条目必须紧接在函数签名后。</entry>
    <entry key="DesignRangeMustApplyToNumericData">coder.designRange supports only variables containing numeric data.</entry>
    <entry key="DesignRangeRedefinition">另一个设计范围约束已应用于此变量。</entry>
    <entry key="DesignRangeBoundsMustBeConstants">设计范围最小值和最大值必须为编译时常量。</entry>
    <entry key="DesignRangeBoundsMustBeScalarDouble">Design range minimum and maximum must be scalar doubles.</entry>
    <entry key="DesignRangeBoundsCannotBeNaN">Design range minimum and maximum must not be NaN.</entry>
    <entry key="DesignRangeUpperBoundBelowLowerBound">Design range maximum must be greater than or equal to the design range minimum.</entry>
    <entry key="PersistentVariableSometimesUndefined">持久变量 ''{0}'' 在某些执行路径中未定义。要进行代码生成，所有变量在使用前都必须完全定义。</entry>
    <entry key="FunctionOutputNotAlwaysAssigned">某些执行路径中未定义输出参量 ''{0}''。要进行代码生成，所有变量在使用前都必须完全定义。</entry>
    <entry key="SEAOneDefinition">对于代码生成，必须使用 ''if isempty'' 代码块来构造 System object 并将其存储在持久变量中。</entry>
    <entry key="SEAPersistentAssign">System object 必须赋给持久变量，才能进行代码生成。</entry>
    <entry key="SubVariableSometimesUndefined">无法对变量 {0} 执行下标赋值，因为变量 {0} 在某些执行路径中未定义。要进行代码生成，所有变量在使用前都必须完全定义。</entry>
    <entry key="VariableSometimesUndefined">变量 ''{0}'' 在某些执行路径中未完全定义。要进行代码生成，所有变量在使用前都必须完全定义。</entry>
    <entry key="VariableUndefined">变量 ''{0}'' 未定义。要进行代码生成，所有变量在使用前都必须完全定义。</entry>
    <entry key="DynamicCellArrayNotProvedFullyDefined">无法确定元胞数组 ''{0}'' 的每个元素是否都在此行之前进行了赋值。要进行代码生成，所有元胞数组元素必须在使用前定义。</entry>
    <entry key="DynamicCellArrayNotProvedFullyDefinedExitingEntryPoint">无法确定在退出函数之前是否对元胞数组 ''{0}'' 的每个元素都进行了赋值。要进行代码生成，所有元胞数组元素必须在使用前定义。</entry>
    <entry key="DynamicCellArrayNotProvedFullyDefinedInRecursiveFunction">无法确定元胞数组 ''{0}'' 的每个元素是否都在递归调用的函数中进行了赋值。要进行代码生成，所有元胞数组元素必须在使用前定义。</entry>
    <entry key="IllegalEntryPointMatlabString">入口函数 ''{0}'' 的变量 ''{1}'' 包含使用代码生成不支持的运算的字符串。</entry>
    <entry key="IllegalGlobalMatlabString">全局变量 ''{0}'' 是使用代码生成不支持的运算的字符串或包含这样的字符串。</entry>
    <entry key="IllegalSimulinkBusWithMatlabString">Simulink Bus 类型变量 ''{0}'' 包含一个字符串，该字符串用于代码生成不支持的运算中。</entry>
    <entry key="PersistentSimulinkStringsNotSupported">在 MATLAB Function 模块中，不支持包含 Simulink 字符串的持久变量。</entry>
    <entry key="VariableSizingSimulinkStringNotSupported">在 MATLAB Function 模块中，如果禁用对可变大小数据的支持，则 Simulink 字符串将不受支持。</entry>
    <entry key="IsmethodDoesNotSupportChar">仅当第一个输入是对象时，代码生成才支持对 ismethod 的调用。此处第一个输入是 ''{0}''。</entry>
    <entry key="IsmethodDoesNotSupportHalf">如果第一个输入的类型为 ''{0}''，则代码生成不支持对 ismethod 的调用。</entry>
    <entry key="IncompatibleEmptyAssignment">将大小为 0×0 的表达式视为 {0} {1} 以匹配以后的赋值。</entry>
    <entry key="IncompatibleEmptyCellArray">将 '{}' 视为 cell({0}) 以匹配以后的赋值。</entry>
    <entry key="DMTUnknownUpperBound">计算的最大大小是无界的。</entry>
    <entry key="DMTUnknownUpperBoundCall">函数 ''{0}'' 输出的计算的最大大小是无界的。</entry>
    <entry key="DMTUnknownUpperBoundMultiCall">函数 ''{1}'' 的输出 #{0, number, integer} 的计算的最大大小是无界的。</entry>
    <entry key="DMTUnknownUpperBoundVar">变量 ''{0}'' 的计算的最大大小是无界的。</entry>
    <entry key="DMTUnknownUpperBoundExplanation">\n静态内存分配要求所有大小都是有界的。</entry>
    <entry key="DMTUnknownUpperBoundForStrings">计算的最大大小是无界的。</entry>
    <entry key="DMTUnknownUpperBoundHDLExplanation">\nHDL 代码生成要求所有维度均为固定大小。</entry>
    <entry key="DMTExceedMaxSize">计算的最大大小超过允许的最大元素数({0, number, integer})。</entry>
    <entry key="DMTExceedMaxSize2">计算的数组大小 {0} 超过允许的最大元素数 {1}。</entry>
    <entry key="DMTExceedMaxSizeCall">函数 ''{0}'' 输出的计算的最大大小超过允许的最大元素数({1, number, integer})。</entry>
    <entry key="DMTExceedMaxSizeMultiCall">函数 ''{1}'' 的输出 #{0, number, integer} 的计算最大大小超过允许的最大元素数({2, number, integer})。</entry>
    <entry key="DMTStructFdErr">\n结构体字段 ''{0}'' 的计算的大小为 {1}。</entry>
    <entry key="DMTClassPropErr">\n类属性 ''{0}'' 的计算的大小为 {1}。</entry>
    <entry key="DMTCellElemErr">\n元胞元素 ''{0}'' 的计算的大小为 {1}。</entry>
    <entry key="DMTExceedMaxSizeVar">变量 ''{0}'' 的计算的最大大小超过允许的最大元素数({1, number, integer})。</entry>
    <entry key="DMTErrWoPath">\n计算的大小为 {0}。</entry>
    <entry key="ArrayDimensionExceedMaxSize">数组维度编号 {1, number, integer} 的大小 {0} 超过支持的最大值({2, number, integer})。</entry>
    <entry key="DMTErrorUnknownSrc">\n由于基础分析的限制，可能会报告此错误。</entry>
    <entry key="DSPLicense">这需要 DSP System Toolbox 许可证。</entry>
    <entry key="DimSubMismatchFewer">赋值的非单一 rhs 维数少于非单一下标。</entry>
    <entry key="DimSubMismatchMore">赋值的非单一 rhs 维数多于非单一下标。</entry>
    <entry key="DimensionIsStaticCanNotMakeDynamic">\n维度 {0,number,integer} 无法成为动态维度: 它先前已设置为具有固定大小 {1,number,integer}。</entry>
    <entry key="DuplicateFunctionAttributesTag">对于每个函数或方法，只能指定一次 coder.preserveFunction 或 coder.MethodAttributes。</entry>
    <entry key="DuplicateStructFieldName">字段名称 ''{0}'' 重复。</entry>
    <entry key="DynamicMemoryAllocationOptionOff">\n请考虑启用动态内存分配以允许无界大小。</entry>
    <entry key="EMLAssert">EML_ASSERT 只能识别 ''error'' 和 ''warning'' 类型的消息。</entry>
    <entry key="EMLInvariantIllegalInputs">对 eml_invariant 的调用应采用以下形式之一: \n eml_invariant(cond, eml_message(...)) \n eml_invariant(cond, eml_message(...), "IfNotConst", "CheckAtRunTime") \n eml_invariant(cond, eml_message(...), "IfNotConst", "Fail")。</entry>
    <entry key="EMLInvariantStringMsgId">第二个输入必须为消息标识符。</entry>
    <entry key="EMLMessageIllegalInput">使用 eml_message 时出错。消息中的空位应为字符向量或整数。</entry>
    <entry key="EmbeddedComponentsConcatenationUndefined">串联操作没有定义为支持 System object。</entry>
    <entry key="EmbeddedComponentsNotSupported">此 System object 不支持代码生成。</entry>
    <entry key="EmbeddedComponentsmxArrayInput">输入必须为 mxArray。</entry>
    <entry key="EmlCInterfaceNotAvailable">FIACCEL 不支持 {0}。要调用 C 函数，请使用 CODEGEN (需要 MATLAB Coder 许可证)。</entry>
    <entry key="EmlCInterfaceNotAvailableDV">Simulink Design Verifier 不支持 {0}。</entry>
    <entry key="EmlCInterfaceAnyLayoutNotAvailableDV"> Simulink Design Verifier 不支持 'coder.ceval' 中的 '-layout:any' 标志。</entry>
    <entry key="EmlUpdateBuildInfoNotSupported">Simulink Design Verifier 不支持 {0}。请改为在 '配置参数' 窗口的 '仿真目标' 选项卡中更新自定义代码信息并选择 '启用自定义代码分析' 选项。</entry>
    <entry key="CannotComputeConstantValue">表达式无法简化为常量。</entry>
    <entry key="CannotComputeConstantValue_WithReason">表达式无法简化为常量: {0}</entry>
    <entry key="CannotComputeConstantValue_SeeNextError">表达式无法简化为常量。有关详细信息，请参见下一个错误。</entry>
    <entry key="CannotComputeConstantValue_NextError">前面的错误由以下原因引起: {0}</entry>
    <entry key="CoderConstWrongMultipleOutputs">当 fcn 函数返回多个输出时，请使用语法 [a,b,...] = coder.const(@fcn,x,y,...)。</entry>
    <entry key="EmlNamespaceFunctionName">{0} 是无法识别的关键字。</entry>
    <entry key="EmlPlaceVarsizeBeforeUse">\n将 coder.varsize() 声明放在第一次使用 {0} 之前。</entry>
    <entry key="EmlPlaceVarsizeAfterDef">将 {1} 声明放在对 {0} 的第一次赋值后。</entry>
    <entry key="EmlUpperboundsNotDynamicMatrix">eml_upperbounds() 只能应用于可变大小数组。</entry>
    <entry key="EmlUpperboundsWrongDimensions">此数组有 {0,number,integer} 个维度，但大小向量有 {1,number,integer} 个元素。</entry>
    <entry key="EmlUpperboundsNonReal">大小向量必须有实数值。</entry>
    <entry key="EmlUpperboundsSizeNotConst">大小向量必须为常量。</entry>
    <entry key="EmlVarsizeDimensionCanNotBeFixed">\n{1} 的维度 {0,number,integer} 的大小可变，无法固定。</entry>
    <entry key="EmlVarsizeHasNoEffectOnGlobals">coder.varsize() 对全局变量不起作用。\n请使用命令行 -globals 开关中的 coder.Type 来定义可变大小的全局变量。</entry>
    <entry key="EmlVarsizeInfFixedDimSize">固定大小维度 {0,number,integer} 具有上界 Inf。系统不支持这种情况。</entry>
    <entry key="EmlVarsizeLargeFixedDimSize">维度 {1,number,integer} 上的固定大小 {0,number,integer} 大于或等于 intmax()。系统不支持这种情况。</entry>
    <entry key="EmlVarsizeLargeStaticMatrix">numel 大于或等于 intmax() 的固定大小矩阵。系统不支持这种情况。</entry>
    <entry key="EmlVarsizeOnlyColonIndexAllowed">coder.varsize() 的输入中只允许使用冒号索引: coder.varsize(''variable.field1(:).field2'')，但不能使用 coder.varsize(''var.field1(1).field2'')。</entry>
    <entry key="EmlVarsizeRedefinition">对同一对象 {0} 应用了冲突的 coder.varsize() 指令。</entry>
    <entry key="EmlVarsizeSuggestedUpperBoundDiffersFromPresetOne">无法更改维度 {0,number,integer} 的预定义上界。预定义的上界为 {1,number,integer}，请求的上界为 {2,number,integer}。</entry>
    <entry key="EmlVarsizeSyntaxErrorInPath">coder.varsize() 的输入中有语法错误。</entry>
    <entry key="EmlVarsizeThirdInputMustBeLogicalVector">coder.varsize() 的最后一个输入必须为逻辑值向量。</entry>
    <entry key="EmlVarsizeThirdInputSizeMismatch">变量的维数(第一个输入)和最后一个输入的大小必须匹配。</entry>
    <entry key="EmlVarsizeTooFewDimensionsGiven">对象 ''{0}'' 的维数超过 coder.varsize() 中提供的维数: {1,number,integer} &gt; {2,number,integer}。</entry>
    <entry key="EmlVarsizeUseInfWithoutMalloc">将上界大小声明为 Inf 需要使用动态内存分配。要允许无界大小，请启用动态内存分配。</entry>
    <entry key="EmlVarsizeVariableIsLocked">无法修改 {0} 的大小，因为变量 ''{1}'' 已锁定。</entry>
    <entry key="EmlVarsizeZeroUpperBoundUnsupported">为维度 {0,number,integer} 指定了零上界。</entry>
    <entry key="EmlVarsizeUnsupportedClass">coder.varsize() 不适用于 ''{0}''。</entry>
    <entry key="EmlVarsizeHeterogeneousCellUnsupported">coder.varsize() 不支持异构元胞数组。</entry>
    <entry key="EmlVarsizeCellParenIndexingUnsupported">coder.varsize() 不支持使用 ''()'' 对元胞数组进行索引。请使用 '''{}''' 索引来访问元素，或不使用索引来访问元胞数组本身。</entry>
    <entry key="EmptyIndexStructArray">索引导致了空结构体数组。不支持空结构体数组。</entry>
    <entry key="EmptyPersistent">不支持将空数组赋给持久变量。</entry>
    <entry key="EmptyStructArray">不支持空结构体数组。</entry>
    <entry key="EnumCannotConvert">无法将输入数组转换为 ''{0}'' 枚举类，因为并非所有元素都在枚举列表中。</entry>
    <entry key="EnumEmptyConstructorCall">''{0}'' 是枚举值，不能用作空函数调用。</entry>
    <entry key="EnumInvalidConst">''{1}'' 中未定义枚举值 ''{0}''。</entry>
    <entry key="EnumInvalidUse">尝试在没有元素引用的情况下使用枚举 ''{0}''。</entry>
    <entry key="EnumsNotAllowed">此处不允许使用枚举类型。该表达式属于枚举类 ''{0}''。</entry>
    <entry key="EnumsNotAllowedForLibraryFcn">Function ''{0}'' does not allow enumeration types. The argument is of class ''{1}'' which is an enumeration.</entry>
    <entry key="HalfNotAllowedForLibraryFcn">函数 ''{0}'' 不允许使用半精度类型。</entry>
    <entry key="HalfComplexSupport">代码生成不支持半精度复数类型。</entry>
    <entry key="NativeHalfTypeCPPSupport">本机半精度类型仅支持 C 目标。使用模拟半精度库时支持 C++ 目标。</entry>
    <entry key="HalfArithmeticOperationUnsupported">对于半精度类型，代码生成仅支持数值类型的算术运算。其中一个操作数的类型为 ''{0}''。</entry>
    <entry key="HalfRelationalOperationUnsupported">对于半精度类型，代码生成仅支持数值或逻辑类型的关系运算。其中一个操作数的类型为 ''{0}''。</entry>
    <entry key="EntryPointMustBeExported">''{0}'' 是入口函数，必须导出。</entry>
    <entry key="EnumCompareString">Code generation does not support comparing an enumeration to a character array, string, or cell array with the operators '==', '~=', or 'isequal'.</entry>
    <entry key="EnumOverloadedRelop">枚举 ''{0}'' 正在重载运算符 ''{1}''，代码生成不支持此操作。</entry>
    <entry key="ErrorLimitReached">已达错误上限。将隐藏后续错误消息。</entry>
    <entry key="ExpectedAnEnum">需要枚举值。</entry>
    <entry key="ExpectedCharString">Expected a character vector.</entry>
    <entry key="ExpectedCellstr">需要字符向量元胞数组。</entry>
    <entry key="ExpectedFIMATH">需要 FIMATH 对象，但找不到。</entry>
    <entry key="ExpectedFunctionHandle">需要函数句柄。但找到的是 {0}。</entry>
    <entry key="ExpectedFunctionHandleOrDirectCall">需要函数句柄，或用圆括号直接调用。</entry>
    <entry key="AmbiguousCallInMatlabExecution">此调用语法(一个不带参数的函数句柄)在 MATLAB 执行中会有多义性。请使用圆括号直接调用函数参数。</entry>
    <entry key="Unexpected">非预期的 {0}。</entry>
    <entry key="ExpectedNonEnumerationClass">需要非枚举类。但找到的是 {0}。</entry>
    <entry key="ExpectedInteger">需要整数。但找到的是类 {0}。</entry>
    <entry key="ExpectedIntegerValue">需要可以 ''int32'' 表示的整数值。</entry>
    <entry key="ExpectedIntegerValueInRangeOf">Expected an integer value in the range {0,number,integer}-{1,number,integer}.</entry>
    <entry key="ExpectedNonnegativeIntegerValue">Expected a nonnegative integer value.</entry>
    <entry key="ExpectedNonComplex">Found a complex value. A real value was expected. Use the functions REAL or IMAG to make this value real if appropriate.</entry>
    <entry key="ExpectedNumeric">需要数值。但找到的是 {0}。</entry>
    <entry key="ExpectedNumericType">需要数值类型。</entry>
    <entry key="ExpectedNumericVector">需要数值向量。</entry>
    <entry key="ExpectedScalarBoolean">需要标量布尔值。</entry>
    <entry key="ExpectedScalarNumeric">需要数值标量。</entry>
    <entry key="ExpectedScalarStruct">应为标量结构体。</entry>
    <entry key="ExpectedScalarNumericAsDouble">Expected a scalar numeric value representable as double.</entry>
    <entry key="OutOfIndexingRange">对于类型为 ''{1}'' 的索引，值 ''{0}'' 超出范围。</entry>
    <entry key="ExpectedScalarString">需要向量而不是字符矩阵。</entry>
    <entry key="ExpectedScalarVerbose">需要标量值。此表达式的大小为 {0}。</entry>
    <entry key="ExpectedTargetIntegerValue">需要可表示为目标 ''int'' 类型的整数值。</entry>
    <entry key="ExpectedUnsignedInteger">需要无符号整数。但找到的是类 {0}。</entry>
    <entry key="ExpectedVector">需要向量表达式。</entry>
    <entry key="ExpectedVectorOfPositiveIntegers">需要一个正整数向量。</entry>
    <entry key="ExpressionTooLarge">此表达式太大。请将部分结果存储在临时变量中，以将表达式拆分成若干更小的部分。</entry>
    <entry key="ExpressionUnsupported">This kind of expression is not supported.</entry>
    <entry key="ExtrinsicArg">coder.extrinsic 的参数必须为函数名称。</entry>
    <entry key="ExtrinsicCallInsideParallelRegion">不支持在并行 FOR 循环中调用外部函数。</entry>
    <entry key="ExtrinsicMisplaced">函数 ''{0}'' 在使用后标记了 coder.extrinsic。</entry>
    <entry key="ExtrinsicTopLevel">对 coder.extrinsic 的调用可能只出现在顶层。</entry>
    <entry key="FailSharedRestricted">调用方 ''{0}'' 无权共享受限资源 ''{1}''。</entry>
    <entry key="FailSharedRestrictedCallerPath">共享受限资源 ''{0}'' 的调用方路径: ''{1}''。</entry>
    <entry key="FailSharedRestrictedCalleePath">共享受限资源 ''{0}'' 的路径: ''{1}''。</entry>
    <entry key="FailSharedRestrictedNoDispatcher">无法共享受限资源 ''{0}'': MATLAB 调度程序不存在。</entry>
    <entry key="FailSharedRestrictedNotOnMATLABPath">无法共享受限资源 ''{0}'': ''{1}'' 不在 MATLAB 路径中。</entry>
    <entry key="FailSharedRestrictedNotValidDirectory">无法共享受限资源 ''{0}'': 路径 ''{1}'' 不包含有效目录。</entry>
    <entry key="FailSharedRestrictedNotDirCaller">无法共享受限资源 ''{0}'': 路径 ''{1}'' 不包含许可的目录。</entry>
    <entry key="FcnNeedsRuntime">''{0}'' 需要使用 EMLRT，并且只能与 MEX 和 S-Function 目标结合使用。</entry>
    <entry key="FieldNameConstantQualifier">\n字段名称必须为常量。</entry>
    <entry key="FieldValuePair">字段和值输入参数必须成对出现。</entry>
    <entry key="FileMgrCmdNotConst">提供的操作无效。它必须为以下各项之一: ''open''、''close''、''filestar''、''autoflush''、''list''、''closeall'。</entry>
    <entry key="FileMgrCmdNotFound">提供的操作 ''{0}'' 无效。它必须为以下各项之一: open、close、filestar、autoflush、list、closeall。</entry>
    <entry key="FileMgrNargin">提供的操作 ''{0}'' 需要 ''{1}'' 个参数。</entry>
    <entry key="FimathIsLocalArg1">EML_FIMATHISLOCAL 的第一个参数必须为定点。</entry>
    <entry key="FimathMismatch">fimath 对象的属性必须匹配。</entry>
    <entry key="FimathMismatchOnField">字段 ''{0}'' 中 fimath 对象的属性必须匹配。</entry>
    <entry key="FimathMismatchOnCell">元胞 ''{0}'' 中 fimath 对象的属性必须匹配。</entry>
    <entry key="FixedPointLicense">这需要 Fixed-Point Designer 许可证。</entry>
    <entry key="FixedPointSize">定点类型不能超过 {0,number,integer} 位；已有 {1,number,integer} 位。</entry>
    <entry key="FixedPointSubsAsgnLhsFIRhsEnum">subsasgn 运算中运算符 ''='' 右侧的操作数不能为枚举值。</entry>
    <entry key="EndPlus1SubsAsgnLhsNdVectorNotSupported">不支持对具有两个以上维度的向量使用 ''end + 1'' 进行下标索引。</entry>
    <entry key="EndPlus1RequiresVariableSizing">要使用 ''end + 1'' 对元胞数组或数组进行下标索引，请在代码生成中启用对可变大小数组的支持。将代码配置属性 EnableVariableSizing 设置为 true，或在 MATLAB Coder 中启用 "启用可变大小" 参数。</entry>
    <entry key="EndPlus1ConflictsWithCoderVarsize">无法使用(end + 1)增大数组 {0}，因为 coder.varsize 指令指示 {0} 的所有维度均为固定大小维度。请修改 coder.varsize 指令，使 {0} 至少有一个维度为可变大小。</entry>
    <entry key="EndPlus1SubsAsgnLhsMultiIndexingNotSupported">不支持使用 ''end+1'' 对元胞数组或数组进行多维索引。</entry>
    <entry key="EndPlus1SubsAsgnLhsMultiOutputNotSupported">从返回多个输出的函数进行赋值时，不支持使用 ''end+1'' 对数组进行下标索引。</entry>
    <entry key="EndPlus1SubsAsgnLhsModularIndexingNotSupported">代码生成不支持使用 ''end + 1'' 对 ''{0}'' 进行下标索引。</entry>
    <entry key="EndPlus1SubsAsgnLhsNonVectorNotSupported">不支持用 ''end + 1'' 通过下标对非向量元胞数组或数组进行索引。</entry>
    <entry key="EndPlus1SubsAsgnLhsFieldOrClosureNotSupported">结构体字段、对象属性或属于父函数的工作区的嵌套函数变量不支持使用 ''end + 1'' 通过下标进行索引。</entry>
    <entry key="EndPlus1SubsAsgnLhsNonVariableNotSupported">仅支持对变量使用 ''end + 1'' 进行下标索引。</entry>
    <entry key="EndPlus1GrowColumnAsRow">变量 ''{0}'' 指定为大小为 {1} 的列向量，但用 ''end+1'' 进行下标索引会产生一个大小为 {2} 的行向量。要作为列追加到 ''{0}''，请使用 ''{0} = [{0}; newValue];''。</entry>
    <entry key="EnumerationDataScopeIncorrecValue">''{0}.getDataScope'' 返回的数据作用域无效。数据作用域必须为 "自动"、"导入" 或 "导出"。</entry>
    <entry key="FixedPointType">不支持的定点类型。</entry>
    <entry key="FixedVariableSizeMismatch">\n不匹配的可变和固定大小表明可能存在运行时错误。如果此诊断不正确，请使用索引来显式使可变大小变为固定大小。</entry>
    <entry key="ForLoopIndexMCOS">不支持对 MATLAB 类进行 FOR 循环迭代。</entry>
    <entry key="ForLoopCellOneRow">要在代码生成中对元胞数组使用 FOR 循环迭代，元胞数组的第一个维度的大小必须恰好为 1。</entry>
    <entry key="ForLoopCellUnassignedElement">当对元胞数组使用 FOR 循环迭代时，代码生成仅支持使用所有元素都已赋值的元胞数组。</entry>
    <entry key="ForLoopCellHeterogeneousRequireUnroll">对异构元胞数组使用 FOR 循环迭代时，请使用 ''coder.unroll'' 展开循环。</entry>
    <entry key="ForLoopIndexFi">不支持对 embedded.fi 对象进行 for 循环迭代。请重写循环以使用独立索引变量访问 embedded.fi 对象中的数据。</entry>
    <entry key="ForLoopIndexFunctionHandle">不支持对函数句柄进行 FOR 循环迭代。</entry>
    <entry key="ForLoopIndexIncompatible">索引变量 {0} 在其对应的 FOR 循环之外使用。如果不执行循环，其运行时行为将不同于 MATLAB。</entry>
    <entry key="ForLoopIndexGlobalIncompatible">索引变量 {0} 是全局变量，因此它可能在其对应的 FOR 循环之外使用。如果不执行循环，其运行时行为将不同于 MATLAB。</entry>
    <entry key="ForLoopIndexMxArray">不支持使用 mxArray 索引进行 FOR 循环。</entry>
    <entry key="ForLoopIndexOutputIncompatibility">输出 {0} 被用作 FOR 循环的索引变量。如果不执行循环，其运行时行为将不同于 MATLAB。</entry>
    <entry key="ForLoopIndexRowsUnknown">FOR 循环索引表达式的行数未知。</entry>
    <entry key="ForLoopIndexUnknown">FOR 循环索引表达式有未知的类。</entry>
    <entry key="ForLoopUnknownSpecial">大小未知的 FOR 循环索引表达式仅在其形式为 A:B 或 A:B:C 时才受支持。</entry>
    <entry key="FunctionCallFailed">函数调用失败。</entry>
    <entry key="FunctionCallFailedFAV">函数调用失败: 位置 {0,number,integer} 处的参数无效。</entry>
    <entry key="FunctionCallFailedFAVDefault">函数调用失败: 位置 {0,number,integer} 处的默认值无效。</entry>
    <entry key="FunctionCallFailedName">调用函数 ''{0}'' 失败。</entry>
    <entry key="FunctionCallWarned">被调函数产生了警告。</entry>
    <entry key="FunctionHandleCanNotBeUsedHere">此处无法使用函数句柄。</entry>
    <entry key="FunctionHandleTypeMismatch">类型不匹配: MATLAB Coder 无法确定函数句柄 {0} 与 {1} 的等效性。</entry>
    <entry key="FunctionHandleUnsupportedForCcalls">C 调用不支持函数句柄。</entry>
    <entry key="FunctionHandleUnsupportedForCcallsWithin">C 调用不支持包含函数句柄的 {0}。</entry>
    <entry key="FunctionHandleUnsupportedForCeval">''coder.ceval'' 不支持函数句柄。</entry>
    <entry key="FunctionHandleUnsupportedForCevalWithin">''coder.ceval'' 不支持包含函数句柄的 {0}。</entry>
    <entry key="FunctionHandleUnsupportedForMATLABCalls">函数句柄无法传递给外部函数。</entry>
    <entry key="FunctionHandleUnsupportedForMATLABCallsWithin">包含函数句柄的 {0} 无法传递给外部函数。</entry>
    <entry key="FunctionHandleUnsupportedForMxArrayValues">函数句柄无法实现与 mxArray 值之间的转换。</entry>
    <entry key="FunctionHandleUnsupportedForMxArrayValuesWithin">包含函数句柄的 {0} 无法实现与 mxArray 值之间的转换。</entry>
    <entry key="FunctionHandleUnsupportedForOutput">函数输出 ''{0}'' 不能为函数句柄。</entry>
    <entry key="FunctionHandleUnsupportedForOutputWithin">函数输出 ''{0}'' 不能是包含函数句柄的 {1}。</entry>
    <entry key="FunctionHandleUnsupportedForSave">无法将函数句柄传递给 ''save''。</entry>
    <entry key="FunctionHandleUnsupportedForSaveWithin">包含函数句柄的 {0} 无法传递给 ''save''。</entry>
    <entry key="FunctionHandleUnsupportedForStateflowCalls">Stateflow 调用不支持函数句柄。</entry>
    <entry key="FunctionHandleUnsupportedForStateflowCallsWithin">Stateflow 调用不支持包含函数句柄的 {0}。</entry>
    <entry key="FunctionPointerNotSupportedHere">此处不支持函数指针。</entry>
    <entry key="FunctionPointerNotSupported">代码生成不支持函数指针。</entry>
    <entry key="FunctionHasNoVararg">此函数没有 ''{0}''。</entry>
    <entry key="FunctionInputArity">函数 ''{0}'' 需要 {1,number,integer} 个输入；找到 {2,number,integer} 个。</entry>
    <entry key="FunctionNotLValue">在赋值表达式的左侧发现函数 ''{0}''。在此上下文中只允许使用变量。</entry>
    <entry key="FunctionNotSupportedForCodeGeneration">代码生成不支持函数 ''{0}''。</entry>
    <entry key="FunctionOutputMxArray">在此上下文中，代码生成不支持此函数的 mxArray 输出。请使用已知类型初始化输出变量 {0}。</entry>
    <entry key="FunctionOutputSEA">函数输出 ''{0}'' 不能为 System object。</entry>
    <entry key="FunctionSizeQualifier">\n左侧的大小是函数输入的指定大小。</entry>
    <entry key="FunctionStructClassQualifier">\n左侧的结构体是函数输入的指定类。</entry>
    <entry key="GetFieldIndex">索引 ''{0,number,integer}'' 不是有效的字段索引。</entry>
    <entry key="GetfieldArg1">第一个参数必须为结构体类型。</entry>
    <entry key="GlobalMisplaced">请在使用之前将 ''{0}'' 声明为全局变量。</entry>
    <entry key="GlobalTopLevel">GLOBAL 声明只能出现在顶层。</entry>
    <entry key="GlobalUnexpectedValue">Found unsupported global data initialization class for global variable ''{0}''.</entry>
    <entry key="GlobalUninitialized">找不到全局变量 ''{0}'' 的初始值。</entry>
    <entry key="GlobalUnsupported">不支持: GLOBAL 变量。</entry>
    <entry key="GlobalMCOSUnsupported">代码生成不支持保留 MATLAB 类实例的全局变量。</entry>
    <entry key="GlobalHandleSEAUnsupported">代码生成不支持包含句柄类或 System object 的全局变量。</entry>
    <entry key="MultiInheritanceSameNamedPropertyAbstractUnsupported">当每个超类都有同名的属性且其中一个超类中的属性是抽象属性时，代码生成不支持从这些超类进行多重继承。属性 ''{0}'' 在超类 ''{1}'' 中是抽象属性，而在超类 ''{2}'' 中不是抽象属性。</entry>
    <entry key="GlobalSparseUnsupported">代码生成不支持作为稀疏矩阵或包含稀疏矩阵的全局变量。</entry>
    <entry key="GlobalOpaqueUnsupported">代码生成不支持 coder.opaque 类型的全局变量。</entry>
    <entry key="GlobalIncompatibleValue">全局变量 ''{0}'' 的初始值与其类型不匹配。</entry>
    <entry key="LoadFailed">无法加载文件 ''{0}''。</entry>
    <entry key="LoadFailedWithCause">无法加载文件 ''{0}'': {1}</entry>
    <entry key="HalfPrecisionLicense">使用半精度数据类型需要 Fixed-Point Designer 或 MATLAB Coder 许可证。</entry>
    <entry key="HalfTypeNotSupportedForTarget">当前代码生成目标不支持 'half' 类型。</entry>
    <entry key="BuiltInFcnConstArg">''{0}'' 函数的所有参数都必须为编译时常量。</entry>
    <entry key="UpdateBuildInfoFailed">无法将 ''{0}'' 方法应用于 BuildInfo。</entry>
    <entry key="UpdateBuildInfoFailedWithCause">无法将 ''{0}'' 方法应用于 BuildInfo: {1}</entry>
    <entry key="LoadFileNotFound">找不到在加载函数中指定的文件 ''{0}''。</entry>
    <entry key="LoadNeedsMATLAB">独立代码生成不支持函数 {0}。请或者更改目标以生成启用了外部调用的 MEX 或 S-Function，或者使用 {1} 以在编译时加载 MAT 文件。</entry>
    <entry key="LoadFileNameNotConstant">''load'' 的文件名参数必须为常量字符串或字符向量。</entry>
    <entry key="LoadSimpleAssignment">函数 ''{0}'' 只能用作不带下标的结构体或数组变量的简单赋值的右侧。</entry>
    <entry key="LoadSingleOutput">调用 ''{0}'' 产生的输出未赋给变量。请将其输出赋给变量(不使用下标索引)。</entry>
    <entry key="LoadUnexpectedValue">使用函数 ''{0}'' 时发现不支持的变量类。</entry>
    <entry key="LoadUnexpectedValueHint">使用命令 ''whos -file {0}'' 查看 MAT 文件中的变量。</entry>
    <entry key="CoderHardwareSettingsUndefined">关于代码生成器硬件设置的信息在当前上下文中不可用。</entry>
    <entry key="CoderHardwareSettingUndefined">The coder hardware setting ''{0}'' is not available in the current context.</entry>
    <entry key="CoderHardwareFailedWithCause">无法获取代码生成器硬件设置 ''{0}'': {1}</entry>
    <entry key="CoderHardwareFailed">无法获取代码生成器硬件设置 ''{0}''。</entry>
    <entry key="IBifUnsupported">尚不支持此内置函数。</entry>
    <entry key="IDPCountMismatch">Incorrect number of input arguments for ''{0}''. Expected {1,number,integer}, but found {2,number,integer}.</entry>
    <entry key="IDPCountMismatchCausedBy">为入口函数 ''{0}'' 指定的输入参数太多。这可能是由以下原因引起的: {1}</entry>
    <entry key="ODPCountMismatch">''{0}'' 的输出参数的数目不正确。需要 {1,number,integer} 个，但找到 {2,number,integer} 个。</entry>
    <entry key="IfWhileNonScalar">代码生成不支持对非标量进行逻辑运算。请使用函数 ''any'' 或 ''all'' 将逻辑矩阵简化为其标量等效项。</entry>
    <entry key="IllegalBaseTypeConversion">无法在这两个基类型之间进行转换。</entry>
    <entry key="IllegalExtrinsic">{0} 指令无法应用于 ''{1}''。请删除此函数对 {2} 的调用。</entry>
    <entry key="IllegalLogicalType">应为可表示零的 logical、char、int、single、double 或 fi。但找到的是 {0}。</entry>
    <entry key="IllegalMatlabType">应为 logical、char、int、fi、single 或 double。但找到的是 mxArray。MxArray 是从对 MATLAB 解释器的调用中返回的，在表达式内部不受支持。它们只能用在赋值的右侧并作为外部函数的参数。</entry>
    <entry key="IllegalMultiOutput">函数 ''{0}'' 不能返回多个输出。</entry>
    <entry key="IllegalMultiOutputUnknown">此函数不能返回多个输出。</entry>
    <entry key="IllegalSizeVector">大小向量必须是包含整数元素的行向量。</entry>
    <entry key="IllegalType">应为 logical、char、int、fi、single 或 double。但找到的是 {0}。</entry>
    <entry key="IllegalTypeConversion">无法在这两种类型之间转换。</entry>
    <entry key="IllegalUseOfEnd">非法使用保留关键字 ''end''。</entry>
    <entry key="IllegalUseOfStrcmp">STRCMP 只能应用于字符值。</entry>
    <entry key="ImplicitMatlabResolution">代码生成不支持函数 {0}。请使用 coder.extrinsic(''{1}'') 绕过此函数的代码生成。</entry>
    <entry key="ImplicitMatlabMethodResolution">代码生成不支持类 {1} 的方法 {0}。请使用 coder.extrinsic(''{2}'') 绕过此函数的代码生成。</entry>
    <entry key="ImplicitMatlabEnumMethodResolution">代码生成不支持枚举 {1} 的方法 {0}。请使用 coder.extrinsic(''{2}'') 绕过此函数的代码生成。</entry>
    <entry key="ImplicitMatlabResolutionUnsupported">代码生成不支持函数 ''{0}''，并且 {1} 指令无法应用于 ''{2}''。</entry>
    <entry key="ImportNotAllowedHere">导入语句只允许作为函数定义后的前导语句。</entry>
    <entry key="ImportNamespaceMustBeEmlpkg">导入语句只支持 emlpkg.* 形式的命名空间。</entry>
    <entry key="ImportNamespaceNotConstant">\n导入命名空间必须为常量表达式。</entry>
    <entry key="ImportUnsupported">当前不支持导入语句。</entry>
    <entry key="ImproperOperarorUse">运算符使用不当。</entry>
    <entry key="IncorrectInputArgumentCounts">输入参数数目不正确。{0} 只接受恰好 {1,number,integer} 个输入(找到 {2,number,integer} 个)。</entry>
    <entry key="IndexComplex">下标索引不能为复数。</entry>
    <entry key="IndexLogical">逻辑索引需支持可变大小数组，但当前被禁用。</entry>
    <entry key="IndexLogicalVarsizeBlocked">要使用逻辑索引，请启用可变大小数组。</entry>
    <entry key="IndexMatrixDynamic">带下标的矩阵的大小不是静态已知的。</entry>
    <entry key="IndexMxArray">不支持 mxArray 索引。请将索引表达式赋给已知类型的变量，然后使用此变量对数组进行索引。</entry>
    <entry key="IndexNonNumeric">下标索引必须为内置的数值类。此索引的类为 ''{0}''。</entry>
    <entry key="IndexOutOfBounds">数组元素 {0,number,integer} 超出边界。请修改索引表达式以访问范围 {1,number,integer}-{2,number,integer} 内的元素。</entry>
    <entry key="IndexOutOfBoundsLhs">数组元素 {0,number,integer} 越界，因为代码生成不支持以这种方式使用索引增大数组。请修改索引表达式以访问 {1,number,integer} - {2,number,integer} 范围内的元素，或将数组显式定义为可变大小。</entry>
    <entry key="VariableCreatedByIndexing">变量 ''{0}'' 尚未赋值。要给变量赋值，请使用完整赋值，而不要使用下标。代码生成不支持通过索引创建数组。</entry>
    <entry key="VariableCreatedByIndexingConst">变量 ''{0}'' 尚未赋值。要给变量赋值，请使用完整赋值，而不要使用下标。代码生成不支持通过索引创建数组。</entry>
    <entry key="IndexIntOutOfBounds">索引表达式越界。尝试访问元素 {0,number,integer}。目标整数类型可表示的最大值为 {1}。</entry>
    <entry key="IndexSizeDimensionMismatch">此索引表达式有 {0,number,integer} 个维度，但大小向量有 {1,number,integer} 个元素。</entry>
    <entry key="IndexSizeDynamic">索引表达式的大小不是静态已知的。</entry>
    <entry key="InlineParadox">矛盾的指令既强制又阻止此函数的内联。将采用最后一个设置。</entry>
    <entry key="ExportParadox">矛盾的指令既强制又阻止导出此函数。将采用最后一个设置。</entry>
    <entry key="MajorityParadox">无法多次指定一个函数的数组布局。</entry>
    <entry key="MajoritySetAfterCheck">在调用 coder.isRowMajor 或 coder.isColumnMajor 后，无法在函数中指定数组布局。</entry>
    <entry key="MajorityNoClasses">行优先函数不支持的类。</entry>
    <entry key="MajorityCevalMultipleDefinitions">无法对同一个 coder.ceval 声明使用多个数组布局定义。</entry>
    <entry key="MajorityWrongExternalFcnMajority">Invalid global array layout mode for the external functions ''{0}''. Supported modes are : ''column'', ''row'' or ''any''.</entry>
    <entry key="MajorityUnsupportedClient">Current code generation workflow does not support row-major data types in {0}.</entry>
    <entry key="ImageUnsupportedClient">当前代码生成工作流不支持 {0} 中的图像数据类型。</entry>
    <entry key="MajorityNoVarSizeIOWhenHaveRowMajor">不支持包含可变大小矩阵或符号维度的入口函数参数，因为 {0} 包含行优先数据类型。</entry>
    <entry key="MajorityHeterogenousVarRow">变量 ''{0}'' 包含以行优先数组布局存储的数据。这与为第一个入口函数指定的列优先数组布局冲突。请对此变量中包含的所有数据使用列优先布局。</entry>
    <entry key="MajorityHeterogenousVarColumn">变量 ''{0}'' 包含以列优先数组布局存储的数据。这与为第一个入口函数指定的行优先数组布局冲突。请对此变量中包含的所有数据使用行优先布局。</entry>
    <entry key="MajorityHeterogenousFcnRow">函数 ''{0}'' 必须使用列优先数组布局。所有入口函数必须具有与第一个入口函数相同的数组布局设定。</entry>
    <entry key="MajorityHeterogenousFcnColumn">函数 ''{0}'' 必须使用行优先数组布局。所有入口函数必须具有与第一个入口函数相同的数组布局设定。</entry>
    <entry key="MajorityAliasBreakForOverlaps">当参数 {0,number,integer} 和 {1,number,integer} 在内存中可能重叠时，不支持更改其数组布局。请将这些参数合并成一个参数。</entry>
    <entry key="MethodAttributesOutsideClass">''{0}'' 只能在类方法中使用。</entry>
    <entry key="MethodMajorityNotAllowed">方法不能包含 coder.rowMajor 或 coder.columnMajor 指令。</entry>
    <entry key="MaxNumberDimensions">代码生成不支持超过 {0,number,integer} 个维度的数组。此数组有 {1,number,integer} 个维度。</entry>
    <entry key="ClassMajorityMismatch">基类和子类数组布局不匹配。</entry>
    <entry key="MajorityCheckOnNonMatrixVar">coder.isRowMajor 和 coder.isColumnMajor 的参数必须为矩阵变量。</entry>
    <entry key="GlobalTopMajorityMismatch">顶层函数的数组布局不能与全局函数的数组布局不同。</entry>
    <entry key="IndexRangeError">索引 {0,number,integer} 超过元素数({1,number,integer})。</entry>
    <entry key="InputSizeMismatch">大小不匹配。输入 {0,number,integer} 要求大小值为 {1}。但发现的大小为 {2}。</entry>
    <entry key="InrecognizedOperatorOption">无法识别的运算符选项。</entry>
    <entry key="IntegerCombination">无法将 ''{0}'' 与 ''{1}'' 组合。整数只能与同类的整数或与双精度标量值组合使用。</entry>
    <entry key="InternalError">\n内部错误: 此错误发生在 MathWorks 函数内部。</entry>
    <entry key="InvalidCClassName">C 类名称无效。</entry>
    <entry key="InvalidClassName">最后一个参数的值 ''{0}'' 无效。</entry>
    <entry key="InvalidComplexToNonComplexAssignment">无法将复数值赋给非复数位置。</entry>
    <entry key="InvalidEnumField">枚举类 ''{1}'' 没有名为 ''{0}'' 的成员。</entry>
    <entry key="InvalidEnumAccess">无法从变量访问枚举常量 ''{0}''。请使用枚举名称: ''{1}.{0}''。</entry>
    <entry key="InvalidFloatClassName">尾部输入必须为 ''single'' 或 ''double''。</entry>
    <entry key="InvalidInlineMode">内联模式 ''{0}'' 无效。仅支持 ''always''、''never'' 和 ''default''。</entry>
    <entry key="InvalidAttributeName">''{0}'' 不是 ''{1}'' 的有效选项名称。</entry>
    <entry key="ConflictingMethodAttributes">方法 ''{0}'' 是 ''{1}''，因此属性 ''{1}'' 不适用。</entry>
    <entry key="InvalidPropertyMode">属性模式 ''{0}'' 无效。仅支持 ''associative'' 和 ''commutative''。</entry>
    <entry key="InvalidReductionOperation">归约运算无效。</entry>
    <entry key="DifferentReductionTypes">有归约使用了不同类型。当前类型为 ''{0}''。以前的类型为 ''{1}''。</entry>
    <entry key="InvalidReductionOperationCommAssoc">不支持的归约运算。</entry>
    <entry key="InvalidReductionOperationNonBinary">归约运算无效。仅支持二元运算。</entry>
    <entry key="InvalidReductionOperationConcat">归约运算无效。在 MATLAB Coder 中，不支持串联形式的归约。</entry>
    <entry key="InvalidNonComplexToComplexAssignment">不支持将非复数值隐式赋给嵌套的复数位置(字段 ''{0}'')。</entry>
    <entry key="InvalidOption">代码生成选项 ''{0}'' 的值无效。</entry>
    <entry key="InvalidStructFieldName">Invalid field name ''{0}''</entry>
    <entry key="IsDefinedExpectsObjectProperty">此内置函数的输入必须为 ''object.property''。</entry>
    <entry key="MCOSBuiltinRequiresNontunableProperty">此内置函数仅支持不可调属性。</entry>
    <entry key="LhsClassQualifier">\n左侧的类是赋值左侧的类。</entry>
    <entry key="LhsRhsComplexMismatch">左侧已约束为非复数，但右侧为复数。要更正此问题，请使用函数 REAL 确保右侧为实数，或使用 COMPLEX 函数确保左侧变量的初始赋值为复数值。</entry>
    <entry key="LhsRhsSizeMismatch">左侧和右侧必须有相同数量的元素。</entry>
    <entry key="LhsSizeQualifier">\n左侧的大小是赋值左侧的大小。</entry>
    <entry key="LhsStructClassQualifier">\n左侧的结构体是赋值左侧的类。</entry>
    <entry key="LibAssertRequiresExactlyThreeInputs">eml_lib_assert() 要求三个输入: 条件、消息 ID、消息文本。</entry>
    <entry key="LicenseCheck">此函数的编译需要涵盖 ''{0}'' 功能的许可证。</entry>
    <entry key="LicenseCheckoutFailed">无法获取函数 ''{1}'' 所需的许可证 ''{0}''。</entry>
    <entry key="LicenseMode">coder.license 的第一个输入必须为 'checkout'。</entry>
    <entry key="LicenseListMustBeConstant">许可证列表必须为常量。</entry>
    <entry key="LockedOption">选项 ''{0}'' 已锁定，无法更改。</entry>
    <entry key="LooksLikeScript">代码生成不支持脚本。请定义一个入口函数。</entry>
    <entry key="LoopTooBigForAutomaticUnroll">循环展开失败，因为展开的循环体的大小超过自动展开的最大大小。如果需要，请使用 coder.unroll() 强制执行展开行为。</entry>
    <entry key="LoopUnrollParforVararg">不支持 parfor 循环的循环展开。</entry>
    <entry key="LoopUnrollCountUnknown">循环展开失败，因为迭代次数未知。</entry>
    <entry key="LoopUnrollCountUnknownOrNegative">循环展开失败，因为迭代次数未知或为负数。</entry>
    <entry key="LoopUnrollCountUnreasonable">循环展开失败，因为迭代次数 {1,number,integer} 超过允许的最大值 {0,number,integer}。</entry>
    <entry key="VarargIndex">由于循环展开失败，无法确定重复变量 ''{0}'' 的索引值。</entry>
    <entry key="DynamicField">由于循环展开失败，无法确定动态字段名称。</entry>
    <entry key="UndefinedProp">由于循环展开失败，无法确定是否为所有元素初始化了属性 ''{0}''。</entry>
    <entry key="LoopUnrollCommonCellType">由于循环展开失败，无法确定所有元胞元素的公共类型。</entry>
    <entry key="MCOSCloningRequiredOnInput">第 {0,number,integer} 个输入在函数 {1} 的不同调用点有不同类型: {2} 和 {3}。</entry>
    <entry key="MCOSCloningRequiredOnOutput">第 {0,number,integer} 个输出在函数 {1} 的不同调用点有不同类型: {2} 和 {3}。</entry>
    <entry key="MCOSOperationUnsupportedHere">检测到使用了 MATLAB 类。代码生成不支持此类。</entry>
    <entry key="MCOSOperationUnsupportedInThisFunction">检测到使用了 MATLAB 类。代码生成不支持它们。</entry>
    <entry key="MCOSOperationUnsupportedNearHere">检测到在此位置附近使用了 MATLAB 类。代码生成不支持这种情况。</entry>
    <entry key="MCOSOperationUnsupported">代码生成不支持此操作。</entry>
    <entry key="MCOSPropertyDoesNotExist">类 ''{0}'' 没有属性 ''{1}''。</entry>
    <entry key="MCOSPropertyNotDefined">属性 ''{0}'' 未定义。</entry>
    <entry key="MCOSPropertyInitialValueUnsupportedType">属性 ''{0}'' 具有不受支持类型的初始值。</entry>
    <entry key="MCOSPropertyInitialPropertyUnsupportedType">无法为类 ''{0}'' 的属性 ''{1}'' 的初始值生成代码。</entry>
    <entry key="MCOSNoClass">没有 {0} 类。</entry>
    <entry key="MCOSNonConstPropertyInitialValueClassType">代码生成仅支持常量属性的类类型初始值。类 ''{1}'' 的属性 ''{0}'' 不是常量。</entry>
    <entry key="MCOSPropertyInitialValueClassTypeUnsupportedUse">Invalid constant property access. Use ''{0}.{1}.someProp'', but not ''{0}.{1}'' or ''{0}.{1}.getProp()''.</entry>
    <entry key="MCOSPropertyMismatchUnassigned">此语句必须保留属性 ''{0}'' 未赋值，或所有传入的执行路径必须对属性 ''{0}'' 赋予 ''{1}'' 类型的值。</entry>
    <entry key="MCOSCannotCallProtectedMethod">无法调用受保护方法 ''{0}''。</entry>
    <entry key="MCOSTunablePropertyNoRuntimeValue">代码生成要求所有包含 ''{0}'' 的属性都标记为不可调。</entry>
    <entry key="MCOSCannotCallPrivateMethod">无法调用私有方法 ''{0}''。</entry>
    <entry key="MCOSConstructorCannotHaveTwoOutputs">Class constructor cannot have more than one output.</entry>
    <entry key="MCOSCannotCreateAbstractClassInstance">无法创建抽象类 ''{0}'' 的实例。</entry>
    <entry key="MCOSUnsupportedFunctionOutputsUsed">This function or method is not supported for code generation but its outputs are used.</entry>
    <entry key="MCOSMethodNotFound">Method ''{0}'' is not found in class ''{1}''.</entry>
    <entry key="MCOSClassNotFound">找不到类 ''{0}''。</entry>
    <entry key="MCOSMethodIsStatic">类 ''{0}'' 的方法 ''{1}'' 是静态方法。</entry>
    <entry key="MCOSMethodIsNotStatic">类 ''{0}'' 的方法 ''{1}'' 不是静态方法。</entry>
    <entry key="MCOSNonscalar">Code generation does not support {0} arrays.</entry>
    <entry key="MCOSCannotSetProtected">无法设置受保护属性 ''{0}''。</entry>
    <entry key="MCOSCannotGetProtected">无法获取受保护属性 ''{0}''。</entry>
    <entry key="MCOSCannotSetPrivate">无法设置私有属性 ''{0}''。</entry>
    <entry key="MCOSCannotGetPrivate">无法获取私有属性 ''{0}''。</entry>
    <entry key="MCOSCannotSetImmutable">Cannot set immutable property ''{0}'' outside the constructor of class ''{1}''.</entry>
    <entry key="MCOSSetPropUnsupportedValueClasses">代码生成不支持使用 set.prop 方法的值类。</entry>
    <entry key="MCOSSetMethodPropertyAccess">在类 ''{0}'' 中，从属属性 ''{1}'' 的 set 方法试图访问存储的属性值。从属属性不存储值，并且无法从其 set 方法中访问。</entry>
    <entry key="MCOSGetMethodPropertyAccess">在类 ''{0}'' 中，从属属性 ''{1}'' 的 get 方法试图访问存储的属性值。从属属性不存储值，并且无法从其 get 方法中访问。</entry>
    <entry key="MCOSNoSetMethod">在类 ''{0}'' 中，没有为从属属性 ''{1}'' 定义 set 方法。从属属性需要 set 方法才能修改其值。</entry>
    <entry key="MCOSNoGetMethod">在类 ''{0}'' 中，没有为从属属性 ''{1}'' 定义 get 方法。从属属性需要 get 方法才能获取其值。</entry>
    <entry key="MCOSNontunableUsedBeforeAssigned">尚未对此不可调属性赋值。在首次使用非可调属性前，必须对其完整赋值。</entry>
    <entry key="MCOSNontunableDependentNotAllowed">代码生成不支持不可调的从属属性。属性 ''{0}'' 是从属属性且不可调。</entry>
    <entry key="MCOSNontunablePropertyValueMismatch">不可调属性 ''{0}'' 的值不匹配。</entry>
    <entry key="MCOSNontunablePropertyValueMismatchLeftHasValue">不可调属性 ''{0}'' 的值不匹配。属性在左侧被赋予常量值，而在右侧没有常量值。</entry>
    <entry key="MCOSNontunablePropertyValueMismatchRightHasValue">不可调属性 ''{0}'' 的值不匹配。属性在右侧被赋予常量值，而在左侧没有常量值。</entry>
    <entry key="MCOSMajorityPropertyValueMismatch">数组布局不匹配。</entry>
    <entry key="MCOSAssignmentToConstantProperty">Setting the constant property ''{0}'' of the ''{1}'' class is not allowed.</entry>
    <entry key="MCOSAssignmentToMethodName">方法调用 as 不能作为赋值的目标。</entry>
    <entry key="MCOSTwoMethodsSameNameInClass">在类 ''{1}'' 中找到两个或多个名为 ''{0}'' 的方法。</entry>
    <entry key="MCOSExtrinsicMethodCallWithDotNotsupported">代码生成不支持使用圆点表示法调用外部方法。''{0}'' 是外部方法。</entry>
    <entry key="MCOSStaticPropertyNoDefaultValue">属性 ''{0}'' 没有默认值。代码生成不支持没有默认值的常量属性。</entry>
    <entry key="MCOSBaseConstructorCallMustBeFirst">在代码生成中，对基构造函数的调用不能以 DISP、FOR、WHILE、SWITCH、IF 或 RETURN 开头。</entry>
    <entry key="MCOSClassConstructorMustHaveOneOutput">类构造函数只能有一个输出。</entry>
    <entry key="MCOSBaseClassCannotBeLoaded">无法加载基类 ''{0}''。</entry>
    <entry key="MCOSClassCannotBeLoaded">无法加载类 ''{0}''。</entry>
    <entry key="MCOSInputNonTunablePropertyUnupported">类 ''{0}'' 具有不可调属性 ''{1}''。不支持具有不可调属性的类作为入口函数的输入。</entry>
    <entry key="MCOSNonTunablePropertyCannotBeImported">类 ''{0}'' 具有不可调属性 ''{1}''。不支持具有不可调属性的类作为外部函数的输出。</entry>
    <entry key="MCOSEnumerationBlocksUnsupported">代码生成不支持类中的枚举块。</entry>
    <entry key="MCOSEventsUnsupported">代码生成不支持事件。</entry>
    <entry key="MCOSMethodUnsupported">The method ''{0}'' is not supported for code generation.</entry>
    <entry key="MCOSOverloadingUnsupported">代码生成不支持重载方法 ''{0}''。</entry>
    <entry key="MCOSDeleteUnsupported">代码生成不支持 ''delete'' 方法。句柄对象仅在程序执行结束时才会销毁，析构函数永远不会被调用。</entry>
    <entry key="MCOSExplicitDeleteUnsupported">代码生成不支持对 ''delete'' 方法的显式调用。</entry>
    <entry key="MCOSMethodNotFoundInRTTI">此函数不是有效的 MATLAB 方法。</entry>
    <entry key="MCOSTwoMethodsSameName">代码生成不支持两个或多个同名的类方法。</entry>
    <entry key="MCOSClassDoesnotHaveProperty">类 ''{0}'' 没有属性 ''{1}''。</entry>
    <entry key="MCOSConstructorAssignToPersistentOrProperty">在代码生成中，句柄类的新实例必须赋给持久变量或持久变量内的属性。</entry>
    <entry key="MCOSAliasedAssignmentExplanation">在代码生成中，句柄类句柄值的现有实例只能赋给局部变量或函数输出。</entry>
    <entry key="MCOSHandleInValue">代码生成不支持值类中的句柄类。</entry>
    <entry key="SharedMCOSHandleInParfor">变量 ''{0}'' 包含在 PARFOR 外部分配的句柄类，因此无法在 PARFOR 内部使用。</entry>
    <entry key="PersistentMCOSHandleInParfor">持久变量 ''{0}'' 包含句柄类，因此无法在 PARFOR 内部使用。</entry>
    <entry key="MCOSUsedAtEntryPoint">{1} 中不支持在顶层输出参数中包含 {0}。输出参数 ''{2}'' 中包含 {0}。</entry>
    <entry key="MCOSHandleUsedAtEntryPoint">{1} 中不支持在顶层输出中包含句柄类。输出参数 ''{0}'' 中包含句柄类。</entry>
    <entry key="MCOSUsedAtBoundary">无法将类传递给外部 MATLAB 函数、C 函数或 Stateflow 函数。</entry>
    <entry key="MCOSStringNotSupportedHere">Strings are not supported here.</entry>
    <entry key="MCOSStringAsForeignFunctionArg">字符串是使用不支持用作此函数参数的运算创建的。</entry>
    <entry key="MCOSNotSupportedHere">此处不支持 MATLAB 类。</entry>
    <entry key="MCOSHandleNotSupportedHere">此处不支持 MATLAB 句柄类。</entry>
    <entry key="MCOSHandleUnsupportedForMxArrayValues">不支持 MATLAB 句柄类作为外部函数的输入或输出。</entry>
    <entry key="MCOSHandleNotSupportedSave">无法将类 ''{0}'' 的对象传递给 ''save''，因为 ''save'' 不支持 MATLAB 句柄类。</entry>
    <entry key="MCOSCannotPassClassesToMATLABFunction">无法将类 ''{0}'' 的对象传递给外部 MATLAB 函数 ''{1}''</entry>
    <entry key="MCOSCannotPassHandleClassesToMATLABFunction">无法将句柄类 ''{0}'' 的对象传递给外部 MATLAB 函数 ''{1}''</entry>
    <entry key="MCOSMxArrayNotAllowedForInternal">无法将 mxArray 传递给 ''{0}''。</entry>
    <entry key="MCOSCannotLoadClassWithMsg">无法加载类 ''{0}'': {1}</entry>
    <entry key="MCOSPropertyInitialValueLoadFailed">无法加载属性 ''{0}'' 的初始值: {1}</entry>
    <entry key="MCOSPropertyAssignmentInConstructorOnly">代码生成仅支持对外围类构造函数内句柄属性的赋值。</entry>
    <entry key="MCOSPropertyAssignmentInConstructorOnlyOnce">代码生成要求对每个句柄属性只赋值一次。此赋值可能执行了零次或多次。</entry>
    <entry key="MCOSHandlePropertyAssignmentCannotBeNested">代码生成仅支持对外围类构造函数内句柄属性的赋值。类 ''{0}'' 的属性 ''{1}'' 是在类构造函数之外赋值的。</entry>
    <entry key="MCOSHandlePropertyAssignedTwice">代码生成要求对每个句柄属性只赋值一次。此属性被赋值了两次或多次。</entry>
    <entry key="MCOSDiamondInheritanceNotSupported">代码生成中不支持菱形继承。类 ''{0}'' 通过两条或多条路径从基类 ''{1}'' 继承。</entry>
    <entry key="MCOSCallInDefaultConstructorFailed">在 ''{1}'' 的默认构造函数中对 ''{0}'' 的调用失败。</entry>
    <entry key="MCOSAccessListAttrNotSupported">代码生成不支持 ''{0}'' 声明中的在 'Access' 属性中使用元类或函数句柄这种用法。</entry>
    <entry key="MCOSOnceSentinelPropertyMustBePrivate">'once' 哨兵属性 ''{0}'' 必须为私有属性。</entry>
    <entry key="MCOSOnceMethodMustBeProtectedOrPublic">'once {0}' 方法 ''{1}'' 必须为受保护方法或公共方法。</entry>
    <entry key="MCOSOnceSentinelPropertyMustHaveInitialValueOfFalse">'once' 哨兵属性 ''{0}'' 的初始值必须为 'false'。</entry>
    <entry key="MCOSOnceSentinelAndSetupMustBeInSameClass">代码生成不支持覆盖 setup()。isInitialized 和 setup() 必须在同一个类中声明。</entry>
    <entry key="MCOSUnsupportedPropertyTypeFunctionHandle">代码生成不支持在类属性中使用函数句柄。</entry>
    <entry key="MCOSUnsupportedPropertyTypeMxArray">代码生成不支持 mxArray 类型的可调类属性。</entry>
    <entry key="EntryPointNontunableMxArrayProperty">代码生成在入口函数中不支持 mxArray 类型的不可调类属性。</entry>
    <entry key="ExtrinsicNontunableMxArrayProperty">代码生成不支持传递给外部函数或从外部函数返回的 mxArray 类型的不可调类属性。</entry>
    <entry key="SaveNontunableMxArrayProperty">代码生成不支持传递给 ''save'' 的 mxArray 类型的不可调类属性。</entry>
    <entry key="MCOSConstructorNameConflict">类构造函数不能有同名的输入和输出。输入 #''{1, number, integer}'' 和输出 #''{2, number, integer}'' 具有相同的名称 ''{0}''。</entry>
    <entry key="MCOSClassDoesNotSupportCodeGeneration">''{0}'' 类不支持代码生成。</entry>
    <entry key="MCOSMethodDoesNotSupportCodeGeneration">The ''{0}'' method does not support code generation.</entry>
    <entry key="MCOSClassIsNotSupportedAsInitialValue">代码生成不支持 ''{1}'' 作为属性的初始值。如果属性 ''{0}'' 不需要为常量，请删除初始值，并改为在构造函数中对其赋值。</entry>
    <entry key="MCOSSeaLimitationNew">函数 ''{1}'' 中的持久变量 ''{0}'' 和函数 ''{3}'' 中的变量 ''{2}'' 可能引用了类 ''{4}'' 的同一实例。由于内部限制，不允许两个持久变量指向此类的同一个实例。</entry>
    <entry key="MCOSSeaLimitationInstance">此表达式及其属性 ''{0}'' 具有相同的类。代码生成不支持递归数据结构体。</entry>
    <entry key="MCOSSeaLimitationInstanceNamedVar">''{0}'' 和 ''{1}'' 具有相同的类。代码生成不支持递归数据结构体。</entry>
    <entry key="MCOSSeaLimitationInstanceProp">此表达式的属性 ''{0}'' 和属性 ''{1}'' 具有相同的类。代码生成不支持递归数据结构体。</entry>
    <entry key="MCOSHandlePropertyAssignmentNonHandleHost">代码生成不支持非句柄类中存在句柄属性。不能对非句柄类 ''{1}'' 的属性 ''{0}'' 赋予对句柄类 ''{2}'' 的引用。</entry>
    <entry key="MCOSNontunableValueClassProperty">代码生成不支持将值类的对象赋给不可调属性。</entry>
    <entry key="MCOSNontunableMCOSInCell">代码生成不支持将包含对象的元胞数组赋给不可调属性。</entry>
    <entry key="MCOSClassNotSupportedHereMissingFromRedirect">在此上下文中，代码生成不支持 MATLAB 类 ''{0}''，因为该类未实现 toRedirect() 和/或 fromRedirect() 方法。</entry>
    <entry key="ThisTypeCannotBeDisplayed">无法显示 ''{0}''。</entry>
    <entry key="DisplayNotSupportedForHandleClasses">代码生成不支持句柄类的显示。''{0}'' 是句柄类。</entry>
    <entry key="MCOSFcnHandleNonStaticMethod">代码生成不支持指向非静态方法的函数句柄。请将函数句柄 @obj.method 替换为等效的匿名函数 @(varargin)obj.method(varargin'{:}')。</entry>
    <entry key="MCOSAbortSetUnsupported">代码生成不支持具有 AbortSet 特性的属性。属性 ''{0}'' 具有 AbortSet 特性。</entry>
    <entry key="MCOSInputParserUnsupported">代码生成不支持 inputParser 对象。请使用参量块执行参量验证。</entry>
    <entry key="MCOSInputTransientPropertyUnsupported">在代码生成中，不支持具有瞬态属性的类作为入口函数的输入。类 ''{1}'' 的属性 ''{0}'' 的瞬态特性为 true。</entry>
    <entry key="MCOSOutputTransientPropertyUnsupported">在代码生成中，不支持具有瞬态属性的类作为入口函数的输出。类 ''{1}'' 的属性 ''{0}'' 的瞬态特性为 true。</entry>
    <entry key="MCOSTransientPropertyCannotBeExported">在代码生成中，不支持具有瞬态属性的类作为外部调用的输入。类 ''{1}'' 的属性 ''{0}'' 的瞬态特性为 true。</entry>
    <entry key="MCOSTransientPropertyCannotBeImported">在代码生成中，不支持具有瞬态属性的类作为外部调用的输出。类 ''{1}'' 的属性 ''{0}'' 的瞬态特性为 true。</entry>
    <entry key="MCOSTransientPropertyUnsupportedForMxArrayValues">具有瞬态属性的类无法与 mxArray 值相互转换。类 ''{1}'' 的属性 ''{0}'' 的瞬态特性为 true。</entry>
    <entry key="MxArrayNotEliminated">无法消除外部函数调用返回的 mxArray。要生成独立代码，代码生成器必须能够消除您的 MATLAB 代码中的所有 mxArray。</entry>
    <entry key="MatlabFunctionNotEliminated">无法生成独立代码，因为外部函数 ''{0}'' 的输出似乎会影响主调函数。请消除对 ''{1}'' 的调用或确保不使用其输出。</entry>
    <entry key="MatlibInputUnknown">MATLAB 函数调用的输入必须具有已知大小和已知类。</entry>
    <entry key="MatrixDeletion">不支持从矩阵中删除元素。</entry>
    <entry key="MatrixMulSize">不能将大小为 {0} 的矩阵与大小为 {1} 的矩阵相乘。对于矩阵乘法 A * B，A 的列数必须与 B 的行数匹配。</entry>
    <entry key="MexInterceptionActivationConstructor">无法激活对 ''{0}'' 的拦截，因为它是一个类构造函数。</entry>
    <entry key="MexInterceptionActivationDuplicateInterception">无法激活对 ''{0}'' 的拦截，因为已有具此名称的符号拦截被激活。</entry>
    <entry key="MexInterceptionActivationFileNotFound">找不到符号: {0}。请提供文件的完整路径。</entry>
    <entry key="MexInterceptionActivationFileAlreadyExists">无法激活对符号 ''{0}'' 的拦截，因为存在冲突文件: {1}</entry>
    <entry key="MexInterceptionActivationNamespace">无法激活对 ''{0}'' 的拦截，因为它位于命名空间中。</entry>
    <entry key="MexInterceptionActivationNonAbsolutePath">路径不是绝对路径: {0}。请提供一个绝对路径。</entry>
    <entry key="MexInterceptionActivationNotOnPath">无法激活对 ''{0}'' 的拦截，因为它不在 MATLAB 路径中。</entry>
    <entry key="MexInterceptionActivationSymbolShadowed">无法激活对 ''{0}'' 的拦截，因为它被 ''{1}'' 遮蔽</entry>
    <entry key="MexInterceptionDeactivationNotActive">无法反激活对 ''{0}'' 的拦截，因为拦截未激活。</entry>
    <entry key="MexInterceptionDectivationSymbolShadowed">无法反激活对 ''{0}'' 的拦截，因为它被 ''{1}'' 遮蔽</entry>
    <entry key="MexInterceptionGenerationFileNotFound">未找到 MEX 文件: {0}</entry>
    <entry key="MexInterceptionGenerationMexNotOnPath">coder.internal.GeneratedMexInterception 的输入必须为位于 MATLAB 路径中的有效 MEX 文件: {0}</entry>
    <entry key="MexInterceptionGenerationInvalidMex">MEX 文件 ''{0}'' 无效。MEX 文件必须由 MATLAB Coder 在适用于此平台的当前版本中生成。</entry>
    <entry key="MissingEMLPragma">''{0}'' 中缺失 %#codegen。\n请将 %#codegen 添加到此文件中，以指示它适合代码生成。\n(''{1}'' 的完整路径是 ''{2}''。)</entry>
    <entry key="MixedDoubleInteger">与整数操作数交互的双精度操作数必须具有整数值。</entry>
    <entry key="MixedInputs">混合输入必须为单精度值和双精度值，或为整数和标量双精度值。不再允许使用所有其他组合形式。</entry>
    <entry key="MultOutputOperator">此运算符没有多个输出</entry>
    <entry key="MultipleReturnValuesFromStateflow">一个 Stateflow 函数不能返回多个输出。</entry>
    <entry key="MustBeConst">值必须为常量。</entry>
    <entry key="MxArrayInput">输入是一个 mxArray。</entry>
    <entry key="MxArraySubscript">不支持在两个 mxArray 之间使用下标赋值。</entry>
    <entry key="MxEmptyStructure">代码生成不支持空结构体。在 ''{0}'' 处找到空结构体。</entry>
    <entry key="MxMixedStructureFieldTypes">Mixed field types in structure arrays not supported for code generation. Type at ''{0}'' must match type at ''{1}''.</entry>
    <entry key="MxStructureWithEmptyMatrix">不支持在结构体内部使用空矩阵。在 ''{0}'' 处发现空矩阵。</entry>
    <entry key="MxStructureWithCell">codegen 不支持从 MATLAB 导入在结构体中含有元胞数组的变量。在 ''{0}'' 处发现元胞数组。</entry>
    <entry key="MxUnsupportedClass">MATLAB class ''{0}'' found at ''{1}'' not supported for code generation.</entry>
    <entry key="MxUnsupportedFixedPointType">不支持在 ''{0}'' 中使用定点类型。</entry>
    <entry key="MxUnsupportedFixedPointWordLength">''{0}'' 中使用了不支持的定点类型。类型的字长超过 128 位。</entry>
    <entry key="MxUnsupportedSparseMatrix">在 ''{0}'' 处发现了不受支持的稀疏矩阵。</entry>
    <entry key="MxVariableSizeConst">代码生成不支持将此结构体数组定义为常量，因为字段 {0} 的大小因数组元素而异。请确保数组中每个结构体实例中的此字段都具有相同大小，或将结构体数组重新创建为一个由结构体标量组成的元胞数组。</entry>
    <entry key="MxErrorLoadingClass">加载 MATLAB 对象 ''{0}'' 时出错。可能是类构造函数遇到错误而异常终止。</entry>
    <entry key="MxUnsupportedMCOSArrays">Element ''{0}'' is an array of objects. Code generation does not support constants containing arrays of objects. </entry>
    <entry key="MxUnsupportedValue">Value at ''{0}'' unsupported for code generation.</entry>
    <entry key="MxUnsupportedMCOSConstant">代码生成不支持类 ''{1}'' 的常量。变量 ''{0}'' 的值是类 ''{1}'' 的对象。</entry>
    <entry key="MxIncompatibleValue">''{0}'' 处的值与预期的类型 ''{1}'' 不匹配。</entry>
    <entry key="MxIncompatibleEnum">''{0}'' 处的值不是基于以下项之一的枚举类: ''int8''、''uint8''、''int16''、''uint16''、''int32''、''uint32'' 或 ''Simulink.IntEnumType''。</entry>
    <entry key="MxStringEncodingConversionError">无法使用 MATLAB 代码生成字符编码(''{1}'')用 8 位字符表示 ''{0}''。代码生成仅支持可以用 8 位表示的字符。</entry>
    <entry key="MxStringEncodingSizeConsistencyError">从 ''{0}'' 到 MATLAB 代码生成字符编码(''{1}'')的转换更改了字符数。代码生成不支持此行为。</entry>
    <entry key="MxStringDecodingConversionError">无法从 MATLAB 代码生成字符编码(''{0}'')转换字符串或字符数组。</entry>
    <entry key="MxStringDecodingSizeConsistencyError">从 MATLAB 代码生成字符编码(''{0}'')转换字符串或字符数组更改了字符数。代码生成不支持此行为。</entry>
    <entry key="MxFiSimulinkIncompatible">''{0}'' 处的值是大于 {1,number,integer} 位的定点数，这不受支持。</entry>
    <entry key="MxNontunableParamsNotSupported">代码生成不支持从 MATLAB 导入 ''{0}'' 的实例。</entry>
    <entry key="MxHandleClassesNotSupported">Importing handle classes from MATLAB not supported for code generation.</entry>
    <entry key="NestedFunctionsInConstructor">代码生成不支持在构造函数中使用嵌套函数。</entry>
    <entry key="NoConversionPossible">无法转换为任何受支持的类型。</entry>
    <entry key="NoFixedPoint">此处不允许使用 ''embedded.fi''。</entry>
    <entry key="NoImplicitCast">无法在这两个类之间执行隐式转换。</entry>
    <entry key="NoNargoutSpecified">重复使用输出变量 ''{0}'' 需要通过 nargout 进行设定。请使用 '-nargout' 为函数 ''{1}'' 指定所需的输出值数目。</entry>
    <entry key="NoVararg">在当前函数没有 {2} 参数的情况下尝试访问 {0}'{'{1,number,integer}'}'。</entry>
    <entry key="NonConstantBraceListAssignRhsCount">braceListAssign 需要赋固定数目的值。</entry>
    <entry key="NonFinites">目标不支持非有限值(Inf 和 NaN)。要允许此表达式，请更改代码生成配置参数。</entry>
    <entry key="NonIntegerIndexExpr">值为 {0} 的非整数索引表达式。</entry>
    <entry key="NonIntegerSizeVector">发现非整数大小向量。</entry>
    <entry key="NonScalarSubsRefInRef">{0} 中只允许标量下标。此下标表达式返回大小为 {1} 的矩阵。</entry>
    <entry key="NonTunableVariableHasMultipleAssignments">标记为 coder.nontunable() 的变量只能有一个赋值。</entry>
    <entry key="NonTunablePropertyHasMultipleAssignments">Nontunable property ''{0}'' may only be assigned once.</entry>
    <entry key="NonTunablePropertyMustBeCompletelyAssigned">无法通过下标赋值来定义类 ''{1}'' 的不可调属性 ''{0}''。请改用完整赋值。</entry>
    <entry key="NonTunablePropertyNotConst">Failed to compute constant value for nontunable property ''{0}''. In code generation, nontunable properties can only be assigned constant values.</entry>
    <entry key="NonZeroImag">The imaginary part must be zero. Expected a scalar numeric value.</entry>
    <entry key="NotSupportedInMATLAB">MATLAB 不支持函数 {0}。请使用 coder.target 将 {0} 限制为用于代码生成。</entry>
    <entry key="NullCharacter">此字符串或字符向量包含空字符 char(0)。代码生成在此上下文中不支持空字符。</entry>
    <entry key="NullCopyDoesNotSupportClass">coder.nullcopy 不支持类 ''{0}'' 的输入。</entry>
    <entry key="NullCopyNotOnRhsOfAssignment">coder.nullcopy 只能出现在赋值的右侧。</entry>
    <entry key="NullCopyOnRhsOfSubscriptedAssignment">coder.nullcopy 只能出现在非下标赋值中。</entry>
    <entry key="InvalidLHS">此表达式不是有效的定义。</entry>
    <entry key="NullInput">缺失输入表达式。</entry>
    <entry key="NumDimsMismatchInAssignment">赋值左侧的维度少于右侧的维度: {0} 无法从 {1} 赋值。</entry>
    <entry key="NumDimsMismatchInAssignmentOnField">赋值左侧的字段 ''{0}'' 的维度少于右侧的维度: {1} 无法从 {2} 赋值。</entry>
    <entry key="NumDimsMismatchInAssignmentOnCell">赋值左侧的元素 ''{0}'' 的维度少于右侧的维度: {1} 无法从 {2} 赋值。</entry>
    <entry key="CannotDetermineNumberOfElements">无法确定元素数。</entry>
    <entry key="NumericTypeLocked">尝试对运算符进行了两次数值类型设置。</entry>
    <entry key="NumerictypeMismatch">embedded.numerictype 对象的属性必须匹配。</entry>
    <entry key="NumerictypeMismatchOnCell">元素 ''{0}'' 中 embedded.numerictype 对象的属性必须匹配。</entry>
    <entry key="NumerictypeMismatchOnField">字段 ''{0}'' 中 embedded.numerictype 对象的属性必须匹配。</entry>
    <entry key="NumfieldsArg">参数必须为结构体类型。</entry>
    <entry key="OpGeneratingComplexSlopeBiasFiUnsupported">Fixed-Point Designer 操作创建的所有复数 FI 对象必须具有 2 的整数次幂斜率和 0 偏置。</entry>
    <entry key="OpaqueCannotBeDisplayed">不透明值无法自动显示。请用分号终止语句以隐藏自动显示。</entry>
    <entry key="OpaqueCannotBeExported">不透明值无法传递给对 MATLAB 的调用。</entry>
    <entry key="OpaqueCannotBeImported">对 MATLAB 的调用无法返回不透明值。</entry>
    <entry key="OpaqueCannotBeSaved">不透明值无法传递给 ''save''。</entry>
    <entry key="UnassignedMClassCannotBeImported">无法从对 MATLAB 的调用中返回包含未赋值元胞的元胞数组。</entry>
    <entry key="OpaqueInitialValue">在没有初始值的函数调用中使用了函数 coder.opaque。要在函数调用中使用 coder.opaque，请提供初始值作为第二个参量。</entry>
    <entry key="OpaqueEmptyType">coder.opaque 的第一个参数必须为有效的 C 类型。</entry>
    <entry key="OpaqueMissingHeaderFile">''{1}'' 的位置 {0,number,integer} 处的可选参数名称必须为 ''HeaderFile'' 或 ''Size''。</entry>
    <entry key="OpaqueMissingHeaderFileValue">输入参数的数目不足。必须为 ''{1}'' 的 ''{0}'' 参数指定一个值。</entry>
    <entry key="OperandSizesMustBeKnown">{0} 的非标量操作数的大小必须已知: 操作数 {1,number,integer} 的大小未知。</entry>
    <entry key="OperandSizesMustBeEqual">{0} 的非标量操作数必须大小相同: 操作数 {1,number,integer} 的大小为 {2}，而操作数 {3,number,integer} 的大小为 {4}。</entry>
    <entry key="OperatorOutsideExpr">{0} 不能出现在表达式中。它只能出现在顶层。</entry>
    <entry key="OperatorMustBeOutsideControlFlow">''{0}'' 不能嵌套在 IF、SWITCH、FOR 或 WHILE 语句中，也不能跟在条件 RETURN 语句后面。</entry>
    <entry key="OverflowModeLocked">尝试对运算符进行了两次溢出模式设置。</entry>
    <entry key="ElementDeletionUnsupported">For code generation, class ''{0}'' does not support element deletion.</entry>
    <entry key="PCodeMessageSuppressed">检测到 P 代码文件问题。请编译对应的 MATLAB 代码来诊断问题。</entry>
    <entry key="PCodeMode">不支持 {1} 函数的参数 ''{0}''。</entry>
    <entry key="ParCallToCustomCCode">在并行 FOR 循环中调用自定义 C 代码。</entry>
    <entry key="ParCallToSideEffectFcn">在并行 FOR 循环中调用具有副作用的函数。</entry>
    <entry key="ParforTooManyArguments">此 PARFOR 语句包含太多参数。</entry>
    <entry key="ParGlobalPersistentAccess">不应在 PARFOR 循环中设置 GLOBAL 或 PERSISTENT 变量 ''{0}''。</entry>
    <entry key="ParIndexRangeError">PARFOR 语句的范围必须为连续递增的有符号整数。</entry>
    <entry key="ParIndexVariableUseError">可能在 PARFOR 循环后使用了索引变量 ''{0}''，但它在该循环后不可用。</entry>
    <entry key="ParIndexVariableDefError">更改循环索引 ''{0}'' 在 PARFOR 循环中无效。</entry>
    <entry key="ParIndexMultiWordError">对于代码生成，PARFOR 索引变量的类型必须能在目标硬件中表示出来。类型 ''{0}'' 没有本机表示形式。</entry>
    <entry key="ParReductionUnsupportedType">变量 ''{0}'' 用作归约变量，但包含结构体、类或元胞类型。</entry>
    <entry key="ParReductionConflictingOps">发现同一归约变量(''{0}'') 存在冲突的归约运算。</entry>
    <entry key="ParReductionConflictingPosn">变量 ''{0}'' 包含非交换的归约函数，\n但此变量不会出现在所有归约赋值的相同参数位置中。</entry>
    <entry key="ParPersistentError">{0} 中不支持在 PARFOR 循环中使用 PERSISTENT 变量</entry>
    <entry key="ParCrossLoopDependence">无法证明数组访问之间不存在循环迭代依赖。</entry>
    <entry key="ParParforUnclassifiable">无法对 parfor 中的变量进行分类。</entry>
    <entry key="ParForLoopWithInfiniteLoopUnpported">代码生成不支持内部有无限循环的 PARFOR 循环。</entry>
    <entry key="ParReductionIllegalOp">变量 ''{0}'' 不支持该归约运算。支持的运算有 +、-、*、&amp; 或 |。</entry>
    <entry key="ParReductionIllegalForm">无法对并行循环中的变量 ''{0}'' 进行分类。</entry>
    <entry key="ParReductionIllegalExpr">归约变量必须为标量变量。不支持结构体字段或数组元素。</entry>
    <entry key="ParReductionIllegalStmt">''{0}'' 是归约变量。涉及归约变量的语句必须是归约赋值语句。</entry>
    <entry key="ParallelForLoopIndexExpressionComplex">并行 FOR 循环索引表达式不能为复数类型。</entry>
    <entry key="ParallelForLoopRangeMustBeRowVector">parfor 循环变量 "{0}" 的范围计算结果必须为行向量。</entry>
    <entry key="ParallelForLoopRangeMustBeNumeric">parfor 循环变量 ''{0}'' 的范围计算结果必须为数值组成的行向量。</entry>
    <entry key="ParallelForLoopIndexExpression">并行 FOR 循环索引表达式仅在形式为 A:B 时才受支持。</entry>
    <entry key="ParallelForLoopUnrollUnsupported">''{0}'' 函数无法与并行 FOR 循环结合使用。</entry>
    <entry key="ParallelForLoopUnrecognizedFlag">将无法识别的标志 ''{0}'' 传递给了并行 FOR 循环构造。</entry>
    <entry key="ParallelForLoopWithBreak">并行 FOR 循环无法通过 BREAK 或 RETURN 语句退出循环。</entry>
    <entry key="ParallelForLoopDebuggingEnabled">不允许在并行执行期间进行调试。将关闭并行功能。</entry>
    <entry key="ParallelBodyDisplayRemoved">PARFOR 循环中隐藏了不带分号的表达式的输出。</entry>
    <entry key="ParallelNumThreads">最大线程数必须为零、正整数或 Inf。</entry>
    <entry key="NoCompilerOpenMPSupport">所选编译器不支持 OpenMP 库；此循环不会并行化。</entry>
    <entry key="JITOpenMPSupport">JIT 技术不支持使用 OpenMP 库，此循环不会并行化。</entry>
    <entry key="ProfilingOpenMPSupport">循环不会并行化，因为 MEX 探查不支持 OpenMP 库。</entry>
    <entry key="ParameterClassMismatch">参数的类型 ''{0}'' 与指定的类型 ''{1}'' 不匹配。</entry>
    <entry key="ParameterCouldNotBeComputed">无法在编译时计算参数 {0} 的值。</entry>
    <entry key="ParameterSizeMismatch">\n参数与指定的大小不匹配。</entry>
    <entry key="ParameterTypeMismatch">参数 ''{0}'' 的类型 {1} 与指定的类型 {2} 不匹配。</entry>
    <entry key="ParameterTypeUnsupported">顶层输入参数 {0} 具有不受支持的类型 {1}。</entry>
    <entry key="ParseErrorAssignmentsMayOnlyAppearAtTopLevel">解析错误: 赋值只能出现在顶层。</entry>
    <entry key="ParseErrorBuiltinTakesFunctionInputAsOnlyArgument">解析错误: 此内置函数将函数输入作为其唯一参数。</entry>
    <entry key="ParseErrorEmlConstExpectsExactlyOneInput">解析错误: EML_CONST 只要求一个输入。</entry>
    <entry key="ParseErrorFunctionCallExpectedOnRhs">解析错误: 此赋值的右侧需为函数调用。</entry>
    <entry key="ParseErrorInvalidArgumentToBuiltin">解析错误: 内置函数的参数无效。</entry>
    <entry key="ParseErrorTooFewArgumentsForBuiltin">解析错误: 内置函数的参数太少。</entry>
    <entry key="ParseErrorFatal">解析 ''{0}'' 时出现严重错误: {1}</entry>
    <entry key="ParsingErrorMessage">解析错误: {0}</entry>
    <entry key="ParsingFailed">解析失败。</entry>
    <entry key="PersistentTopLevel">PERSISTENT 声明只能出现在顶层。</entry>
    <entry key="PossibleError">\n上述错误可能是由于功能受限而非真正的错误条件而报告的。检测错误时，复杂的控制流有时会产生误报。</entry>
    <entry key="PossibleErrorSimulink">\n上述错误可能是由于功能受限而非真正的错误条件而报告的。检测错误时，不使用 Simulink 输入值和可调 Simulink 参数值。它有时无法处理复杂的控制流。</entry>
    <entry key="PropertyNotEqualTo">属性 ''{0}'' 在赋值语句的左侧为 ''{1}''，但在右侧为 ''{2}''。</entry>
    <entry key="PropertyNotEqualToUnspecified">属性 ''{0}'' 在赋值语句的左侧为 ''{1}''，但右侧未指定。</entry>
    <entry key="PropertyUnknown">未知属性</entry>
    <entry key="PropertyUnspecifiedNotEqualTo">属性 ''{0}'' 在赋值语句的左侧未指定，但在右侧为 ''{1}''。</entry>
    <entry key="Recursion">不允许递归调用。函数 ''{0}'' 参与了递归调用。</entry>
    <entry key="RecursionLimit">已达编译时递归上限。</entry>
    <entry key="RecursionLimitInput">已达编译时递归上限。每次调用时，函数 ''{0}'' 的输入 #{1,number,integer} 的大小或类型可能会更改。</entry>
    <entry key="RecursionLimitConstInput">已达编译时递归上限。每次调用时，函数 ''{0}'' 的输入 #{1,number,integer} 的值可能会更改。</entry>
    <entry key="RuntimeRecursionDisabled"> 运行时递归已禁用。函数 ''{0}'' 是递归函数。</entry>
    <entry key="RecursiveFunctionUndefinedOutput">在任何运行时递归调用之前，必须对所有输出赋值。此处未对输出 ''{0}'' 赋值。</entry>
    <entry key="NoConstantFoldDirectCallExplicit">无法直接对 ''{0}'' 调用进行常量折叠，因为它显式禁止直接进行常量折叠。</entry>
    <entry key="NoConstantFoldDirectCallUninitialized">无法直接对 ''{0}'' 调用进行常量折叠，因为对于输出 ''{1}''，它返回了未初始化的数据。</entry>
    <entry key="NoConstantFoldRecursiveCall">无法在函数 ''{1}'' 中常量折叠对运行时递归函数 ''{0}'' 的调用。</entry>
    <entry key="ReinterpretSizeMismatch">尝试将 {0,number,integer} 位重新解释为 {1,number,integer} 位。大小更改需要 EML_CAST。</entry>
    <entry key="ReinterpretUnrecognizedType">EML_REINTERPRET 中的类型无法识别。</entry>
    <entry key="Relop">此比较使用的位数({0,number,integer})多于支持的位数({1,number,integer})。请将两侧都转换为一种通用的数值类型来克服此限制。</entry>
    <entry key="RequireEmlMessage">此表达式应为 eml_message 对象。</entry>
    <entry key="RequireNumeric">表达式必须为数值。但发现它是 {0}。</entry>
    <entry key="RequireNumericUnknown">表达式必须为数值。无法确定其类型。</entry>
    <entry key="ReservedProperty">属性名称 ''{0}'' 是保留名称。请重命名此属性。</entry>
    <entry key="ReservedWord">非法使用保留字 {0}。</entry>
    <entry key="ResultRange">输入值 {0} 超出结果类 {1} 的范围。</entry>
    <entry key="RoundingModeLocked">尝试对运算符进行了两次舍入模式设置。</entry>
    <entry key="RtErrorMxArray">函数 eml_lib_assert、eml_invariant、coder.internal.assert、coder.internal.errorIf 和 coder.internal.error 不支持带 ''{0}'' 参数的运行时错误报告。在调用其中一个函数之前，请将所有参数转换为字符向量或内置数值类型。或者，从外部调用 ASSERT 或 ERROR。</entry>
    <entry key="SEAStaticReference">代码生成不支持访问此对象的静态方法和属性。</entry>
    <entry key="SysObjSameInstanceRequired">对 System object 类 ''{0}'' 应用了不同配置。</entry>
    <entry key="SEAUnsupportedForCcalls">C 调用不支持 System object。</entry>
    <entry key="SEAUnsupportedForCeval">''coder.ceval'' 不支持 System object。</entry>
    <entry key="SEAUnsupportedForMATLABCalls">外部调用不支持 System object。</entry>
    <entry key="SEAUnsupportedForMxArrayValues">mxArray 值不支持 System object。</entry>
    <entry key="SEAUnsupportedForSave">代码生成不支持使用 save 命令保存 System object。</entry>
    <entry key="SameNameRepeatingInputAndOutput">代码生成不支持使用可变长度输入 ''{0}'' 作为输出。</entry>
    <entry key="SameNameInputAndRepeatingOutput">代码生成不支持使用可变长度输出 ''{0}'' 作为输入。</entry>
    <entry key="SaveSpecialVarName">在代码生成中，''save'' 不支持保存变量 ''{0}''。请使用备用变量名称。</entry>
    <entry key="SaveFileNameInvalidType">''save'' 的文件名参数必须为字符向量或字符串标量。</entry>
    <entry key="SaveNonLiteral">代码生成要求传递给 ''save'' 的所有变量名称和选项均为字符向量或字符串字面值。例如，''save a.mat b c'' 或 ''save(filename, ''a'', "b")''。</entry>
    <entry key="SaveRequiresVariableNames">在代码生成中，当调用 ''save'' 时，必须显式列出要保存的变量。</entry>
    <entry key="SaveStandaloneIgnored">对于独立代码生成，''save'' 被忽略，它仅在生成启用了外部调用的 MEX 或 S-Function 时才有效。</entry>
    <entry key="SaveUnsupportedOptionStruct">代码生成中不支持 ''save'' 使用 ''-struct'' 参数。</entry>
    <entry key="SaveUnsupportedOptionRegexp">代码生成中不支持 ''save'' 使用 ''-regexp'' 参数。</entry>
    <entry key="SaveUnsupportedWildcard">代码生成中不支持在调用 ''save'' 时使用通配符 ''*''。请显式列出要保存的所有变量的名称。</entry>
    <entry key="SaveInvalidVariable">找不到变量 ''{0}''。</entry>
    <entry key="SaveIndirectUnsupported">代码生成中不支持通过函数句柄间接使用 ''save''。请使用 ''save fileName x y -option''。</entry>
    <entry key="ShellEscape">shell 转义(!)不受支持。</entry>
    <entry key="ShiftIndexOutOfBounds">不允许偏移 {0,number,integer} 位。有效的偏移范围是 {1,number,integer}-{2,number,integer}。</entry>
    <entry key="SimulinkStringInBusesUnsupported">MATLAB Function 模块不支持内部包含字符串的总线。</entry>
    <entry key="SizeArg2">SIZE 的第二个输入必须为数值。</entry>
    <entry key="SizeInputNumeric">{0} 的大小输入必须为数值。</entry>
    <entry key="SizeDimen">维度参数必须是范围在 1 到 2^31 之间的一个正整数标量。</entry>
    <entry key="SizeIO">具有多个输入的 SIZE 只返回了一个输出。</entry>
    <entry key="SizeMismatch">数组的大小不兼容({0} 和 {1})。</entry>
    <entry key="SizeMismatchOnField">字段 ''{2}'' 中的数组的大小不兼容({0} 和 {1})。</entry>
    <entry key="SizeMismatchOnCell">Arrays in element ''{2}'' have incompatible sizes ({0} and {1}).</entry>
    <entry key="SizeOverflow">\n在维度 {0,number,integer} 中，固定大小 {1,number,integer} 超过上界大小 {2,number,integer}。</entry>
    <entry key="SizesIncompatibleForImplicitExpansion">无法执行此运算，因为数组的大小不兼容(大小为 {0} 和大小为 {1})。</entry>
    <entry key="SizesIncompatibleForImplicitExpansionOnDim">\n维度 {0,number,integer} 中的大小不兼容({1,number,integer} 和 {2,number,integer})。</entry>
    <entry key="SizeVectorConstantQualifier">大小向量必须为常量表达式。</entry>
    <entry key="SizeCannotBeScalar">''{0}'' 的大小参数必须有至少两个元素。</entry>
    <entry key="SizeVectorSizeLimit">超出了程序允许的最大变量值。</entry>
    <entry key="SliceLeftConstantQualifier">\n切片左索引必须为常量。</entry>
    <entry key="SliceRightConstantQualifier">\n切片右索引必须为常量。</entry>
    <entry key="StaticDynamicSizeMismatchOnAssignment">无法进行此赋值，因为维度 {0,number,integer} 左侧是固定大小，而右侧是可变大小({1} 和 {2})。</entry>
    <entry key="StaticDynamicSizeMismatchOnAssignmentOnField">Unable to make this assignment because dimension {0,number,integer} in field ''{1}'' is fixed size on the left side but variable size on the right ({2} and {3}).</entry>
    <entry key="StaticDynamicSizeMismatchOnAssignmentOnCell">Unable to make this assignment because dimension {0,number,integer} in element ''{1}'' is fixed size on the left side but variable size on the right ({2} and {3}).</entry>
    <entry key="Str2funcAnonymousFunctionStringNotSupported">对于代码生成，str2func 不支持匿名函数字符向量。</entry>
    <entry key="Str2funcInvalidFunctionName">str2func 输入 "{0}" 不是有效的函数名称。</entry>
    <entry key="StrcmpCellarrayUnsupported">代码生成不支持将 varargin 或 varargout 之类的重复变量传递给 STRCMP。</entry>
    <entry key="StrcmpEnumChar">For code generation, {0} does not support enumeration inputs.</entry>
    <entry key="StructArgMax">传递给 struct() 的参数太多；当前限制是 {0,number,integer} 个参数。</entry>
    <entry key="StructField">无法从类型为 ''{1}'' 的变量中提取字段 ''{0}''，因为此变量不是结构体。</entry>
    <entry key="StructFieldAssignOrder">对 ''{0}'' 的赋值没有发生在对 ''{1}'' 的赋值之前。结构体字段在所有控制流路径中必须按相同的顺序赋值。</entry>
    <entry key="StructFieldInherited">无法从 ''{1}'' 中提取字段 ''{0}''，因为不支持 Simulink 总线对象上的继承类型。要访问 Simulink 总线，请在模型资源管理器中显式设置输入类型。</entry>
    <entry key="StructFieldNameLength">字段名称 ''{0}'' 超出 MATLAB 允许的名称长度({1,number,integer} 个字符)</entry>
    <entry key="StructFieldUndefined">结构体字段 ''{0}'' 无效。</entry>
    <entry key="StructFieldUndefinedLocked">结构体字段 ''{0}'' 无效。代码生成不支持在读取或使用结构体后向其添加新字段。</entry>
    <entry key="StructureExtraneousField">结构体不匹配。右侧的结构体有一个额外的字段 ''{0}''。</entry>
    <entry key="StructureExtraneousFieldOnCell">结构体不匹配。右侧元素 ''{0}'' 中的结构体有一个额外的字段 ''{1}''。</entry>
    <entry key="StructureExtraneousFieldOnField">结构体不匹配。右侧字段 ''{0}'' 中的结构体有一个额外的字段 ''{1}''。</entry>
    <entry key="StructureFieldNameMismatch">结构体不匹配。左侧结构体的位置 {1,number,integer} 中的字段名称 ''{0}'' 与右侧结构体的字段名称 ''{2}'' 不匹配。</entry>
    <entry key="StructureFieldNameMismatchOnField">结构体不匹配。字段 ''{0}'' 的位置 {2,number,integer} 中的字段名称 ''{1}'' 与字段名称 ''{3}'' 不匹配。</entry>
    <entry key="StructureFieldNameMismatchOnCell">结构体不匹配。元素 ''{0}'' 的位置 {2,number,integer} 中的字段名称 ''{1}'' 与字段名称 ''{3}'' 不匹配。</entry>
    <entry key="StructureMismatchFieldDiffLhs">左侧结构体中的字段未出现在右侧: {0}。</entry>
    <entry key="StructureMismatchFieldDiffRhs">右侧结构体中的字段未出现在左侧: {0}。</entry>
    <entry key="StructureMissingField">结构体不匹配。右侧结构体缺失字段 ''{0}''。</entry>
    <entry key="StructureMissingFieldOnCell">结构体不匹配。右侧元素 ''{0}'' 中的结构体缺失字段 ''{1}''。</entry>
    <entry key="StructureMissingFieldOnField">结构体不匹配。右侧字段 ''{0}'' 中的结构体缺失字段 ''{1}''。</entry>
    <entry key="StructureSizeMismatch">结构体不匹配。左侧结构体有 {0,number,integer} 个字段，右侧结构体有 {1,number,integer} 个字段。</entry>
    <entry key="StructureSizeMismatchOnField">结构体不匹配: 字段 ''{0}'' 中的结构体有 {1,number,integer} 个字段，右侧结构体有 {2,number,integer} 个字段。</entry>
    <entry key="StructureSizeMismatchOnCell">结构体不匹配: 元素 ''{0}'' 中的结构体有 {1,number,integer} 个字段，右侧结构体有 {2,number,integer} 个字段。</entry>
    <entry key="StructureTypeMismatch">结构体类型不匹配；''{0}'' 与 ''{1}'' 不匹配。</entry>
    <entry key="SubsAsgnSizeMismatch">数组的大小不兼容({0} 和 {1})。</entry>
    <entry key="SubscriptAssignmentDissimilar">在不同结构体之间进行了下标赋值。</entry>
    <entry key="SubscriptEmpty">不支持通过下标对空矩阵进行索引。</entry>
    <entry key="SubscriptMissing">缺少矩阵下标。() 内应有一个表达式。</entry>
    <entry key="SubscriptIntoThisTypeIsNotSupported">代码生成不支持通过下标对 ''{0}'' 进行索引。</entry>
    <entry key="SubscriptedAssignmentIntoMxArray">代码生成不支持对 mxArray 进行下标赋值。</entry>
    <entry key="SwitchCaseFiWordLengthSupport">在 SWITCH 表达式中，fi 对象支持的字长为 {0,number,integer} 位或更少。</entry>
    <entry key="SwitchCaseRange">SWITCH case {0} 不在类 {1} 的范围内。</entry>
    <entry key="SwitchCaseRedundant">冗余 SWITCH case。将只执行第一个。</entry>
    <entry key="SwitchCasesInteger">SWITCH case 的计算结果必须为可在 ''int32'' 中表示的整数值。</entry>
    <entry key="SwitchExpression">Switch 表达式必须为标量或字符向量。</entry>
    <entry key="SystemObjectsLibraryNotFound">找不到 System object 支持库。</entry>
    <entry key="SystemObjectsTranslation">生成代码时出错: {0}</entry>
    <entry key="ThisCast">此转换</entry>
    <entry key="TooFewInputArguments">输入参数太少。{0} 需要 {1,number,integer} 个或更多输入(找到 {2,number,integer} 个)。</entry>
    <entry key="TooManyInputArguments">输入参数太多。{0} 接受 {1,number,integer} 个或更少输入(找到 {2,number,integer} 个)。</entry>
    <entry key="TopLevelFunctionCanNotHaveVararg">{1} 中的代码生成不支持对顶层函数使用重复输入或输出，如 ''{0}''。</entry>
    <entry key="TopLevelOutputOfUnknownType">顶层输出参数 {0} 的类型未知或不透明。</entry>
    <entry key="TransientEntryPoint">  不支持瞬变入口函数。</entry>
    <entry key="TransientFunctionCall">无法从非瞬变函数调用瞬变函数。</entry>
    <entry key="TransposeND">未定义 N 维数组的转置。</entry>
    <entry key="TypeMismatch">变量类型不兼容(类型 ''{0}'' 和类型 ''{1}'')。</entry>
    <entry key="TypeMismatchOnField">In field ''{2}'', variable types are incompatible (type ''{0}'' and type ''{1}'').</entry>
    <entry key="TypeMismatchOnCell">在元素 ''{2}'' 中，变量类型不兼容(类型 ''{0}'' 和类型 ''{1}'')。</entry>
    <entry key="TypeNameMismatch">无法执行此赋值，因为左侧变量的用户定义类与右侧变量的用户定义类不匹配(''{0}'' 和 ''{1}'')。</entry>
    <entry key="UnSupportedEmbeddedComponent">不支持此 System object。</entry>
    <entry key="UnauthorizedPCode">未授权编译 P 文件 ''{0}''。在 P 文件中包含指令 coder.allowpcode(''plain'')。 </entry>
    <entry key="UndefinedFunctionOrVariable">未定义函数或变量 {0}。</entry>
    <entry key="UndefinedInternalFunction">未定义函数或变量 {0}。</entry>
    <entry key="UndefinedFunctionOrVariableNargIOInputFcn">未定义函数或变量 {0}。</entry>
    <entry key="UndefinedFunctionOrVariableExtra">未定义函数或变量 ''{0}''。局部变量的第一次赋值会确定其类。</entry>
    <entry key="UndefinedFunctionOrVariablePossibleClass">''{0}'' 既是类又是命名空间。要解决这种多义性，如果引用类 {0} 的属性或方法 ''{1}''，请使用 ''var.{1}'' 而不是 ''{0}.{1}''。</entry>
    <entry key="UnexpectedOperator">意外的 MATLAB 运算符。</entry>
    <entry key="Unimplemented">{0}: {1,number,integer}: 此构造不是为代码生成实现的。</entry>
    <entry key="UnknownCallInputClass">无法确定此函数调用输入的类。</entry>
    <entry key="UnknownCallInputSize">无法确定此函数调用输入的大小。</entry>
    <entry key="UnknownClass">无法确定此表达式的类。</entry>
    <entry key="UnknownError">未知错误。</entry>
    <entry key="UnknownInputClass">无法确定输入的 CLASS。</entry>
    <entry key="UnknownInputSize">无法确定输入的 SIZE。</entry>
    <entry key="UnknownInputSizeAndClass">无法确定输入的大小或类。</entry>
    <entry key="UnknownSize">无法确定此表达式的大小。</entry>
    <entry key="UnknownSizedSizeVector">无法确定维数。可能的原因是给定的大小向量的长度不同。</entry>
    <entry key="UnknownType">应为 logical、char、int、fi、single 或 double。无法确定有关类型的任何信息。</entry>
    <entry key="UnrecognizedEMLPragmaAnnotation">%#codegen pragma 上的注解无法识别，将被忽略。支持的注解是 %#codegen&lt;AUTO&gt; 和 %#codegen&lt;PRE&gt;。</entry>
    <entry key="UnrecognizedOption">无法识别的选项 ''{0}''。</entry>
    <entry key="UnrecognizedOptionEnumValue">无法识别的枚举值 ''{0}''。有效的枚举选项为: ''{1}''。</entry>
    <entry key="UnsupportedClass">不支持 ''{0}'' 作为要转换的操作数。</entry>
    <entry key="UnsupportedFeatureCallThroughNonConstantFunction">代码生成不支持通过非常量函数的调用。</entry>
    <entry key="UnsupportedFeatureClass">代码生成不支持 ''Class''。</entry>
    <entry key="UnsupportedFeatureDotNotationOnEmbeddedFi">不支持对 ''embedded.fi'' 使用圆点表示法。</entry>
    <entry key="UnsupportedFeatureEmptyMatricesInStructures">不支持结构体中有空矩阵。</entry>
    <entry key="UnsupportedFeatureEmptyStructures">不支持空结构体。</entry>
    <entry key="UnsupportedFeatureForLoopsWithNonRealIndices">具有非实数索引的 FOR 循环。</entry>
    <entry key="UnsupportedFeatureFunnyLHS">不支持用非 A(X)、A(X,Y) 或 A 形式的 LHS 赋值。</entry>
    <entry key="UnsupportedFeatureInt64">Stateflow 中不支持数值类 ''int64'' 和 ''uint64''。</entry>
    <entry key="UnsupportedTypeHalf">此工作流不支持半精度代码生成。请联系 halfprecisionfeedback@groups.mathworks.com，告诉我们为什么它对您很重要。</entry>
    <entry key="UnsupportedTypeHalfLocationLogging">buildInstrumentedMex 不支持半精度数据类型。</entry>
    <entry key="UnsupportedFeatureInverseDivision">不支持反除法。</entry>
    <entry key="UnsupportedFeatureInverseMatrixDivision">代码生成不支持反矩阵除法。</entry>
    <entry key="UnsupportedFeatureMATLABTypeInStructures">代码生成不支持结构体内部的 MxArray。</entry>
    <entry key="UnsupportedFeatureMatrixDeletion">代码生成不支持矩阵删除。</entry>
    <entry key="UnsupportedFeatureMatrixDivision">代码生成不支持矩阵除法。</entry>
    <entry key="UnsupportedFeatureMatrixPower">代码生成不支持矩阵幂。</entry>
    <entry key="UnsupportedFeatureMethodDotNotationOnEmbeddedComponent">代码生成不支持对 System object 使用圆点表示法方法。请改为将对象作为第一个参数传递给方法。</entry>
    <entry key="UnsupportedFeatureMixingOpaqueAndNonOpaqueTypes">不支持混合使用不透明和非不透明类型。</entry>
    <entry key="UnsupportedFeatureNonScalarFunctionHandles">代码生成不支持非标量函数句柄。</entry>
    <entry key="UnsupportedFeaturePower">代码生成不支持幂。</entry>
    <entry key="UnsupportedFeatureReferencingAComponentFromNonScalarArray">代码生成不支持直接访问非标量结构体的字段。此限制也适用于非标量对象的属性。</entry>
    <entry key="ReferencingAComponentWhenGrowing">代码生成不支持在使用 ''end+1'' 增大结构体数组时直接访问字段。请在增大结构体数组后修改该字段。此限制也适用于对象的属性。</entry>
    <entry key="UnsupportedFeatureReferencingAComponentFromScalarBeingGrown">代码生成不支持在使用圆点表示法定义结构体字段之后使用 (end + 1) 索引增大结构体。要使用(end + 1)增大结构体数组，请使用 struct 构造函数定义结构体字段。</entry>
    <entry key="UnsupportedFeatureReturningStructuresFromMATLABFunctions">从 MATLAB 函数返回结构体。</entry>
    <entry key="UnsupportedFeatureSEAInValueClass">代码生成不支持值类中的 System object。</entry>
    <entry key="UnsupportedFeatureSetDotNotationOnEmbeddedComponent">代码生成不支持在构造后设置 System object 的属性。</entry>
    <entry key="UnsupportedFeatureSpmd">代码生成不支持 spmd。</entry>
    <entry key="UnsupportedFeatureStructFromClass">代码生成不支持从对象构造结构体。</entry>
    <entry key="UnsupportedFeatureStructValues">代码生成不支持结构体值。</entry>
    <entry key="UnsupportedFeatureStructureArray">GETFIELDNAME 不支持用于代码生成的结构体数组。</entry>
    <entry key="UnsupportedFeatureTryCatch">代码生成不支持 try 和 catch。</entry>
    <entry key="UnsupportedFeatureThrow">代码生成不支持抛出异常功能。</entry>
    <entry key="UnsupportedFeatureTypeInStructures">代码生成不支持结构体中的 ''{0}'' 类型。</entry>
    <entry key="UnsupportedFeatureWritingPropertiesToEmbeddedFimath">代码生成不支持将属性写入 ''embedded.fimath''。</entry>
    <entry key="UnsupportedFeatureWritingPropertiesToEmbeddedNumerictype">代码生成不支持将属性写入 ''embedded.numerictype''。</entry>
    <entry key="UnsupportedFeatureWritingPropertiesToFi">代码生成不支持将属性写入 ''embedded.fi''。</entry>
    <entry key="UnsupportedFileExtension">代码生成仅支持 MATLAB 文件。不支持 ''{1}'' 的文件扩展名 ''{0}''。</entry>
    <entry key="UnsupportedMexCall">函数调用解析为 MEX 文件 ''{0}''。代码生成仅支持 MATLAB 文件。请使用 coder.extrinsic 将此 MEX 函数声明为外部函数。</entry>
    <entry key="UnsupportedMultiOutput">不支持多个输出。</entry>
    <entry key="UnsupportedTerminal">检测到解析错误: 不支持的终端符号。</entry>
    <entry key="UpperBoundDoesNotMatch">维度 {0,number,integer} 具有上界 {1,number,integer}，该上限与预期的上界 {2,number,integer} 不匹配。</entry>
    <entry key="UseCurlyBracesIndexingForVarargs">此运算不支持元胞数组。请改用花括号。</entry>
    <entry key="ValuelistUnknownParent">{0} 不能在此上下文中使用。</entry>
    <entry key="NamedArgsUnavailableDueToFunctionDirective">''{0}'' 不支持命名参数。</entry>
    <entry key="ValueUnavailableDueToFunctionDirective">''{0}'' 必须放在任何函数输入之前。在此行之前使用了变量 ''{1}''。</entry>
    <entry key="ValueUnavailableDueToOptimization">由于优化，值不可用。</entry>
    <entry key="VarargArrayIsEmpty">''{0}'' 包含零个元素；请求了元素 {1,number,integer}。</entry>
    <entry key="VarargoutCanNotGrowInLoop">重复输出变量 ''{0}'' 无法在 FOR 或 WHILE 语句中增长。</entry>
    <entry key="VariableExpected">需要变量名称。</entry>
    <entry key="CellArrayIndexingNotSupported">代码生成不支持使用圆括号 () 对元胞数组进行索引。请改用花括号 '{}'。</entry>
    <entry key="VarsizeBlocked">可变大小数组当前被禁用，无法生成代码。</entry>
    <entry key="VarsizeDimSizeMismatch">\n维度 {0,number,integer} 中的大小不兼容({1,number,integer} 和 {2,number,integer})。</entry>
    <entry key="VarsizeRequiresVariableSizing">To use coder.varsize, enable support for variable-size arrays.</entry>
    <entry key="VarsizeVariableNameExpected">coder.varsize() 的输入必须为变量名称或 ''variable.field1.field2'' 序列。</entry>
    <entry key="VectorNonNumeric">不支持非数值向量表达式。</entry>
    <entry key="VectorNotDouble">不支持非双精度向量表达式。</entry>
    <entry key="VectorStride">不支持步幅为零的向量表达式。</entry>
    <entry key="VisibilityChangeToField">字段 ''{0}'' 的可见性从 ''{1}'' 更改为 ''{2}''。</entry>
    <entry key="VisibilityChangeToMethod">方法 ''{0}'' 的可见性从 ''{1}'' 更改为 ''{2}''。</entry>
    <entry key="VoidInExpr">不返回输出的函数调用无法嵌入表达式中。</entry>
    <entry key="WarningLimitReached">达到警告限制。将隐藏进一步的警告消息。</entry>
    <entry key="XCatMixingEnumAndNonEnumTypes">代码生成不支持在 horzcat/vertcat 中混合使用枚举和非枚举类。</entry>
    <entry key="XCatMixingEnumTypes">无法串联 ''{0}'' 和 ''{1}'' 两个不同类的对象。</entry>
    <entry key="XRefUnknownOption">传递给 ''{0}'' 的选项无法识别。</entry>
    <entry key="NestedParallelForLoops">parfor 循环无法嵌套。</entry>
    <entry key="MissingIsEmptyForHandleObjects">对于代码生成，必须使用 'if isempty' 代码块来构造句柄对象并将其存储在持久变量中。</entry>
    <entry key="Suppressed">已隐藏错误。</entry>
    <entry key="DebugError">内部调试错误消息。</entry>
    <entry key="NullAssignmentOneNonColonOnly">空赋值只能有一个非冒号索引。</entry>
    <entry key="InvalidIntClassName">类名无效。</entry>
    <entry key="SysObjUnboundedInput">此 System object 方法不支持无界大小的输入。</entry>
    <entry key="SysObjUnboundedInputMallocAll">This System object method does not support input of unbounded size.\nConfigure 'DynamicMemoryAllocation' to a mode other than 'AllVariableSizeArrays' to allow automatic size propagation.</entry>
    <entry key="SysObjUnboundedOutput">此 System object 方法不支持无界大小的输出。</entry>
    <entry key="SysObjUnboundedOutputMallocAll">此 System object 方法不支持无界大小的输出。\n请将 'DynamicMemoryAllocation' 配置为 'AllVariableSizeArrays' 以外的模式，以允许自动大小传播。</entry>
    <entry key="Int64InSizePropagation">由于条件表达式中存在 int64/uint64 类型，无法确定此模块的输出大小。</entry>
    <entry key="MCOSVarSizeHandleProp">仅当启用动态内存分配时，才支持句柄类中的可变大小属性。</entry>
    <entry key="MCOSVarSizeHandlePropFromJoin">\n此运算会将 ''{1}.{0}'' 的大小从 {2} 更改为 {3}。</entry>
    <entry key="MCOSVarSizeHandlePropFromJoinOnField">\n该运算将 ''{2}'' 中句柄类 ''{1}'' 的属性 ''{0}'' 的大小从 {3} 更改为 {4}，并使该属性的大小可变。</entry>
    <entry key="MCOSVarSizeHandlePropFromRhs">\n此运算将 ''{1}.{0}'' 定义为 {2}。</entry>
    <entry key="MCOSVarSizeHandlePropDynamicAllocation">\n启用动态内存分配。</entry>
    <entry key="MCOSUnsupportedOnProp">类属性不支持 ''{0}''。</entry>
    <entry key="MCOSCoderVarSizeOnClass">coder.varsize() 不支持类。</entry>
    <entry key="MCOSCoderVarSizeOnString">coder.varsize is not supported for string variables.</entry>
    <entry key="MCOSUnsupportedCallToSetupImpl">代码生成不支持 ''setupImpl'' 方法。请改用 ''setup'' 函数。</entry>
    <entry key="MCOSCstrDefineHPropNotDeclaredInThisCls">类 ''{0}'' 的构造函数只能定义在它自身中声明的句柄属性。然而，属性 ''{1}'' 是在 ''{2}'' 中声明的。</entry>
    <entry key="MCOSSetupImplDefineHPropNotDeclaredInThisCls">类 ''{1}'' 的方法 ''{0}'' 只能定义在类 ''{2}'' 中声明的句柄属性。然而，属性 ''{3}'' 是在 ''{4}'' 中声明的。</entry>
    <entry key="MCOSHPropAssignOverlapInCstrAndSetupImpl">代码生成要求对一个句柄属性最多只赋值一次。可以在 ''{1}'' 的构造函数中对属性 ''{0}'' 赋值。</entry>
    <entry key="MCOSSetupImplCalledTwice">代码生成要求只调用一次此方法。但实际上调用了两次或多次此方法。</entry>
    <entry key="MCOSSetupImplCalledOnlyOnce">代码生成要求只调用一次此方法。此调用可能执行了零次或多次。</entry>
    <entry key="MCOSSetupImplFirstArgThisPtr">'setupImpl' 的第一个参数只能是变量 ''{0}''。</entry>
    <entry key="MCOSCallSetupImplOfBaseCls">类 ''{0}'' 的方法 'setupImpl' 只能调用在其直接超类中声明的 'setupImpl' 方法。</entry>
    <entry key="MCOSSetPropOnHandle">代码生成中不支持使用 ''{0}'' 定义句柄属性。</entry>
    <entry key="InternalSetPropNotProperlyAssigned">必须将 coder.internal.setprop 赋给实例变量，例如 obj = coder.internal.setprop(obj,...);</entry>
    <entry key="InternalSetPropObjNotInstanceVariable">coder.internal.setprop 的第一个参量必须为实例变量。</entry>
    <entry key="RecursiveFunctionExtraInput">对于代码生成，不支持使用同时在外部函数中使用的变量的嵌套运行时递归函数。''{0}'' 在嵌套的运行时递归函数 ''{1}'' 中和一个外部函数中使用。</entry>
    <entry key="RecursiveFunctionInput">对于代码生成，不支持具有 {0} 个输入的运行时递归函数。输入 ''{1}'' 包含一个 {0}。</entry>
    <entry key="RecursiveDestructorNotSupported">代码生成不支持递归 delete 方法。</entry>
    <entry key="RecursiveFunctionOutput">对于代码生成，不支持具有 {0} 个输出的运行时递归函数。输出 ''{1}'' 包含一个 {0}。</entry>
    <entry key="CannotConvertToIndexInt">无法将值转换为 coder.internal.indexInt。外围运算要求所有操作数均为 coder.internal.indexInt。</entry>
    <entry key="MCOSEscapingHandleObjectInLoopUnsupported">无法分配此句柄对象。对于代码生成，在循环内分配的句柄对象无法在循环外引用。</entry>
    <entry key="MCOSEscapingHandleObjectInRecursionUnsupported">无法分配此句柄对象，因为句柄对象已创建多次。对于代码生成，只有递归函数的其中一次调用能创建句柄对象。</entry>
    <entry key="MCOSEscapingHandleObjectPersistentUnsupported">无法重新分配由持久变量引用的句柄对象，因为该句柄对象已创建多次。要进行代码生成，请确保只创建一次由持久变量引用的句柄对象。</entry>
    <entry key="AutoExtrinsicUsage">仅在 MATLAB 环境中支持此调用以及可能的其他调用。报告中对具有有限支持的所有调用进行了区分。</entry>
    <entry key="AutoExtrinsicDisabledUsage">仅在 MATLAB 环境中支持此调用。</entry>
    <entry key="CoderReplaceInEntryPoint">入口函数中不支持 'coder.replace'。</entry>
    <entry key="CoderReplaceNoVarargoutSupport">输出数目可变的函数不支持 'coder.replace'。</entry>
    <entry key="CoderReplaceVariableSizedInput">'coder.replace' 与可变大小输入不兼容。函数输入 #{0,number,integer} 的大小可变。</entry>
    <entry key="CoderReplaceVariableSizedOutput">'coder.replace' 与可变大小输出不兼容。函数输出 #{0,number,integer} 的大小可变。</entry>
    <entry key="CoderReplaceGlobalVar">访问全局变量的函数不支持 'coder.replace'。请更新函数以替换全局变量并将其作为参量传递。</entry>
    <entry key="CoderReplacePersistVar">'coder.replace' 用于了访问持久变量的函数。这种用法很容易导致代码不正确，将在以后的版本中弃用。请更新函数以替换持久变量并将其作为参量传递。</entry>
    <entry key="CoderReplaceSyntaxError">'coder.replace' 的参数无效。仅支持 '-errorifnoreplacement' 和 '-warnifnoreplacement'。</entry>
    <entry key="CoderReplaceReplacementNotFound">找不到函数 ''{0}'' 的函数替换。</entry>
    <entry key="MultipleInstancesOfCoderReplace">不允许在同一函数中有多个 ''coder.replace'' 实例。</entry>
    <entry key="MCOSSimulinkCoderLimitationPointers">无法生成代码，因为持久变量 ''{0}'' 具有指针类型。</entry>
    <entry key="MCOSPersistentPropertyMismatch">无法将类型为 ''{4}'' 的值赋给持久变量 ''{2}'' 的属性 ''{1}''，因为在以前对函数 ''{0}'' 的调用中，此变量被赋予了类型 ''{3}''。</entry>
    <entry key="MCOSPersistentPropertyValueMismatch">已多次调用函数 ''{0}''，其中一些调用为持久变量 ''{2}'' 的不可调属性 ''{1}'' 赋予了不同的值。</entry>
    <entry key="ControlC">用户已中止编译。</entry>
    <entry key="MCOSMethodAccessListRestricted">无法访问类 ''{1}'' 中的方法 ''{0}''。</entry>
    <entry key="MCOSPropertyAccessListRestricted">无法检索 {1} 的属性 {0}，因为对此属性的访问受到限制。</entry>
    <entry key="CellarrayUsedAtEntryPoint">{1} 中不支持元胞数组作为顶层函数输出。输出 ''{0}'' 是元胞数组。</entry>
    <entry key="CellarrayHCatOnly">代码生成仅支持行向量元胞数组。</entry>
    <entry key="VararginAssignNotSupported">代码生成不支持对 ''{0}'' 赋值。</entry>
    <entry key="CellSubscriptMustBeScalarOrVector">元胞下标索引必须为标量或向量。</entry>
    <entry key="CellarraysAreNotSupportedHere">此处不支持元胞数组。</entry>
    <entry key="VarargsAreNotSupportedHere">此处不支持 varargin 和 varargout 等重复变量。</entry>
    <entry key="CellsubMultiIndexNotSupported">不支持对元胞数组进行多维索引。</entry>
    <entry key="CellConstructorSizeMismatch">不是矩形元胞数组。所有行的大小都应匹配。</entry>
    <entry key="CellConstructorTooManyElements">元素数超过 {0, number, integer}。</entry>
    <entry key="CellIdxHeterogeneousNonConst">代码生成中不支持对异构元胞数组进行非常量索引。</entry>
    <entry key="UnsupportedFeatureNestedFunctions">{0} 中不支持嵌套函数。</entry>
    <entry key="CellSubscriptEmpty">Index is out of bounds because the cell array is empty.</entry>
    <entry key="CStructNameCell">无法将元胞数组赋给具有冲突结构体信息的元胞数组，也无法反向赋值。</entry>
    <entry key="CannotConvertToHeteroGeneous">无法使此元胞数组成为异构元胞数组。</entry>
    <entry key="BadMessageIdentifier">''{0}'' 不是有效的消息标识符。</entry>
    <entry key="OpaqueCastOpaqueArg">''fromOpaqueCast'' 的第一个参数必须为不透明类型。</entry>
    <entry key="ConstantSizeRequiredOnDmension">使用 '':'' 或 ''end'' 需要维度 ''{0, number, integer}'' 上具有常量大小的元胞数组。</entry>
    <entry key="CellTooManyOutputsRequested">请求的输出太多。其原因很可能是含有逗号分隔列表扩展的左侧两旁缺少 []。</entry>
    <entry key="CellLhsValueListEmpty">左侧已初始化且索引范围为空。但右侧返回一个或多个结果。</entry>
    <entry key="CellCatNotRectangular">串联的矩阵的维度不一致。</entry>
    <entry key="CellIndexingNDFewerIndices">代码生成不支持对索引数少于维数的元胞数组进行索引。</entry>
    <entry key="CellIndexingNonScalar">代码生成不支持以这种方式对元胞数组进行非标量索引。</entry>
    <entry key="CellIndexingLogical">代码生成不支持对元胞数组进行逻辑索引。</entry>
    <entry key="NonScalarCellRefIndex">On the left side of an assignment, an index into a cell array must extract exactly one element.</entry>
    <entry key="MxArrayInCellNotSupported">代码生成不支持元胞数组内的 mxArray。</entry>
    <entry key="VarargAssignmentNeedsFixedSizeVector">对重复变量 ''{0}'' 的赋值要求右侧是固定大小的行向量。</entry>
    <entry key="VarargAssignmentToCellFunction">代码生成不支持从 "cell" 函数中对重复变量 ''{0}'' 赋值。请直接对 ''{0}'' 的各个元素赋值。</entry>
    <entry key="CellUsageOfUnassignedElement">此操作尝试使用未定义的元胞数组元素。要进行代码生成，所有元胞数组元素必须在使用前定义。</entry>
    <entry key="CellUsageOfUnassignedElementWithPath">Elements ''{0}'' not fully defined. For code generation, all cell array must be defined before use.</entry>
    <entry key="CellFunctionNoArgs">传递给 cell 函数的输入参数不足。</entry>
    <entry key="CellFunctionSingleArgMistyped">传递给 cell 函数的单个参数必须为标量、由标量组成的向量或元胞数组。</entry>
    <entry key="CellFunctionMultipleNonScalarInts">向 cell 函数传递了多个非整数标量参数</entry>
    <entry key="InputFollowingLikeIsNotANumericArray">''like'' 后面的输入参数必须为数值数组。</entry>
    <entry key="InputFollowingLikeIsNotALogicalArray">''like'' 后面的输入参数必须为逻辑数组。</entry>
    <entry key="CellEntryPointOutputWithUnassignedElement">入口函数返回的元胞数组的元素 ''{0}'' 未完全定义。要进行代码生成，所有元胞数组元素必须在使用前定义。</entry>
    <entry key="CellRecursiveOutputWithUnassignedElement">运行时递归函数返回的元素 ''{0}'' 未完全定义。要进行代码生成，所有元胞数组元素必须在使用前定义。</entry>
    <entry key="CellUseOfElementLockedAsUnassigned">使用后无法初始化元胞数组元素。要进行代码生成，所有元胞数组元素必须在使用前定义。</entry>
    <entry key="CellUseOfElementLockedAsUnassignedWithPath">在定义前使用了元胞数组元素 ''{0}''。要进行代码生成，所有元胞数组元素必须在使用前定义。</entry>
    <entry key="CellHomogeneousCellAssignedNonCompatibleHeterogeneous">赋值左侧的同构元胞数组无法重新赋给异构元胞数组。</entry>
    <entry key="CellHeterogeneousCellAssignedNonCompatibleHomogeneous">赋值左侧的异构元胞数组无法重新赋给同构元胞数组。</entry>
    <entry key="OneElementCellArrayExpected">此处需要一元元胞数组。</entry>
    <entry key="StorageClassGlobalVarNotDefined">变量 ''{0}'' 不是全局变量。在为 ''{1}'' 声明存储类之前，请将其设为全局变量。</entry>
    <entry key="StorageClassUnsupportedSC">不支持存储类名称 ''{0}''。</entry>
    <entry key="StorageClassMultiAssignAttempt">尝试将存储类重新赋给变量 ''{0}''。</entry>
    <entry key="StorageClassNotSupported">在此上下文中不支持调用 'storageClass' 函数。</entry>
    <entry key="StorageClassConstGlobalNotSupported">尝试将存储类赋给 'constant' 全局变量 ''{0}''。不支持将存储类赋给 'constant' 全局变量。</entry>
    <entry key="StorageClassReservedKeyword">变量 ''{0}'' 的名称与标准库中的保留关键字冲突。</entry>
    <entry key="StorageClassWritableGlobalNoDefine">尝试将 'ExportedDefine' 存储类赋给可写全局变量 ''{0}''。请将此存储类赋给只读全局变量。</entry>
    <entry key="StorageClassMultiWordNoDefine">尝试将 'ExportedDefine' 存储类赋给多字变量 ''{0}''。多字变量通常以结构体形式表示，因此它们不适合 'ExportedDefine' 存储类。</entry>
    <entry key="StorageClassNonScalarNoDefine">尝试将 'ExportedDefine' 存储类赋给非标量变量 ''{0}''。请将此存储类赋给实数标量变量。</entry>
    <entry key="StorageClassDynamicNotSupported">尝试将存储类赋给可变大小的全局变量 ''{0}''。仅支持固定大小的变量。</entry>
    <entry key="InvalidDataAlignmentValue">对齐值必须是正整数并且是 2 的幂。</entry>
    <entry key="DataAlignmentVarNotFound">数据对齐不支持 ''{0}''。请使用全局变量或 I/O 变量。</entry>
    <entry key="DataAlignmentDynamicNotSupported">数据对齐不支持 ''{0}'' 可变大小变量。</entry>
    <entry key="DataAlignmentScalarNotSupported">''{0}'' scalar variable not supported for data alignment.</entry>
    <entry key="DataAlignmentComplexTypeNotSupported">数据对齐不支持 ''{0}'' 复变量。</entry>
    <entry key="DataAlignmentMultiAssignAttempt">数据对齐值已赋给 ''{0}''。不支持重新赋值。</entry>
    <entry key="ExpectedCellArray">需要元胞数组。</entry>
    <entry key="ExpectedVariable">需要变量。</entry>
    <entry key="CellTopLevelOutputNotFullyDefined">必须对顶层输出变量 ''{0}'' 进行完整赋值。</entry>
    <entry key="ValueReturnedFromFuncNotFullyDefined">必须对从 ''{0}'' 返回的值进行完整赋值。</entry>
    <entry key="CellArrayVarSizeIndexingIntoHeterogeneous">无法为索引大小未知且基础元胞数组为非同构的索引表达式生成代码。</entry>
    <entry key="UnsupportedDataTypeConversion">不支持的数据类型转换: ''{0}''</entry>
    <entry key="CellTypeMismatchGeneric">无法执行赋值，左侧和右侧的类型不相关。</entry>
    <entry key="StructArrayViaCellHomogeneous">参数编号 ''{0,number,integer}'' 是元胞数组，其元素的类型并不全部相同。对于代码生成，使用元胞数组创建结构体数组需要元胞数组的元素具有相同的类型。</entry>
    <entry key="CellConstructedCellNotFullyDefined">构造的元胞数组未完全定义。要进行代码生成，所有元胞数组元素必须在使用前定义。</entry>
    <entry key="CellPassedToFuncNotFullyDefined__generic">Cell array input to function ''{0}'' not fully defined. For code generation, all cell array elements must be defined before use.</entry>
    <entry key="CellPassedToFuncNotFullyDefined__namedCell_unknownVals">传递给函数 ''{1}'' 的元胞数组 ''{0}'' 的元素未完全定义。要进行代码生成，所有元胞数组元素必须在使用前定义。</entry>
    <entry key="CellPassedToFuncNotFullyDefined__namedCell_knownVals">Elements ''{2}'' of cell array ''{0}'' passed to function ''{1}'' not fully defined. For code generation, all cell array elements must be defined before use.</entry>
    <entry key="CellPassedToFuncNotFullyDefined__returnedCell_knownVals">函数 ''{0}'' 返回的元胞数组的元素 ''{2}'' 在该元胞数组用作函数 ''{1}'' 的输入之前未完全定义。要进行代码生成，所有元胞数组元素必须在使用前定义。</entry>
    <entry key="CellPassedToFuncNotFullyDefined__returnedCell_unknownVals">从函数 ''{0}'' 返回的元胞数组在用作函数 ''{1}'' 的输入之前未完全定义。要进行代码生成，所有元胞数组元素必须在使用前定义。</entry>
    <entry key="VarsizeOnInputVar">函数输入变量 ''{0}'' 不支持 coder.varsize。请改为将 coder.varsize 与作为被调函数的输入的变量一起使用。</entry>
    <entry key="VarsizeOnByRefExtraVar">同时在嵌套函数和包含该嵌套函数的函数中使用的变量不支持 coder.varsize。</entry>
    <entry key="InfiniteLoop">由于存在无限循环，函数 ''{0}'' 不会终止。</entry>
    <entry key="MCOSTypedPropertyUnsupported">属性 ''{0}'' 限制其值的类。代码生成不支持限制属性值的类。</entry>
    <entry key="Db4uNestedFunction">Variable ''{0}'' not defined on all execution paths before it is used in a nested function. For code generation, all variables must be fully defined before use.</entry>
    <entry key="Db4uOverflow">codegen 在分析函数 ''{0}'' 时遇到内部资源限制。从函数的输入变量可以访问 ''{1}'' 的大量实例。</entry>
    <entry key="RelopOnCellNotSupported">此运算符没有定义为支持 'cell' 类型的输入参数。</entry>
    <entry key="CatOnCellAndValuelistNotSupported">代码生成不支持元胞数组和以逗号分隔的列表的串联。</entry>
    <entry key="CatOnStructValuelistOfCellNotSupported">代码生成不支持从结构体数组生成的以逗号分隔的元胞列表的串联。</entry>
    <entry key="CatOnCellVarargNotSupported">代码生成不支持串联重复变量，如 varargin 和 varargout。请将重复变量复制到另一个临时变量，然后使用此临时变量进行串联。</entry>
    <entry key="CEvalOnCellNotSupported">coder.ceval() 不支持 'cell' 类型的输入或输出。</entry>
    <entry key="ForeignFcnOnCellNotSupported">此函数不支持 'cell' 类型的输入或输出。</entry>
    <entry key="ValidatorSizeMismatch">Invalid argument. Input dimension {2} is size {0} but is constrained to size {1} by argument validation.</entry>
    <entry key="CannotValidateMxArray">代码生成不支持对 mxArray 对象进行验证。</entry>
    <entry key="TabularSizeValidator">代码生成不支持对表或时间表对象的大小进行验证。</entry>
    <entry key="CincludeUnknownParam">参数名称 {0} 无法识别。</entry>
    <entry key="CincludeInvalidInput">参数名称-值对组无效。</entry>
    <entry key="BinaryOperationsOnEnumsNotSupported">代码生成不支持对枚举值进行二元运算。此表达式是一个枚举值。</entry>
    <entry key="StringsAreNotSupported">{0} 中不支持字符串。</entry>
    <entry key="StringArraysNotSupported">代码生成不支持字符串数组。使用一个字符向量元胞数组。</entry>
    <entry key="DeferInferenceRequiresNoOutputs">延迟的函数不能有输出。</entry>
    <entry key="ColonOperatorResultTooLarge">数组太大，无法进行此运算。要使用冒号运算符创建数组或通过下标对数组进行索引，数组中的元素数必须小于 intmax。</entry>
    <entry key="CellsPassedToStructMustBeFullyAssigned">必须对传递给结构体的元胞数组进行完整赋值。</entry>
    <entry key="GetMCOSFailure">无法加载类 ''{0}''。</entry>
    <entry key="UndefinedPersistentVariable">必须对持久变量 ''{0}'' 赋值，然后才能使用它。唯一的例外是使用 ''isempty({1})'' 执行的检查可以在赋值前执行。</entry>
    <entry key="UnsupportedConversionFromToEnum">不支持从 ''{0}'' 转换为枚举 ''{1}''。</entry>
    <entry key="SxfunFirstArgumentExtrinsic">coder.internal.sxfun 的第一个参数不能为外部函数。</entry>
    <entry key="UnsupportedSparseType">Returning sparse matrices of class ''{0}'' to MATLAB is not supported.</entry>
    <entry key="InputMustBeSparse">Input argument must be sparse.</entry>
    <entry key="SparseNotSupported">''{0}'' does not support sparse matrix inputs.</entry>
    <entry key="ValidateattributesNeedConstAttributes">属性必须为常量。</entry>
    <entry key="InvalidParamToCoderInternalReferenceParameter">coder.internal.reference_parameter 需要一个传递给它的参量，该参量是主调函数的标量输入和输出变量。</entry>
    <entry key="ReferenceParameterCannotBeCell">函数 ''{0}'' 要求输入 ''{1}'' 不是元胞数组。</entry>
    <entry key="InvalidCallToRefParamFcn">The function ''{0}'' requires that the variable ''{1}'' be passed to it as both an input and output argument.</entry>
    <entry key="RefereneceParameterEntryPoint">使用 ''coder.internal.reference_parameter'' 的函数不能为入口函数。请使用调用 ''{0}'' 的包装函数。</entry>
    <entry key="CallToRefParamFcnNotDirectlyInAssign">使用 coder.internal.reference_parameter 的函数必须直接在赋值表达式中使用，其中匹配的输入和输出变量具有相同的名称和类型。请确保输出变量的类型在调用点后不会更改。</entry>
    <entry key="ReferenceParameterInputAndOutputTypesDisagree">coder.internal.reference_parameter 要求变量 ''{0}'' 的输入和输出类型相等。</entry>
    <entry key="CoderVarsizeCannotChangeBlockInputVar">coder.varsize 无法更改模块输入 ''{0}'' 的大小。请使用模块配置对话框修改输入的大小。</entry>
    <entry key="CoderVarsizeCannotChangeBlockOutputVar">coder.varsize 无法更改模块输出 ''{0}'' 的大小。请使用模块配置对话框修改输出的大小。</entry>
    <entry key="CoderVarsizeCannotChangeEntryPointInputVar">coder.varsize 无法更改入口函数输入 ''{0}'' 的大小。请使用 coder.typeof 或 Coder App 修改输入的大小。</entry>
    <entry key="FunctionArgumentValidationAttributeNotSupported">代码生成不支持参数块属性 ''{0}''。</entry>
    <entry key="FunctionArgumentValidationRepeatingEntryPointNotSupported">对于入口函数的 varargin (适用于输入模块)和 varargout (适用于输出模块)以外的参数，代码生成不支持重复参数块。</entry>
    <entry key="FunctionArgumentValidationMultipleRepeatingInputs">代码生成不支持在一个函数中有多个重复的输入参数。</entry>
    <entry key="FunctionArgumentValidationRepeatingTildeNotSupported">代码生成不支持忽略的重复参数。</entry>
    <entry key="FunctionArgumentValidationNamedEntryPoint">代码生成不支持对入口函数的名称-值参数进行函数参数验证。</entry>
    <entry key="FunctionArgumentValidationRepeatingValidatorsNotSupported">代码生成不支持对重复输入/输出(如 ''{0}'')进行参数验证。请删除所有类验证、大小验证和验证函数。</entry>
    <entry key="FunctionArgumentValidationNotEnoughInputArguments">参数列表无效。函数需要另外 {0,number,integer} 个输入。</entry>
    <entry key="FunctionArgumentValidationNamedMissingInput">尚未提供 ''{1}'' 的名称-值参数 ''{0}'' 作为此函数的输入提供。</entry>
    <entry key="FunctionArgumentValidationNamedVariableLHS">代码生成不支持对包含命名字段的参数赋值。请按名称对 ''{0}'' 的各个字段赋值。</entry>
    <entry key="FunctionArgumentValidationNamedVariableRHSLoop">代码生成不支持访问在 FOR 或 WHILE 循环中嵌套的包含命名字段的参数。请使用 ''coder.unroll'' 展开循环，或按名称访问 ''{0}'' 的各个字段，或将 ''{0}'' 复制到局部变量并改用该局部变量。</entry>
    <entry key="FunctionArgumentValidationNamedVariableNestedAnon">代码生成不支持在嵌套函数或匿名函数中引用包含命名字段的参数。请使用 ''{0}'' 的各个字段，或将 ''{0}'' 作为嵌套/匿名函数的输入进行传递。</entry>
    <entry key="FunctionArgumentValidationNamedInvalid">无效的参数名称 ''{0}''。有效名称为 {1}。</entry>
    <entry key="FunctionArgumentValidationNamedAmbiguous">具有多义性的参数名称 ''{0}'' 有多个可能的匹配项: {1}。</entry>
    <entry key="FunctionArgumentValidationNamedNonConst">此参数不是常量，因此在代码生成过程中无法匹配 ''{0}'' 内部的名称-值参数。如果在代码生成期间不知道在调用点处传递的名称，代码生成可能会失败或产生与 MATLAB 不一致的结果。</entry>
    <entry key="FunctionArgumentValidationNamedUnknownIfRow">此参数是否为行向量是在运行时确定的，因此在代码生成过程中无法匹配 ''{0}'' 内的名称-值参数。如果在代码生成期间不知道在调用点处传递的名称，代码生成可能会失败或产生与 MATLAB 不一致的结果。</entry>
    <entry key="FunctionArgumentValidationNamedInvalidBuiltin">代码生成不支持将 ''{0}'' 应用于包含命名字段的参数。</entry>
    <entry key="FunctionArgumentValidationNamedClassNotFound">找不到类 ''{0}''。</entry>
    <entry key="ExistVariableLoop">代码生成不支持检查 for 循环、while 循环、嵌套函数或匿名函数中是否存在变量。</entry>
    <entry key="ExistNoMode">要在代码生成中使用 exist，请提供搜索类型作为第二个参量。</entry>
    <entry key="ExistBuiltinMode">代码生成不支持使用 'builtin' 作为搜索类型来调用 exist。</entry>
    <entry key="ExistClassMode">代码生成不支持使用 'class' 作为搜索类型来调用 exist。</entry>
    <entry key="ExistDirMode">代码生成不支持使用 'dir' 作为搜索类型来调用 exist。请考虑使用 isfolder。</entry>
    <entry key="ExistFileMode">代码生成不支持使用 'file' 作为搜索类型来调用 exist。请考虑使用 isfile。</entry>
    <entry key="ExistVariableNotPatternMatched">当使用 'var' 作为搜索类型调用 exist 时，代码生成仅支持传递字面值参量。此外，对于此搜索类型，代码生成不支持通过函数句柄调用 exist。</entry>
    <entry key="ExistVariableSometimesUndefined">变量 ''{0}'' 的存在与否取决于运行时输入。在调用 exist 函数之前，请在所有执行路径中定义 ''{0}''。或者，确保在 exist 函数调用之前未在任何执行路径中定义 ''{0}''。</entry>
    <entry key="ExistVarargout">代码生成不支持检查 ''{0}'' 是否存在。</entry>
    <entry key="ErrorThrownFromDestructorWithLangTargetCpp">执行类析构函数时捕获到以下错误:\n错误使用 ''{0}'' (第 {1,number,integer} 行)\n{2}</entry>
    <entry key="OutOfMemoryInFcn">内部错误: 编译 ''{0}'' 时内存不足。</entry>
    <entry key="OutOfMemory">内部错误: 内存不足。</entry>
    <entry key="McosClassExpected">输入必须为 MATLAB 对象。</entry>
    <entry key="IsMatlabThreadDeprecated">函数 coder.ismatlabthread 将在以后的版本中删除。</entry>
    <entry key="MissingInputVariable">输入参量的数目不足。输入 ''{0}'' 未提供给此函数或方法。</entry>
    <entry key="EmptyClassName">The input class name cannot be empty.</entry>
    <entry key="BoundedArrayUnimplementedOperation">此操作未在 coder.internal.BoundedArray 上实现。</entry>
    <entry key="BoundedArrayInvalidSizeVector">大小向量无效。</entry>
    <entry key="BoundedArraySizeNotBounded">数据的大小不受 UpperBounds 的限制。</entry>
    <entry key="BoundedArrayOutOfBoundsIndex">索引表达式越界。请尝试沿维度 {1,number,integer} 访问元素 {0,number,integer}。沿该维度的最大值是 {2,number,integer}。</entry>
    <entry key="BoundedArrayCatIncompatibleDimensions">要串联的数组的维度不一致。</entry>
    <entry key="BoundedArrayCatBoundsIncompatibleDimensions">无法串联不兼容的有界数组。要进行代码生成，非串联数组维度的上界必须相同。</entry>
    <entry key="InputMustBeConst">''{1}'' 的输入 {0,number,integer} 必须为常量。</entry>
    <entry key="HandleClassExpected">''{1}'' 的输入 {0,number,integer} 必须为句柄对象。</entry>
    <entry key="MatlabInternalFeatureReadOnly">代码生成仅支持具有一个输入的 matlab.internal.feature。</entry>
    <entry key="CannotComputeSizeOfVarargout">代码生成不支持计算 varargout 的大小、numel 或长度。请改用 nargout。</entry>
    <entry key="SubscriptedAssignmentToThisClassNotAllowedInParallelLoop">代码生成不支持在并行 for 循环中对 ''{0}'' 类型的共享变量进行下标赋值。</entry>
    <entry key="MatrixDeletionNotSupportedInParallelLoop">并行 for 循环内部不支持从共享变量中删除元素。</entry>
    <entry key="Empty"/>
    <entry key="Explicit">{0}</entry>
    <entry key="LineSeparator">\n</entry>
    <entry key="EmbeddedComponentPropagationError">{0}</entry>
    <entry key="GenericForAllErrors">{0}</entry>
    <entry key="MatlabInternalFeatureNotFound">Unknown foundation feature ''{0}''.</entry>
    <entry key="PreferStrongerSpecialization">Internal Error: Prefer stronger specialization</entry>
  </message>
</rsccat>
