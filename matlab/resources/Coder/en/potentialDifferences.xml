<?xml version="1.0" encoding="UTF-8" ?>
<!-- Copyright 2016-2017 The MathWorks, Inc. -->
<rsccat version="1.0" locale="en_US" product="Coder" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../schema/msgcat.xsd">
  <message>
    <entry key="DomainError">The generated code assumes that real input values result in real outputs. If complex outputs are expected, use the 'complex' function to give the input a zero imaginary part.</entry>
    <entry key="UnsupportedSpecialEmpty">The generated code assumes that the variable-size matrix input will not have a 0x0 size.</entry>
    <entry key="diag_varsizedMatrixVector">The generated code extracts the diagonal of a matrix X and returns a vector. If the input X is supposed to be a vector, pass X(:) instead of X.</entry>
    <entry key="UnsupportedNaN">In the generated code, NaN values will not be removed from the input.</entry>
    <entry key="eml_all_or_any_specialEmpty">The generated code assumes that the variable-size matrix input will not have a 0x0 size.</entry>
    <entry key="eml_min_or_max_varDimZero">The generated code assumes that the dimension to operate along has non-zero length.</entry>
    <entry key="NonIncreasing">The generated code assumes that grid values are strictly increasing.</entry>
    <entry key="eml_assert_valid_dim_dimTooLarge">The generated code assumes that sizes are representable using the C type 'int'.</entry>
    <entry key="MustBeFiniteAndStrictlyIncreasing">The generated code assumes that input X is finite and strictly increasing.</entry>
    <entry key="mtimes_noDynamicScalarExpansion">The generated code performs a general matrix multiplication. If a variable-size matrix operand becomes a scalar at run time, dimensions must still agree. There will not be an automatic switch to scalar multiplication.</entry>
    <entry key="autoDimIncompatibility">In the generated code, the dimension to operate along is selected automatically, and might be different from MATLAB. Consider specifying the working dimension explicitly as a constant value.</entry>
    <entry key="VectorVector">For indexing a vector with a vector, vector1(vector2), the code generator assumed that the result would have the same orientation as vector1. If vector1 is a scalar at run time, the orientation of vector2 must match vector1.</entry>
    <entry key="MatrixMatrix">For indexing a matrix with a matrix, matrix1(matrix2), the code generator assumed that the result would have the same size as matrix2. If matrix1 and matrix2 are vectors at run time, their orientations must match.</entry>
    <entry key="OutOfTargetRangeTruncated">The generated code assumes that the index value is within the valid range.</entry>
    <entry key="SizesOverflowOnDim">The generated code assumes that the array operations will be within the upper bounds of each dimension.</entry>
    <entry key="OutOfBoundRange">The generated code assumes that the index is within the array bounds. If the index exceeds the bounds, the array will not grow. To grow the array, consider preallocating memory or using concatenation. For example, [X A].</entry>
    <entry key="NontunableHandleProp">The generated code assumes that the value of a nontunable property does not change at run time.</entry>
    <entry key="ForLoopVector">The generated code assumes that the number of iterations of the loop is representable using the C type 'int'.</entry>
    <entry key="ValueIsNonInteger">The generated code assumes that the value is representable using the C type 'int'.</entry>
    <entry key="SizesMismatch">The generated code assumes that the sizes on the left and right sides match.</entry>
    <entry key="eml_assert_valid_size_arg_invalidSizeVector">The generated code assumes that the size vector is a row vector with finite integer elements that are less than intmax('int32'), and that fit in the C data type 'int' on the target hardware.</entry>
    <entry key="int_forloop_overflow">The generated code assumes the loop index does not overflow on the last iteration of the loop. If the loop index overflows, an infinite loop can occur.</entry>
  </message>
</rsccat>
