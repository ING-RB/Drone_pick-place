<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ja_JP" product="Simulink" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="ModelingStandards">モデリング標準</entry>
    <entry key="modelassistantObsolete">'modelassistant' は旧式です。代わりに 'modeladvisor' を使用してください。</entry>
    <entry key="MALicenseCheckoutFail">ライセンスをチェックアウトできません。{0} に対するライセンスが見つかりません。 </entry>
    <entry key="MAMissVnVLicenseForCustomCheck">カスタム チェックを実行するには、有効な Simulink Check のライセンスが必要です。</entry>
    <entry key="MAMissVnVLicenseForMACE">モデル アドバイザー構成エディターを起動するには、有効な Simulink Check のライセンスが必要です。</entry>
    <entry key="MALoadConfigMissCorrespondCheck">チェック "{0}" ("{1}" で指定) が構成 {2} を読み込むときに見つかりません。missing sl_customization.m ファイルが見つからない、またはツールボックスがインストールされていない可能性があります。</entry>
    <entry key="MAMissCorrespondCheck">チェック {0} が見つかりません。missing sl_customization.m ファイルが見つからない、またはツールボックスがインストールされていない可能性があります。</entry>
    <entry key="MASlcustomizeInsideMlroot">モデル アドバイザーをカスタマイズする sl_customization.m ({0}) ファイルを、MATLAB フォルダーのルートまたは matlabroot/work フォルダー以外のサブフォルダーに配置しないでください。</entry>
    <entry key="MACENoDuplicateName">"{0}" は既に存在します。同じフォルダー内の項目は異なる名前でなければなりません。</entry>
    <entry key="MAErrorChangeWorkConfiguration">モデル アドバイザーは現在 {0} の構成を使用して開かれています。新規構成を使用するには、モデル アドバイザーで [ファイル] &gt; [構成の読み込み] を選択してください。</entry>
    <entry key="MACENotRenameFolder">このフォルダー名は変更できません。</entry>
    <entry key="MACEEmptyDisplayName">名前のフィールドが空です。名前を入力してください。</entry>
    <entry key="MAUnableStartMAWhenMACEOpen">モデル アドバイザー構成エディターが開かれています。モデル アドバイザーを起動する前に構成エディターを閉じてください。</entry>
    <entry key="MACEReservedName">フォルダー "{0}" は予約名のため、その名前にすることはできません。別のフォルダー名を選択してください。</entry>
    <entry key="MAFactoryGrpUnderGrp">ModelAdvisor.FactoryGroup オブジェクト {0} は、タスク別のグループに下にのみ置くことができます。</entry>
    <entry key="MAUnableLocateRestorePointName">指定した復元ポイント {0} の位置を特定できませんでした。</entry>
    <entry key="MASystemRenamed">システム名は {0} から {1} に変更されました。{2} をチェックするには、モデルを再度読み込まなければなりません。</entry>
    <entry key="FPASystemRenamed">システム名は {0} から {1} に変更されました。{2} をチェックするには、モデルを再度読み込まなければなりません。</entry>
    <entry key="MACBTitle">モデル アドバイザーのチェック ブラウザー</entry>
    <entry key="MADisplayName">表示名</entry>
    <entry key="MACheckTitle">チェック タイトル</entry>
    <entry key="MACheckID">チェック ID</entry>
    <entry key="MAToolTip">ヒント</entry>
    <entry key="MAProductAssociation">関連製品</entry>
    <entry key="MATools">ツール</entry>
    <entry key="MANew">新規</entry>
    <entry key="MAUndo">元に戻す</entry>
    <entry key="MARedo">やり直し</entry>
    <entry key="MAOpen">開く</entry>
    <entry key="MACopy">コピー</entry>
    <entry key="MAPaste">貼り付け</entry>
    <entry key="MACut">切り取り</entry>
    <entry key="MAMoveup">上に移動</entry>
    <entry key="MAMovedown">下に移動</entry>
    <entry key="MANewfolder">新規フォルダー</entry>
    <entry key="MAYes">はい</entry>
    <entry key="MAInstructions">解説</entry>
    <entry key="MANo">いいえ</entry>
    <entry key="MAEnable">有効</entry>
    <entry key="MADisable">無効</entry>
    <entry key="MAWorkflow">ワークフロー</entry>
    <entry key="MACreate">作成</entry>
    <entry key="MAConfigure">設定</entry>
    <entry key="MACheck">チェック</entry>
    <entry key="MAManage">管理</entry>
    <entry key="MAFind">検索</entry>
    <entry key="MANameandDescription">名前と説明</entry>
    <entry key="MASearchNameDescription">名前と説明の検索</entry>
    <entry key="MAFindNext">次を検索</entry>
    <entry key="MAFindPrevious">前を検索</entry>
    <entry key="MACloseToolbar">ツール バーを閉じる</entry>
    <entry key="MAPhraseNotFound">見つかりません</entry>
    <entry key="MANumberOccurrences">{0,number,integer}/{1,number,integer}</entry>
    <entry key="MAPhraseFoundInCheckName">チェック名内で見つかりました。</entry>
    <entry key="MAPhraseFoundInFolderName">フォルダー名内で見つかりました。</entry>
    <entry key="MAPhraseFoundInDescription">解析の説明内で見つかりました。</entry>
    <entry key="MASelectMatFile">MAT ファイルの検索</entry>
    <entry key="MASelectMATLABFile">MATLAB ファイルの選択</entry>
    <entry key="MACETitle">モデル アドバイザー構成エディター</entry>
    <entry key="MACETreeTitle">現在の構成: {0}</entry>
    <entry key="MACERootMsg0">モデル アドバイザー構成エディターは、モデル アドバイザーの構成を効率よくカスタマイズして運用します。以下は一般的なワークフローです。</entry>
    <entry key="MACERootMsg1">カスタム チェックを作成します。</entry>
    <entry key="MACERootMsg2">チェック項目を整理しカスタム構成を作成します。</entry>
    <entry key="MACERootMsg3">カスタム構成を展開します。</entry>
    <entry key="MACERootMsg4">モデルがモデリングのガイドラインに準拠していることを検証します。</entry>
    <entry key="MARootMsg0">モデルがモデリングのガイドラインに準拠していることを検証します。</entry>
    <entry key="MACELibRootNodeMsgLine1">チェック ブラウザーからチェックを構成エディターにドラッグアンドドロップします。</entry>
    <entry key="MACENewMsg">新規エディター セッションを開始</entry>
    <entry key="MACELoadMsg">構成の読み込み</entry>
    <entry key="MACEDeleteMsg">選択したチェックまたはフォルダーを削除</entry>
    <entry key="MACEEnableMsg">選択したチェックまたはフォルダーを有効にする</entry>
    <entry key="MACEDisableMsg">選択したチェックまたはフォルダーを無効にする</entry>
    <entry key="MACESaveMsg">現在の構成を保存</entry>
    <entry key="MACECopyMsg">選択したチェックまたはフォルダーをコピー</entry>
    <entry key="MACEPasteMsg">現在のフォルダーに貼り付け</entry>
    <entry key="MACECutMsg">選択したチェックまたはフォルダーを切り取る</entry>
    <entry key="MACEMoveUpMsg">選択したチェックまたはフォルダーを上に移動</entry>
    <entry key="MACEMoveDownMsg">選択したチェックまたはフォルダーを下に移動</entry>
    <entry key="MACEFolderNewMsg">現在のフォルダーに新規フォルダーを作成</entry>
    <entry key="MACECheckBrowserMsg">チェック ブラウザーの起動</entry>
    <entry key="MALoadedConfigurationFromDisk">{0} から読み込まれた構成</entry>
    <entry key="MALoadConfiguration">構成の読み込み...</entry>
    <entry key="MAOpenConfigurationEditor">構成エディターを開く</entry>
    <entry key="MASetDefaultConfiguration">現在の構成を既定の設定にする</entry>
    <entry key="MARestoreDefaultConfiguration">既定の構成に戻す</entry>
    <entry key="MALoadingConfiguration">構成 {0} の読み込み中...</entry>
    <entry key="MASavingConfiguration">構成 {0} を保存中...</entry>
    <entry key="MAUnableLoadPrefConfiguration">構成 {0} を読み込むことができません。</entry>
    <entry key="MACEUnableSaveEmptyConfig">空の構成を保存できません。</entry>
    <entry key="MAWarnLoadConfigUI">新たな構成を読み込むと、モデル アドバイザーの以前の結果とレポートが削除されます。</entry>
    <entry key="MAWarnLoadConfigUIWhenDirty">現在の構成は変更が保存されていません。現在の構成を上書きするために新規構成を開いてください。</entry>
    <entry key="MASetDefaultConfig">{0} は既定の構成として設定されました。</entry>
    <entry key="MAResetDefaultConfig">既定の構成はリセットされました。 </entry>
    <entry key="MAWarnResetDefaultConfig">既定の構成を戻してモデル アドバイザーを再起動しますか?これは既存のレポートを削除します。</entry>
    <entry key="MAInvalidConfigFile">{0} は、有効な構成ファイルではありません。</entry>
    <entry key="MADouWantSaveConfigChange">現在の構成の変更を保存しますか ?</entry>
    <entry key="MAGetConfigObjInvalidSource">入力値が無効です。有効な値は ''ConfigUICellArray'' または ''CheckLibrary'' のいずれかです。</entry>
    <entry key="MAGetConfigObjArrayNotPopulated">ConfigUICellArray が空です。{0} を呼び出す前に ConfigUICellArray を与えなければなりません。</entry>
    <entry key="MARptName">レポート名</entry>
    <entry key="SLVersion">Simulink バージョン</entry>
    <entry key="MdlVersion">モデル バージョン</entry>
    <entry key="MASystem">システム</entry>
    <entry key="MACurrentrun">現在の実行</entry>
    <entry key="MARunSummary">実行の概要</entry>
    <entry key="MASystemSelector">システム セレクター</entry>
    <entry key="MAMdlNewerThanRpt">{0} モデルはモデル アドバイザー レポートよりも新しいです。最新のレポートを生成するために更新したモデルでモデル アドバイザーのチェックを再度実行してください。 </entry>
    <entry key="MAExplorerAdviceMsg"> モデル アドバイザーは、Simulink をシミュレーションとコード生成のために最適に利用できるようにするためにモデルを解析します。特定のチェック項目を選択することで、その項目に対する詳細な情報をレポートできます。これは特に設計の初期段階で役立ちます。 </entry>
    <entry key="MAExplorerStartMsg"> モデル アドバイザーを開始...  </entry>
    <entry key="MASystemHierarchy">システムの階層</entry>
    <entry key="MASystemSelectorDescription">開始するためのシステムを選択してください。</entry>
    <entry key="MASelectSystemDialogTitle">階層からシステムを選択してください:</entry>
    <entry key="MACurrentSystem">現在のシステム</entry>
    <entry key="MACurrentSystemAndBelow">現在のシステム以下</entry>
    <entry key="MAFor">目的</entry>
    <entry key="MAShow">表示</entry>
    <entry key="MASelectSubsystem">サブシステムの選択...</entry>
    <entry key="MAOk">OK</entry>
    <entry key="MAName">名前</entry>
    <entry key="MALoad">読み込み</entry>
    <entry key="MASave">保存</entry>
    <entry key="MASaveAs">名前を付けて保存...</entry>
    <entry key="MADelete">削除</entry>
    <entry key="MAInvalidType">指定したタイプ {0} が無効です。</entry>
    <entry key="MAMASaveRestorepointDialogTitle">モデル アドバイザー:モデルとデータの復元ポイントの保存</entry>
    <entry key="MAMALoadRestorepointDialogTitle">モデル アドバイザー:モデルとデータの復元ポイントの読み込み</entry>
    <entry key="MASaveRestorepointInstruct">復元ポイントに対する名前と説明 (オプション) を入力してください。</entry>
    <entry key="MALoadRestorepointInstruct">読み込む復元ポイントを選択してください。</entry>
    <entry key="MANoRestorepointSaved">保存した復元ポイントはありません。</entry>
    <entry key="MALoadRestorePoint">復元ポイントの読み込み...</entry>
    <entry key="MASaveRestorePoint">復元ポイントの保存</entry>
    <entry key="MASaveAsRestorePoint">別名で復元ポイントを保存...</entry>
    <entry key="MASavingRestorePoint">復元ポイント {0} の保存中...</entry>
    <entry key="MAWarnLoadRestorePoint">復元ポイント {0} を読み込むと現在のモデルとワークスペースを上書きします。</entry>
    <entry key="MAWarnOverwriteRestorePoint">復元ポイント {0} は既に存在します。置き換えますか?</entry>
    <entry key="MAPass">パス</entry>
    <entry key="MAFail">失敗</entry>
    <entry key="MAWarning">警告</entry>
    <entry key="MACancel">キャンセル</entry>
    <entry key="MATotal">総数</entry>
    <entry key="MAWhatsThis">これはなに?</entry>
    <entry key="MAAboutSimulink">Simulink について</entry>
    <entry key="MAUnsupportDataType">サポートされないデータ型です。</entry>
    <entry key="MAUnknownEventReceived">不明なイベントを受け取りました。</entry>
    <entry key="MASpecifySystemName">システム名を指定してください。</entry>
    <entry key="MAInvalidBtnClick">予期せぬボタンがクリックされました。ツールを再開してください。</entry>
    <entry key="MAUnsupportedInputParamType">サポートされない入力パラメーター タイプです。</entry>
    <entry key="MAUnrecognizedSolver">認識されないソルバー: {0}</entry>
    <entry key="MAInvalidNumArgs">引数の数が無効です。</entry>
    <entry key="MAUnexpectedAction">予期せぬアクション</entry>
    <entry key="MAUnableLocateMAObj">{0} に対するモデル アドバイザー オブジェクトが見つかりません。</entry>
    <entry key="MAUnknownMethod">不明なメソッド {0} が指定されました。</entry>
    <entry key="MAUnknownAction">不明なアクション</entry>
    <entry key="MAReportNotExist">レポートが存在しません。新規レポートを生成してください。</entry>
    <entry key="MATriggerUpdateDiagram">モデルの更新トリガー</entry>
    <entry key="MAAbnormalExit">異常終了:</entry>
    <entry key="MAInvalidParam">指定したパラメーターが無効です。パラメーターは {0} でなければなりません。</entry>
    <entry key="MAIncorrectAPIUsage">{0} メソッドの使用が正しくありません。</entry>
    <entry key="MADuplicatedArgName">{0} を異なる名前にしなければなりません。</entry>
    <entry key="MANoGroupAllowedUnderProcedure">ModelAdvisor.Procedure オブジェクトの内部で許可されている ModelAdvisor.Group オブジェクトがありません。</entry>
    <entry key="MAUnableLocateActiveSys">モデル アドバイザーのアクティブなシステムの位置を特定できませんでした。モデル アドバイザー ツールを再起動してください。</entry>
    <entry key="MANoItemToDispaly">表示する項目がありません。</entry>
    <entry key="MACanNotPublishTaskNode">ModelAdvisor.Task オブジェクトの公開は許可されていません。</entry>
    <entry key="MADupProcessCallback">複数のモデル アドバイザーのプロセスのコールバック関数が見つかりません。最優先のものだけが使用されます。</entry>
    <entry key="MAErrorMACallbackFunc">モデル アドバイザーのコールバック関数でエラーが発生: {0}.</entry>
    <entry key="MAPropertyNolongerSupport">プロパティ {0} は、サポートされなくなりました。</entry>
    <entry key="MAMissEntriesForEnum">{0} の内部に定義された入力パラメーターは、タイプ enum に対する入力が足りません。 </entry>
    <entry key="MAMissProductNameWhenPublishObj">有効な製品名を {0} に変換するために必要です。</entry>
    <entry key="MACheckIDDuplicate">チェック ID {0} は、複製されます。</entry>
    <entry key="MACheckTitleDuplicate">チェックのタイトル {0} は、複製されます。</entry>
    <entry key="MATaskIDDuplicate">タスクのアドバイザー ID {0} は、複製されます。</entry>
    <entry key="MAUnableFindCheckSpecified">モデル アドバイザーのチェック {0} ({1} で指定) が見つかりません。スペルが正しくないか、必要なライセンスが見つからないことが原因である可能性があります。</entry>
    <entry key="MAMultipleParentFound">{0} は、複数の親ノードを持っています。</entry>
    <entry key="MARun">実行</entry>
    <entry key="MAValueisReserved">{0} は予約されています。</entry>
    <entry key="MARunToFailure">すべて実行</entry>
    <entry key="MARunAll">すべて実行</entry>
    <entry key="MAContinue">続行</entry>
    <entry key="MAInProgress">進行中の {0}。</entry>
    <entry key="MAGroupLegendNote">グループ フォルダー - 任意の順で実行</entry>
    <entry key="MAProcedureLegendNote">手順フォルダー - 順番に実行</entry>
    <entry key="MANothingtoContinue">続けるフォームがありません。</entry>
    <entry key="MAModelNotRdyForGenReport">モデルは、レポートを作成する準備ができていません。</entry>
    <entry key="MAMissLicense">{0} のタスクは、必要なライセンス {1} が見つからないため、読み込むことができません。</entry>
    <entry key="MANotAllowAddObject">{0} を {1} オブジェクトに追加することはできません。</entry>
    <entry key="MAOneCheckNotSyncRpt">タイムスタンプを持つ 1 の項目が {0} と異なります。</entry>
    <entry key="MAMoreCheckNotSyncRpt">タイムスタンプを持つ {0} の項目が {1} と異なります。</entry>
    <entry key="MACurrent">現在</entry>
    <entry key="MAReset">リセット</entry>
    <entry key="PassedMsg">パス</entry>
    <entry key="FailedMsg">失敗</entry>
    <entry key="WarningMsg">警告</entry>
    <entry key="RecAction">推奨アクション</entry>
    <entry key="LinkToBlocks">以下のリンクを使用して、ブロックまたはダイアログに移動してください:</entry>
    <entry key="SeeAlso">参考</entry>
    <entry key="FormatTemplateConstructorError">FormatTemplate コンストラクターは、''ListTemplate'' または ''TableTemplate'' のいずれかの入力が必要です</entry>
    <entry key="NoColumnTitles">列のタイトルは行を追加する前に設定しなければなりません。</entry>
    <entry key="RowColumnMismatch">行内の列数がテーブル内の列数と一致しません。テーブル内の列数: {0}</entry>
    <entry key="RefLinksCells">setRefLink の入力はセル配列のセル配列でなければなりません。</entry>
    <entry key="RefLinksMatlabKeyword">セルの長さが 4 の場合、setRefLink の 1 番目の入力引数はキーワード ''matlab'' でなければなりません。</entry>
    <entry key="RefLinksCellLength">setRefLink の入力のセルの長さが正しくありません。</entry>
    <entry key="setCheckTextInputLength">setCheckText の入力は文字ベクトルでなければなりません。</entry>
    <entry key="setCheckTextInput">setCheckText に渡される引数の数が正しくありません。</entry>
    <entry key="ColTitlesListTemplate">列のタイトルは ListTemplate オブジェクトに対して設定できません。</entry>
    <entry key="setColTitlesInputString">setColTitles の入力は文字ベクトルのセル配列でなければなりません。</entry>
    <entry key="setColTitlesInput">setColTitles に渡される引数の数が正しくありません。</entry>
    <entry key="setFormatTypeInput">setFormatType の入力引数の数が正しくありません。</entry>
    <entry key="setInformationInputString">setInformation の入力は文字ベクトルでなければなりません。</entry>
    <entry key="setInformationInput">setInformation に渡される引数の数が正しくありません</entry>
    <entry key="ListObjTableTemplate">リンク オブジェクトは TableTemplate オブジェクトに対して設定できません。</entry>
    <entry key="setListObjInput">setListObj に渡される引数の数が正しくありません</entry>
    <entry key="setRecActionInputString">setRecAction の入力は文字ベクトルか、文字ベクトルのセル配列でなければなりません。</entry>
    <entry key="setRecActionInput">setRecAction に渡される引数の数が正しくありません</entry>
    <entry key="setRefLinkInput">setRefLink に渡される引数の数が正しくありません</entry>
    <entry key="setSubBarInputLength">setSubBar の入力は Boolean でなければなりません。</entry>
    <entry key="setSubBarInput">setSubBar に渡される引数の数が正しくありません</entry>
    <entry key="setSubResultStatusInputLength">setSubResultStatus の入力は文字ベクトルでなければなりません。</entry>
    <entry key="setSubResultStatusInput">setSubResultStatus に渡される引数の数が正しくありません</entry>
    <entry key="setSubResultStatusTextInputLength">setSubResultStatusText の入力は文字ベクトルでなければなりません。</entry>
    <entry key="setSubResultStatusTextInput">setSubResultStatusText に渡される引数の数が正しくありません</entry>
    <entry key="setSubTitleInputLength">setSubTitle の入力は文字ベクトルでなければなりません。</entry>
    <entry key="setSubTitleInput">setSubTitle に渡される引数の数が正しくありません</entry>
    <entry key="TableInfoListTemplate">ListTemplate オブジェクトに対してテーブル データを追加できません。</entry>
    <entry key="setTableInfoInput1">データをテーブルに追加する前にテーブルに対する列のタイトルを設定しなければなりません。</entry>
    <entry key="setTableInfoInput2">setTableInfo の入力のサイズは列数と一致しなければなりません。列数: {0}</entry>
    <entry key="setTableInfoInput3">setTableInfo の入力はセル、またはセル配列でなければなりません。</entry>
    <entry key="setTableInfoInput4">setTableInfo に渡される引数の数が正しくありません</entry>
    <entry key="setTableTitleInputLength">setTableTitle の入力は文字ベクトルでなければなりません。</entry>
    <entry key="setTableTitleInput">setTableTitle に渡される引数の数が正しくありません</entry>
    <entry key="TableTitleListTemplate">ListTemplate オブジェクトに対してテーブルのタイトルを設定できません。</entry>
    <entry key="GetMdlRefVariantInfoWrongBlockType">''Simulink.{0}'' の最初の引数は、Simulink モデル ブロックのハンドルでなければなりません。</entry>
    <entry key="GetOutportInfoWrongBlockType">''Simulink.{0}'' の最初の引数は、Simulink Outport ブロックのハンドルでなければなりません。</entry>
    <entry key="GetMdlRefVariantInfoNonPositiveVariantIndex">''Simulink.{0}'' の 2 番目の引数は、バリアントの正 (1 ベース) のインデックスでなければなりません。</entry>
    <entry key="GetMdlRefVariantInfoTooLargeVariantIndex">ブロック ''{0}'' には {1,number,integer} バリアントしかないため、''Simulink.{2}'' の 2 番目の引数は、1 と {3,number,integer} の間になければなりません。</entry>
    <entry key="FPCAHelp">固定小数点の変換タスクのヘルプ</entry>
    <entry key="FPCARootMsg1">固定小数点アドバイザーは、浮動小数点から固定小数点データ型へのシステム、または、サブシステムの変換を容易にします。</entry>
    <entry key="FPCAContainerMsg1">固定小数点アドバイザーは、浮動小数点モデル、または、サブシステムの固定小数点表現への変換を容易にします。</entry>
    <entry key="FPCAContainerMsg2">次のタスクを実行します。</entry>
    <entry key="FPCAContainerMsg3">固定小数点アドバイザーは、タスクの結果のフィードバックを提供します。タスクが失敗すると、固定小数点アドバイザーは、タスクを完了するためのモデルの変更方法に関する情報を提供します。詳細は、[ヘルプ] をクリックしてください。</entry>
    <entry key="FPCAContainerMsg4">変換するモデルの準備</entry>
    <entry key="FPCAContainerMsg5">モデル全体の設定オプションを実行してください。</entry>
    <entry key="FPCAContainerMsg6">浮動小数点のベースライン データ セットを作成してください。</entry>
    <entry key="FPCAContainerMsg7">データ型とスケーリングの準備 </entry>
    <entry key="FPCAContainerMsg8">ブロックの特定の設定を実行してください。</entry>
    <entry key="FPCAContainerMsg9">設計の最小値と最大値情報をモデルに追加してください。</entry>
    <entry key="FPCAContainerMsg10">固定小数点ツールに戻って、データ型とスケーリングを実行します。</entry>
    <entry key="FPCAContainerMsg15">以下を実行します;</entry>
    <entry key="FPCAContainerMsg16">ユーティリティ 1:現在のデータ型の概要を参照してください。</entry>
    <entry key="FPCAContainerMsg17">ユーティリティ 2:シミュレーションの数値誤差の概要を参照してください。</entry>
    <entry key="FPCAContainerMsg18">ユーティリティ 3:現在のシミュレーション データと参照データ間の差分の概要を参照してください。</entry>
    <entry key="FPCAContainerMsg19">タスクのヘルプを得るには、</entry>
    <entry key="FPCAContainerMsg20">タスクを右クリックします。</entry>
    <entry key="FPCAContainerMsg21">ポップアップ メニューから [これはなに?] を選択してください。</entry>
    <entry key="MAUnsupportedObject">指定したオブジェクトはサポートされません。項目は {0} のオブジェクトでなければなりません。</entry>
    <entry key="MAUnsupportedItem">addItem メソッドで指定した項目はサポートされません。項目は ModelAdvisor.Element オブジェクトまたは文字ベクトルでなければなりません。</entry>
    <entry key="MAContentMustBeString">オブジェクトに対し指定した内容は文字ベクトルではありません。内容には文字ベクトルのみを含めてください。</entry>
    <entry key="MAInvalidaTableConstructor">不正な使用方法。テーブルを初期化するには Table(rowSize, columnSize) を使用してください。</entry>
    <entry key="MAInvalidaImageSourceMustBeString">イメージに対し指定したソースは文字ベクトルではありません。イメージのソースには文字ベクトルのみを含めてください。</entry>
    <entry key="MATableBorderNeedInteger">テーブルの境界サイズに対して指定した値は整数ではありません。非負の整数値を指定してください。</entry>
    <entry key="MAInvalidDataType">無効なデータ型が指定されました。データ型は ModelAdvisor.Element オブジェクトまたは文字ベクトルになります。</entry>
    <entry key="MAParamExceedTableSize">指定した行、または列のサイズはテーブル サイズを超えています。指定したテーブル サイズの範囲内でサイズを指定してください。</entry>
    <entry key="MAParamTableSizeNotMatch">入力のセル配列のサイズがテーブル サイズと一致しません。テーブルと同じサイズのセル配列を指定してください: {0}</entry>
    <entry key="MAInvalidAlignType">指定した配置が無効です。配置は、left, right, center のいずれかになります。</entry>
    <entry key="MAInvalidSLCallbackStyle">コールバック スタイルが無効です。hilite_system または open_system のコールバック スタイルを使用してください。</entry>
    <entry key="MAModelAdvisor">モデル アドバイザー</entry>
    <entry key="MAErrorChangeWorkSystem">前のセッションを終了する前に、モデル アドバイザーの作業システムを誤って変更しようとしています。作業システムを変更するには、Simulink.ModelAdvisor.getModelAdvisor(system, ''new'') を使用してください。</entry>
    <entry key="MAAnalysis">解析</entry>
    <entry key="MADescription">説明</entry>
    <entry key="MAInputParameters">入力パラメーター</entry>
    <entry key="MAResult">結果</entry>
    <entry key="MAExit">終了</entry>
    <entry key="MAFile">ファイル</entry>
    <entry key="MAEdit">編集</entry>
    <entry key="MANotApplicable">適用不可</entry>
    <entry key="MASourceTab">ソース タブ</entry>
    <entry key="MAView">ビュー</entry>
    <entry key="MAHelp">ヘルプ</entry>
    <entry key="MAModelAdvisorHelp">モデル アドバイザーのヘルプ</entry>
    <entry key="MAReport">レポート</entry>
    <entry key="MALastReport">最終レポート</entry>
    <entry key="MAFromNode">ノード</entry>
    <entry key="MASummary">まとめ</entry>
    <entry key="MATaskHierarchy">タスク階層</entry>
    <entry key="MADateTime">日付/時間</entry>
    <entry key="MADisplay">表示</entry>
    <entry key="MAAction">アクション</entry>
    <entry key="MASpreadsheet">スプレッドシート</entry>
    <entry key="MAExploreSelection">選択を探索...</entry>
    <entry key="MAFormat">形式</entry>
    <entry key="MAModelAdvisorTaskManager">モデル アドバイザーのタスク マネージャー</entry>
    <entry key="MAExploreResult">結果の探索</entry>
    <entry key="MARootNodeMsgLine1">フォルダー内のチェックを表示するにはそのフォルダーを開きます。</entry>
    <entry key="MARootNodeMsgLine2">チェックを有効、または無効にするには、チェック名の横のチェック ボックスを選択、またはクリアしてください。</entry>
    <entry key="MARootNodeMsgLine3">フォルダー内のすべてのチェックを有効、または無効にするには、フォルダーを右クリックしてから "すべて選択"、または "すべて選択解除" をクリックしてください。 </entry>
    <entry key="MARootNodeMsgLine4">詳細は、"ヘルプ" をクリックしてください。 </entry>
    <entry key="MARootNodeMsgLine5">すべての可能なアクションのリストに対して、左のペインでオブジェクトを右クリックしてください。</entry>
    <entry key="MARootNodeMsgLine6">チェックを実行するには、左のペインでフォルダーまたはチェックを選択してください。</entry>
    <entry key="MALegend">凡例</entry>
    <entry key="MASource">ソース</entry>
    <entry key="MATitle">タイトル</entry>
    <entry key="MATaskName">タスク名</entry>
    <entry key="MAProcessCallbackFuncName">プロセスのコールバック関数名</entry>
    <entry key="MASelectedCheck">選択したチェック</entry>
    <entry key="MAPSelectedCheck">選択したチェック (常時)</entry>
    <entry key="MADeselectedCheck">選択解除したチェック</entry>
    <entry key="MAPassedCheck">パスしたチェック</entry>
    <entry key="MAFailedCheck">失敗したチェック</entry>
    <entry key="MAInitializing">初期化中...</entry>
    <entry key="MAPleaseWait">お待ちください...</entry>
    <entry key="MARunToSelectedTask">選択したタスクまで実行</entry>
    <entry key="MAResetThisTask">このタスクをリセット</entry>
    <entry key="MACETitleInRpt">モデル アドバイザー構成</entry>
    <entry key="MAProcessing">処理中</entry>
    <entry key="MAProcessCallbacks">コールバック処理中</entry>
    <entry key="MAProcessCallback">コールバック処理中</entry>
    <entry key="MACompilingModel">モデルのコンパイル中...</entry>
    <entry key="MACompilingModelForCodegen">モデルをコード生成向けにコンパイルしています...</entry>
    <entry key="MAWarnReportFromDifferentNode">警告 - 最終レポートは、現在のノードとは異なるモデル アドバイザーのノードから作成されました。</entry>
    <entry key="MAPressRunThisCheck">&lt;b&gt;[このチェックを実行]&lt;/b&gt; をクリックしてください。</entry>
    <entry key="MAPressRunThisTask">&lt;b&gt;[このタスクを実行]&lt;/b&gt;をクリックしてください。</entry>
    <entry key="MARightClickThenPressRunThisCheck">選択するためにタスク階層内でこのチェックを右クリックして、&lt;b&gt;[このチェックを実行]&lt;/b&gt; を押してください。</entry>
    <entry key="MASelectThenPressRunThisCheck">このチェックを実行するには、チェックを選択して、&lt;b&gt;[このチェックを実行]&lt;/b&gt; をクリックしてください。</entry>
    <entry key="MASelectThenPressRunThisTask">このタスクを実行するには、前のタスクのすべてにパスか警告の結果がなければなりません。</entry>
    <entry key="MAShowRptAfterRun">実行後にレポートを表示</entry>
    <entry key="MAAdviceOnContainerNode1">このフォルダー内の有効な項目のすべてを処理し、新規レポートを生成するには、{0} をクリックしてください。</entry>
    <entry key="MAAdviceOnContainerNode2">{0} をクリックすると、有効な手順フォルダーの実行は失敗します。</entry>
    <entry key="MAAdviceOnContainerNode3">このフォルダー内のすべての項目を選択、または、選択解除するには、右クリックします。 </entry>
    <entry key="MAAdviceOnContainerNode4">処理後にレポートを自動的に表示するには、{0} を選択してください。 </entry>
    <entry key="MAAdviceOnContainerNode5">生成した最終レポートを表示するには、"レポート" のパスのリンクをクリックしてください。</entry>
    <entry key="MAAdviceOnContainerNode6">すべての可能なアクションのリストに対して、タスク階層内の項目を右クリックしてください。 </entry>
    <entry key="MAAdviceOnprocedure1">タスクが失敗するまで、タスク フォルダー内のすべてのタスクを自動的に実行するには、フォルダーを選択して、{0} をクリックします。</entry>
    <entry key="MAAdviceOnprocedure1HDLWA">タスクフォルダー内のすべてのタスクを自動的に実行するには、フォルダーを選択して {0} をクリックします。</entry>
    <entry key="MAAdviceOnprocedure2">タスクを手動で実行するには、タスクを選択して、{0} をクリックします。タスクを順番に実行しなければなりません。そのため、{1} は、前のタスクが実行されていない場合、利用できません。 </entry>
    <entry key="MAAdviceOnprocedure3">タスクの処理後にレポートを自動的に表示するには、{0} を選択してください。</entry>
    <entry key="MAAdviceOnprocedure5">詳細は、タスクを右クリックして {0} を選択してください。</entry>
    <entry key="MAStatus">状態</entry>
    <entry key="MANotRunMsg">実行なし</entry>
    <entry key="MAWaivedMsg">失敗 - 放棄してパス</entry>
    <entry key="MAFailedMsg">失敗</entry>
    <entry key="MASeverity">重大度</entry>
    <entry key="MAAdvisory">報告</entry>
    <entry key="MARequired">要求</entry>
    <entry key="MASelected">選択</entry>
    <entry key="MAPermSelected">常に選択</entry>
    <entry key="MADeselected">選択解除</entry>
    <entry key="MAPermDeselected">常に選択解除</entry>
    <entry key="MARunSelectedChecks">選択したチェックを実行</entry>
    <entry key="MASaveReport">名前を付けて保存...</entry>
    <entry key="MARunThisCheck">このチェックを実行</entry>
    <entry key="MARunThisTask">このタスクを実行</entry>
    <entry key="MANoteNotCreateReport">メモ: レポートを作成しません</entry>
    <entry key="MASelectAll2">すべて選択</entry>
    <entry key="MADeselectAll">すべて選択解除</entry>
    <entry key="MASelect">選択</entry>
    <entry key="MADeselect">選択解除</entry>
    <entry key="MANeedWrittableWorkDir">''{0}'' で作業ディレクトリを作成中にエラーが発生しました。書き込み権限のあるディレクトリに移動し、モデル アドバイザーを再実行してください。 </entry>
    <entry key="MAInvalidParamsetActionStyle">setActionStyle メソッドで使用されているアクション コールバック スタイル {0} が無効です。</entry>
    <entry key="MACanOnlyCallWhileExecuteCheckCallback">{0} メソッドは、チェック コールバックを実行中にのみ呼び出すことが可能です。</entry>
    <entry key="MACanOnlyCallWhileExecuteActionCallback">{0} メソッドは、アクション コールバックを実行中にのみ呼び出すことが可能です。</entry>
    <entry key="MAInvalidCallsetActionResultStatus">setActionResultStatus メソッドは、アクション コールバックを実行中にのみ呼び出すことが可能です。</entry>
    <entry key="MARunAdvisor">アドバイザーを実行</entry>
    <entry key="MAByProduct">製品別</entry>
    <entry key="MAByTask">タスク別</entry>
    <entry key="MAReportEmpty">表示する結果がありません。左側のペインでいくつかの項目を選択し、&lt;b&gt;{0}&lt;/b&gt; を押してください。</entry>
    <entry key="NoActionCallBack">チェック {0} に対するモデル アドバイザーのアクション コールバックがありません。 </entry>
    <entry key="MAErrorActionCallback">チェック {0} に対するモデル アドバイザーのアクション コールバック関数を呼び出し中にエラーが発生しました。 </entry>
    <entry key="MAWarnEmptyActionButtonName">ActionCallbackHandle は含まれていますが ActionButtonName が欠けているため、モデル アドバイザーはチェック {0} を無視しました。</entry>
    <entry key="MAWarnCheckboxActionButtonTogether">ActionCallbackStyle が "PerGroup" の場合、モデル アドバイザーはチェック {0} に対する ActionShowCheckBox の設定を無視します。</entry>
    <entry key="MAWarnVVLicense">Simulink V&amp;V のライセンスは利用できません。{0} の内部のモデル アドバイザーのコールバックを無視します。</entry>
    <entry key="MAInvalidCheckID">チェック TitleID が無効です。</entry>
    <entry key="MAErrorInActionCallback">チェック {0} に対するモデル アドバイザーのアクション コールバック関数を呼び出し中にエラーが発生しました。 </entry>
    <entry key="MAMaxIdLengthLargerThan31">&lt;p /&gt;{0} を {1} に設定しました。ISO&amp;#174; や MISRA&amp;#174; のような C の業界標準規格は、最初の 31 文字以内が固有である識別子が必要です。適合を保証するために、識別子の最大長を 31 文字に設定する必要があります。</entry>
    <entry key="MACheckSolverVariableStep">モデルは {0} ({1}) を指定しています。Embedded Coder を使用して、このモデルからコードを生成する場合は、最初にその&lt;b&gt;[ソルバー]&lt;/b&gt; コンフィギュレーション パラメーターの設定を変更して、固定ステップの離散ソルバーを指定しなければなりません。&lt;p&gt;なお、モデルのサブシステムの 1 つからコードを生成するために、ソルバーの設定を変更する必要はありません。その理由は、サブシステムのコンテキスト メニュー から &lt;b&gt;&lt;/b&gt;[C/C++ コード]、[このサブシステムのビルド] または &lt;b&gt;&lt;/b&gt;[C/C++ コード]、[S-Function を生成] を選択すると、Embedded Coder が自動的に設定を固定ステップ ソルバーに変更するためです。&lt;/p&gt;</entry>
    <entry key="MATitletipIdentQuestFixptOper">これらの演算は最適でない結果を導きます</entry>
    <entry key="MATitleIdentQuestFixptOper">問題のある固定小数点演算を特定</entry>
    <entry key="MATitleEnableLongLong">'long long' データ型の使用法をチェック</entry>
    <entry key="MATitleTipEnableLongLong">計算量の多いマルチワード型が検出された場合に、'long long' データ型の使用法をチェック</entry>
    <entry key="MATitleTipIdentBlocksQuestFixptOper">これらのブロックにより、固定小数点コードが最適でなくなる可能性があります</entry>
    <entry key="MATitleIdentBlocksQuestFixptOper">計算量の多い固定小数点および飽和のコードを生成するブロックを特定</entry>
    <entry key="MATitleIdentQuestSubsysSetting_tip">いくつかのサブシステムの設定は、最適でない結果を導きます。</entry>
    <entry key="MATitleIdentQuestSubsysSetting_pass"> 正しくない設定のサブシステムは見つかりませんでした。</entry>
    <entry key="MATitleIdentQuestSubsysSetting_rec_action">Subsystem ブロックでは、[関数のパッケージ化] オプションで [再利用できない関数] を指定してはなりません。</entry>
    <entry key="MATitleIdentQuestSubsysSetting">問題のあるサブシステムの設定を特定</entry>
    <entry key="MATitleCodeGenSanityCheck">コード生成の目的に対するモデル コンフィギュレーションをチェック</entry>
    <entry key="MATitleTipCodeGenSanityCheck">コード生成の目的に対するモデル コンフィギュレーションをチェックします。1 つのオプションの変更が他のオプションに影響するため、このチェックを正常にパスするために複数回反復が必要な場合もあります。</entry>
    <entry key="MATitleDataStoreExecutionOrder">Data Store Read ブロックと Data Store Write ブロックの相対的な実行順序のチェック</entry>
    <entry key="MATitleTipDataStoreExecutionOrder">Data Store Read ブロックと Data Store Write ブロックについて、レガシとタスクベースの並べ替えとの間で、相対的な実行順序の変更をチェックします</entry>
    <entry key="MADataStoreExecutionOrderAction">ブロック優先順序を変更して、元の実行順序に戻す</entry>
    <entry key="MADataStoreExecutionOrderModify">変更</entry>
    <entry key="MADataStoreExecutionOrderPassDesc">実行順序が変更された Data Store ブロックを特定します。</entry>
    <entry key="MADataStoreExecutionOrderPassMsg">Data Store Read ブロックまたは Data Store Write ブロックが存在しないか、すべてのデータ ストア ブロックの実行順序が一貫しています。</entry>
    <entry key="MADataStoreExecutionOrderFailDesc">実行順序が変更された Data Store ブロックを特定します。</entry>
    <entry key="MADataStoreExecutionOrderFailMsg">次のブロックの実行順序が変更されています:</entry>
    <entry key="MADataStoreExecutionOrderFailAction">それらの実行順序を明示的に指定してください。</entry>
    <entry key="MATitleDataStoreRTWExecutionOrder">Data Store Read ブロックと Data Store Write ブロックの相対的な実行順序の変更をチェック</entry>
    <entry key="MATitleTipDataStoreRTWExecutionOrder">生成コードで、Data Store Read ブロックと Data Store Write ブロックの相対的な実行順序がノーマル モード シミュレーションと比較して変更されているかどうかをチェックします。</entry>
    <entry key="MADataStoreRTWExecutionOrderAction">相対的な実行順序が生成コードと同じになるようにノーマル モード シミュレーションのブロックの優先順位を変更するには、以下のボタンをクリックします:</entry>
    <entry key="MADataStoreRTWExecutionOrderModify">ブロックの優先順位の変更</entry>
    <entry key="MADataStoreRTWExecutionOrderPassDesc">実行順序が変更された Data Store ブロックを特定します。</entry>
    <entry key="MADataStoreRTWExecutionOrderPassMsg">Data Store Read ブロックまたは Data Store Write ブロックが存在しないか、すべてのデータ ストア ブロックの実行順序が一貫しています。</entry>
    <entry key="MADataStoreRTWExecutionOrderFailDesc">実行順序が変更された Data Store ブロックを特定します。</entry>
    <entry key="MADataStoreRTWExecutionOrderFailMsg">次のブロックの実行順序が変更されています:</entry>
    <entry key="MADataStoreRTWExecutionOrderFailAction">それらの実行順序を明示的に指定してください。</entry>
    <entry key="MAforCodeGenAdvisorCheckEnableMemcpyFixButton">値の変更</entry>
    <entry key="MAforCodeGenAdvisorCheckEnableMemcpyFixButtonDesc">コンフィギュレーション パラメーター [ベクトルの割り当てに対して memcpy を使用] の値を変更します</entry>
    <entry key="MARawTitleCodeGenSanityCheck">コード生成の目的に対するモデル コンフィギュレーションをチェック</entry>
    <entry key="MATCodeGenSanityCheckPassMsg">パス</entry>
    <entry key="MATCodeGenSanityCheckPassMsg2">以下のパラメーターは、推奨値でチェックして確認されました</entry>
    <entry key="MATCodeGenSanityCheckNoObjective">指定した目的値がありません</entry>
    <entry key="MATCodeGenSanityCheckNoObjectiveLinkMsg">コンフィギュレーション セットから目的を指定...</entry>
    <entry key="MATCodeGenSanityCheckNoObjectiveMsg">コード生成アドバイザーのルート ノードから目的を指定します。</entry>
    <entry key="MATCodeGenSanityCheckResultTableTitle">以下のパラメーター値は、選択した目的に対して最適化されません。&lt;br&gt;&lt;br&gt;警告を自動で修正するには、[パラメーターの変更] ボタンをクリックし、このチェックを再度実行してください。警告を手動で修正するには、このパラメーターのハイパーリンクをクリックしてコンフィギュレーション パラメーター ダイアログ ボックスを開き、手動で修正値を適用してください。</entry>
    <entry key="MATCodeGenSanityCheckResultTableColName1">パラメーター</entry>
    <entry key="MATCodeGenSanityCheckResultTableColName2">現在の値</entry>
    <entry key="MATCodeGenSanityCheckResultTableColName2a">前の値</entry>
    <entry key="MATCodeGenSanityCheckResultTableColName3">推奨値</entry>
    <entry key="MATCodeGenSanityCheckResultTableColName4">値</entry>
    <entry key="MATCodeGenSanityCheckObjectives">目的</entry>
    <entry key="CodeGenObjectiveCheckGroupName">コード生成の目的</entry>
    <entry key="CodeGenObjectiveCheckGroupDescr">コード生成の目的</entry>
    <entry key="MACodeGenSanityCheckFixButtonTitle">パラメーターの変更</entry>
    <entry key="MATitleCodeGenSanityCheckFixButtonDescr">現在値を推奨値に変更してください。いくつかのパラメーターは手動で変更する必要があります。</entry>
    <entry key="MATCodeGenSanityCheckFixNoChange">変更されたパラメーターはありません。</entry>
    <entry key="MATCodeGenSanityCheckFixPartlySingular">1 つのパラメーターが自動的にその推奨値に設定されます (下記の表を参照)。</entry>
    <entry key="MATCodeGenSanityCheckFixPartly">{0,number,integer} 個のパラメーターが自動的に推奨値に設定されます (下記の表を参照)。</entry>
    <entry key="MATCodeGenSanityCheckFixManualSingular">手動での変更が必要なパラメーターが 1 つあります。この変更により影響を与えるパラメーター設定とともに、手動での変更が必要なパラメーターを表示するには、[このチェックを実行] をクリックしてください。\n\n</entry>
    <entry key="MATCodeGenSanityCheckFixManual">手動での変更が必要なパラメーターが {0,number,integer} 個あります。これらの変更により影響を与えるパラメーター設定とともに、手動で変更する必要のあるパラメーターのリストを表示するには、"このチェックを実行" をクリックしてください。\n\n</entry>
    <entry key="MATCodeGenSanityCheckFixAll">すべてのパラメーターが推奨に従って設定されています</entry>
    <entry key="MATitleChecktipDiscreteIntegBlockwInitialCondition">IC にも Constant ブロックにも接続されていない状態端子と初期条件端子を持つ Discrete-Time Integrator ブロックは適切に初期化されません。</entry>
    <entry key="MATitleCheckDiscreteIntegBlockwInitialCondition">不確かな初期条件をもつ Discrete-Time Integrator ブロックをチェック</entry>
    <entry key="MATitletipCheckBusTreatedAsVector">ベクトルとして扱われるバス信号を識別します。</entry>
    <entry key="MATitleCheckBusTreatedAsVector">ベクトルとして扱われるバス信号のチェック</entry>
    <entry key="MATitleCheckVirtualBusUsageUpgrade">ブロックへのバーチャル バス入力のチェック</entry>
    <entry key="MATitletipCheckVirtualBusUsageUpgrade">バーチャル バスをサポートしないブロックに入力されているバーチャル バス信号を、すべて特定します。</entry>
    <entry key="MATitletipCheckForProperMergeBlockUsage">Merge ブロックの同じツリーを直接駆動するブロックは、各タイム ステップにおいて相互排他的な実行を持つ必要があります。この条件を保証できない場合、モデルの動作が意図しないものになります。</entry>
    <entry key="MATitleCheckForProperMergeBlockUsage">Merge ブロックの使用方法をチェック</entry>
    <entry key="MATitletipDataStoreCheck">マルチタスク データの整合性、厳密な型指定、および上位のスコープのデータ ストアの優先順位が低くなっていないかなどの Data Store Memory ブロックに関するモデリングの問題をチェックします。</entry>
    <entry key="MATitleDataStoreCheck">マルチタスク、厳密な型指定、優先順位の低下などの問題について、Data Store Memory ブロックをチェック</entry>
    <entry key="MATitletipCheckForProperDataStoreBlockUsage">Data Store Memory ブロックと関連するモデリングの問題をチェックします (例: 書き込み前の読み取り、読み取り後の書き込み、書き込み後の書き込みなどの問題のシナリオの検出)。</entry>
    <entry key="MATitleCheckForProperDataStoreBlockUsage">データ ストア アクセスに関する順序の問題がないかどうかをチェック </entry>
    <entry key="MADataStoreAnalysisForDetailsSee">Data Store ブロックのアクセス順序の設定方法の詳細は、{0} を参照してください。</entry>
    <entry key="MADataStoreOrderingDataStoreAccess">データ ストア アクセスの順序付け</entry>
    <entry key="MADataStoreRBWTitle">書き込み前の読み取りの問題の可能性を特定しました</entry>
    <entry key="MADataStoreReadBeforeWriteError">モデルは、現在のタイム ステップで、以下のブロックについて、データが書き込まれていない Data Dtore ブロックからデータを読み込もうとしています。</entry>
    <entry key="MADataStoreRBWAction">Data Store Write ブロックの前に必ず Data Store Read ブロックが実行されるように、モデルの再構築を検討してください。</entry>
    <entry key="MADataStoreMETitle">書き込み後の書き込みの問題の可能性を特定しました</entry>
    <entry key="MADataStoreMutualExclusiveness">モデルは、現在のタイム ステップで、以下のブロックについて、データ ストアに 2 回続けてデータを書き込もうとしています。</entry>
    <entry key="MADataStoreMEAction">1 つのタイム ステップで 1 つの Data Store Write ブロックのみが実行されるように、モデルの再構築を検討してください。</entry>
    <entry key="MADataStoreWARTitle"> 読み取り後の書き込みの問題の可能性を特定しました</entry>
    <entry key="MADataStoreWriteAfterReadError">モデルは、現在のタイム ステップで、以下のブロックについて、データ ストアからデータを読み込んだ後にデータ ストアにデータを書き込もうとしています。</entry>
    <entry key="MADataStoreWARAction">Data Store Reader ブロックの後に Data Store Writer ブロックが実行されないように、モデルの再構築を検討してください。</entry>
    <entry key="MATitleMigrateToSimplifiedMode">簡易初期化モードへの移行</entry>
    <entry key="MATitletipMigrateToSimplifiedMode">予期せぬ初期化動作が発生する可能性のあるパラメーター設定を特定し、簡易初期化モードへの移行を実現します。</entry>
    <entry key="MATitleCheckOptimalBusVirtual_tip">生成コードの効率を改善するよう非バーチャル バスになる可能性のあるバーチャル バスをチェックします。</entry>
    <entry key="MATitleCheckOptimalBusVirtual">最適なバーチャル バスをチェック</entry>
    <entry key="MATitleCheckOptimalBusVirtual_warn">次のブロックは、モデルの境界を超えるバーチャル バスを指定しています。</entry>
    <entry key="MATitleCheckOptimalBusVirtual_pass">バーチャル バスが見つかりません。</entry>
    <entry key="MATitleCheckOptimalBusVirtual_rec_action">このモデルから生成されるコードの効率を上げるには、ブロックを変更して非バーチャル バスを指定することを検討してください。</entry>
    <entry key="MATitletipCheckImplicitSignalRes">暗黙的な信号の関連付け、すなわち、Simulink.Signal オブジェクトへのすべての信号と状態の名前を関連付けるよう設定されているモデルをチェックします。これは効率が悪くなり、インクリメンタルなコード生成とモデル参照の速度が遅くなります。</entry>
    <entry key="MATitleCheckImplicitSignalRes">暗黙的な信号の関連付けをチェック</entry>
    <entry key="MATitleCheckDTAndScale">slDataTypeAndScale() の呼び出しをチェック</entry>
    <entry key="MATitletipCheckDTAndScale">slDataTypeAndScale() を使用することで指定されたデータ型パラメーターをもつブロックを検索します。</entry>
    <entry key="MACheckDTAndScaleSub0">必要な置き換えのケース</entry>
    <entry key="MACheckDTAndScaleSub0Info">サポートされなくなった slDataTypeAndScale() への呼び出しを特定し、置き換える必要があります。このような呼び出しは常に自動的に置き換えられます。 </entry>
    <entry key="MADTAndScaleSub0Case">以下の slDataTypeAndScale() への呼び出しはサポートされなくなったため、置き換える必要があります。</entry>
    <entry key="MADTAndScaleSub0NoCase">置き換えが必要な slDataTypeAndScale() の呼び出しがありません。</entry>
    <entry key="MACheckDTAndScaleSub0RecAction">エラーを自動で修正するには、"{0}" ボタンをクリックし、このチェックを再度実行してください。エラーを手動で修正するには、ブロックを特定するブロックのハイパーリンクをクリックしてください。ブロックをダブルクリックするとブロック パラメーター ダイアログ ボックスが開きます。ブロック パラメーター ダイアログ ボックスで、手動で推奨値を適用してください。</entry>
    <entry key="MACheckDTAndScaleSub1">推奨される置き換えのケース</entry>
    <entry key="MACheckDTAndScaleSub1Info">モデル アドバイザーが自動的に置換することができる slDataTypeAndScale() の不必要な呼び出しを特定します。</entry>
    <entry key="MACheckDTAndScaleSub01Link">slRemoveDataTypeAndScale() の自動置き換えのケース</entry>
    <entry key="MADTAndScaleSub1Case">以下の slDataTypeAndScale() の呼び出しは不必要なため、自動的に置き換えられます。</entry>
    <entry key="MADTAndScaleSub1NoCase">自動置き換えが必要な slDataTypeAndScale() の呼び出しがありません。</entry>
    <entry key="MACheckDTAndScaleSub1RecAction">警告を自動で修正するには、"{0}" ボタンをクリックし、このチェックを再度実行してください。警告を手動で解決するには、ブロックを特定するブロックのハイパーリンクをクリックしてください。ブロックをダブルクリックするとブロック パラメーター ダイアログ ボックスが開きます。ブロック パラメーター ダイアログ ボックスで、手動で推奨値を適用してください。</entry>
    <entry key="MACheckDTAndScaleSub2">手動検査のケース</entry>
    <entry key="MACheckDTAndScaleSub2Info">不必要な可能性のある slDataTypeAndScale() の呼び出しを特定します。</entry>
    <entry key="MACheckDTAndScaleSub2Link">slRemoveDataTypeAndScale() の手動検査のケース</entry>
    <entry key="MADTAndScaleSub2Case">不必要かどうかを特定するために slDataTypeAndScale() への以下の呼び出しを確認してください。</entry>
    <entry key="MADTAndScaleSub2NoCase">手動検査の必要な slDataTypeAndScale() の呼び出しがありません。</entry>
    <entry key="MACheckDTAndScaleSub2RecAction">警告を手動で解決するには、ブロックを特定するブロックのハイパーリンクをクリックしてください。ブロックをダブルクリックしてブロック パラメーター ダイアログ ボックスを開き、呼び出しを検査して、不必要な場合はその値を手動で変更してください。</entry>
    <entry key="MADTAndScaleRemove">変更</entry>
    <entry key="MADTAndScaleRemoveDscp">自動置換のケースにリストされる slDataTypeAndScale() の不必要な呼び出しを置き換えます。</entry>
    <entry key="MADTAndScaleRemoveDscp_new">必要または推奨される置き換えのケースにリストされる、slDataTypeAndScale() へのサポートされていない、または不要な呼び出しを置き換えます。</entry>
    <entry key="MADTAndScaleRemoveCase">以下の slDataTypeAndScale() の呼び出しは置き換えられました。</entry>
    <entry key="MADTAndScaleAllBlocks">すべてのケース</entry>
    <entry key="MADTAndScaleBlockName">ブロック</entry>
    <entry key="MADTAndScaleParamName">パラメーター</entry>
    <entry key="MADTAndScaleNewStr">推奨値 </entry>
    <entry key="MADTAndScaleOldStr">古い値</entry>
    <entry key="MADTAndScaleCurStr">現在の値</entry>
    <entry key="MATitletipCheckParamTunableIgnore">モデル パラメーター設定ダイアログ ボックスにパラメーター調整情報が指定されているモデルをチェックします。Simulink は参照モデルに対してこの方法が指定された調整情報を無視します。</entry>
    <entry key="MATitleCheckParamTunableIgnore">参照モデルに対して無視されたパラメーター調整情報をチェック</entry>
    <entry key="MATitletipCheckBlockConstraintTunableParam">調整可能な場合、Lookup と Lookup2D ブロックには、厳密な制約があります。</entry>
    <entry key="MATitleCheckBlockConstraintTunableParam">調整可能なパラメーターに制約があるブロックをチェック</entry>
    <entry key="MATitletipCheckSampleTime">不正なタスク モードは、非効率なコード実行になります。</entry>
    <entry key="MATitleCheckSampleTime">サンプル時間とタスク モードをチェック</entry>
    <entry key="MATitletipIdentQuestCodeInstr">生成コードのインストルメンテーションは、最適でない結果を導きます。</entry>
    <entry key="MATitleIdentQuestCodeInstr">問題のあるコード インストルメンテーション (データ I/O) を特定</entry>
    <entry key="MATitletipIdentQuestSoftSpec">いくつかのソフトウェア環境設定に対するサポートは、最適でない結果を導きます</entry>
    <entry key="MATitleIdentQuestSoftSpec">問題のあるソフトウェア環境仕様を特定</entry>
    <entry key="MATitletipCheckOptimSetting">最適化パラメーターが未選択のため、最適な結果にならない可能性があります。</entry>
    <entry key="MATitleCheckOptimSetting">最適化の設定をチェック</entry>
    <entry key="MATitletipCheckHardImple">ハードウェア属性の矛盾や不十分な指定は、最適でない結果を導きます</entry>
    <entry key="MATitleCheckHardImple">ハードウェア実行をチェック</entry>
    <entry key="MATitletipCheckModelrefMismatch">Model ブロックの設定が最上位モデルと一致しないモデル ブロックを特定</entry>
    <entry key="MATitleCheckModelrefMismatch">モデル リファレンスの設定の不一致をチェック</entry>
    <entry key="MATitletipCheckModelRefSIMConfigCompliance">アクセラレータ シミュレーションがサポートしないモデル参照の診断設定を特定します。</entry>
    <entry key="MATitletipCheckModelRefRTWConfigCompliance">コード生成がサポートしないモデル参照の識別子の書式設定を特定します。</entry>
    <entry key="MAModelRefSIMConfigCheckInfo">現在の診断設定は、アクセラレータ モードの参照モデルではサポートされていません。このモデル参照の階層の最上位モデルは ''{0}'' です。</entry>
    <entry key="MAModelRefRTWConfigCheckInfo">最上位モデルが ''{0}'' のモデル参照階層のコード生成では、現在の識別子の書式設定はサポートされていません。</entry>
    <entry key="MAModelRefConfigCheckDSMHeader">アクセラレータ モードでの参照モデルにおいて、以下のローカルな Data Store Memory ブロックでは、[書き込み前の読み取りを検出]、[読み取り後の書き込み] および [書き込み後の書き込み] の各診断設定はサポートされていません。</entry>
    <entry key="MAModelRefConfigCheckPassText">コンフィギュレーション パラメーター設定は検査にパスしました。</entry>
    <entry key="MAModelRefConfigCheckTableCol1">パラメーター</entry>
    <entry key="MAModelRefConfigCheckTableCol2">現在の値</entry>
    <entry key="MAModelRefConfigCheckRecActionSIM">これらの診断を活用するには、モデルが確実に&lt;a href="matlab:helpview([docroot,''/toolbox/simulink/ug/simulink_ug.map''], ''mamodelref_sim_modes'');"&gt;ノーマル モードで参照される&lt;/a&gt;ようにしてください。詳細については、&lt;a href="matlab:helpview([docroot,''/toolbox/simulink/ug/simulink_ug.map''],''model_ref_limitations_ma_checksimulation'');"&gt;ドキュメンテーション&lt;/a&gt;を参照してください。</entry>
    <entry key="MAModelRefConfigCheckRecActionRTW">コード生成で $R トークンが追加されました。これはモデル名を表します。詳細については、&lt;a href="matlab:helpview([docroot,''/toolbox/rtw/helptargets.map''],''model_ref_limitations_ma_checkcodegen'');"&gt;ドキュメンテーション&lt;/a&gt;を参照してください。</entry>
    <entry key="MAModelRefConfigCheckModelHeader">参照モデル: </entry>
    <entry key="MATitleCheckModelRefSIMConfigCompliance">高速化されたモデル参照シミュレーション中に無視された診断設定をチェック</entry>
    <entry key="MATitleCheckModelRefRTWConfigCompliance">モデル参照に使用されているコード生成識別子の書式をチェック</entry>
    <entry key="MATitletipIdentQuestBlocks">コード生成でサポートされない、または、展開を推奨しないブロックを特定</entry>
    <entry key="MATitleIdentQuestBlocks">指定したシステム内の問題のあるブロックを特定</entry>
    <entry key="MATitletipCheckSolver">不適切な設定はコード生成を妨げます。指定が不十分なサンプル時間は、予期しない結果になる可能性があります。</entry>
    <entry key="MATitleCheckSolver">コード生成に対するソルバーをチェック</entry>
    <entry key="MATitletipIdentExpensiveBlocks">これらの設定は最適でない結果を導きます</entry>
    <entry key="MATitleIdentExpensiveBlocks">計算量の多い丸めコードを生成するブロックを特定</entry>
    <entry key="MATitletipIdentLUTRangeCheckCode">Lookup Table ブロック、Prelookup ブロック、Interpolation ブロックなどの Lookup Table ブロックでは、入力値が常に有効なブレークポイントの範囲内に該当する場合、これらの設定によりコード生成が非効率になる可能性があります。</entry>
    <entry key="MATitleIdentLUTRangeCheckCode">計算量が多い範囲外のチェック コードを生成する Lookup Table ブロックを特定</entry>
    <entry key="MALookupTableRemoveRangeCheckingCodeInfo">次の Lookup Table ブロックは、範囲外のチェック コードを生成します。入力値が常に有効なブレークポイントの範囲内に該当する場合、ブロックごとに組み込みコード生成における範囲チェック コードを削除することができます。</entry>
    <entry key="MALUTRemoveRangeCheckCodeDscp">入力値が常に有効なブレークポイントの範囲内に該当する場合は、より効率的なコード生成のために範囲チェック コードを削除することができます。</entry>
    <entry key="MALUTRemoveRangeCheckCodePass">Lookup Table ブロックは、範囲チェックのないコードを生成するように設定されています。</entry>
    <entry key="MALookupTableBlockName">ブロック</entry>
    <entry key="MALookupTableParamName">パラメーター</entry>
    <entry key="MALookupTableNewSetting">推奨設定</entry>
    <entry key="MALookupTableRangeRemoveAction">リストされているすべてのブロックに対する警告を自動で修正するには、"{0}" ボタンをクリックし、このチェックを再度実行してください。警告を手動で解決するには、ブロックを特定するブロックのハイパーリンクをクリックしてください。ブロックをダブルクリックするとブロック パラメーター ダイアログ ボックスが開きます。ブロック パラメーター ダイアログ ボックスで、手動で推奨設定を適用してください。さらに、ブロック パラメーター ダイアログ ボックスで 'DiagnosticForOutOfRangeInput' を [警告] または [エラー] に設定してシミュレーション時に範囲外の入力値を検出することを推奨します。</entry>
    <entry key="MALookupTableRangeRemoveActionResult">リストされているすべてのブロックは範囲チェック コードを生成しないように設定されています。また、現在の設定が [なし] である場合、これらのブロックの 'DiagnosticForOutOfRangeInput' は [警告] に設定されます。このため、シミュレーション時に範囲外の入力値を検出できます。</entry>
    <entry key="MALookupTableRangeRemove">変更</entry>
    <entry key="MATitletipCheckRootInport">属性が完全に定義されていないルート モデルの Inport ブロックは、予期しない結果になる可能性があります</entry>
    <entry key="MATitleCheckRootInport">ルート モデルの Inport ブロックの仕様をチェック</entry>
    <entry key="MATitletipIdentUnconnectLine">未接続のオブジェクトは、モデル内に問題があることを示します</entry>
    <entry key="MATitleIdentUnconnectLine">接続されていないライン、入力端子、出力端子を特定</entry>
    <entry key="MATitlePartialBusParameters">バス信号を使った部分構造体パラメーターの使用をチェック</entry>
    <entry key="MATitleTipPartialBusParameters">関連するバス信号と形状が一致していない構造体パラメーターを参照するブロックを特定します。</entry>
    <entry key="MATitleCheckModelReferenceIOMsg">無効なルートの Inport/Outport ブロックの接続をチェック</entry>
    <entry key="MATitletipCheckModelReferenceIOMsg">このモデルが別のモデルによって参照される場合に、ルートの Inport と Outport ブロックの無効な接続を検出します</entry>
    <entry key="MACheckModelReferenceIOMsgStatus">次の場所で無効な接続が見つかりました。</entry>
    <entry key="MACheckModelReferenceIOMsgRecAction">この警告を回避するには、''{0}'' の前に Signal Conversion ブロックを挿入してください。</entry>
    <entry key="MAPassResultStatusPartialBusParameters">部分構造体パラメーターをバス信号と併用するブロックが見つかりません。</entry>
    <entry key="MARecActionPartialBusParameters">Simulink.Bus.createMATLABStruct を使用して、リストされたブロックに対して、部分構造体パラメーター値を完全な構造体パラメーター値に変換することを検討してください。</entry>
    <entry key="MAUnableOpenModel">モデルを開くことができません。モデルを開いてモデル アドバイザー ツールを再起動してください。</entry>
    <entry key="MAErrorOccurredCompile">モデルをコンパイル中にエラーが発生しました。</entry>
    <entry key="MARequiresCompile">このチェックを実行するとモデルが更新され、処理時間が増加します</entry>
    <entry key="MARequiresCompileShort">このチェックを実行するとモデルが更新されます。</entry>
    <entry key="MASelectItemFromList">次のリストから製品のカテゴリ、または項目を選択:</entry>
    <entry key="MASelectTaskFromList">次のリストからタスクを選択:</entry>
    <entry key="MASelectAll">すべてを選択または選択解除</entry>
    <entry key="MARegenerateReport">警告:リンクは期限が切れています。最新情報のレポートを再度生成してください。</entry>
    <entry key="MANotWorkOnLibrary">モデル アドバイザーは Simulink ライブラリをサポートしません。</entry>
    <entry key="MARequiresJava">このツールを実行するには Java が必要です。</entry>
    <entry key="FunctionRequiresJava">関数 ''{0}'' は Java がサポートされていることが必要です</entry>
    <entry key="MARemoveExistReport">モデル アドバイザーは既存のレポートを削除しています。</entry>
    <entry key="MAUnableCreateFilesInDirectory">現在の作業ディレクトリの下のモデル アドバイザーに対するファイルを作成できません: ''{0}''。書き込みできるよう現在のディレクトリを変更してください。</entry>
    <entry key="MAPassedMsg">パス</entry>
    <entry key="MAAnalysisThrewError">モデルの解析中に問題が発生しました。修正することで解析を完了できる可能性があります: {0}</entry>
    <entry key="MAMustBeBlockDiagram">解析の更新は、モデル レベルのみをサポートします。この解析を実行するには、サブシステム レベルの代わりにモデルの最上位レベルからモデル アドバイザーを開いて、全体の解析を開始してください。</entry>
    <entry key="MAUpdateDiagnosticSummary">モデル アドバイザーは、このバージョンの Simulink で使用した場合の問題についてモデル内のブロック、設定、参照をチェックしました。以下に記述されたすべての問題を解決する最初のステップとして、報告されている問題をもつモデルとライブラリ上で Simulink アップグレード アドバイザーを実行する必要があります。ここで識別されたもの以上の問題がある可能性があります。詳細は、{0} を参照してください。</entry>
    <entry key="MAUnableFindTaskSpecified">モデル アドバイザーのノード {0} ({1} で指定) が見つかりません。スペルが正しくないか、必要なライセンスが見つからないことが原因である可能性があります。</entry>
    <entry key="MAIncompleteTreeStructure">モデル アドバイザーのツリー構造が正しくありません。フォルダー {0} の構造体が正しく指定されていません。</entry>
    <entry key="MAMdlFilesMsgDiagnostic">参照モデルの更新状況:</entry>
    <entry key="MAMdlFilesMsgNone">(このファイルから参照されるモデルは更新の必要がありません)</entry>
    <entry key="MALibFilesMsgDiagnostic">ライブラリの更新状況 (参照ブロックのみチェックされます):</entry>
    <entry key="MALibFilesMsgNone">(このブロック線図でリンクされている MathWorks のものではないライブラリはありません)</entry>
    <entry key="MAFileMsgNeedsUpdate">(更新を推奨)</entry>
    <entry key="MAFileMayNeedUpdate">(更新の可能性あり)</entry>
    <entry key="MAFileMsgCheck">(チェックを推奨)</entry>
    <entry key="MABlocksMsgDiagnostic">更新が推奨されるブロックを更新理由でグループ化:</entry>
    <entry key="MAReasonStr">&lt;b&gt;更新理由&lt;/b&gt; &amp;#8212; {0}:</entry>
    <entry key="modelBadStateForCheck">アップグレード アドバイザーは、現在のコンパイル状態のモデル {0} に対し要求されたチェックを実行できません</entry>
    <entry key="MACompileCheckUpdatesTitle">コンパイル時の情報を要求し、既知のアップグレード問題に対するモデル、ローカルなライブラリ、参照モデルをチェック</entry>
    <entry key="MACompileCheckUpdatesTitleTips">コンパイル時の情報を必要とする共通のアップグレード問題をチェックします</entry>
    <entry key="MAMdlRefTaskTitle">モデル参照</entry>
    <entry key="MAMdlRefTaskTitleTips">モデル リファレンスに関するチェックを実行</entry>
    <entry key="MADataTransferTaskTitle">データ転送の効率性</entry>
    <entry key="MADataTransferTaskTitleTips">データ転送の効率性に関するチェックを実行します</entry>
    <entry key="MAUpgradeTaskTitle">Simulink の現バージョンへのアップグレード</entry>
    <entry key="MAUpgradeTaskTitleTips">推奨バージョンのアップグレードのチェックを実行</entry>
    <entry key="MATitleCheckSfunctions">S-function に対する実行時の診断</entry>
    <entry key="MATitletipCheckSfunctions">S-Function が存在する場合に配列範囲とソルバーの整合性をチェック</entry>
    <entry key="MAMsgCheckSfunctions">このモデルは、次の C-MEX S-function を含んでいます。</entry>
    <entry key="MASetSolverDataInconsistencyToWarning">&lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'',''{0}'',''ConsistencyChecking'');"&gt;[ソルバー データの不整合]&lt;/a&gt; &lt;a href="matlab:helpview(strcat(docroot, ''/toolbox/simulink/helptargets.map''), ''cpd_diags_solverdatainconsistency'',''CSHelpWindow'');"&gt;[?]&lt;/a&gt; を、&lt;code&gt;[エラー]&lt;/code&gt; または &lt;code&gt;[警告]&lt;/code&gt; (現在は &lt;code&gt;[なし]&lt;/code&gt; に設定) に設定し、Simulink がその組み込みブロックに適用する ODE ソルバーの整合性ルールに S-Function が従っているかどうかを検証することを検討してください。</entry>
    <entry key="MASetArrayBoundsCheckingToWarning">&lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'',''{0}'',''ArrayBoundsChecking'');"&gt;[配列範囲の超過]&lt;/a&gt; &lt;a href="matlab:helpview(strcat(docroot, ''/toolbox/simulink/helptargets.map''), ''cpd_diags_arrayboundsexceeded'',''CSHelpWindow'');"&gt;[?]&lt;/a&gt; を &lt;code&gt;[エラー]&lt;/code&gt; または &lt;code&gt;[警告]&lt;/code&gt; (現在は &lt;code&gt;[なし]&lt;/code&gt; に設定) に設定し、S-Function が配列範囲外に書き込んでいるかどうかをチェックすることを検討してください。</entry>
    <entry key="MAMsgMultiTaskDataStore">&lt;b&gt;[マルチタスク データ ストア]&lt;/b&gt; のチェックが [エラー] に設定されていません。リアルタイムのマルチタスク環境で運用される場合、異なるタスクでの書き込みや読み取りを行うデータ ストアの値の整合性はリスクがあります。&lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'',''{0}'',''MultiTaskDSMMsg'')"&gt;[マルチタスク データ ストア]&lt;/a&gt; 設定を [エラー] に変更することを検討してください。</entry>
    <entry key="MAMsgDuplicateDataStore">&lt;b&gt;[データ ストア名の重複]&lt;/b&gt; のチェックが [エラー] に設定されていません。データ ストア名を重複して使用すると、意図せず上位のモデル スコープのデータ ストアの優先順位を低くすることになります。&lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'',''{0}'',''UniqueDataStoreMsg'')"&gt;[データ ストア名の重複]&lt;/a&gt; 設定を [エラー] に変更することを検討してください。</entry>
    <entry key="MAMsgDataStoreReadWrite">データ ストアの読み取りや書き込みを行う順番に関するさまざまな実行時の診断があります。</entry>
    <entry key="MATitleDataStoreRWOrder">Data Store ブロックについて読み取り/書き込みの診断が有効であるかどうかをチェック</entry>
    <entry key="MATitletipDataStoreRWOrder">Data Store ブロックがある場合、読み取り/書き込みの順の診断チェックがオンになっていることを確認します。</entry>
    <entry key="MAMsgGlobalDataStoreRWOrder">&lt;b&gt;[{0} の検出]&lt;/b&gt; のチェックはグローバルに無効です。&lt;b&gt;[コンフィギュレーション パラメーター]&lt;/b&gt; ダイアログ ボックスの &lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'',''{1}'',''{2}'')"&gt;[データ有効性]&lt;/a&gt; ページでこの設定を有効にすることを検討してください。</entry>
    <entry key="MAMsgLocalDataStoreRWOrder">&lt;b&gt;[{0} の検出]&lt;/b&gt; は、次の Data Store Memory ブロックに対して有効ではありません。&lt;b&gt;[コンフィギュレーション パラメーター]&lt;/b&gt; ダイアログ ボックスの &lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'',''{1}'',''{2}'')"&gt;[データ有効性]&lt;/a&gt; ページで、この設定をグローバルに有効にするか、次のすべてのブロックで有効にすることを検討してください。</entry>
    <entry key="MATitleNonDiscSigDataStore">モデリング エラーに対して Data Store ブロック サンプル時間をチェック</entry>
    <entry key="MATitletipNonDiscSigDataStore">Data Store ブロックで、[連続サンプル時間] または [マイナー ステップで固定] が指定されていないことをチェックします。</entry>
    <entry key="MAMsgNonDiscSigDataStore">&lt;p /&gt; 次の Data Store Memory、Data Store Read、Data Store Write ブロックには、連続サンプル時間またはマイナー ステップで固定のサンプル時間があります。</entry>
    <entry key="MAMsgNonDiscSigDataStoreSuggest">&lt;p /&gt; これらのブロックに連続のサンプル時間を指定する必要がない場合、これらのブロックを離散にするか、Memory ブロック、または Goto および From ブロックでそれらを置き換えることを検討してください。</entry>
    <entry key="MANonContDSMPass"> すべての Data Store ブロックは離散のサンプル時間を持っています。&lt;font color="#008000"&gt;パス&lt;/font&gt;</entry>
    <entry key="MAMultiTaskCheck">&lt;p /&gt; &lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'',''{0}'',''MultiTaskDSMMsg'');"&gt;マルチタスクの Data Store ブロックを検出する&lt;/a&gt; &lt;a href="matlab:helpview(strcat(docroot, ''/toolbox/simulink/helptargets.map''), ''cpd_diags_multitaskdatastore'', ''CSHelpWindow'');"&gt;[?]&lt;/a&gt; コンパイル時間の診断は、現在無効です。多くの場合、マルチタスクの Data Store ブロックは、Data Store ブロックを使用してモデリングの問題を示しています。マルチタスクの Data Sore ブロックのチェックを有効にするには、&lt;b&gt;[コンフィギュレーション パラメーター]&lt;/b&gt; ダイアログ ボックスの &lt;b&gt;[データ有効性]&lt;/b&gt; ページを使用することを検討してください。</entry>
    <entry key="MATitleNonContSigDerivPort">微分端子を駆動する不連続信号をチェック</entry>
    <entry key="MATitletipNonContSigDerivPort">微分端子を駆動する不連続信号を、多数のソルバーのリセットを引き起こすモデリング問題としてマーク</entry>
    <entry key="MAMsgNonContSigDerivPort">&lt;p /&gt; 正確なシミュレーション結果を確保するため、ソルバーは、微分端子を駆動する非連続信号の値の変化に対応してリセットされます。微分端子を駆動する非連続信号のうち、1 つ以上のインスタンスを取り除くと、シミュレーションのパフォーマンスが向上することがあります。 </entry>
    <entry key="MAMsgContSrcLocationHeader"> &lt;tr&gt;&lt;td&gt;&lt;b&gt;Block&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;Port&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;開始インデックス &lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;幅&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;</entry>
    <entry key="MAMsgNonContSigDerivPortSuggest"> &lt;p /&gt; 微分端子を駆動する各非連続信号について、以下の変更を検討してください。&lt;ul&gt;&lt;li&gt;信号を連続にする。&lt;/li&gt; &lt;li&gt;信号を受信する連続ブロックを、離散バージョンのブロックに置き換える。&lt;/li&gt;&lt;/ul&gt;</entry>
    <entry key="MASimPnATaskTitle">シミュレーションの精度</entry>
    <entry key="MASimPnATaskTitleTip">シミュレーションの精度改善のチェック</entry>
    <entry key="MASimRuntimeAccuracyTaskTitle">シミュレーション実行時の精度の診断</entry>
    <entry key="MASimRuntimeAccuracyTaskTitleTip">精度の診断は問題を見つけるのに役立ちますが Simulink は遅くなります。</entry>
    <entry key="MADataStoreBlocksTaskTitle">Data Store Memory ブロックの管理</entry>
    <entry key="MADataStoreBlocksTaskTitleTip">問題を検出するため、Data Store ブロックの使用法の改善をチェックします。</entry>
    <entry key="MADiagHasPerformanceHit">&lt;p /&gt; &lt;b&gt;メモ&lt;/b&gt;:これらの実行時の診断は、大幅にシミュレーション速度を遅くする可能性があります。シミュレーション中に警告やエラーにならないことを検証した後で &lt;code&gt;{0}&lt;/code&gt; の設定に戻す必要があります。 </entry>
    <entry key="CheckPassed">&lt;b&gt;[{0} の検出]&lt;/b&gt; は&lt;font color="#008000"&gt;パス&lt;/font&gt;</entry>
    <entry key="CheckEnabled">&lt;b&gt;[{0} の検出]&lt;/b&gt; は&lt;font color="#008000"&gt;有効&lt;/font&gt;</entry>
    <entry key="MAMsgCouldNotCompileModel">&lt;p /&gt; モデル &lt;b&gt;{0}&lt;/b&gt; をコンパイルできません。</entry>
    <entry key="ContinuousBlocks">連続ブロック</entry>
    <entry key="ZOHBlocks">Zero Order Hold ブロック</entry>
    <entry key="MAErrorStackDump">{0} の {1,number,integer} 行</entry>
    <entry key="CommonMAMuxUsedCheckMsg">不適切に使用された Mux ブロックを置き換えた後、モデルがバス信号をベクトルとして含まないようにチェックする必要があります。 </entry>
    <entry key="CommonMAMuxUsedFixMsg">これを行うには、[コンフィギュレーション パラメーター] ペインで [Mux ブロックをバス信号の作成に使用] の診断をエラーに設定し、このチェックを再度実行してください。</entry>
    <entry key="CommonMAMuxUsedConfigLink">バス - Mux ブロックをバス信号の作成に使用</entry>
    <entry key="CommonMAMuxUsedConfigLink1">バス - ベクトルとして扱われるバス信号</entry>
    <entry key="CommonMAUnableToRunCheckForProperBusOnSubsystem">''バスの使用方法'' のチェックは、最上位のモデルからのみ機能します。このチェックを実行するには、最上位のモデルからアドバイザーを実行してください。</entry>
    <entry key="CommonMAResultCheckBusSignalsFromMux">Simulink でベクトルとして扱うモデル内のバス信号を特定できるようにするために、診断 ''Mux ブロックをバス信号の作成に使用'' をエラーに設定することを推奨します。</entry>
    <entry key="CommonMAResultCheckBusSignalsFromMuxLink">バス: Mux ブロックをバス信号の作成に使用</entry>
    <entry key="CommonMAMuxUsedasBusErrorMsg2">Bus Creator ブロックは次のライブラリにあります。</entry>
    <entry key="CommonMAMuxUsedasBusErrorMsg3">以下のリストは、出力がバス信号として扱われる機能を持つブロックが Mux ブロックの入力に接続されているか、バス信号を入力とする機能を持つブロックが Mux ブロックの出力に接続されています。</entry>
    <entry key="CommonMAMuxUsedasBusErrorMsg4">以下の Mux ブロックは、異なる次元の信号を含むバス信号を出力します。</entry>
    <entry key="CommonMAMuxUsedasBusErrorMsg5">以下の Mux ブロックは、異なるデータ型の信号を含むバス信号を出力します。</entry>
    <entry key="CommonMAMuxUsedasBusErrorMsg6">以下の Mux ブロックは、異なる信号タイプ (実数/複素数) の信号を含むバス信号を出力します。</entry>
    <entry key="CommonMAMuxUsedasBusErrorMsg7">以下の Mux ブロックは、異なるサンプリング モード (サンプル ベース/フレームベース) を持つ信号を含むバス信号を出力します。</entry>
    <entry key="CommonMAMuxUsedasBusErrorMsg8">以下の Mux ブロックは、異なるストレージ クラスを持つ信号を含むバス信号を出力します。</entry>
    <entry key="CommonMAMuxUsedasBusErrorMsg9">モデルはバスを適切に使用しています。しかし、モデルは将来不適切なバスの使用になる可能性のある変更を検出するよう設定されていないため、このチェックは必ずしも完全ではありません。このような変更を検出するには、コンフィギュレーション パラメーターで ''ベクトルとして扱われるバス信号'' の診断をエラーに設定し、チェックを再度実行してください。 </entry>
    <entry key="CommonMABusToVectorErrorMsg1">モデルは、Simulink が暗黙的にベクトルに変換するバス信号を含んでいます。Simulink で将来の機能を利用するために、モデル内でこれらの信号をベクトルに明示的に変換する必要があります。これを行うには、接続するバス信号とブロックの入力端子間に ''Bus to Vector'' 変換ブロックを挿入するか、次のコマンドを使用してください。 </entry>
    <entry key="CommonMABusToVectorErrorMsg2">''Bus to Vector'' 変換ブロックは次のライブラリにあります。  </entry>
    <entry key="CommonMABusToVectorErrorMsg3">検出されたバス信号をベクトルに変換した後、将来不適切なバスの使用になる可能性のある変更を検出するには、コンフィギュレーション パラメーターを開いて、''ベクトルとして扱われるバス信号'' の診断をエラーに設定し、チェックを再度実行しててください。 </entry>
    <entry key="CommonMABusToVectorErrorMsg4">以下のバス信号はベクトルとして扱われます。</entry>
    <entry key="CommonMABusToVectorMsg"> 入力端子に接続されているバス信号   </entry>
    <entry key="MAErrorSimulationNotStopped">Simulink はモデル ''{0}'' をシミュレーション中です。シミュレーションを中止して再度実行してください。</entry>
    <entry key="MAErrorModelFileNotWritable">モデル {0} は書き込み可能ではありません。ファイルのアクセス許可を変更して書き込み可能にしてください。</entry>
    <entry key="MAConfirmYes">はい</entry>
    <entry key="MAConfirmNo">いいえ</entry>
    <entry key="rapidAccelSimStart">次のモデルに対するラピッド アクセラレータを開始: {0}</entry>
    <entry key="rapidAccelCheckingIfUpToDate">構造的なチェックサムを計算中</entry>
    <entry key="rapidAccelBuildStart">モデルに対するラピッド アクセラレータ ターゲットをビルド中: {0}</entry>
    <entry key="rapidAccelTargetIsUpToDate">ラピッド アクセラレータ ターゲットは最新です</entry>
    <entry key="rapidAccelTargetIsOutOfDate">ラピッド アクセラレータ ターゲットは期限が切れています</entry>
    <entry key="rapidAccelBuildFinish">### モデルに対するアクセラレータ ターゲットをビルドしました: {0}</entry>
    <entry key="rapidAccelBuildFailed">ラピッド アクセラレータ モードのモデル ''{0}'' をシミュレーションするためのスタンドアロンの実行ファイルをビルドできません。</entry>
    <entry key="rapidAccelBuildFailedCSFunctionSourceNotFound">ラピッド アクセラレータ モードのモデル ''{0}'' をシミュレーションするためのスタンドアロンの実行ファイルをビルドできません: C S-Function ソース ファイル ''{1}'' が見つかりませんでした。ラピッド アクセラレータ シミュレーションでは、特定の S-Function (例: レベル 1 の S-Function) のソース ファイルが、その S-Function の MEX ファイルと同じフォルダー内にあることが必要です。追加の S-Function ソース ファイルは、S-Function ブロックの [S-Function モジュール] フィールドから、また rtwmakecfg.m ファイルの使用を通じて指定できます。詳細については、S-Function のドキュメンテーションを参照してください。</entry>
    <entry key="rapidAccelBuildFailedMaybeCPP">	ビルドに失敗した原因は、''{0}'' でカスタム C++ コードを使用したことである可能性があります。現在、ラピッド アクセラレータは C コード生成のみをサポートしています。</entry>
    <entry key="rapidAccelDoesNotSupportImages">モデル ''{0}'' はイメージ データ型を使用するため、このモデルをラピッド アクセラレータ モードでシミュレートすることはできません。</entry>
    <entry key="rapidAccelExeError">モデル ''{0}'' のシミュレーション中にラピッド アクセラレータ プロセスがクラッシュしました。 \n{1}</entry>
    <entry key="rapidAccelAssertion"> 時間 {1} で ''{0}'' においてアサーションが検知されました</entry>
    <entry key="rapidAccelGccVersion"> gcc version ''{0}'' を使用しています。このバージョンの gcc は、ラピッド アクセラレータでサポートされていません。現在、ラピッド アクセラレータでサポートされているバージョンは、''{1}'' 以降です。</entry>
    <entry key="rapidAccelUnableToLoadExtInputsWrongNumber"> モデル ''{0}'' の外部入力の評価中にエラーが発生しました: ''{0}'' にはルートの Inport ブロックが {2} 個ありますが、''{0}'' の [コンフィギュレーション パラメーター] ダイアログの [データのインポート/エクスポート] ページで {1} 個の外部入力が指定されています。[データのインポート/エクスポート] ページで指定する外部入力の数は 1 であるか、モデルのルートの Inport ブロックの数と等しくなければなりません。 </entry>
    <entry key="rapidAccelUnableToLoadExtInputsBadFormat"> モデル ''{0}'' の外部入力の評価中にエラーが発生しました: ラピッド アクセラレータ モードでは、外部入力は double の配列であるか、リーフが MATLAB timeseries の構造体でなければなりません。 </entry>
    <entry key="rapidAccelDatasetExtInputInvalidNumberOfExtInputs">モデル ''{0}'' の最初の外部入力データ型は、Simulink.SimulationData.Dataset です。ラピッド アクセラレータは、外部入力が 1 つだけ指定されている場合にのみ、この型の外部入力をサポートします。</entry>
    <entry key="rapidAccelDatasetExtInputNonScalarDataset">モデル ''{0}'' の外部入力データ型は、Simulink.SimulationData.Dataset です。入力の次元がスカラーではありません。ラピッド アクセラレータは、Simulink.SimulationData.Dataset オブジェクトがスカラーである場合のみ、この型の外部入力をサポートします。</entry>
    <entry key="rapidAccelDatasetExtInputInvalidNumberOfElements">モデル ''{0}'' の外部入力データ型は、Simulink.SimulationData.Dataset です。ラピッド アクセラレータは、Simulink.SimulationData.Dataset インスタンスにモデルのルート Inport ブロックと同数の要素がある場合にのみ、この型の外部入力をサポートします。ルート Inport ブロックには、Enable ブロック、および [トリガー タイプ] が [立ち上がり]、[立ち下がり]、または [両方] に設定された Trigger ブロックが含まれます。</entry>
    <entry key="rapidAccelDatasetExtInputInvalidNumberOfSamples">モデル ''{0}'' の外部入力データ型は、Simulink.SimulationData.Dataset です。ラピッド アクセラレータでは、データセット内の各 timeseries に非ゼロの数のデータ点が含まれている場合にのみ、この型の外部入力をサポートします。</entry>
    <entry key="rapidAccelMCOSObjExtInputsNotSupported">モデル ''{0}'' に対する外部入力データには、MATLAB オブジェクトのタイプ ''{1}'' の信号値があります。ラピッド アクセラレータはそのようなデータ型の外部入力をサポートしません。</entry>
    <entry key="rapidAccelInportBoundsNotHonoured"> モデル ''{0}'' の 1 つ以上のルート Inport には、空でない OutMin パラメーターまたは OutMax パラメーターがあります。ただし、ルート Inport のデータの範囲がラピッド アクセラレータに適用されないため、シミュレーション中に警告やエラーが発生せずにデータの範囲を超える可能性があります。  </entry>
    <entry key="rapidAccelCppNotSupported">ラピッド アクセラレータは、C コードのみサポートします。コンフィギュレーション セットで設定されていると C++ 内のモデル ''{0}'' はビルドできません。これにより、ビルドが失敗する可能性があります。</entry>
    <entry key="rapidAccelSimOptNotSupported">シミュレーション オプション ''{0}'' は、ラピッド アクセラレータ モードでサポートされていません</entry>
    <entry key="rapidAccelSimOptInvVal">sim コマンド オプション ''{0}'' はラピッド アクセラレータに対して、文字ベクトル型または数値型のいずれかでなければなりません。</entry>
    <entry key="rapidAccelInvCmdlSimParam">sim コマンドのパラメーター ''{0}'' とその値は、有効なパラメーターと値の組ではありません。パラメーターの設定は、以下のエラーを発生します: {1} : {2} </entry>
    <entry key="rapidAccelSimOptNotSupportedWithoutUpdate">シミュレーション オプション ''{0}'' は、最新のチェックがオフのラピッド アクセラレータ モードでサポートされません。</entry>
    <entry key="rapidAccelInlineParametersOff">モデル ''{0}'' ではパラメーターが既定で調整可能です。''[コンフィギュレーション パラメーター] &gt; [コード生成] &gt; [最適化] &gt; [既定のパラメーター動作]'' を [インライン] に設定し、調整可能なパラメーターも指定することを強く推奨します。</entry>
    <entry key="rapidAccelUnableToStartExecutable">PID ''{1}'' を検出する必要がある、モデル ''{0}'' に対するラピッド アクセラレータの実行可能ファイルを起動できません。</entry>
    <entry key="rapidAccelUnableToFindPort">モデル ''{0}'' に対するラピッド アクセラレータ ターゲットに接続するための未使用の TCP/IP ポートが見つかりません</entry>
    <entry key="rapidAccelCannotGetPID">''{0}'' に対するラピッド アクセラレータ ターゲットの開始が成功したかどうかを特定できません</entry>
    <entry key="rapidAccelUnableToConnect">エクスターナル モードで ''{0}'' に対するラピッド アクセラレータ ターゲットに接続できません: {1}</entry>
    <entry key="rapidAccelExtModeConnectFailed">ラピッド アクセラレータ ターゲットの接続に失敗しました</entry>
    <entry key="rapidAccelTgtConnConnectFailed">内部の接続に問題があるため、次のシミュレーション機能はラピッド アクセラレータ モードで使用できません:\n -シミュレーション中の構造化されたパラメーターの調整\n -Simulink データ インスペクターへのデータのストリーミング\n -Simulink Dashboard ブロックへのデータのストリーミング</entry>
    <entry key="rapidAccelExeModeStartFailed">モデル ''{0}'' に対するラピッド アクセラレータ ターゲットは、開始に失敗しました</entry>
    <entry key="rapidAccelExeInterrupted">シミュレーションは中止しました</entry>
    <entry key="rapidAccelSettingUp">ラピッド アクセラレータ モードでシミュレーションするよう設定中</entry>
    <entry key="rapidAccelBuilding">ラピッド アクセラレータ ターゲットをビルド中</entry>
    <entry key="rapidAccelLaunching">ラピッド アクセラレータ ターゲットを起動中</entry>
    <entry key="rapidAccelConnecting">ラピッド アクセラレータ ターゲットに接続中</entry>
    <entry key="rapidAccelRunning">ラピッド アクセラレータ モードで実行中</entry>
    <entry key="rapidAccelRunningInMultithreading">{0,number,integer} 個のワーカー スレッドを使ってラピッド アクセラレータ モードで実行中</entry>
    <entry key="rapidAccelSecondSim">ラピッド アクセラレータ シミュレーション、または、モデル {0} のビルドは既に実行しています。2 つのビルドまたはシミュレーションを開始できません。</entry>
    <entry key="rapidAccelIncorrectOutputs">[コンフィギュレーション パラメーター] ダイアログ ボックスの [データのインポート/エクスポート] ページでモデル {0} に対して指定した出力の数が正しくありません。ルート レベルの Outport が別々に返されるように指定する場合、コンマ区切りのリスト内のフィールド数は、ルート レベルの Outport の数と等しくなければなりません。また、フィールドは有効な MATLAB 変数名でなければなりません。</entry>
    <entry key="rapidAccelInvalidOutputsVar">モデル {0} に対して指定された出力変数が正しくありません。</entry>
    <entry key="rapidAccelToFileBlksNotSupportedWithoutUpdate">モデル {0} は ToFile ブロックを含んでいます。ToFile ブロックは、最新のチェックをオフにしてシミュレーションする場合はサポートされません。</entry>
    <entry key="rapidAccelExeNotFound">モデル ''{0}'' で実行可能なラピッド アクセラレータが見つかりません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="BuildRapidAcceleratorTargetFix"&gt; &lt;cmd&gt;Simulink.BlockDiagram.buildRapidAcceleratorTarget(''{0}'')&lt;/cmd&gt; &lt;txt&gt;モデル ''{0}'' 用にラピッド アクセラレータ ターゲットをビルドする&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;

</entry>
    <entry key="rapidAccelBadBlockDiagramParameterNonexistent"> モデル ''{0}'' のブロック線図パラメーター ''{2}'' の評価中にエラーが発生しました: ''{2}'' の値として ''{1}'' が指定されていますが、ベース ワークスペースまたは ''{0}'' のモデル ワークスペースに ''{1}'' という名前の変数がありません。''{2}'' の値として有効なリテラル値または有効な変数名を指定してください。 </entry>
    <entry key="rapidAccelBadBlockDiagramParameterExpectingNumeric"> モデル ''{0}'' のブロック線図パラメーター ''{2}'' の評価中にエラーが発生しました: ''{2}'' の値は数値でなければならず、''{1}'' が指定されていますが、''{1}'' が数値でない値に評価されました。''{2}'' に対して数値を指定してください。 </entry>
    <entry key="rapidAccelAutoSolverError">最新のチェックをオフにしたラピッド アクセラレータは、自動ソルバーとの互換性がありません。最新のチェックをオンにするか、非自動ソルバーを使用してください。</entry>
    <entry key="rapidAccelExtModeTestingError">モデルに対する ExtModeTesting パラメーターの設定中にエラーがありました: {0},: {1}, {2}。</entry>
    <entry key="rapidAccelOutportInvalidArrayDataLogging">出力をワークスペースへ保存するための [配列] の形式は、ルートの Outport に接続されるすべての信号が、スカラーまたは 1 次元配列である必要があります。[コンフィギュレーション パラメーター]、[データのインポート/エクスポート] の [形式] を [構造体] または [時間付き構造体] に指定してください。</entry>
    <entry key="NoRapidAccelSimModeForRootFcnCall">モデル ''{0}'' には関数呼び出しを生成するルートレベルの inport (''{1}'') が含まれているため、このモデルではラピッド アクセラレータ シミュレーション モードはサポートされていません。</entry>
    <entry key="rapidAccelSFunctionNeedsToBeRegenerated">S-Function ブロック ''{0}'' への入力または出力として使用されたバスに、Simulink が追加したパディングがあります。この S-Function をラピッド アクセラレータ シミュレーションの最上位モデルで使用する前に、最初に作成したときと同じツールを使ってその S-Function を再生成してください。&lt;a href="matlab:sl(''upgradeadvisor'', ''{1}'')"&gt;アップグレード アドバイザー&lt;/a&gt;のチェック [コンパイル時の情報を必要とする、既知のブロック アップグレード問題についてモデルをチェックします] は、このようなすべてのブロックの特定と自動更新を行う際に役立ちます。</entry>
    <entry key="rapidAccelSFunctionBuilderNeedsToBeRegenerated">S-Function Builder ブロック ''{0}'' への入力または出力として使用されバスに、Simulink が追加したパディングがあります。この S-Function をラピッド アクセラレータ シミュレーションの最上位モデルで使用する前に、S-Function Builder で S-Function を再生成してください。&lt;a href="matlab:sl(''upgradeadvisor'', ''{1}'')"&gt;アップグレード アドバイザー&lt;/a&gt;のチェック [コンパイル時の情報を必要とする、既知のブロック アップグレード問題についてモデルをチェックします] は、このようなすべてのブロックの特定と自動更新を行う際に役立ちます。</entry>
    <entry key="rapidAccelSimHardwareAccelRapidAccelUpToDateCheck">モデルは、パラメーター 'SimHardwareAccelerarion' が別の CPU に対し 'native' となる設定でコンパイルされており、'RapidAcceleratorUpToDateCheck' が 'Off' に設定された状態でシミュレートすることはできません。'RapidAcceleratorUpToDateCheck' を 'On' に設定してモデルをシミュレートし、現在の CPU 用にモデルを再コンパイルしてください。</entry>
    <entry key="rapidAcceleratorExternalModeConnectStage">ラピッド アクセラレータ プロセスに接続してシミュレート</entry>
    <entry key="rapidAcceleratorExeErrorBeforeConnect"> モデル ''{0}'' のラピッド アクセラレータ ターゲットに接続しようとしたときにエラーが発生しました: ''{1}'' </entry>
    <entry key="rapidAcceleratorConnectTakingTooLong"> モデル ''{0}'' のラピッド アクセラレータ シミュレーションの開始に通常より時間がかかっています。 </entry>
    <entry key="rapidAccelSFcnDataTypeAccess"> S-Function ''{0}'' が simstruct メソッド ''{1}'' を呼び出そうとしました。ラピッド アクセラレータ モードで使用される S-Function 内では、メソッド ''{1}'' は許可されていません。''{1}'' の呼び出しは、ssGetDataTypeProperties、ssGetNumBusElements などの simstruct メソッド経由で間接的に行われた可能性があります。</entry>
    <entry key="rapidAccelSFcnRegDataType"> S-Function ''{0}'' が simstruct メソッド ''{1}'' を呼び出そうとしました。ラピッド アクセラレータ モードで使用される S-Function 内では、メソッド ''{1}'' は許可されていません。</entry>
    <entry key="rapidAccelSFcnMex"> S-Function ''{0}'' が MEX API 関数 ''{1}'' を呼び出そうとしました。ラピッド アクセラレータ モードで使用される S-Function 内では、''{1}'' の呼び出しは許可されていません。</entry>
    <entry key="rapidAccelSFcnMexFileNotFoundDuringUTDCOffSim"> S-Function ''{0}'' の MEX ファイルが見つかりませんでした。モデル ''{1}'' のラピッド アクセラレータ シミュレーションは中止されました。''{0}'' の MEX ファイルを MATLAB パス上に配置してください。 </entry>
    <entry key="rapidAccelSFcnsWithoutSourceNotSupportedMinGW"> モデル ''{0}'' に含まれる非インライン化 C S-Function のソース コードが、S-Function の MEX ファイルと同じディレクトリにありません。MinGW を使用する場合、ラピッド アクセラレータ モードでのそのような S-Function の使用は許可されていません。''{0}'' をラピッド アクセラレータ モードで実行するには、コンパイラを変更するか、''{0}'' の各 S-Function のソース コードを、必ず S-Function の MEX ファイルと同じディレクトリに配置してください。 </entry>
    <entry key="rapidAccelSFcnSourceExistsButUsingMexFileAnyways"> S-Function ''{0}'' のソース コードは MATLAB パス上に存在しますが、S-Function の MEX ファイルと同じディレクトリにはありません。現在のラピッド アクセラレータ シミュレーションは、S-Function の MEX ファイルを動的に読み込みます。''{0}'' のソース コードはラピッド アクセラレータのターゲットにコンパイルされません。 </entry>
    <entry key="rapidAccelSFcnErrorDuringrtwmakecfg"> S-Function ''{0}'' に対して rtwmakecfg を呼び出すときにエラーが発生しました: rtwmakecfg によって返される構造体の 'sourcePath' フィールドは string のセル配列でなければなりません。 </entry>
    <entry key="rapidAccelSFcnLoaderBlockError"> ラピッド アクセラレータ モードで S-Function ''{0}'' の MEX ファイルを動的に読み込もうとしたときに内部エラーが発生しました: ''{1}''。''{0}'' のソース コードを指定するか、ノーマル モードまたはアクセラレータ モードでモデルのシミュレーションを試してください。 </entry>
    <entry key="rapidAccelSFcnLoaderSFcnInfoFileNameNull"> ラピッド アクセラレータ モードの初期化中に内部エラーが発生しました: MEX S-Function 情報ファイル名がラピッド アクセラレータ ターゲットに指定されていません。シミュレーションを再実行してください。 </entry>
    <entry key="rapidAccelSFcnLoaderSFcnInfoFileError"> ラピッド アクセラレータ モードで MEX S-Function を動的に読み込むための準備中に内部エラーが発生しました: ''{0}'' </entry>
    <entry key="rapidAccelSFcnLoaderMexFileError"> ラピッド アクセラレータ モードで S-Function MEX ファイル ''{0}'' の処理中に内部エラーが発生しました: ''{1}''。対応する S-Function のソース コードを指定するか、ノーマル モードまたはアクセラレータ モードでモデルのシミュレーションを試してください。 </entry>
    <entry key="rapidAccelInitialStateError"> モデル ''{0}'' の初期状態の取得中にエラーが発生しました。 </entry>
    <entry key="rapidAccelCollapsedParameterComplexityMismatch"> ''{0}'' の値は ''{1}'' ですが、''{3}'' のラピッド アクセラレータ ターゲットがビルドされたときは ''{2}'' でした。最新チェックがオフのシミュレーションを実行しているときに、式 ''{0}'' の値の実数/複素数を変更することはできません。 </entry>
    <entry key="rapidAccelCollapsedParameterLengthMismatch"> The value of the expression '{0}'' has ''{1}'' elements but had ''{2}'' elements when the Rapid Accelerator target for ''{3}'' was built. The number of elements in the value of the expression ''{0}''  cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelCollapsedParameterUnableToCast"> 式 ''{0}'' の値は ''{1}'' 型ですが、''{3}'' のラピッド アクセラレータ ターゲットがビルドされたときは ''{2}'' 型でした。最新チェックがオフのシミュレーションを実行しているときに、式 ''{0}'' の値の型を変更することはできません。 </entry>
    <entry key="rapidAccelMaskParameterEvaluationError"> ブロック ''{1}'' の式 ''{0}'' の値の計算中にエラーが発生しました。</entry>
    <entry key="rapidAccelMaskParameterComplexityMismatch"> ブロック ''{1}'' の式 ''{0}'' の値の計算中にエラーが発生しました: ''{0}'' の値は ''{2}'' ですが、''{4}'' のラピッド アクセラレータ ターゲットがビルドされたときは ''{3}'' でした。最新チェックがオフのシミュレーションを実行しているときに、式 ''{0}'' の値の実数/複素数を変更することはできません。 </entry>
    <entry key="rapidAccelMaskParameterLengthMismatch"> ブロック ''{1}'' の式 ''{0}'' の値の計算中にエラーが発生しました: ''{0}'' の値には ''{2}'' 個の要素がありますが、''{4}'' のラピッド アクセラレータ ターゲットがビルドされたときは ''{3}'' 個の要素がありました。最新チェックがオフのシミュレーションを実行しているときに、式 ''{0}'' の値の要素数を変更することはできません。 </entry>
    <entry key="rapidAccelMaskParameterUnableToCast"> ブロック ''{1}'' の式 ''{0}'' の値の計算中にエラーが発生しました: ''{0}'' の値は ''{2}'' 型ですが、''{4}'' のラピッド アクセラレータ ターゲットがビルドされたときは ''{3}'' 型でした。最新チェックがオフのシミュレーションを実行しているときに、式 ''{0}'' の値の型を変更することはできません。 </entry>
    <entry key="rapidAccelSparseParameterLengthMismatch"> The parameter ''{0}'' of the block ''{1}'' has ''{2}'' non zero elements but had ''{3}'' at build time. The number of non zero elements in the value of ''{0}''  cannot increase. </entry>
    <entry key="rapidAccelSparseParameterShapeMismatch"> The shape of the sparse expression / variable ''{0}'' has ''{1}'' columns but had ''{2}'' columns when the Rapid Accelerator target for ''{3}'' was built. The number of columns in the value of the sparse expression / variable ''{0}''  cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelSparseParameterComplexityMismatch"> The value of ''{0}'' is ''{1}'' but was ''{2}'' when the Rapid Accelerator target for ''{3}'' was built. The complexity of the value of the sparse expression / variable ''{0}'' cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelSparseParameterUnableToCast"> The value of the sparse expression / variable ''{0}'' has type ''{1}'' but had type ''{2}'' when the Rapid Accelerator target for ''{3}'' was built. The type of the value of the sparse expression / variable ''{0}''  cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelSparseParameterInvalidType"> スパース式/変数 ''{0}'' の型が ''{1}'' ですが、これは数値の実行時パラメーターでは許可されていません。このパラメーターには数値または数式を指定してください。</entry>
    <entry key="rapidAccelSparseParameterPatternMismatch"> The sparsity pattern of parameter ''{0}'' of the block ''{1}'' is not allowed to change.</entry>
    <entry key="rapidAccelTransformedParameterArgComplexityMismatch"> The value of the expression ''{0}'' is ''{1}'' but was ''{2}'' when the Rapid Accelerator target for ''{3}'' was built. The complexity of the value of the expression ''{0}'' cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelTransformedParameterArgSizeMismatch"> The value of the expression ''{0}'' has ''{1}'' dimension but had ''{2}'' dimension when the Rapid Accelerator target for ''{3}'' was built. The dimension of the expression ''{0}'' cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelTransformedParameterArgTypeMismatch"> The value of the expression ''{0}'' has type ''{1}'' but had type ''{2}'' when the Rapid Accelerator target for ''{3}'' was built. The type of the value of the expression ''{0}'' cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelTransformedParameterLengthMismatch"> The transformed parameter has ''{0}'' elements but had ''{1}'' elements when the Rapid Accelerator target for ''{2}'' was built. The number of elements of the transformed parameter cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelTransformedParameterComplexityMismatch"> The transformed parameter is ''{0}'' but was ''{1}'' when the Rapid Accelerator target for ''{2}'' was built. The complexity of the transformed parameter cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelTransformedParameterTypeMismatch"> The transformed parameter has type ''{0}'' but had type ''{1}'' when the Rapid Accelerator target for ''{2}'' was built. The type of the transformed parameter cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelBusParameterStructVariableMismatch">ブロック ''{1}'' のパラメーター ''{0}'' は、Simulink Compiler シミュレーションにおいて、または RapidAcceleratorUpToDateCheckOff が 'off' である場合、調整可能ではありません: パラメーターの値を指定する構造体が、パラメーターのバス型と一致しません。</entry>
    <entry key="TopModelPilERT">SIL または PIL シミュレーション モードで "{0}" を実行できません。Embedded Coder がインストールされていないか、ライセンスがありません。これを解決するには、Embedded Coder をインストールしてライセンスを確認してください。</entry>
    <entry key="TopModelPilSLC">SIL または PIL シミュレーション モードで "{0}" を実行できません。Simulink Coder がインストールされていないか、ライセンスがありません。これを解決するには、Simulink Coder をインストールしてライセンスを確認してください。</entry>
    <entry key="pilRunning">{0} モードを実行中 (中止する場合はコマンド ウィンドウで Ctrl+C キーを押してください)</entry>
    <entry key="MAMergeAnalysisError">Merge の解析を完了できません:</entry>
    <entry key="MADataStoreAnalysisRBWError">書き込み前の読み取りデータ ストア分析を完了することができません</entry>
    <entry key="MAMergeAnalysisInvalidMaxAnalysisTime">最大解析時間は正のスカラー値でなければなりません。</entry>
    <entry key="MAMergeAnalysisSummaryHeading">まとめ</entry>
    <entry key="MAMergeAnalysisDetailHeading">詳細</entry>
    <entry key="MAMergeAnalysisDescOverall">Merge ブロックはツリー構造を作るために結合できます。下記のレポートは、グループとして同じツリー内の Merge ブロックをまとめて解析した結果を示します。</entry>
    <entry key="MAMergeAnalysisDescPassed">この Merge ブロックのツリーは適切に使われています。</entry>
    <entry key="MAMergeAnalysisDescUnknown">Merge の解析手順は、与えられた時間で解析を完了できません。</entry>
    <entry key="MAMergeAnalysisTotalMergeTrees">Merge ツリーの総数</entry>
    <entry key="MAMergeAnalysisStatus">状態</entry>
    <entry key="MAMergeAnalysisMergeTree">Merge ツリー</entry>
    <entry key="MAMergeAnalysisDescription">説明</entry>
    <entry key="MAMergeAnalysisHeadingFailed">失敗</entry>
    <entry key="MAMergeAnalysisHeadingPassed">パス</entry>
    <entry key="MAMergeAnalysisHeadingWarning">警告</entry>
    <entry key="MAMergeAnalysisHeadingUnknown">不明</entry>
    <entry key="MAMergeAnalysisProblemForcedRun">ブロック {0} と {1} は、同じ Merge ブロックのツリーを駆動し、同じタイム ステップで実行できます。</entry>
    <entry key="MAMergeAnalysisForDetailsSee">Merge ブロックの使用についての詳細は、次を参照してください</entry>
    <entry key="MAMergeAnalysisMerge">マージ</entry>
    <entry key="MAMsgAnd">と</entry>
    <entry key="MAMsgBlock">ブロック</entry>
    <entry key="MAMsgBlocks">ブロック</entry>
    <entry key="MAUnableToRunCheckOnSubsystem">このチェックは最上位のモデルからのみ動作します。そのため、このチェックを実行するには、最上位のモデルからモデル アドバイザーを実行してください。</entry>
    <entry key="MAOutportCondSubsysCheckError">Outport と Merge の初期化パラメーターのチェックが完了できません: </entry>
    <entry key="MAOutportCondSubsysCheckLibraryBlock">ライブラリ ブロック</entry>
    <entry key="MAOutportCondSubsysCheckInstance">インスタンス</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOverall">Outport ブロックの使用をチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOverall">このチェックは簡易初期化モードへの移行に備えて Outport ブロックと条件付きサブシステムに関連する問題を検出し、報告します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOverall">このモデルでは簡易初期化モードを使用していません。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOverallHasError">モデルを変更して以下の失敗したサブチェックをすべて解決した後、このチェックを再実行してください。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOverallNoErrorButHasWarning">サブチェックで報告された以下のすべての警告に必ず対処してください</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOverallNoErrorNoWarning">Outport ブロックまたは条件付きサブシステムに関連するメッセージは見つかりませんでした。コンフィギュレーション パラメーターを使用してこのモデルを簡易初期化モードに移行させることができます</entry>
    <entry key="MAOutportCondSubsysCheckHeadingBlockDiagramErrorNeedStrictBusMode">バス診断設定を確認</entry>
    <entry key="MAOutportCondSubsysCheckDescBlockDiagramErrorNeedStrictBusMode">[コンフィギュレーション パラメーター] ダイアログ ボックスの [診断] の [接続性] ペインで [Mux ブロックをバス信号の作成に使用] オプションが [エラー] に設定されていることを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusBlockDiagramErrorNeedStrictBusMode">このモデルで不適切なバス診断設定が検出されました。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionBlockDiagramErrorNeedStrictBusMode">[Mux ブロックをバス信号の作成に使用] オプションを [エラー] に設定すると、エラーなしでモデルが更新されることを確認してください。</entry>
    <entry key="MAMergeBlockCheckLibraryBlock">ライブラリ ブロック</entry>
    <entry key="MAMergeBlockCheckInstance">インスタンス</entry>
    <entry key="MAMergeBlockCheckHeadingLibraryBlockErrorMigration">移行できないインスタンスをもつライブラリ ブロックをチェック</entry>
    <entry key="MAMergeBlockCheckDescLibraryBlockErrorMigration">モデル内の、ライブラリにリンクされたブロックのすべてのインスタンスが簡易初期化モードに安全に移行できることを確認します。</entry>
    <entry key="MAMergeBlockCheckStatusLibraryBlockErrorMigration">次のライブラリ ブロックには、簡易初期化モードに移行できないインスタンスが少なくとも 1 つあるか、または異なる移行パスをもつインスタンスが少なくとも 2 つあります。</entry>
    <entry key="MAMergeBlockCheckRecActionLibraryBlockErrorMigration">これらのブロックごとに、適切な改善策を判断するためにインスタンスに関するサブチェックの結果を検証してください。</entry>
    <entry key="MAMergeBlockCheckHeadingLibraryBlockWarningMigration">警告をもつインスタンスがあるライブラリ ブロックをチェック</entry>
    <entry key="MAMergeBlockCheckDescLibraryBlockWarningMigration">警告をもつインスタンスがあるライブラリ ブロックを特定します。</entry>
    <entry key="MAMergeBlockCheckStatusLibraryBlockWarningMigration">以下の各ライブラリ ブロックには、サブチェックの警告をもつインスタンスが少なくとも 1 つあります。</entry>
    <entry key="MAMergeBlockCheckRecActionLibraryBlockWarningMigration">すべての警告を許容できるかどうかを判断してください。警告を許容できない場合は、簡易初期化モードに移行する前に警告に従ってモデルを変更してください。</entry>
    <entry key="MAMergeBlockCheckHeadingOverall">Merge ブロックの使用をチェック</entry>
    <entry key="MAMergeBlockCheckDescOverall">このチェックは簡易初期化モードへの移行に備えて Merge ブロックに関連する問題を検出し、レポートします。 </entry>
    <entry key="MAMergeBlockCheckStatusOverall">このモデルでは簡易初期化モードを使用していません。</entry>
    <entry key="MAMergeBlockCheckRecActionOverallHasError">モデルを変更して以下の失敗したサブチェックをすべて解決した後、このチェックを再実行してください。</entry>
    <entry key="MAMergeBlockCheckRecActionOverallNoErrorButHasWarning">以下のサブチェック内で報告された警告を確認し、注意が必要なすべての問題に対処してください。</entry>
    <entry key="MAMergeBlockCheckRecActionOverallNoErrorNoWarning">Merge ブロックに関連するメッセージは見つかりませんでした。コンフィギュレーション パラメーターを使用してこのモデルを簡易初期化モードに移行させることができます。</entry>
    <entry key="MAMergeBlockCheckHeadingBlockDiagramErrorNeedMergeDiagnostics">Merge ブロックの実行時診断設定をチェック</entry>
    <entry key="MAMergeBlockCheckDescBlockDiagramErrorNeedMergeDiagnostics">[コンフィギュレーション パラメーター] ダイアログ ボックスで、Merge ブロックの [同じタイム ステップで実行する複数の駆動ブロックを検出] オプションが [エラー] に設定されていることを確認してください。</entry>
    <entry key="MAMergeBlockCheckStatusBlockDiagramErrorNeedMergeDiagnostics">このモデルの Merge ブロックで不適切な実行時診断設定が検出されました。</entry>
    <entry key="MAMergeBlockCheckRecActionBlockDiagramErrorNeedMergeDiagnostics">[同じタイム ステップで実行する複数の駆動ブロックを検出] オプションを [エラー] にセットした後、モデルのシミュレーションでエラーが発生しないことを確認してください。</entry>
    <entry key="MAModelLevelMessagesCheckHeadingOverall">モデル レベルのメッセージをチェック</entry>
    <entry key="MAModelLevelMessagesCheckDescOverall">このチェックは簡易初期化モードへの移行に備えてモデル レベルのメッセージを検出し、報告します。</entry>
    <entry key="MAModelLevelMessagesCheckStatusOverall">このモデルについて、対処が必要ないくつかのモデル レベルのメッセージが報告されています。</entry>
    <entry key="MAModelLevelMessagesCheckRecActionOverallHasError">モデルを変更して以下の失敗したサブチェックをすべて解決した後、このチェックを再実行してください。</entry>
    <entry key="MAModelLevelMessagesCheckRecActionOverallNoErrorButHasWarning">以下のサブチェック内で報告された警告を確認し、注意が必要なすべての問題に対処してください。</entry>
    <entry key="MAModelLevelMessagesCheckRecActionOverallHasErrorOtherChecksFail">また、モデルを変更して以下の失敗したサブチェックをすべて解決した後、このチェックを再度実行してください。</entry>
    <entry key="MAModelLevelMessagesCheckRecActionOverallNoErrorButHasWarningOtherChecksFail">また、以下のサブチェック内で報告された警告を確認し、注意が必要なすべての問題に対処してください。</entry>
    <entry key="MAModelLevelMessagesCheckRecActionOtherChecks">次のチェックを実行し、報告されたすべての問題に対処してください。</entry>
    <entry key="MAModelLevelMessagesCheckHeadingBlockDiagramWarningClassicMode">簡易初期化モード設定を確認</entry>
    <entry key="MAModelLevelMessagesCheckDescBlockDiagramWarningClassicMode">[コンフィギュレーション パラメーター] ダイアログ ボックスで、[指定不足の初期化の検出] パラメーターが [簡易] に設定されていることを確認してください。</entry>
    <entry key="MAModelLevelMessagesCheckStatusBlockDiagramWarningClassicMode">このモデルでは簡易初期化モードを使用していません。</entry>
    <entry key="MAModelLevelMessagesCheckRecActionBlockDiagramWarningClassicMode">このモデルの &lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;[指定不足の初期化の検出]&lt;/sldiag&gt; 設定を [簡易] に設定します</entry>
    <entry key="MAModelLevelMessagesCheckHeadingModelReferenceErrorModelRefNeedConsistentOutportInit">Model ブロックで簡易初期化モードを使用していることを確認</entry>
    <entry key="MAModelLevelMessagesCheckDescModelReferenceErrorModelRefNeedConsistentOutportInit">すべての参照モデルで簡易初期化モードが使用されていることを確認します。</entry>
    <entry key="MAModelLevelMessagesCheckStatusModelReferenceErrorModelRefNeedConsistentOutportInit">次の Model ブロックが参照するモデルでは、簡易初期化モードへの移行が行われていません。</entry>
    <entry key="MAModelLevelMessagesCheckRecActionModelReferenceErrorModelRefNeedConsistentOutportInit">以下のサブチェック内で報告された警告を確認し、注意が必要なすべての問題に対処してください。エラーが報告されなかった場合、[指定不足の初期化の検出] モードを [簡易] に変更できます</entry>
    <entry key="MAMergeBlockCheckHeadingMergeErrorSingleInput">単一入力 Merge ブロックをチェック</entry>
    <entry key="MAMergeBlockCheckDescMergeErrorSingleInput">入力端子が 1 つのみの Merge ブロックがないことを確認します。</entry>
    <entry key="MAMergeBlockCheckStatusMergeErrorSingleInput">以下の Merge ブロックには入力端子が 1 つしかありません。単入力の Merge ブロックは、簡易初期化モードでサポートされていません。</entry>
    <entry key="MAMergeBlockCheckRecActionMergeErrorSingleInput">Mux ブロックと単一入力 Merge ブロックの組み合わせを等価な多入力の Merge ブロックと置き換えてください。</entry>
    <entry key="MAMergeBlockCheckHeadingMergeErrorEmptyIC">[初期出力] が未指定になっているルート Merge ブロックをチェック</entry>
    <entry key="MAMergeBlockCheckDescMergeErrorEmptyIC">[初期出力] パラメーターがすべてのルート Merge ブロックに対して明示的に指定されていることを確認します。</entry>
    <entry key="MAMergeBlockCheckStatusMergeErrorEmptyIC">[初期出力] パラメーターは以下のルート Merge ブロックに対して明示的に指定されていません。</entry>
    <entry key="MAMergeBlockCheckRecActionMergeErrorEmptyIC">上にリストされた Merge ブロックの [初期出力] パラメーターを [] 以外の値に設定してください。</entry>
    <entry key="MAMergeBlockCheckHeadingMergeWarningUseDefaultIC">[初期出力] が未指定になっているルート Merge ブロックをチェック</entry>
    <entry key="MAMergeBlockCheckDescMergeWarningUseDefaultIC">[初期出力] 値が明示的に指定されていない Merge ブロックの新しい動作について警告します</entry>
    <entry key="MAMergeBlockCheckStatusMergeWarningUseDefaultIC">以下の Merge ブロックには、[初期出力] パラメーターが明示的に指定されていません。この場合、Merge ブロックは既定のグラウンド値を [初期出力] 値として使用します。</entry>
    <entry key="MAMergeBlockCheckRecActionMergeWarningUseDefaultIC">Merge ブロックの新しい動作を許容できるかどうかを判断してください。許容できない場合は、簡易初期化モードに移行する前にモデルを変更して新しい動作に対処してください。</entry>
    <entry key="MAMergeBlockCheckHeadingMergeErrorInputOffsets">入力端子オフセットが非ゼロの Merge ブロックをチェック</entry>
    <entry key="MAMergeBlockCheckDescMergeErrorInputOffsets">すべての Merge ブロックの [異なる端子幅を許可] パラメーターがオフであることを確認します。</entry>
    <entry key="MAMergeBlockCheckStatusMergeErrorInputOffsets">以下の Merge ブロックのパラメーター [異なる端子幅を許可] がオンになっています。</entry>
    <entry key="MAMergeBlockCheckRecActionMergeErrorInputOffsets">上にリストされた Merge ブロックの [異なる端子幅を許可] パラメーターをオフにしてください。true のマージを必要とする信号要素に対してのみ Merge ブロックを使用してください。その他の要素は、Concatenate ブロックを使用してマージされた要素と連続的に結合できます。</entry>
    <entry key="MAMergeBlockCheckHeadingMergeErrorNonCondSubsysSrc">未接続の入力をもっている Merge ブロック、または条件付きではない実行サブシステムからの入力をもっている Merge ブロックをチェック</entry>
    <entry key="MAMergeBlockCheckDescMergeErrorNonCondSubsysSrc">Merge ブロックが、未接続の入力、Iterator Subsystem で直接駆動される入力、条件付き実行サブシステムではないブロックによる入力のいずれももっていないことを確認します。</entry>
    <entry key="MAMergeBlockCheckStatusMergeErrorNonCondSubsysSrc">次の Merge ブロックで不適切な入力接続が検出されました。</entry>
    <entry key="MAMergeBlockCheckRecActionMergeErrorNonCondSubsysSrc">上記で指定された要件ごとに、上にリストされた Merge ブロックの入力接続を変更してください。</entry>
    <entry key="MAMergeBlockCheckHeadingMergeErrorDiscontigCondSubsysSrc">結合された入力、または条件付き実行サブシステム以外によって並べ替えられた入力をもつ Merge ブロックをチェック</entry>
    <entry key="MAMergeBlockCheckDescMergeErrorDiscontigCondSubsysSrc">Mux、Bus Creator、Selector のいずれかのブロックを使用して、どの Merge ブロックも、結合された入力信号または条件付き実行サブシステム以外によって並べ替えられた入力信号をもっていないことを確認します。</entry>
    <entry key="MAMergeBlockCheckStatusMergeErrorDiscontigCondSubsysSrc">次の Merge ブロックで不適切な入力接続が検出されました。</entry>
    <entry key="MAMergeBlockCheckRecActionMergeErrorDiscontigCondSubsysSrc">上記の要件ごとに、上にリストされた Merge ブロックの入力接続を変更してください。</entry>
    <entry key="MAMergeBlockCheckHeadingMergeErrorMultSrcTs">一貫しないサンプル時間をもつ Merge ブロックをチェック</entry>
    <entry key="MAMergeBlockCheckDescMergeErrorMultSrcTs">対象の Merge ブロックのすべての入力信号が同じサンプル時間をもつことを確認します。</entry>
    <entry key="MAMergeBlockCheckStatusMergeErrorMultSrcTs">以下の Merge ブロックは、異なるサンプル時間の入力信号をもっています。</entry>
    <entry key="MAMergeBlockCheckRecActionMergeErrorMultSrcTs">上記の要件ごとに、上にリストされた Merge ブロックの入力信号のサンプル時間を変更してください。</entry>
    <entry key="MAMergeBlockCheckHeadingMergeErrorMultInputsDrivenBySameSrc">単一のソースによって駆動される複数の入力端子をもつ Merge ブロックをチェック</entry>
    <entry key="MAMergeBlockCheckDescMergeErrorMultInputsDrivenBySameSrc">どの Merge ブロックも、同一の条件付き実行サブシステムにより駆動される、または、条件付きで実行される Merge ブロックにより駆動される入力信号をもたないことを確認します。</entry>
    <entry key="MAMergeBlockCheckStatusMergeErrorMultInputsDrivenBySameSrc">次の Merge ブロックで不適切な入力接続が検出されました。</entry>
    <entry key="MAMergeBlockCheckRecActionMergeErrorMultInputsDrivenBySameSrc">上記の要件ごとに、上にリストされた Merge ブロックの入力接続を変更してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorBufferConflictFcnCall">信号のバッファー要件が競合する Outport ブロックをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorBufferConflictFcnCall">関数呼び出し信号を妨げるバッファーがないことを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorBufferConflictFcnCall">以下の個々の Outport ブロックは、標準データ信号と関数呼び出しトリガーの両方か、それを経由して渡される関数呼び出しデータに依存する信号のいずれかをもっています。確実に正しい初期化を行うために、標準データ信号によっては明示的な信号バッファーを必要とします。しかし、関数呼び出しに関連する信号のバッファーリングが関数呼び出しデータ依存の違反になるので、そのようなバッファリングを適用できません。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorBufferConflictFcnCall">関数呼び出しに関連する信号を接続する Outport ブロックとは異なる標準データ信号に Outport ブロックを使用するように、モデルを変更してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorBufferConflictSigObj">非自動ストレージ クラスを含む信号オブジェクトが原因で信号のバッファー要件が競合する Outport ブロックをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorBufferConflictSigObj">非自動ストレージ クラスを含む信号オブジェクトを妨げるバッファーがないことを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorBufferConflictSigObj">次の各 Outport ブロックの着信信号ラインには、非自動ストレージ クラスをもつ信号オブジェクトがあります。この場合、初期化が正しく行われることを確認するために、簡易初期化モードで信号バッファーを明示的に挿入する必要があります。しかし、挿入すると、Simulink ではこのような非自動ストレージ クラスと対応するサブシステム出力を関連付けることができなくなるので、バッファーの挿入はできません。バッファーは、次の 1 つまたは複数の理由のために必要です。&lt;br&gt;(1) Ground ブロック、Constant ブロックまたは Stateflow ブロックなど、出力が上書きできないブロックで Outport が駆動されている。&lt;br&gt;(2) Outport は、Merge ブロックの入力に接続されている。&lt;br&gt;(3) Outport は、現在のサブシステム内で入れ子にされている別の Outport と同じ信号ソースを共有しているが、独自に明示的な初期出力値をもっている。&lt;br&gt;(4) Outport は、同じサブシステム内で別の Outport と同じ信号ソースを共有しているが、独自に明示的な初期出力値をもっている。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorBufferConflictSigObj">いずれの理由でも、Outport ブロックの前に Signal Conversion ブロックを挿入し、ストレージ クラスの指定を挿入されたブロックの出力に移動することを検討してください。理由 (4) の場合は、別の Outport を経由して非自動ストレージ クラスをもつ信号が渡されるように、モデルを変更することを検討してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorNeedVirtualBusCopy">明示的なバス コピーを必要とする Outport ブロックをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorNeedVirtualBusCopy">必要なときにすべての Outport ブロックに対する入力バス信号がコピーされることを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorNeedVirtualBusCopy">必ず正しく初期化するために、以下の Outport ブロックは、入力バス信号の明示的なコピーを必要とします。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorNeedVirtualBusCopy">それぞれの Outport ブロックの前に Signal Conversion ブロックを挿入し、[出力] パラメーターを [信号コピー] に設定してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorScalarICForBusSignal">バス信号により駆動され、[初期出力] がスカラー値ではない Outport ブロックをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorScalarICForBusSignal">すべての Outport ブロックがバス信号により駆動され、[初期出力] がスカラー値であることを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorScalarICForBusSignal">次の Outport ブロックでは、初期出力値にスカラーが必要です。この値でない場合、簡易初期化モードに移行した後でモデルを更新できません。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorScalarICForBusSignal">各 Outport ブロックの [初期出力] パラメーターにスカラー値を入力します。すべての要素の初期値が同じでない場合、Initial Condition (IC) 構造体を使用して、簡易初期化モードへの移行後に [初期出力] を設定します。Initial Condition 構造体の詳細については、関連するドキュメンテーションを参照してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorMergedButInheritingFromResetWhenDisabledOutport">マージされた Outport ブロックが、ディセーブル時にリセットするように設定された Outport ブロックから初期出力値を継承するかどうかをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorMergedButInheritingFromResetWhenDisabledOutport">Merge ブロックを駆動するすべての Outport ブロックが、親サブシステムのディセーブル時に出力値を保持することを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorMergedButInheritingFromResetWhenDisabledOutport">以下の Outport ブロックは Merge ブロックを駆動しています。しかし、初期出力値の継承元である Outport ブロックは、ブロックがディセーブル時にリセットするように設定されています。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorMergedButInheritingFromResetWhenDisabledOutport">各 Outport ブロックの [ディセーブル時の出力] パラメーターが [保持] であることを確認してください。[初期出力] パラメーターに明示的な値が指定されていることを確認してください。または、対象のソース Outport ブロックで [ディセーブル時の出力] パラメーターを [保持] に変更してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorMergedButResetWhenDisabled">ブロックのディセーブル時にリセットされる結合 Outport ブロックをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorMergedButResetWhenDisabled">Merge ブロックを駆動するすべての Outport ブロックが、親サブシステムのディセーブル時に出力値を保持することを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorMergedButResetWhenDisabled">以下の Outport ブロックは Merge ブロックを駆動しますが、ブロックのディセーブル時にリセットするように設定されています。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorMergedButResetWhenDisabled">各 Outport ブロックに対して、[ディセーブル時の出力] パラメーターを [保持] に設定してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorEmptyIC">未定義の [初期出力] 値をもつ Outport ブロックをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorEmptyIC">すべての Outport ブロックが明確な [初期出力] 値をもっていることを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorEmptyIC">次の各 Outport ブロックで、[初期出力] パラメーターの無効な設定が検出されました。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorEmptyIC">各々の Outport ブロックに対する [初期出力] パラメーターを [] 以外の値に変更してください。代わりに、[]としてパラメーター値を残してください。しかし、すべての Outport ソースが [初期出力] 値の有効なソースであることを確認してください。Constant、Initial Condition、Merge (初期出力付き)、条件付き実行サブシステム ブロックのいずれかです。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportWarningUseDefaultIC">無効な初期条件ソースにより未定義となった [初期出力] 値をもつ Outport ブロックをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportWarningUseDefaultIC">空行列 ([]) を使用して既定の [初期出力] 値を指定する Outport ブロックの新しい動作について警告します</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportWarningUseDefaultIC">Outport には未定義の [初期出力] 値があり、Outport のソースの少なくとも 1 つは初期値を継承する有効なソースではないため、Outport では既定のグラウンド値を初期出力として使用します。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportWarningUseDefaultIC">Outport ブロックの新しい動作を許容できるかどうかを判断してください。許容できない場合は、簡易初期化モードに移行する前にモデルを変更して新しい動作に対処してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorEmptyICRateTrans">自動レート変換をもつ Outport ブロックをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorEmptyICRateTrans">[初期出力] パラメーターが、自動レート変換をもつすべての Outport ブロックに対して指定されていることを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorEmptyICRateTrans">Simulink は、以下の Outport ブロックの入力に Rate Transition ブロックを挿入しました。その [初期出力] パラメーターを指定しなければなりません。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorEmptyICRateTrans">初期出力値を指定してください。これを行わない場合は、[コンフィギュレーション パラメーター] ダイアログの [ソルバー] ペインでオプション [データ転送に対するレート変換を自動的に取り扱う] をオフにしてください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorEmptyICInternal">特別な信号ストレージ要件をもつ Outport ブロックをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorEmptyICInternal">[初期出力] パラメーターが、特別な信号ストレージ要件をもつすべての Outport ブロックに対して指定されていることを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorEmptyICInternal">Simulink 内部の信号ストレージ処理システムに従うために、[初期出力] を以下の Outport ブロックに対して明示的に指定しなければなりません。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorEmptyICInternal">各々の Outport ブロックに対する [初期出力] パラメーターを [] 以外の値に変更してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportWarningUseDefaultICInternal">[初期出力] 値が未定義の、特別な信号ストレージ要件をもつ Outport ブロックをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportWarningUseDefaultICInternal">空行列 ([]) を使用して既定の [初期出力] 値を指定する Outport ブロックの新しい動作について警告します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportWarningUseDefaultICInternal">Simulink 内部の信号ストレージ処理システムに対応させるために、Outport では既定のグラウンド値を初期出力として使用します。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportWarningUseDefaultICInternal">Outport ブロックの新しい動作を許容できるかどうかを判断してください。許容できない場合は、簡易初期化モードに移行する前にモデルを変更して新しい動作に対処してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorResetButEmptyIC">ディセーブル時にリセットされる Outport ブロックの [初期出力] 設定をチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorResetButEmptyIC">[初期出力] パラメーターが、ディセーブル時にリセットするすべての Outport ブロックに対して指定されていることを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorResetButEmptyIC">以下の Outport ブロックでは、[初期出力] パラメーターがディセーブル時にリセットされるよう設定されているため、明示的に指定されなければなりません。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorResetButEmptyIC">各々の Outport ブロックに対する [初期出力] パラメーターを [] 以外の値に変更してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorNeedEmptyICForFcnCallInArgPassThru">関数呼び出しデータ依存信号をパス スルーする Outport ブロックの [初期出力] 設定をチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorNeedEmptyICForFcnCallInArgPassThru">[初期出力] パラメーターが、関数呼び出しデータ依存信号をパス スルーする Outport ブロックに対して [] に設定されていることを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorNeedEmptyICForFcnCallInArgPassThru">以下の Outport ブロックでは関数呼び出しデータ依存信号がパス スルーされるため、[初期出力] パラメーターが [] に設定されなければなりません。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorNeedEmptyICForFcnCallInArgPassThru">各々の Outport ブロックに対する [初期出力] パラメーターを [] に設定してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportWarningSignalObjectSpecifyingICParam">信号オブジェクトを使用して [初期出力] 値を指定する Outport ブロックをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportWarningSignalObjectSpecifyingICParam">信号オブジェクトを使用して [初期出力] 値を指定する Outport ブロックの新しい動作に関して警告します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportWarningSignalObjectSpecifyingICParam">簡易初期化モードでは、次の Outport ブロックの [初期出力] パラメーターを信号オブジェクトで指定できなくなりました。信号オブジェクトは、これらの Outport ブロックの入力または出力信号を初期化するためにまだ使用できますが、初期化の結果が、Outport ブロックの信号オブジェクトにより上書きされる可能性があります。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportWarningSignalObjectSpecifyingICParam">Outport ブロックの新しい動作を許容できるかどうかを判断してください。許容できない場合は、簡易初期化モードに移行する前にモデルを変更して新しい動作に対処してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportWarningMergedFromGroundSrc">Ground ブロックへ未接続または接続済みの結合 Outport ブロックをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportWarningMergedFromGroundSrc">Merge ブロックを駆動しているが、Ground ブロックへの未接続の入力または接続済み入力をもっている Outport ブロックの新しい動作について警告します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportWarningMergedFromGroundSrc">クラシック初期化モードでは、未接続または接地された Outport ブロックは、それらの親の条件付き実行サブシステムを実行するときでもマージ信号を更新しません。ただし、簡易初期化モードでは、次の Outport ブロックは親である条件付き実行サブシステムが実行されるときに 0 の値でマージ信号を更新します。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportWarningMergedFromGroundSrc">Outport ブロックの新しい動作を許容できるかどうかを判断してください。許容できない場合は、簡易初期化モードに移行する前にモデルを変更して新しい動作に対処してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportWarningMergedFromNestedCondSubsysSrc">入れ子の条件付き実行サブシステムで駆動される、マージされた Outport ブロックをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportWarningMergedFromNestedCondSubsysSrc">Merge ブロックを駆動しているが、親の条件付き実行サブシステム内に入れ子にされた条件付き実行サブシステムで駆動される Outport ブロックの新しい動作について警告します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportWarningMergedFromNestedCondSubsysSrc">クラシック初期化モードでは、入れ子にされた条件付き実行サブシステムで駆動される Outport ブロックは、それらの親の条件付き実行サブシステムを実行するときでもマージ信号を更新しない場合があります。ただし、簡易初期化モードでは、次の Outport ブロックは親である条件付き実行サブシステムが実行されるときに、駆動する入れ子の条件付き実行サブシステムの最後の出力値でマージ信号を常に更新します。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportWarningMergedFromNestedCondSubsysSrc">Outport ブロックの新しい動作を許容できるかどうかを判断してください。許容できない場合は、簡易初期化モードに移行する前にモデルを変更して新しい動作に対処してください。</entry>
    <entry key="MAMergeBlockCheckHeadingMergeWarningSignalObjectSpecifyingICParam">信号オブジェクトを使用して [初期出力] 値を指定する Merge ブロックをチェック</entry>
    <entry key="MAMergeBlockCheckDescMergeWarningSignalObjectSpecifyingICParam">信号オブジェクトを使用して [初期出力] 値を指定する Merge ブロックの新しい動作に関して警告します。</entry>
    <entry key="MAMergeBlockCheckStatusMergeWarningSignalObjectSpecifyingICParam">簡易初期化モードでは、次の Merge ブロックの [初期出力] パラメーターを信号オブジェクトで指定できなくなりました。信号オブジェクトは、これらの Merge ブロックの出力信号を初期化するためにまだ使用できますが、初期化の結果が、Merge ブロックの信号オブジェクトにより上書きされる可能性があります。</entry>
    <entry key="MAMergeBlockCheckRecActionMergeWarningSignalObjectSpecifyingICParam">新しい動作を許容できるかどうかを判断してください。許容できない場合は、簡易初期化モードに移行する前にモデルを変更して新しい動作に対処してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportWarningUseICFromInputSignal">移行時に入力信号から [初期出力] 値を取得する Outport ブロックをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportWarningUseICFromInputSignal">入力信号から [初期出力] 値を取得できる Outport ブロックの新しい動作について警告します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportWarningUseICFromInputSignal">以下の Outport ブロックの [初期出力] パラメーターは指定されていません ([] に設定)。簡易初期化モードでは、それぞれの Outport ブロックの [初期出力] の値が入力信号から派生することを前提としています。その結果、初期化動作はクラシック初期化モードと異なる可能性があります。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportWarningUseICFromInputSignal">新しい動作を許容できるかどうかを判断してください。許容できない場合は、簡易初期化モードに移行する前にモデルを変更して新しい動作に対処してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportWarningUseScalarZeroAsIC">可変サイズの入力と未指定の [初期出力] をもつ最も内部の Outport ブロックの移行の競合をチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportWarningUseScalarZeroAsIC">可変サイズの入力をもっている最も内部の Outport ブロックに対する [初期出力] 設定の変化について警告します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportWarningUseScalarZeroAsIC">以下の各 Outport ブロックは最も内部の Outport ブロックであり、可変サイズの入力をもちます。そして、親のサブシステムが再度イネーブルになったときにのみ信号サイズが変動します。その結果、[初期出力] パラメーターが未指定 ([]) であっても、Simulink はこのパラメーターが 0 であると暗黙的に仮定します。簡易初期化モードでは、このパラメーターは明示的に 0 に設定されます。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportWarningUseScalarZeroAsIC">簡易初期化モードに移行する前に、[初期出力] を [] 以外の値に明示的に設定するか、0 の設定が許容できることを確認してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportWarningConvertToEmptyHeldIC">明示的な [初期出力] をもつ外部 Outport ブロックをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportWarningConvertToEmptyHeldIC">明示的な [初期出力] をもつ外部の Outport ブロックの新しい設定について警告します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportWarningConvertToEmptyHeldIC">クラシック初期化モードでは、以下の各 Outport ブロックは、対応するソースの Outport ブロックのパラメーターと [初期出力] および [ディセーブル時の出力] パラメーターが同じになっています。その結果、簡易初期化モードでは [初期出力] パラメーターが [] に、[ディセーブル時の出力] パラメーターが [保持] に設定されます。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportWarningConvertToEmptyHeldIC">簡易初期化モードに移行する前に、新しい設定が許容できることを確認してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportWarningUseICFromDialog">明示的な [初期出力] をもつ外部 Outport ブロックをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportWarningUseICFromDialog">明示的な [初期出力] をもつ外部の Outport ブロックの新しい設定について警告します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportWarningUseICFromDialog">クラシック初期化モードでは、以下の各 Outport ブロックは、対応するソースの Outport ブロックのパラメーターと [初期出力] および [ディセーブル時の出力] パラメーターが同じになっています。その結果、簡易初期化モードでは [初期出力] パラメーターが [] に、[ディセーブル時の出力] パラメーターが [保持] に設定されます。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportWarningUseICFromDialog">簡易初期化モードに移行する前に、新しい設定が許容できることを確認してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportDispositionUseICFromDialog">ダイアログで指定されている [初期出力] の値または既定のゼロ値を使用する Outport ブロックの移行の競合のチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportDispositionUseICFromDialog">ライブラリにリンクされ、ダイアログで指定されている [初期出力] の値または既定のゼロ値を使用する Outport ブロックについて、同一の移行パスが存在することを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportDispositionUseICFromDialog">簡易初期化モードでは、次の各 Outport ブロックはダイアログで指定されている [初期出力] の値または既定のゼロ値を使用します。同じライブラリ リンクをもつ Outport ブロックの他のインスタンスは、エラーが含まれるか、別の方法で移行されています。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportDispositionUseICFromDialog">各 Outport ブロックの他のインスタンスに対応する別の移行パスの詳細については、サブチェック &lt;a href="#Simulink:tools:MAOutportCondSubsysCheckHeadingLibraryBlockErrorMigration"&gt;[移行できないインスタンスをもつライブラリ ブロックをチェック]&lt;/a&gt; で結果を調べてください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportDispositionUseICFromInputSignal">入力信号から初期出力値を取得する Outport ブロックの移行の競合のチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportDispositionUseICFromInputSignal">ライブラリにリンクされ、入力信号から初期出力値を取得する Outport ブロックについて、移行パスが同一であることを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportDispositionUseICFromInputSignal">次の各 Outport ブロックは、入力信号から初期出力値を取得します。同じライブラリ リンクをもつ Outport ブロックの他のインスタンスは、エラーが含まれるか、別の方法で移行されています。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportDispositionUseICFromInputSignal">各 Outport ブロックの他のインスタンスに対応する別の移行パスの詳細については、サブチェック &lt;a href="#Simulink:tools:MAOutportCondSubsysCheckHeadingLibraryBlockErrorMigration"&gt;[移行できないインスタンスをもつライブラリ ブロックをチェック]&lt;/a&gt; で結果を調べてください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportDispositionUseDefaultIC">既定のグラウンド値を [初期出力] 値として使用する Outport ブロックの移行の競合をチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportDispositionUseDefaultIC">ライブラリにリンクされた、既定のグラウンド値を [初期出力] 値として使用する Outport ブロックについて同一の移行パスを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportDispositionUseDefaultIC">パラメーター [初期出力] は現在 [] に設定されており Outport のソースは無効な初期条件ソースであるため、簡易初期化モードでは、Outport は既定のグラウンド値を初期出力として使用します。同じライブラリ リンクをもつ Outport ブロックの他のインスタンスは、エラーが含まれるか、別の方法で移行されています。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportDispositionUseDefaultIC">各 Outport ブロックの他のインスタンスに対応する別の移行パスの詳細については、サブチェック &lt;a href="#Simulink:tools:MAOutportCondSubsysCheckHeadingLibraryBlockErrorMigration"&gt;[移行できないインスタンスをもつライブラリ ブロックをチェック]&lt;/a&gt; で結果を調べてください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportDispositionUseEmptyICForMerge">明示的な [初期出力] の指定が無い、マージされた Outport ブロックの移行の競合をチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportDispositionUseEmptyICForMerge">ライブラリにリンクされた、[初期出力] の明示的な指定なしにマージされた Outport ブロックについて同一の移行パスを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportDispositionUseEmptyICForMerge">簡易初期化モードでは、次の各 Outport ブロックの [初期出力] と [ディセーブル時の出力] パラメーターはMerge ブロックを駆動しているため、それぞれ [] と [保持] のままとなります。同じライブラリ リンクをもつ Outport ブロックの他のインスタンスは、エラーが含まれるか、別の方法で移行されています。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportDispositionUseEmptyICForMerge">各 Outport ブロックの他のインスタンスに対応する別の移行パスの詳細については、サブチェック &lt;a href="#Simulink:tools:MAOutportCondSubsysCheckHeadingLibraryBlockErrorMigration"&gt;[移行できないインスタンスをもつライブラリ ブロックをチェック]&lt;/a&gt; で結果を調べてください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportDispositionUseEmptyIC">明示的な [初期出力] の指定が無い Outport ブロックの移行の競合をチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportDispositionUseEmptyIC">ライブラリにリンクされた、[初期出力] の明示的な指定がない Outport ブロックについて同一の移行パスを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportDispositionUseEmptyIC">簡易初期化モードでは、次の各 Outport ブロックの [初期出力] と [ディセーブル時の出力] パラメーターはそれぞれ [] と [保持] のままとなります。同じライブラリ リンクをもつ Outport ブロックの他のインスタンスは、エラーが含まれるか、別の方法で移行されています。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportDispositionUseEmptyIC">各 Outport ブロックの他のインスタンスに対応する別の移行パスの詳細については、サブチェック &lt;a href="#Simulink:tools:MAOutportCondSubsysCheckHeadingLibraryBlockErrorMigration"&gt;[移行できないインスタンスをもつライブラリ ブロックをチェック]&lt;/a&gt; で結果を調べてください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportDispositionUseScalarZeroAsIC">可変サイズの入力と未指定の [初期出力] をもつ最も内部の Outport ブロックの移行の競合をチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportDispositionUseScalarZeroAsIC">可変サイズの入力と未指定の [初期出力] をもち、ライブラリにリンクされた最も内部の Outport ブロックについて同一の移行パスを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportDispositionUseScalarZeroAsIC">以下の各 Outport ブロックは最も内部の Outport ブロックであり、可変サイズの入力をもちます。そして、親のサブシステムが再度イネーブルになったときにのみ信号サイズが変動します。その結果、[初期出力] パラメーターが未指定 ([]) であっても、Simulink はこのパラメーターが 0 であると暗黙的に仮定します。簡易初期化モードでは、このパラメーターは明示的に 0 に設定されます。同じライブラリ リンクをもつ Outport ブロックの他のインスタンスは、エラーが含まれるか、別の方法で移行されています。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportDispositionUseScalarZeroAsIC">各 Outport ブロックの他のインスタンスに対応する別の移行パスの詳細については、サブチェック &lt;a href="#Simulink:tools:MAOutportCondSubsysCheckHeadingLibraryBlockErrorMigration"&gt;[移行できないインスタンスをもつライブラリ ブロックをチェック]&lt;/a&gt; で結果を調べてください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportDispositionUseEmptyICForSimEvents">SimEvents セマンティクスをもつ Outport ブロックの移行の競合をチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportDispositionUseEmptyICForSimEvents">ライブラリにリンクされた、SimEvents の初期化セマンティクスを使用する Outport ブロックについて同一の移行パスを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportDispositionUseEmptyICForSimEvents">簡易初期化モードでは、次の各 Outport ブロックの [初期出力] と [ディセーブル時の出力] パラメーターはそれぞれ [] と [保持] のままとなります。これは、親である条件付き実行サブシステムが SimEvents ブロックに接続しているためです。同じライブラリ リンクをもつ Outport ブロックの他のインスタンスは、エラーが含まれるか、別の方法で移行されています。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportDispositionUseEmptyICForSimEvents">各 Outport ブロックの他のインスタンスに対応する別の移行パスの詳細については、サブチェック &lt;a href="#Simulink:tools:MAOutportCondSubsysCheckHeadingLibraryBlockErrorMigration"&gt;[移行できないインスタンスをもつライブラリ ブロックをチェック]&lt;/a&gt; で結果を調べてください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingSubSystemWarningCondSubsysMovingBlocksIntoContextFromOutputSide">出力範囲全体に実行コンテキストを伝播する、条件付き実行サブシステムをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescSubSystemWarningCondSubsysMovingBlocksIntoContextFromOutputSide">実行コンテキストの伝播に関するサブシステムの新しい動作について警告します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusSubSystemWarningCondSubsysMovingBlocksIntoContextFromOutputSide">[サブシステムの境界全体に実行コンテキストの伝播] オプションが以下のサブシステムに選択されています。しかし、簡易初期化モードの場合、サブシステムの実行コンテキストの伝播は、正常な初期化が確実に行われるよう出力側で無効にされます。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionSubSystemWarningCondSubsysMovingBlocksIntoContextFromOutputSide">簡易初期化モードに移行する前に、サブシステムの新しい動作が許容できることを確認してください。</entry>
    <entry key="MAOutportCondSubsysCheckPropCECAcrossSSBoundary">サブシステムの境界全体に実行コンテキストを伝播</entry>
    <entry key="MADiscreteIntegratorCheckHeadingOverall">Discrete-Time Integrator ブロックの使用をチェック</entry>
    <entry key="MADiscreteIntegratorCheckDescOverall">このチェックは簡易初期化モードへの移行に備えて Discrete-Time Integrator ブロックに関連する問題を検出し、報告します。</entry>
    <entry key="MADiscreteIntegratorCheckStatusOverall">このモデルでは簡易初期化モードを使用していません。</entry>
    <entry key="MADiscreteIntegratorCheckRecActionOverallHasError">モデルを変更して以下の失敗したサブチェックをすべて解決した後、このチェックを再実行してください。</entry>
    <entry key="MADiscreteIntegratorCheckRecActionOverallNoErrorButHasWarning">以下のサブチェック内で報告された警告を確認し、注意が必要なすべての問題に対処してください。</entry>
    <entry key="MADiscreteIntegratorCheckRecActionOverallNoErrorNoWarning">Discrete-Time Integrator ブロックに関連する問題は見つかりませんでした。コンフィギュレーション パラメーターを使用してこのモデルを簡易初期化モードに移行させることができます。</entry>
    <entry key="MADiscreteIntegratorCheckHeadingDiscreteIntegratorWarningOutputICMode">[初期条件設定] パラメーターが [出力] に設定されている Discrete-Time Integrator ブロックをチェック</entry>
    <entry key="MADiscreteIntegratorCheckDescDiscreteIntegratorWarningOutputICMode">Discrete-Time Integrator ブロックを特定し、簡易初期化モードでの変更について警告します。</entry>
    <entry key="MADiscreteIntegratorCheckStatusDiscreteIntegratorWarningOutputICMode">次のブロックは簡易初期化モードでは異なる結果を生成する可能性があります。</entry>
    <entry key="MADiscreteIntegratorCheckRecActionDiscreteIntegratorWarningOutputICMode">簡易初期化モードでの Discrete-Time Integrator の新しい初期化動作についての詳細は、ドキュメンテーションを参照してください。</entry>
    <entry key="MADiscreteIntegratorCheckHeadingDiscreteIntegratorDispositionUseStateICMode">[初期条件設定] パラメーターが [自動] に設定される Discrete-Time Integrator ブロックの移行の競合をチェック</entry>
    <entry key="MADiscreteIntegratorCheckDescDiscreteIntegratorDispositionUseStateICMode">[初期条件設定] パラメーターに [自動] オプションを使用している、ライブラリにリンクされた複数の Discrete-Time Integrator ブロックについて、移行パスが同一であることを確認します</entry>
    <entry key="MADiscreteIntegratorCheckStatusDiscreteIntegratorDispositionUseStateICMode">次の各 Discrete-Time Integrator ブロックは、簡易初期化モードでは [初期条件設定] パラメーターが [自動] のままとなります。同じライブラリ リンクをもつ Discrete-Time Integrator ブロックの他のインスタンスは、エラーが含まれるか、別の方法で移行されています。</entry>
    <entry key="MADiscreteIntegratorCheckRecActionDiscreteIntegratorDispositionUseStateICMode">各 Discrete-Time Integrator ブロックの他のインスタンスに対応する別の移行パスについての詳細は、サブチェック &lt;a href="#Simulink:tools:MAOutportCondSubsysCheckHeadingLibraryBlockErrorMigration"&gt;[移行できないインスタンスをもつライブラリ ブロックをチェック]&lt;/a&gt; で結果を調べてください。</entry>
    <entry key="MADiscreteIntegratorCheckLibraryBlock">ライブラリ ブロック</entry>
    <entry key="MAOutportCondSubsysCheckHeadingAnyBlockWarningCannotReadInputFromNonVirtualSubsysInStart">初期化中に非バーチャル サブシステムから入力を読み込むブロックをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescAnyBlockWarningCannotReadInputFromNonVirtualSubsysInStart">初期化中に非バーチャル サブシステムから入力を読み込むブロックの新しい動作について警告します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusAnyBlockWarningCannotReadInputFromNonVirtualSubsysInStart">以下のブロックは、現在、初期化中に非バーチャル サブシステムから入力を最適化の形式として読み取ります。この最適化は不正確なシミュレーション結果をもたらす可能性があるため、簡易初期化モードではオフになります。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionAnyBlockWarningCannotReadInputFromNonVirtualSubsysInStart">簡易初期化モードに移行する前に、新しい動作が許容できることを確認してください。</entry>
    <entry key="MADiscreteIntegratorCheckHeadingAnyBlockErrorUseElapsedTimeInIterSubsys">経過時間を必要とする Iterator Subsystem 内のブロックをチェック</entry>
    <entry key="MADiscreteIntegratorCheckDescAnyBlockErrorUseElapsedTimeInIterSubsys">Iterator Subsystem 内で経過時間を必要とするブロックが使用されていないことを確認します。</entry>
    <entry key="MADiscreteIntegratorCheckStatusAnyBlockErrorUseElapsedTimeInIterSubsys">次のブロックは、2 つの連続した実行間での経過時間を管理するサービスを必要とするため、簡易初期化モードの Iterator Subsystem の階層内では許可されません。</entry>
    <entry key="MADiscreteIntegratorCheckRecActionAnyBlockErrorUseElapsedTimeInIterSubsys">予期しない動作を回避するために、Iterator Subsystem 内でそのようなブロックを使用しないでください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingLibraryBlockErrorMigration">移行できないインスタンスをもつライブラリ ブロックをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescLibraryBlockErrorMigration">モデル内の、ライブラリにリンクされたブロックのすべてのインスタンスが簡易初期化モードに安全に移行できることを確認します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusLibraryBlockErrorMigration">次のライブラリ ブロックには、簡易初期化モードに移行できないインスタンスが少なくとも 1 つあるか、または異なる移行パスをもつインスタンスが少なくとも 2 つあります。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionLibraryBlockErrorMigration">これらのブロックごとに、適切な改善策を判断するためにインスタンスに関するサブチェックの結果を検証してください。</entry>
    <entry key="MAOutportCondSubsysCheckHeadingLibraryBlockWarningMigration">警告をもつインスタンスがあるライブラリ ブロックをチェック</entry>
    <entry key="MAOutportCondSubsysCheckDescLibraryBlockWarningMigration">警告をもつインスタンスがあるライブラリ ブロックを特定します。</entry>
    <entry key="MAOutportCondSubsysCheckStatusLibraryBlockWarningMigration">以下の各ライブラリ ブロックには、サブチェックの警告をもつインスタンスが少なくとも 1 つあります。</entry>
    <entry key="MAOutportCondSubsysCheckRecActionLibraryBlockWarningMigration">すべての警告を許容できるかどうかを判断してください。警告を許容できない場合は、簡易初期化モードに移行する前に警告に従ってモデルを変更してください。</entry>
    <entry key="MAOutportCondSubsysCheckActionButtonName">設定の変更</entry>
    <entry key="MAOutportCondSubsysCheckActionDescription">簡易初期化モードとの互換性のために、Outport ブロックと条件付きサブシステムのすべての設定を移行します。</entry>
    <entry key="MADiscreteIntegratorCheckActionButtonName">設定の変更</entry>
    <entry key="MADiscreteIntegratorCheckActionDescription">簡易初期化モードとの互換性のために、Discrete-Time Integrator ブロックの設定を変更します。</entry>
    <entry key="MASimplifiedModeCheckActionButtonName">設定の変更</entry>
    <entry key="MASimplifiedModeCheckActionDescription">すべてのモデル設定を簡易初期化モードに移行します。その結果、[コンフィギュレーション パラメーター] ダイアログで [指定不足の初期化の検出] オプションが [簡易] に設定されます。作業を進める前に、モデルとすべての関連するライブラリ ファイルが書き込み可能で、未保存の変更がないことを確認してください。</entry>
    <entry key="MATitleReplaceZOHDelayByRTB">レート変換の実行用に Delay ブロック、Unit Delay ブロックおよび Zero-Order Hold ブロックをチェック</entry>
    <entry key="MATitletipReplaceZOHDelayByRTB">モデル内でレート変換を実行する Delay ブロック、Unit Delay ブロックおよび Zero-Order Hold ブロックを特定します。これらを Rate Transition ブロックに置き換えてください。</entry>
    <entry key="MAMsgReplaceZOHDelayByRTBWarn">&lt;p /&gt; 次の Delay ブロック、Unit Delay ブロックや Zero-Order Hold ブロックは、入力信号と出力信号間のレート変換として動作します。これらのブロックは、非表示の Rate Transition ブロックに置き換えられました。 </entry>
    <entry key="MAMsgReplaceZOHDelayByRTBSuggest">&lt;p /&gt; パフォーマンスの信頼性を高めるには、これらのブロックを実際の Rate Transition ブロックに置き換えます。[モデルのアップグレード] をクリックしてモデルを保存してください。 </entry>
    <entry key="MANonReplaceZOHDelayByRTBPass"> モデルには、レート変換を実行する Delay ブロック、Unit Delay ブロック、または Zero-Order Hold ブロックが含まれていません。</entry>
    <entry key="MAReplaceZOHDelayByRTBActionButtonName">モデルのアップグレード</entry>
    <entry key="MAReplaceZOHDelayByRTBActionDescription">Delay ブロック、Unit Delay ブロックおよび Zero-Order Hold ブロックを Rate Transition ブロックに置き換えるには、ここをクリックしてください。この操作によりモデルが再コンパイルされます。コンパイル後に、モデルを保存して変更内容を永続的に反映してください。</entry>
    <entry key="MAReplaceZOHDelayByRTBActionResults">次のブロックは Rate Transition ブロックに置き換えられました。変更を保持するには、モデルを保存してください。</entry>
    <entry key="MAReplaceZOHDelayByRTBUnexpectedError">ブロック置換中に予期しないエラーが発生しました: {0}</entry>
    <entry key="OutportMigrateTitle">Outport の設定を移行</entry>
    <entry key="OutportMigrateConfirmQuestion">これらの変更を元に戻すのは難しいため、引き続き操作を行う前にモデルとライブラリのバックアップ コピーを保存してください。モデル ''{0}'' を簡易初期化モードに移行しますか?</entry>
    <entry key="OutportMigrateUnexpectedError">モデルの移行中に予期しないエラーが発生しました: {0}</entry>
    <entry key="OutportMigrateRunning">モデル アドバイザーは、モデル ''{0}'' 内のブロックの設定を簡易初期化モードに対応するように移行しています。</entry>
    <entry key="SimplifiedModeMigrateRunning">モデル アドバイザーは、モデル ''{0}'' 内のブロックの設定を簡易初期化モードに対応するように移行しています。</entry>
    <entry key="OutportMigrateCompleted">ブロックの移行が完了しました。</entry>
    <entry key="SimplifiedModeMigrateCompleted">ブロックの移行が完了しました。</entry>
    <entry key="OutportMigrateCancelled">モデルの簡易初期化への移行がユーザーによりキャンセルされたか、または失敗しました。</entry>
    <entry key="OutportMigrateNotNeeded">モデル ''{0}'' は既に移行が完了しているため、ブロックの移行は必要ありません。</entry>
    <entry key="MADataStoreCheckActionButtonName">続行</entry>
    <entry key="MADataStoreCheckActionDescription">データ ストア メモリが推奨される最良の方法に適合するかどうかをチェックします。操作を行う前に、上記で報告されたすべての警告を理解しているか、または、対処しているか確認してください。</entry>
    <entry key="slDebuguiRequiresJava">Simulink デバッガーは Java がサポートされていることが必要です</entry>
    <entry key="viewLinkDataRequiresJava">リンク データ ダイアログは、Java がサポートされていることが必要です。代わりに、''LinkData'' プロパティの set_param/get_param を使用してください。</entry>
    <entry key="slDebuguiInUse">Simulink デバッガー ''{0}'' が使用されています。\n''{1}'' のデバッグを行うには、現在のデバッガーを終了してください。</entry>
    <entry key="slDebugCurrentBlockIsEmpty">モデル ''{0}'' 内で選択されたブロックがありません。</entry>
    <entry key="slDebugCurrentBlockNotInModel">ブロック ''{0}'' 上にブレークポイントを設定できません。デバッグされているモデル ''{1}'' 内にないためです。</entry>
    <entry key="slDebugBreakpointSetOnVirtualBlock">選択したブロック ''{0}'' はバーチャルなブロックです。ブレークポイントを設定するには、非バーチャル ブロックを選択しなければなりません。モデル ''{1}'' 内の非バーチャルなブロックのリストについては、デバッガーのソートされたリスト ペイン、または SLIST コマンドの出力を参照してください。</entry>
    <entry key="NoSLDebugWithTLCDebug">Simulink デバッガーは、TLC デバッガーの実行中に無効になっています。</entry>
    <entry key="NoTLCDebugWithSLDebug">TLC デバッガーは、Simulink デバッガーを開いている間に無効になっています。</entry>
    <entry key="LUTEditorNoUndefinedExpressions">パラメーター ''{0}'' (ブロック ''{1}'' 内) の実行中にエラーが発生しました。\n このパラメーターが変数名を指定している場合、ワークスペース内に変数が定義されているか確認してください。\n そうでない場合、このパラメーターが対応するブレークポイントのベクトルと同じ次元のデータを指定することを確認してください。</entry>
    <entry key="PosRealCheck">正の実数、または z = 0 の近傍のいずれかの極を持つハイブリッド システムの線形化は dlinmod でサポートされません。これは Simulink Control Design のコマンドの線形化でサポートされます。</entry>
    <entry key="ImplicitSignalResolutionAlreadyDisabled">モデル ''{0}'' では、信号オブジェクトの暗黙的な関連付けが既に無効になっています。</entry>
    <entry key="TurnOnResolutionForSignals">以下の信号ラベルは、信号オブジェクトに強制的に関連付けられます。</entry>
    <entry key="TurnOnResolutionForStates">以下の状態は、信号オブジェクトに強制的に関連付けられます。</entry>
    <entry key="CannotDisableImplicitSignalResolution">このモデルはコンフィギュレーション参照を使用しているため、SignalResolutionControl を ''UseLocalSettings'' に変更できません。信号オブジェクトの暗黙的な関連付けを無効にするには、ソース コンフィギュレーション セット ''{0}'' でこのパラメーターを手動で変更します。</entry>
    <entry key="RenameStateflowOutputSignal">信号ラベルを ''{0}'' から ''{1}'' に Stateflow チャート ''{2}'' の出力に対して変更しています。</entry>
    <entry key="ExpectedOneStateflowOutputWithSignalName">信号と同じ名前を持つ 1 つの Outport ブロックを見つける必要があります。</entry>
    <entry key="dlinmodUseZeroTs">LINMOD モードで強制的にサンプル時間を 0 にします。</entry>
    <entry key="dlinmodReturningTransferFunction">伝達関数モデルを返します</entry>
    <entry key="dlinmodUnrecognizedOption">認識されないオプションです。詳細は HELP DLINMOD を参照してください。</entry>
    <entry key="dlinmodNoV5Sparse">スパース行列は ''v5'' オプションでサポートされていません。</entry>
    <entry key="dlinmodNoV5AnalysisPorts">解析の端子は ''v5'' オプションでサポートされていません。</entry>
    <entry key="dlinmodMultiTaskingSolver">モデルを線形化する場合、モデルはシングルタスクの固定ステップ、または可変ステップ ソルバーを使用しなければなりません。</entry>
    <entry key="dlinmodWrongInputVectorSize">長さ {0,number,integer} の入力ベクトルが必要です。</entry>
    <entry key="dlinmodExtraStatesZero">余分な状態は 0 に設定されています。</entry>
    <entry key="dlinmodIgnoreDiscreteStates">離散状態を無視しています (適切に取り扱うには DLINMOD を使用してください)</entry>
    <entry key="dlinmodNoSampleTimeFoundUseFixedStepSize">モデル内にサンプル時間がありません。既定の設定を固定ステップ サイズにします。</entry>
    <entry key="dlinmodNoSampleTimeFound">モデル内にサンプル時間がありません。既定の設定を 1 にします。</entry>
    <entry key="dlinmodv5RequireStateStruct">Model ブロックをもつモデルは、線形化を初期化するために状態の構造体を使用しなければなりません。</entry>
    <entry key="dlinmodv5StateStructXPert">モデルの状態に対して構造体形式を使用する場合、変数 XPERT は構造体として指定されなければなりません。</entry>
    <entry key="linmodNotSupportedMultipleModelReference">モデル {0} は、ノーマル モードのモデル リファレンスとアクセラレータ モードのモデル リファレンスとして使用されています。これは、線形解析ツールでは現在サポートされていません。ノーマル モードの参照の単一のインスタンスのみを使用してください。</entry>
    <entry key="trimModelMustHaveOneState">平衡化するために、システムは少なくとも 1 つの状態がなければなりません。</entry>
    <entry key="trimNotSupportedModelReference">Model ブロックを持つモデルは、コマンド trim でサポートされません。</entry>
    <entry key="trimSupportContinuousDerivatives">コマンド [X,U,Y,DX]=TRIM(''SYS'',X0,U0,Y0,IX,IU,IY,DX0,IDX) では、DX0 の長さは、Simulink モデルの連続状態の数と同じでなければなりません。</entry>
    <entry key="slbusInvalidNumInputs">入力数が無効です。</entry>
    <entry key="slbusInvalidScope">scope 引数が無効です。scope の有効な値は、Simulink.data.BaseWorkspace オブジェクトまたは Simulink.data.DataDictionary オブジェクトです。</entry>
    <entry key="slbusObjectToCellInvalidInput">入力はバス名を含むセル配列でなければなりません。</entry>
    <entry key="slbusNotPreserveAdditionalProps">追加プロパティは ''{0}'' のサブクラスには保存されません。</entry>
    <entry key="slbusSaveInvalidFirstArg">入力引数が無効です。1 番目と 2 番目の入力引数は文字ベクトルでなければなりません。</entry>
    <entry key="slbusSaveInvalidExt">ファイル名が無効です。ファイル名は、''.m'' の拡張子を持つか、または拡張子を持たないものでなければなりません。</entry>
    <entry key="slbusSaveFileAlreadyExists">ファイル ''{0}'' は存在します。新規ファイル名を指定する、またはファイル ''{1}'' を削除し、コマンドを再実行してください。</entry>
    <entry key="slbusSaveDirDoesNotExist">指定したディレクトリが存在しません。</entry>
    <entry key="slbusSaveInvalidSecondArg">2 番目の入力は、''cell'' または ''object'' でなければなりません。</entry>
    <entry key="slbusSaveInvalidThirdArg">3 番目の入力はバス名を含むセルでなければなりません。</entry>
    <entry key="slconnectionBusSaveInvalidSecondArg">Second input must be a cell array of connection bus names.</entry>
    <entry key="slbusSaveFileOpenError">バス オブジェクトの保存用にファイル ''{0}'' を開くことができません。実際のエラー: ''{1}''.</entry>
    <entry key="slbusCreateObjectInvalidModelName">モデル名が無効です。</entry>
    <entry key="slbusCreateObjectBadSimulationStatus">モデル ''{0}'' のシミュレーション状態は ''{1}'' です。これはモデルが実行中であることを示しています。\n シミュレーションを停止し、Simulink.Bus.createObject を再実行してください。</entry>
    <entry key="slbusCreateObjectGeneric">入力構造体のフィールド ''{0}'' を処理中に Simulink.Bus.createObject から次のエラーが報告されました。\n''{1}''</entry>
    <entry key="slbusCreateObjectNonNumericStructField">構造体フィールド ''{0}'' に数値、論理値、MATLAB 時系列値がありません。</entry>
    <entry key="slbusCreateObjectNonVectorStringStructField">構造体フィールド ''{0}'' が string スカラーまたは 1 次元文字配列をもっていません。</entry>
    <entry key="slbusCreateObjectOrderMismatch">入力構造体の次の位置でフィールドの数または順序付けが一致していません。''{0}'' および ''{1}''。Simulink.Bus.createObject では、下位の構造体の配列のすべての要素が互いに整合している必要があります。</entry>
    <entry key="slbusCreateObjectStructNonStructMismatch">''{0}'' は構造体のフィールドですが、''{1}'' は構造体のフィールドではありません。Simulink.Bus.createObject では、下位の構造体の配列ですべての要素が互いに整合している必要があります。</entry>
    <entry key="slbusCreateObjectDimsMismatch">入力構造体の次の位置でフィールドの次元が一致しません。''{0}'' および ''{1}''。Simulink.Bus.createObject では、下位の構造体の配列ですべての要素が互いに整合している必要があります。</entry>
    <entry key="slbusCreateObjectDataTypeMismatch">入力構造体の次の位置でフィールドのデータ型が一致しません。''{0}'' および ''{1}''。Simulink.Bus.createObject では、下位の構造体の配列ですべての要素が互いに整合している必要があります。</entry>
    <entry key="slbusCreateObjectComplexityMismatch">入力構造体の次の位置でフィールドの実数/複素数が一致しません。''{0}'' および ''{1}''。Simulink.Bus.createObject では、下位の構造体の配列ですべての要素が互いに整合している必要があります。</entry>
    <entry key="slbusCreateObjectMultiColumnTimetable">timetable オブジェクトがもつ変数は 1 つでなければなりません。</entry>
    <entry key="slbusCreateObjectMultiChannelDatastore">matlab.io.datastore.MDFDatastore オブジェクトは 1 つを超えるチャネルを読み込むように構成できません。</entry>
    <entry key="slbusCreateObjectInvalidPortElement">端子 ''{1}'' の要素 ''{0}'' 用には Simulink.Bus を作成できません。</entry>
    <entry key="slcreateMATLABStructInvalidFirstArgument">最初の入力は、有効なバス オブジェクト名か、ブロック端子への 1 つ以上の (すなわち配列の) 有効なハンドルでなければなりません。</entry>
    <entry key="slcreateMATLABStructInvalidDimension">最初の引数がバス オブジェクト名である場合、有効な次元 D=[d_1, ..., d_n] を 3 番目の入力パラメーターとして与えることができます。この次元の値は、結果として生じる構造体の次元を決定します。2 番目の入力パラメーターに部分構造体を使用する場合、部分構造体の次元 P=[p_1, ..., p_m] は、D に対して互換性をもたなければなりません (つまり、1&lt;=i&lt;=m に対して m &lt;= n かつ p_i &lt;= d_i)。最初の引数がバス オブジェクト名のセル配列である場合、有効な次元のセル配列を指定することもできます。最初の引数がバス オブジェクト名でない場合は次元を与えることはできません。</entry>
    <entry key="slcreateMATLABStructInvalidPartialStruct">最初の引数がバス オブジェクト名またはブロック端子への有効なハンドルである場合、2 番目の入力は MATLAB 構造体または空 ([]) でなければなりません。この構造体のフィールドで指定された値は、結果的に完全な MATLAB 構造体内の対応するフィールドに入力されます。最初の引数がブロック端子のハンドルの配列またはバス オブジェクト名のセル配列の場合、2 番目の引数は、MATLAB 構造体のセル配列でなければなりません。</entry>
    <entry key="slcreateMATLABStructInvalidNumSecondArguments">端子ハンドルの数は指定された部分構造体の数と同じでなければなりません。</entry>
    <entry key="slcreateMATLABStructStrictBusRequired">このユーティリティ関数では、[コンフィギュレーション パラメーター] ダイアログ ボックスの [接続性] パネルの [Mux ブロックをバス信号の作成に使用] の診断を ''エラー'' に設定しなければなりません</entry>
    <entry key="slcreateMATLABStructBadFieldInPartialStructure">部分構造体は一貫しない形を持っており、''{0}'' で生成された構造体とは異なります</entry>
    <entry key="slcreateMATLABStructInconsistentDimensionInPartialStructure">部分構造体の次元が ''{0}'' のバス オブジェクト ノードの次元と一致していません。</entry>
    <entry key="slcreateMATLABStructBadFieldAttributeDimensions">{0}'' で部分構造体に提供された値は次元 ''{1}'' ですが、生成された構造体内にある対応する値は次元 ''{2}'' です</entry>
    <entry key="slcreateMATLABStructBadFieldAttributeDataType">部分構造体のフィールド ''{0}'' に指定された値のデータ型は ''{1}'' ですが、Simulink.Bus.createMATLABStruct ではこのフィールドのデータ型に ''{2}'' の値を必要とします。このフィールドに指定された値を ''{2}'' にキャストすることは、桁落ちを引き起こすか、あるいはサポートされていません。</entry>
    <entry key="slcreateMATLABStructBadFieldAttributeDataTypeConversion">部分構造体のフィールド ''{0}'' に指定された値のデータ型は ''{1}'' ですが、Simulink.Bus.createMATLABStruct ではこのフィールドのデータ型に ''{2}'' の値を必要とします。このフィールドに指定された値は ''{2}'' にキャストされます。</entry>
    <entry key="slcreateMATLABStructBadFieldAttributeComplexity">{0}'' で部分構造体に提供された値は ''{1}'' ですが、生成された構造体内にある対応する値は ''{2}'' です</entry>
    <entry key="slcreateMATLABStructFromBusObject">Simulink.Bus.createMATLABStruct は、一時的なモデル ''TmpModelForCreatingMATLABStruct'' を使用して MATLAB 構造体を作成します。構造体の作成中にエラーが発生しました。以下の原因を確認してください:</entry>
    <entry key="MATitletipCheckForProperFcnCallRetVals">Simulink で暗黙的に Signal Conversion ブロックを挿入するため、潜在的に遅れる可能性のある Function-Call ブロックの戻り値を特定</entry>
    <entry key="MATitleCheckForProperFcnCallRetVals">潜在的に遅れる Function-Call ブロックの戻り値をチェック</entry>
    <entry key="MABlkPortPairListItem">ブロックの入力端子 ({0}):</entry>
    <entry key="MAMsgHiddenBufCausingLoop">Simulink は、対応する信号がメモリ内で連続であることを保証するために、次の関数呼び出し開始プログラムのブロックの入力端子の前に、暗に Signal Conversion ブロックを挿入しました。これは、呼び出されている Function-Call Subsystem からの戻り値としてこれらの信号を観測する可能性のある関数呼び出し開始プログラムのブロックに対して 1 ステップ遅れる可能性があります。遅延を避けるために、リストされた入力端子の信号が呼び出される Function-Call Subsystem 内の信号ブロックから発生するようにしてください。遅れてもよい場合、影響する入力端子の前に Unit Delay ブロックを挿入してください。</entry>
    <entry key="MATitleIdentSigsWithContTsAndNonFloatDataType">連続サンプル時間と浮動小数点でないデータ型をもつブロックの出力信号を特定</entry>
    <entry key="MAUnableToRunCheckForProperBusOnSubsystem">''バスの使用方法'' のチェックは、最上位のモデルからのみ機能します。このチェックを実行するには、最上位のモデルからアドバイザーを実行してください。</entry>
    <entry key="MATitleCheckDisabledLinks">無効なライブラリ リンクを特定</entry>
    <entry key="MATitletipCheckDisabledLinks">無効なライブラリ リンクに対するモデルを検索します。ライブラリ リンクを無効にすると予期せぬシミュレーション結果になる可能性があるので、一般的にモデルは無効のライブラリ リンクで保存すべきではありません。このチェックの結果は既知のアップグレード問題に対するチェックの結果と重複する可能性があることに注意してください。</entry>
    <entry key="MAResultCheckDisabledLinks">下記にリストされたブロックはライブラリ リンクが無効になっています。リンクを解決するには、Simulink ブロック線図でブロックを右クリックし、''{1}'' メニューから ''{0}'' を選択します。</entry>
    <entry key="MATitleCheckParameterizedLinks">パラメーター付きのライブラリ リンクを特定</entry>
    <entry key="MATitletipCheckParameterizedLinks">パラメーター付きのライブラリ リンクに対するモデルを検索します。パラメーター付きのライブラリ リンクは、予期せぬシミュレーション結果を生ずる可能性があります。</entry>
    <entry key="MAResultCheckParameterizedLinks">次のブロックはパラメーター付きのライブラリ リンクです。Simulink ブロック線図内のブロックを右クリックして [ライブラリ リンク] メニューから適切な項目を選択することで、変更をライブラリに伝播または破棄することが可能です。</entry>
    <entry key="MAResultWeaklyTypedDataStores">以下のブロックは、それらのデータ型または信号タイプを継承する Data Store Memory ブロックです。データ ストア メモリを入力する場合、予期せぬデータ型または信号タイプの伝播を回避できます。データ ストア メモリは、このブロックにより、または、厳密に型指定された Simulink.Signal オブジェクトの型に関連付けられることで厳密に型指定される可能性があります。</entry>
    <entry key="MATitleCheckUnresolvedLinks">未解決のライブラリ リンクを特定</entry>
    <entry key="MATitletipCheckUnresolvedLinks">未解決のライブラリ リンクに対するモデル (ライブラリ ブロックが見つからないモデル) を検索します。モデルは未解決のリンクがある間はシミュレーションできません。</entry>
    <entry key="MAResultCheckUnresolvedLinks">次のブロックは未解決のライブラリ リンクです。ライブラリが見つからない、またはライブラリが指定した名前のブロックを含んでいないかのどちらかです。</entry>
    <entry key="MALibLinksTaskTitle">ライブラリ リンクとバリアントの管理</entry>
    <entry key="MALibLinksTaskTitleTips">ライブラリ リンクおよびバリアントの一般的な問題を特定するためにチェックします。</entry>
    <entry key="MATitleCheckVariantOverride">バリアントの選択をオーバーライドするバリアント ブロックの特定</entry>
    <entry key="MATitletipCheckVariantOverride">アクティブなバリアント制御ではなくオーバーライド オプションを使用して、バリアントの選択を指定するバリアント ブロックを特定します。</entry>
    <entry key="MAResultCheckVariantOverride"> 次のブロックでは、OverrideUsingVariant パラメーターを使用してバリアントの選択を指定します。</entry>
    <entry key="MASubResultStatusVariantOverride">バリアント制御を使用してアクティブなバリアントを特定します。</entry>
    <entry key="MAVariantOverrideCheckPassed">バリアントの選択をオーバーライドするバリアント ブロックが見つかりません。</entry>
    <entry key="VariantBlocks">ブロック</entry>
    <entry key="CurrentOverrideSetting">値のオーバーライド</entry>
    <entry key="MAColTitle1ConvertMdlrefVarToVSS">ブロック名</entry>
    <entry key="MAColTitle2ConvertMdlrefVarToVSS">結果</entry>
    <entry key="MAColResultSuccessConvertMdlrefVarToVSS">変換済み</entry>
    <entry key="MATitleIdentConfigSubsys">Variant Subsystem ブロックに変換するために、モデル内の Configurable Subsystem ブロックを特定します。</entry>
    <entry key="MATitletipIdentConfigSubsys">モデル レベルまたはサブシステム レベルにある Configurable Subsystem ブロックを特定し、アップグレードします。Variant Subsystem は、同等の機能を維持しながら、拡張機能を提供します。ブロックのコンテナーとしての Configurable Subsystem は、将来のリリースで削除される予定です。 </entry>
    <entry key="MAConfigSubsysAction">すべて変換</entry>
    <entry key="MAConfigSubsysActionDescription">特定された Configurable Subsystem テンプレート ブロックを Variant Subsystem ブロックに変換します。</entry>
    <entry key="MADescriptionConfigSubsys">モデル レベルまたはサブシステム レベルにある Configurable Subsystem ブロックを特定し、アップグレードします。</entry>
    <entry key="MADescriptionConfigSubsysByModelDisc">モデルまたはサブシステムのレベルで、モデルの離散化により作成された Configurable Subsystem のインスタンスを特定し、更新します。</entry>
    <entry key="MATitleConvertMdlrefVarToVSS">Model Variants ブロックを特定し、Model ブロックの選択肢を含む Variant Subsystem ブロックに変換します</entry>
    <entry key="MATitletipConvertMdlrefVarToVSS">Model Variants ブロックを Model ブロックの選択肢を含む Variant Subsystem ブロックにアップグレードします。バリアント サブシステムは、同等の機能を維持しながら、拡張機能を提供します。バリアント モデルのコンテナーとしての Model ブロックは、将来のリリースで削除される予定です。</entry>
    <entry key="MADescriptionConvertMdlrefVarToVSS">Model Variants ブロックをモデル レベルで特定します。</entry>
    <entry key="MAConvertMdlrefVarToVSSCheckActionButtonName">変換</entry>
    <entry key="MAConvertMdlrefVarToVSSCheckActionButtonDescription">Model Variants ブロックを、Model ブロックの選択肢を含むバリアント サブシステムに変換します。</entry>
    <entry key="MAResultCheckForCSSTempBlocks">モデル内に以下の Configurable Subsystem テンプレート ブロックが見つかりました。</entry>
    <entry key="MAResultCheckForCSSBlocks">モデル内に以下の Configurable Subsystem ブロックが見つかりました。</entry>
    <entry key="MAResultInfoOnParameterizedCSSInstances">Configurable Subsystem ブロックの変換時にパラメーター化されたデータが失われないように、Configurable Subsystem のパラメーター付きのすべてのリンク ブロックを更新しなければなりません。モデル アドバイザーの [パラメーター付きのライブラリ リンクを特定] チェックを使用して、Configurable Subsystem のパラメーター付きリンクを使用しているすべてのモデルを更新してください。
</entry>
    <entry key="MAResultCheckStatusPass">正常に変換:''{0}''</entry>
    <entry key="MAResultCheckStatusFail">変換に失敗:''{0}''</entry>
    <entry key="MAResultCheckStatusTitle">変換ステータス:</entry>
    <entry key="MAResultCheckForCSSBlocksByModelDisc">モデルの離散化により作成された次の Configurable Subsystem のインスタンスがモデル内に見つかりました。</entry>
    <entry key="MAResultCheckForConvertMdlrefVarToVSS">次の Model Variants ブロックが見つかりました</entry>
    <entry key="MAResultCheckForConvertMdlrefVarToVSSPass">Model Variants ブロックが見つかりませんでした。</entry>
    <entry key="MAResultActionForConvertMdlrefVarToVSSWarn">一部の Model Variants ブロックを、Model ブロックを選択肢としてもつ Variant Subsystem ブロックに変換できません。次の手順を実行してこれらを Variant Subsystem ブロックに変換します。1) Variant Subsystem ブロックを追加する。vssHandle = add_block('simulink/Ports &amp; Subsystems/Variant Subsystem', 'Model/VariantSubsystem', 'MakeNameUnique', 'on') など。2) Model Variants ブロックで参照されるすべての Model ブロックのパラメーターを取得する。varParams = get_param('Model/ModelVariantsBlock', 'Variants') など。3) Variant Subsystem ブロックに Model ブロックを選択肢として追加する。たとえば、このコマンド choiceHandle = add_block('Model/ModelVariantsBlock', ['Model/VariantSubsystem/', varParams.ModelName(1)] を使用して 1 つの選択肢を追加する。4) 必須パラメーターを元の Model Variants ブロックから設定する。パラメーター 'Name'、'ModelName'、'ParameterArgumentValues'、および 'Simulation mode' に set_param(choiceHandle, parameter, value) を使用する。</entry>
    <entry key="MAResultActionForConvertMdlrefVarToVSSPass">すべての Model Variants ブロックが Model ブロックの選択肢を含む Variant Subsystem ブロックに正常に変換されました。</entry>
    <entry key="MASubResultStatusForCSSBlocks">&lt;p&gt;&lt;b&gt;[モデル階層を解析してアップグレード シーケンスを続行]&lt;/b&gt; チェックを実行し、Configurable Subsystem テンプレート ブロックを変換して、リストされている Configurable Subsystem ブロックを更新します。&lt;/p&gt; </entry>
    <entry key="MASubResultStatusForCSSBlocksByModelDisc">&lt;p&gt;離散化に関する情報を保持するには、リストに提示された Configurable Subsystem の各インスタンスを右クリックし、[サブシステムとモデル参照] &gt; [変換] &gt; [Variant Subsystem] を選択して、それらを Variant Subsystem に変換します。&lt;/p&gt; </entry>
    <entry key="MACheckForCSSPassed">Configurable Subsystem ブロックが見つかりません。</entry>
    <entry key="ParserConfigUnknownLang">言語 ''{0}'' が認識されません。</entry>
    <entry key="LCTErrorInvalidAction">無効なアクション ''{0}''</entry>
    <entry key="LCTErrorFirstFcnArgumentMustBeStruct">1 番目の引数は、legacy_code(''initialize'') で初期化された構造体 (または構造体配列) でなければなりません</entry>
    <entry key="LCTErrorSecondFcnArgumentMustBeStruct">2 番目の引数は、legacy_code(''initialize'') で初期化された構造体 (または構造体配列) でなければなりません</entry>
    <entry key="LCTErrorFirstFcnArgumentMustBeScalarStruct">1 番目の引数は legacy_code(''initialize'') で初期化された 1 x 1 の構造体でなければなりません</entry>
    <entry key="LCTErrorCannotOpenFile">ファイル "{0}.{1}" {2} を開けられません</entry>
    <entry key="LCTErrorCannotFindIncludePath">インクルード パス "{0}" が見つかりません</entry>
    <entry key="LCTErrorCannotFindSourcePath">ソース パス "{0}" が見つかりません</entry>
    <entry key="LCTErrorCannotFindLibraryPath">ライブラリ パス "{0}" が見つかりません</entry>
    <entry key="LCTErrorCannotFindSourceFile">ソース ファイル "{0}" が見つかりません</entry>
    <entry key="LCTErrorCannotFindLibraryFile">ライブラリ ファイル "{0}" が見つかりません</entry>
    <entry key="LCTErrorBadSimulinkVersion">Simulink のバージョン "{0}" はサポートされません</entry>
    <entry key="LCTWarnFileConflict">ファイル "{0}" は既に存在し、CMEX ファイルではありません。このファイルを別のディレクトリに移すか、名前を変えなければなりません。あるいは SFunctionName を別にしなければなりません</entry>
    <entry key="LCTErrorBadArgumentOptionForCompilation">2 番目の引数 OPT は文字ベクトルか、文字ベクトルのセル配列でなければなりません</entry>
    <entry key="LCTErrorMexNotConfigured">C コンパイラは、''compile'' オプションで legacy_code() を呼び出す前に、設定しなければなりません。MATLAB コマンド ウィンドウで mex(''-setup'') と入力してください</entry>
    <entry key="LCTMsgStartCompiling">{0} のコンパイルを開始</entry>
    <entry key="LCTMsgFinishCompiling">{0} のコンパイル終了</entry>
    <entry key="LCTMsgEndCompiling">終了</entry>
    <entry key="LCTBlkMaskDescription">このブロックは、以下の Legacy Code Tool の定義で指定されたレガシ関数を呼び出すことができます:\n{0}</entry>
    <entry key="LCTBlkMaskHelp">このブロックは、Legacy Code Tool で自動的に生成されました。このツールと呼び出しの詳細は、ヘルプを参照してください。</entry>
    <entry key="LCTBlkMaskSampleTimeParam">サンプル時間 (継承は -1)</entry>
    <entry key="LCTBlkMaskShowFcnSpecParam">表示関数の仕様</entry>
    <entry key="LCTErrorSLObjectNotFound">データ型 "{0}" は組み込みデータ型でもなく、Simulink.AliasType、Simulink.NumericType、Simulink.Bus オブジェクトまたは列挙型データによっても定義されていません</entry>
    <entry key="LCTErrorSLObjectHeaderFile">Simulink データ オブジェクト "{0}" (クラス {1}) にはヘッダー ファイルが必要です</entry>
    <entry key="LCTErrorEnumTypeMustSpecifyHeaderFile">列挙データ型 "{0}" にはヘッダー ファイルが必要です</entry>
    <entry key="LCTErrorAddClassNameToEnumNamesNotSupported">列挙型のデータ型 "{0}" を設定してクラス名を列挙型の値に追加することはできません</entry>
    <entry key="LCTErrorBusElementEmpty">Bus/StructType オブジェクト "{0}" は、少なくとも 1 つの Bus/StructType 要素を含まなければなりません。</entry>
    <entry key="LCTErrorBusElementBoolComplex">Bus/StructType 要素 "{0}" (Bus/StructType オブジェクト "{1}") はネイティブな複素数データ型のみ使用することが可能です。boolean の複素数データ型はサポートされません</entry>
    <entry key="LCTErrorBusElementNonScalar">バス要素 "{0}" (バス オブジェクト "{1}") は、スカラーでなければなりません</entry>
    <entry key="LCTErrorBusElementBadDim">(バス オブジェクト "{1}" の) バス要素 "{0}" の次元は有効な数値でなければなりません。</entry>
    <entry key="LCTErrorUnspecifiedScaling">未設定のスケーリングを持つ Simulink.NumericType はサポートされません ("{0}")</entry>
    <entry key="LCTErrorBadDimToTest">テストのための不正な次元</entry>
    <entry key="LCTErrorParseBadAssignement">関数の仕様 "{0}" 内の引数に誤りがあります。関数からの戻り値は、出力端子の値にのみ割り当てなければなりません</entry>
    <entry key="LCTErrorParseUnrecognizedToken">トークン (または式) "{0}" は ("{1}" 内で) 認識されません</entry>
    <entry key="LCTErrorParseMissingDataType">(式 "{0}" 内の) データ型は指定されなけばなりません。あるいは、データ型は ("{1}" 内で) 有効ではありません。</entry>
    <entry key="LCTErrorParseBadDataId">入力/出力/パラメーター/作業数は、(式 "{0}" 内 ("{1}" から)) 0 より大きい値が指定されなければなりません</entry>
    <entry key="LCTErrorParseBadOutputOrDWorkDim">出力、または作業の次元は (式 "{0}" 内 ("{1}" から)) 完全に指定されなければなりません</entry>
    <entry key="LCTErrorParseBadOutputOrDWorkDimForDynSize">出力、または作業の次元は、(式 "{0}" 内 ("{1}" から)) 入力/出力/パラメーター/作業のサイズに動的に指定するために使用できません。</entry>
    <entry key="LCTErrorParseBadParameterDim">パラメーターの次元は、(式 "{0}" 内 ("{1}" から)) 別のパラメーター、または入力の次元で指定できません</entry>
    <entry key="LCTErrorParseBadInputDim">入力の次元は、(式 "{0}" 内 ("{1}" から)) 別の入力の次元で指定できません</entry>
    <entry key="LCTErrorParseDifferentDataSpec">次元とデータ型の仕様は、すべての関数の仕様を通して同じでなければなりません</entry>
    <entry key="LCTErrorParseDuplicatedArgName">関数の引数名は固有でなければなりません</entry>
    <entry key="LCTErrorParseBadComplexSizeArg">関数 size() からの戻り値を複素数にはできません</entry>
    <entry key="LCTErrorParseBadTrailingDim">N 次元の入力/出力/パラメーター/作業に対して、後に続く次元は (式 "{0}" 内 ("{1}" から)) 1 より大きくなければなりません</entry>
    <entry key="LCTErrorParseBadDimSpec">次元の仕様は (動的なサイズに対して) 空、またはそうでない場合は (式 "{0}" 内 ("{1}" から)) 0 より大きくなければなりません</entry>
    <entry key="LCTErrorParseBadDataAccessForMethod">"{0}" のメソッドの間、古い形式のコードは入力/出力値、あるいは (式 "{1}" 内 ("{2}" から)) アドレスにアクセスできません</entry>
    <entry key="LCTErrorValidateDataId">{0} の数は 1 で始まり、単調増加でなければなりません</entry>
    <entry key="LCTErrorValidateScalarBusObject">{0} は Simulink.Bus オブジェクトでスカラーでなければなりません</entry>
    <entry key="LCTErrorValidateParameterBusObject">パラメーターを Simulink.Bus  オブジェクトにはできません</entry>
    <entry key="LCTErrorValidateBadBooleanComplex">boolean でない複素数の組み込みデータ型のみサポートされます ({0} {1,number,integer})</entry>
    <entry key="LCTErrorValidateBadParameterOrInputAsDim">{0} {1}{2,number,integer} は、存在しない {3} {4}{5,number,integer} への参照があります</entry>
    <entry key="LCTErrorValidateBadScalarParameterOrInputAsDim">{0} {1}{2,number,integer} は、スカラー {3} {4}{5,number,integer} のサイズへの参照があります</entry>
    <entry key="LCTErrorValidateBadDimParameterOrInputAsDim">{0} {1}{2,number,integer} は、存在しない次元 {3} {4}{5,number,integer} への参照があります</entry>
    <entry key="LCTErrorValidateBadComplexParamAsDim">パラメーター p{0,number,integer} のデータ型は、その値が次元の定義に対して使われている場合、複素数にはできません</entry>
    <entry key="LCTErrorValidateBadFixedPointParamAsDim">パラメーター p{0,number,integer} のデータ型は、次元の定義に対して使われている場合、固定小数点にはできません</entry>
    <entry key="LCTErrorValidateBadParamValueAsDim">{0} {1}{2,number,integer} は、非スカラーのパラメーター p{3,number,integer} への参照があります</entry>
    <entry key="LCTErrorValidateAllDynSize">入力/出力/パラメーター/作業の動的なサイズを指定している場合、すべての次元は動的なサイズ ({0} {1,number,integer}) でなければなりません</entry>
    <entry key="LCTErrorValidateSizeArgDataType">引数 "{0}" (関数の仕様 {1}FcnSpec) のデータ型を固定小数点、またはバス オブジェクトにもできません</entry>
    <entry key="LCTErrorValidateSizeArgDataId">引数 "{0}" (関数の仕様 {1}FcnSpec) は、存在しない {2} {3,number,integer} への参照があります</entry>
    <entry key="LCTErrorValidateSizeArgDataDim">引数 "{0}" (関数の仕様 {1}FcnSpec) は、存在しない {2} {3,number,integer} の次元への参照があります</entry>
    <entry key="LCTErrorValidateVoidArg">データ型が "void*" または "void**" になるのは作業データだけです。\n{0}</entry>
    <entry key="LCTErrorValidateInvalideFieldName">関数の仕様の構造体内の無効なフィールド "{0}"</entry>
    <entry key="LCTErrorValidateInvalideFieldDataType">フィールド "{0}" は、クラス "{1}" のものですが、クラス "{2}" のものでなければなりません</entry>
    <entry key="LCTErrorValidateInvalideStringFieldDataType">フィールド "{0}" は文字ベクトルまたは string でなければなりません</entry>
    <entry key="LCTErrorValidateBadLanguage">フィールド "Options.language" は "C" または "C++" でなければなりません</entry>
    <entry key="LCTErrorValidateSampleTimeValue">SampleTime フィールドは非負でなければなりません (あるいは継承は -1)</entry>
    <entry key="LCTErrorValidateSampleTimeOffsetValue">オフセットは周期より小さくなければなりません</entry>
    <entry key="LCTErrorValidateSampleTimeOffsetValue1">周期が -1 の場合、オフセットは 0 でなければなりません</entry>
    <entry key="LCTErrorValidateSampleTimeOffsetValue2">周期が 0 の場合、オフセットは 1 でなければなりません</entry>
    <entry key="LCTErrorValidateSampleTimeField">SampleTime フィールドは、''inherited'' か ''parameterized''、または、[値 オフセット] か [値] でなければなりません</entry>
    <entry key="LCTErrorValidateEmptyStringField">フィールド "{0}" は空でない文字ベクトルでなければなりません</entry>
    <entry key="LCTErrorValidateSFunctionName">フィールド "SFunctionName" は、有効でない文字 ("{0}") を含んでいます</entry>
    <entry key="LCTErrorValidateCellString">フィールド "{0}" は文字ベクトルまたは string 配列のセルでなければなりません</entry>
    <entry key="LCTErrorValidateBadHeaderFile">フィールド "HeaderFiles" はファイル名のみ受け入れます。"IncPaths" フィールド内にパス "{0}" を追加しなければなりません</entry>
    <entry key="LCTErrorValidateBadFile">不正な {0} ファイル "{1}"</entry>
    <entry key="LCTErrorDataTypeWordlengthTooBig">Simulink.NumericType "{0}" の "Wordlength" プロパティは、64 以下でなければなりません</entry>
    <entry key="LCTWarningDataTypeWordlengthModified">データ型 "{0}" は、サポートされない語長 ({1,number,integer}) を使用しています。\nこのデータ型を使用している固定小数点信号はより長い語長 ({2,number,integer}) の内部に入れられます。</entry>
    <entry key="LCTSFcnCppCodeAPIWarningSkipTLC">"{0}" の仕様は、S-Function Code 設定 API を使用するために設定されます。TLC ブロックのファイルは生成されません。</entry>
    <entry key="LCTSFcnCppCodeAPIWarningCppNotSupported">C++ 言語は S-Function Code 設定 API でまだサポートされていません。TLC ベースのコード生成を使用しなければなりません。</entry>
    <entry key="LCTSFcnCppCodeAPIWarningNoSLDataObjectSupport">S-Function Code 設定 API でまだサポートされていない Simulink.AliasType, Simulink.NumericType または Simulink.Bus に対するヘッダー ファイルが与えられました。TLC ベースのコード生成を使用しなければなりません。</entry>
    <entry key="LCTSFcnCppCodeAPIWarningVoidWorkNotSupported">Void work は S-Function Code 設定 API でまだサポートされていません。TLC ベースのコード生成を使用しなければなりません。</entry>
    <entry key="LCTSFcnCppCodeAPIWarningManyHeaderfilesNotSupported">1 つを超えるヘッダー ファイルの指定は、S-Function Code 設定 API でまだサポートされていません。TLC ベースのコード生成を使用しなければなりません。</entry>
    <entry key="LCTSFcnCppCodeAPIWarningEnclosedHeaderfilesNotSupported">''"'' または ''&lt;&gt;'' で囲まれているヘッダー ファイルは、S-Function Code 設定 API ではまだサポートされていません。TLC ベースのコード生成を使用しなければなりません。</entry>
    <entry key="LCTSFcnCodeAPIError2DMatrixNotSupported">行優先の 2 次元行列の処理は、S-Function Code Construction API ではまだサポートされていません。TLC ベースのコード生成を使用しなければなりません。</entry>
    <entry key="LCTSFcnBusElementCplx2DMatrixNotSupported">バス要素または StructType 要素 "{0}" ("{2}" で指定されたバスまたは StructType オブジェクト "{1}" の) は、"convert2DMatrixToRowMajor" オプションが true の場合はサポートされない複合型の 2 次元配列です。</entry>
    <entry key="LCTSFcnCplx2DMatrixNotSupported">"convert2DMatrixToRowMajor" オプションが true の場合、"{0}" はサポートされない複合型の 2 次元配列です。</entry>
    <entry key="LCTSFcnCodeAPIErrorNDArrayNotSupported">行優先の N 次元配列の処理は、S-Function Code 設定 API ではまだサポートされていません。TLC ベースのコード生成を使用しなければなりません。</entry>
    <entry key="LCTSFcnBusElementCplxNDArrayNotSupported">バス要素または StructType 要素 "{0}" ("{2}" で指定されたバスまたは StructType オブジェクト "{1}" の) は、"convertNDArrayToRowMajor" オプションが true の場合はサポートされない複合型の N 次元配列です。</entry>
    <entry key="LCTSFcnCplxNDArrayNotSupported">"convertNDArrayToRowMajor" オプションが true の場合、"{0}" はサポートされない複合型の N 次元配列です。</entry>
    <entry key="LCTSpecParserBadOutputAccessForMethod">レガシ コードは条件付きで割り当てられていないため、出力値またはアドレスにアクセスできるのは "Output" メソッドのときのみです。\n{0}</entry>
    <entry key="LCTSpecParserBadOutputAccessForTerminate">レガシ コードは "Terminate" メソッドのときは出力値またはアドレスにアクセスできません。\n{0}</entry>
    <entry key="LCTSpecParserBadInputAccessForMethod">レガシ コードが入力値またはアドレスにアクセスできるのは、"Output" メソッドのときのみです。\n{0}</entry>
    <entry key="LCTSpecParserBadDimSpec">次元の仕様は (動的なサイズに対して) 空であるか、そうでない場合は 0 より大きくなければなりません:\n{0}</entry>
    <entry key="LCTSpecParserBadTrailingDim">N 次元の入力/出力/パラメーター/作業に対して、後に続く次元は 1 より大きくなければなりません:\n{0}</entry>
    <entry key="LCTSpecParserBadComplexSizeArg">関数 "size" または "numel" の戻り値を複素数にすることはできません:\n{0}</entry>
    <entry key="LCTSpecParserBadFcnReturn">この関数の戻り値として指定できるのはスカラー出力だけです。\n{0}</entry>
    <entry key="LCTSpecParserBadParameterDim">パラメーターの次元は、別のパラメーターまたは入力の次元で指定できません:\n{0}</entry>
    <entry key="LCTSpecParserBadInputDim">入力の次元は、別の入力の次元で指定できません:\n{0}</entry>
    <entry key="LCTSpecParserBadOutputOrDWorkDimForDynSize">出力または作業の次元は、動的にサイズが変更される入力/出力/パラメーター/作業を指定するために使用できません:\n{0}</entry>
    <entry key="LCTSpecParserBadOutputOrDWorkDim">出力または作業の次元は完全に指定されなければなりません:\n{0}</entry>
    <entry key="LCTSpecParserBadDataId">入力/出力/パラメーター/作業の数には、0 より大きい値が指定されなければなりません:\n{0}</entry>
    <entry key="LCTSpecParserUnrecognizedToken">認識されないトークン (または式) です。\n{0}</entry>
    <entry key="LCTSpecParserBadSpec">式に有効な関数の仕様が見つかりません:\n{0}</entry>
    <entry key="LCTSpecParserBadLhsExpr">関数の仕様に、有効な左辺の式が見つかりません (この関数の戻り値としてスカラー出力のみを指定可):\n{0}</entry>
    <entry key="LCTSpecParserBadArgListExpr">関数の仕様に有効な引数リストが見つかりません:\n{0}</entry>
    <entry key="LCTSpecParserBadRhsExpr">関数の仕様に認識されない要素があります。\n{0}</entry>
    <entry key="LCTSpecParserBadArgExpr">関数の仕様に認識されない引数があります。\n{0}</entry>
    <entry key="LCTSpecParserBadStars">アスタリスクは仕様では 1 つまたは 2 つしか許可されていません:\n{0}</entry>
    <entry key="LCTSpecParserBadVoidArg">サポートされない void 引数式です。\n{0}</entry>
    <entry key="LCTSpecParserBadMixedDynFixDims">Cannot mix dynamic and fix dimensions in the same specification:\n{0}</entry>
    <entry key="LCTSpecParserBadDynamicArrayRowMajor">動的な配列次元は、行優先ではサポートされていません。\n{0}</entry>
    <entry key="LCTSpecParserBadDynamicArrayDWork">動的な配列次元は、DWork ではサポートされていません。\n{0}</entry>
    <entry key="LCTSpecParserBadDynamicArrayParameter">動的な配列次元は、パラメーターではサポートされていません。\n{0}</entry>
    <entry key="LCTSpecParserBadDynamicArrayBusElement">Dynamic array dimensions are not supported for Simulink.BusElement (element "{0}" in Simulink.Bus "{1}")</entry>
    <entry key="LCTSpecParserBadDynamicArrayCodeAPI">Dynamic array dimensions are not supported by the S-Function Code Construction API. Must use TLC based code generation.</entry>
    <entry key="LCTSizeSpecParserBadSizeSyntaxWithDesc">仕様の構文が無効です。\n{0}</entry>
    <entry key="LCTSizeSpecParserBadSizeSyntax">仕様の構文が無効です</entry>
    <entry key="LCTSizeSpecParserSizeExprNotParameterAccess">式で使用できるのはパラメーター名だけです ("{0}" が見つかりました)</entry>
    <entry key="LCTSizeSpecParserSizeExprNotSupportedFun">サポートされる関数は "size" と "numel" だけです ("{0}" が見つかりました)</entry>
    <entry key="LCTSizeSpecParserSizeExprArg1NotCallNode">関数 "{1}" に渡された最初の引数はサポートされていません (現在は "{0}" です)</entry>
    <entry key="LCTSizeSpecParserSizeExprArg1NotDataName">関数 "{1}" に渡された最初の引数を認識できません ("{0}" が見つかりました)</entry>
    <entry key="LCTSizeSpecParserSizeExprArg1IsDWork">作業データに対して関数 "size" を呼び出すことはできません</entry>
    <entry key="LCTSizeSpecParserSizeExprBadSizeNumArg">関数 "size" には引数が 2 つ必要です ({0} 個見つかりました)</entry>
    <entry key="LCTSizeSpecParserSizeExprArg2NotInt">関数 "size" に渡される 2 番目の引数は整数でなければなりません ("{0}" が見つかりました)</entry>
    <entry key="LCTSizeSpecParserSizeExprArg2NotPosInt">関数 "size" に渡される 2 番目の引数は 0 より大きい整数でなければなりません (現在は {0} です)</entry>
    <entry key="LCTSizeSpecParserSizeExprBadNumelNumArg">関数 "numel" には引数が 1 つ必要です ({0} 個見つかりました)</entry>
    <entry key="LCTSizeSpecParserSizeExprBadOp">式 "{0}" はサポートされていません</entry>
    <entry key="LCTSpecBadId">識別子 "{0}" はサポートされていません</entry>
    <entry key="LCTSizeSpecParserNegExpr">式 "{0}" は負の値 "{1}" に評価されます</entry>
    <entry key="LCTSizeSpecParserFltExpr">式 "{0}" は非整数値 "{1}" に評価されます</entry>
    <entry key="LCTGlobalIOInputsOutputsOnly">"{0}" は無効なグローバル変数の指定です。グローバル変数は、入力、出力、パラメーターおよびデータ ストア メモリに対してのみサポートされています。</entry>
    <entry key="LCTGetSetIODSMParamOnly">get/set の指定 "{0}" が無効です。get/set 関数は、パラメーターおよびデータ ストア メモリに対してのみサポートされています。</entry>
    <entry key="LCTGlobalIOMissingColon">式にコロンがありません。期待される式の形式: {0} ...</entry>
    <entry key="LCTGlobalIONeedsDataTypeAndPortID">"{0}" は無効なグローバル変数の指定です。グローバル変数の指定にはデータ型と端子の指定が含まれていなければなりません。</entry>
    <entry key="LCTGlobalIOPointerNoExtern">"{0}" は無効なグローバル変数の指定です。ポインター変数をもつグローバル I/O は extern ポインター型のみをサポートしています。</entry>
    <entry key="LCTGlobalIORequireStubSimBehavior">グローバル I/O およびデータ ストア メモリは、リリース間コード統合ワークフローを通してのみサポートされています。</entry>
    <entry key="LCTGlobalIODoesntSupportSingleCPPMexFile">グローバル I/O は ''SingleCPPMexFile'' をサポートしていません。</entry>
    <entry key="LCTGlobalIODoesntSupportMultipleExecInstances">グローバル I/O は ''MultipleExecInstances'' をサポートしていません。</entry>
    <entry key="LCTGlobalIODoesntSupportConvert2DMatrixToRowMajor">グローバル I/O は ''convert2DMatrixToRowMajor'' をサポートしていません。</entry>
    <entry key="LCTGlobalIODoesntSupportConvertNDArrayToRowMajor">グローバル I/O は ''convertNDArrayToRowMajor'' をサポートしていません。</entry>
    <entry key="LCTGlobalIncompatibleStorageClass">ブロック "{2}" の {0} 端子 {1} から "{3}" ストレージ クラスと指定された識別子 "{4}" をもつ信号への接続が、名前の競合により妨げられています。別の識別子または別のストレージ クラスを使用してください。</entry>
    <entry key="LCTGlobalIncompatibleRootIOStorageClass">ブロック "{2}" の {0} 端子 {1} から指定の識別子 "{3}" をもつ信号への接続が、変数の所有権の競合により妨げられています。異なる識別子を使用するか、または Simulink のコンフィギュレーション セット パラメーター ''EnableDataOwnership'' を ''オン'' に設定し、Exported スコープをもつカスタム ストレージ クラス (ExportToFile など) を使用して、空でない ''Owner'' 属性を設定してください。</entry>
    <entry key="LCTGlobalInputOutputOnly">portType "{0}" が無効です。portType は "Output" または "Input" でなければなりません。</entry>
    <entry key="LCTGlobalDSMInvalidReadOnlyTag">グローバル DSM 式 "{0}" が無効です。変数名 "{1}" の後ろに配置可能な接尾辞は、読み取り専用の DSM を示す "readonly" のみです。</entry>
    <entry key="LCTGetSetNeedWorkspaceName">get/set の指定 "{0}" が無効です。コロンの後に信号またはパラメーターのワークスペース オブジェクト名が必要です。</entry>
    <entry key="LCTGetSetNeedGetMethod">get/set の指定 "{0}" が無効です。get メソッドは常に定義されなければなりません。</entry>
    <entry key="LCTDSMFunctionArgNotSupported">{1} 関数 "{0}" の定義の引数が無効です: データ ストア メモリは、関数の引数としてサポートされません。</entry>
    <entry key="LCTNamedDataTypeConflictsWithOpaque">名前付きデータ型 ''{0}'' と、既に定義済みのデータ型が競合しています。</entry>
    <entry key="LCTOpaqueDataTypeConflictsWithNamed">データ型 ''{0}'' と、既に定義済みの名前付きデータ型が競合しています。</entry>
    <entry key="LCTCannotDriveMultipleRootOutportsWithStorageClass">リリース間で使用されるブロック {1} の&lt;sldiag objui="outport" objparam="{0}" objname="{1}"&gt;出力端子 {0}&lt;/sldiag&gt; が 1 つを超えるルート出力端子を直接に駆動し、少なくとも 1 つのルート出力端子に明示的なストレージ クラスが設定されています。生成されるコードの出力端子とインポートされるコードの変数の間の関係を定義するには、親モデルで、ブロックの出力端子に接続されたラインに、名前のついた信号と明示的なストレージ クラスを割り当てます。</entry>
    <entry key="LCTFileNotGeneratedByLCT">ファイル ''{0}'' はレガシ コード ツールによって生成されていません。</entry>
    <entry key="LCTCannotParseFileContents">ファイル ''{0}'' の内容を解析できません。</entry>
    <entry key="LCTBadFixedFileContents">ファイル ''{0}'' を修正できません。</entry>
    <entry key="slSaveAsBadVersion">''{0}'' に保存しようとしたバージョンはサポートされていません。</entry>
    <entry key="slSaveAsDepreciatedVersion">選択した ''{0}'' を持つバージョンへの保存は廃止予定のため、Simulink の将来のリリースでは削除される予定です。</entry>
    <entry key="FxpCheckFailed">''{0}'' に対するモデル アドバイザーの固定小数点のチェックを実行できません。エラーが発生しました。\n''{1}''</entry>
    <entry key="FxpCheckFailedModelIntDivSettings">モデルの整数の除算設定</entry>
    <entry key="FxpCheckFailedProductBlockRounding">Product ブロックの丸め</entry>
    <entry key="FxpCheckFailedLookupBlockRounding">Lookup ブロックの丸め</entry>
    <entry key="FxpCheckFailedLookupBreakpointSpacing">Lookup のブレークポイントの間隔</entry>
    <entry key="FxpCheckFailedPreLookupBlocks">PreLookup ブロック</entry>
    <entry key="FxpCheckFailedGainBlocks">Gain ブロック</entry>
    <entry key="FxpCheckFailedProductBlocks">Product ブロック</entry>
    <entry key="FxpCheckFailedDotProductBlocks">Dot product ブロック</entry>
    <entry key="FxpCheckFailedSumBlocks">Sum ブロック</entry>
    <entry key="FxpCheckFailedRelopBlocks">Relational operator ブロック</entry>
    <entry key="FxpCheckFailedMinmaxBlocks">Minmax ブロック</entry>
    <entry key="FxpCheckFailedDiscreteIntegratorBlocks">Discrete integrator ブロック</entry>
    <entry key="FxpCheckFailedDTCBlocks">Data Type Conversion ブロック</entry>
    <entry key="FxpCheckFailedCompToZeroBlocks">Compare To Zero ブロック</entry>
    <entry key="FxpCheckFailedCompToConstBlocks">Compare To Constant ブロック</entry>
    <entry key="FxpPreLookupDivision">以下のブロックの最適化の可能性: インデックス検索法が ''等間隔のポイント'' で ''ブレークポイント'' データが調整不可の場合、\n偶数の 2 のべき乗の間隔を使用してみてください。そうでない場合、計算量の多い除算演算を回避するために\n別のインデックス検索法を指定してください。</entry>
    <entry key="FxpEvenSpacingSignificant">以下の Lookup Table の最適化の可能性: ''入力値のベクトル'' が調整不可の場合、''入力値のベクトル'' データを\n等間隔にしてください。より効率的な実行を行うために 2 のべき乗間隔を\n使用してください。詳細は、fixpt_look1_func_approx を参照してください。</entry>
    <entry key="FxpEvenSpacingSlight">以下の Lookup Table の最適化の可能性: ''入力値のベクトル'' データがおおよそ等間隔で量子化されている場合、\n''入力値のベクトル'' データを等間隔にしてください。より効率的な実行を行うために 2 のべき乗間隔を\n使用してください。詳細は、fixpt_evenspace_cleanup を参照してください。</entry>
    <entry key="FxpEvenSpacingPerfect">以下の Lookup Table の最適化の可能性: ''入力値のベクトル'' データが等間隔で調整不可の場合、\n偶数の 2 のべき乗の間隔を使用し、テーブルを変更してみてください。これは除算の代わりに\nシフトを使用する簡略化した実行になります。詳細は、fixpt_look1_func_approx を参照してください。</entry>
    <entry key="FxpEvenSpacingPow2WithNonEvenSearch">次の 1-D、2-D、または n-D Lookup Table ブロックの最適化の可能性:''ブレークポイント'' データが偶数の 2 のべき乗の間隔で調整不可の場合は、\n''等間隔のポイント'' 検索法にすることを推奨します。除算演算を避けて、''ブレークポイント'' データの\nメモリ容量を減らすため、より効率的な実行を行うことと同じ結果になります。</entry>
    <entry key="FxpEvenSpacingNotPow2WithNonEvenSearch">次の 1-D、2-D、または n-D Lookup Table ブロックの最適化の可能性:''ブレークポイント'' データが等間隔の場合は、効率性を改善してメモリの使用を減らすために、\n''インデックス検索法'' を ''等間隔のポイント'' に設定してください。さらに効率的に改善するために、''ブレークポイント'' データが\n調整不可の場合に偶数の 2 のべき乗間隔にすることを検討してください。  </entry>
    <entry key="FxpEvenSpacingNotPow2WithEvenSearch">次の 1-D、2-D、または n-D Lookup Table ブロックの最適化の可能性:''ブレークポイント'' データが等間隔で調整不可の場合は、\n''ブレークポイント'' データを偶数の 2 のべき乗間隔に調整してください。これは除算の代わりに\nシフトを使用する簡略化した実行になります。詳細は、fixpt_look1_func_approx を参照してください。</entry>
    <entry key="FxpNotEvenSpacingWithNonEvenSearch">次の 1-D、2-D、または n-D Lookup Table ブロックの最適化の可能性:''ブレークポイント'' データが調整不可の場合は、\n''ブレークポイント'' データを偶数の 2 のべき乗に調整し、''等間隔のポイント'' インデックス検索法を使用してください。\n これにより効率的な実行になります。</entry>
    <entry key="FxpCheckDIntegrateBlock">以下の Discrete Integrator は、複雑な初期条件モードを持っています。\n初期条件は、状態と出力を初期化するために使用されます。\n結果として、出力方程式は、特別な生成コードが必要で、\n特別なグローバル変数が必要です。状態のみ効率的に初期化されるように\n初期条件モードを設定してください。</entry>
    <entry key="FxpCouldNotComputeRounding">モデル アドバイザーは、以下の Product ブロックに対して\n最も効率的な丸め手法を計算できません。</entry>
    <entry key="FxpSuggestMoreEfficientRounding">最も効率的な生成コードを得るには、以下のブロックの &lt;b&gt;[丸めの\n整数演算の手法]&lt;/b&gt; パラメーターを {0} に変更する必要があります。</entry>
    <entry key="FxpCheckLookupRounding">最も効率的な生成コードを得るには、以下のブロックの &lt;b&gt;[丸めの\n整数演算の手法]&lt;/b&gt; パラメーターを &lt;code&gt;[最も簡潔]&lt;/code&gt; に変更する必要があります。</entry>
    <entry key="FxpCheckDTConvRounding">最も効率的な生成コードを得るには、以下のブロックの &lt;b&gt;[丸めの\n整数演算の手法]&lt;/b&gt; パラメーターを &lt;code&gt;[最も簡潔]&lt;/code&gt; に変更する必要があります。</entry>
    <entry key="FxpCheckProductBlock">不変の定数値を持つ入力 (サンプル時間の色が赤紫) は、\nオンラインの除算演算の分母として使用されます。演算が乗算に変更され、\n不変の入力がその逆数で置き換えられる場合、\n除算は、オフラインになり、オンラインの演算は乗算になります。これは、\n満足する数値を与え、通常、高速で\n小さい生成コードになります。</entry>
    <entry key="FxpCheckMultiWord">\nこのオプションを使用するには、マルチワード処理を避けるために次のブロックの語長を変更してください。 </entry>
    <entry key="FxpNetSlopeChangeRndMethod">\nこのオプションを使用するには、次のブロックの &lt;b&gt;[整数丸めモード]&lt;/b&gt; パラメーターを &lt;code&gt;[最も簡潔]&lt;/code&gt; に変更するか、&lt;b&gt;[コンフィギュレーション パラメーター] &gt; [ハードウェア実行] &gt; [デバイスの詳細] &gt; [符号付き整数の除算の丸め]&lt;/b&gt; の設定に変更してください。 </entry>
    <entry key="FxpNetSlopeChangeHWRndMeth">\nこのオプションを使用するには、&lt;b&gt;[コンフィギュレーション パラメーター] &gt; [ハードウェア実行] &gt; [デバイスの詳細] &gt; [符号付き整数の除算の丸め]&lt;/b&gt; の設定を &lt;code&gt;[ゼロ方向]&lt;/code&gt; または &lt;code&gt;[負方向]&lt;/code&gt; に変更してください。</entry>
    <entry key="FxpCheckMulOptSetOnRationalApprox">次のブロックは、乗算の場合に正味傾きの計算を呼び出します。このモデルでは、&lt;b&gt;[コンフィギュレーション パラメーター] &gt; [数学とデータ型] &gt; [固定小数点の正味傾き計算に除算を使用]&lt;/b&gt; の設定が &lt;code&gt;[オン]&lt;/code&gt; に設定されています。 </entry>
    <entry key="FxpCheckMulOptSetOnReciprocalOfInt">次のブロックは、乗算の場合に正味傾きの計算を呼び出します。このモデルでは、&lt;b&gt;[コンフィギュレーション パラメーター] &gt; [数学とデータ型] &gt; [固定小数点の正味傾き計算に除算を使用]&lt;/b&gt; の設定が &lt;code&gt;[整数の逆数の場合にのみ除算を使用]&lt;/code&gt; に設定されています。 </entry>
    <entry key="FxpCheckMulOptSetOffRationalApprox">次のブロックは、乗算の場合に正味傾きの計算を呼び出します。この正味傾きの計算は、乗算してシフト、整数の乗算または除算、整数の乗算と除算のいずれかで実装できます。&lt;b&gt;[コンフィギュレーション パラメーター] &gt; [数学とデータ型] &gt; [固定小数点の正味傾き計算に除算を使用]&lt;/b&gt; の設定を &lt;code&gt;[オン]&lt;/code&gt; に変更すると、より効率的なコードが生成される可能性があります。たとえば、fixdt(1, 16, 7/10, 0) から fixdt(1, 16, 1, 0) までの正味傾きの計算は、Qy = Qu*11469 &gt;&gt; 14 の代わりに Qy = (Qu*7)/10 を使用して実現できます。 </entry>
    <entry key="FxpCheckMulOptSetOffReciprocalOfInt">次のブロックは、乗算の場合に正味傾きの計算を呼び出します。この正味傾きの計算は、乗算してシフト、あるいは整数の除算で実装できます。&lt;b&gt;[コンフィギュレーション パラメーター] &gt; [数学とデータ型] &gt; [固定小数点の正味傾き計算に除算を使用]&lt;/b&gt; の設定を &lt;code&gt;[整数の逆数の場合にのみ除算を使用]&lt;/code&gt; または &lt;code&gt;[オン]&lt;/code&gt; に変更すると、より効率的なコードが生成される可能性があります。たとえば、fixdt(1, 16, 1/1000, 0) から fixdt(1, 16, 1, 0) までの正味傾きの計算は、Qy = (int16_T)((int32_T)Qu * 1677L &gt;&gt; 24) の代わりに Qy = Qu/1000 を使用して実現できます。 </entry>
    <entry key="FxpCheckMulOptSetOffRationalApproxSetOnReciprocalOfInt">次のブロックは、乗算の場合に正味傾きの計算を呼び出します。&lt;b&gt;[コンフィギュレーション パラメーター] &gt; [数学とデータ型] &gt; [固定小数点の正味傾き計算に除算を使用]&lt;/b&gt; が &lt;code&gt;[整数の逆数の場合にのみ除算を使用]&lt;/code&gt; に設定されています。この設定を &lt;code&gt;[オン]&lt;/code&gt; に変更すると、より効率的なコードが生成される可能性があります。たとえば、fixdt(1, 16, 7/10, 0) から fixdt(1, 16, 1, 0) までの正味傾きの計算は、Qy = Qu*11469 &gt;&gt; 14 の代わりに Qy = (Qu*7)/10 を使用して実現できます。 </entry>
    <entry key="FxpCheckCastOptSetOnRationalApprox">次のブロックは、キャストに対して正味傾きの計算を呼び出します。このモデルでは、&lt;b&gt;[コンフィギュレーション パラメーター] &gt; [数学とデータ型] &gt; [固定小数点の正味傾き計算に除算を使用]&lt;/b&gt; の設定が &lt;code&gt;[オン]&lt;/code&gt; に設定されています。 </entry>
    <entry key="FxpCheckCastOptSetOnReciprocalOfInt">次のブロックは、キャストに対して正味傾きの計算を呼び出します。このモデルでは、&lt;b&gt;[コンフィギュレーション パラメーター] &gt; [数学とデータ型] &gt; [固定小数点の正味傾き計算に除算を使用]&lt;/b&gt; の設定が &lt;code&gt;[整数の逆数の場合にのみ除算を使用]&lt;/code&gt; に設定されています。 </entry>
    <entry key="FxpCheckCastOptSetOffRationalApprox">次のブロックは、キャストに対して正味傾きの計算を呼び出します。この正味傾きの計算は、乗算してシフト、整数の乗算または除算、整数の乗算と除算のいずれかで実装できます。&lt;b&gt;[コンフィギュレーション パラメーター] &gt; [数学とデータ型] &gt; [固定小数点の正味傾き計算に除算を使用]&lt;/b&gt; の設定を &lt;code&gt;[オン]&lt;/code&gt; に変更すると、より効率的なコードが生成される可能性があります。たとえば、fixdt(1, 16, 7/10, 0) から fixdt(1, 16, 1, 0) までの正味傾きの計算は、Qy = Qu*11469 &gt;&gt; 14 の代わりに Qy = (Qu*7)/10 を使用して実現できます。 </entry>
    <entry key="FxpCheckCastOptSetOffReciprocalOfInt">次のブロックは、キャストに対して正味傾きの計算を呼び出します。この正味傾きの計算は、乗算してシフト、あるいは整数の除算で実装できます。&lt;b&gt;[コンフィギュレーション パラメーター] &gt; [数学とデータ型] &gt; [固定小数点の正味傾き計算に除算を使用]&lt;/b&gt; の設定を &lt;code&gt;[整数の逆数の場合にのみ除算を使用]&lt;/code&gt; または &lt;code&gt;[オン]&lt;/code&gt; に変更すると、より効率的なコードが生成される可能性があります。たとえば、fixdt(1, 16, 1/1000, 0) から fixdt(1, 16, 1, 0) までの正味傾きの計算は、Qy = (int16_T)((int32_T)Qu * 1677L &gt;&gt; 24) の代わりに Qy = Qu/1000 を使用して実現できます。 </entry>
    <entry key="FxpCheckCastOptSetOffRationalApproxSetOnReciprocalOfInt">次のブロックは、キャストに対して正味傾きの計算を呼び出します。&lt;b&gt;[コンフィギュレーション パラメーター] &gt; [数学とデータ型] &gt; [固定小数点の正味傾き計算に除算を使用]&lt;/b&gt; が &lt;code&gt;[整数の逆数の場合にのみ除算を使用]&lt;/code&gt; に設定されています。この設定を &lt;code&gt;[オン]&lt;/code&gt; に変更すると、より効率的なコードが生成される可能性があります。たとえば、fixdt(1, 16, 7/10, 0) から fixdt(1, 16, 1, 0) までの正味傾きの計算は、Qy = Qu*11469 &gt;&gt; 14 の代わりに Qy = (Qu*7)/10 を使用して実現できます。 </entry>
    <entry key="FxpMulCheckSatOnUseMinMaxOff">以下のブロックは、非常に扱いにくい乗算です。\n1 番目の入力は {0,number,* #0} ビットをもっています。\n2 番目の入力は {1,number,* #0} ビットをもっています。\n理想の乗算は {2,number,* #0} ビットをもちます。\nターゲットに対する最も大きな整数サイズは、{3,number,integer} ビットのみもちます。\n飽和は、C コードの理想の乗算のすべての {4,number,integer} ビットを\n定義する必要があるため、ON です。\nC コードは、大きくて遅いこの乗算行うために必要です。\nこのターゲットに対して、乗算を {5,number,integer} ビット × {6,number,integer} ビット倍に制限することを強く推奨します。</entry>
    <entry key="FxpMulCheckSatOffUseMinMaxOff">以下のブロックは、非常に扱いにくい乗算です。\n1 番目の入力は {0,number,* #0} ビットをもっています。\n2 番目の入力は {1,number,* #0} ビットをもっています。\n理想の乗算は {2,number,* #0} ビットをもちます。\nターゲットに対する最も大きな整数サイズは、{3,number,integer} ビットのみもちます。\n入力と出力の相対的なスケーリングは、C コードで定義された理想の乗算の\n{4,number,integer} の最上位ビットのいくつかが必要です。\nC コードは、大きくて遅いこの乗算行うために必要です。\nこのターゲットに対して、乗算を {5,number,integer} ビット × {6,number,integer} ビット倍に制限することを強く推奨します。</entry>
    <entry key="FxpMulCheckSatOnUseMinMaxOn">入力範囲を正しく指定しない限り (詳細については、指定された最小値と最大値を使用した生成コードの最適化に関するドキュメンテーションを参照してください)、以下のブロックで非常に扱いにくい乗算が必要になることがあります。\n1 番目の入力は {0,number,* #0} ビットをもっています。\n2 番目の入力は {1,number,* #0} ビットをもっています。\n型情報に基づき、理想の乗算は {2,number,* #0} ビットになります。\nターゲットに対する最も大きな整数サイズは、{3,number,integer} ビットのみもちます。\n飽和は、C コードの理想の乗算のすべての {4,number,integer} ビットを\n定義する必要があるため、ON です。\nC コードは、大きくて遅いこの乗算行うために必要です。\nこのターゲットに対して、乗算を {5,number,integer} ビット × {6,number,integer} ビット倍に制限することを強く推奨します。</entry>
    <entry key="FxpMulCheckSatOffUseMinMaxOn">入力範囲を正しく指定しない限り (詳細については、指定された最小値と最大値を使用した生成コードの最適化に関するドキュメンテーションを参照してください)、以下のブロックで非常に扱いにくい乗算が必要になることがあります。\n1 番目の入力は {0,number,* #0} ビットをもっています。\n2 番目の入力は {1,number,* #0} ビットをもっています。\n型情報に基づき、理想の乗算は {2,number,* #0} ビットになります。\nターゲットに対する最も大きな整数サイズは、{3,number,integer} ビットのみもちます。\n入力と出力の相対的なスケーリングは、C コードで定義された理想の乗算の\n{4,number,integer} の最上位ビットのいくつかが必要になることがあります。\nC コードは、大きくて遅いこの乗算行うために必要です。\nこのターゲットに対して、乗算を {5,number,integer} ビット × {6,number,integer} ビット倍に制限することを強く推奨します。</entry>
    <entry key="FxpMulCheckNoZeroBias">以下のブロックは、非零のバイアスを持つ信号を乗算しています。\n特別な手順が乗算を実行するために必要となるため、\n可能な場合は、これを避けることを推奨します。\nこれを回避するには、ブロックが乗算を行う前\nおよび/または後に Data Type Conversion ブロックを挿入してください。これは、バイアスの削除を\n許可し、中間の計算に対するデータ型と\nスケーリングの制御が行えます。多くの場合、\nData Type Conversion ブロックは、(サブ) システムの "端" に移動することが可能です。\n変換は 1 回だけ行われ、サブシステム内のすべてのブロックは、\nよりシンプルなバイアスのない数学を学ぶことができます。</entry>
    <entry key="FxpMulCheckMismatchSlope">以下のブロックは、不適切な傾き調整要素で信号を乗算しています。\n1 番目の入力の傾き調整要素は {0} です。\n2 番目の入力の傾き調整要素は {1} です。\n入力の傾き調整要素は {2} です。 \n出力の傾き調整要素は {3} です。\nこの不一致は、1 回ではなく 2 回の乗算命令が演算に\n含まれているためです。この不一致を削除するには、\n傾き調整要素が入力の傾き調整要素の積となるように\n出力のスケーリングを変更してください。</entry>
    <entry key="FxpSumCheckBiasNote">よい精度と効率性については、\nすべての非零のバイアスの項を単一の net のバイアスの修正項に集めることに注意してください。範囲は、バイアスを\n含まない入力と出力に対して以下のように与えられます。 </entry>
    <entry key="FxpSumCheckMinMax">以下の Sum ブロックは値域エラーになる可能性があります。{0} 入力の 1 つは以下の範囲を持っています。\n{1} - {2}\nこれは、以下の出力範囲を超えています。\n{3} - {4}オーバーフローまたは飽和の可能性を減らすために、出力とアキュムレータのデータ型を等しくするか、すべての入力の範囲を超えるよう変更してください。  </entry>
    <entry key="FxpSumCheckMismatchSlope">以下の Sum ブロックは、出力の傾き調整要素と等しくない\n入力の傾き調整要素を持っています。\n入力の傾き調整要素は {0} です。\n出力の傾き調整要素は {1} です。\n正味の傾きの調整要素は {2} です。\nこの不一致のために、1 つまたは複数の乗算処理に対して適切な設定が Sum ブロックに必要となります。不一致を削除するには、入力、出力、アキュムレータのすべてが同じ傾き調整要素を持つようにデータ型を変更してください。</entry>
    <entry key="FxpSumCheckMismatchBias">以下の Sum ブロックに対して、入力のバイアスの net の和は、\n出力のバイアスと等しくありません。実行は、バイアスの調整を\n正しく行うために 1 つの余分な加算、\nまたは、減算の命令を含みます。正味のバイアスの調整を 0 にするように\n出力スケーリングのバイアスを変更し、余分な演算を\n除去できます。</entry>
    <entry key="FxpRelopCheckDataTypeNotSame">以下の Relational Operator ブロックに対して、\n1 番目と 2 番目の入力のデータ型が同じはありません。ブロックが実行される度に\n変換操作が必要です。入力の 1 つが不変\n(サンプル時間の色が赤紫) の場合、他の入力と一致するように\n不変の入力のデータ型とスケーリングを変更することは、\nモデルの効率を改善する良い機会です。</entry>
    <entry key="FxpRelopCheckSingleInputFixptBool">以下の Relational Operator ブロックの出力は常に {0} です。これは演算子が {1} であり、入力データ型が {2} であるためです。その結果、デッド コードとなって除去されます。</entry>
    <entry key="FxpRelopCheckU1Max">以下の Relational Operator ブロックに対して、1 番目の入力は、大きい正の範囲を持っています。2 番目の入力は、比較演算を\n行う前に 1 番目の入力のデータ型と\nスケーリングに変換されます。\n1 番目の入力は {0} から {1} の範囲を持ちますが、\n2 番目の入力は、キャスト中に値域エラーが発生するような\n{2} から {3} の範囲を持ちます。\n両方の入力を、各入力を完全に表すのに\n十分な範囲と精度を持つ共通のデータ型に変換するために、\nRelational Operator ブロックの前に\nData Type Conversion ブロックを挿入します。エラーのない\n比較演算になります。</entry>
    <entry key="FxpRelopCheckU1Slope">以下の Relational Operator ブロックに対して、1 番目の入力は、大きい正の範囲を持っています。2 番目の入力は、比較演算を\n行う前に 1 番目の入力のデータ型と\nスケーリングに変換されます。\n1 番目の入力は、精度 {0} を持っています。\n2 番目の入力は、変換を実行するたびに\n桁落ちする可能性のある精度 {1} を持っています。\n両方の入力を、各入力を完全に表すのに\n十分な範囲と精度を持つ共通のデータ型に変換するために、\nRelational Operator ブロックの前に\nData Type Conversion ブロックを挿入します。エラーのない\n比較演算になります。</entry>
    <entry key="FxpRelopCheckU2Max">以下の Relational Operator ブロックに対して、2 番目の入力は、大きい正の範囲を持っています。1 番目の入力は、比較演算を\n行う前に 2 番目の入力のデータ型と\nスケーリングに変換されます。\n1 番目の入力は {0} から {1} の範囲を持ちますが、\n2 番目の入力は、キャスト中に値域エラーが発生するような\n{2} から {3} の範囲を持ちます。\n両方の入力を、各入力を完全に表すのに\n十分な範囲と精度を持つ共通のデータ型に変換するために、\nRelational Operator ブロックの前に\nData Type Conversion ブロックを挿入します。エラーのない\n比較演算になります。</entry>
    <entry key="FxpRelopCheckU2Slope">以下の Relational Operator ブロックに対して、2 番目の入力は、大きい正の範囲を持っています。1 番目の入力は、比較演算を\n行う前に 2 番目の入力のデータ型と\nスケーリングに変換されます。\n1 番目の入力は、精度 {0} を持っています。\n2 番目の入力は、変換を実行するたびに\n桁落ちする可能性のある精度 {1} を持っています。\n両方の入力を、各入力を完全に表すのに\n十分な範囲と精度を持つ共通のデータ型に変換するために、\nRelational Operator ブロックの前に\nData Type Conversion ブロックを挿入します。エラーのない\n比較演算になります。</entry>
    <entry key="FxpRelopCheckMismatchSlope">以下の Relational Operator ブロックは、1 番目と 2 番目の入力に対して異なる傾き調整要素を持っています。\n1 番目の入力の傾き調整要素は {0} です。\n2 番目の入力の傾き調整要素は {1} となっています。\n正味の傾きの調整は、{2} です。\nこの不一致は、Relational Operator が、小さい正の範囲を持つ入力が\n大きい正の範囲を持つ入力のデータ型とスケーリングに変換される度に\n乗算演算を必要とするために発生します。\n不一致を削除するには、入力のいずれかのスケーリングを変更してください。</entry>
    <entry key="FxpMinmaxCheckNotSame">以下の MinMax ブロックに対して、出力と入力の\nデータ型が同じではありません。ブロックが実行される度に\n変換操作が必要です。データ型を同じになるように\n変更する場合、モデルがより効率的になります。</entry>
    <entry key="FxpMinmaxCheckMinMax">以下の MinMax ブロックに対して、入力は、\n比較演算を実行する前に出力のデータ型と\nスケーリングに変換されます。\n入力は {0} から {1} の範囲を持ちますが、\n出力は、キャスト中に値域エラーが発生するような\n{2} から {3} の範囲を持ちます。\n各入力を完全に表すのに十分な範囲と\n精度を持つように、出力データ型を\n変更する場合、エラーのない演算になります。</entry>
    <entry key="FxpMinmaxCheckSlope">以下の MinMax ブロックに対して、入力は、\n比較演算を実行する前に出力のデータ型と\nスケーリングに変換されます。\n入力は、精度 {0} を持っています。\n出力は、変換を実行するたびに\n桁落ちする可能性のある精度 {1} を持っています。\n各入力を完全に表すのに十分な範囲と\n精度を持つように、出力データ型を\n変更する場合、エラーのない演算になります。</entry>
    <entry key="FxpMinmaxCheckFracSlope">以下の MinMax ブロックは、出力の傾き調整要素と等しくない\n傾き調整要素を持つ入力があります。\n入力の傾き調整要素は {0} です。\n出力の傾き調整要素は {1} となっています。\nまた、正味の傾きの調整は {2} です。\nこの不一致は、MinMax ブロックが、入力が出力のデータ型とスケーリングに\n変換される度に乗算演算を必要とするために発生しています。\nこの不一致を削除するには、入力、または、出力のいずれかのスケーリングを変更してください。</entry>
    <entry key="FxpManyMulDivSameBlock">以下の Product ブロックは、複数の乗算、または、除算演算を行うよう\n設定されています。これはサポートしますが、出力データ型が\n整数、または、固定小数点の場合、この演算は、ブロックごとに 1 つの乗算、\nまたは、1 つの除算を実行するいくつかのブロック全体を分離する演算の場合より\n良い結果になります。いくつかのブロックの使用は、中間の計算に対して\n使用されるデータ型とスケーリングを制御できます。中間の計算に対する\nデータ型の選択は、精度、値域エラー、効率性に影響します。</entry>
    <entry key="FxpManyDivSameBlock">以下の Product ブロックは、複数の除算演算を行うよう\n設定されています。数値解析の分野からの一般的な\nガイドラインは、最初にすべての分母項を一緒に乗算し、\n次に、1 つの除算のみ行うというものです。これは、\n浮動小数点と、特に、固定小数点の計算における精度と、\nしばしば速度を改善します。これは、\nProduct ブロックをカスケード接続することで Simulink で行うことができます。</entry>
    <entry key="FxpEmbedDivRoundUndef">整数の除算の生成コードの方が効率的です。符号付き整数の除算の丸めに関しては、C 言語の規格で完全には規定されていません。この仕様不足に直面した場合、除算に生成されるコード サイズは、シミュレーションとコード生成間のビットトゥルーを保証するために大きくなります。モデルの [製品ハードウェア] プロパティを使用すると、実装に固有の符号付き整数の丸め動作を指定できます。動作は現在 [未定義] に設定されています。この製品ハードウェアの情報を決定および設定することで、除算で生成されるコードのサイズを削減できます。一般的な動作では、[符号付き整数の除算の丸め] を [ゼロ方向] にします。&lt;p&gt;&lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'', ''{0}'', ''ProdIntDivRoundTo'');"&gt;[製品ハードウェア] プロパティ&lt;/a&gt;&lt;/p&gt;</entry>
    <entry key="FxpCheckDivZeroProtect">整数の除算の生成コードには、0、INT_MIN/-1、LONG_MIN/-1 で除算するなど、演算の例外を防ぐ機能が含まれます。ハードウェアによっては、演算の例外が悪影響を引き起こす場合があるため、これらの例外が致命的にならないように保護する必要があります。設計者によっては、例外を引き起こす入力の組み合わせがある場合、除算が行われないように慎重にモデルを設計することもあります。これらのモデルでは、除算演算の一部として防止コードが生成され、冗長となってしまいます。この冗長な保護コードは、[コンフィギュレーション パラメーター] ダイアログ ボックスの固定小数点の除算設定を使用して削除できます。この設定は、モデルで除算演算の例外が発生しないことを慎重に検証した場合にのみ行う必要があります。&lt;p&gt;&lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'', ''{0}'', ''NoFixptDivByZeroProtection'');"&gt;[除算演算の例外を防ぐコードの削除]&lt;/a&gt;&lt;/p&gt;</entry>
    <entry key="FxpEmbeddedHardwareNotMicro">効率的な C コード生成に関するモデル アドバイザーの一部のチェックは、モデルの製品ハードウェアのデバイスに対応する設定により、スキップされる場合があります。ASIC または FPGA ターゲットなどの製品ハードウェア デバイスの場合、C コードは適切ではありません。モデルの [製品ハードウェア] プロパティは、[コンフィギュレーション パラメーター] ダイアログ ボックスの [ハードウェア実行] ペインの上部で指定します。C コード生成に固有のチェックを有効にするには、char 当たりのビット数などのターゲット C コンパイラ プロパティが表示されるように、[製品ハードウェア] のデバイスを変更してください。&lt;p&gt;&lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'', ''{0}'', ''ProdHWDeviceType'');"&gt;[製品ハードウェア] プロパティ&lt;/a&gt;&lt;/p&gt;</entry>
    <entry key="FxpCheckCmpToZero">以下の Compare To Zero ブロックでパラメーター オーバー フローが発生しました。このブロックは入力データ型を使用して 0 を表します。入力データ型 {0} は正確には 0 を表すことができないため、値は最も近い表現可能な値に飽和されました。\nこの問題を修正するには、0 を表すことができる入力データ型を選択します。    </entry>
    <entry key="FxpCheckCmpToConst">以下の Compare To Constant ブロックでパラメーター オーバー フローが発生しました。このブロックは入力データ型を使用して定数値パラメーターを表します。定数値パラメーター {0} は、入力データ型 {1} が表すことのできる範囲外にあります。指定した値は、表現可能な最も近い値になります。\nこの問題を修正するには、定数値パラメーターを表すことができる入力データ型を選択するか、定数値パラメーターを変更して入力データ型と一致させます。</entry>
    <entry key="FxpCheckCmpToConstAlwaysTrue"> このブロックは入力データ型 {0} を使用して定数値パラメーター {1} を表します。指定された関係演算子の場合、このブロックの出力は常に true になります。\n この問題を修正するには (1) このブロックを出力が true である定数ブロックで置き換えることを検討するか、(2) {2} を超える値を表すことができるように入力データ型を変更します。</entry>
    <entry key="FxpCheckCmpToConstAlwaysFalse"> このブロックは入力データ型 {0} を使用して定数値パラメーター {1} を表します。指定された関係演算子の場合、このブロックの出力は常に false になります。\n この問題を修正するには (1) このブロックを出力が false である定数ブロックで置き換えることを検討するか、(2) {2} を超える値を表すことができるように入力データ型を変更します。</entry>
    <entry key="MADisableSignalLoggingT">信号のログを無効</entry>
    <entry key="MADisableSignalLoggingTTip">不必要な信号のログを無効</entry>
    <entry key="MAActionDisableSignalLogging">すべてのログを取った信号で信号のログを無効にします。</entry>
    <entry key="MADisableSignalLoggingFail">以下の表は、ログが有効な信号をリストします。</entry>
    <entry key="MADisabledSignalLoggingFor">{0} の信号に対するログを無効にします。 </entry>
    <entry key="MANoPortFound">信号線が見つかりません。</entry>
    <entry key="MAErrAnalyzingLoggingFail">信号のログの解析に失敗しました。</entry>
    <entry key="MASignalAnalysisResult">信号解析の結果</entry>
    <entry key="MASignalCategory">信号カテゴリ</entry>
    <entry key="MASignalCount">固有の信号カウント</entry>
    <entry key="MASignalCurrentlyLogEnabled">ログを取る</entry>
    <entry key="MASignalCurrentlyLogDisabled">ログを取らない</entry>
    <entry key="MAAll">すべて</entry>
    <entry key="MAErrUpdateModelFailTit">モデルを更新できません</entry>
    <entry key="MAErrUpdateModelFailMsg">モデルを更新できません。 {0}  {1}</entry>
    <entry key="MAPassed">パス</entry>
    <entry key="MAFailed">失敗</entry>
    <entry key="MAModifyAll">すべて変更</entry>
    <entry key="MATitleDetectReusableSubsystemNotReused">Detect サブシステムは再利用可能として設定されていますが、1 回しか使用されません</entry>
    <entry key="MADetectReusableSubsystemNotReusedWarningMsg">以下の Subsystem ブロックは &lt;b&gt;[関数のパッケージ化]&lt;/b&gt; オプションを &lt;code&gt;[再利用可能な関数]&lt;/code&gt; に指定しますが、ブロックは一度しか使用されません。これにより、生成コードでブロックの実行効率が低下する可能性があります。以下のブロックについては、&lt;b&gt;[関数のパッケージ化]&lt;/b&gt; を &lt;code&gt;[自動]&lt;/code&gt; に設定してください。</entry>
    <entry key="MADescrDetectReusableSubsystemNotReused">&lt;b&gt;[関数のパッケージ化]&lt;/b&gt; を &lt;tt&gt;[再利用可能な関数]&lt;/tt&gt; に指定しても一度しか使用されないサブシステムを特定します。</entry>
    <entry key="MADetectReusableSubsystemNotReusedRecAction">上記のブロックについては、&lt;b&gt;[関数のパッケージ化]&lt;/b&gt; を &lt;code&gt;[自動]&lt;/code&gt; に設定してください。</entry>
    <entry key="MATitleCheckEnableMemcpy">効率最適化パラメーターをチェック</entry>
    <entry key="MATitletipCheckEnableMemcpy">&lt;b&gt;[実行効率性]&lt;/b&gt; または &lt;b&gt;[ROM 効率性]&lt;/b&gt; の目的に依存する最適化パラメーターを特定します。</entry>
    <entry key="MACheckEnableMemcpyResultNA">モデルは &lt;b&gt;[ROM 効率性]&lt;/b&gt; または &lt;b&gt;[実行効率性]&lt;/b&gt; の目的を使用していません。</entry>
    <entry key="MACheckEnableMemcpyResultWarning">モデルは &lt;b&gt;{0}&lt;/b&gt; の目的を使用しています。&lt;b&gt;[ベクトルの割り当てに対して memcpy を使用]&lt;/b&gt; がオフになっています。</entry>
    <entry key="MACheckEnableMemcpyResultPassed">&lt;ul&gt;&lt;li&gt;モデルは次の目的を使用しています: &lt;b&gt;{0}&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;[ベクトルの割り当てに対して memcpy を使用]&lt;/b&gt; が選択されています&lt;/li&gt;&lt;/ul&gt;</entry>
    <entry key="MATitletipDetectReusableSubsystemNotReused">Detect Subsystem は再利用可能として 設定されていますが、1 回しか再利用されません</entry>
    <entry key="slprof_hilite_usage">使用法:slprofile_hilite_system([''encoded-path'',] ''block-name'')</entry>
    <entry key="slprof_unhilite_usage">使用法:slprofile_unhilite_system(system_name)</entry>
    <entry key="badEncPath">予期せぬエンコード パス</entry>
    <entry key="openReportFileWritable">書き込み用レポートを開くときのエラー</entry>
    <entry key="slprofNotMATLABWebBrowser">MATLAB Web ブラウザーにプロファイル レポートを開くことができません。Simulink モデルへのハイパーリンクは、MATLAB Web ブラウザーでのみ機能します。</entry>
    <entry key="slprofBrowserNotFound">レポートを保存しましたが Web ブラウザーが見つかりません</entry>
    <entry key="slprofBrowserNotLaunched">レポートを保存しましたが Web ブラウザーを起動できません</entry>
    <entry key="assertExtModeCallback">注意:メインのエントリ ポイント内に認識されないアクションがあります。</entry>
    <entry key="errExtModeConfigDialog">エクスターナル モードの設定ダイアログ内でエラー</entry>
    <entry key="extModeOpenInvCommand">M アサート: コマンドが無効です。</entry>
    <entry key="extModeOpenGenericError">''{0}'' コマンドを実行で下記エラーが生成されました:\n\n{1}</entry>
    <entry key="extModeOpenUnknownUpInfoIdx">M アサート: upInfo インデックスが不明です。</entry>
    <entry key="extModeOpenUnhandledDataType">データ型を扱えません:\n{0}</entry>
    <entry key="extModeOpenSLRTAppNotLoaded">''{0}'' アプリケーションがターゲットに読み込まれていません。</entry>
    <entry key="extModeOpenSLRTTrigSigNotFound">選択したトリガー信号がスコープに対して存在しません: {0}。</entry>
    <entry key="extModeOpenSLRTInvalidUpInfoType">UpInfoType の値が無効です。</entry>
    <entry key="extModeOpenSLRTScopesOutOfScope">スコープが削除されました。シミュレーションを続けることはできません。</entry>
    <entry key="extModeOpenSLRTScopeWillNotUpload">スコープ ''{0}'' は信号をアップロードしません。</entry>
    <entry key="extModeOpenSLRTTargetPCNotDefined">接続プロセスが失敗しました。ターゲット PC ''{0}'' は定義されていません。</entry>
    <entry key="extModeOpenSLRTAddSignalCopyBlock">''{0}'' の入力信号はアップロードできません。SignalCopy ブロックを ''{1}'' の入力端子に追加することを検討してください。</entry>
    <entry key="extModeOpenSLRTTgtConnNoStreamingMulticore">''{0}'' アプリケーションは信号データを SDI と Simulink Dashboard にストリームできません。ターゲットはマルチコア用に構成されていなければなりません。</entry>
    <entry key="extModeOpenSLRTTgtConnNoStreamingConnect">''{0}'' アプリケーションは信号データを SDI と Simulink Dashboard にストリームできません。ターゲットの接続に失敗しました。</entry>
    <entry key="extModeOpenSLRTTgtConnNoStreamingSDI">''{0}'' アプリケーションは信号データを SDI と Simulink Dashboard にストリームできません。SDI の開始に失敗しました。</entry>
    <entry key="extModeOpenSLRTUnobservableSignal">信号 ''{0}'' は ''{1}'' から観測できません。</entry>
    <entry key="SLFeatureNotEnoughArgs">入力引数が不足しています。</entry>
    <entry key="SLFeatureInvalidCall">slfeature への呼び出しが無効です。</entry>
    <entry key="AddExecEventListenerInvalidInputArgs">3 つの入力引数が必要です。</entry>
    <entry key="AddExecEventListenerRequireOneOutputArg">''add_exec_event_listener'' の出力は、リスナーがアクティブである期間中、変数に割り当てる必要があります。</entry>
    <entry key="AddExecEventListenerOnlyToNonVirtualBlocks">''{0}'' のブロック メソッドの実行イベントに対するリスナーの追加はサポートされていません。リスナーは非バーチャル ブロックにのみ追加できます。</entry>
    <entry key="AddExecEventListenerOnlyDuringExecuting">''{0}'' のブロック メソッドの実行イベントに対するリスナーの追加はサポートされていません。リスナーは、ブロック線図の実行時にのみ追加できます。</entry>
    <entry key="SFunctionWizardJaveNotEnabled">現時点では、このプラットフォームで、Java が完全に有効ではありません。S-Function の書き方については、Writing S-functions を参照してください。</entry>
    <entry key="SfunBuilderBusNotFound">バスがワークスペース内で見つかりません</entry>
    <entry key="hmiSLTgtEmptyTagInputArg">タグの入力は空にできません。</entry>
    <entry key="hmiSLTgtIncorrectlyFormedTag">タグは正しく整形されていません。</entry>
    <entry key="encPathArgsMustBeStrings">すべての入力引数は文字ベクトルでなければなりません。</entry>
    <entry key="decPathFirstArgError">エンコード パスである 1 番目の引数は文字ベクトルでなければなりません。</entry>
    <entry key="decPathSecondArgError">2 番目の引数は、パスの残りとモデル名を結合するためにあり、true または false でなければなりません。</entry>
    <entry key="enc2normalpathFirstArgError">エンコード パスである 1 番目の引数は文字ベクトルでなければなりません。</entry>
    <entry key="ConflictConfigSetRefStateflowTargets">モデル ''{0}'' において、Stateflow の sfun ターゲットの設定が、コンフィギュレーション参照と競合しています。コンフィギュレーション セットが新たに作成され、モデルのアクティブなコンフィギュレーション セットとして設定されています。新規のコンフィギュレーション セットは変数 ''{1}'' からの値で構成されますが、シミュレーション ターゲット パラメーターは Stateflow の sfun ターゲット設定から来ています。コンフィギュレーション参照は一時的に非アクティブとしてマークされています。''updatecsref'' を使用して競合を解決し、コンフィギュレーション参照を元のアクティブな状態に戻してください。詳しい情報については ''help updatecsref'' と入力してください。</entry>
    <entry key="PotentialConflictConfigSetRefStateflowTargets">モデル ''{1}'' の読み込み時に、Stateflow の sfun ターゲット設定を ''{0}'' に格納できません。モデルを読み込む前にコンフィギュレーション セット オブジェクト ''{2}'' をベース ワークスペースに読み込んでください。</entry>
    <entry key="UpdatecsrefProgressMessage1">\nステップ 2-1: モデル ファイルを解析\n----------------------------------</entry>
    <entry key="UpdatecsrefProgressMessage2">\nステップ 2-2: Stateflow の sfun ターゲット設定を比較し、モデルとコンフィギュレーション セットを更新\n---------------------------------------------------------------------------------------------</entry>
    <entry key="UpdatecsrefConfigSetRefNotFound">更新するコンフィギュレーション参照はありません。</entry>
    <entry key="UpdatecsrefExitUpdatecsref">\nupdatecsref が存在します。</entry>
    <entry key="UpdatecsrefModelUpdated">\n以下のモデル ファイルは更新されました。</entry>
    <entry key="UpdatecsrefWSVarUpdated">\n以下のベースワーク スペース オブジェクトは更新されました。</entry>
    <entry key="UpdatecsrefUpdateMATFile">MAT ファイルを更新するためにベース ワークスペース内の現在の値を使用してください。</entry>
    <entry key="UpdatecsrefAppendDescription">以下は ''{0}'' の ''description'' に追加されます</entry>
    <entry key="UpdatecsrefIgnoreWSVar">オブジェクト ''{0}'' を更新する必要はありません。</entry>
    <entry key="UpdatecsrefChangeWSVar">続けてオブジェクト ''{0}'' を変更しますか?(Y/n)</entry>
    <entry key="UpdatecsrefSetActiveConfigSet">''{0}'' をモデル ''{1}'' のアクティブなコンフィギュレーション セットとして設定しますか? (Y/n)</entry>
    <entry key="UpdatecsrefOnlyConfigSetRef">アクティブなコンフィギュレーション セットとして使用されます。続けますか? (Y/n)</entry>
    <entry key="UpdatecsrefOnlyConfigSetRefisActive">    アクティブなコンフィギュレーション セットとして使用されます。</entry>
    <entry key="UpdatecsrefChooseConfigSetRef">アクティブなコンフィギュレーション セットとして有効なコンフィギュレーション参照を選択してください (既定では [1]):</entry>
    <entry key="UpdatecsrefWSVarUpdatedSuccessfully">オブジェクト ''{0}'' は正常に更新されました。</entry>
    <entry key="UpdatecsrefModelUpdatedSuccessfully">モデル ''{0}'' は正常に更新されました。</entry>
    <entry key="UpdatecsrefUpdateParameter">パラメーター ''{0}'' (''{1}'') は ''{2}'' から ''{3}'' に変更されます</entry>
    <entry key="UpdatecsrefWSVarUsedBy">''{0}'' は次で使用されます</entry>
    <entry key="UpdatecsrefConfigSetRefinMdl">コンフィギュレーション参照 ''{0}'' (モデル ''{1}'')</entry>
    <entry key="UpdatecsrefDifferentParameterValue">''{0}'' と ''{1}'' は、パラメーター ''{2}'' に対して異なる値を持っています。</entry>
    <entry key="UpdatecsrefUpdatedAlready">モデル ''{0}'' は既に更新されています。</entry>
    <entry key="UpdatecsrefNoConfigSetRef">モデル ''{0}'' は無視されます。コンフィギュレーション参照を使用しません。</entry>
    <entry key="UpdatecsrefInvalidConfigSetRef">モデル ''{0}'' 内で以下の無効なコンフィギュレーション参照が見つかりました。</entry>
    <entry key="UpdatecsrefNeedValidConfigSetRef">updatecsref を実行する前に、モデル ''{0}'' に対する有効なコンフィギュレーション参照を与えてください。</entry>
    <entry key="UpdatecsrefValidConfigSetRef">モデル ''{0}'' 内で以下の有効なコンフィギュレーション参照が見つかりました。</entry>
    <entry key="UpdatecsrefQuit">[{0}] 終了</entry>
    <entry key="UpdatecsrefConfigSetRefValue">[{0}] コンフィギュレーション参照 ''{1}'' はコンフィギュレーション セット オブジェクト ''{2}'' を指しています</entry>
    <entry key="UpdatecsrefConfigSetRefInfoBase">コンフィギュレーション参照 ''{0}'' はコンフィギュレーション セット オブジェクト ''{1}'' を指しています</entry>
    <entry key="UpdatecsrefInvalidConfigSetRef1">しかし、''{0}'' が存在しません </entry>
    <entry key="UpdatecsrefInvalidConfigSetRef2">しかし、''{0}'' がコンフィギュレーション セット オブジェクトではありません</entry>
    <entry key="UpdatecsrefIntroduction">updatecsref はコンフィギュレーション参照の更新スクリプトです。R2008b において、Stateflow\nsfun ターゲット設定は、Stateflow シミュレーション ターゲット ダイアログ ボックスから\nコンフィギュレーション セットのシミュレーション ターゲット パラメーターに移りました。\nコンフィギュレーション参照により同じコンフィギュレーション セット オブジェクトを共有する\nモデルがある場合、updatecsref はそのようなモデルが同じ Stateflow の sfun ターゲット設定を\nもつかどうかをチェックし、これらの設定をその共有のコンフィギュレーション セット オブジェクトに移動させます。\n</entry>
    <entry key="UpdatecsrefNeedModelFiles">コンフィギュレーション参照を使用するモデル ファイルのリストを与えてください。\n</entry>
    <entry key="UpdatecsrefNeedCloseModelFiles">以下のモデルを閉じてください。</entry>
    <entry key="UpdatecsrefRequirements1">updatecsref を実行する前に以下のことを行ってください。\n1. コンフィギュレーション参照を使用するモデル ファイルのリストを検出します。\n   コンフィギュレーション参照を使用しないモデルはあっても無視されます。\n   このリストに含まれない、コンフィギュレーション参照を使用するモデルについては、\n   その Stateflow sfun ターゲット設定が、共有されたコンフィギュレーション セット\n   オブジェクト内の設定と同じではない場合、モデルの読み込み時に警告が出されます。</entry>
    <entry key="UpdatecsrefRequirements2">2. いくつかのモデルが updatecsref を使用せず既に更新されている場合、\n   所望の Stateflow の sfun ターゲット設定がアクティブなコンフィギュレーション セットの\n   シミュレーション ターゲット パラメーター内にあることを確認してください。</entry>
    <entry key="UpdatecsrefRequirements3">3. リスト内のすべてのモデル ファイルのバックアップを取ります。ベース ワークスペース内の\n   共有コンフィギュレーション セット オブジェクトを作成する MAT ファイルまたは MATLAB ファイルのバックアップを取ってください。</entry>
    <entry key="UpdatecsrefRequirements4">4. すべての開いているモデル ファイルを閉じてください。</entry>
    <entry key="UpdatecsrefRequirements5">5.共有されるコンフィギュレーション セット オブジェクトをベース ワークスペースに読み込みます。データ\n ディクショナリ内のオブジェクトは省略できます。モデルで\n自動的に読み込まれるオブジェクトは省略できます。しかし、モデル ファイルのリストの\n前に関連するモデル名を入れてください。</entry>
    <entry key="UpdatecsrefRequirements6">6. updatecsref(''mdlfilename1'',''mdlfilename2'',...) のように、モデル ファイル名のリストを updatecsref に与えてください</entry>
    <entry key="UpdatecsrefRequirements7">7. ワークスペースの共有コンフィギュレーション セットのオブジェクトを\nコンフィギュレーション参照ファイルに保存し戻してください。\n</entry>
    <entry key="UpdatecsrefUnknownFileName">ファイル ''{0}'' が存在しません。</entry>
    <entry key="UpdatecsrefLoadingModel">\n''{0}'' を解析中</entry>
    <entry key="UpdatecsrefUpdatingModel">\n''{0}'' を更新中</entry>
    <entry key="UpdatecsrefNoStateflow">モデル ''{0}'' は無視されます。Stateflow チャートがありません。</entry>
    <entry key="UpdatecsrefResolveDiffParam">\nモデルを更新し、上記のパラメーターごとに同じ値を持たせるようにしてください。</entry>
    <entry key="lbCannotRemoveLockFile">内部エラー: ロック ファイル {0} を削除できません</entry>
    <entry key="SimulationOutputWhoEmpty">この Simulink.SimulationOutput オブジェクトには編集可能なプロパティが含まれていません</entry>
    <entry key="SimulationOutputWhoHeading">この Simulink.SimulationOutput オブジェクトには次の編集可能なプロパティが含まれています。</entry>
    <entry key="SimulationOutputDispGetNoLinks">''get'' を使用して名前で変数にアクセスします。</entry>
    <entry key="SimulationOutputDispGet">&lt;a href="matlab: help {0}/get"&gt;get&lt;/a&gt; を使用して名前で変数にアクセスします。</entry>
    <entry key="SimulationOutputArrDispHeading"> Simulink.SimulationOutput 配列</entry>
    <entry key="SimulationOutputDispMetadata">&lt;a href="matlab: help {0}/getSimulationMetadata"&gt;getSimulationMetadata&lt;/a&gt; を使用してシミュレーションについてのメタデータにアクセスします。</entry>
    <entry key="SimulationOutputDispMetadataNoLinks">''getSimulationMetadata'' を使用してシミュレーションについてのメタデータにアクセスします。</entry>
    <entry key="SimulationOutputDispEmpty">    空</entry>
    <entry key="SimulationMetadataCreationError"> 次の理由により、Simulink.SimulationMetadata を作成できません: </entry>
    <entry key="SimulationMetadataUserStringDatatypeMismatch">UserString は char 型でなければなりません</entry>
    <entry key="RegRuleInvalidSignature">シグネチャが無効です。入力引数 ''{0}'' には文字ベクトルのセル配列が必要です。</entry>
    <entry key="RegRuleInvalidRuleSet">継承ルールが無効です。</entry>
    <entry key="RegRuleInvalidChar">ルール ''{0}'' には不正な文字 '{' ''|'', '''{''', '''}''' '','' '}' のいずれかが含まれています。</entry>
    <entry key="RegRuleInvalidPrefix">ルール ''{0}'' は ''Inherit: '' で始まりません。</entry>
    <entry key="cpreprocessorUnsupportedPlatform">現在のプラットフォームでは cpreprocessor はサポートされません</entry>
    <entry key="cpreprocessorcppfailure">入力ファイルを前処理できません。\n cpreprocessor からの出力は {0} です</entry>
    <entry key="cpreprocessorcppoutput">C プリプロセッサからのメッセージ:\n{0}</entry>
    <entry key="cpreprocessorFileNotFound">ファイル {0} が見つかりません。</entry>
    <entry key="lci_accesslegacywsInternalError">内部エラー。{0} が見つかりません</entry>
    <entry key="BaseWSVarInconsistentValueWithLegacyCode">変数 ''{0}'' の値は、レガシ コード内の値と異なります</entry>
    <entry key="DirectoryCreationFailure">''{0}'' に作業ディレクトリを作成できません</entry>
    <entry key="FileCreationFailure">ファイル ''{0}'' (''{1}'') を作成できません</entry>
    <entry key="InconsistentTargetWordSpec">C データ型のターゲットの語長が一致しません</entry>
    <entry key="InconsistentTargetWordLength">C の ''{0}'' 型はシミュレーションでは {1,number,integer} ビットとして表されますが、ターゲット ハードウェアでは {2,number,integer} ビットです。</entry>
    <entry key="LegacySymbolisReserved">古い形式のシンボル ''{0}'' は、優先順位の高い Simulink の ''{1}'' の既定の定義が存在する可能性があります。</entry>
    <entry key="CTypeNotSupported">古い形式のシンボル ''{0}'' の C の型は Simulink でサポートされません</entry>
    <entry key="CTypeWordLengthNotSupported">Simulink は語長 ({0,number,integer} ビット) (古い形式のシンボル {1}) をサポートしません</entry>
    <entry key="LegacySymbolUnknownDimension">''{0}'' の次元が不明です</entry>
    <entry key="LegacySymbolZeroDimension">''{0}'' の次元には要素がありません</entry>
    <entry key="InlineParamsOff">コード生成時に古い形式のシンボルを統合するには、''[コンフィギュレーション パラメーター] &gt; [コード生成] &gt; [最適化] &gt; [既定のパラメーター動作]'' を [インライン] に設定しなければなりません。</entry>
    <entry key="LegacyDataTypeNameUsedByBaseWSVar">C データ型 {0} (古い形式のシンボル {1} で使用) は、同じ名前を持つ優先順位の高いベース ワークスペース変数が存在する可能性があります。{2} のタイプ名としてブロック線図を表示することはできません。</entry>
    <entry key="CTypeNotSupportedHoweverUsedbyBaseWSVar">古い形式のシンボル ''{0}'' の C の型は Simulink でサポートされません。しかし、対応するオブジェクト ''{1}'' のデータ型は ''{2}'' です</entry>
    <entry key="CTypeWordLengthNotSupportedHoweverUsedbyBaseWSVar">Simulink は語長 ({0,number,integer} ビット) (古い形式のシンボル {1}) をサポートしません。しかし、対応するオブジェクト ''{2}'' のデータ型は ''{3}'' です</entry>
    <entry key="WrongStorageClass">{0} は既にレガシ コードに定義されています。ただし、オブジェクト {1} のストレージ クラスが {2} であるため、生成される定義が重複する可能性があります。ストレージ クラスを ImportedExtern、ImportedExternPointer、Custom のいずれかに変更してください</entry>
    <entry key="BaseWSVarWrongDatatype">古い形式のシンボル {0} は Simulink 内で {1} でなければなりません。しかし、対応するオブジェクト {2} のデータ型は {3} です</entry>
    <entry key="FailtoGetSystemHeaderPath">システム ヘッダー ファイルのパスを特定できません</entry>
    <entry key="ObjectiveCustomizerNotInitialized">ObjectiveCustomizer は初期化されていません。&lt;a href="matlab:sl_refresh_customizations"&gt;sl_refresh_customizations&lt;/a&gt; コマンドを実行してください。</entry>
    <entry key="ObjectiveCustomizerInitializationFailure">Java が無効のため、ObjectiveCustomizer を初期化できません。ObjectiveCustomizer を正常に初期化するには、-nojvm 開始オプションを付けずに MATLAB を再起動してください。</entry>
    <entry key="badCheckIDError">''{0}'' の目的は、無効なモデル アドバイザーのチェック ID (''{1}'') を含んでいます。有効なモデル アドバイザーのチェック ID を指定し、sl_refresh_customizations を実行してください。ファイルは {2} にあります。</entry>
    <entry key="badCheckIDErrorMsgBoxTitle">エラー</entry>
    <entry key="PreDefinedCheckError">''{0}'' はあらかじめ定義されたチェックです。\n</entry>
    <entry key="ExistingAdditionalCheckError">''{0}'' は既存の追加チェックです。\n</entry>
    <entry key="multipleSLCustomizationFiles">1 つの sl_customization.m のみ目的のカスタマイズ API に対して許可されています。\n</entry>
    <entry key="repeatedOrderError">''{0}'' と ''{1}'' は同じ次数を持っています: {2,number,integer}\n</entry>
    <entry key="invalidCSParameterError">''{0}'' は有効な設定パラメーターではありません。\n</entry>
    <entry key="existedCSParameterError">''{0}'' は既にオブジェクティブ ''{1}'' に存在します。\n</entry>
    <entry key="noNameSpecifiedCSParameterError">設定パラメーターに対して指定された名前がありません。\n</entry>
    <entry key="noValueSpecifiedCSParameterError">設定パラメーターに対して指定された値がありません: ''{0}''。\n</entry>
    <entry key="existedCheckError">''{0}'' は既にオブジェクティブ ''{1}'' (''{2}'' に関連する) に存在します。\n</entry>
    <entry key="dependencyViolatedAbsentError">目的 ''{0}'' において、パラメーター ''{1}'' は追加されていない ''{2}'' に依存します。\n</entry>
    <entry key="dependencyViolatedWrongValueError">目的 ''{0}'' において、パラメーター ''{1}'' は正しく設定されていない値 ''{2}'' に依存します。\n</entry>
    <entry key="noNameSpecifiedCheckError">チェックに対して指定された名前がありません。\n</entry>
    <entry key="invalidBaseObjective">目的 ''{0}'' が存在しません。\n</entry>
    <entry key="invalidBaseObjectiveAsCell">セル配列は基本目的として利用できません。\n</entry>
    <entry key="CSParameterNotExistedInBase">''{0}'' は基本目的 ''{1}'' に存在しません。\n</entry>
    <entry key="checkNotExistedInBase">''{0}'' は基本目的 ''{1}'' に存在しません。\n</entry>
    <entry key="noBaseError">''{0}'' には基本目的がありません。\n</entry>
    <entry key="duplicatedObjName">''{0}'' は重複する目的名です。別の目的名を選択してください。\n</entry>
    <entry key="duplicatedObjID">''{0}'' は重複する目的 ID です。固有の目的 ID を指定してください。\n</entry>
    <entry key="invalidObjectiveID">''{0}'' は無効な目的 ID です。有効な文字は数値、文字、''_'' です。</entry>
    <entry key="invalidObjectiveName">目的名 ''{0}'' が無効です。\n目的名は、英字、または ''_'' で始まり、\nかつ、英字、番号、'' ''、''_'' のみを含んでいなければなりません。</entry>
    <entry key="disallowedCheck">''{0}'' は、ブロック線図の更新で共通のモデル アドバイザーのユーティリティを使用しないため許可されません。</entry>
    <entry key="noParamError">目的 ''{0}'' に定義されたパラメーターがありません。</entry>
    <entry key="badOutputArgumentName">引数名 ''{0}'' が無効です。''-format''、''-comments'' または ''-varname'' を指定します。</entry>
    <entry key="badOutputFileName">出力ファイル名 ''{0}'' が無効です。出力ファイル名は英字で始まり、使用できるのは英字、数字、''_'' のみです。</entry>
    <entry key="badOutputFileNameDirectory">ディレクトリ (''{0}'') は存在しません。</entry>
    <entry key="badOutputFileNameExtension">''{0}'' は有効な拡張子ではありません。使用できるのは ''.m'' のみです。</entry>
    <entry key="badFileNameExtension">''{0}'' は有効な拡張子ではありません。使用できるのは ''.m'' および ''.mat'' のみです。</entry>
    <entry key="badOutputRedundantArg">{0} は複数回指定されています。</entry>
    <entry key="badOutputConflict">''{0}'' は ''{1}'' に設定されています。そのため、''{2}'' を ''{3}'' に設定することはできません。</entry>
    <entry key="badOutputVariableName">''-varname'' の値 ''{0}'' が無効です。有効な変数名を指定してください。</entry>
    <entry key="badOutputFormat">''-format'' の値 ''{0}'' が無効です。[MATLAB 関数] または [MATLAB スクリプト] を指定してください。</entry>
    <entry key="badOutputComments">''-comments'' の値 ''{0}'' が無効です。''on'' または ''off'' を指定してください。</entry>
    <entry key="badOutputUpdate">''-update'' の値 ''{0}'' が無効です。''true'' または ''false'' を指定してください。</entry>
    <entry key="unwritableError">''{0}'' を正常に作成できません。</entry>
    <entry key="badVersion1">1 番目のパラメーターは有効なバージョン番号ではありません。</entry>
    <entry key="badVersion2">2 番目のパラメーターは有効なバージョン番号ではありません。</entry>
    <entry key="MFileParametersWithNoUI">[コンフィギュレーション パラメーター] ダイアログ ボックスにはないパラメーター</entry>
    <entry key="MFileNotConfigSetError">入力パラメーターは有効なコンフィギュレーション セットではありません。</entry>
    <entry key="MFileUnsuccessful">エラー:</entry>
    <entry key="MFileVersionViolation">ターゲットのコンフィギュレーション セットのバージョンはオリジナルのコンフィギュレーション セットより古いです。</entry>
    <entry key="MFileTimestamp">{0} で生成されるコンフィギュレーション セットの MATLAB 関数</entry>
    <entry key="MFileVersion">MATLAB バージョン: {0}</entry>
    <entry key="MFileOrder1">以下のコマンドの順序を変更しないでください。パラメーター間に依存関係があります。</entry>
    <entry key="MFileOrder2">以下のコマンドには依存関係がありません。</entry>
    <entry key="MFileTargetSpecific">以下はターゲット特有のパラメーターです。</entry>
    <entry key="MFileOriginalConfigSetVersion">オリジナルのコンフィギュレーション セットのバージョン</entry>
    <entry key="MFileOriginalEncoding">文字エンコード</entry>
    <entry key="MFileBridgeComponentNotSupported">製品固有のコンポーネントを含む Simulink.ConfigSet オブジェクトは、モデル エクスプローラーでベース ワークスペースから .m ファイルとしてエクスポートできません。Simulink.ConfigSet オブジェクトを .m ファイルとしてエクスポートするには、このオブジェクトをモデルに付加してからエクスポートするか、関数 saveAs を使用します。</entry>
    <entry key="MFileNotSupportforLib">コンフィギュレーション セットの saveAs メソッドはライブラリでサポートされていません。</entry>
    <entry key="MFilePane">ペイン</entry>
    <entry key="MFileGeneralPane">一般</entry>
    <entry key="NoReferencedModel">モデル ''{0}'' には参照モデルが含まれません。 </entry>
    <entry key="CSRefPropagationPBarTitle">参照モデルへの伝播</entry>
    <entry key="CSRefPropagationPBarFindRMLabel">参照モデルを探しています</entry>
    <entry key="CSRefPropagationPBarModelLabel">参照モデル: </entry>
    <entry key="MFileDefaultToERT">''''システム ターゲット ファイル'''' を ''''ert.tlc'''' に設定しています。</entry>
    <entry key="FileAlreadyExists">ターゲットの文字エンコード ({0}) はオリジナル ({1}) と違います。</entry>
    <entry key="CSVersionCompareWrongInput">誤った入力</entry>
    <entry key="CSVersionCompareSameVersion">同じバージョン</entry>
    <entry key="CSVersionCompareEarlierVersion">前のバージョン</entry>
    <entry key="CSVersionCompareLaterVersion">後のバージョン</entry>
    <entry key="MATitletipFcnCallUsageCheck">関数呼び出しの接続性に適用され、モデルの実行に影響する可能性のあるモデル診断設定をチェックします。</entry>
    <entry key="MATitleFcnCallUsageCheck">関数呼び出し接続の使用をチェック</entry>
    <entry key="MAFcnCallUsageCheckActionButtonName">設定の変更</entry>
    <entry key="MAFcnCallUsageCheckActionDescription">モデル コンフィギュレーションの診断設定を変更してください。</entry>
    <entry key="FcnCallUsageSubTitle1">[コンテキスト依存の入力] 設定をチェックします</entry>
    <entry key="FcnCallUsageInfo1">&lt;b&gt;[コンテキスト依存の入力]&lt;/b&gt; 診断が &lt;tt&gt;[エラー]&lt;/tt&gt; に設定されていることを確認します。 </entry>
    <entry key="FcnCallUsagePassMsg1">&lt;b&gt;[診断] &gt; [接続性] &gt; [コンテキスト依存の入力]&lt;/b&gt; が &lt;tt&gt;[エラー]&lt;/tt&gt; に設定されています。</entry>
    <entry key="FcnCallUsageFailMsg1">&lt;b&gt;[診断] &gt; [接続性] &gt; [コンテキスト依存の入力]&lt;/b&gt; は &lt;tt&gt;{0}&lt;/tt&gt; に設定されています。これは不確定なモデル実行になる可能性があります。</entry>
    <entry key="FcnCallUsageRecAction">{0} を &lt;tt&gt;[エラー]&lt;/tt&gt; に設定してください。</entry>
    <entry key="FcnCallUsageHyperLink1">[診断] &gt; [接続性] &gt; [コンテキスト依存の入力]</entry>
    <entry key="slVarStructAlreadyExists">変数 ''{0}'' は既に存在します。</entry>
    <entry key="slVarStructCreatedVariableGlobalWS">モデルで認識されるグローバル名前空間で変数 ''{0}'' を作成しました。</entry>
    <entry key="slVarStructNonStructArgument">変数 ''{0}'' は構造体ではありません。</entry>
    <entry key="slVarStructDuplicatedNodes">構造体 ''{0}'' のリーフ ノード名を複製:\n{1}</entry>
    <entry key="slPVInvalidNumPVInputs">パラメーター/値の組み合わせの入力引数の数が無効です。</entry>
    <entry key="slPVNotStringPVInputs">パラメーター/値の組み合わせは文字ベクトルでなければなりません。</entry>
    <entry key="slPVUnrecognizedPInputs">パラメーター ''{0}'' が認識されません。</entry>
    <entry key="slPVUnrecognizedVInputs">パラメーター ''{0}'' は値 ''{1}'' を受け入れません。必要な値: {2}。</entry>
    <entry key="slPVDuplicatedPInputs">パラメーター ''{0}'' は重複しています。</entry>
    <entry key="indexedGroupItems_InvalidN">''getIndexedGroupItems'' に渡される列の数 ''N'' が無効です。列の数は正の整数でなければなりません。</entry>
    <entry key="indexedGroupItems_InvalidStretch">行の最初のエントリとして "ストレッチ" を指定することはできません。行は、有効なウィジェットまたは "空白" で始まらなければなりません。</entry>
    <entry key="indexedGroupItems_InvalidOpt">''getIndexedGroupItems'' は ''空白'' または ''ストレッチ'' にする必要があります。</entry>
    <entry key="Finder_NotEnoughInputs">入力引数が不足しています。</entry>
    <entry key="Finder_RequiresJava">[検索] ダイアログでは Java がサポートされている必要があります。</entry>
    <entry key="Finder_SystemNotFound">システム ''{0}'' が存在しません。</entry>
    <entry key="Finder_FailedForSimulink">Simulink オブジェクトで失敗した操作を検索します。</entry>
    <entry key="Finder_FailedForStateflow">Stateflow オブジェクトで失敗した操作を検索します。</entry>
    <entry key="Finder_HandleNotFound">選択したオブジェクトが見つかりません。このエラーは、検索を実行した後でモデルを閉じたり編集したりすると、発生する可能性があります。検索を再実行して、オブジェクトを検索できるようにしなければなりません。</entry>
    <entry key="cannotOpenFile">保存エラー。ファイル ''{0}'' を開けません。</entry>
    <entry key="evalFileFailed">''{0}'' の実行中にエラーが発生しました。エラー メッセージ: {1}</entry>
    <entry key="ModelVarStructNoChangesApplied">モデル ''{0}'' に変更が適用されませんでした</entry>
    <entry key="ParserConfig">''選択されている'' コンパイラが見つかりません。mex -setup を実行する必要があります。</entry>
    <entry key="DependencyViewerParseError">findDependencies:''{0}'' パラメーターを解釈できません。{1} であることを確認してください。</entry>
    <entry key="csOpenProlog">{0} のプロローグ</entry>
    <entry key="csOpenEpilog">{0} のエピローグ</entry>
    <entry key="csOpenTitleBar">{0} カスタム コード</entry>
    <entry key="ccOpenTopOf">{0} の最上位</entry>
    <entry key="ccOpenBottomOf">{0} の最下位</entry>
    <entry key="ccOpenDeclarationCode">{0} 宣言コード</entry>
    <entry key="ccOpenExecutionCode">{0} 実行コード</entry>
    <entry key="ccOpenExitCode">{0} 終了コード</entry>
    <entry key="ccOpenCustomCode">{0} カスタム コード</entry>
    <entry key="connectionAndTriggeringMsg">接続とトリガー</entry>
    <entry key="floatingScopeMsg">フローティング スコープ</entry>
    <entry key="enableUpload">データ アップロードを有効にする</entry>
    <entry key="durationLabel">持続時間</entry>
    <entry key="parameterTuningLabel">パラメーター調整</entry>
    <entry key="configurationLabel">構成</entry>
    <entry key="externalModeCtrlPanel">エクスターナル モード コントロール パネル</entry>
    <entry key="externalDataArchiving">外部データをアーカイブする</entry>
    <entry key="editFileNote">ファイル ノートの編集</entry>
    <entry key="ModelAdvisorFileIntegrityTaskTitle">Simulink モデル ファイルの整合性</entry>
    <entry key="ModelAdvisorFileIntegrityTaskTitleTips">ファイルの整合性を確認できるようにチェックします。</entry>
    <entry key="SLXModelPropertyTaskTitle">モデル履歴プロパティをチェック</entry>
    <entry key="SLXModelPropertyTaskModifyActionName">プロパティのリセット</entry>
    <entry key="SLXModelPropertyTaskModifyActionDesc">モデル履歴プロパティを既定値に置き換えます。</entry>
    <entry key="SLXModelPropertyTaskDisplayName">編集されたモデル履歴プロパティ値をもつモデルをチェック</entry>
    <entry key="SLXModelPropertyTaskDescription">ソース管理ツールのキーワード代入で使用可能な編集されたモデル履歴プロパティ値がないかどうか、モデルをチェックします。このキーワード代入は、SLX ファイル形式と互換性がありません。</entry>
    <entry key="SLXModelPropertyTaskInfo">[モデル プロパティ] ダイアログの [履歴] ペインにあるパラメーターが既定のタグを使用することをチェックしてください。MDL ファイル形式では、一部のモデル プロパティを構成して、ソース管理ツールのキーワード代入を利用できます。モデルを SLX 形式で保存する場合、ソース管理ツールではキーワード代入を実行できません。そのようなキーワード代入からのモデル ファイル内の情報は、MDL ファイルを SLX として最初に保存するときにキャッシュされ、再度更新されることはありません。それ以降、モデル内の [モデル プロパティ履歴] ペインと Model Info ブロックでは、古い情報が表示されることになります。</entry>
    <entry key="SLXModelPropertySuccessOne">このモデルはプロパティ {0} の既定値を使用します。</entry>
    <entry key="SLXModelPropertyFailOne">このモデルのプロパティ {0} は、"{1}" の値をもちます。既定値は "{2}" です。</entry>
    <entry key="SLXModelPropertyRecAction">[プロパティのリセット] ボタンをクリックして、これらのプロパティを既定値にリセットします。</entry>
    <entry key="SLXModelPropertyRecWorked">プロパティ {0} を既定値 {1} に設定します。</entry>
    <entry key="SLXModelPropertyRecFailed">プロパティ {0} を設定できませんでした:</entry>
    <entry key="ModelInfoKeywordSubstitutionTaskTitle">外部のソース管理ツールと交信できる Model Info ブロックの特定</entry>
    <entry key="ModelInfoKeywordSubstitutionTaskDescription">キーワード代入を介した外部のソース管理ツールによる変更が必要な、Model Info ブロックを特定します。このチェックは、外部のソース管理ツールによる上書きが可能な、ドル記号で囲まれた Model Info ブロック内のテキストを検索します。キーワード代入はモデルを破損させる可能性があるため推奨されません。</entry>
    <entry key="ModelInfoKeywordSubstitutionBlockTitle">Model Info ブロックが見つかりました: ''{0}''</entry>
    <entry key="ModelInfoKeywordSubstitutionKWSDescription">Model Info ブロック ''{0}'' には、キーワード代入を使用して外部のソース管理ツールが MDL ファイルを上書きできるようにする可能性のあるテキストが含まれています。キーワード代入はモデルを破損させる可能性があるため推奨されません。このテキストを検証し、手動で削除するには、Model Info ブロック ''&lt;a href="matlab:open_system(''{0}'');"&gt;{0}&lt;/a&gt;'' を開きます。テキストは次のとおりです:&lt;br/&gt;{1}&lt;br/&gt;</entry>
    <entry key="ModelInfoKeywordSubstitutionKWSDescriptionSLX">Model Info ブロック ''{0}'' にはドル記号で囲まれたテキストが含まれています。これにより、外部のソース管理ツールは、キーワード代入を使用して MDL ファイルを上書きできるようになりました。キーワード代入は SLX ファイルでは機能しません。このテキストを検証し、手動で削除するには、Model Info ブロック ''&lt;a href="matlab:open_system(''{0}'');"&gt;{0}&lt;/a&gt;'' を開きます。テキストは次のとおりです:&lt;br/&gt;{1}&lt;br/&gt;</entry>
    <entry key="CGFESecondArgNotAString">2 番目の入力引数は文字ベクトルでなければなりません。</entry>
    <entry key="CGFEThirdArgNotAString">3 番目の入力引数は文字ベクトルでなければなりません。</entry>
    <entry key="CGFESecondAndThirdArgNotAString">2 番目と 3 番目の入力引数は文字ベクトルでなければなりません。</entry>
    <entry key="CGFESecondArgNotAClassOf">2 番目の入力引数は、{0} オブジェクトでなければなりません。</entry>
    <entry key="CGFEPropertyValueNotInSet">''{0}'' プロパティの値は許可された一連の値に属しません。</entry>
    <entry key="CGFEPropertyValueNotUInt32">''{0}'' プロパティの値は uint32 の範囲内に収まらなければなりません。</entry>
    <entry key="CGFEPropertyValueNotInt32">''{0}'' プロパティの値は int32 の範囲内に収まらなければなりません。</entry>
    <entry key="CGFEPropertyValueNotBool">''{0}'' プロパティの値は論理データ型でなければなりません。</entry>
    <entry key="CGFEPropertyValueNotString">''{0}'' プロパティの値は文字ベクトルでなければなりません。</entry>
    <entry key="CGFEPropertyValueNotEnumString">''{0}'' プロパティの値は列挙値に対応する文字ベクトルでなければなりません。</entry>
    <entry key="CGFEPropertyValueNotClassOf">''{0}'' プロパティの値はクラス ''{1}'' に属さなければなりません。</entry>
    <entry key="CGFEPropertyValueNotCellStr">''{0}'' プロパティの値は文字ベクトルのセルでなければなりません。</entry>
    <entry key="FENoMexCompilerForLang">''{0}'' 言語用に設定された mex コンパイラがありません。コンパイラを指定するには、コマンド "mex -setup" を実行します。</entry>
    <entry key="CodeGenAdvisor">コード生成アドバイザー(&amp;A)</entry>
    <entry key="CodeGenAdvisorTab">コード生成アドバイザー</entry>
    <entry key="CodeGenAdvisorForSubSystem">コード生成アドバイザー(&amp;A)</entry>
    <entry key="CGACheckObj">&lt;b&gt;現在の目的:&lt;/b&gt; &lt;font color="#0000FF"&gt;{0}&lt;/font&gt;&lt;br&gt; コード生成の目的は、モデル ({1}) で設定された目的とは異なります。[パラメーターの変更] ボタンをクリックし、現在の目的をモデルに格納してください。</entry>
    <entry key="CGACheckObjEqual">&lt;b&gt;現在の目的:&lt;/b&gt; &lt;font color="#0000FF"&gt;{0}&lt;/font&gt;&lt;br&gt;</entry>
    <entry key="CGAReport">コード生成アドバイザー レポート</entry>
    <entry key="MATitleOldMaskTabnamesConversion">MaskTabNames パラメーターを使用してマスク ダイアログのタブを指定するマスク ブロックを特定</entry>
    <entry key="MATitletipOldMaskTabnamesConversion">MaskTabNames パラメーターを使用して、マスク ダイアログにタブをプログラムで作成するマスク ブロックを特定します。R2013b 以降では、ダイアログ コントロールは、マスク ダイアログ上のタブにパラメーターをグループ化するために使用されます。</entry>
    <entry key="MALogNoOldMaskTabnamesConversionRequired">MaskTabNames を使用してマスク ダイアログでタブを作成するマスク ブロックは見つかりませんでした。</entry>
    <entry key="MALogUpgradeOldMaskTabnamesConversion">次のブロックは、MaskTabNames パラメーターを使用します。タブにダイアログ コントロールを使用するには、''{0}'' をクリックしてこれらのブロックを変換します。</entry>
    <entry key="MAUpgradeButtonOldMaskTabnamesConversion">アップグレード</entry>
    <entry key="MAActionOldMaskTabnamesConversion">MaskTabNames を使用してマスク ダイアログでタブを作成するマスク ブロックをアップグレードします。</entry>
    <entry key="MALogOldMaskTabnamesConversionDone">次のマスク ブロックが正常にアップグレードされ、タブ ダイアログ コントロールを使用できるようになりました。変更を保存して、チェックを再実行してください。</entry>
    <entry key="MAConvert">変換</entry>
    <entry key="MAUnitInconsTaskTitle">単位の不一致</entry>
    <entry key="MAUnitInconsTaskTitleTips">単位の不一致チェックを実行します</entry>
    <entry key="MAUnitInconsOutPortStr">出力端子</entry>
    <entry key="MAUnitInconsInPortStr">入力端子</entry>
    <entry key="MAUnitsInconsDst1Units">変換元 1 の単位</entry>
    <entry key="MAUnitsInconsDst2Units">変換元 2 の単位</entry>
    <entry key="MAUnitsInconsBusObjUnits">バス要素の単位</entry>
    <entry key="MAUnitsInconsSrcUnits">変換元単位</entry>
    <entry key="MAUnitsInconsDstUnits">変換先の単位</entry>
    <entry key="MATitleIdentUnitMismatchPairs">モデル内の単位の不一致を特定</entry>
    <entry key="MATitletipIdentUnitMismatchPairs">モデル内で単位が一致しないブロックのペアを特定します。</entry>
    <entry key="MAInfoIdentUnitMismatchPairs">モデル内の単位の不一致をチェックしてください。</entry>
    <entry key="MARawTitleIdentUnitMismatchPairs">単位の不一致をチェック</entry>
    <entry key="MAFailIdentUnitMismatchPairsSingular">単位の不一致が 1 件見つかりました。</entry>
    <entry key="MAFailIdentUnitMismatchPairs">単位の不一致が {0,number,integer} 件見つかりました。</entry>
    <entry key="MAPassIdentUnitMismatchPairs">単位の不一致は見つかりませんでした。</entry>
    <entry key="MADetailUnitMismatchPairs">単純な単位の変換で解決できない単位の不一致の詳細は、次の表を参照してください。</entry>
    <entry key="MAcol1UnitMismatchPairs">変換元</entry>
    <entry key="MAcol2UnitMismatchPairs">変換先</entry>
    <entry key="MAcol5UnitMismatchPairs">不一致のタイプ</entry>
    <entry key="MADetailUnitMismatchBus">入力バスとの単位の不一致の詳細は、次の表を参照してください。</entry>
    <entry key="MAcol1UnitBusMismatchPairs">ブロック</entry>
    <entry key="MAcol2UnitBusMismatchPairs">ソース 1</entry>
    <entry key="MAcol3UnitBusMismatchPairs">ソース 2</entry>
    <entry key="MADetailUnitMismatchBusObj">バス オブジェクトとの単位の不一致の詳細は、次の表を参照してください。</entry>
    <entry key="MAcol1UnitBusObjMismatchPairs">ブロック</entry>
    <entry key="MAcol2UnitBusObjMismatchPairs">バス要素</entry>
    <entry key="MAcol3UnitBusObjMismatchPairs">バス オブジェクト</entry>
    <entry key="MADetailUnitMismatchConstBlocks">Constant ブロック内での単位の不一致の詳細については、次の表を参照してください。</entry>
    <entry key="MAcol1UnitMismatchConstBlocks">ブロック</entry>
    <entry key="MAUnitsInconsConstValueUnits">値パラメーターの単位</entry>
    <entry key="MAUnitsInconsConstValueTypeUnits">ValueType の単位</entry>
    <entry key="MADetailUnitPhysicalQuantityMismatch">物理量のみの単位の不一致の詳細については、次の表を参照してください。</entry>
    <entry key="MAcol1UnitPhysicalQuantityMismatch">ブロック</entry>
    <entry key="MAUnitsInconsPhysicalQuantityMismatchUnit">単位</entry>
    <entry key="MAUnitsInconsPhysicalQuantityMismatchPhysicalQuantity">PhysicalQuantity</entry>
    <entry key="MAcol1UnitLoadingMismatchPairs">不一致の位置</entry>
    <entry key="MAcol2UnitLoadingMismatchPairs">指定した単位</entry>
    <entry key="MAcol3UnitLoadingMismatchPairs">データ単位</entry>
    <entry key="MADetailUnitMismatchLoading">外部データの読み込み時に検出された単位の不一致の詳細は、次の表を参照してください。</entry>
    <entry key="MAcol1UnitParamMismatchPairs">ブロック</entry>
    <entry key="MAcol2UnitParamMismatchPairs">パラメーター</entry>
    <entry key="MAcol3UnitParamMismatchPairs">パラメーターの単位</entry>
    <entry key="MAcol4UnitParamMismatchPairs">変数</entry>
    <entry key="MAcol5UnitParamMismatchPairs">変数の単位</entry>
    <entry key="MADetailUnitMismatchParameter">ブロック パラメーターとその値の間の単位の不一致の詳細については、次の表を参照してください。</entry>
    <entry key="MATitleIdentUnitAutoConv">モデル内の自動単位変換を特定</entry>
    <entry key="MATitletipIdentUnitAutoConv">モデル内に挿入された自動単位変換を特定します。</entry>
    <entry key="MAInfoIdentUnitAutoConv">自動単位変換がないかどうかをチェックします。</entry>
    <entry key="MARawTitleIdentUnitAutoConv">自動単位変換をチェック</entry>
    <entry key="MAWarnIdentUnitAutoConvSingular">1 つのコンポーネント ペア間に自動単位変換が挿入されています。詳細については、次の表を参照してください:</entry>
    <entry key="MAWarnIdentUnitAutoConv">{0,number,integer} 個のコンポーネント ペア間に自動単位変換が挿入されています。詳細については、次の表を参照してください:</entry>
    <entry key="MAPassIdentUnitAutoConv">自動単位変換は見つかりませんでした。</entry>
    <entry key="MACol1UnitAutoConv">変換位置</entry>
    <entry key="MACol4UnitAutoConv">追加のメッセージ</entry>
    <entry key="MADetailUnitAutoConvUnsuccessful">単位の不一致により失敗した位置の詳細は、次の表を参照してください。これらの不一致を解決するには、Unit Conversion ブロックを追加してください。</entry>
    <entry key="MACol1UnitAutoConvUnsuccessful">変換の実行位置</entry>
    <entry key="MACol1UnitAutoConvUnsuccessfulReason">原因</entry>
    <entry key="MAEfficientTunableParamExprTitle">非効率的な飽和コードを生成するコンフィギュレーション パラメーターをチェック</entry>
    <entry key="MAEfficientTunableParamExprTips">非効率的な飽和コードの生成につながる可能性のあるコンフィギュレーション パラメーターを特定します。</entry>
    <entry key="MAEfficientTunableParamExprMsg1">範囲外の値を処理する飽和コード生成の設定をチェックします。このコードは、アプリケーションの正味効率を下げます。</entry>
    <entry key="MAEfficientTunableParamExprActionDesciption">上記のコンフィギュレーション パラメーターを推奨値に変更してください。</entry>
    <entry key="MATitleIdentDisallowUnitSys">モデル内の許可されていない単位系を特定</entry>
    <entry key="MATitletipIdentDisallowUnitSys">モデル内で許可されていない単位系が使用されているかどうかを特定します。</entry>
    <entry key="MAInfoIdentDisallowUnitSys">許可されていない単位系についてチェックします。</entry>
    <entry key="MARawTitleIdentDisallowUnitSys">許可されていない単位系をチェック</entry>
    <entry key="MAWarnIdentDisallowUnitSysSingular">許可されていない単位系が 1 箇所で見つかりました。</entry>
    <entry key="MAWarnIdentDisallowUnitSys">許可されていない単位系が {0,number,integer} 箇所で見つかりました。</entry>
    <entry key="MAPassIdentDisallowUnitSys">許可されていない単位系は見つかりませんでした。</entry>
    <entry key="MADetailDisallowUnitSysInBlocks">モデル内のブロックで使用されている許可されていない単位系の詳細については、次の表を参照してください:</entry>
    <entry key="MACol1DisallowUnitSys">使用場所</entry>
    <entry key="MACol2DisallowUnitSys">使用されている単位</entry>
    <entry key="MACol3DisallowUnitSys">許可された単位系</entry>
    <entry key="MADetailDisallowUnitSysInParamObjs">ブロック パラメーターの参照先オブジェクトで使用されている、許可されていない単位系の詳細については、次の表を参照してください。</entry>
    <entry key="MACol1DisallowUnitSysParamObj">使用場所</entry>
    <entry key="MACol2DisallowUnitSysParamObj">使用されている単位</entry>
    <entry key="MACol3DisallowUnitSysParamObj">許可された単位系</entry>
    <entry key="MACol4DisallowUnitSysParamObj">ブロック パラメーターで参照</entry>
    <entry key="MACol5DisallowUnitSysParamObj">オブジェクト タイプ</entry>
    <entry key="MACol6DisallowUnitSysParamObj">オブジェクト名</entry>
    <entry key="MADetailDisallowUnitSysInSignalObjs">モデル内の Simulink.Signal オブジェクトで許可されていない単位系の使用の詳細については、次の表を参照してください:</entry>
    <entry key="MACol1DisallowUnitSysSignalObj">使用場所</entry>
    <entry key="MACol2DisallowUnitSysSignalObj">使用されている単位</entry>
    <entry key="MACol3DisallowUnitSysSignalObj">許可された単位系</entry>
    <entry key="MACol4DisallowUnitSysSignalObj">信号オブジェクト</entry>
    <entry key="MATitleIdentUndefinedUnits">モデル内の未定義の単位を特定</entry>
    <entry key="MATitletipIdentUndefinedUnits">未定義の単位が使用されていないかどうかを特定します。</entry>
    <entry key="MAInfoIdentUndefinedUnits">未定義の単位がないかどうかをチェックします。</entry>
    <entry key="MARawTitleIdentUndefinedUnits">未定義の単位をチェックします。</entry>
    <entry key="MAWarnIdentUndefinedUnitsSingular">未定義の単位が 1 箇所で見つかりました。</entry>
    <entry key="MAWarnIdentUndefinedUnits">未定義の単位が {0,number,integer} 箇所で見つかりました。</entry>
    <entry key="MADetailUndefinedUnitsInBlocks">モデル内のブロックで使用されている未定義の単位の詳細については、下の表を参照してください。指定された単位を [提案] 列にある単位に置き換えることを検討してください。</entry>
    <entry key="MAPassIdentUndefinedUnits">未定義の単位は見つかりませんでした。</entry>
    <entry key="MACol1UndefinedUnits">使用されている単位</entry>
    <entry key="MACol2UndefinedUnits">ブロック</entry>
    <entry key="MASuggColUndefinedUnits">提案</entry>
    <entry key="MADetailUndefinedUnitsInObjs">モデルで参照しているオブジェクトで使用されている未定義の単位の詳細については、下の表を参照してください。指定された単位を [提案] 列にある単位に置き換えることを検討してください。</entry>
    <entry key="MACol1UndefinedUnitsInObjs">使用されている単位</entry>
    <entry key="MACol2UndefinedUnitsInObjs">使用場所</entry>
    <entry key="MACol3UndefinedUnitsInObjs">オブジェクトタイプ</entry>
    <entry key="MACol4UndefinedUnitsInObjs">オブジェクト名</entry>
    <entry key="MACol1IncompatibleSimscapeUnits">使用されている Simscape の単位</entry>
    <entry key="MACol2IncompatibleSimscapeUnits">ブロック</entry>
    <entry key="MADetailIncompatibleSimscapeUnits">モデルの参照先 Simulink の単位と互換性のない Simscape の単位の使用に関する詳細は、次の表を参照してください。</entry>
    <entry key="UnitsBadgeDescriptionTitle">詳細は、以下を参照してください</entry>
    <entry key="UnitsMismatchFixSuggestionRow1">推奨アクション (次のいずれかを実行):</entry>
    <entry key="UnitsMismatchFixSuggestionRow2Col1">1) 接続元の単位を変更</entry>
    <entry key="UnitsMismatchFixSuggestionRow2Col2">接続元に移動</entry>
    <entry key="UnitsMismatchFixSuggestionRow3Col1">2) 接続先の単位を変更</entry>
    <entry key="UnitsMismatchFixSuggestionRow3Col2">接続先に移動</entry>
    <entry key="UnitsMismatchFixSuggestionRow4Col1">3) [] に設定されている [単位] パラメーターをもつ Signal Specification ブロックを挿入します</entry>
    <entry key="MATitleIdentAmbiguousUnits">モデル内のあいまいな単位を特定</entry>
    <entry key="MATitletipIdentAmbiguousUnits">あいまいな単位の使用を特定します。</entry>
    <entry key="MAInfoIdentAmbiguousUnits">あいまいな単位がないかチェックします。</entry>
    <entry key="MARawTitleIdentAmbiguousUnits">あいまいな単位をチェック。</entry>
    <entry key="MAWarnIdentAmbiguousUnitsSingular">あいまいな単位が 1 か所で見つかりました。</entry>
    <entry key="MAWarnIdentAmbiguousUnits">あいまいな単位が {0,number,integer} か所で見つかりました。</entry>
    <entry key="MADetailAmbiguousUnitsInBlocks">モデル内のブロックで使用されているあいまいな単位の詳細については、下の表を参照してください。指定した単位を [提案] 列に示されているもので修正することを検討してください。</entry>
    <entry key="MAPassIdentAmbiguousUnits">あいまいな単位は見つかりませんでした。</entry>
    <entry key="MACol1AmbiguousUnits">使用されている単位</entry>
    <entry key="MACol2AmbiguousUnits">ブロック</entry>
    <entry key="MASuggColAmbiguousUnits">提案</entry>
    <entry key="MADetailAmbiguousUnitsInObjs">モデルが参照するオブジェクトで使用されているあいまいな単位の詳細については、下の表を参照してください。指定した単位を [提案] 列に示されているもので修正することを検討してください。</entry>
    <entry key="MACol1AmbiguousUnitsInObjs">使用されている単位</entry>
    <entry key="MACol2AmbiguousUnitsInObjs">使用場所</entry>
    <entry key="MACol3AmbiguousUnitsInObjs">オブジェクト タイプ</entry>
    <entry key="MACol4AmbiguousUnitsInObjs">オブジェクト名</entry>
    <entry key="EditTimeMismatchUnitAttr">単位</entry>
    <entry key="EditTimeMismatchDataTypeAttr">データ型</entry>
    <entry key="EditTimeMismatchComplexityAttr">実数/複素数</entry>
    <entry key="EditTimeMismatchDimensionsAttr">次元</entry>
    <entry key="EditTimeMismatchPortHeader">端子</entry>
    <entry key="EditTimeMismatchSourcePort">接続元</entry>
    <entry key="EditTimeMismatchDestPort">接続先</entry>
    <entry key="EditTimeMismatchDestPortSelection">接続先端子</entry>
    <entry key="EditTimeMismatchTitle">属性の矛盾</entry>
    <entry key="EditTimeMismatchAttribute">属性</entry>
    <entry key="EditTimeMismatchSummary">属性が不一致の接続先端子が {0} 個見つかりました。</entry>
    <entry key="ErrorApplyingHotParamTitle">エラー</entry>
    <entry key="MASFunAnalyzerTaskTitle">S-Function チェック</entry>
    <entry key="MASFunAnalyzerTaskTitleTips">S-Function チェックを実行します</entry>
    <entry key="MATitleSFunctionAnalyzerCheck">モデルの S-Function をチェック</entry>
    <entry key="MATitletipSFunctionAnalyzerCheck">S-Function チェックを実行します</entry>
    <entry key="MAInfoSFunctionAnalyzerCheck">モデルの S-Function をチェックし、潜在的な問題と改善点をレポートします。</entry>
    <entry key="MAFailSFunctionAnalyzerCheck">S-Function チェックが失敗しました。</entry>
    <entry key="MAPassSFunctionAnalyzerCheck">S-Function チェックがパスしました。</entry>
    <entry key="MAWarnSFunctionAnalyzerCheck">S-Function チェックに警告があります。</entry>
    <entry key="MASFunAnalyzerReport">詳細については、&lt;a href="matlab:Simulink.sfunction.analyzer.openReport(''{0}'');"&gt;S-Function チェック レポート&lt;/a&gt;を開いてください。</entry>
    <entry key="MANoUserSfunctions">モデル内にユーザー定義の S-Function がありません。</entry>
    <entry key="MASFcnMexAnalyzerTaskTitle">S-Function のアップグレードの問題がないかモデルをチェックします</entry>
    <entry key="MASFcnMexAnalyzerTaskTitleTips">S-Function をチェックし、互換性の問題を特定します</entry>
    <entry key="MASFcnMexAnalyzerCheckTitle">S-Function のアップグレードの問題がないかモデルをチェックします</entry>
    <entry key="MASFcnMexAnalyzerCheckTitleTips">S-Function をチェックし、互換性の問題を特定します</entry>
    <entry key="MAInfoSFcnMexAnalyzerCheck">モデルの S-Function をチェックし、アップグレードの問題と改善点をレポートします。</entry>
    <entry key="MAPassSFcnMexAnalyzerCheck">S-Function のアップグレードのチェックにパスしました。</entry>
    <entry key="MASubTitleENOEVER">カスタムビルドのバイナリ MEX ファイル</entry>
    <entry key="MASubInfoENOEVER">S-Function がカスタムビルドの MEX ファイルを使用しているかどうかをチェックします。</entry>
    <entry key="MAComplaintENOEVER">以下の S-Function は、サポートされていないカスタムビルドの MEX ファイルを使用します。</entry>
    <entry key="MASubTitleELNKCPP">互換性のない C++ コンパイル オプション</entry>
    <entry key="MASubInfoELNKCPP">C++ S-Function が互換性のないオプションでコンパイルされていないかをチェックします。</entry>
    <entry key="MAComplaintELNKCPP">以下の S-Function は、互換性のないオプションでコンパイルされた MEX ファイルに関連付けられています。</entry>
    <entry key="MASubTitleELNKAPI">互換性のない MEX コンパイル オプション</entry>
    <entry key="MASubInfoELNKAPI">S-Function が互換性のないオプションでコンパイルされていないかをチェックします。</entry>
    <entry key="MAComplaintELNKAPI">以下の S-Function は、互換性のないオプションでコンパイルされています。</entry>
    <entry key="MASubTitleEVERAPI">互換性のないコンパイルとリンク</entry>
    <entry key="MASubInfoEVERAPI">S-Function が互換性のないオプションでコンパイルされ、リンクされていないかをチェックします。</entry>
    <entry key="MAComplaintEVERAPI">以下の S-Function のコンパイルとリンクのオプションは互換性がありません。</entry>
    <entry key="MASubTitleEUNKAPI">サポートされない関数</entry>
    <entry key="MASubInfoEUNKAPI">S-Function が将来のリリースでコンパイルされるかどうかをチェックします。</entry>
    <entry key="MAComplaintEUNKAPI">以下の S-Function は将来のリリースでコンパイルされていますが、現在のリリースではサポートされていません。</entry>
    <entry key="MASubTitleURECOMP">再コンパイルが必要</entry>
    <entry key="MASubInfoURECOMP">S-Function が旧式の API でコンパイルされていないかをチェックします。</entry>
    <entry key="MAComplaintURECOMP">以下の S-Function は最新の API でコンパイルされていません。</entry>
    <entry key="MASubTitleULATEST">データ アクセス関数</entry>
    <entry key="MASubInfoULATEST">コンパイルされた S-Function に型なしのデータ アクセス関数がないかをチェックします。</entry>
    <entry key="MAComplaintULATEST">以下の S-Function は型なしのデータ アクセス関数を 1 つ以上呼び出します。</entry>
    <entry key="MASubTitleUCOMPAT">非推奨の関数</entry>
    <entry key="MASubInfoUCOMPAT">コンパイルされた S-Function に非推奨の関数がないかをチェックします。</entry>
    <entry key="MAComplaintUCOMPAT">以下の S-Function は非推奨の関数を 1 つ以上呼び出します。</entry>
    <entry key="MASubTitleULEGACY">互換性のない 32 ビットの関数</entry>
    <entry key="MASubInfoULEGACY">コンパイルされた S-Function に 32 ビットの関数がないかをチェックします。</entry>
    <entry key="MAComplaintULEGACY">以下の S-Function は 32 ビットの関数を 1 つ以上呼び出します。</entry>
    <entry key="MASubTitleUENTRYP">欠損 Entrypoint</entry>
    <entry key="MASubInfoUENTRYP">S-Function に有効な entrypoint が含まれているかをチェックします。</entry>
    <entry key="MAComplaintUENTRYP">以下の S-Function はエントリ ポイントを含まないため、MATLAB では実行されません。これはおそらく、S-Function で ''simulink.c'' がインクルードされていないことが原因です。</entry>
    <entry key="MAAddtlInfoUENTRYP">C MEX S-Function の一般的な形式については、ドキュメンテーションを参照してください。</entry>
    <entry key="CodeBrowserInvalidFileName">コード ブラウザー: 無効なファイル名:  {0}</entry>
    <entry key="MaxIdentifierErrorInConfigParameters">この競合は、[コンフィギュレーション パラメーター] ダイアログ ボックスの [識別子] ペインで識別子の最大の長さを増加させるか、あるいは競合する識別子の名前を変更することで解決する場合があります。</entry>
    <entry key="CGAParallelNotSupported">コード生成アドバイザーは並列ビルドではサポートされません。''{0}'' のモデル チェックは中止されます。この警告を無効にするには、[コンフィギュレーション パラメーター] ダイアログ ボックスで [コード生成前にモデルをチェック] を [オフ] に設定します。</entry>
    <entry key="PrefixForCompileCheck">^</entry>
    <entry key="MAMsgContSrcLocation">&lt;tr&gt;&lt;td&gt;&lt;a href="matlab:modeladvisorprivate(''hiliteSystem'',''{0}'');"&gt;{1}&lt;/a&gt;&lt;/td&gt;&lt;td align="right"&gt;{2,number,integer}&lt;/td&gt;&lt;td align="right"&gt;{3,number,integer}&lt;/td&gt;&lt;td align="right"&gt;{4,number,integer}&lt;/td&gt;&lt;/tr&gt;</entry>
    <entry key="rapidAccelTgtConnParamDownloadWarning">{0}</entry>
    <entry key="MADiscreteIntegratorCheckDiscreteIntegrator">Discrete-Time Integrator</entry>
    <entry key="LCTErrorRethrowErrorWithSpec">{1}:\n{0}</entry>
    <entry key="LCTSpecParserBadSizeSyntax">{1}:\n{0}</entry>
    <entry key="extModeOpenSLRTWarning">{0}</entry>
    <entry key="SFunctionWizardInvalidArgs">{0}</entry>
    <entry key="SimulationOutputDispHeading">Simulink.SimulationOutput:</entry>
    <entry key="ParserMessage">{0}</entry>
  </message>
</rsccat>
