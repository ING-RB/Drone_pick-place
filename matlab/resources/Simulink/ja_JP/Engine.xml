<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ja_JP" product="Simulink" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="ModelCompileDuringSymbolLookup">ブロック パラメーターは、そのブロック自体がもつブロック線図 ''{0}'' を参照できません。</entry>
    <entry key="AVT_LicenseError">設計を変換するために必要な Simulink Design Verifier のライセンスを照合できません。</entry>
    <entry key="AbsoluteTimeNotSupported">ブロック ''{0}'' は、現在の設定でサポートされていない絶対時間が使われています。&lt;sldiag objui="configset" objparam="SupportAbsoluteTime"&gt;[絶対時間のサポート]&lt;/sldiag&gt; を選択することを検討してください。</entry>
    <entry key="InvCallToSubstituteCS">substituteTmpConfigSetForBuild および restoreOrigConfigSetForBuild への呼び出しが無効です。これらは、2 つの引数で呼び出されなければならず、また戻り値がありません。</entry>
    <entry key="InvalidModelRefTargetTypeForVmExecution">モデル参照ターゲット タイプ ''{0}'' は JIT アクセラレータ シミュレーションに対して無効です</entry>
    <entry key="AbortingCompilation">モデルのコンパイルを中止しています</entry>
    <entry key="AbortCompilation">モデルのコンパイルを中止しました。</entry>
    <entry key="AccErrorStatus">アクセラレータ シミュレーション ''{0}'' の実行時にエラーが報告されました。\n{1}</entry>
    <entry key="AccModelNameTooLong">アクセラレータの結果の MEX ファイル名が長すぎるため、モデル ''{0}'' を高速化できません。モデル名を変更し、名前の長さを {1,number,integer} 文字より少なくしてください。</entry>
    <entry key="AccelCodeGenError">モデル ''{0}'' に対する Accelerator MEX ファイルの作成中に問題が発生しました。</entry>
    <entry key="AccelCodeGenErrorTellAboutVerbose">モデル ''{0}'' の Accelerator MEX ファイルの作成に問題があります。\n ビルド出力を見るには、set_param(''{1}'',''AccelVerboseBuild'',''on'') を使用してください。</entry>
    <entry key="AccelJITErrorTellAboutVerbose">JIT によるモデル ''{0}'' の高速化中にエラーが発生しました。\n詳細を表示するには set_param(''{1}'',''AccelVerboseBuild'',''on'') を使用します</entry>
    <entry key="AccelJITError">JIT によるモデル ''{0}'' の高速化中にエラーが発生しました。</entry>
    <entry key="AccelInvCalltoRunBlock">sleAccRunBlock への無効な呼び出し</entry>
    <entry key="AccelMexLoadError">Accelerator MEX ファイル ''{0}'' の読み込み中にエラーが発生しました。</entry>
    <entry key="AccelNameConflict">Accelerator は高速化された mex ファイルにこの名前を使用しているため、モデル ''{0}'' は名前を変更しなければなりません。</entry>
    <entry key="AccelNotSupportedAlgLoopsWithCertainBlocks">モデル ''{0}'' の代数ループにブロック ''{1}'' が含まれているため、このモデルではアクセラレータ モードはサポートされません。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{0}'','SimulationMode','Normal')&lt;/cmd&gt; &lt;txt&gt;代わりにノーマル モードを使用してモデル ''{0}'' のシミュレーションを行う。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
	</entry>
    <entry key="AccelNotSupportedWithSFcnAPI">モデル名を関数として使用しているシミュレーションでは、アクセラレータ モードはサポートされません。</entry>
    <entry key="AccelUnableToAcqFoundFcnHdl">アクセラレータ モードでのモデル ''{0}'' のシミュレーション中に、Simulink で MATLAB 関数 ''{1}'' の一致が検出されましたが、その実行はできませんでした。この問題が発生するのは通常、検出された MATLAB 関数が目的の関数と大文字と小文字のみが異なるためです。現在のモデルの名前を変更してください。または、代替の MATLAB 関数を削除するか、その関数名を変更するか、その関数を含むフォルダーを削除して、代替の MATLAB 関数を MATLAB パスから削除してください。 </entry>
    <entry key="AccelUnableToAcqFcnHdl">MATLAB 関数 ''{0}'' のハンドルを取得できません</entry>
    <entry key="AccelBuildNoModelName">現在のモデル名を取得できません。</entry>
    <entry key="ActionECPotentialPreStartOutputDiff">''{0}'' の出力は、''{1}'' が t = 0 でアクティブ化されていない場合、以前の Simulink のリリースと異なる結果を生成する可能性があります。ブロック ''{2}'' はゼロの入力に対して非ゼロの出力を生成する可能性があり、''{3}'' の実行コンテキストが継承されています。以前のリリースでは、''{4}'' は実行コンテキストは継承されず、条件付きサブシステムの開始前に非ゼロの出力を生成した可能性があります。コンテキストを継承させないようにするには、再計算させたい信号のレートに ''{5}'' のサンプル時間を明示的に設定します。この警告メッセージをオフにするには、&lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;[実行コンテキストのアクティブになる前の出力をチェック]&lt;/sldiag&gt; をオフにしてください。</entry>
    <entry key="ActionECPotentialPreStartOutputDiffConsistentOutportInit">''{0}'' の出力は、''{1}'' が t = 0 でアクティブ化されていない場合、以前の Simulink のリリースと異なる結果を生成する可能性があります。ブロック ''{2}'' はゼロの入力に対して非ゼロの出力を生成する可能性があり、''{3}'' の実行コンテキストが継承されています。以前のリリースでは、''{4}'' は実行コンテキストは継承されず、条件付きサブシステムの開始前に非ゼロの出力を生成した可能性があります。コンテキストを継承させないようにするには、再計算させたい信号のレートに ''{5}'' のサンプル時間を明示的に設定します。この警告メッセージをオフにするには、&lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;[実行コンテキストのアクティブになる前の出力をチェック]&lt;/sldiag&gt; をオフにしてください。</entry>
    <entry key="AddDimsDependRuleCompStageMismatch">Simulink は ''{0}'' で S-function に対する ''ssAddOutputDimsDependencyRule'' の不正な使用を検出しました。この関数 SimStruct は ''mdlSetWorkWidths'' メソッドでのみ使用できます。</entry>
    <entry key="AlgLoopFrozenModesNoConvergence" context="warning">既定のアルゴリズムが時間 {1} で収束しなかったため、モード反復アルゴリズムに切り替えてブロック ''{0}'' を含む代数ループを解こうとします。解に収束するのに時間がかかるモード反復アルゴリズムを試す代わりにエラーを報告するには、次のコマンドを使用します: feature(''{2}'',0)。</entry>
    <entry key="AlgLoopFrozenModesOscilationDetected" context="warning">モード振動が原因で既定のアルゴリズムが時間 {1} で収束しなかったため、モード反復アルゴリズムに切り替えてブロック ''{0}'' を含む代数ループを解こうとします。解に収束するのに時間がかかるモード反復アルゴリズムを試す代わりにエラーを報告するには、次のコマンドを使用します: feature(''{2}'',0)。</entry>
    <entry key="AlgLoopFrozenModesTooManyModeChanges" context="warning">モードが {0,number,integer} 回を超えて変更されたことが原因で既定のアルゴリズムが時間 {2} で収束しなかったため、モード反復アルゴリズムに切り替えてブロック ''{1}'' を含む代数ループを解こうとします。解に収束するのに時間がかかるモード反復アルゴリズムを試す代わりにエラーを報告するには、次のコマンドを使用します: feature(''{3}'',0)。</entry>
    <entry key="AlgLoopNoSupportOfVarSizeSig" context="error">Block ''{0}'' is part of an algebraic loop and has variable-size inputs or outputs, which are not supported in algebraic loops.</entry>
    <entry key="AlgLoopMemoryAllocationError" context="error">Unable to allocate memory to solve the algebraic loop that contains ''{0}'' as one of {2,number,integer} total blocks in the loop. Eliminate the algebraic loop or reduce the number of algebraic variables ({1,number,integer}) in the loop.</entry>
    <entry key="AlgLoopTroubleInFixedStep">
      モデルの定義が正しくないか、システム方程式に解がないか、数値的問題が原因で代数ループのソルバーが収束しなかったため、ブロック ''{0}'' が含まれる代数ループを時間 {1} で {2}ベースのアルゴリズムを使用して解くことができません。推奨アクションを実行してもエラーが解決しない場合、モデルの定義が正しくない可能性があります。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{3}'','AlgebraicLoopSolver',''{4}'');&lt;/cmd&gt; &lt;txt&gt;代数ループ ソルバーのアルゴリズムを [自動] に変更する。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{3}'');configset.highlightParameter(''{3}'','FixedStep');&lt;/cmd&gt; &lt;txt&gt;[固定ステップ サイズ (基本サンプル時間)] パラメーターの値を小さくする。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;</entry>
    <entry key="AlgLoopTroubleInVariableStep">
      モデルの定義が正しくないか、システム方程式に解がないか、数値的問題が原因で代数ループのソルバーが収束しなかったため、ブロック ''{0}'' が含まれる代数ループを時間 {1} で {2}ベースのアルゴリズムを使用して解くことができません。推奨アクションを実行してもエラーが解決しない場合、モデルの定義が正しくない可能性があります。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{3}'','AlgebraicLoopSolver',''{4}'');&lt;/cmd&gt; &lt;txt&gt;代数ループ ソルバーのアルゴリズムを [自動] に変更する。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{3}'');configset.highlightParameter(''{3}'','RelTol');&lt;/cmd&gt; &lt;txt&gt;ソルバーのタイム ステップが小さくなるように [相対許容誤差] パラメーターの値を小さくする。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
      
    </entry>
    <entry key="SetAlgebraicLoopSolverToAutoForBlock">set_param(''{0}'', 'Solver', 'auto');</entry>
    <entry key="AlgLoopTroubleInFixedStepWithAlgebraicConstraintBlock">
      Unable to solve the algebraic loop that contains block ''{0}'' at time {1} using the {2}-based algorithm because the model is ill-defined, the system equations do not have a solution, or numerical issues prevented the algebraic loop solver from converging. If the error persists after trying the suggested actions, the model is likely ill-defined.
      &lt;actions exclusiveFixIts="yes"&gt;
      &lt;action type="fixit"&gt;
      &lt;cmd&gt;{3}&lt;/cmd&gt;
      &lt;txt&gt;Change the algebraic loop solver algorithm to "auto".&lt;/txt&gt;
      &lt;/action&gt;
      &lt;action type="suggestion"&gt;
      &lt;cmd&gt;load_system(''{4}'');configset.highlightParameter(''{4}'','FixedStep');&lt;/cmd&gt;
      &lt;txt&gt;Reduce the ''Fixed-step size (fundamental sample time)'' parameter value.&lt;/txt&gt;
	  &lt;/action&gt;
      &lt;/actions&gt;</entry>
    <entry key="AlgLoopTroubleInVariableStepWithAlgebraicConstraintBlock">
      Unable to solve the algebraic loop that contains block ''{0}'' at time {1} using the {2}-based algorithm because the model is ill-defined, the system equations do not have a solution, or numerical issues prevented the algebraic loop solver from converging. If the error persists after trying the suggested actions, the model is likely ill-defined.
      &lt;actions exclusiveFixIts="yes"&gt;
      &lt;action  type="fixit"&gt;
      &lt;cmd&gt;{3}&lt;/cmd&gt;
      &lt;txt&gt;Change the algebraic loop solver algorithm to ''auto''.&lt;/txt&gt;
      &lt;/action&gt;
      &lt;action type="suggestion"&gt;
      &lt;cmd&gt;load_system(''{4}'');configset.highlightParameter(''{4}'','RelTol');&lt;/cmd&gt;
      &lt;txt&gt;Reduce the ''Relative tolerance'' parameter value so that the solver takes smaller time steps.&lt;/txt&gt;
      &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="AlgLoopTroubleInFixedStepNoSolverSwitch">
      モデルの定義が正しくないか、システム方程式に解がないか、数値的問題が原因で代数ループのソルバーが収束しなかったため、ブロック ''{0}'' が含まれる代数ループを時間 {1} で {2}ベースのアルゴリズムを使用して解くことができません。推奨アクションを実行してもエラーが解決しない場合、モデルの定義が正しくない可能性があります。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{2}'');configset.highlightParameter(''{2}'','FixedStep');&lt;/cmd&gt; &lt;txt&gt;[固定ステップ サイズ (基本サンプル時間)] パラメーターの値を小さくする。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
      
    </entry>
    <entry key="AlgLoopTroubleInVariableStepNoSolverSwitch">
      モデルの定義が正しくないか、システム方程式に解がないか、数値的問題が原因で代数ループのソルバーが収束しなかったため、ブロック ''{0}'' が含まれる代数ループを時間 {1} で {2}ベースのアルゴリズムを使用して解くことができません。推奨アクションを実行してもエラーが解決しない場合、モデルの定義が正しくない可能性があります。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{2}'');configset.highlightParameter(''{2}'','RelTol');&lt;/cmd&gt; &lt;txt&gt;ソルバーのタイム ステップが小さくなるように [相対許容誤差] パラメーターの値を小さくする。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="AlgLoopTroubleInFixedStepWithAlgebraicConstraintBlockNoSolverSwitch">
      Unable to solve the algebraic loop that contains block ''{0}'' at time {1} using the {2}-based algorithm because the model is ill-defined, the system equations do not have a solution, or numerical issues prevented the algebraic loop solver from converging. If the error persists after trying the suggested actions, the model is likely ill-defined.
      &lt;actions exclusiveFixIts="yes"&gt;
      &lt;action type="suggestion"&gt;
      &lt;cmd&gt;load_system(''{2}'');configset.highlightParameter(''{2}'','FixedStep');&lt;/cmd&gt;
      &lt;txt&gt;Reduce the ''Fixed-step size (fundamental sample time)'' parameter value.&lt;/txt&gt;
      &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="AlgLoopTroubleInVariableStepWithAlgebraicConstraintBlockNoSolverSwitch">
      モデルの定義が正しくないか、システム方程式に解がないか、数値的問題が原因で代数ループのソルバーが収束しなかったため、ブロック ''{0}'' が含まれる代数ループを時間 {1} で {2}ベースのアルゴリズムを使用して解くことができません。推奨アクションを実行してもエラーが解決しない場合、モデルの定義が正しくない可能性があります。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{2}'');configset.highlightParameter(''{2}'','RelTol');&lt;/cmd&gt; &lt;txt&gt;ソルバーのタイム ステップが小さくなるように [相対許容誤差] パラメーターの値を小さくする。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="AlgLoopsDisabled">モデル ''{0}'' の代数ループを解くことができません。[代数ループ] パラメーターの値が [エラー] で、代数ループ ソルバーが無効になっているためです。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{0}'');configset.highlightParameter(''{0}'','AlgebraicLoopMsg');&lt;/cmd&gt; &lt;txt&gt;[代数ループ] パラメーターの値を [警告] または [なし] に変更する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
	</entry>
    <entry key="AlgStateNotFinite">ブロック "{0}" が含まれる代数ループの代数変数について、時間 {1} で Inf または NaN 値が計算されました。これは、システム方程式に特異点が含まれていることを示す可能性があります。[相対許容誤差] または [固定ステップ サイズ (基本サンプル時間)] のパラメーター値を小さくしてソルバーのステップ サイズを小さくすることを試みるか、または代数ループ変数値の初期推定を調整してください。</entry>
    <entry key="AlgebraicLoopsNotSupportedInRTWGEN">代数ループを含むモデルのコード生成はサポートされていません。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;関数 Simulink.BlockDiagram.getAlgebraicLoops を使用して、モデル内の代数ループを強調表示する。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;[コード生成およびシミュレーション用に出力メソッドと更新メソッドを結合] パラメーターをオフにする。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="AmbiguousCRLRegisteredType">タイプ ''{0}'' には、複数の定義がコード置換ライブラリで見つかりました。このタイプには、単一の定義を指定してください。</entry>
    <entry key="AmbiguousCRLAndSimDataDictType">タイプ ''{0}'' があいまいです。同じ名前の異なるタイプが、Simulink またはデータ ディクショナリに既に存在しています。このタイプには、単一の定義を指定してください。</entry>
    <entry key="ApplicationInvalid">無効なアプリケーションが指定されました</entry>
    <entry key="ArtificialAlgLoopModelRefNote">この代数ループは、代数ループの各参照モデルについて [疑似代数ループの発生の最小化] モデル パラメーターを選択することで解決する場合があります。</entry>
    <entry key="ArtificialAlgLoopNote">この代数ループは、ループ内の 1 つ以上の Atomic Subsystem または Enabled Subsystem について [疑似代数ループの発生の最小化] ブロック パラメーターを選択するか、またはループ内の参照モデルについて [疑似代数ループの発生の最小化] モデル コンフィギュレーション パラメーターを選択することで解決する場合があります。
	</entry>
    <entry key="ArtificialAlgLoopSubsystemNote">この代数ループは、ループ内にある 1 つ以上の Atomic Subsystem または Enabled Subsystem の [疑似代数ループの発生の最小化] パラメーターを選択することによって解決する場合があります。</entry>
    <entry key="AsyncGlobalDSM">モデル ''{0}'' において、グローバルな Simulink.Signal の ''{1}'' オブジェクトで定義されたグローバルなデータ ストアを参照するブロックのいくつかは、非同期のタスクで実行するように構成されています。1 つのモデル内でアクセスされる グローバルなデータ ストアは、すべて周期的なシングル タスクで実行されなければなりません。</entry>
    <entry key="AsyncRateTransBlkHasInvalidDst">Rate Transition ブロック ''{0}'' は、接続先 ''{1}'' に接続できません。接続先のブロックは、非同期に実行される関数呼び出しブロック内にあり、その優先順位は Rate Transition ブロックの出力のサンプル時間の優先順位と異なります。</entry>
    <entry key="AsyncRateTransBlkHasInvalidMultipleDsts">Rate Transition ブロック ''{0}'' に複数の接続先があります。接続先はすべて、同じサンプル時間をもつか、同じ優先順位で非同期に実行される関数呼び出しブロックでなければなりません。</entry>
    <entry key="AsyncRateTransBlkHasInvalidMultipleSrcs">Rate Transition ブロック ''{0}'' には非同期で実行される、異なるサンプル時間をもつソースが複数あります。非同期で実行されるすべてのソースでサンプル時間は同じでなければなりません。</entry>
    <entry key="BackPropDoesNotSupportND">{0,number,integer} 次元信号をブロック ''{2}'' の&lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;入力端子 {1,number,integer}&lt;/sldiag&gt; からブロック ''{4}'' の&lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;出力端子 {3,number,integer}&lt;/sldiag&gt; に伝播できません。後続のブロックは、(すべて、または現在の設定のいずれかにおいて) 2 より大きい次元をもつ信号を受け入れません。</entry>
    <entry key="BackPropDoesNotSupportNDCompSig">ブロック ''{2}'' の&lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;入力端子 {1,number,integer}&lt;/sldiag&gt; からブロック ''{4}'' の&lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;出力端子 {3,number,integer}&lt;/sldiag&gt; に少なくとも {0,number,integer} 次元信号を含む合成信号を伝播できません。後続のブロックは、(すべて、または現在の設定のいずれかにおいて) 2 より大きい次元をもつ信号を受け入れません。</entry>
    <entry key="BadFeedbackConn">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; から開始する 1 つ以上の仮想ブロックを含むフィードバック接続にエラーがあります</entry>
    <entry key="BusSourcePropBadFeedbackConn">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; から開始する 1 つ以上の仮想ブロックを含むフィードバック接続にエラーがあります</entry>
    <entry key="AutoInsertedBlocksDataListAssignmentNotAllowed">ブロック データ リストは変更可能ではないため、インデックス付き代入はサポートされていません。</entry>
    <entry key="AutoInsertedBlockDataListInvalidBlockName">無効なブロック名が指定されています。</entry>
    <entry key="AutoInsertedBlockDataListContainerNotFound">Simulink.AutoInsertedBlockDataList オブジェクトの読み込み中にコンテナー ''{1}'' の {0} が見つかりませんでした。正しいモデルを開き、オブジェクトを再読み込みしてください。</entry>
    <entry key="AutoInsertedBlockDataBlockDiagramObjectNotFound">MAT ファイルからの読み込み中に、Simulink.AutoInsertedBlockData オブジェクトの自動挿入を行うブロック ''{0}'' が見つかりませんでした。正しいモデルを開き、オブジェクトを再読み込みしてください。</entry>
    <entry key="BadInportNum">システム ''{0}'' に、入力端子 {1,number,integer} に対応するブロックがありません。端子には 1 で始まる連続した番号を付けなければなりません。</entry>
    <entry key="BadOutportNum">システム ''{0}'' に、出力端子 {1,number,integer} に対応するブロックがありません。端子には 1 で始まる連続した番号を付けなければなりません。</entry>
    <entry key="BadPropDimsInfoNoUnifyIO">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; から ''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; に次元情報を伝播できません。''{5}'' の入力次元 '{'{4}'}' の次元が多重化された出力信号 '{'{6}'}' と一致しません。</entry>
    <entry key="BadPropDimsInfoNoUnifyOI">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; から ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; に次元情報を伝播できません。多重化された出力信号 '{'{4}'}' の次元が ''{6}'' の入力次元 '{'{5}'}' と一致しません。</entry>
    <entry key="BadPropDimsInfoUnifyOI">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; で多重化された信号の次元を、''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; の入力次元に一致するように統一できません。特に、{5} に一致するように '{'{4}'}' を統一できません。そのため、''{7}'' の&lt;sldiag objui="outport" objparam="{6,number,integer}" objname="{7}"&gt;出力端子 {6,number,integer}&lt;/sldiag&gt; から ''{9}'' の&lt;sldiag objui="inport" objparam="{8,number,integer}" objname="{9}"&gt;入力端子 {8,number,integer}&lt;/sldiag&gt; に次元情報を伝播できません。</entry>
    <entry key="BadPropDimsInfoUnifyMatrixOI"> 1 つ以上の入力信号が行列タイプであるため、''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; で多重化された信号の統一次元を特定できません。特に '{'{2}'}' を統一できません。そのため、''{4}'' の&lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;出力端子 {3,number,integer}&lt;/sldiag&gt; から ''{6}'' の&lt;sldiag objui="inport" objparam="{5,number,integer}" objname="{6}"&gt;入力端子 {5,number,integer}&lt;/sldiag&gt; に次元情報を伝播できません。</entry>
    <entry key="BdNotCompiled">モデル ''{0}'' にプログラムからアクセスするには、事前にそのモデルをコンパイルしておかなければなりません。</entry>
    <entry key="BdCommandDisallowedDuringSim">モデル ''{0}'' はシミュレーション中であるため、プログラム インターフェイス経由でコマンド ''{1}'' を処理することができません。</entry>
    <entry key="BdSettingChangeNotAllowed">モデル ''{1}'' のパラメーター ''{0}'' は、コンパイルされているか、シミュレーションが実行中の場合は変更できません。</entry>
    <entry key="BdSimRunningAlready">ブロック線図 ''{0}'' のシミュレーションは現在実行中です。2 番目のシミュレーションを開始できません。</entry>
    <entry key="BdWriteCloseError">{0} の取り扱い中にファイルを閉じるときのエラーが発生しました。エラー コードは {1,number,integer} ({2}) です。</entry>
    <entry key="BdWriteInvBlockParamType">エラー。''{1}'' の S-Function ''{0}'' の mdlRTW は、無効なパラメーター タイプで ssWriteRTWParameters を呼び出しています。</entry>
    <entry key="BdWriteInvIndentLevel">{0} の書き込み中に、レコードの開始文字 '''{''' または終了文字 '''}''' の数の不一致が見つかりました。</entry>
    <entry key="BdWriteMxArrayFailure">メソッド BdWriteMxArray は失敗しました: ''{0}''</entry>
    <entry key="BdWriteParamInvComplexSig">パラメーター ''{0}'' は、実数でなければなりません。複素数パラメーターを書き込むには、SS_WRITE_VALUE_DTYPE_VECT を使用してください。</entry>
    <entry key="BdWriteParamInvParamValue">{0} パラメーター ''{1}'' の値を ''{2}.rtw'' ファイルに書き込み中にエラーが発生しました。</entry>
    <entry key="BdWriteParamNameTooLong">パラメーター名 ({0}) の長さは、{1,number,integer} 文字未満でなければなりません。</entry>
    <entry key="BdWriteParamNonBuiltInDType">非 MATLAB データ型のパラメーター ''{0}'' を書き込めません。</entry>
    <entry key="BlkIgnoringUsedAsDStateFlag">''{0}'' の離散状態は、データ型 ''{1}'' が組み込みでないため、ログに記録されません。</entry>
    <entry key="BlkInAlgLoopErr">''{0}'' での代数ループ エラーです\n</entry>
    <entry key="BlkInAlgLoopErrWithInfo">ブロック ''{0}''{1}{2} を含む代数ループにエラーがあります\n</entry>
    <entry key="BlkInLoop">''{0}'' はループ内にあります。</entry>
    <entry key="BlkInTrigSSLoop">''{1}'' の入力端子 ({0}) は、Triggered Subsystem や Triggered Model ブロック含むループ内にあります。</entry>
    <entry key="BlkWithFcnCallRetValInLoop">Simulink は、対応する信号がメモリ内で連続するように、サブシステム ''{1}'' の Inport ブロック {0} の後に暗に Signal Conversion ブロックを挿入しました。これは、呼び出されている関数呼び出しサブシステムからの戻り値としてこれらの信号を観測する関数呼び出しイニシエーターのブロック {2} に対して 1 ステップ遅れる可能性があります。この状態を回避するには、必ず、呼び出される Function-Call Subsystem 内の単一のブロックから、それぞれの関数呼び出しの戻り値を発生させてください。</entry>
    <entry key="BlkWithPortInLoop">''{1}'' の入力端子 ({0}) はループ内にあります。</entry>
    <entry key="BlkWithPortInLoopWithConstTs">''{1}'' の入力端子 ({0}) はループ内にあります。このブロックに定数のサンプル時間があります。</entry>
    <entry key="BlkWithPortInLoopWithConstTsInside">''{1}'' の入力端子 ({0}) はループ内にあります。この Subsystem ブロックに定数のサンプル時間があるか、このサブシステム内に定数のサンプル時間をもつブロックがあります。</entry>
    <entry key="BlkWithPortInLoopWithAsyncTs">''{1}'' の入力端子 ({0}) はループ内にあります。このブロックに非同期のサンプル時間があります。</entry>
    <entry key="BlkWithPortInLoopWithMultiTs">''{1}'' の入力端子 ({0}) はループ内にあります。このブロックに複数のサンプル時間があります。</entry>
    <entry key="BlkWithParamWriteInLoop">Parameter Writer ブロックまたは Parameter Writer ブロックの親サブシステムであるブロック ''{0}'' と、パラメーターが Parameter Writer ブロックによって書き込まれるブロック ''{1}'' を含む代数ループが無効です。</entry>
    <entry key="Blk_Support_IR_Conditional_Init">ダミー メッセージ</entry>
    <entry key="BlockBusObjectTsClash">ブロック ''{0}'' は、競合しているサンプル時間の情報を指定します: ブロックは、ブロックのサンプル時間が {2} となるように要素が定義されたバスオブジェクト ''{1}'' を指定しますが、ブロックのサンプル時間のプロパティは {3} が指定されます。ブロックのサンプル時間、またはオブジェクトの要素に継承 (-1) かのいずれかの設定を行ってください。</entry>
    <entry key="BlockCStateArrayBoundsError">モデル全体の連続状態の配列は、''{2}'' の S-Function ''{1}'' の関数 ''mdl{0}'' の実行後に壊れます。この破損は S-Function のソース コード内のエラーによる可能性が最も高いです。ここで、S-Function の連続状態のポインターは割り当てられた制限を超えてインクリメント/デクリメントされています。このようなメモリのエラーにより、MATLAB がクラッシュしたり、誤ったシミュレーション結果を生成する可能性があります。</entry>
    <entry key="BlockDWorkArrayBoundsError">モデル全体の作業ベクトル配列 (DSTATES, RWORK, IWORK, PWORK, DWORK, MODE ベクトルを含む) は、''{2}'' の S-Function ''{1}'' の関数 ''mdl{0}'' の実行後に壊れます。この破損は S-Function のソース コード内のエラーによる可能性が最も高いです。ここで、S-Function の作業ベクトルのポインターは割り当てられた制限を超えてインクリメント/デクリメントされています。このようなメモリのエラーにより、MATLAB がクラッシュしたり、誤ったシミュレーション結果を生成する可能性があります。</entry>
    <entry key="BlockIO_Complexity">ブロック ''{2}'' の&lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;入力端子 {1,number,integer}&lt;/sldiag&gt; に対する {0} の入力信号は、両方の信号の複素数が同じでなければならないため、{3} の出力端子 {4,number,integer} で上書きできません。</entry>
    <entry key="BlockIO_Datatypes">ブロック ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; に対する信号のソース ブロック ''{1}'' の出力端子 {0,number,integer} は、信号のデータ型が異なるため、出力端子 {4,number,integer} で上書きできません。</entry>
    <entry key="BlockIO_DifferentOutportReuse">ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に対する入力信号は、その出力端子 {2,number,integer} で上書きされず、出力端子 {3,number,integer} で上書きされます。</entry>
    <entry key="BlockIO_GlobalLocal">ブロック ''{2}'' の&lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;入力端子 {1,number,integer}&lt;/sldiag&gt; に対する {0} の入力信号は、同じスコープでなければならないため、{3} の出力端子 {4,number,integer} で上書きできません。</entry>
    <entry key="BlockIO_GroundBlock">ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に対する入力信号は、そのソースが GROUND ブロックのため、出力端子 {2,number,integer} で上書きできません。</entry>
    <entry key="BlockIO_InputSignalGreaterThanOutput">ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に対する入力信号は、そのサイズが出力端子より大きいため、出力端子 {2,number,integer} で上書きできません。これは制限で、後のリリースで対応します。</entry>
    <entry key="BlockIO_InputSignalIsNoncontiguous">ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に対する入力信号は、複数の出力端子から発生しているため、出力端子 {2,number,integer} で上書きできません。</entry>
    <entry key="BlockIO_InputSignalIsRootInport">ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に対する入力信号は、そのソースが ROOT 端子のため、出力端子 {2,number,integer} で上書きできません。</entry>
    <entry key="BlockIO_InputSignalSmallerThanOutput">ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に対する入力信号は、そのサイズが出力端子より小さいため、出力端子 {2,number,integer} で上書きできません。</entry>
    <entry key="BlockIO_InputSignalStillUsed">ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に対する信号値は、まだ実行されていないブロック ''{4}'' の&lt;sldiag objui="inport" objparam="{3,number,integer}" objname="{4}"&gt;入力端子 {3,number,integer}&lt;/sldiag&gt; で引き続き必要とされているため、出力端子 {2,number,integer} で上書きできません。</entry>
    <entry key="BlockIO_MarkedNonReusable">ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に対する入力信号は、再利用不可としてマークされているため、出力端子 {2,number,integer} で上書きできません。</entry>
    <entry key="BlockIO_NoBufferReuse">バッファーの再利用の最適化がこのブロック線図に対して OFF になっているため、ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に対する入力信号をその出力端子 {2,number,integer} で上書きできません。</entry>
    <entry key="BlockIO_SignalSourceGreaterThanOutput">ブロック ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; に対する信号のソース ブロック ''{1}'' の出力端子 {0,number,integer} は、出力端子 {4,number,integer} よりサイズが大きいため、この出力端子で上書きできません。これは制限で、後のリリースで対応します。</entry>
    <entry key="BlockIO_SignalSourceSmallerThanOutput">ブロック ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; に対する信号のソース ブロック ''{1}'' の出力端子 {0,number,integer} は、出力端子 {4,number,integer} よりサイズが小さいため、この出力端子で上書きできません。</entry>
    <entry key="BlockIO_Systems">ブロック ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; に対する信号のソース ブロック ''{1}'' の出力端子 {0,number,integer} は、信号が異なるシステム内にあるため、出力端子 {4,number,integer} で上書きできません。</entry>
    <entry key="BlockIO_AlgebraicLoop">ブロック ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; に対する信号のソース ブロック ''{1}'' の出力端子 {0,number,integer} は、代数ループの一部であるため、出力端子 {4,number,integer} で上書きできません。</entry>
    <entry key="BlockIO_Testpoint">ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に対する入力信号は、信号の少なくとも 1 つがテスト ポイントのため、出力端子 {2,number,integer} で上書きできません。</entry>
    <entry key="BlockIO_Logging">ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に対する入力信号は、信号の少なくとも 1 つのログが記録されているため、出力端子 {2,number,integer} で上書きできません。</entry>
    <entry key="BlockIO_UnequalSampleTimes">ブロック ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; に対する信号のソース ブロック ''{1}'' の出力端子 {0,number,integer} は、信号が異なるサンプル時間をもつため、出力端子 {4,number,integer} で上書きできません。</entry>
    <entry key="BlockIO_UnknownReason">ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に対する入力信号は、不明な理由により、出力端子 {2,number,integer} で上書きできません。</entry>
    <entry key="BlockJacobianMethodButNoConfig">''{0}'' ではヤコビ メソッドが実装されていますが、関数 DoPostPropagationTasks でのヤコビアンの次元の構成に失敗しました。</entry>
    <entry key="BlockJacobianNumElementsOverflow">''{0}'' のヤコビアン要素数が、メモリ内で許可される最大ヤコビアン要素数 {1, number, integer} を超えています。</entry>
    <entry key="ModelJacobianNumElementsOverflow">モデル ''{0}'' のヤコビアン要素数が、メモリ内で許可される最大ヤコビアン要素数 {1, number, integer} を超えています。</entry>
    <entry key="BlockJacobianMethodButNoIrJc">''{0}'' ではヤコビ メソッドが実装されていますが、JacobianIrJc メソッド内でのヤコビ構造 (Ir, Jc) の初期化に失敗しました。</entry>
    <entry key="BlockNotFoundMessage">ライブラリ ブロック ''{0}'' が見つかりません</entry>
    <entry key="BlockNotFoundTitle">ブロックが見つかりません</entry>
    <entry key="BlockOutputArrayBoundsError">モデル全体のブロック出力の信号配列は、''{2}'' の S-Function ''{1}'' の関数 ''mdl{0}'' の実行後に壊れます。この破損は S-Function のソース コード内のエラーによる可能性が最も高いです。ここで、S-Function の出力端子信号のポインターは割り当てられた制限を超えてインクリメント/デクリメントされています。このメモリの並べ替えによるエラーは、MATLAB がクラッシュしたり、誤ったシミュレーション結果を生成する可能性があります</entry>
    <entry key="BlockOutputInfNanDetectedError">ブロック ''{0}'' は、{4} のタイム ステップ {5} で、&lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;出力端子 {3,number,integer}&lt;/sldiag&gt; の要素 {2,number,integer} に対する ''{1}'' を出力します &lt;actions exclusiveFixIts="no"&gt; &lt;action type="suppression"&gt;&lt;/action&gt; &lt;/actions&gt;</entry>
    <entry key="BlockOutputBufferExceedsMaxlimit">ブロック ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; からの string 信号は、タイム ステップ {2} で打ち切られます。長さが上限の {3,number,integer} 文字を超えています。&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="BlockOutputBufferOverflowDetectedError">ブロック ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; からの string 信号が、タイム ステップ {2} で打ち切られました。長さが、出力データ型で指定された最大長の {3,number,integer} 文字を超えました。出力の string データ型の最大長を増やすことを検討してください。&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="BlockOutputStringContainsNullChar">ブロック ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; からの string 信号が、null 文字 ''char(0)'' をサポートしていません。</entry>
    <entry key="CANNOT_ACCESS_BUS">''{1}'' のバス信号の ''{0}'' へのアクセスはサポートされていません。</entry>
    <entry key="CannotDeleteBusySystem">コールバックまたはパラメーター評価の処理中は、''{0}'' を削除できません。</entry>
    <entry key="ParamEvalDelete">Cannot delete ''{0}'' while it is evaluating parameter.</entry>
    <entry key="CallbackDelete">コールバック中にはブロック ''{0}'' を削除できません</entry>
    <entry key="CallbackEvalErr">{1} ''{2}'' の &lt;sldiag objui="callback" objparam="{0}"&gt;&lt;/sldiag&gt; コールバックの評価中にエラーが発生しました。\nコールバック文字列は ''{3}'' です</entry>
    <entry key="CallbackRecursion">前のコールバックの実行中に ''{1}'' の {0} コールバックを再度呼び出そうとしています。</entry>
    <entry key="CombineOutputUpdateFcnMinorTimeSteps">The output(s) read after the base-rate model step reflects intervening minor time steps. To observe data that is a snapshot of output(s) at major time steps, do one of the following:\n * Place a Zero-Order Hold block before the continuous output port ''{0}''. \n * Clear &lt;sldiag objui="configset" objparam="CombineOutputUpdateFcns"&gt;Single output/update function&lt;/sldiag&gt;, and read model output values after model_output call and before model_update call.</entry>
    <entry key="CannotChangeBlkParamsInsideParameterizedForEachSS">シミュレーションをラピッド アクセラレータ モードで実行している間は For Each Subsystem ''{2}'' 内のブロック ''{1}'' のパラメーター ''{0}'' を変更できません。これは、このサブシステムに 1 つ以上の分割されたマスク パラメーターが含まれているためです。</entry>
    <entry key="CannotChangeBlkParamsInPFESSFromPToNP"> ブロック ''{1}'' のパラメーター ''{0}'' は、シミュレーション中に For Each Subsystem の分割されたマスク パラメーターを少なくとも 1 つは参照しなければなりません。これは、このパラメーター値が、For Each Subsystem の分割されたマスク パラメーターを 1 つ以上直接または間接的に参照するように設定されているためです。</entry>
    <entry key="CannotChangeBlkParamsInPFESSFromNPToP">ブロック ''{1}'' のパラメーター ''{0}'' は、シミュレーション中に For Each Subsystem の分割されたマスク パラメーターを直接または間接的に参照する値に変更することはできません。これは、このブロック パラメーター値が、For Each Subsystem の分割されたマスク パラメーターを参照しないように設定されているためです。</entry>
    <entry key="CannotSetBlkParamsToPartitionedMaskVarInPFESS">ブロック ''{1}'' のパラメーター ''{0}'' は、For Each Subsystem の分割されたマスク パラメーターを参照する値に設定することはできません。このパラメーターは、分割されたマスク パラメーターの参照をサポートしていません。</entry>
    <entry key="CannotSetAnonymousBlkParamsToPartitionedMaskVarInPFESS">ブロック ''{0}'' は For Each Subsystem の分割されたマスク パラメーターを参照できません。</entry>
    <entry key="CannotSetBlkParamsInMultiRateDelayBlockInPFESS">Delay ブロック ''{1}'' のパラメーター ''{0}'' は、For Each Subsystem の分割されたマスク パラメーターを参照する値に設定することはできません。Delay ブロックは、分割されたマスク パラメーターのマルチレート モードでの参照をサポートしていません。</entry>
    <entry key="CannotSetBlkParamsInSFunctionWithoutMdlProcessParameters">ブロック ''{0}'' は For Each Subsystem ''{1}'' の分割されたマスク パラメーターの参照をサポートしていません。この S-Function で関数 mdlProcessParameters が定義されていません。</entry>
    <entry key="CannotSetBlkParamsInTLCSfcnBlockInPFESS">ブロック ''{1}'' のパラメーター ''{0}'' は、分割されたマスク パラメーターを参照する値に設定することはできません。TLC で生成された S-Function は、分割されたマスク パラメーターの参照をサポートしていません。</entry>
    <entry key="CannotSetMdlRefArgToPartitionedMaskVarInRTW">''[コンフィギュレーション パラメーター] &gt; [コード生成] &gt; [識別子] &gt; [スカラーのインライン パラメーターの生成]'' が [マクロ] に設定されている場合、ブロック ''{1}'' のモデル引数 ''{0}'' は、分割されたマスク パラメーターをコード生成時に参照する値には設定できません。このパラメーターを [リテラル] に変更することを検討してください。</entry>
    <entry key="CannotReferenceTransformedTunableVarInPFESS">ブロック ''{1}'' のパラメーター ''{0}'' は、For Each Subsystem ''{2}'' の分割されたマスク パラメーターを参照する値には設定できません。このパラメーターは 1 つ以上のダイアログ パラメーターを変換したものです。変換されたパラメーターは For Each Subsystem の分割されたマスク パラメーターの参照をサポートしていません。パラメーターの変換を回避するには、''{5}(...)'' の式を介して、ブロック ''{4}'' のマスク パラメーター ''{3}'' の式を明示的にデータ型 ''{5}'' にキャストすることを検討してください。</entry>
    <entry key="CannotReferenceTransformedTunableVarInPFESSForUserSFcn">ブロック ''{1}'' のパラメーター ''{0}'' は、For Each Subsystem の分割されたマスク パラメーターを参照する値に設定することはできません。このパラメーターは 1 つ以上のダイアログ パラメーターを変換したものです。変換されたパラメーターは For Each Subsystem の分割されたマスク パラメーターの参照をサポートしていません。</entry>
    <entry key="PartitionedStructParamNotAllowed">For Each Subsystem ''{1}'' のマスク パラメーター ''{0}'' は、非数値、あるいは非数値フィールドを含む構造体として評価されるため、分割できません。</entry>
    <entry key="CannotChangeConstTsBlks">サンプル時間が定数 (inf) であるため、シミュレーションの実行中に ''{1}'' のパラメーター ''{0}'' を変更できません。定数のサンプル時間は通常、''[コンフィギュレーション パラメーター] &gt; [コード生成] &gt; [最適化] &gt; [既定のパラメーター動作]'' が [インライン] に設定されている場合に発生します。</entry>
    <entry key="CannotChangePortFrameData">S-function のメソッド {0} は、''{3}'' の {1} 端子 {2,number,integer} のフレーム データが 1 度設定されると、それを変更できません。</entry>
    <entry key="CannotChangePostCompileVirtBlks">シミュレーションの実行中は、''{1}'' の ''{0}'' パラメーターを変更できません。ブロックはシミュレーション用に最適化されたため、バーチャルになりました。</entry>
    <entry key="CannotDisplayFrameSignal">''{1}'' 上の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; から発生する選択された信号は、フレームベースのため表示できません</entry>
    <entry key="CannotDisplayWideFrameSignal">''{1}'' 上の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; から発生する選択された信号は、1 より大きいフレーム サイズをもつフレームベースの信号のため表示できません</entry>
    <entry key="CannotEvaluateFloatingDuration">フローティング スコープの [持続時間] フィールドは、正の整数に評価される有効な MATLAB 式でなければなりません。既定値に auto を使用中</entry>
    <entry key="CannotEvaluateDWorkDimArg">導出パラメーターに指定された式 ''{0}'' は、スカラーで評価されません。導出された次元の引数として指定される導出パラメーターは、倍精度スカラーで評価されなければなりません。</entry>
    <entry key="CannotExecuteTargDataMap">ターゲット データ マップ ファイル ''{0}{1}{2}'' を実行できない、または存在しません。\nターゲットを停止し、{3} の実行ファイルを削除し、コードをリビルドし、再度試してください。エクスターナル モードの実行には、ビルド ディレクトリが存在する必要があることに注意してください。</entry>
    <entry key="CannotHaveNDFrames">この端子がフレームベースに設定されている場合、{2,number,integer} 次元となるよう ''{1}'' の端子 {0,number,integer} に設定できません。フレームベースの端子に対して、次元数は 2 でなければなりません</entry>
    <entry key="CannotHaveUnorientedFrames">この端子がフレームベースに設定されている場合、1 次元となるよう ''{1}'' の端子 {0,number,integer} に設定できません。フレームベースの端子に対して、次元数は 2 でなければなりません</entry>
    <entry key="CannotHaveUnsetOutputDimsMode">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の次元モードが継承されます。すべての入力端子に対して固定または可変の次元モードが設定されても次元モードを継承することのできる出力端子はありません。</entry>
    <entry key="CannotHaveUnsetOutputFrameData">''{0}'' は出力端子 {1,number,integer} に対して不明なフレーム状態を持ちます。すべての入力端子のフレーム状態が既知の場合、すべての出力端子のフレーム状態は既知でなければなりません。</entry>
    <entry key="CannotPropFixedDimsModeForward">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; から ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; に固定サイズのモードを伝播できません。入力端子は可変サイズのモードが必要です。''{4}'' を可変サイズの信号を出力するブロックに置き換えるか、あるいは ''{5}'' を固定サイズの信号が必要なブロックに置き換えてください。</entry>
    <entry key="CannotPropFixedDimsModeForwardWithSource">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; から ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; に固定サイズのモードを伝播できません。入力端子は可変サイズのモードが必要です。固定サイズのモードは ''{4}'' から発生しています。''{5}'' を可変サイズの信号を出力するブロックに置き換えるか、あるいは ''{6}'' を固定サイズの信号が必要なブロックに置き換えてください。</entry>
    <entry key="CannotPropFrameDataBus">フレームベースの要素をもつバス ''{0}'' は、''{2}'' の&lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;入力端子 {1,number,integer}&lt;/sldiag&gt; に伝播できません。この入力端子がサンプル ベースの信号を必要としているためです。</entry>
    <entry key="CannotPropFrameDataForward">この入力端子はサンプル ベースの信号を必要としているため、フレームベースの信号を ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; から ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; に伝播できません。信号のパスに Unbuffer を挿入することを検討してください。</entry>
    <entry key="CannotPropFrameDataForwardWithSource">この入力端子はサンプル ベースの信号を必要としているため、フレームベースの信号を ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; から ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; に伝播できません。フレームベースの信号は ''{4}'' から発生しています。信号のパスに Unbuffer を挿入することを検討してください。</entry>
    <entry key="CannotPropFrameDataWhenLatchingOutside">サブシステム ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{2}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; は、フレームベースの信号を受け入れられません。対応する Inport ブロック ''{2}'' で [外部信号を遅延して入力をラッチ] パラメーターが設定されていることが原因です。 </entry>
    <entry key="CannotPropFrameDataWhenLatchingOutsideForRootTrigger">ルートの入力端子 ''{0}'' は、[外部信号を遅延して入力をラッチ] パラメーターが選択されているため、フレームベースの信号を出力できません。[外部信号を遅延して入力をラッチ] の選択を解除するか、set_param(blk,'SamplingMode','Sample based') (blk はルートの入力端子のハンドル) を実行してサンプリング モードを [サンプル ベース] に設定することを検討してください。</entry>
    <entry key="CannotPropFrameDataWhenLatchingOutsideForTriggeredModelBlock">トリガーされた Model ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; は、フレームベースの信号を受け入れられません。参照モデル ''{2}'' で対応する Inport ブロックに [外部信号を遅延して入力をラッチ] パラメーターが設定されているためです。 </entry>
    <entry key="CannotPropNonFrameDataForward">この入力端子はフレームベースの信号を必要としているため、サンプル ベースの信号を ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; から ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; に伝播できません。信号のパスに Buffer または Frame Conversion ブロックを挿入することを検討してください。</entry>
    <entry key="CannotPropNonFrameDataForwardWithSource">この入力端子はフレームベースの信号を必要としているため、サンプル ベースの信号を ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; から ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; に伝播できません。サンプル ベースの信号は ''{4}'' から発生しています。信号のパスに Buffer または Frame Conversion ブロックを挿入することを検討してください。</entry>
    <entry key="CannotPropVariableDimsModeForward">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; から ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; に可変サイズのモードを伝播できません。入力端子は固定サイズのモードが必要です。次のいずれかについて ''{4}'' の設定を調べてください: 1) そのブロックは可変サイズの信号をサポートしていない。 2) そのブロックは可変サイズの信号をサポートしているが固定サイズを設定する必要がある。</entry>
    <entry key="CannotPropVariableDimsModeForwardWithSource">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; から ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; に可変サイズのモードを伝播できません。入力端子は固定サイズのモードが必要です。可変サイズのモードは ''{4}'' から発生しています。次のいずれかについて ''{5}'' の設定を調べてください: 1) そのブロックは可変サイズの信号をサポートしていない。2) そのブロックは可変サイズの信号をサポートしているが固定サイズを設定する必要がある。</entry>
    <entry key="SimFcnInportDoesNotSupportVarDims">Unable to propagate the variable-size signal with finite upper bounds to the Inport block ''{0}'' of the Simulink Function block. Only fixed-size signals or unbounded variable-size signals are supported by the Inport block of the Simulink Function block.</entry>
    <entry key="SimFcnOutportDoesNotSupportVarDims">上限が有限である可変サイズの信号を Simulink Function ブロックの Outport ブロック ''{0}'' から伝播できません。Simulink Function ブロックの Outport ブロックでは、固定サイズの信号または制限なしの可変サイズ信号のみがサポートされます。</entry>
    <entry key="CannotUnifyDimsMode">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; から ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; に次元モードを伝播できません。ソースの出力で多重化された信号の 1 つは可変サイズのモードです。この多重化された信号は、Simulink が遷移先にモードを伝播する前に逆多重化されなければなりません。</entry>
    <entry key="CannotUnifyFrameData">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; から ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; にフレーム データを伝播できません。ソースの出力時の信号へと多重化された信号の 1 つにフレーム データが含まれています。この多重化された信号は、遷移先に接続する前に逆多重化されなければなりません。</entry>
    <entry key="CannotUploadTunTransformsOfDstType">ターゲットからパラメーターをアップロード中に、データ型 ''{0}'' からデータ型 ''{1}'' への変換エラーが発生しました。</entry>
    <entry key="CannotUseSetDefaultDimsFcn">''{0}'' は [既定の次元関数の設定] を使用できません。</entry>
    <entry key="CantCmdlSimInExternalMode">関数 sim を使用して開始するシミュレーションでは、エクスターナル モード シミュレーションはサポートされません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{0}'','SimulationMode','Normal');&lt;/cmd&gt; &lt;txt&gt;ノーマル モードでシミュレーションを行うようにモデルを構成する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;</entry>
    <entry key="CantStepExternalMode">エクスターナル モードを進行できません</entry>
    <entry key="ChangePortToBlockSampleTimes">このブロックは端子ベースのサンプル時間を使って設定されているため、''{0}'' のブロックベースのサンプル時間にアクセスできません。</entry>
    <entry key="ExclusiveSignalMustHaveSameStorageClass">バリアント サブシステム内で同一の識別子をもつ信号は、同一のストレージ クラスをもたなければなりません。</entry>
    <entry key="ExclusiveSignalOnInport">バリアント サブシステムの 2 つの異なる選択肢の入力端子に同じ信号オブジェクトを使用することは許可されていません。信号 ''{0}'' が ''{1}'' と ''{2}'' で見つかりました。Signal Conversion ブロックを追加し、Signal Conversion ブロックの出力端子の信号プロパティを指定することを検討してください。</entry>
    <entry key="Comp_AutoSolver">コンパイル: ソルバーの自動選択</entry>
    <entry key="Comp_AdaptBus">コンパイル:バス名を適用する</entry>
    <entry key="Comp_Autosave">自動保存: すべての未保存のモデルをバックアップ</entry>
    <entry key="Comp_Blockio">コンパイル : ブロック I/O のインデックスを設定中</entry>
    <entry key="Comp_BusCache">コンパイル : バス キャッシュを更新</entry>
    <entry key="Comp_BusConv">コンパイル : バス変換ブロックを挿入</entry>
    <entry key="Comp_CacheMR">コンパイル: システムに対する Model ブロックをキャッシュ</entry>
    <entry key="Comp_CacheSrcs">コンパイル : ソースと接続先をキャッシュ</entry>
    <entry key="Comp_Checksums">コンパイル : チェックサムを計算中</entry>
    <entry key="Comp_Cleanup">コンパイル : メモリをクリーンアップ中</entry>
    <entry key="Comp_CompProps">コンパイル : コンパイルしたプロパティの初期化中</entry>
    <entry key="Comp_CompSet">コンパイル : コンパイルしたブロックの設定を作成中</entry>
    <entry key="Comp_Complete">コンパイル : コンパイル段階が完了しました</entry>
    <entry key="Comp_Datatypes">コンパイル : データ型、複素信号、単位およびシンボリック次元を伝播</entry>
    <entry key="Comp_EvalBlocks">コンパイル : ブロック パラメーターの評価中</entry>
    <entry key="Comp_SSCConstruct">コンパイル: Simscape 物理ネットワークの方程式系の作成中</entry>
    <entry key="Comp_SSCAnalyze">コンパイル: Simscape 物理ネットワークの方程式系の解析中</entry>
    <entry key="Comp_SSCSetup">コンパイル: Simscape 物理ネットワークのシミュレーションの設定中</entry>
    <entry key="Comp_SSCInitialize">実行中: Simscape 物理ネットワークの方程式系の初期化中</entry>
    <entry key="Comp_ExpandForBus">コンパイル : バスサポートに対するブロックを展開</entry>
    <entry key="Comp_Final">コンパイル : コンパイルが完了しました</entry>
    <entry key="Comp_GenSorted">コンパイル : 並べ替えリストを生成中</entry>
    <entry key="Comp_InitBlocks">コンパイル : すべてのブロックを初期化中</entry>
    <entry key="Comp_MR">コンパイル : モデル リファレンス ターゲットを更新中</entry>
    <entry key="Comp_RLS">コンパイル中 : 再利用可能なライブラリ サブシステムのターゲットを更新中</entry>
    <entry key="Comp_PostProp">コンパイル : 後伝播のタスクを完了</entry>
    <entry key="Comp_Precompile">コンパイル : プリコンパイル通知を実行中</entry>
    <entry key="Comp_PropContexts">コンパイル : 条件付きコンテキストを伝播</entry>
    <entry key="Comp_PropFrames">コンパイル : フレーム データと次元を伝播</entry>
    <entry key="Comp_PropLabels">コンパイル : 信号ラベルを伝播</entry>
    <entry key="Comp_PropPassByRef">コンパイル : 参照によるパスを伝播</entry>
    <entry key="Comp_Reeval">コンパイル : Bus Selector を再評価中</entry>
    <entry key="Comp_References">コンパイル : ライブラリ リンクのブロックを更新中</entry>
    <entry key="Comp_SF_Post">コンパイル : Stateflow のポストコンパイルを通知</entry>
    <entry key="Comp_SF_Start">コンパイル : Stateflow のコンパイルを開始</entry>
    <entry key="Comp_SampleTimes">コンパイル : サンプル時間を伝播</entry>
    <entry key="Comp_SortBlocks">コンパイル : 伝播に対するブロックリストを並べ替え</entry>
    <entry key="Comp_Start">コンパイル : モデルのコンパイルを開始</entry>
    <entry key="Comp_SysProps">コンパイル : システム レベルのプロパティを伝播</entry>
    <entry key="Comp_Testpoints">コンパイル : 暗黙的なテスト ポイントを設定中</entry>
    <entry key="Comp_PostActSrc">コンパイル: サブシステムの出力端子の設定中</entry>
    <entry key="Comp_UpdateDisplay">コンパイル : グラフィカルな表示を更新中</entry>
    <entry key="Comp_UpdateSorted">コンパイル : ソート順序の表示を更新中</entry>
    <entry key="Comp_Workspace">コンパイル : モデル ワークスペースの初期化中</entry>
    <entry key="CompactFormatNotSupportnonInlinedSF">ブロック ''{0}'' はインラインでない S-Function です。これは、[ファイル パッケージ化形式] が [コンパクト] または [コンパクト (別々のデータ ファイル)] の場合はサポートされません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''ERTFilePackagingFormat'',''Modular'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="ERTFilePackagingFormat"&gt;[ファイル パッケージ化形式]&lt;/sldiag&gt; を [モジュラー] に変更する&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="CompileNeededForSampleTimes">モデル ''{0}'' に対する [サンプル時間] 情報にアクセスするには、モデルを更新しなければなりません。</entry>
    <entry key="CompileNeededForVariantConditions">モデル ''{0}'' に関する VariantConditions 情報にアクセスするには、ブロック線図の更新を実行しなければなりません</entry>
    <entry key="ModelHasNoVariantConditions">モデル ''{0}'' にはバリアント条件はありません </entry>
    <entry key="CompileNeededForTasks">モデル ''{0}'' に対する [タスク] 情報にアクセスするには、ブロック線図の更新を実行しなければなりません。</entry>
    <entry key="CompileNeededForClocks">モデル ''{0}'' に対する [クロック] 情報にアクセスするには、ブロック線図の更新を実行しなければなりません。</entry>
    <entry key="ComplexityNotCompatibleMatlab">与えられた MATLAB 配列の実数/複素数は、Simulink の内部データと互換性がありません</entry>
    <entry key="CompilePhaseStatusBarStart"> : 起動済み</entry>
    <entry key="CompilePhaseStatusBarEnd"> : 完了</entry>
    <entry key="ContSTInpPortIsFrameBased">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; は、この端子が連続サンプル時間をもつにもかかわらずフレームベースに設定されています。フレームベースの信号は離散サンプル時間をもつ必要があります。</entry>
    <entry key="ContStateAccessError">このブロックの Start メソッドが実行される前に ''{0}'' の連続状態にアクセスできません。</entry>
    <entry key="ContinuousTimeNotSupported">ブロック ''{0}'' では、現在の設定でサポートされていない連続時間が使用されています。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''SupportContinuousTime'',''on'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="SupportContinuousTime"&gt;[連続時間のサポート]&lt;/sldiag&gt; を選択する&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="Conv1DVectToColVectByBlock">''{0}'' は、1 次元信号で駆動されています。これにより、入力信号は列ベクトル (行列) に自動的に変換されています。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;Reshape を使用する&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''VectorMatrixConversionMsg'',''none'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="VectorMatrixConversionMsg"&gt;[ベクトル/行列ブロック入力変換]&lt;/sldiag&gt; を [なし] に設定して、このメッセージを非表示にする&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="CovAccessError">カバレッジ ツールにアクセス中に発生した致命的なエラー: {0}</entry>
    <entry key="CovBlockTooManySignals">{0} のカバレッジに対する信号が多すぎます。信号範囲カバレッジがオフです。</entry>
    <entry key="CovGenericBlock">''{0}'' の解析中に発生したカバレッジ ツールの致命的なエラーです。</entry>
    <entry key="CovGenericModel">モデルを解析中に発生したカバレッジ ツールの致命的なエラーです。</entry>
    <entry key="CovSetupError">カバレッジ ツールに設定中に致命的エラーが発生しました。</entry>
    <entry key="CovNotSupportedSLDVBlockType">このデータ型は ''{0}'' でサポートされていません - このブロックに対しカバレッジがオフになっています。</entry>
    <entry key="CreateUndoSubsystemWarning">サブシステム内で行われたすべてのグラフィカルな変更は削除される予定です。\n サブシステムの変更を戻すには、サブシステムの作成のやり直しを選択してください\n</entry>
    <entry key="CreateUndoWriteProtectedSubsystemError">''ReadOnly'' または ''NoReadWrite'' であるサブシステムに対して、サブシステムの作成を元に戻すことはできません。\n</entry>
    <entry key="DSMemoryAsyncTsNotMatchObject">モデル ''{0}'' において、データ ストア ''{1}'' にアクセスする 1 つ以上のブロックが非同期のタスクで実行されます。これは、{2} のワークスペース内の Simulink.Signal オブジェクトで格納されたデータに対して指定されたサンプル時間プロパティと矛盾します。すなわち、信号オブジェクトは、サンプル時間 {3} をもつシングル タスク内でデータ ストアがアクセスされることを指定しています。</entry>
    <entry key="DSMemoryHybridTsNotMatchObject">モデル ''{0}'' において、データ ストア ''{1}'' にアクセスする 1 つ以上のブロックが複数のタスクで実行されます。これは、{2} のワークスペース内の Simulink.Signal オブジェクトで格納されたデータ ストアに対して指定されたサンプル時間プロパティと矛盾します。信号オブジェクトは、サンプル時間 {3} をもつ 1 つのタスク内でデータ ストアがアクセスされることを指定しています。</entry>
    <entry key="DSMemoryReaderWriterTsNotMatchObject">モデル ''{0}'' において、データ ストア ''{1}'' にアクセスする 1 つ以上のブロックがサンプル時間 {2} のタスクで実行されます。これは、{3} のワークスペース内の Simulink.Signal オブジェクトで指定されたデータ ストア メモリのサンプル時間プロパティと矛盾します。すなわち、信号オブジェクトは、サンプル時間 {4} をもつシングル タスク内でデータ ストアがアクセスされることを指定しています。</entry>
    <entry key="DWorkDataNotReusableSC">''{0}'' の所有する状態のストレージ クラスがグローバルであるため、生成されたコードは再利用可能ではありません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;Simulink.internal.OpenBlockParamsDialog(''{0}'',''StateStorageClass'')&lt;/cmd&gt; &lt;txt&gt;[ストレージ クラス] を [自動] に設定する&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''CodeInterfacePackaging'')&lt;/cmd&gt; &lt;txt&gt;[コード インターフェイスのパッケージ化] を [再利用できない関数] に設定する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''MultiInstanceErrorCode'')&lt;/cmd&gt; &lt;txt&gt;[マルチインスタンス コードのエラーの診断] を [なし] または [警告] に設定する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="DWorkDimArgIsNotDerivedParam">導出された次元の引数に指定された ''{0}'' は無効な引数です。引数は導出されたブロック パラメーターでなければなりません。</entry>
    <entry key="DataDimensionMismatch">データの次元が一致しません</entry>
    <entry key="DataTypeHeaderRecursion">データ型のヘッダー ファイルの依存関係において再帰が検出されました。型依存関係の連鎖: ''{0}''。ヘッダー ファイルの依存関係の対応する連鎖: ''{1}''。</entry>
    <entry key="DataTypeMismatch">データ型が一致しません。{0} のデータは、{1} のデータが必要な場合に与えられます</entry>
    <entry key="DataTypeMismatchField">データ型が MATLAB の構造体のフィールドのデータ型と一致しません</entry>
    <entry key="DataTypeMismatchNumField">データ型が一致しません。{0,number,integer} のフィールドをもつ構造体が与えられましたが、{1,number,integer} のフィールドをもつ構造体が必要です</entry>
    <entry key="DataTypeNotCompatibleMatlab">与えられた MATLAB 配列のデータ型は、Simulink の内部データと互換性がありません</entry>
    <entry key="DataUploadNotSupported">データのアップロードは、タイプ ''{0}'' のデータに対してサポートされていません。</entry>
    <entry key="DefaultBlockDiagramInvalidMethod">メソッド ''{0}'' は、そのオブジェクトに対して実行されません。</entry>
    <entry key="DefaultDimsListHasBeenTruncated">この指定不足の次元のリストは打ち切られました。</entry>
    <entry key="DefaultDimsMethodUsed">モデル ''{0}'' には指定不足の信号の次元があり、Simulink は既定でこれらの次元を割り当てました。あいまいさを防ぐため、ブロックのダイアログ ボックスでこれらの次元を指定することを検討してください。あるいは、必要に応じて ''Signal Specification'' ブロックを追加してください。Simulink は次の信号の次元を割り当てました: {1}</entry>
    <entry key="DefaultDimsMightHaveCausedError">
		指定不足の信号の次元を解決中に、モデル ''{0}'' のコンパイルが失敗しました。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{0}'');configset.highlightParameter(''{0}'','UnderSpecifiedDimensionMsg');&lt;/cmd&gt; &lt;txt&gt;指定不足の信号の次元リストで、[警告] または [エラー] の診断を有効にする。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
	</entry>
    <entry key="DefaultDimsLinkToDisable">
		このメッセージをオフにするには、&lt;sldiag objui="configset" objparam="UnderSpecifiedDimensionMsg"&gt;[指定不足の次元]&lt;/sldiag&gt; を [なし] に設定してください。
	</entry>
    <entry key="DefaultDimsSetAtBlockInPort">ブロック ''{0}'' の&lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;入力端子 {1,number,integer}&lt;/sldiag&gt; が {2} に設定されています。</entry>
    <entry key="DefaultDimsSetAtBlockOutPort">ブロック ''{0}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; が {2} に設定されています。</entry>
    <entry key="DefaultGraphPropertyLoadOnly">既定のグラフ プロパティは、モデルの読み込み中にのみ設定可能です。代わりにルートのグラフのプロパティを設定してください。</entry>
    <entry key="DerivAccessError">このブロックの Start メソッドが実行される前に ''{0}'' の微係数にアクセスできません。</entry>
    <entry key="DerivNotFinite">ブロック ''{1}'' の時間 {2} における状態 ''{0}'' の導関数が有限ではありません。シミュレーションを停止します。解に特異点が存在する可能性があります。そうでない場合は、(固定ステップ サイズを小さくする、または許容誤差を厳しくすることによって) ステップ サイズを減らしてみてください</entry>
    <entry key="JacobianMatrixWithNanInf">自動ソルバーで、時間 t=0.0 のヤコビ行列に有限でないエントリがあることが検出されました。シミュレーションを停止します。解に特異点が存在する可能性があります。そうでない場合は、(最大ステップ サイズを小さくするか許容誤差を厳しくすることによって) ステップ サイズを減らしてみてください</entry>
    <entry key="Dims1DVectTo2DVectorConversion">1 次元配列は 2 次元ベクトル (行列) に変換されています。''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; で生成された 1 次元信号は、自動的に 2 次元ベクトル (行列) に変換されています。この信号は、''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; を駆動しています。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;Reshape を使用する&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{1}'',''VectorMatrixConversionMsg'',''none'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="VectorMatrixConversionMsg"&gt;[ベクトル/行列ブロック入力変換]&lt;/sldiag&gt; を [なし] に設定して、このメッセージを非表示にする&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="Dims2DVectTo1DVectorConversion">2 次元ベクトル (行列) は、1 次元配列に変換されています。''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; で生成された 2 次元ベクトル (行列) 信号は、自動的に 1 次元配列に変換されています。この信号は、''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; を駆動しています。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;Reshape を使用する&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{1}'',''VectorMatrixConversionMsg'',''none'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="VectorMatrixConversionMsg"&gt;[ベクトル/行列ブロック入力変換]&lt;/sldiag&gt; を [なし] に設定して、このメッセージを非表示にする&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="DimsPropBadDefDims2">''{0}'' の次元を設定中にエラーが発生しました。出力端子 {1,number,integer} は、すべての入力端子が既知の次元をもつにもかかわらず、不明な次元があります。</entry>
    <entry key="DisableButNotReturnWkspOutput">ワークスペースへの出力は無効になっています。特に ''sim'' が ''parfor'' の内部で呼び出される場合にこれが発生します。ワークスペースの出力を保存するには、''sim'' コマンド オプション内で ''SaveWorkspaceOutputs'' を ''on'' に設定してください</entry>
    <entry key="DomainDataLocked">領域 ''{0}'' に対するデータはロックされています。</entry>
    <entry key="DomainHasNoPortTypes">領域 ''{0}'' には端子タイプがありません。少なくとも 1 つは指定しなければなりません。</entry>
    <entry key="DomainModelAlreadyRegistered">領域のモデルは、既に ''{0}'' の名前で登録されています。</entry>
    <entry key="DomainModelNotRegistered">''{0}'' の名前の領域のモデル定義が見つかりません。</entry>
    <entry key="DomainNotFound">物理モデリングの領域定義ファイル {0}.m が見つかりません。そのため、このモデルのシミュレーションができません。モデルを閉じて、領域定義ファイルを MATLAB パスに追加し、モデルを再度開いてください。</entry>
    <entry key="DomainParameterNotSet">領域パラメーター ''{0}'' はすべての領域が設定されなければなりません。領域 ''{1}'' にはこのパラメーターが設定されていません。</entry>
    <entry key="DomainPortTypeParameterNotSet">端子タイプのパラメーター ''{0}'' はすべての端子タイプが設定されなければなりません。端子タイプ ''{1}'' にはこのパラメーターが設定されていません。</entry>
    <entry key="DomainConnectIncorrectReturnValue">領域 ''{2}'' の端子 ''{0}'' および端子 ''{1}'' は、接続関数の戻り値の型が不正です。接続関数は、論理スカラーを返さなければなりません。</entry>
    <entry key="PortTypeNotDefinedForNonDynamicDomain">端子タイプ ''{0}'' がドメイン ''{1}'' のドメイン定義で見つかりません。このドメインは動的な端子タイプをサポートしていません。
    </entry>
    <entry key="DomainInvalidDynamicPortTypesCallback">領域 ''{0}'' の DynamicPortTypesCallback プロパティが無効です。このプロパティは、MATLAB の関数ハンドルの 1 行 2 列のセル配列でなければなりません。1 番目はセットアップ関数ハンドルで、2 番目は接続関数ハンドルです。</entry>
    <entry key="DuplicatePortNum">''{0}'' に重複した端子番号があります</entry>
    <entry key="DuplicatedNameInRegistry">''{0}'' という名前の項目は、このレジストリに既に存在します。</entry>
    <entry key="UngroupedCanPrmNotAllowedMulInstSLFcn">パラメーター ''{0}'' はモデル引数として構成されており、マルチインスタンス コードを生成するように構成されている Simulink 関数 ''{1}'' で使用されます。このモデル化の組み合わせでは、パラメーターは Auto 以外のストレージ クラスをもたなければなりません。</entry>
    <entry key="GroupedCanPrmNotAlloweSLFcnCppClass">パラメーター ''{0}'' はモデル引数として構成されており、Simulink 関数 ''{1}'' で使用されます。このモデリング構成のカプセル化された C++ コードを生成するには、パラメーターがプライベート スコープ内のクラス メンバーである必要があります。C++ コード マッピング エディターで、''Model parameter arguments'' プロパティを ''private'' に設定します。</entry>
    <entry key="ECPotentialOutputDiffTunablePrm">''{0}'' の出力は、以前の Simulink のリリースと異なる結果を生成する可能性があります。ブロック ''{1}'' には調整可能な変数があり、条件付き実行サブシステム ''{2}'' で継承されます。''{3}'' の調整可能なパラメーターを変更する場合、条件付き実行サブシステムを実行したときのみブロックの出力は再計算されます。コンテキストを継承させないようにするには、''{4}'' のサンプル時間に信号を再計算させるレートを明示的に設定します。この警告メッセージをオフにするには、&lt;sldiag objui="configset" objparam="CheckExecutionContextRuntimeOutputMsg"&gt;[実行コンテキストの実行時の出力をチェック]&lt;/sldiag&gt; をオフにしてください。</entry>
    <entry key="ECPotentialOutputDiffTunablePrmConsistentOutportInit">''{0}'' の出力は、以前の Simulink のリリースと異なる結果を生成する可能性があります。ブロック ''{1}'' には調整可能な変数があり、条件付き実行サブシステム ''{2}'' で継承されます。''{3}'' の調整可能なパラメーターを変更する場合、条件付き実行サブシステムを実行したときのみブロックの出力は再計算されます。コンテキストを継承させないようにするには、''{4}'' のサンプル時間に信号を再計算させるレートを明示的に設定します。この警告メッセージをオフにするには、&lt;sldiag objui="configset" objparam="CheckExecutionContextRuntimeOutputMsg"&gt;[実行コンテキストの実行時の出力をチェック]&lt;/sldiag&gt; をオフにしてください。</entry>
    <entry key="ECoder_LicenseError">組み込み C コードの生成に必要な Embedded Coder のライセンスを照合できません</entry>
    <entry key="MATLABCoder_LicenseError">コードの生成に必要な MATLAB Coder のライセンスを照合できません</entry>
    <entry key="EI_BoolParam">エンジン インターフェイス メソッド ''{0}'' に対する入力引数が無効です。パラメーター ''{1}'' は、ブール値 ''on'' または ''off'' のみ受け入れます</entry>
    <entry key="EI_UpdateOnlyNotAllowed">UpdateBDOnly は、HDL またはエンジン インターフェイスを使用するモデル リファレンス スタイルのコンパイルに対して、true であってはなりません。</entry>
    <entry key="EI_CannotCompleteEI">エンジン インターフェイス メソッドを完了できません</entry>
    <entry key="EI_EINotEnabled">Simulink エンジン インターフェイスは有効ではありません。</entry>
    <entry key="EI_ImproperSubclass">入力のクラスは、既定のクラスの適切なサブクラスではありません</entry>
    <entry key="EI_InvalidBlock">無効なブロック</entry>
    <entry key="EI_VirtualBlockDoesNotHaveCData">このブロックはバーチャルであり、最適化により除去されています。</entry>
    <entry key="EI_NOTASynthesizedBlock">ブロックは合成ブロックではありません。</entry>
    <entry key="EI_ObjChanged">モデルのコンパイル中にオブジェクトが変更されました</entry>
    <entry key="EI_InvalidInputPort">無効な入力端子</entry>
    <entry key="EI_InvalidModel">無効なモデル</entry>
    <entry key="EI_InvalidObject">無効な Simulink オブジェクト</entry>
    <entry key="EI_InvalidOption">無効なオプション</entry>
    <entry key="EI_InvalidBusSelElIdx">無効な busSelElIdx。busSelElIdx は、常に非バーチャル バスのソース ポートに関連付けられ、有効な整数 (-1 &gt;= busSelElIdx &gt; maxDFSIdx) でなければなりません。</entry>
    <entry key="EI_InvalidVBPort">ポートがバーチャル バス信号に関連付けられていません</entry>
    <entry key="EI_InvalidOutputPort">無効な出力端子</entry>
    <entry key="EI_InvalidSimType">無効な Sim タイプ</entry>
    <entry key="EI_InvalidUDIHandle">無効な UDI ハンドル</entry>
    <entry key="EI_MissingParamValPair">エンジン インターフェイス メソッド ''{0}'' に対する入力引数が無効です。入力パラメーター ''{1}'' は、一致する値がありません</entry>
    <entry key="EI_ModelInitiated">モデルは既に開始しています</entry>
    <entry key="EI_UnrecognizedParam">エンジン インターフェイス メソッド ''{0}'' に対する入力引数が無効です。入力パラメーター ''{1}'' は、有効なパラメーターではありません</entry>
    <entry key="EI_UnspecifiedInputPort">ブロックは複数の入力端子を持っています。指定してください</entry>
    <entry key="EI_UnspecifiedOutputPort">ブロックは複数の出力端子を持っています。指定してください</entry>
    <entry key="ElementNotFound">指定した要素が見つかりません</entry>
    <entry key="EI_EIIsLocked">エンジン インターフェイスがロックされています。MATLAB セッションを再起動するか、デバッガーを追加してロックされた値をリセットしなければなりません。このメッセージはリリース ビルドでは表示されません</entry>
    <entry key="EnabTrigECPotentialPreStartOutputDiff">''{0}'' の出力は、''{1}'' が t = 0 で有効化もトリガーもされていない場合、以前の Simulink のリリースと異なる結果を生成する可能性があります。ブロック ''{2}'' はゼロの入力に対して非ゼロの出力を生成する可能性があり、''{3}'' の実行コンテキストが継承されています。以前のリリースでは、''{4}'' は実行コンテキストは継承されず、条件付きサブシステムの開始前に非ゼロの出力を生成した可能性があります。コンテキストを継承させないようにするには、再計算させたい信号のレートに ''{5}'' のサンプル時間を明示的に設定します。この警告メッセージをオフにするには、&lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;[実行コンテキストのアクティブになる前の出力をチェック]&lt;/sldiag&gt; をオフにしてください。</entry>
    <entry key="EnabTrigECPotentialPreStartOutputDiffConsistentOutportInit">''{0}'' の出力は、''{1}'' が t = 0 で有効化もトリガーもされていない場合、以前の Simulink のリリースと異なる結果を生成する可能性があります。ブロック ''{2}'' はゼロの入力に対して非ゼロの出力を生成する可能性があり、''{3}'' の実行コンテキストが継承されています。以前のリリースでは、''{4}'' は実行コンテキストは継承されず、条件付きサブシステムの開始前に非ゼロの出力を生成した可能性があります。コンテキストを継承させないようにするには、再計算させたい信号のレートに ''{5}'' のサンプル時間を明示的に設定します。この警告メッセージをオフにするには、&lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;[実行コンテキストのアクティブになる前の出力をチェック]&lt;/sldiag&gt; をオフにしてください。</entry>
    <entry key="EnabledECPotentialPreStartOutputDiff">''{0}'' の出力は、''{1}'' が t = 0 で有効にされていない場合、以前の Simulink のリリースと異なる結果を生成する可能性があります。ブロック ''{2}'' はゼロの入力に対して非ゼロの出力を生成する可能性があり、''{3}'' の実行コンテキストが継承されています。以前のリリースでは、''{4}'' は実行コンテキストは継承されず、条件付きサブシステムの開始前に非ゼロの出力を生成した可能性があります。コンテキストを継承させないようにするには、再計算させたい信号のレートに ''{5}'' のサンプル時間を明示的に設定します。この警告メッセージをオフにするには、&lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;[実行コンテキストのアクティブになる前の出力をチェック]&lt;/sldiag&gt; をオフにしてください。</entry>
    <entry key="EnabledECPotentialPreStartOutputDiffConsistentOutportInit">''{0}'' の出力は、''{1}'' が t = 0 で有効にされていない場合、以前の Simulink のリリースと異なる結果を生成する可能性があります。ブロック ''{2}'' はゼロの入力に対して非ゼロの出力を生成する可能性があり、''{3}'' の実行コンテキストが継承されています。以前のリリースでは、''{4}'' は実行コンテキストは継承されず、条件付きサブシステムの開始前に非ゼロの出力を生成した可能性があります。コンテキストを継承させないようにするには、再計算させたい信号のレートに ''{5}'' のサンプル時間を明示的に設定します。この警告メッセージをオフにするには、&lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;[実行コンテキストのアクティブになる前の出力をチェック]&lt;/sldiag&gt; をオフにしてください。</entry>
    <entry key="RootOutportDirectConnToIRTRootInport">ルート Outport ブロック ''{0}'' はルート Inport ブロック ''{1}'' によって駆動できません。ルート Inport ブロックが、Initialize Function ブロック、Reinitialize Function、Reset Function ブロック、または Terminate Function ブロックにも接続されているためです。</entry>
    <entry key="VirtualRootOutportDirectConnToRootInport">バーチャル ルート Outport ブロック ''{0}'' は、ルート Inport ブロック ''{1}'' に直接接続できません。</entry>
    <entry key="MATFileLoggingDataObjectRootOutport">モデル内の Outport ブロック ''{0}'' は、非自動ストレージ クラスの信号によって駆動されています。MAT ファイルのログは、この構成ではサポートされていません。</entry>
    <entry key="ErrInExtModeMexFile">エクスターナル モードの MEX ファイル ''{0}'' の実行中にエラーが発生しました:\n{1}</entry>
    <entry key="ErrorAnnotationCallback">注釈 ''{0}''。''{1}'' コールバックのエラー</entry>
    <entry key="ErrorInMultipleDimsModes">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; から ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; に次元モード情報を伝播できません。出力端子 {4,number,integer} で多重化された信号には、入力端子 {5,number,integer} と一致しない次元モードが設定されています。</entry>
    <entry key="ErrorInMultipleFrames">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; から ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; にフレーム情報を伝播中にエラーが発生しました。端子は矛盾するフレーム情報をもつ多重化された信号を受け入れるよう設定されています。</entry>
    <entry key="ErrorNotWrittenYet">''{0}'' でエラーが見つかりました。エラー メッセージを割り当てるおよび/または書き込む必要があります。</entry>
    <entry key="ExecEventAccessError">実行イベント リスナーのブロックへの追加と削除を行えるのは、シミュレーション中のみです。ブロック ''{0}'' は現在実行されていません。そのためイベント リスナーをこのブロックに追加できません。</entry>
    <entry key="EventCallbackNotSupportedForMultiThreadCoSim">ブロックがマルチスレッド モードで実行されている場合、実行イベント リスナーのコールバックはサポートされていません。コマンド set_param(''{0}'','MultiThreadCoSim','off') を実行して、''{1}'' のマルチスレッドをオフにしてください。</entry>
    <entry key="ExportFcnsMode_AbsoluteTimeNotSupported">ブロック ''{0}'' は絶対時間を使用していますが、これは現在の関数呼び出しのエクスポートの設定ではサポートされていません。</entry>
    <entry key="ExportFcnsMode_NonInlinedSFcnsNotSupported">ブロック ''{0}'' は、関数呼び出しをエクスポートするために、現在の設定でサポートされていないインラインではない S-function です。</entry>
    <entry key="ExportedFcnCallSrcInsideContext">関数呼び出しブロック ''{0}'' の入力は、自身の出力に依存します。これによって関数呼び出しの期間全体で固定されないサブシステムの入力が生ずる可能性があります。対応する入力の前に Function-Call Feedback Latch ブロックを配置するか、または対応する Inport ブロックで [Function-Call Subsystem 出力のフィードバック信号の入力をラッチするz] オプションを選択することを検討してください。</entry>
    <entry key="ExportedFcnCallSILSrcInsideContext">ブロック ''{0}'' は、入力が自身の出力に依存する上、その入力をラッチしないサブシステムからエクスポートされたコードをシミュレートします。このため、コードのシミュレーションと、元のサブシステムのシミュレーションの結果が異なる場合があります。元のサブシステムで対応する入力の前に Function-Call Feedback Latch ブロックを配置するか、または対応する Inport ブロックで [Function-Call Subsystem 出力のフィードバック信号の入力をラッチする] オプションを選択することを検討してください。</entry>
    <entry key="ExtInpSFExecAtInit">Stateflow チャート ''{1}'' でチェック ボックス [初期化時に指定されたチャートを実行 (入力)] がオンになっている場合、ルート入力端子 ''{0}'' における値は、このチャートによって使用されています。この設定は {2} ではサポートされません。チャートの [初期化時に指定されたチャートを実行 (入力)] チェック ボックスをクリアする、または、ルートの Inport のすぐ後に Signal Conversion ブロックを挿入することを検討し、[''ブロック削減'' の最適化からこのブロックを排除する] チェック ボックスが Signal Conversion ブロックに対して選択されていることを確認してください</entry>
    <entry key="ExtInpSimscapeWhenFPC">ルートの Inport ブロック {0} の値は、Simscape ブロック ''{1}'' で使用されています。この設定は {2} ではサポートされません。ルートの Inport ブロックのすぐ後に Simulink Signal Conversion ブロックを挿入することを検討してください。必ず、Signal Conversion ブロックのパラメーター ['ブロック削減' の最適化からこのブロックを排除する] を選択してください。</entry>
    <entry key="ExtModeCannotDownloadParamBecauseNoHostToTarget">タイプ ({1}) はエクスターナル モードの関数 host-to-target に登録されていないため、パラメーター {0} をダウンロードできません</entry>
    <entry key="ExtModeCantUploadDataCSC">ソース信号の 1 つがカスタムのストレージ クラスを使用しているため、Simulink はデータを ''{0}'' にアップロードすることができません</entry>
    <entry key="ExtModeCantUploadDataConstantSampleTime">ブロックまたはそのソース ブロックの 1 つに定数のサンプル時間があるため、Simulink はデータを ''{0}'' にアップロードできません</entry>
    <entry key="ExtModeCantUploadDataMultipleRates">シングル レートではないため、Simulink はデータを ''{0}'' にアップロードすることができません。</entry>
    <entry key="ExtModeCantUploadDataNoConnectedSignals">接続された信号がないため、Simulink はデータを ''{0}'' にアップロードすることができません</entry>
    <entry key="ExtModeCantUploadDataNoConvertFunc">ソース信号の 1 つがエクスターナル モードでサポートされないデータ型を使用しているため、Simulink はデータを ''{0}'' にアップロードすることができません</entry>
    <entry key="ExtModeCantUploadDataNoDWork">アップロード可能な dwork がないため、Simulink はデータを ''{0}'' にアップロードすることができません</entry>
    <entry key="ExtModeCantUploadDataNoInputPorts">アップロード可能な入力端子がないため、Simulink はデータを ''{0}'' にアップロードすることができません</entry>
    <entry key="ExtModeCantUploadDataPortBasedSampleTime">ブロックまたはそのソース ブロックの 1 つに端子ベースのサンプル時間があるため、Simulink はデータを ''{0}'' にアップロードできません</entry>
    <entry key="ExtModeCantUploadDataRootInport">駆動ブロックの 1 つが最上位の Inport であるため、Simulink はデータを ''{0}'' にアップロードすることができません</entry>
    <entry key="ExtModeCantUploadDataVarDims">ソース信号の 1 つが可変サイズであるため、Simulink はデータを ''{0}'' にアップロードすることができません。可変サイズの信号は、エクスターナル モードの TCP/IP プロトコルとシリアル転送プロトコルでのみサポートされています。さらに、ターゲット ハードウェアでの 'int' のサイズは、MATLAB 開発用コンピューターでのサイズと一致しなければなりません。</entry>
    <entry key="ExtModeChecksumMismatch">エクスターナル モードで実行しようとしているモデルが、ターゲットで実行中のアプリケーションに適合しません。チェックサム テスト ({0}) に失敗しました。ホスト モデルの構造的チェックサムは [{1,number,integer}, {2,number,integer}, {3,number,integer}, {4,number,integer}] で、ターゲット アプリケーションの構造的チェックサムは [{5,number,integer}, {6,number,integer}, {7,number,integer}, {8,number,integer}] です。モデルをリビルドし、ターゲットで実行してから、エクスターナル モードのシミュレーションを再度実行してください。</entry>
    <entry key="ExtModeErrorCallingSFcnExtModeFcn">''{0}'' に対するエクスターナル モード関数の呼び出し中にエラーが発生しました: {1}</entry>
    <entry key="ExtModeErrorCalllingExtmodeTransports">extmode_transports.m の呼び出しエラー。</entry>
    <entry key="ExtModeErrorGettingIntrfLevelFromExtmodeTransports">extmode_transports.m から ExtModeIntrfLevel に対する適切な値を取得できません</entry>
    <entry key="ExtModeErrorGettingMexFileFromExtmodeTransports">extmode_transports.m から ExtModeMexFile に対する適切な値を取得できません</entry>
    <entry key="ExtModeFailToWriteMatFile">行列の MAT ファイルへの書き込みに失敗しました</entry>
    <entry key="ExtModeFileDirNameEmpty">[外部データをアーカイブする] ダイアログの [ディレクトリ] および [ファイル] フィールドに、ディレクトリまたはファイル名を指定しなければなりません</entry>
    <entry key="ExtModeInvTrigDuration">エクスターナル モードのトリガーの所要時間は、0 より大きいスカラーの整数である必要があります</entry>
    <entry key="ExtModeInvalidPositiveValue">''{0}'' は正の値でなければなりません。</entry>
    <entry key="ExtModeInvalidNonNegativeValue">''{0}'' を負の値にしてはなりません。</entry>
    <entry key="ExtModeInvalidTrigBlock">無効なエクスターナル モードのトリガー信号です</entry>
    <entry key="ExtModeInvalidTrigBlockPath">トリガー信号 ''{0}'' が有効ではありません。[外部信号とトリガー] ダイアログ ボックスを使用して有効な信号を指定してください。</entry>
    <entry key="ExtModeInvalidTrigElementSpec">エクスターナル モードのトリガー要素の指定は、1 つの整数、キーワード ''last''、キーワード ''any'' のいずれかでなければなりません</entry>
    <entry key="ExtModeInvalidTrigPortSpec">エクスターナル モードのトリガー端子の指定は、単一の整数またはキーワード ''last'' でなければなりません</entry>
    <entry key="ExtModeMultipleTriggers">複数のエクスターナル モードのトリガーが見つかりました</entry>
    <entry key="ExtModeSFAndMATLABFcnInvalidTriggers">エクスターナル モードは、Stateflow または MATLAB Function ブロックをトリガー信号として使用できません</entry>
    <entry key="ExtModeMustBeConnectedToStartTarget">ターゲットが接続されていないので、エクスターナル モード シミュレーションを開始することができません。</entry>
    <entry key="ExtModeOneClickNeedsSLCoder">Simulink とターゲット ハードウェアが接続されておらず、Simulink Coder がインストールされていないため、エクスターナル モード シミュレーションを実行できません。エクスターナル モード シミュレーションのビルドと展開を行って、開始するには、Simulink Coder をインストールしてください。既に展開されているモデルのシミュレーションを開始するには、Simulink をターゲット ハードウェアに接続してください。</entry>
    <entry key="ExtModeUnexpectedIncomingPacketFromTarget">Simulink がターゲットから予期しない着信パケットを受信したため、エクスターナル モードを終了します。</entry>
    <entry key="ExtModeNameTooLong">名前が長すぎて添え字を追加できません</entry>
    <entry key="ExtModeNoHostToTarget">{0} はエクスターナル モードの関数 host-to-target に登録されていないため、信号をそのタイプにすることはできません</entry>
    <entry key="ExtModeNoTargetToHost">{0} はエクスターナル モードの関数 target-to-host に登録されていないため、そのタイプのオブジェクトをアップロードできません</entry>
    <entry key="ExtModeNoTrigSpecified">トリガーが指定されていません</entry>
    <entry key="ExtModeNotAllRequiredFieldsSet">エクスターナル モード (ExtConnect) の初期化は、すべての必要なフィールド (例: sizeofTargetReal, hostToTargetRealFcn) の初期化に失敗しました</entry>
    <entry key="ExtModeOpenProtocolError">External Mode Open Protocol {0} のコマンドは失敗しました</entry>
    <entry key="ExtModeOpenProtocolErrorWithStatus">External Mode Open Protocol {0} のコマンドは、状態 {1,number,integer} で失敗しました</entry>
    <entry key="ExtModeOpenProtocolInvalidTimeSeriesData">ソース信号の 1 つが不正にフォーマットされたデータをアップロードしたため、''{0}'' はデータをアップロードできません。これには、次の理由が考えられます:\n \t(1) 時間とデータ ベクトルは長さが等しくない \n \t(2) タイプ、データ ベクトルの次元または複雑度、そしてソースの信号が一致しない\n \t(3) 時間ベクトルのタイプが ''double'' でない\n \t(4) パラメーター [ExtModeOpenProtocolUploadingEqualLengthVectors] は ''on'' だがすべてのデータ ベクトルの長さが等しくない</entry>
    <entry key="ExtModeOpenProtocolParamNotSupported">パラメーター ''{0}'' は、選択した External Mode Open Protocol トランスポート層によりサポートされていません。</entry>
    <entry key="ExtModeOpenProtocolIntegerOnlyMismatch">''PurelyIntegerCode'' のモデルの値がターゲット アプリケーションの対応する値と一致しません。''PurelyIntegerCode'' のモデルの値を更新して、ターゲット アプリケーションをリビルドしてください。</entry>
    <entry key="ExtModeOpenProtocolDataDrop">ターゲット アプリケーションからアップロードされた信号を受信して表示する 1 つ以上のブロック (Floating Scope ブロックと Scope ブロック、Spectrum Analyzer ブロックと Time Scope ブロック、Display ブロック、To Workspace ブロックなど) でデータが破棄されました。考えられる原因は、ターゲット アプリケーションでサンプリングされた時間変数の精度が十分でないことです。それらのブロックを Simulation Data Inspector ブロックまたは Dashboard ブロックに置き換えることを検討してください。</entry>
    <entry key="ExtModeTrigElementOutOfRange">''{0}'' 端子 ''{1,number,integer}'' に対して指定されたエクスターナル モードのトリガー要素は、負または範囲外です。入力幅は {2,number,integer} です。指定した端子: {3}</entry>
    <entry key="ExtModeTrigPortOutOfRange">''{0}'' に対して指定されたエクスターナル モードのトリガー端子は、負または範囲外です。{1,number,integer} 個の端子があります。指定した端子: {2}</entry>
    <entry key="ExtModeTrigSigInTriggeredSubsys">''{0}'' への入力は、データのアップロードに対してトリガー信号として指定されています。トリガー信号は、トリガーされたサンプル時間の接続先をもつことができません。</entry>
    <entry key="ExtOutSFExecAtInit">Stateflow チャート ''{1}'' でチェック ボックス [初期化時に指定されたチャートを実行 (入力)] が選択されている場合、ルートの Outport ''{0}'' の値がそのチャートに割り当てられます。この設定は {2} ではサポートされません。チャートの [初期化時に指定されたチャートを実行 (入力)] チェック ボックスをクリアする、または、ルートの Outport のすぐ前に Signal Conversion ブロックを挿入することを検討し、[''ブロック削減'' の最適化からこのブロックを排除する] チェック ボックスが Signal Conversion ブロックに対して選択されていることを確認してください</entry>
    <entry key="ExternalDomainRegistrationSymbolNotFound">''{0}'' に対する登録記号が見つかりません。\n''{1}''</entry>
    <entry key="InvalidDomainRegistrationKey">''{0}'' のレジストレーション キーが無効です。</entry>
    <entry key="ExternalModeNotReusableUnconditionalError">エクスターナル モードのシミュレーションが選択された場合、生成されたコードは再利用可能ではありません。[コンフィギュレーション パラメーター]、[コード生成]、[インターフェイス] ペインで、[コード インターフェイスのパッケージ化] を [再利用できない関数] に設定することを検討してください。</entry>
    <entry key="ExternalModeNotReusableMultiInstanceErrorDiagnostic">エクスターナル モード シミュレーションが選択されているため、''{0}'' に対する生成コードは再利用可能ではありません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;[コード インターフェイスのパッケージ化]&lt;/sldiag&gt; を [再利用できない関数] に設定する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''MultiInstanceErrorCode'',''None'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="MultiInstanceErrorCode"&gt;[マルチインスタンス コードのエラーの診断]&lt;/sldiag&gt; を [なし] に設定して、このメッセージを非表示にする&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;      
</entry>
    <entry key="ExternalModeCppClassProfilingNotSupportedError">When external mode simulation is chosen and ''Code interface packaging'' is set to ''C++ Class'', code execution profiling is not supported. Consider setting ''CodeExecutionProfiling'' to off.</entry>
    <entry key="ExtraModelrefNoncontSignal">モデル ブロック ''{0}'' が不連続点をもつ信号を出力し、連続状態をもつブロックに入力しています。正しい解を確実に得るため、連続サンプル時間をもつモデル ブロックの入力端子に送られる離散信号もすべてトラッキングしています。これはソルバーの余分なリセットを生じる可能性があります。この診断は &lt;sldiag objui="configset" objparam="ModelReferenceExtraNoncontSigs"&gt;[不要な離散微分信号]&lt;/sldiag&gt; を [なし] に設定することで無効にできます</entry>
    <entry key="FcnCallActionDataDepViolation">関数呼び出しサブシステムまたはアクション サブシステムの利用によるデータ依存性エラー。ループを赤いラインに従って前進方向、もしくは青いラインに従って後退方向にたどることができます。緑のラインは、ループ内の前進および後退のパスのオーバーラップを意味します。追加情報については、&lt;a href=\"matlab:openExample('simulink_features/SimulinkSubsystemSemanticsExample'); open_system('sl_subsys_semantics/ Function-call subsystems');\"&gt;''sl_subsys_semantics''&lt;/a&gt; にある Function-Call Subsystem の有効な例と無効な例を参照してください。</entry>
    <entry key="MessageServiceDelegationOpNew">モデル {0} に参照モデルとメッセージを送受信するブロック {1} が含まれる場合、パラメーター [Model ブロックのインスタンス化に動的メモリ割り当てを使用] はサポートされません。[コンフィギュレーション パラメーター] &gt; [コード生成] &gt; [インターフェイス] ペインで、[Model ブロックのインスタンス化に動的メモリ割り当てを使用] チェック ボックスをオフにしてください。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''UseOperatorNewForModelRefRegistration'',''off'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="'UseOperatorNewForModelRefRegistration'"&gt;&lt;/sldiag&gt;[Model ブロックのインスタンス化に動的メモリ割り当てを使用] を選択解除する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="FunctionServiceDelegationOpNew">関数を指定する、または必要とするバス要素端子 {1} がモデル {0} に含まれている場合、パラメーター [Model ブロックのインスタンス化に動的メモリ割り当てを使用] はサポートされません。[コンフィギュレーション パラメーター] &gt; [コード生成] &gt; [インターフェイス] ペインで、[Model ブロックのインスタンス化に動的メモリ割り当てを使用] チェック ボックスをオフにしてください。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''UseOperatorNewForModelRefRegistration'',''off'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="'UseOperatorNewForModelRefRegistration'"&gt;&lt;/sldiag&gt;[Model ブロックのインスタンス化に動的メモリ割り当てを使用] を選択解除する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="FunctionServiceCircularDependency">モデル {0} のコードを生成できません。モデル {0} には Model ブロック {1} および {2} が含まれており、これらは依存ループの一部です。この依存ループを切断するには、単一モデルにクライアント関数端子とサーバー関数端子の両方を含めないでください。</entry>
    <entry key="FunctionServiceUnconnectedClient">関数を指定する、または必要とする未接続のバス要素端子 {1} をもつ Model ブロックが含まれているモデル {0} のコードは生成できません。コードを生成するには、Model ブロックの端子を入力ブロックまたは出力ブロックに接続してください。</entry>
    <entry key="FcnCallActionDataDepViolationWarn">関数呼び出しサブシステムまたはアクション サブシステムの利用によるデータ依存性エラー。これらの依存関係をトレースするには、[コンフィギュレーション パラメーター] &gt; [診断] &gt; [接続性] &gt; [関数の呼び出し] &gt; [無効な関数呼び出し接続] で [エラー] を選択します。[警告] オプションは将来のリリースで廃止される予定であることに注意してください。追加情報については、&lt;a href=\"matlab:openExample('simulink_features/SimulinkSubsystemSemanticsExample'); open_system('sl_subsys_semantics/ Function-call subsystems');\"&gt;''sl_subsys_semantics''&lt;/a&gt; にある Function-Call Subsystem の有効な例と無効な例を参照してください。</entry>
    <entry key="FcnCallECPotentialPreStartOutputDiff">''{0}'' の出力は、''{1}'' が t = 0 で呼び出されない場合、以前の Simulink のリリースと異なる結果を生成する可能性があります。ブロック ''{2}'' はゼロの入力に対して非ゼロの出力を生成する可能性があり、''{3}'' の実行コンテキストが継承されています。以前のリリースでは、''{4}'' は実行コンテキストは継承されず、条件付きサブシステムの開始前に非ゼロの出力を生成した可能性があります。コンテキストを継承させないようにするには、再計算させたい信号のレートに ''{5}'' のサンプル時間を明示的に設定します。この警告メッセージをオフにするには、&lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;[実行コンテキストのアクティブになる前の出力をチェック]&lt;/sldiag&gt; をオフにしてください。</entry>
    <entry key="FcnCallECPotentialPreStartOutputDiffConsistentOutportInit">''{0}'' の出力は、''{1}'' が t = 0 で呼び出されない場合、以前の Simulink のリリースと異なる結果を生成する可能性があります。ブロック ''{2}'' はゼロの入力に対して非ゼロの出力を生成する可能性があり、''{3}'' の実行コンテキストが継承されています。以前のリリースでは、''{4}'' は実行コンテキストは継承されず、条件付きサブシステムの開始前に非ゼロの出力を生成した可能性があります。コンテキストを継承させないようにするには、再計算させたい信号のレートに ''{5}'' のサンプル時間を明示的に設定します。この警告メッセージをオフにするには、&lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;[実行コンテキストのアクティブになる前の出力をチェック]&lt;/sldiag&gt; をオフにしてください。</entry>
    <entry key="FcnCallPortGroupedBlkSrcInsideContext">Model ブロック ''{0}'' には関数呼び出しが入力されており、そのデータ入力はそれ自身の出力に依存します。 このため、実行時にブロックの入力が変わる場合があります。 対応する入力の前に、Function-Call Feedback Latch ブロックを配置することを検討してください。 もう 1 つの方法として、Model ブロック ''{1}'' 内の対応するルートの Inport ブロックを接続先とするすべての下流の Inport ブロックで、[Function-Call Subsystem 出力のフィードバック信号の入力をラッチする] パラメーターを選択する方法があります。</entry>
    <entry key="FcnCallMdlBlkSrcInsideContext">Model ブロック ''{0}'' には関数呼び出しが入力されており、そのデータ入力はそれ自身の出力に依存します。このため、実行時にブロックの入力が変わる場合があります。対応する入力の前に Function-Call Feedback Latch ブロックを配置するか、またはモデル ''{1}'' の対応する Inport ブロックで [Function-Call Subsystem 出力のフィードバック信号の入力をラッチする] パラメーターを選択することを検討してください。</entry>
    <entry key="FcnCallSSCycleDataDepViolation">関数呼び出しブロックによる入力データ依存性エラー。次の関数呼び出しブロックは巡回的に呼び出され、共通の関数呼び出しイニシエーターがありません。巡回的呼び出しを解除するには、Stateflow Chart のような単一のブロックをイニシエーターとして使うことができます。共通の関数呼び出しイニシエーターが使用される場合、呼び出された関数呼び出しブロック間のすべてのデータ接続はデータ ストア (グローバル変数) として扱われ、データの暗黙的な依存関係はありません。Memory または Unit Delay を適切な位置に挿入することによっても、ループを解除できます。追加情報については、&lt;a href=\"matlab:openExample('simulink_features/SimulinkSubsystemSemanticsExample'); open_system('sl_subsys_semantics/ Function-call subsystems');\"&gt;''sl_subsys_semantics''&lt;/a&gt; にある Function-Call Subsystem の有効な例と無効な例を参照してください。</entry>
    <entry key="FcnCallSSSrcInsideContext">Function-Call Subsystem ''{0}'' の入力は、自身が呼び出すコンテキスト内に現れる次のソース ブロックに依存します: {1}。この依存関係によって、関数を呼び出している間はサブシステムの入力が固定にならない可能性があります。また、コード生成の結果がシミュレーション結果とは異なる可能性もあります。対応する入力の前に Function-Call Feedback Latch ブロックを配置するか、対応する Function-Call Subsystem の Inport ブロックで [Function-Call Subsystem 出力のフィードバック信号の入力をラッチする] パラメーターを選択することを検討してください。</entry>
    <entry key="FcnCallSSSrcInsideContextStatus">''{0}'' の 1 つ以上の関数呼び出しブロックの入力が、自身を呼び出すコンテキスト内にあるソース ブロックに依存しています。&lt;sldiag objui="configset" objparam="FcnCallInpInsideContextMsg"&gt;[コンテキスト依存の入力]&lt;/sldiag&gt; で [エラー] が選択されているため、この条件はエラーとして報告されます。追加情報については、&amp;lt;a href=\"matlab:openExample('simulink_features/SimulinkSubsystemSemanticsExample'); open_system('sl_subsys_semantics/ Function-call subsystems');\"&amp;gt;''sl_subsys_semantics''&amp;lt;/a&amp;gt; にある Function-Call Subsystem の有効な例と無効な例を参照してください。</entry>
    <entry key="FcnCallSSSrcInsideContextGoingToExportStatus">1 つ以上の Function-Call ブロックの入力は、自身を呼び出すコンテキスト内に表示されるソース ブロックに依存します。特に 1 つ以上の Function-Call ブロックはエクスポートされる関数に対応するので、エクスポートされたコードの動作がサブシステムの動作と異なることがあります。[コンフィギュレーション パラメーター] &gt; [診断] &gt; [接続性] &gt; [関数の呼び出し] &gt; [コンテキスト依存の入力] で [エラー] が選択されているため、この条件はエラーとして報告されます。追加情報については、&lt;a href=\"matlab:openExample('simulink_features/SimulinkSubsystemSemanticsExample'); open_system('sl_subsys_semantics/ Function-call subsystems');\"&gt;''sl_subsys_semantics''&lt;/a&gt; にある Function-Call Subsystem の有効な例と無効な例を参照してください。</entry>
    <entry key="FcnCallSSSrcInsideContextGoingToExportTip">1 つ以上の Function-Call ブロックの入力は、自身を呼び出すコンテキスト内に表示されるソース ブロックに依存します。特に 1 つ以上の Function-Call ブロックはエクスポートされる Function-Call Subsystem なので、エクスポートされたコードの動作がサブシステムの動作と異なる場合があります。これらの依存関係をトレースするには、[コンフィギュレーション パラメーター] &gt; [診断] &gt; [接続性] &gt; [関数の呼び出し] &gt; [コンテキスト依存の入力] で [エラー] を選択します。[警告] オプションは将来のリリースで廃止される予定であることに注意してください。追加情報については、&lt;a href=\"matlab:openExample('simulink_features/SimulinkSubsystemSemanticsExample'); open_system('sl_subsys_semantics/ Function-call subsystems');\"&gt;''sl_subsys_semantics''&lt;/a&gt; にある Function-Call Subsystem の有効な例と無効な例を参照してください。</entry>
    <entry key="FcnCallSSSrcInsideContextTip">1 つ以上の Function-Call ブロックの入力は、自身を呼び出すコンテキスト内に表示されるソース ブロックに依存します。これらの依存関係をトレースするには、[コンフィギュレーション パラメーター] &gt; [診断] &gt; [接続性] &gt; [関数の呼び出し] &gt; [コンテキスト依存の入力] で [エラー] を選択します。[警告] オプションは将来のリリースで廃止される予定であることに注意してください。追加情報については、&lt;a href=\"matlab:openExample('simulink_features/SimulinkSubsystemSemanticsExample'); open_system('sl_subsys_semantics/ Function-call subsystems');\"&gt;''sl_subsys_semantics''&lt;/a&gt; にある Function-Call Subsystem の有効な例と無効な例を参照してください。</entry>
    <entry key="FcnCallSSMessageSrcInsideContext">Function-Call Subsystem ''{0}'' のメッセージ入力は、それ自身が呼び出すコンテキスト内に現れる次のソース ブロックに依存します: {1}。この依存関係は、Function-Call Subsystem から取得するメッセージにより、シミュレーション時間が進まずにサイクルを無限に繰り返す、無限のサイクル状態を引き起こす可能性があります。対応する入力の前に、Message Delay ブロックを配置することを検討してください。</entry>
    <entry key="FileNameCycle">次のサブシステムは、循環的な依存問題を起こすファイルにコードを生成しています。システムのファイル名を変更してこの循環を取り消してください</entry>
    <entry key="FileNameCycleBlockMsg">ファイル ''{0}'' (サブシステム ''{1}'' による) は、ファイル ''{2}'' (サブシステム ''{3}'' による) を含んでいます。</entry>
    <entry key="FocingSFcnDFMsg">モデル ''{0}'' は次を指定しています:\n \tset_param(''{1}'',''TryForcingSFcnDF'',''on'');\n この設定により、Simulink 4.0 とそれ以前のバージョンで特殊な実行モードを利用できるため、S-Function に補正を実行できます:\n \t(1) 入力端子に直達をもたない S-Function を mdlInitializeSizes で指定。\n \t(2) 次に、mdlOutputs または mdlGetTimeOfNextVarHit メソッドにより、対応する入力信号にアクセス。\n この補正モードの結果、非バーチャル サブシステム内で S-Function が含まれるモデルについて、ブロックの実行順序が不正確になることもあります。モデル内で任意の S-Function を更新して、mdlOutputs() または mdlGetTimeOfNextVarHit() でアクセスされた任意の入力端子信号に直達を指定し、次のコマンドを実行してください: \tset_param(''{2}'',''TryForcingSFcnDF'',''off'');\n 「直達」の用語は誤解されやすいことに注意してください。混乱を避けるために直達を「必要な入力」として考えることができます。特に、S-Function が mdlOutputs() または mdlGetTimeOfNextVarHit() のどちらかで入力信号にアクセスする場合は、直達のフラグを 1 (真) に設定しなければなりません。\n</entry>
    <entry key="FramesNeedsSigProcLicense">''{0}'' は、フレームベースのサンプリング モードをもついくつかのブロックを含んでいます。Simulink でフレームベースの処理を行うには DSP System Toolbox のライセンスが必要です。</entry>
    <entry key="FramesNeedsSigProcLicenseInpPort">ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; のサンプリング モードをフレームに設定する間にエラーが発生しました。Simulink でフレームベースの処理を行うには DSP System Toolbox のライセンスが必要です。</entry>
    <entry key="FramesNeedsSigProcLicenseOutPort">ブロック ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; のサンプリング モードをフレームに設定する間にエラーが発生しました。Simulink でフレームベースの処理を行うには DSP System Toolbox のライセンスが必要です。</entry>
    <entry key="FwdPropDoesNotSupportND">{0,number,integer} 次元信号をブロック ''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; からブロック ''{4}'' の&lt;sldiag objui="inport" objparam="{3,number,integer}" objname="{4}"&gt;入力端子 {3,number,integer}&lt;/sldiag&gt; に伝播できません。後続のブロックは、(すべて、または現在の設定のいずれかにおいて) 2 より大きい次元をもつ信号を受け入れません。</entry>
    <entry key="FwdPropDoesNotSupportNDCompSig">ブロック ''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; からブロック ''{4}'' の&lt;sldiag objui="inport" objparam="{3,number,integer}" objname="{4}"&gt;入力端子 {3,number,integer}&lt;/sldiag&gt; に少なくとも {0,number,integer} 次元信号を含む合成信号を伝播できません。後続のブロックは、(すべて、または現在の設定のいずれかにおいて) 2 より大きい次元をもつ信号を受け入れません。</entry>
    <entry key="FwdTableNotLibWarn">ブロック線図 ''{0}'' の転送テーブルがライブラリではないため、設定することができません。指定の転送テーブル情報を廃棄しています</entry>
    <entry key="FxpPointFiToNoFPSignal">''{0}'' に無効な指定: fi オブジェクトを固定小数点ではない信号に割り当てようとしています</entry>
    <entry key="FxpPointInvDataTypeID">データ型 id は、Simulink の組み込み、または固定小数点のデータ型に対応しません。</entry>
    <entry key="FxpPoint_Bias_Mismatch">''{0}'' に無効な指定: バイアス {1} の fi オブジェクトをバイアス {2} の固定小数点の信号に割り当てようとしています</entry>
    <entry key="FxpPoint_Frac_Length_Mismatch">''{0}'' に無効な指定: 小数部の長さ {1,number,integer} の fi オブジェクトを小数部の長さ {2,number,integer} の固定小数点の信号に割り当てようとしています</entry>
    <entry key="FxpPoint_Sign_Mismatch1">''{0}'' に無効な指定: 符号付きの fi オブジェクトを符号なしの信号に割り当てようとしています</entry>
    <entry key="FxpPoint_Sign_Mismatch2">''{0}'' に無効な指定: 符号なしの fi オブジェクトを符号付きの信号に割り当てようとしています</entry>
    <entry key="FxpPoint_Slope_Mismatch">''{0}'' に無効な指定: 傾き {1} の fi オブジェクトを傾き {2} の固定小数点の信号に割り当てようとしています</entry>
    <entry key="FxpPoint_Word_Length_Mismatch">''{0}'' に無効な指定: 語長 {1,number,integer} の fi オブジェクトを語長 {2,number,integer} の固定小数点の信号に割り当てようとしています</entry>
    <entry key="FxpPoint_DataType_Mismatch">''{0}'' の割り当てが無効です。fi オブジェクトを DataType プロパティ ''{1}'' に割り当てようとしましたが、信号のプロパティと一致しません。</entry>
    <entry key="GetCurrentTimeInExecOnly">''{0}'' の現在のシミュレーション時間は、シミュレーション実行中にのみアクセス可能です。</entry>
    <entry key="HalfUnsupportedForSldv">データ型が無効です。half は Simulink Design Verifier または固定小数点ツールの範囲解析ワークフローでサポートされていません。</entry>
    <entry key="ITVSActionSubsysMustHaveScalarIC">Simulink は無効の初期出力を検出しました。条件付きで実行されるサブシステム ''{1}'' が [可変サイズの信号のサイズを伝播] が ''実行の再開時のみ'' に設定されている ''{2}'' にある場合、スカラーの初期出力のみ ''{0}'' 内で許可されます。</entry>
    <entry key="ITVSActionSubsysVarDimsMismatch">''{2}'' の端子 {1,number,integer} における入力信号の現在の次元 {0,number,integer} は、前回の値 {3,number,integer} から時間 {5} での {4,number,integer} の現在の値に変更することができません。サブシステム内の ''{6}'' に対して、[可変サイズの信号のサイズを伝播] のパラメーターは [実行の再開時のみ] に設定されています。しかし、サブシステムの実行は既にこのタイム ステップの前に再開されているため、信号のサイズを変更することができません。入力サイズの変動は、サブシステムの実行が再開された時点でそのタイム ステップと同期する必要があります。</entry>
    <entry key="ITVSFcnCallSubsysVarDimsMismatch">''{2}'' の端子 {1,number,integer} における入力信号の現在の次元 {0,number,integer} は、時間 {3} で変更することができません。サブシステム内の ''{4}'' に対して、[可変サイズの信号のサイズを伝播] パラメーターは [イネーブルのときのみ] に設定されています。しかし、サブシステムは既にこのタイム ステップの前にイネーブルになっているため、信号のサイズを変更することができません。サブシステムがイネーブルになった時点でそのタイム ステップと同期するように、信号の入力サイズの変動を変更することを検討してください。この解法が不十分な場合は、Enabled サブシステムの内部に関数呼び出し開始プログラムを配置してください。</entry>
    <entry key="ITVSResetSubsysVarDimsMismatch">''{2}'' の端子 {1,number,integer} における入力信号の現在の次元 {0,number,integer} は、前回の値 {3,number,integer} から時間 {5} での {4,number,integer} の現在の値に変更することができません。サブシステム内の ''{6}'' に対して、[可変サイズの信号のサイズを伝播] のパラメーターは [リセット時のみ] に設定されています。しかし、このタイム ステップでサブシステムがリセットされていないため、信号サイズを変更できません。入力サイズの変動は、サブシステムがリセットされた時点でそのタイム ステップと同期する必要があります。</entry>
    <entry key="ITVSSubsysMustHaveScalarIC">Simulink は無効の初期出力を検出しました。条件付きで実行されるサブシステム ''{1}'' が [可変サイズの信号のサイズを伝播] が ''イネーブルのときのみ'' に設定されている ''{2}'' にある場合、スカラーの初期出力のみ ''{0}'' 内で許可されます。</entry>
    <entry key="ITVSSubsysVarDimsMismatch">''{2}'' の端子 {1,number,integer} における入力信号の現在の次元 {0,number,integer} は、前回の値 {3,number,integer} から時間 {5} での {4,number,integer} の現在の値に変更することができません。サブシステム内の ''{6}'' に対して、[可変サイズの信号のサイズを伝播] のパラメーターは [イネーブルのときのみ] に設定されています。しかし、サブシステムは既にこのタイム ステップの前にイネーブルになっているため、信号のサイズを変更することができません。入力サイズの変動は、サブシステムがイネーブルになった時点でそのタイム ステップと同期する必要があります。</entry>
    <entry key="IgnoringDataTypeHeaderFilesForERTSfcn">指定したデータ型のヘッダー ファイルは、ERT S-function ラッパーの生成時に無視されます。</entry>
    <entry key="IllegalValue">''{0}'' に対する不正な値</entry>
    <entry key="ImpIterBlkSrcIsNotInportBlk">Implicit Iterator ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に対するソースが無効です。Implicit Iterator ブロックの入力端子は直接 Inport ブロックに接続しなければなりません。</entry>
    <entry key="PerturbJacNotSupportedInForEachSS">このサブシステムではヤコビアンをサポートしていません。これは、サブシステム内の 1 つのブロックは、離散状態が生じても解析ヤコビアンを提供しないためです。</entry>
    <entry key="JacWarningForStateInForEachSSOfOriginalModel">ヤコビアンは、元のモデル内の For Each サブシステムの外にあるブロックの離散状態を反映するだけです。</entry>
    <entry key="IncorrectNumRTPWritten">S-Function ''{0}'' の mdlRTW でエラーが発生しました。この関数は {1,number,integer} 個の実行時パラメーターを書き込み、{2,number,integer} 個の実行時パラメーターを登録しました</entry>
    <entry key="InitStatesInForEachSSNotSupported">モデル ''{0}'' は、For Each ブロックが含まれる 1 つか複数のサブシステム内に状態のブロックを持っています。そのような状態の初期化はサポートされていません。</entry>
    <entry key="InitStatesInArrayFormatShouldBeAvoided">モデル ''{0}'' の初期状態は配列として指定されています。配列形式で指定されている初期状態値が変更されると、ラピッド アクセラレータ ターゲットがリビルドされます。リビルドせずに初期状態を調整できる構造体形式を使用することを検討してください。\nこの警告は、設定 &lt;sldiag objui="configset" objparam="InitInArrayFormatMsg"&gt;[初期状態が配列]&lt;/sldiag&gt; を使用して無効にできます。</entry>
    <entry key="InitStatesInRefMdlNotSupported">モデル ''{0}'' は状態をもつモデル ブロックです。初期状態が配列の形式で指定された場合、参照モデル内のこれらの状態の初期化はサポートされません。</entry>
    <entry key="InjectionDataMethodCalledNotProperly">エンジン インターフェイス メソッド "getInjectionDataForSignalBasedLinearization" を適切に実行するために、モデル パラメーター "CompileForInfoOnSignalBasedLinearization" を "on" に設定する必要があります。コマンド "set_param(mdl,''CompileForInfoOnSignalBasedLinearization'',''on'');" は、メソッドを呼び出す前に実行してください。</entry>
    <entry key="InputDimsMismatch">''{2}'' の入力端子 {0,number,integer} と&lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;入力端子 {1,number,integer}&lt;/sldiag&gt; の現在の次元が時間 {3} において異なります。すべての入力端子は、モデルの実行中、同じ次元でなければなりません。</entry>
    <entry key="InputDimsModeInconsistent">''{2}'' の入力端子 {0,number,integer} と&lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;入力端子 {1,number,integer}&lt;/sldiag&gt; の次元モードが異なります。すべての入力端子は、同じ次元モードでなければなりません。</entry>
    <entry key="InputNotConnected">ブロック ''{1_SLObject}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1_SLObject}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; が接続されていません。</entry>
    <entry key="InputPortFrameDataMismatch">入力端子のフレーム データが一致しません。''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; は {2} のデータが必要です。しかし、{3} のデータで駆動されています</entry>
    <entry key="InputPortMultiDDimsDisallowed">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; の次元を {2} に設定できません。このブロックは、2 次元より大きい次元の信号を取り扱うよう設定されていません。</entry>
    <entry key="InputPortTrailingUnityDimsDisallowed">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; の次元を {2} に初期化できません。行列の次元数が 2 を超える場合、後続の次元のサイズは 1 より大きくなければなりません。</entry>
    <entry key="InsertBlkAtInportIntroduceNewTsInTrigSys">Triggered Subsystem または Function-Call Subsystem では、レートが無効になるため、それらのサブシステムに Rate Transition ブロックを自動で挿入することはできません。このエラーを修正するには、ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に手動で Rate Transition ブロックを挿入してください。</entry>
    <entry key="InsertBlkAtOutportIntroduceNewTsInTrigSys">Triggered Subsystem または Function-Call Subsystem では、レートが無効になるため、それらのサブシステムに Rate Transition ブロックを自動で挿入することはできません。このエラーを修正するには、ブロック ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に手動で Rate Transition ブロックを挿入してください。</entry>
    <entry key="InsertBlkAtVirtualBlkInput">Simulink は未指定のレート変換を検出しました。しかし、Simulink はバーチャル ブロックの上流に Rate Transition ブロックを自動的に挿入することができません。ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に手動で Rate Transition ブロックを挿入してください。</entry>
    <entry key="InsertBlkAtVirtualBlkOutput">Simulink は未指定のレート変換を検出しました。しかし、Simulink はバーチャル ブロックの下流に Rate Transition ブロックを自動的に挿入することができません。ブロック ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に手動で Rate Transition ブロックを挿入してください。</entry>
    <entry key="InsertRTBTypeMismatch2Blks">次のいずれかの理由により、ブロック ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; とブロック ''{3}'' の&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; の間の確定的なデータ転送を確認するための Rate Transition ブロックを挿入できません: \n - ブロックの 1 つが非同期のレートで実行されている。\n - ブロックの 1 つのサンプル時間ではオフセットが非ゼロである。\n - 2 つのブロックのサンプル時間が整数倍の組み合わせではない。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{1}'',''InsertRTBMode'')&lt;/cmd&gt; &lt;txt&gt;[確定的なデータ転送] を [可能な限り] または [行わない (最小遅延)] に設定する&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="InvActionDuringCallback">コールバック中には、モデル ''{0}'' を変更できません</entry>
    <entry key="InvAlgLoopInConstRateTask">ループ内のすべてのブロックに定数のサンプル時間があるため、モデル ''{0}'' の代数ループを解くことができません。</entry>
    <entry key="InvAlgLoopWithConstTsBlocks">Unable to solve algebraic loop in model ''{0}'' because one or more blocks in the loop with a constant sample time are connected to constant sample time ports of blocks such as ''{1}'' that is outside this loop.</entry>
    <entry key="InvAlgLoopWithMultiTaskBlocks">Unable to solve algebraic loop in multi-tasking model ''{0}'' because one or more blocks in the loop has multiple rates.
    &lt;actions exclusiveFixIts="yes"&gt;
    &lt;action type="fixit"&gt;
    &lt;cmd&gt;set_param_action(''{0}'', ''EnableMultiTasking'', ''off'');&lt;/cmd&gt;
    &lt;txt&gt;Consider unselecting configuration option &lt;sldiag objui="configset" objparam="EnableMultiTasking"&gt;''Treat each discrete rate as a separate task''&lt;/sldiag&gt; to change the model to single tasking mode.&lt;/txt&gt;
    &lt;/action&gt;
    &lt;/actions&gt;
    </entry>
    <entry key="InvAlgLoopWithAsyncTsBlocks">ループ内の 1 つ以上のブロックに非同期のサンプル時間を含む複数のレートがあるため、モデル ''{0}'' の代数ループを解くことができません。</entry>
    <entry key="InvAsyncTimeSourceNotBaseRate">Model ブロック ''{1}'' の関数呼び出し入力端子 ''{2}'' を駆動する S-Function ''{0}'' の、時間ソースの選択が無効です。参照モデルに絶対時間を必要とするブロックが含まれているため、S-Function でこのオプションを SS_TIMESOURCE_BASERATE に設定する必要があります。</entry>
    <entry key="InvAsyncCustomFlag">S-function ''{0}'' の SS_OPTION_ASYNCHRONOUS_CUSTOM フラグが、その関数呼び出し先 ''{1}'' でサポートされていません。</entry>
    <entry key="ModelRefInitAsyncPriorityNotSpecified">The block ''{0}'' must specify asynchronous task priority of {3,number,integer} to match the priority specified at input port ''{2}'' of function-call Model block ''{1}''.</entry>
    <entry key="ModelRefInitAsyncPriorityMismatch">The asynchronous task priority {1,number,integer} specified by block ''{0}'' does not match the priority {4,number,integer} specified at input port ''{3}'' of function-call Model block ''{2}''.</entry>
    <entry key="ModelRefInvalidInitAsyncPriority">同時実行タスクが有効になっている場合、S-function ''{0}'' による非同期タスクの優先順位 {1,number,integer} の指定は無効です。</entry>
    <entry key="ModelRefFcnPortHasMultipleInitiators">Model ブロック ''{0}'' は、入力端子 ''{1}'' において、非同期の関数呼び出しによって駆動されます。非同期の関数呼び出しに、複数の非同期の関数呼び出しが直接または間接的に含まれる場合、Model ブロックの入力端子を駆動することができません。</entry>
    <entry key="InvBlkInputPortTs">''{2}'' の入力端子番号 {3,number,integer} のサンプル時間 [{0} {1}] は無効です。サンプル時間は、実数の double スカラー (period) または長さが 2 の実数の double ベクトル (period, offset) でなければなりません。ここで、period、offset は有限で非負、offset は period より小さくなくてはなりません。 </entry>
    <entry key="InvBlkOutputPortTs">''{2}'' の出力端子番号 {3,number,integer} のサンプル時間 [{0} {1}] は無効です。サンプル時間は、実数の double スカラー (period) または長さが 2 の実数の double ベクトル (period, offset) でなければなりません。ここで、period、offset は有限で非負、offset は period より小さくなくてはなりません。</entry>
    <entry key="InvBlkTs">''{3}'' のサンプル時間 {2,number,integer} として指定された周期 ({0}) およびオフセット ({1}) は無効です。サンプル時間は、実数の double スカラー (period) または長さが 2 の実数の double ベクトル (period, offset) でなければなりません。ここで、period、offset は有限で非負、offset は period より小さくなくてはなりません。 </entry>
    <entry key="InvBlkUsingElapsedTimeInFcnCallSubsys">関数呼び出しサブシステム ''{0}'' は、このブロックが 2 つの連続する実行間で経過した時間を管理するサービスを必要とするため、ブロック ''{1}'' を含むことはできません。関数呼び出しサブシステムは t = {2} において複数回実行されるため、2 つの実行間の経過時間を適切に定義することができません。</entry>
    <entry key="InvBlkUsingElapsedTimeInIteratorSubsys">Iterator サブシステム ''{0}'' は、このブロックが 2 つの連続する実行間で経過した時間を管理するサービスを必要とするため、ブロック ''{1}'' を含むことはできません。Iterator サブシステムは、与えられたタイム ステップで複数回実行されるため、2 つの実行間の経過時間を適切に定義することができません。</entry>
    <entry key="InvBlockAdded">Inport、Outport、Connection Port、Subsystem および Model ブロックのみを Variant Subsystem ブロック ''{0}'' に追加できます。</entry>
    <entry key="InvBlockDelete">シミュレーション実行中は ''{0}'' を削除できません</entry>
    <entry key="InvBlockNameInInitStateStruct">モデル ''{0}'' に対して、指定した初期化状態を読み込めません。初期状態の構造体の {1}({2,number,integer}).{3} フィールドは、モデルのブロックへのパスを指定する文字ベクトルでなければなりません</entry>
    <entry key="InvCStateChange">シミュレーション実行中は ''{0}'' の連続状態数を変更できません</entry>
    <entry key="InvCallForFeature">''slfeature'' オプションをもつ ''slInternal'' の呼び出しが無効です。このオプションには有効なサブオプションが必要です</entry>
    <entry key="InvCallForFeatureName">無効な slfeature の名前 ''{0}'' が指定されました</entry>
    <entry key="IncompatibleTypeForInplace">入力タイプと出力タイプはインプレース置き換えに対応していません。</entry>
    <entry key="InplaceVardimNotSupported">''{0}'' uses variable-size in-place input and output signals which are not supported.</entry>
    <entry key="InvCommandDuringPreLoadFcnCallback">PreLoadFcn コールバックの処理中にモデル ''{1}'' のコマンド ''{0}'' を実行できません</entry>
    <entry key="InvDFeedChange">シミュレーション実行中は ''{0}'' の直達を変更できません。</entry>
    <entry key="InvDStateChange">シミュレーション実行中は ''{0}'' の離散状態数を変更できません</entry>
    <entry key="InvDisallowConstTsChange">シミュレーション実行中は ''{0}'' の disallow_constant_ts フラグを変更できません。</entry>
    <entry key="InvCompDiscSampleTime"> 無効なサンプル時間が ''{0}'' に伝播されました。入力信号のソースに固定の離散サンプル時間を指定することにより、このエラーを回避できます。詳細は、「&lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''],''specifying_sample_time'')"&gt;サンプル時間の指定&lt;/a&gt;」を参照してください。</entry>
    <entry key="InvUserDiscSampleTime">ブロック ''{0}'' はサンプル時間 {1} を許可しません。離散サンプル時間または継承されるサンプル時間を ''{2}'' に入力してください。</entry>
    <entry key="InvElementInInitStateStruct">モデル ''{0}'' に対して、指定した初期状態を読み込めません。初期状態のインデックス {1,number,integer} における要素の BlockName/BlockPath が無効です</entry>
    <entry key="InvExtModeMexFile">エクスターナル モード MEX ファイル ''{0}'' は、存在しないか、または MATLAB パス上にありません。入力された MEX ファイル名は、ファイル拡張子をもつ必要がないことに注意してください</entry>
    <entry key="InvExtModeMexFileArgs">エクスターナル モードの MEX ファイルの引数 ''{0}'' の解釈中にエラーが発生しました。</entry>
    <entry key="InvExtModeParamVectName">''ExtModeParamVectName'' プロパティに対して無効な MATLAB 変数名が指定されました</entry>
    <entry key="InvFMexTsLen">''{1}'' の FORTRAN MEX S-function ''{0}'' によって出力されたサンプル時間 (TS) 行列は、次元が {2,number,integer}x2 の行列でなければなりません。</entry>
    <entry key="InvFMexTsMatrix">''{1}'' の FORTRAN MEX S-function ''{0}'' によって出力されたサンプル時間 (TS) 行列が無効です。</entry>
    <entry key="InvFcnCallSSDataInput">関数呼び出しブロックのデータ依存性エラー。\n関数呼び出しブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; は ''{2}'' によって駆動されています。このドライバーは、関数呼び出しブロックの実行時にドライバーの出力を有効にするため、関数呼び出しイニシエーター ''{3}'' の前に実行しなければなりません。しかし、Simulink は関数呼び出しイニシエーターの前にドライバーを実行することはできません。これは、関数呼び出しイニシエーターの出力とドライバーとの間にデータの依存性があるためです。イニシエーターとそれが実行するブロックの間の関数呼び出しの数は、{4,number,integer} 回であることに注意してください。関数呼び出しブロックの有効な例と無効な例については、Simulink ライブラリの Subsystem Examples を参照してください。</entry>
    <entry key="InvFcnCallSSDataInputNoObj">関数呼び出しブロックのデータ依存性エラー。\n関数呼び出しブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; は ''{2}'' によって駆動されています。このドライバーは、関数呼び出しブロックの実行時にドライバーの出力を有効にするため、関数呼び出しイニシエーター ''{3}'' の前に実行しなければなりません。しかし、Simulink は関数呼び出しイニシエーターの前にドライバーを実行することはできません。これは、関数呼び出しイニシエーターの出力とドライバーとの間にデータの依存性があるためです。イニシエーターとそれが実行するブロックの間の関数呼び出しの数は、{4,number,integer} 回であることに注意してください。関数呼び出しブロックの有効な例と無効な例については、Simulink ライブラリの Subsystem Examples を参照してください。</entry>
    <entry key="InvFieldInInitStateStruct">モデル ''{0}'' に対して、指定した初期化状態を読み込めません。初期状態は {1} の構造体配列を含む構造体でなければなりません。{2} の構造体は次のフィールドをもつ必要があります: ''{3}''、''{4}'' および ''{5}''</entry>
    <entry key="InvInputPortChange">シミュレーション実行中は ''{0}'' の入力端子のプロパティを変更できません</entry>
    <entry key="InvLabelInInitStateStruct">モデル ''{0}'' に対して、指定した初期状態を読み込めません。初期状態のインデックス ({2,number,integer}) における要素の {1} フィールドは、有効な状態ラベルを指定する文字ベクトルでなければなりません</entry>
    <entry key="InvLineAdded">バリアント サブシステム ブロック ''{0}'' に行を追加することはできません。</entry>
    <entry key="InvLinearAnalysisAttrChange">シミュレーションの実行中に、''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の線形解析の属性を変更できません</entry>
    <entry key="InvMFileTsLen">''{1}'' の MATLAB S-function ''{0}'' によって出力されたサンプル時間 (TS) 行列は、次元が {2,number,integer}x2 の行列でなければなりません。</entry>
    <entry key="InvMFileTsMatrix">''{1}'' のMATLAB S-function ''{0}'' によって出力されたサンプル時間 (TS) 行列が無効です。</entry>
    <entry key="InvMatlFeatureCalledViaSlFeature">slfeature は、機能 ''{0}'' へのゲートウェイとして使用できません。この機能は、Simulink から登録されないか、このゲートウェイで呼び出せない特別なコールバックをもつかのいずれかです。</entry>
    <entry key="InvMdlRefFieldInInitStateStruct">モデル ''{0}'' に対して、指定した初期化状態を読み込めません。初期状態の構造体の {1}({2,number,integer}).{3} フィールドは、logical スカラー値でなければなりません</entry>
    <entry key="InvMemLayoutConnStatePort">''{2}'' の状態端子から ''{0}'' の入力端子 {1,number,integer} への接続が無効です。データの出力端子からの信号のみこのブロックに接続できます。</entry>
    <entry key="InvMemLayoutConnectType">''{0}'' の出力端子 {1,number,integer} に無効なメモリ レイアウトの接続設定が見つかりました。このエラー メッセージについて MathWorks にお問い合わせください</entry>
    <entry key="InvMemLayoutLoop">ブロック {0} を含むループが無効です</entry>
    <entry key="InvMemLayoutPartialPortSrc">メモリ レイアウトのブロック ''{0}'' の&lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;入力端子 {1,number,integer}&lt;/sldiag&gt; とそのソース間で無効な部分的端子接続が見つかりました。このエラー メッセージの詳細については MathWorks にお問い合わせください</entry>
    <entry key="InvModeVectChange">シミュレーション中に ''{0}'' のモード ベクトルの要素数を変更することはサポートされていません。</entry>
    <entry key="InvModelBusy">コールバックまたはパラメーター評価の処理中にモデル ''{0}'' を閉じることはできません。</entry>
    <entry key="InvModelChange">シミュレーションの実行中にモデル ''{0}'' を変更することはできません</entry>
    <entry key="InvModelChangeInFastRestart">高速リスタート モードで初期化中のモデル ''{0}'' は変更できません。高速リスタートを無効にするには、&lt;a href=\"matlab:set_param(bdroot,'FastRestart','off')\"&gt;ここ&lt;/a&gt;をクリックしてください</entry>
    <entry key="InvModelSimDuringClose">モデルを閉じている間は、モデル ''{0}'' のシミュレーションはできません。</entry>
    <entry key="InvSimCommandArgumentsForFastRestart">高速リスタートが有効の場合、sim コマンドで次のパラメーターはサポートされません: ''{0}''</entry>
    <entry key="InvModelClose">コンパイル中またはシミュレーションの実行中にモデル ''{0}'' を閉じることはできません。</entry>
    <entry key="InvModelCloseWhenInitializedInFastRestart">高速リスタートで初期化されている場合、モデル ''{0}'' を閉じることはできません</entry>
    <entry key="InvModelCloseDuringSave">保存中にモデル ''{0}'' を閉じることはできません。</entry>
    <entry key="InvModelInitingModelWS">モデル ワークスペースの初期化中にモデル ''{0}'' を閉じることはできません。</entry>
    <entry key="InvModelCompileWhenInitingModelWS">モデル ワークスペースの初期化中にモデル ''{0}'' をコンパイルできません。</entry>
    <entry key="InvModelUdim">{0} 無効な入力ベクトルの長さ ({1,number,integer}) が、長さ {3,number,integer} を必要とする ''{2}'' に与えられました。</entry>
    <entry key="InvNameChangeDuringLoad">読み込み中は、ブロック線図 ''{0}'' の名前を ''{1}'' に変更することができません。ブロック線図が完全に読み込まれた後にのみ、名前を変更できます。</entry>
    <entry key="InvNumPortsChange">シミュレーション実行中は ''{0}'' の端子数を変更できません</entry>
    <entry key="InvOptionForFeature">''slfeature'' オプションをもつ ''slInternal'' への呼び出しで与えられたサブオプション ''{0}'' が無効です。</entry>
    <entry key="InvOptionForFeatureGetSet">slfeature の get/set への呼び出しが無効です。</entry>
    <entry key="InvOptionForFeatureStats">''slfeature'' オプションをもつ ''slInternal'' への呼び出しのサブオプション ''stats'' に対して与えられた追加の入力引数が無効です。追加引数は必要ありません。</entry>
    <entry key="InvOutHasDiscontChange">シミュレーション実行中は ''{0}'' の output_has_discontinuities フラグを変更できません。</entry>
    <entry key="InvParamComplexityChange">シミュレーション実行中は ''{1}'' 内のパラメーター {0,number,integer} の複雑度 (実数または複素数) を変更できません</entry>
    <entry key="InvParamDTypeChange">シミュレーション実行中は ''{1}'' のパラメーター {0,number,integer} のデータ型を変更できません</entry>
    <entry key="InvParamWidthChange">シミュレーション実行中は ''{1}'' 内のパラメーター {0,number,integer} の幅を変更できません。</entry>
    <entry key="InvPortCharChange">シミュレーション実行中は ''{0}'' の端子の特性を変更できません</entry>
    <entry key="InvPortDimsChange">シミュレーション実行中は ''{0}'' の端子の次元を変更できません</entry>
    <entry key="InvPriOnBEP">In Bus Element ブロック、または非バーチャル サブシステム内の Out Bus Element ブロックでは、優先順位を指定できません。ブロック ''{1}'' で指定した優先順位 {0,number,integer} を無視します。</entry>
    <entry key="InvPriOnFcnCallSS">関数呼び出しブロック ''{1}'' に指定した優先順位 {0,number,integer} を無視します。それらの実行はそれらの関数呼び出しイニシエーターによって制御されるため、優先順位は関数呼び出しブロックで指定することはできません。</entry>
    <entry key="InvPriOnActionSS">Action Subsystem ''{1}'' に指定した優先順位 {0,number,integer} を無視します。それらの実行は If ブロックまたは Switch Case ブロックによって制御されるため、優先順位は Action Subsystem で指定することはできません。</entry>
    <entry key="InvPriOnIteratorBlock">For Iterator または While Iterator ブロック ''{1}'' に指定した優先順位 {0,number,integer} を無視します。Iterator ブロックは、For Iterator または While Iterator Subsystem 内で最初に実行するブロックでなければならないため、優先順位を指定することはできません。</entry>
    <entry key="InvPriOnMergeBlock">Merge ブロック ''{1}'' に指定した優先順位 {0,number,integer} を無視します。それらの実行はそれらの入力端子ソースによって制御されるため、優先順位は Merge ブロックで指定することはできません。</entry>
    <entry key="InvPriOnInjInportOutportBlk">Injector Inport/Outport ブロック ''{1}'' で指定した優先順位 {0,number,integer} を無視します。Injector Inport/Outport ブロックでは優先順位を指定できません。</entry>
    <entry key="InvPriOnMultiTaskBlock">マルチタスクで実行するブロック ''{1}'' に指定した優先順位 {0,number,integer} を無視します。</entry>
    <entry key="InvPriOnIRTFunction">Initialize Function、Reinitialize Function、Reset Function または Terminate Function ブロック ''{1}'' に指定した優先順位 {0,number,integer} を無視します。Initialize Function、Reinitialize Function、Reset Function または Terminate Function ブロックの実行はそのスケジューラによって制御されます。</entry>
    <entry key="InvPriOnSimulinkFunction">Simulink 関数 ''{1}'' で指定された優先順位 {0,number,integer} を無視します。Simulink 関数の実行は対応する Function Caller ブロックによって制御されるため、優先順位は指定できません。</entry>
    <entry key="InvPriOnVirtBlock">{1} ''{2}'' に指定した優先順位 {0,number,integer} を無視します。優先順位はバーチャルなブロックでは指定できません。</entry>
    <entry key="InvCheckActDstOKToReadInputInStart">指定した出力端子のオーナー ブロック ''{0}'' がバーチャル ブロックまたは置換されたブロックであるため、情報は利用できません。非バーチャル ブロックまたは置換されていないブロックに対応する出力端子を指定してください。</entry>
    <entry key="InvRTWGenSettingsYESNOType">RTWGenSetting フィールドの値 ''{0}'' は、''yes'' または ''no'' のみが有効です</entry>
    <entry key="InvRTWIdLen">識別子として無効な長さが指定されました ([コンフィギュレーション パラメーター] ダイアログの [コード生成] の "識別子" を参照してください)。識別子は {0,number,integer} 以上の長さでなければなりません。</entry>
    <entry key="InvRapidAccelRTPOpt">ラピッド アクセラレータ パラメーターの設定が無効です。''RapidAcceleratorUpToDateCheck'' を ''off'' に設定する必要があることに注意してください</entry>
    <entry key="InvRapidAccelUpdateCheckOpt">ラピッド アクセラレータの更新状態をチェック オプションが無効です</entry>
    <entry key="InvRetForFeature">''slfeature'' オプションをもつ ''slInternal'' への呼び出しに対する戻り値の数が無効です</entry>
    <entry key="InvReturnWkspOutputOpt">オプション ReturnWorkspaceOutputs の無効な値です</entry>
    <entry key="InvSFcnCall_CommonInit">ブロック ''{0}'' の設定が無効です。入力端子 ''{1,number,integer}'' と ''{2,number,integer}'' にエクスポートされる関数呼び出しは、共通の関数呼び出し開始プログラムで駆動されていません。</entry>
    <entry key="InvSFcnCall_InlinedInAccel">Unable to simulate S-Function block ''{0}'' in accelerator mode because its function-call input port {1,number,integer} is driven by block ''{2}'' that is not a noninlined S-function. An S-function is identified as noninlined if it does not use TLC in accelerator mode.</entry>
    <entry key="InvSFcnCall_RTWNotSupported">ブロックは関数呼び出しをエクスポートするよう設定されているため、S-Function ブロック ''{0}'' はコード生成をサポートしません。</entry>
    <entry key="InvSFcnStructParamDType">''{1}'' のパラメーター {0,number,integer} に対する値は、そのデータ型が S-function が生成されたときに使用された構造体のデータ型と一致しないため無効です</entry>
    <entry key="InvSaveMdlBeforeSaveAs">モデルの変更が保存されていないため、以前のバージョンにエクスポートできません。作業を進める前にモデルを保存してください。</entry>
    <entry key="MDXNotSupportExportToPrevious">システム ターゲット ファイル "mdx.tlc" を使用するモデルは R2020a より前のリリースにエクスポートできません。</entry>
    <entry key="ExportSubsystemUnsupportedRelease">サブシステム モデルは R2019b より前のリリースにエクスポートできません。</entry>
    <entry key="InvScopeArrayFormat1">''{0}'' は、''形式'' パラメーターが ''配列'' ではなく、''構造体''、または ''時間付き構造体'' に設定されている場合、いくつかの入力端子を持ち、複数の端子データのみログを取ることができます。このパラメーターは、[Scope パラメーター] ダイアログの [データ ヒストリ] タブにあります。このダイアログは、[Scope] メニューから選択可能です。</entry>
    <entry key="InvScopeArrayFormat2">''{0}'' への入力は、行列信号です。行列信号は、''形式'' パラメーターが ''配列'' ではなく、''構造体''、または ''時間付き構造体'' に設定されている場合のみログを取ることができます。このパラメーターは、[Scope パラメーター] ダイアログの [データ ヒストリ] タブにあります。このダイアログは、[Scope] メニューから選択可能です。</entry>
    <entry key="InvSignalDims">''{0}'' で指定された次元が無効です。次元は継承 (-1 に設定) されるか、正の整数値を含むベクトルとして指定されなければなりません。</entry>
    <entry key="InvSignalDimsDataType">''{0}'' で指定された次元に無効なデータ型が含まれています。次元は &lt;a href="matlab:helpview([docroot ''/simulink/ug/simulink_ug.map''], ''dataTypes'')"&gt;Simulink 組み込みデータ型&lt;/a&gt;で指定しなければなりません。</entry>
    <entry key="InvSignalDimsWidth">端子幅または次元のエラー。''{1}'' で指定した次元 ''{0}'' は 1 ～ {2,number,integer} までのサイズを指定しなければなりません。</entry>
    <entry key="InvSimCommandDuringPreLoadFcnCallback">PreLoadFcn コールバックの処理中にモデル ''{0}'' の sim コマンドを実行できません</entry>
    <entry key="InvStatePortUsage">状態端子は、代数ループを切り離したり、システム間の状態を「受け渡し (hand-off)」たりするためにのみに使用できます。''{1}'' に (直接または仮想接続で) 送る信号のソース として、状態端子 ''{0}'' ではなく出力端子を使ってください</entry>
    <entry key="InvSubsystemResetInputSampleTime">リセット信号を入力しているサブシステム ''{0}'' のサンプル時間は、サブシステムのサンプル時間と異なります。サブシステムのリセット入力端子で Rate Transition ブロックを挿入することを検討してください。</entry>
    <entry key="InvSupAliasTypeChange">シミュレーション実行中は ''{0}'' の supports_alias_data_types フラグを変更できません。</entry>
    <entry key="InvTnext">''{2}'' の S-function ''{1}'' で出力された次のサンプルにヒットする時間 {0} は、''{3}'' の前のサンプル ヒット時間よりも大きくなければなりません。</entry>
    <entry key="InvTnextForM">flag={3,number,integer} の呼び出し中に、{2} の S-function ''{1}'' によって出力された次のサンプルにヒットする時間 {0} は、前のサンプル ヒット時間 {4} よりも大きくなければなりません。</entry>
    <entry key="InvTrigSignal">トリガー信号を定義する ''{0}'' は、データ ログに対して設定されていなければなりません。</entry>
    <entry key="InvTsChange">シミュレーションの実行中は、''{0}'' のサンプル時間を変更できません。</entry>
    <entry key="InvValForFeatureSet">整数のスカラー値は、slfeature ''{0}'' を設定している間に指定されなければなりません。</entry>
    <entry key="InvValuesComplexityInInitStateStruct">Type mismatch in the initial state for model ''{0}''. The {1}({2,number,integer}).{3} field in the initial state structure is complex valued, whereas the corresponding state ''{4}'' in block ''{5}'' is not complex valued</entry>
    <entry key="InvValuesDataTypeInInitStateStruct">Data type mismatch in the initial state for model ''{0}''. The {1}({2,number,integer}).{3} field in the initial state structure is of type {4}, whereas the corresponding state ''{5}'' in block ''{6}'' is of type {7}.</entry>
    <entry key="InvValuesInInitStateStruct">モデル ''{0}'' に対して、指定した初期化状態を読み込めません。初期状態の構造体の {1}({2,number,integer}).{3} フィールドは、有限の数値配列でなければなりません。</entry>
    <entry key="InvValuesInInitStateStructFixedPt">初期状態の構造体のフィールド {0}({1,number,integer}).{2} に固定小数点データを読み込めません。Dataset 形式を使用して固定小数点の初期状態データを読み込んでください。</entry>
    <entry key="InvValuesInInitStateRaccelFixedPt">Unable to load fixed-point data for 'values' field at index ({0,number,integer}) in the initial state. Fix point data type is not supported for loading initial states.</entry>
    <entry key="InvValuesInInitStateRaccelHalf">Unable to load half-precision data for 'values' field at index ({0,number,integer}) in the initial state. Half data type is not supported for loading initial states.</entry>
    <entry key="InvValuesInInitState">Unable to load data for 'values' field at index ({0,number,integer}) in the initial state. 'values' field in the initial state must be a finite numeric or logical array.</entry>
    <entry key="InvValuesSizeInInitStateStruct">モデル ''{0}'' に対する初期状態のサイズが一致しません。初期状態の構造体の {1}({2,number,integer}).{3} フィールドには {4,number,integer} 要素がありますが、ブロック ''{6}'' の対応する状態 ''{5}'' には {7,number,integer} 要素があります</entry>
    <entry key="InvVarTsLoc">''{0}'' は、可変ステップ サイズのサンプル時間を含むため、条件付き実行サブシステムでは利用できません。</entry>
    <entry key="InvVectorModeChange">シミュレーション実行中は ''{0}'' のベクトル/行列演算モードを変更できません</entry>
    <entry key="InvalidBlockConnection">予期せぬ、または無効なブロックの接続があります。これは、ライブラリ ブロックがオリジナルの実装と互換性のない新規領域を使用するために根底となる実装を変更する場合に起こります。一致する領域を使用するために、ブロックの接続をチェックして作り直してください。</entry>
    <entry key="UnknownCharacterEncoding">モデル ''{1}'' に指定された文字エンコード ''{0}'' が不明です。</entry>
    <entry key="InvalidCondInput">S-Function ''{0}'' で、&lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;入力端子 {1,number,integer}&lt;/sldiag&gt; が出力関数において条件付きで必要であることが示されました。しかし、入力端子の直達のフラグ は false です。つまり、出力関数では入力を必要としません。これは無効です。</entry>
    <entry key="InvalidDimFromETVSSubsysIC">無効な次元が検出されました: ''{0}'' の初期出力は、{1,number,integer} の出力次元が {2,number,integer} を指定しており、最大次元 {3,number,integer} を超えています。</entry>
    <entry key="InvalidDtypeIDFromDataDictionary">データ ディクショナリによって、タイプ ''{0}'' に無効なタイプ ID が生成されました。</entry>
    <entry key="InvalidElementName">''{0}'' の名前をもつ要素が存在します</entry>
    <entry key="InvalidElementType">無効な要素のタイプ</entry>
    <entry key="InvalidICForBusWithVarDimsElements">''{0}'' ブロックの初期出力は可変サイズの要素をもつバスをサポートしません。</entry>
    <entry key="InvalidInitialDimensions_sds">端子の初期の次元が無効です。''{2}'' の {0} 端子 {1,number,integer} の次元が設定されていません。</entry>
    <entry key="InvalidInputTypeForProdWithVardims">''{0}'' の入力は、非零のバイアスや傾きをもつ固定小数点のデータ型の可変サイズの信号です。Product ブロックはこの入力をサポートしません。固定小数点のデータ型を使用する場合、バイアスを 0 に変更したり単位傾きを使用したりすることを検討してください。</entry>
    <entry key="InvalidInputTypeForSumWithVardims">''{0}'' の入力は、非零のバイアスをもつ固定小数点のデータ型の可変サイズの信号です。Sum ブロックはこの入力をサポートしません。固定小数点のデータ型を使用する場合、バイアスを 0 に変更することを検討してください。</entry>
    <entry key="InvalidInputVariableSizeSignal">ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に接続された信号は可変サイズの信号ですが、コード生成に対し現在は無効になっています。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{1}'',''SupportVariableSizeSignals'',''on'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="SupportVariableSizeSignals"&gt;[可変サイズの信号のサポート]&lt;/sldiag&gt; を選択する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="InvalidInputVariableSizeSignalInRowMajor">ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に接続された信号は可変サイズの信号ですが、行優先の配列レイアウトでのコード生成では現在サポートされていません。</entry>
    <entry key="NDDynamicArrayInputSignalInRowMajor">ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に接続された信号は多次元の動的配列信号ですが、行優先の配列レイアウトでのコード生成では現在サポートされていません。</entry>
    <entry key="InvalidMemSecForSystem">ブロック ''{2}'' の [Subsystem Parameters] ダイアログで指定された ''{1}'' のメモリ セクション ''{0}'' が無効です。メモリ セクション パッケージ ''{3}'' が Embedded Coder ディクショナリに読み込まれました。''{3}'' パッケージからメモリ セクションを選択してください</entry>
    <entry key="InvalidMemSecForSystemDefaults">ブロック線図 ''{2}'' の [コンフィギュレーション パラメーター] ダイアログで指定された ''{1}'' のメモリ セクション ''{0}'' が無効です。メモリ セクション パッケージは ''{3}'' です</entry>
    <entry key="InvalidModelArgument">''{0}'' は、有効な引数ではありません。</entry>
    <entry key="InvalidModelFlag">Simulink モデル ''{0}'' は、無効なフラグで呼び出されました。</entry>
    <entry key="InvalidModelFlagOption">''{0}'' は無効なフラグ オプションです</entry>
    <entry key="InvalidModelOption">''{0}'' は無効なオプションです。</entry>
    <entry key="InvalidNumDataStores">''{0}'' の DataStores 数を負にできません</entry>
    <entry key="InvalidNumDworks">''{0}'' の Dwork 数を負にできません</entry>
    <entry key="InvalidNumInputPorts">''{0}'' の入力端子の数を負にはできません。</entry>
    <entry key="InvalidNumModelArg">Simulink モデル ''{0}'' は、無効な引数の数で呼び出されました。</entry>
    <entry key="InvalidNumOutputPorts">''{0}'' の出力端子数を負にはできません。</entry>
    <entry key="InvalidOutputVariableSizeSignal">ブロック ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に接続された信号は可変サイズの信号ですが、コード生成に対し現在は無効になっています。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{1}'',''SupportVariableSizeSignals'',''on'')&lt;/cmd&gt; &lt;txt&gt;Select &lt;sldiag objui="configset" objparam="SupportVariableSizeSignals"&gt;[可変サイズの信号のサポート]&lt;/sldiag&gt; を選択する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="InvalidOutputVariableSizeSignalInRowMajor">ブロック ''{1}'' &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;の出力端子 {0,number,integer}&lt;/sldiag&gt; に接続された信号は可変サイズの信号ですが、行優先の配列レイアウトでのコード生成では現在サポートされていません。</entry>
    <entry key="NDDynamicArrayOutputSignalInRowMajor">ブロック ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に接続された信号は多次元の動的配列信号ですが、行優先の配列レイアウトでのコード生成では現在サポートされていません。</entry>
    <entry key="InvalidPassThroughInputIdx">S-Function ブロック ''{1}'' に対して ''ssSetInputDimsSameAsOutputDims'' に指定された入力端子のインデックス {0,number,integer} が存在しません。</entry>
    <entry key="InvalidPassThroughOutputIdx">S-Function ブロック ''{1}'' に対して ''ssSetInputDimsSameAsOutputDims'' に指定された出力端子のインデックス {0,number,integer} が存在しません。</entry>
    <entry key="InvalidReturnErrorsOption">''{0}'' は CaptureErrors の無効なオプションです。</entry>
    <entry key="InvalidSkipParameterUpdateOption">''{0}'' は SkipParameterUpdate の無効なオプションです。</entry>
    <entry key="InvalidFastRestartOption">''{0}'' は FastRestart の無効なオプションです。</entry>
    <entry key="InvalidLiveTuningOption">''LiveTuning'' に指定されたオプション ''{0}'' が無効です。</entry>
    <entry key="SkipParameterUpdateNeedsFastRestart">SkipParameterUpdate パラメーターは、モデルが高速リスタートで初期化されている場合にのみ設定できます。</entry>
    <entry key="InvalidSCDBlockLinearizationSpecification">ブロック パラメーター ''SCDBlockLinearizationSpecification'' が無効です。パラメーターは、MATLAB の構造体、または空の MATLAB 配列 [] のいずれかでなければなりません。構造体には、フィールド ''Name''、''Specification''、''Type''、''ParameterNames'' および ''ParameterValues'' の文字ベクトルのみを含むフィールドが必要です。</entry>
    <entry key="InvalidSampleTime">''{0}'' に指定されているサンプル時間の形式が無効です。サンプル時間は [sample_time, offset_time] の形式に従ってベクトルを使って指定しなければなりません。</entry>
    <entry key="InvalidSampleTimeForMSFcn">''{0}'' に指定されているサンプル時間の形式が無効です。サンプル時間は [sample_time, offset_time] の形式のベクトルを使用して指定しなければなりません。レベル 2 の MATLAB S-Function で有効なサンプル時間のペアは以下のとおりです: 連続: [0, offset]、離散: [discrete_sample_time_period, offset]、継承: [-1, 0]、可変: [-2, 0]。</entry>
    <entry key="InvalidPortSampleTimeForMSFcn">''{2}'' 端子 {3,number,integer} のサンプル時間 [{0}, {1}] が無効です。サンプル時間は [sample_time, offset_time] の形式のベクトルを使用して指定しなければなりません。レベル 2 の MATLAB S-Function で有効なサンプル時間のペアは以下のとおりです: 連続: [0, offset]、離散: [discrete_sample_time_period, offset]、継承: [-1, 0]、可変: [-2, 0]。</entry>
    <entry key="InvalidScalarICTypeForOutportWithVirtualBus">Outport ブロック ''{0}'' の [初期出力] パラメーターは、パラメーターがスカラーで Outport ブロックが混合データ型のバーチャル バス信号によって駆動されているため、''boolean''、''uint8''、''uint16''、''uint32''、''int8''、''int16''、''int32''、''single''、''double''、または固定小数点のデータ型でなければなりません。</entry>
    <entry key="InvalidScrollbarOffset">スクロールバーのオフセットは長さが2の正の整数ベクトルでなければなりません。</entry>
    <entry key="InvalidSelfLoop" context="error">ブロック ''{0}'' を含む非バーチャル サブシステム ''{1}'' の自己ループが原因で、ブロック ''{0}'' を含む代数ループを解くことができません。</entry>
    <entry key="InvalidSimViewingDevice">''{0}'' は有効な SimViewingDevice ではありません。SimViewingDevices は、 \n \t - シングル レートで、 \n \t - 連続状態がなく、 \n \t - 出力のないものでなければなりません
</entry>
    <entry key="InvalidSolver">"{0}" のソルバーは、連続状態を含むブロック線図 ''{1}'' をシミュレーションできません。</entry>
    <entry key="InvalidContStateInExpFcnMdl">Export-function model ''{0}'' does not support block ''{1}'' because the block has continuous states.</entry>
    <entry key="InvalidZeroCrossingInExpFcnMdl"> ゼロクロッシング検出は、エクスポート関数モデル "{0}" ではサポートされていません。</entry>
    <entry key="InvalidInputSignalComplexity">ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に接続された信号は、複素数値であるか、複素数値のバス要素を含んでいます。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;信号またはバス要素を複素数以外に変更する&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{1}'',''SupportComplex'',''on'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="SupportComplex"&gt;[複素数のサポート]&lt;/sldiag&gt; を選択する (参照先や参照元のモデルに影響する可能性があります&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="InvalidInputSignalDataType">ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に接続された信号は、浮動小数点型であるか、浮動小数点型のバス要素を含んでいます。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;データ型を変更する&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{1}'',''PurelyIntegerCode'',''off'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="PurelyIntegerCode"&gt;[浮動小数点数のサポート]&lt;/sldiag&gt; を選択する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="InvalidOutputSignalComplexity">ブロック ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に接続された信号は、複素数値であるか、複素数値のバス要素を含んでいます。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;信号またはバス要素を複素数以外に変更する&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{1}'',''SupportComplex'',''on'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="SupportComplex"&gt;[複素数のサポート]&lt;/sldiag&gt; を選択する (参照先や参照元のモデルに影響する可能性があります&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="InvalidOutputSignalDataType">ブロック ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に接続された信号は、浮動小数点型であるか、浮動小数点型のバス要素を含んでいます。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;データ型を変更する&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{1}'',''PurelyIntegerCode'',''off'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="PurelyIntegerCode"&gt;[浮動小数点数のサポート]&lt;/sldiag&gt; を選択する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="InvalidWorkComplexity">ブロック ''{0}'' の作業ベクトルには複素数の値があります。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;データ型を変更する&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''SupportComplex'',''on'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="SupportComplex"&gt;[複素数のサポート]&lt;/sldiag&gt; を選択する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="InvalidWorkDataType">ブロック ''{0}'' の作業ベクトルに浮動小数点型が含まれています。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;データ型を変更する&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''PurelyIntegerCode'',''off'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="PurelyIntegerCode"&gt;[浮動小数点数のサポート]&lt;/sldiag&gt; を選択する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="InvalidRTParamComplexity">ブロック ''{1}'' のパラメーター ''{0}'' には複素数の値があります。それを複素数以外に変更するか、[コンフィギュレーション パラメーター]、[コード生成]、[インターフェイス] ペインの [サポート] で [複素数] チェック ボックスを選択することを検討してください</entry>
    <entry key="InvalidRTParamDataType">ブロック ''{1}'' のパラメーター ''{0}'' が浮動小数点型です。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;データ型を変更する&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{1}'',''PurelyIntegerCode'',''off'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="PurelyIntegerCode"&gt;[浮動小数点数のサポート]&lt;/sldiag&gt; を選択する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="InvalidWksParamComplexity">パラメーター ''{0}'' が複素数値です。それを複素数以外に変更するか、[コンフィギュレーション パラメーター]、[コード生成]、[インターフェイス] ペインの [サポート] で [複素数] チェック ボックスを選択することを検討してください</entry>
    <entry key="InvalidWksParamDataType">パラメーター ''{0}'' が浮動小数点型です。データ型を変更するか、[コンフィギュレーション パラメーター] &gt; [コード生成] &gt; [インターフェイス] ペインで [サポート] の [浮動小数点数] チェック ボックスを選択することを検討してください</entry>
    <entry key="InvalidStructuredWksParamComplexity">パラメーター ''{0}'' が複素数値です。それを複素数以外に変更するか、[コンフィギュレーション パラメーター]、[コード生成]、[インターフェイス] ペインの [サポート] で [複素数] チェック ボックスを選択することを検討してください</entry>
    <entry key="InvalidStructuredWksParamDataType">パラメーター ''{0}'' が浮動小数点型です。データ型を変更するか、[コンフィギュレーション パラメーター] &gt; [コード生成] &gt; [インターフェイス] ペインで [サポート] の [浮動小数点数] チェック ボックスを選択することを検討してください</entry>
    <entry key="InvalidTypeForDWorkDimArg">''{0}'' に指定されたデータ型は無効です。この導出パラメーターはデータ型 ''double'' として評価されなければなりません。</entry>
    <entry key="InvalidVarDimsAssignForOutputPort">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に割り当てられた可変次元が無効です。可変次元は、非負の整数の配列でなければならず、それぞれの整数は、最大次元を超えることはできません</entry>
    <entry key="InvalidVirtualBusSignalTypeForOutportWithScalarIC">ブロック ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の信号データ型が無効です。Outport ブロック ''{2}'' を駆動するバーチャル バスのすべての信号は、Outport ブロックの [初期出力] パラメーターがスカラーであるため、''boolean''、''uint8''、''uint16''、''uint32''、''int8''、''int16''、''int32''、''single''、''double''、または固定小数点のデータ型でなければなりません。</entry>
    <entry key="UnableToInitializeOutput">Outport ブロック ''{0}'' の初期出力値を決定できません。</entry>
    <entry key="UnableToInitializeOutputCauseDueToInvalidICSrc">Outport ブロックの 1 つ以上のソース ブロックが有効な初期条件ソースではないため、初期出力を継承できません。詳細については、Simulink ドキュメンテーションの「&lt;a href="matlab:helpview([docroot ''/toolbox/simulink/helptargets.map''], ''inherit_initial_output_values'')"&gt;入力信号からの初期出力値の継承&lt;/a&gt;」を参照してください。
</entry>
    <entry key="UnableToInitializeOutputCauseDueToUnsupportedDataType">グラウンド値は既定の初期出力として使用できません。そのような値は、ソース ブロック ''{1}'' の出力端子 {0, number, integer} のデータ型に対して決定できないためです。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;Simulink.internal.OpenBlockParamsDialog(''{2}'',''InitialOutput'')&lt;/cmd&gt; &lt;txt&gt;''{2}'' に対する [初期出力] を ''[]'' 以外の値に設定する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    
    </entry>
    <entry key="Invalid_Listner_TID_Format">''{0}'' に指定されているイベント リスナーの形式が無効です。イベント リスナー TID は [tid_1, tid_2, tid_3] の形式のベクトルを使って指定されなければなりません</entry>
    <entry key="JacobianAnalyticLinNotEnabled">AnalyticLinearization オプションは有効ではありません</entry>
    <entry key="LatchLinearizeErr">Cannot add linearization point at inport block ''{0}'' because such points are not supported for inports which have the option to latch subsystem inputs during execution turned on.</entry>
    <entry key="LatchLoopAssert">サブシステム ''{1}'' の実行期間全体で入力 {0,number,integer} をラッチできません。この入力に対するメモリ バッファーは、シミュレーション中に保持されるサブシステムの他の入力の 1 つのメモリ バッファーにマッピングされます。通常の操作では、このエラーを見ることはありません。このエラーは、このモデル内のバッファーの再利用に関する可能性のある問題を示しています。バグとしてこの問題を報告してください。また、この入力に接続される Outport ブロックの前に Signal Conversion ブロックを明示的に追加することにより、この信号のコピーを作成し、問題を回避してください。</entry>
    <entry key="LatchLoopError">Cannot latch all inputs of subsystem ''{0}'' over the duration of its execution. Since inport ''{1}'' directly reads the signal at the output of inport ''{2}'', it is not possible to latch both of these inputs independently before the execution of the subsystem. Consider inserting a Signal Conversion block before the outport block connected to the first inport to make an explicit copy of this signal.</entry>
    <entry key="LicenseError">Unable to check out the Simulink Coder license which is needed to generate code.</entry>
    <entry key="LineWithoutDst">未接続の出力ラインが ''{0}'' で見つかりました (出力端子: {1,number,integer})</entry>
    <entry key="LineWithoutSrc">未接続の入力ラインが ''{0}'' で見つかりました (入力端子: {1,number,integer})</entry>
    <entry key="LinearAnalysisForIterator">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の線形解析の属性は、Iterator ブロックを駆動するように設定できません</entry>
    <entry key="LinearAnalysisNonDataPort">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の線形解析の属性は、データのない端子で設定できません</entry>
    <entry key="LinearAnalysisNotSupportedInMultiTasking">
    マルチタスク モードでは、線形化はサポートされていません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{0}'',''EnableMultiTasking'',''off'');&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="EnableMultiTasking"&gt;[各離散レートを個別のタスクとして扱う]&lt;/sldiag&gt; をオフにする。&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{0}'',''SolverType'',''Variable-step'');&lt;/cmd&gt; &lt;txt&gt;可変ステップ ソルバーを使用する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    
</entry>
    <entry key="LinearAnalysisTooManyElements">モデルは線形化に対して多すぎる要素を含んでいます。モデルのサイズを減らしてください。</entry>
    <entry key="LinearAnalysisTooManyIOElements">Total size of input and output elements for linearization ({0} megabytes) must be less than 20% of the total available memory ({1} megabytes). To reduce the total size of the input and output elements, consider using fewer elements.</entry>
    <entry key="LinearizationWithSFuncDSMWrite">Data Store Memory への書き込みを行う S-Function ブロックの場合、線形化はサポートされていません。S-Function ブロック ''{0}'' と Data Store Memory ''{1}'' 間の接続は、線形解析中に無視されます。</entry>
    <entry key="LinearizationWithSFuncDSMRead">Data Store Memory から読み取りを行う S-Function ブロックの場合、線形化はサポートされていません。S-Function ブロック ''{0}'' と Data Store Memory ''{1}'' 間の接続は、線形解析中に無視されます。</entry>
    <entry key="InvalidPotentialLinearizationIO">SCDPotentialLinearizationIOs 構造体の要素 {0,number,integer} は、モデルの既存のブロックを参照していません。</entry>
    <entry key="InvalidLinearizationIOVariantSubsystem">線形化 IO ポイントを Variant Subsystem の最上位に配置することはできません。</entry>
    <entry key="LinearlyImplicitActionSubsystemWithFixedStepImplicit">モデル ''{0}'' は ''{1}'' ソルバーを使用し、線形陰的な ODE 系を指定する Action Subsystem を含むため、そのコードは生成できません。Action Subsystem 内の線形陰的な方程式での ''{1}'' の使用はサポートされていません</entry>
    <entry key="LinearlyImplicitEnabledSubsystemWithFixedStepImplicit">モデル ''{0}'' は ''{1}'' ソルバーを使用し、線形陰的な ODE 系を指定する Enabled Subsystem を含むため、そのコードは生成できません。Enabled Subsystem 内の線形陰的な方程式での ''{1}'' の使用はサポートされていません</entry>
    <entry key="LinearlyImplicitSystemsUnsupportedTarget">GRT、ERT、または xPC 以外のターゲット タイプに対して ODE の陰的な線形システムを指定しているため、モデル ''{0}'' のコードを生成できません。ODE の陰的な線形システムは GRT、ERT、および xPC ターゲットに対してのみサポートされます</entry>
    <entry key="LinearlyImplicitSystemsUnsupportedTargetOption">Unable to generate code for model ''{0}'' because ''C++ class'' as code interface packaging is not supported for model that specifies a linearly implicit system of ODEs. Set model configuration parameter &lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;Code interface packaging&lt;/sldiag&gt; to ''Nonreusable function'' or ''Reusable function''.</entry>
    <entry key="Listener_InvalidTid">''{0}'' のイベント リスナー TID は、0 から {1,number,integer} までの範囲になければなりません</entry>
    <entry key="MFileTsMustBeEmpty">''{1}'' の MATLAB S-function ''{0}'' によって出力されたサンプル時間 (TS) 行列は空でなければなりません</entry>
    <entry key="MSFcnAddDimsDependRuleCompStageMismatch">Simulink は ''{0}'' でレベル 2 MATLAB S-function に対する ''AddOutputDimsDependencyRule'' の不正な使用を検出しました。この関数 SimStruct は ''PostPropagationSetup'' メソッドでのみ使用できます。</entry>
    <entry key="MSFcnInvalidPassThroughInputIdx">レベル 2 MATLAB S-Function ブロック ''{1}'' に対して ''InputPortSameDimsAsOutputPort'' に指定された入力端子のインデックス {0,number,integer} が存在しません。</entry>
    <entry key="MSFcnInvalidPassThroughOutputIdx">レベル 2 MATLAB S-Function ブロック ''{1}'' に対して ''InputPortSameDimsAsOutputPort'' に指定された出力端子のインデックス {0,number,integer} が存在しません。</entry>
    <entry key="MSfcnMissingDefinedDimsDependRuleVarDims">''{1}'' のレベル 2 MATLAB S-function ''{0}'' は、''SignalSizesComputeType'' が ''FromInputSize'' になるように宣言されています。したがって、&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{0}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; の次元依存の規則を登録するために ''AddOutputDimsDependencyRules'' メソッドを使用しなければなりません。</entry>
    <entry key="MTCondExecDiagNotMatchModelAdvisor">サンプル時間の診断の [マルチタスクの条件付き実行サブシステム] の診断は ''{0}'' です。サブシステム ''{1}'' は、マルチタスクで実行します。これは、リアルタイム システムで壊れたデータ、または確定性のない動作を引き起こします。モデル アドバイザーは、リアルタイム システムに対してコードを生成する場合は、この診断を ''エラー'' にすることを推奨します。診断を ''エラー'' に変更することを検討してください。</entry>
    <entry key="MTCondExecSysHasAsync">条件付きの実行サブシステム ''{0}'' は、非同期のサブシステムを含みます。これは、リアルタイム システムでデータが破損する原因になります。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;非同期のサブシステムを条件付き実行サブシステムの外に移動する。&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''MultiTaskCondExecSysMsg'',''none'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="MultiTaskCondExecSysMsg"&gt;[マルチタスクの条件付き実行サブシステム]&lt;/sldiag&gt; を [なし] に設定して、このメッセージを非表示にする。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="MTDSMDiagNotMatchModelAdvisor">[コンフィギュレーション パラメーター] ダイアログの [診断] ページの [マルチタスク データ ストア] オプションは、''{0}'' です。異なるタスクで実行する Data Store Read ブロックと Data Store Write ブロックが存在します。これは、リアルタイム システムでデータが壊れる原因になります。モデル アドバイザーは、リアルタイム システムに対してコードを生成する場合は、この診断を ''エラー'' にすることを推奨します。診断を ''エラー'' に変更することを検討してください。</entry>
    <entry key="MaximumFwdTimesExceed">ライブラリ ''{0}'' を読み込もうとする際に、再帰限界値が制限を超えました。この問題の潜在的な原因は、メカニズムを転送するライブラリ リンクが無限ループ内で実行されていることです。</entry>
    <entry key="MatrixTypeForDWorkLength">次元の値に指定された引数 ''{0}'' はスカラーでなければなりません。</entry>
    <entry key="MdlFileDeleted">ブロック線図を読み込みましたがファイルは削除されました</entry>
    <entry key="MdlFileLoaded">ブロック線図を読み込みました</entry>
    <entry key="MdlFileNotOnPath">ブロック線図 ''{0}'' に含まれるファイルは、MATLAB パス {1} 上にありません。</entry>
    <entry key="MdlFileShadowedByFile">ブロック線図 ''{0}'' を含むファイルは、MATLAB パスの上位にある同名のファイルにより優先度が低くなっています。これは予期しない動作の原因になります。詳細は、Simulink ドキュメンテーションの &lt;a href="matlab:helpview([docroot ''/toolbox/simulink/helptargets.map''], ''shadowing'')"&gt;"Avoiding Problems with Shadowed Files"&lt;/a&gt; を参照してください。\n\nブロック線図を含むファイル: {1}\nMATLAB パスの上位にあるファイル: {2}</entry>
    <entry key="MdlFileMissingAndShadowedByFile">ブロック線図 ''{0}'' を含むファイルが見つかりません。同じ名前をもつ異なるファイルが MATLAB パスに存在しています。これは予期しない動作の原因になります。詳細については、Simulink ドキュメンテーションの「&lt;a href="matlab:helpview([docroot ''/toolbox/simulink/helptargets.map''], ''shadowing'')"&gt;Avoiding Problems with Shadowed Files&lt;/a&gt;」を参照してください。\n\n不足しているファイル: {1}。\nMATLAB パス上にあるファイル: {2}</entry>
    <entry key="LoadShadowedFile">ファイル ''{0}'' は、MATLAB パスの上位にある別の同名ファイルより優先度が低いため、読み込まれません。詳細は、Simulink ドキュメンテーションの &lt;a href="matlab:helpview([docroot ''/toolbox/simulink/helptargets.map''], ''shadowing'')"&gt;"Avoiding Problems with Shadowed Files"&lt;/a&gt; を参照してください。\n\nMATLAB パスの上位にあるファイル: {1}</entry>
    <entry key="SlxFileShadowsMoreRecentMdlFile">ファイル ''{0}.slx'' は、同じフォルダー内でより最近保存された MDL ファイル ''{1}.mdl'' より優先順位が高くなっています。詳細は、Simulink ドキュメンテーションの「&lt;a href="matlab:helpview([docroot ''/toolbox/simulink/helptargets.map''], ''shadowing'')"&gt;"Avoiding Problems with Shadowed Files"&lt;/a&gt;」を参照してください。</entry>
    <entry key="MdlFileShadowedByVariable">ブロック線図 ''{0}'' は、同じ名前の変数があるため優先されません。</entry>
    <entry key="MdlFileShadowing">モデル名 ''{0}'' は、MATLAB ワークスペースまたはパス上の別の名前より優先順位が高くなっています。この名前の別の使用を見つけるには、コマンドラインで "which -all {1}" と入力してください。問題を回避するためにモデル名を変更する必要があります。</entry>
    <entry key="MdlRefExecTimeWithBlockRequestStateResetSizeVary">ブロック ''{0}'' には、入力信号のサイズが変わるたびにリセットが必要な状態が含まれています。このブロック プロパティは、[可変サイズの信号のサイズを伝播] の [実行中] 設定と矛盾しています。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''PropagateVarSize'',''Only when enabling'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="PropagateVarSize"&gt;[可変サイズの信号のサイズを伝播]&lt;/sldiag&gt; を [イネーブルのときのみ] に変更する。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;''{1}'' を Enabled/Function-Call/Action/Resettable Subsystem 内に配置し、対応する制御端子ブロックの [可変サイズの信号のサイズを伝播] パラメーターを [イネーブルのときのみ] (Enabled Subsystem または Function-Call Subsystem の場合)、[実行の再開時のみ] (Action Subsystem の場合)、または [リセット時のみ] (Resettable Subsystem の場合) に設定する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="MdlRefInitTimeWithblockSizeDependOnValue">ブロック ''{0}'' の出力信号サイズは入力信号の値に依存します。しかし、&lt;sldiag objui="configset" objparam="PropagateVarSize"&gt;[可変サイズの信号のサイズを伝播]&lt;/sldiag&gt; が [イネーブルのときのみ] に設定されています。このパラメーターを [実行中] に変更することを検討してください。</entry>
    <entry key="MemoryAllocationError">メモリ割り当てエラー</entry>
    <entry key="MemorySectionsNotFound">メモリ セクション定義の読み込みエラー。</entry>
    <entry key="MetadataMustBeStruct">ブロック線図の [メタデータ] パラメーターは MATLAB 構造体でなければなりません</entry>
    <entry key="MissedNoncontSignal">Subsystem ブロック ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; が不連続点をもつ信号を出力し、連続状態をもつブロックに入力している可能性があります。これにより、ソルバーが不連続点付近で不正確な解を生成する可能性があります。</entry>
    <entry key="MixedContextOnGenerator">''{0}'' の接続先の端子は、(たとえば、ルート システム内の 1 つの端子と条件付き実行サブシステム内の別の端子のように) 異なる execution コンテキスト内に存在します。</entry>
    <entry key="MixedContextOnViewer">''{0}'' は、(たとえば、ルート システム内の信号と条件付き実行サブシステム内の別の信号のように) 異なる実行内容から発生する信号を表示しています。</entry>
    <entry key="ModelAlreadyCompiled">''{0}'' は、既にコンパイルされています</entry>
    <entry key="ModelCannotBeCompiledAgainWhileItIsBeingCompiled">モデルはコンパイル処理中のため、再度コンパイルすることはできません</entry>
    <entry key="CannotStartNewSimWhileSimOrCompileStarted">モデルのブロック線図の更新またはシミュレーションが開始された後は、そのモデルの新しいコマンド ライン シミュレーションを開始できません </entry>
    <entry key="ModelBlockNotConfiguredForMessagesMultiInstance">参照モデル ''{0}'' はメッセージを送受信するよう設定されていますが、メッセージベースの通信用には構成されていません。モデル コンフィギュレーション パラメーター [最上位モデルごとに可能なインスタンスの総数] を [複数] に設定してください。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''ModelReferenceNumInstancesAllowed'',''Multi'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="ModelReferenceNumInstancesAllowed" objname="{0}"&gt;[最上位モデルごとに可能なインスタンスの総数]&lt;/sldiag&gt; を [複数] に設定する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="ModelBlockNotConfiguredForFcnPortMultiInstance">参照モデル ''{0}'' は関数端子を使用していますが、クライアント/サーバー通信用に構成されていません。モデル コンフィギュレーション パラメーター [最上位モデルごとに可能なインスタンスの総数] を [複数] に設定してください。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''ModelReferenceNumInstancesAllowed'',''Multi'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="ModelReferenceNumInstancesAllowed" objname="{0}"&gt;[最上位モデルごとに可能なインスタンスの総数]&lt;/sldiag&gt; を [複数] に設定する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="ModelBlockCannotBeReusableForMultiInstanceCode">参照モデル ''{0}'' は再利用可能なコードを生成できません。この参照モデルでは、[最上位モデルごとに可能なインスタンスの総数] が [1] に設定されています。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''ModelReferenceNumInstancesAllowed'',''Multi'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="ModelReferenceNumInstancesAllowed" objname="{0}"&gt;[最上位モデルごとに可能なインスタンスの総数]&lt;/sldiag&gt; を [複数] に設定する。&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{1}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="CodeInterfacePackaging" objname="{1}"&gt;最上位モデル ''{1}'' で [コード インターフェイスのパッケージ化]&lt;/sldiag&gt; を [再利用できない関数] に設定する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="FunctionPortsRequireCpp">モデル ''{0}'' は関数サービス端子を含んでいますが、C++ クラス コードを生成するように構成されていません。モデル コンフィギュレーション パラメーター [コード インターフェイスのパッケージ化] (''CodeInterfacePackaging'') を [C++ クラス] に設定します。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''C++ class'')&lt;/cmd&gt; &lt;txt&gt;モデル ''{0}'' の &lt;sldiag objui="configset" objparam="CodeInterfacePackaging" objname="{0}"&gt;[コード インターフェイスのパッケージ化]&lt;/sldiag&gt; を [C++ クラス] に設定する (参照先や参照元のモデルに影響する可能性あり)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="MessagesDependsOnCppClassCode">参照モデル ''{0}'' はメッセージを送受信するよう設定されていますが、メッセージベースの通信用には構成されていません。モデル コンフィギュレーション パラメーター [コード インターフェイスのパッケージ化] (''CodeInterfacePackaging'') を [C++ クラス] に設定します。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''C++ class'')&lt;/cmd&gt; &lt;txt&gt;モデル ''{0}'' の &lt;sldiag objui="configset" objparam="CodeInterfacePackaging" objname="{0}"&gt;[コード インターフェイスのパッケージ化]&lt;/sldiag&gt; を [C++ クラス] に設定する (参照先や参照元のモデルに影響する可能性あり)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="GenerateAllocFcnDependsOnMultiInstanceCode">モデルの [コード インターフェイスのパッケージ化] オプションが [再利用できない関数] に設定されている場合は、モデル オプション GenerateAllocFcn を設定できません</entry>
    <entry key="ModelCompInProgress">''{0}'' のコンパイルを実行中</entry>
    <entry key="ModelDoesNotExist">
''{0}'' は Simulink モデルを識別するように MATLAB で登録されていないため、コンパイルできません。同じ名前の MATLAB クラスが他にも存在する可能性があります。その場合は、モデル名またはクラス名を変更してください。
</entry>
    <entry key="ModelNameTooLong">''{0}'' はモデル名が長すぎるため無効です</entry>
    <entry key="ModelTermInProgress">''{0}'' の終了を実行中</entry>
    <entry key="ModuleLibraryLoadError">以下のエラーのため ''{0}'' を読み込むことができません\n''{1}''\n</entry>
    <entry key="MultSampleTime">1つのサンプル時間のみ ''{0}'' を指定できます。</entry>
    <entry key="MultSysGenSameFcn">サブシステム ''{0}'' と ''{1}'' は同じ関数名 ''{2}'' が指定されています。この 2 つのシステムが完全に同じでなければ、この指定は正しくありません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;Simulink.internal.OpenBlockParamsDialog(''{0}'',''RTWFcnName'')&lt;/cmd&gt; &lt;txt&gt;''{0}'' の関数名を変更する&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;Simulink.internal.OpenBlockParamsDialog(''{1}'',''RTWFcnName'')&lt;/cmd&gt; &lt;txt&gt;''{1}'' の関数名を変更する&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''MaxIdLength'')&lt;/cmd&gt; &lt;txt&gt;[識別子の最大の長さ] を大きくする (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="RowMajorReusableFcnUnsupported">関数名 ''{1}'' の ForEach Subsystem ''{0}'' は再利用可能としてマークされています。これは、行優先のコード生成では現在サポートされていません。</entry>
    <entry key="MultiFcnCallInlined">複数の呼び出しがあるため、Function-Call Subsystem ''{0}'' の [コード生成] の [関数のパッケージ化] 設定を [インライン] から [関数] に変更します</entry>
    <entry key="FcnCallSysWithMulTidsCalledFromSFSfcn">親の中にインライン化できないため、Function-Call Subsystem ''{0}'' の [コード生成] の [関数のパッケージ化] 設定を [インライン] から [関数] に変更します</entry>
    <entry key="NonSLDomainFcnForceInline"> ''{0}'' の [関数のパッケージ化] の設定を、''{1}'' から ''Inline'' へ変更しています。このブロックにはイベント ベースの信号入力が含まれているか、イベント ベースの信号入力をもつ Atomic または Function-Call Subsystemに含まれています。</entry>
    <entry key="ReusableTopModelWithInternalDefaultMapping">このモデルでは、入出力が個々の引数として渡される再利用可能なコードを生成できません。これは、モデルの [内部データ] が''{0}'' にマッピングされ、これが、システム ''{1}'' が再利用できない関数として生成されるように強制する、単一インスタンスのストレージ クラスであるためです。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''RootIOFormat'',''Structure reference'')&lt;/cmd&gt; &lt;txt&gt; &lt;sldiag objui="configset" objparam="RootIOFormat"&gt;[ルートレベル I/O を以下として渡す]&lt;/sldiag&gt; を [構造体参照] に設定する &lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;[コード インターフェイスのパッケージ化]&lt;/sldiag&gt; を [再利用できない関数] に設定する (参照モデルまたは参照元モデルに影響を与える可能性あり)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="MultiInstanceForcedNonInline">''{0}'' がインラインにならないように設定されているため、このモデルでは、入出力が個別の引数として渡される再利用可能なコードを生成できません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''RootIOFormat'',''Structure reference'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="RootIOFormat"&gt;[ルートレベル I/O を以下として渡す]&lt;/sldiag&gt; を [構造体参照] に設定する&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;[コード インターフェイスのパッケージ化]&lt;/sldiag&gt; を [再利用できない関数] に設定する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="MultiInstanceForcedNonInlineCPP">''{0}'' がインラインにならないように設定されているため、このモデルでは C++ クラスのインターフェイスを生成できません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''CodeInterfacePackaging'')&lt;/cmd&gt; &lt;txt&gt;[コード インターフェイスのパッケージ化] を [C++ クラス] 以外の値に設定する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="MultiInstanceNonReusableAsyncSFcn">''{0}'' がコードの再利用をサポートしない非同期の S-Function であるため、このモデルでは再利用可能なコードを生成できません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;[コード インターフェイスのパッケージ化]&lt;/sldiag&gt; を [再利用できない関数] に設定する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="MultiInstanceNonReusableAsyncSFcn2">''{0}'' がインラインではない非同期の S-Function であるため、このモデルでは再利用可能なコードを生成できません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;[コード インターフェイスのパッケージ化]&lt;/sldiag&gt; を [再利用できない関数] に設定する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="MultiInstanceNonReusableSFcn">''{0}'' がコードの再利用をサポートしていないため、このモデルでは、入出力が個別の引数として渡される再利用可能なコードを生成できません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''RootIOFormat'',''Structure reference'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="RootIOFormat"&gt;[ルートレベル I/O を以下として渡す]&lt;/sldiag&gt; を [構造体参照] に設定する&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;[コード インターフェイスのパッケージ化]&lt;/sldiag&gt; を [再利用できない関数] に設定する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="MultiInstanceNonReusableSFcn2">''{0}'' がインラインでないため、このモデルでは、入出力が個別の引数として渡される再利用可能なコードを生成できません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''RootIOFormat'',''Structure reference'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="RootIOFormat"&gt;[ルートレベル I/O を以下として渡す]&lt;/sldiag&gt; を [構造体参照] に設定する&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;[コード インターフェイスのパッケージ化]&lt;/sldiag&gt; を [再利用できない関数] に設定する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="MultiInstanceNonReusableSFcn2GRT">''{0}'' は、インラインではないため、モデルは再利用可能なコードを生成できません。''grt_malloc.tlc'' ターゲットの代わりに ''grt.tlc'' ターゲットを使用することを検討してください。</entry>
    <entry key="MultiInstanceNonReusableSFcnCPP">''{0}'' は I/O 引数を使用したコードの再利用をサポートしていないため、このモデルは、[I/O 引数の step メソッド''] スタイルの C++ クラス インターフェイスを生成できません。[コンフィギュレーション パラメーター]、[コード生成]、[インターフェイス] ペインから [C++ クラス インターフェイスの設定] ボタンをクリックして、[Void-void step メソッド] スタイルの C++ クラス インターフェイスの使用を検討してください。</entry>
    <entry key="MultiInstanceNonReusableSFcnGRT">''{0}'' は、コードの再利用がサポートされていないため、モデルは再利用可能なコードを生成できません。''grt_malloc.tlc'' ターゲットの代わりに ''grt.tlc'' ターゲットを使用することを検討してください。</entry>
    <entry key="MultiInstanceSfcnNotInline">''{0}'' がインラインでないため、このモデルでは、入出力が個別の引数として渡される再利用可能なコードを生成できません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''RootIOFormat'',''Structure reference'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="RootIOFormat"&gt;[ルートレベル I/O を以下として渡す]&lt;/sldiag&gt; を [構造体参照] に設定する&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;[コード インターフェイスのパッケージ化]&lt;/sldiag&gt; を [再利用できない関数] に設定する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="MultiInstanceSfcnNotInlineCPP">''{0}'' がインラインでないため、このモデルでは C++ クラス インターフェイスを生成できません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''CodeInterfacePackaging'')&lt;/cmd&gt; &lt;txt&gt;[コード インターフェイスのパッケージ化] を [C++ クラス] 以外の値に設定する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="MultiInstanceWideFcnCallTrig">''{0}'' が複数のソースから呼び出される関数呼び出しトリガーでトリガーされているため、このモデルでは、入出力が個別の引数として渡される再利用可能なコードを生成できません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''RootIOFormat'',''Structure reference'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="RootIOFormat"&gt;[ルートレベル I/O を以下として渡す]&lt;/sldiag&gt; を [構造体参照] に設定する&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;[コード インターフェイスのパッケージ化]&lt;/sldiag&gt; を [再利用できない関数] に設定する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="MultiInstanceDefaultSharedLocalDSMMapping">''{0}'' は再利用可能なサブシステムであり、共有ローカル データ ストアの既定のストレージ クラスが Embedded Coder ディクショナリで定義されていないため、このモデルでは、入出力が個別の引数として渡される再利用可能なコードを生成できません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''RootIOFormat'',''Structure reference'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="RootIOFormat"&gt;[ルートレベル I/O を以下として渡す]&lt;/sldiag&gt; を [構造体参照] に設定する&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;[コード インターフェイスのパッケージ化]&lt;/sldiag&gt; を [再利用できない関数] に設定する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="MultiInstanceWideFcnCallTrigCPP">''{0}'' が複数のソースから呼び出される関数呼び出しトリガーでトリガーされているため、このモデルでは C++ クラス インターフェイスを生成できません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''CodeInterfacePackaging'')&lt;/cmd&gt; &lt;txt&gt;[コード インターフェイスのパッケージ化] を [C++ クラス] 以外の値に設定する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="AutosarCSCMdlRefParam">サブモデル ''{0}'' は ''AUTOSAR.Parameter'' オブジェクト ''{1}'' を参照できません。これは、このオブジェクトのカスタム ストレージ クラス ''{2}'' がモデルの階層構造の最上位モデルでのみサポートされているためです。パラメーターをモデルの引数としてサブモデルに渡すことを検討してください。</entry>
    <entry key="AutosarCSCMdlRefSig">サブモデル ''{0}'' は ''AUTOSAR.Signal'' オブジェクト ''{1}'' を参照できません。これは、このオブジェクトのカスタム ストレージ クラス ''{2}'' がモデルの階層構造の最上位モデルでのみサポートされているためです。 </entry>
    <entry key="AutosarPIMCSCTopModel">モデル ''{0}'' は AUTOSAR ターゲットを使用していないため、''AUTOSAR.Signal'' オブジェクト ''{1}'' を参照できません。 </entry>
    <entry key="MultiplePriorityViolations">システム ''{1}'' で {0,number,integer} の優先順位違反が検出されました。これらの優先順位違反は独立ではないことに注意してください。すなわち、上記の診断で報告されたブロックのサブセットの優先順位を変更すると、すべての優先順位違反を処理する可能性があります。</entry>
    <entry key="MultirateEnable">Enabled Subsystem ''{0}'' は、複数のタスクで実行します。これは、リアルタイム システムにおけるデータの破損や非確定的動作の原因になります。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;シングルレートの Enabled Subsystem を使用する&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''EnableMultiTasking'',''off'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="EnableMultiTasking"&gt;[各離散レートを個別のタスクとして扱う] をオフにする&lt;/sldiag&gt;&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''MultiTaskCondExecSysMsg'',''none'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="MultiTaskCondExecSysMsg"&gt;[マルチタスクの条件付き実行サブシステム]&lt;/sldiag&gt; を [なし] に設定して、このメッセージを非表示にする&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="MultirateEnable_MC">Enabled Subsystem ''{0}'' は、複数の同時実行タスクで実行します。これにより、リアルタイム システムでデータの破損や非確定的な動作が発生する可能性があります。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;シングルレートの Enabled Subsystem を使用する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="MultirateRootEnable">このモデルにはルート レベルのイネーブル端子 ''{0}'' が含まれており、マルチタスクで実行します。これは、リアルタイム システムで壊れたデータ、または確定性のない動作を引き起こします。モデルをシングルレートに変更するか、[コンフィギュレーション パラメーター] ダイアログ ボックスの [ソルバー] ペインで [各離散レートを個別のタスクとして扱う] オプションをオフにすることを検討してください。</entry>
    <entry key="MultipleAutoInsertedBlocksAtPort">ブロック ''{3}'' の {1} 端子 {2,number,integer} には自動挿入された同様のブロックが複数あるため、ブロック ''{0}'' をこの端子に永続的に挿入/配置できません。</entry>
    <entry key="NoAutoInsertedBlocksAtPort">ブロック ''{3}'' の {1} 端子 {2,number,integer} には自動挿入された同様のブロックが存在しないため、ブロック ''{0}'' をこの端子に永続的に挿入/配置できません。</entry>
    <entry key="NamedItemRename">既に名前が付けられている項目名を変更しようとしています。</entry>
    <entry key="NeverGotDisconnectResponse">ターゲットから切断の応答を一切受信していません。切断中...</entry>
    <entry key="NeverGotFinalLogBufferTerminator">ターゲットから最終のデータ ログ バッファーとログ終了を受信しませんでした。切断中...</entry>
    <entry key="NoActionSSInLoops">アクション サブシステムによる入力データ依存性エラー。アクション サブシステムの有効および無効な例は、Simulink ライブラリの Subsystem Examples を参照してください</entry>
    <entry key="NoAutoUpdateStatusClock">モデルのステータス バーとブロック線図パラメーター ''SimulationTime'' のターゲット時間を更新できません。ターゲット時間の更新を有効にするには、set_param(''{0}'',''ExtModeAutoUpdateStatusClock'',''on'') を実行してください。</entry>
    <entry key="NoBlocksInModel">ブロック線図 ''{0}'' は、ブロックを含まないか、すべてのブロックがバーチャルです</entry>
    <entry key="NoBehaviorsForArchitectureModel">アーキテクチャ モデル ''{0}'' にコンポーネントが含まれないか、あるいはすべてのコンポーネントがバーチャルです。コンポーネント、あるいはルート入力またはルート出力に動作を追加すると、この問題が解決される場合があります。</entry>
    <entry key="NoChangeWhileLogging">データ ログの進行中はデータ ログ オプションを変更できません</entry>
    <entry key="NoChangeWhileRunningInExtMode">シミュレーションをエクスターナル モードで実行している間は、''{2}'' のパラメーター ''{0} ({1})'' を変更できません。</entry>
    <entry key="NoChangeToDurationWhileConnectedInPackedMode">パラメーター ''ExtModeTrigDuration'' を変更できません。モデルがターゲット アプリケーションに接続されており、''ExtModeSendContiguousSamples'' が ''on'' になっています。</entry>
    <entry key="NoChecksumDetails">''{1}'' で利用可能な ''{0}'' の詳細がありません</entry>
    <entry key="NoChecksumDetailsCallGetCS">''{1}'' で利用可能な ''{0}'' の詳細がありません。モデルを終了し、コンパイルされていない状態のモデルで Simulink.{2}.getChecksum(''{3}'') を呼び出してみてください。</entry>
    <entry key="NoDataTypeOverrideForPurelyIntegerCode">浮動小数点数のサポートが無効になっており、モデルで double または single データ型が使用されているため、このモデルのコードを生成できません。モデルの [データ型オーバーライド] 設定が原因となっている可能性があります。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(get_param(0,'CurrentSystem'), 'PurelyIntegerCode','off')&lt;/cmd&gt; &lt;txt&gt;コードを生成するために、浮動小数点数のサポートを有効にする。&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;fxptui.setDTOValueOnModel(gcs,'Off')&lt;/cmd&gt; &lt;txt&gt;モデルからデータ型オーバーライドを削除する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="NoDataUploadBlocks">アップロードに対して選択されたデータがありません。</entry>
    <entry key="NoDirectConnWhenDrivingIter">Inport ブロック ''{0}'' から Iterator ブロック ''{1}'' への接続が無効です。Iterator に接続された Inport を直接 Outport に接続することはできません。Inport ブロックを Outport ブロックに直接接続する信号線上に Signal Conversion ブロックを挿入することを検討してください。</entry>
    <entry key="NoExtCmdsIfNotRunning">エクスターナル モード コマンドは、エクスターナル モードでターゲットに接続されているときにのみ発行できる可能性があります。</entry>
    <entry key="NoFcnCallOrActionSSInLoops">関数呼び出しサブシステムまたはアクション サブシステムによる入力データ依存性エラー。追加情報については、&lt;a href=\"matlab:openExample('simulink_features/SimulinkSubsystemSemanticsExample'); open_system('sl_subsys_semantics/ Function-call subsystems');\"&gt;''sl_subsys_semantics''&lt;/a&gt; にある Function-Call Subsystem の有効な例と無効な例を参照してください。</entry>
    <entry key="NoHiliteForInvalidConn">最適化により、Simulink は ''{0}'' を含むループ セクションを強調できないかもしれません。</entry>
    <entry key="NoSimBlockDiagram">モデル ''{0}'' は ''{1}'' ブロック線図であるため、そのシミュレーションは許可されません。</entry>
    <entry key="NoDefaultBDSim">既定のブロック線図のシミュレーションは許可されていません。</entry>
    <entry key="NoMemSecPackageForSystem">ブロック ''{1}'' の [Subsystem のパラメーター] ダイアログで指定されたメモリ セクション ''{0}'' が無効です。[コンフィギュレーション パラメーター] ダイアログで選択されたメモリ セクション パッケージがありません。</entry>
    <entry key="NoMemSecPackageForSystemDefaults">無効なメモリ セクション ''{0}'' がブロック線図 ''{1}'' の [コンフィギュレーション パラメーター] ダイアログに指定されました。指定されたメモリ セクションのパッケージがありません。</entry>
    <entry key="NoModelForRTWNameOpen">Simulink Coder ブロックまたはシステム名で open_system を使用するには、モデルを開いていなければなりません。</entry>
    <entry key="RTWNameIsEmpty">ブロック ''{0}'' に空のコード生成名があります。</entry>
    <entry key="RTWIdIsVoid">ブロック ''{0}'' にコード生成識別子がありません。</entry>
    <entry key="NoNonVirtualBlocksInModel">ブロック線図 ''{0}'' のすべてのブロックはバーチャルであるか、ブロック削減の最適化により削除されているか、あるいは非アクティブなバリアントであるため、シミュレーションの対象がありません。コード生成では、ブロック削減の最適化によって、コード生成に関与しない Sink ブロックで終端となるすべてのブロック線図の分岐が削除されることに注意してください。たとえば、&lt;sldiag objui="configset" objparam="MatFileLogging"&gt;[MAT ファイルのログ]&lt;/sldiag&gt; がオフの場合、To Workspace ブロックとそれらのソースが削除される可能性があります。</entry>
    <entry key="NoNonvirtSubsysSelfLoops">非バーチャル サブシステム ''{0}'' を含む直接フィードバック接続は許可されていません。</entry>
    <entry key="NoMultiTaskModelSelfLoops">マルチタスク モデルでは、レートが異なる Model ブロック ''{0}'' を含む直接フィードバック接続は許可されていません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param_action(''{1}'', ''EnableMultiTasking'', ''off'');&lt;/cmd&gt; &lt;txt&gt;コンフィギュレーション オプション &lt;sldiag objui="configset" objparam="EnableMultiTasking"&gt;[各離散レートを個別のタスクとして扱う]&lt;/sldiag&gt; の選択を解除し、モデルをシングル タスク モードに変更することを検討する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="NoConstRateIOSelfLoop">ブロック ''{0}'' の出力端子 {1,number,integer} と&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{0}"&gt;入力端子 {2,number,integer}&lt;/sldiag&gt; の直接フィードバック接続は、一方の端子に定数サンプル時間が存在し、もう一方には存在しない場合、許可されていません。
</entry>
    <entry key="NoOutputTimesWithFixedStep">固定ステップ ソルバー (''{0}'') では ''OutputTimes'' はサポートされません。TIMESPAN の最初と最後の要素が、開始と終了時間として使われます。それ以外の要素は無視されています。詳細については、''help sim'' と入力してください。</entry>
    <entry key="NoRTWCustomCode">ブロック ''{0}'' は、Simulink Coder Custom Code ブロックです。このブロックのタイプは、{1} で利用できません。</entry>
    <entry key="NoRefineWithFixedStep">固定ステップ ソルバー (''{0}'') では ''Refine'' はサポートされません。指定されたリファイン ファクター ''{1,number,integer}'' は無視されています。詳細については、''help sim'' と入力してください。</entry>
    <entry key="NoRefineWithPureDiscrete">&lt;sldiag objui="configset" objparam="Refine"&gt;[リファイン ファクター]&lt;/sldiag&gt; コンフィギュレーション パラメーターに指定された値を無視します。これは、モデル ''{0}'' が純粋な離散モデルであるためです。詳細は、[リファイン ファクター] オプションのドキュメンテーションを参照してください。</entry>
    <entry key="NoSListForSystem">システム ''{0}'' に対する並べ替えリストを決定できません。</entry>
    <entry key="NoTrigSSInLoops">ループ内に Triggered Subsystem や Model ブロックの利用による不明示的なソート順序が検出されました。Triggered Subsystem の有効な例と無効な例は、Simulink ライブラリの Subsystem Examples を参照してください。</entry>
    <entry key="NoTsInhDueToPreSetDWorkSigObj">このモデルは、サンプル時間がブロック ''{2}'' にある DWork {1,number,integer} に関連する信号オブジェクト ''{0}'' に対して明示的に設定されているため、サンプル時間を継承しません。\n \n このモデルがサンプル時間を継承する必要がない場合、コンフィギュレーション パラメーター ダイアログのソルバー タブで "周期的なサンプル時間の制約" を "サンプル時間に依存しない" 以外のものに変更してください。</entry>
    <entry key="NoTsInhDueToPreSetOutputSigObj">サンプル時間がブロック ''{2}'' にある&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; に関連する信号オブジェクト ''{0}'' に対して明示的に設定されているため、このモデルはサンプル時間を継承しません。\n \n このモデルがサンプル時間を継承する必要がない場合、[コンフィギュレーション パラメーター] ダイアログの [ソルバー] タブで [周期的なサンプル時間の制約] を [サンプル時間に依存しない] 以外のものに変更してください。</entry>
    <entry key="MultipleRunTimeTasks">ブロック ''{0}'' に、複数のランタイム レートがあります。</entry>
    <entry key="NonGraphicalDependencyCrossesFunctionSubsystem">関数呼び出しサブシステムの内部にあるため、ブロック ''{0}'' をブロック ''{1}'' の前に実行することができません。</entry>
    <entry key="NonGraphicalDependencyDifferentModels">異なるモデル内にあるため、ブロック ''{0}'' をブロック ''{1}'' の前に実行することができません。</entry>
    <entry key="NonGraphicalDependencyLoop">依存ループを引き起こすため、ブロック ''{0}'' をブロック ''{1}'' の前に実行することができません。</entry>
    <entry key="NonGraphicalDependencyMergeBlock">Merge ブロックがあるため、ブロック ''{0}'' をブロック ''{1}'' の前に実行することができません。</entry>
    <entry key="NonInhTsGlbDSMInhTsMod">モデル ''{0}'' 内において、いくつかのブロックはサンプル時間 {2} をもつ Simulink.Signal オブジェクトに対応するグローバルなデータ ストア ''{1}'' にアクセスします。しかし、そのモデルはサンプル時間に依存しないよう指定します。オブジェクトのサンプル時間は、継承 (-1) されなければなりません。</entry>
    <entry key="NonInlinedSFcnsNotSupported">ブロック ''{0}'' はインラインでない S-Function で、現在の構成ではサポートされていません。&lt;sldiag objui="configset" objparam="SupportNonInlinedSFcns"&gt;[インラインでない S-Function のサポート]&lt;/sldiag&gt; を選択してください。</entry>
    <entry key="NonInlinedSFcnsNotSupportedForRowMajor">ブロック ''{0}'' はインラインでない S-Function です。これは、行優先のコード生成ではサポートされません。</entry>
    <entry key="NonSourceBeingUsedAsSource">ビューアーおよびジェネレーター マネージャーは、ソースなしでは使用できません。''{0}'' は入力をもつように設定されているため、ソースではありません</entry>
    <entry key="NoninlinedSfcnNotReused">S-function ''{0}'' は、オプション SS_OPTION_WORKS_WITH_CODE_REUSE を持ちますが、ブロックは ''{1}.tlc'' ファイルを持ちません。このシステムは、再利用されません</entry>
    <entry key="RowMajorSfcnNotReusedInAcceleratedModes"> S-Function ''{0}'' を含むサブシステムは、アクセラレータ モードとラピッド アクセラレータ モードのコード再利用に関与できません。これは、''{0}'' が SS_ROW_MAJOR オプションを設定するためです。</entry>
    <entry key="NotEnoughMemoryOnTarget">ターゲット上にパケットを処理するための十分なメモリがありません: {0}</entry>
    <entry key="NotImplemented">内部エラー</entry>
    <entry key="NotMatchWithModelAdvisor">設定はモデル アドバイザーで推奨されません。</entry>
    <entry key="NotSupportSubsysFileInCPF">[コンフィギュレーション パラメーター] ダイアログ ボックスの [コード生成] &gt; [コード配置] ペインの [ファイル パッケージ化形式] パラメーターに対する [コンパクト] オプションは、サブシステムに対して個別のソース ファイルを生成しません。[Subsystem のパラメーター] ダイアログ ボックスで、次のサブシステムの [コード生成ファイル名オプション] パラメーターを [自動] に指定してください: ''{0}''。代替策は、[コンフィギュレーション パラメーター] ダイアログ ボックスの [コード生成] &gt; [コード配置] ペインで [ファイル パッケージ化形式] パラメーターを [モジュラー] として指定することです。</entry>
    <entry key="NotSupportedVarSizePropTypeAmbiguous">
参照モデル ''{0}'' の [可変サイズの信号のサイズを伝播] が [モデル内のブロックから推測] に設定されています。モデルには、モデル参照ターゲットで可変サイズの信号をもつ条件付き実行サブシステムまたは Resettable Subsystem ''{1}'' が含まれています。しかし Simulink は、次のいずれかの特性をもつブロックをモデル内で検出しませんでした。1) ブロックの出力信号のサイズが入力信号の値に依存する。2) 入力信号のサイズが変わり、ブロックが Enabled/Function-Call/Action/Resettable Subsystem 内にない場合にブロック状態のリセットが必要である。したがって、モデルが可変サイズの信号の伝播を [実行中] にサポートすべきか [イネーブルのときのみ] サポートすべきかを、Simulink では判断できません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''PropagateVarSize'')&lt;/cmd&gt; &lt;txt&gt;[可変サイズの信号のサイズを伝播] を [実行中] または [イネーブルのときのみ] に変更する&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="NotSupportedVarSizePropTypeAmbiguousRootControlPort">
参照モデル ''{0}'' の [可変サイズの信号のサイズを伝播] が [モデル内のブロックから推測] に設定されています。モデルのルート ''{1}'' には制御端子が含まれており、モデル参照ターゲットで可変サイズの信号があります。しかし Simulink は、次のいずれかの特性をもつブロックをモデル内で検出しませんでした。1) ブロックの出力信号のサイズが入力信号の値に依存する。2) 入力信号のサイズが変わり、ブロックが Enabled/Function-Call/Action/Resettable Subsystem 内にない場合にブロック状態のリセットが必要である。したがって、モデルが可変サイズの信号の伝播を [実行中] にサポートすべきか [イネーブルのときのみ] サポートすべきかを、Simulink では判断できません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''PropagateVarSize'')&lt;/cmd&gt; &lt;txt&gt;[可変サイズの信号のサイズを伝播] を [実行中] または [イネーブルのときのみ] に変更する&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="Not_FxpPoint">''{1}'' の ''{0}'' のメソッドは、整数と固定小数点のデータ型に対してのみ呼び出せます</entry>
    <entry key="NumDimsMismatchFromETVSSubsysIC">次元数の不一致が検出されました:''{0}'' の初期出力は、出力次元数が {1,number,integer} を指定しています。しかし、その入力信号は {2,number,integer} 次元です。</entry>
    <entry key="NumDimsNotMatchMatlab">与えられた MATLAB 配列の次元数は、Simulink の内部データの次元数と一致しません</entry>
    <entry key="Num_Var_Dims_Mismatch">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に割り当てられた可変次元が無効です。可変次元の数は {2,number,integer} です。しかし、MATLAB の配列の長さは {3,number,integer} です。</entry>
    <entry key="OVERRIDE_IR_SUPPORT_FLAG">ダミー メッセージ</entry>
    <entry key="ObsoleteExprDepthLimit">モデル パラメーター ''RTWExpressionDepthLimit'' は旧式です。代わりに ''ExpressionFolding'' パラメーターを使用してください。</entry>
    <entry key="ObsoleteSimPrmPage">モデル パラメーター ''SimParamPage'' は、旧式です。[コンフィギュレーション パラメーター] ダイアログに影響するため、''slCfgPrmDlg'' コマンドを使用してください。</entry>
    <entry key="OldStyleStateLabel">初期状態の構造体において、''{0}'' に対する状態ラベルは {1} から {2} に更新される必要があります。</entry>
    <entry key="OnlyTermWhenCompForChecksums">モデル ''{0}'' はチェックサムに対してのみコンパイルされました。終了は、この状態においてモデルに対して権限のあるモデル コマンドのみです。</entry>
    <entry key="OuterOutportPassThruFcnCallInArgMustInheritIC">Outport ブロック ''{0}'' のパラメーター [初期出力] は、ブロック ''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子{1,number,integer}&lt;/sldiag&gt; から発生する信号上での関数呼び出しデータの依存性違反を避けるために、[] に設定しなければなりません。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{0}'',''InitialOutput'',''[]'');&lt;/cmd&gt; &lt;txt&gt;''{0}'' に対する [初期出力] を ''[]'' に設定する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="OutportBufferRequiredConstTS">定数のサンプル時間をもつブロック ''{1}'' の出力端子 {2,number,integer} によって Outport ブロックが駆動されているため、確実に正しく初期化を行うには、Outport ブロック ''{0}'' に接続される信号が信号のコピーでなければなりません。Signal Conversion ブロックを挿入するか、モデルを変更してください。</entry>
    <entry key="OutportBufferRequiredExpFcnRootOutport">サブシステム ''{1}'' の出力端子 {2,number,integer} がエクスポート関数モデルのルート Outport ブロックを駆動するため、Outport ブロック ''{0}'' に接続される信号は信号のコピーでなければなりません。Signal Conversion ブロックを挿入するか、モデルを変更してください。</entry>
    <entry key="OutportBufferRequiredMergeNesting">サブシステム ''{1}'' の出力端子 {2,number,integer} は Merge ブロックに接続され、Outport ブロックは入れ子形式の条件付き実行サブシステム ''{3}'' の出力端子 {4,number,integer} によって駆動されているため、Outport ブロック ''{0}'' に接続される信号は信号のコピーでなければなりません。信号のコピーによって、結果がマージされる前に入れ子形式の条件付きサブシステムから最後に計算された出力が保持されます。Signal Conversion ブロックを挿入するか、モデルを変更してください。</entry>
    <entry key="OutportBufferRequiredMergeBranching">サブシステム ''{1}'' の出力端子 {2,number,integer} が Merge ブロックに接続されているため、Outport ブロック ''{0}'' に接続される信号は信号のコピーでなければなりません。ソース ブロック ''{3}'' の出力端子 {4,number,integer} は複数の接続先に分岐するため、その直接のマージはサポートされません。Signal Conversion ブロックを挿入するか、モデルを変更してください。</entry>
    <entry key="OutportBufferRequiredMergeNotReusable">サブシステム ''{1}'' の出力端子 {2,number,integer} が Merge ブロックに接続されているため、Outport ブロック ''{0}'' に接続される信号は信号のコピーでなければなりません。ソース ブロック ''{3}'' の出力端子 {4,number,integer} の信号バッファーは再利用不可としてマークされているため、その直接のマージはサポートされません。Signal Conversion ブロックを挿入するか、モデルを変更してください。</entry>
    <entry key="OutportBufferRequiredMergeModelBlock">サブシステム ''{1}'' の出力端子 {2,number,integer} が Merge ブロックに接続されているため、Outport ブロック ''{0}'' に接続される信号は信号のコピーでなければなりません。対応するルート Outport ブロックを参照モデルで駆動している信号が Merge ブロックの使用ルールに違反しているため、ソース Model ブロック ''{3}'' の出力端子 {4,number,integer} の直接のマージはサポートされません。Signal Conversion ブロックを挿入するか、モデルを変更してください。</entry>
    <entry key="OutportBufferRequiredNesting1">独立した初期出力値を指定して、入れ子形式の条件付き実行サブシステム ブロック ''{1}'' の出力端子 {2,number,integer} により Outport ブロックが駆動されているため、確実に正しく初期化を行うには Outport ブロック ''{0}'' に接続される信号が信号のコピーでなければなりません。Signal Conversion ブロックを挿入するか、モデルを変更してください。</entry>
    <entry key="OutportBufferRequiredNesting2">Merge ブロック ''{1}'' の出力端子 {2,number,integer} 経由で、独立した初期出力値を指定して入れ子形式の条件付き実行サブシステムにより Outport ブロックが駆動されているため、確実に正しく初期化を行うには Outport ブロック ''{0}'' に接続される信号が信号のコピーでなければなりません。Signal Conversion ブロックを挿入するか、モデルを変更してください。</entry>
    <entry key="OutportBufferRequiredNotReusable">ソース ブロック ''{1}'' の出力端子 {2,number,integer} の信号バッファーが再利用不可としてマークされているため、確実に正しく初期化を行うには、Outport ブロック ''{0}'' に接続される信号が信号のコピーでなければなりません。Signal Conversion ブロックを挿入するか、モデルを変更してください。</entry>
    <entry key="OutportBufferRequiredBranching">ソース ブロック ''{1}'' の出力端子 {2,number,integer} が、独立した初期出力値を使って別の Outport ブロック ''{3}'' を駆動しているため、確実に正しく初期化を行うには Outport ブロック ''{0}'' に接続される信号が信号のコピーでなければなりません。Signal Conversion ブロックを挿入するか、モデルを変更してください。</entry>
    <entry key="OutportBufferRequiredBranchingSameOutport">ソース ブロック ''{1}'' の出力端子 {2,number,integer} が 2 つの独立した信号を使用して Outport ブロック ''{0}'' を駆動しているため、正しい初期化を確実に行うには、この Outport ブロックに接続される信号が信号のコピーでなければなりません。Signal Conversion ブロックを挿入するか、モデルを変更してください。</entry>
    <entry key="OutportBufferRequiredStateflowReset">Stateflow ブロック ''{1}'' の出力端子 {2,number,integer} が Outport ブロックを駆動し、親サブシステム ''{3}'' は有効化に際してステートをリセットするように構成され、かつ有効化に際し実行される保証がないため、確実に正しく初期化を行うには Outport ブロック ''{0}'' に接続される信号が信号のコピーでなければなりません。Signal Conversion ブロックを挿入するか、モデルを変更してください。</entry>
    <entry key="OutportBufferRequiredVariantCondition">Outport ブロックのバリアント条件がソース ブロックのバリアント条件と異なるため、Outport ブロック ''{0}'' に接続される信号は信号のコピーでなければなりません。Signal Conversion ブロックを挿入するか、モデルを変更してください。</entry>
    <entry key="OutportBufferNotAllowedFcnCallInit">ソース ブロック ''{0}'' の出力端子 {1,number,integer} からの信号が関数呼び出し信号であるため、Outport ブロック ''{2}'' の前に Signal Conversion ブロックを自動的に挿入できません。</entry>
    <entry key="OutportBufferNotAllowedFcnCallInArg">ソース ブロック ''{0}'' の出力端子 {1,number,integer} からの信号が Outport ブロックを通って関数呼び出し先ブロックに渡され、挿入は関数呼び出しのデータ依存性違反の原因となるため、Outport ブロック ''{2}'' の前に Signal Conversion ブロックを自動的に挿入できません。関数呼び出しのデータ依存性違反の例は、モデル例 &lt;a href="matlab:openExample(''simulink_features/SimulinkSubsystemSemanticsExample''); open_system('sl_subsys_semantics/ Function-call subsystems');"&gt; ''sl_subsys_semantics''&lt;/a&gt; を参照してください。</entry>
    <entry key="OutportBufferNotAllowedSigObj">ソース ブロック ''{0}'' の出力端子 {1,number,integer} からの信号が非自動ストレージ クラスであるため、Outport ブロック ''{2}'' の前に Signal Conversion ブロックを自動的に挿入できません。</entry>
    <entry key="OutportCannotBufferFcnCallSFcn">''{0}'' 出力端子 {1,number,integer} からの関数呼び出し信号は、Outport ブロック ''{2}'' で規則的な信号として処理されています。Outport ブロックで関数呼び出し信号が確実に認識されるように、サブシステム''{3}'' の出力端子 {4,number,integer} を Function-Call Subsystem に接続します。Outport ブロックの [初期出力] を [] に設定します。または、S-Function ブロック ''{5}'' のソース コードがアクセス可能で、出力端子 {6,number,integer} のすべての要素が関数呼び出しである場合、mdlInitializeSizes で ssSetOutputPortDataType(S, {7,number,integer}, SS_FCN_CALL) を使用してこの出力端子を関数呼び出し信号として明示的に宣言することを検討してください。Outport ブロックの [初期出力] を [] に設定します。</entry>
    <entry key="OutportCannotBufferFcnCall">''{0}'' 出力端子 {1,number,integer} からの関数呼び出し信号は、Outport ブロック ''{2}'' で規則的な信号として処理されています。Outport ブロックで関数呼び出し信号が確実に認識されるように、サブシステム''{3}'' の出力端子 {4,number,integer} を Function-Call Subsystem に接続します。Outport ブロックの [初期出力] を [] に設定します。</entry>
    <entry key="OutportCannotHaveICForVirtualBus"> Outport ブロックがバーチャルなバス信号で駆動される場合、Outport ブロック ''{0}'' のパラメーター [初期出力] は空 ([]) でなければなりません。この Outport ブロックに対してスカラーまたは構造体の値の初期出力を指定できます。ただし、&lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;[指定不足の初期化の検出]&lt;/sldiag&gt; を [簡易] に設定して、簡易初期化モードを有効にしなければなりません。新規の初期化モードで必要なモデリング標準に準拠するために、いくつかの変更が必要になる可能性があることに注意してください。詳細は、モデル アドバイザーのチェック ''Outport と Merge ブロックに対する初期化パラメーターの整合性をチェック'' のドキュメンテーションを参照してください。</entry>
    <entry key="OutportCannotLogNonBuiltInDataTypes">Using the structure or array format is not supported when logging outport ''{0}'' with the string data type or data types that are not built-in. Change the logging format to Dataset or disable Output Logging.
		
		&lt;actions exclusiveFixIts="yes"&gt;
			&lt;action type="fixit"&gt;
				&lt;cmd&gt;set_param(bdroot(''{0}''),''SaveFormat'',''Dataset'')&lt;/cmd&gt;
				&lt;txt&gt;Set data format of model to Dataset.&lt;/txt&gt;
			&lt;/action&gt;
			&lt;action type="fixit"&gt;
				&lt;cmd&gt;set_param(bdroot(''{0}''),''SaveOutput'',''off'')&lt;/cmd&gt;
				&lt;txt&gt;Disable Output Logging.&lt;/txt&gt;
			&lt;/action&gt;
	    &lt;/actions&gt;
		
	</entry>
    <entry key="OutportEmptyDialogIC">Outport ブロック ''{0}'' の [初期出力] パラメーターの設定が無効です。初期出力値は完全に指定しなければなりません。</entry>
    <entry key="OutportInvalidEmptyDialogIC">Outport ブロック ''{0}'' の [初期出力] パラメーターの設定が無効です。初期出力値は完全に指定しなければなりません。または、既定の初期化を使用するには、[初期出力] パラメーターの値に空の行列 ('[]') を使用してください。</entry>
    <entry key="OutportInvICSrcInternal">Cannot inherit initial output for Outport block ''{0}'' because Simulink inserted a block of type ''{1}'' on the input signal of this Outport block. To correct this problem, specify an initial output value.</entry>
    <entry key="OutportInvICSrcPort">ブロック ''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; が有効な初期出力のソースでないため、Outport ブロック ''{0}'' に対する初期出力を継承できません。Outport ブロックは、Constant、Initial Condition、Merge (初期出力付き)、または、条件付きで実行されるサブシステム ブロックからの初期出力のみ継承できます。この問題を修正するには、Outport が必ず有効な初期出力のソースで駆動されるようにするか、初期出力の値を指定してください。</entry>
    <entry key="OutportInvICSrcRateTrans">Cannot inherit initial output for Outport block ''{0}'' because a Rate Transition block is inserted on the input signal of the Outport block. If you need a rate transition, specify an initial output value for the Outport block. Otherwise, deselect the option ''Automatically handle rate transition for data transfer'' in the Solver pane of the Configuration Parameters dialog</entry>
    <entry key="OutportInheritICStateflowMultiRateEnabledSubsys1">Outport block
    ''{0}'' is inheriting its initial output value from &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;output port
    {1,number,integer}&lt;/sldiag&gt; of Stateflow block ''{2}'' in the multi-rate enabled
    subsystem ''{3}''. Consider one of the following modifications:\n

    (1) Change ''States when enabling'' parameter of Enable Port block ''{4}'' to
    ''held''.\n

    (2) Make the enabled subsystem single-rate.\n

    (3) For the Outport block, ensure that the parameter ''Initial output'' is
    not empty ([]).\n

    (4) Insert a Signal Conversion block before the Outport block.</entry>
    <entry key="OutportInheritICStateflowMdlRefMultiRateEnabledSubsys1">Outport ブロック ''{0}'' は、マルチレートの Enabled Subsystem ''{3}'' にある Model ブロック ''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; を経由して Stateflow ブロックからの初期出力値を継承しています。次のいずれかの変更を検討してください。\n (1) Enable Port ブロック ''{4}'' の [イネーブル時の状態] パラメーターを [保持] に変更する。\n (2) Enabled Subsystem をシングルレートにする。\n (3) Outport ブロックで、パラメーター [初期出力] が空 ([]) でないことを確認する。\n (4) Outport ブロックの前に Signal Conversion ブロックを挿入する。</entry>
    <entry key="OutportInheritICStateflowMultiRateEnabledSubsys2">Outport ブロック ''{0}'' は Stateflow ブロック ''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; からの初期出力値を継承していますが、その親の Function-Call Subsystem ''{3}'' がマルチレートの Enabled Subsystem ''{4}'' によって駆動されています。次のいずれかの変更を検討してください。\n (1) Trigger Port ブロック ''{5}'' の [イネーブル時の状態] パラメーターを [保持] に変更する。\n (2) Enabled Subsystem をシングルレートにする。\n (3) Outport ブロックで、パラメーター [初期出力] が空 ([]) でないことを確認する。\n (4) Outport ブロックの前に Signal Conversion ブロックを挿入する。</entry>
    <entry key="OutportInheritICStateflowMdlRefMultiRateEnabledSubsys2">Outport ブロック ''{0}'' は Model ブロック ''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; を経由して Stateflow ブロックからの初期出力値を継承していますが、その親の Function-Call Subsystem ''{3}'' がマルチレートの Enabled Subsystem ''{4}'' によって駆動されています。次のいずれかの変更を検討してください。\n (1) Trigger Port ブロック ''{5}'' の [イネーブル時の状態] パラメーターを [保持] に変更する。\n (2) Enabled Subsystem をシングルレートにする。\n (3) Outport ブロックで、パラメーター [初期出力] が空 ([]) でないことを確認する。\n (4) Outport ブロックの前に Signal Conversion ブロックを挿入する。</entry>
    <entry key="OutportInvalidArrayDataLoggingUsingLHSA_COMPLEXITY">ルート出力端子に接続されている信号に実数/複素数の相違があるため、sim コマンドの追加出力引数を介して出力を保存できません。 \n入力引数 '''ReturnWorkspaceOutputs'' および ''on'' を使用することで、1 つの出力引数を介して出力を保存してください。</entry>
    <entry key="OutportInvalidArrayDataLoggingUsingLHSA_DATATYPE">ルート出力端子に接続されている信号にデータ型の相違があるため、sim コマンドの追加出力引数を介して出力を保存できません。 \n入力引数 '''ReturnWorkspaceOutputs'' および ''on'' を使用することで、1 つの出力引数を介して出力を保存してください。</entry>
    <entry key="OutportInvalidArrayDataLoggingUsingLHSA_DIM">モデル ''{0}'' のルート出力端子に接続されている信号がスカラーまたは 1 次元配列でないため、sim コマンドの追加出力引数を介して出力を保存できません。 \n入力引数 '''ReturnWorkspaceOutputs'' および ''on'' を使用することで、1 つの出力引数を介して出力を保存してください。</entry>
    <entry key="OutportInvalidArrayDataLogging_COMPLEXITY">ルート出力端子に接続されている信号の実数/複素数が同じではないため、出力を ''配列'' 形式で保存できません。 \n''[コンフィギュレーション パラメーター] &gt; [データのインポート/エクスポート] &gt; [形式]'' を [データセット]、[時間付き構造体]、または [構造体] に設定してください。出力形式は、コマンド ライン シミュレーションの sim コマンドの入力引数 ''SaveFormat'' を介して指定することもできます。</entry>
    <entry key="OutportInvalidArrayDataLogging_DATATYPE">ルート出力端子に接続されている信号にデータ型の相違があるため、出力を ''配列'' 形式で保存できません。 \n''[コンフィギュレーション パラメーター] &gt; [データのインポート/エクスポート] &gt; [形式]'' を [データセット]、[時間付き構造体]、または [構造体] に設定してください。出力形式は、コマンド ライン シミュレーションの sim コマンドの入力引数 ''SaveFormat'' を介して指定することもできます。</entry>
    <entry key="OutportInvalidArrayDataLogging_DIM">モデル ''{0}'' のルート出力端子に接続されている信号がスカラーまたは 1 次元配列でないため、出力を ''配列'' 形式で保存できません。''[コンフィギュレーション パラメーター] &gt; [データのインポート/エクスポート] &gt; [形式]'' を [データセット]、[構造体]、または [時間付き構造体] に設定してください。</entry>
    <entry key="BEPInvalidDataLoggingFormat">モデル ''{0}'' にはルート レベルの Bus Element Outport ブロックがあり、出力を [配列]、[構造体] または [時間付き構造体] のいずれかの形式で保存するように設定されています。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''SaveFormat'')&lt;/cmd&gt; &lt;txt&gt;''[コンフィギュレーション パラメーター] &amp;gt; [データのインポート/エクスポート] &amp;gt; [形式]'' を [データセット] に設定して出力を保存する&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="OutportMustHaveScalarICForBusSignal">The parameter ''Initial output'' of Outport block ''{0}'' must be a scalar or a structure when the Outport block is driven by a bus signal</entry>
    <entry key="OutportVarDimsVirtualBusWithNonVirtualSubbusSimplified">非バーチャル バス要素を含むバーチャル バスは、Outport ブロック ''{0}'' への入力としてはサポートされていません。バスの要素のうち少なくとも 1 つに可変次元があるからです。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;''{0}'' の入力に 'To Virtual Bus' ブロックを挿入し、バス信号を非バーチャル バス要素をもたないものに変換する。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;あるいは、''{0}'' への入力に、可変次元をもつ要素が含まれていないことを確認する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="OutportVarDimsVirtualBusWithNonVirtualSubbusClassic">非バーチャル バス要素を含むバーチャル バスは、Outport ブロック ''{0}'' への入力としてはサポートされていません。バスの要素のうち少なくとも 1 つに可変次元があるからです。次のすべての手順を実行し、問題を修正してください。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{1}'',''UnderspecifiedInitializationDetection'',''Simplified'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;[指定不足の初期化の検出]&lt;/sldiag&gt; を [簡易] に設定する。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;''{0}'' の入力に 'To Virtual Bus' ブロックを挿入し、バス信号を、非バーチャル バス要素を含まないものに変換する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="OutportMustHaveScalarICForVarDimsVirtualBusClassic">モデル ''{1}'' では、''{0}'' のような Outport ブロックが含まれている場合は、パラメーター &lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;[指定不足の初期化の検出]&lt;/sldiag&gt; を [クラシック] に設定できません。このブロックはバーチャル バスによって駆動され、バスには可変次元の要素が含まれているからです。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;Simulink.internal.OpenBlockParamsDialog(''{0}'',''InitialOutput'')&lt;/cmd&gt; &lt;txt&gt;[初期出力] パラメーターをスカラー値に設定する。&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{1}'',''UnderspecifiedInitializationDetection'',''Simplified'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;[指定不足の初期化の検出]&lt;/sldiag&gt; を [簡易] に設定する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="OutportNeedsVirtualBusCopy">Outport ブロック ''{0}'' を駆動するバス信号の明示的なコピーは、対応するサブシステムの出力信号を正しく初期化するために必要です。この Outport ブロックの前に、[出力] オプションを [信号コピー] に設定した Signal Conversion ブロックを挿入してください。次の理由のため、追加の信号のコピーが必要な場合があります。(1) Outport は、Ground ブロック、Constant ブロックまたは Stateflow ブロックのような上書きできない出力をもつブロックで駆動されている。(2) Outport は、同じサブシステム内の別の Outport または現在のサブシステム内で入れ子にされている Outport と同じ信号ソースを共有しているが、初期出力値が異なっている。(3) Outport は、Merge ブロックの入力に接続されている。(4) 明示的な初期値をもつ Simulink.Signal オブジェクトが、Outport の入力信号のいずれかに指定されている。</entry>
    <entry key="OutportPassingThruFcnCallInitSigMustInheritIC">A function-call trigger signal from &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;output port {1,number,integer}&lt;/sldiag&gt; of block ''{2}'' is passing through the Outport block ''{0}''. Therefore, the parameter ''Initial output'' must be set to [].
    &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;set_param(''{0}'',''InitialOutput'',''[]'');&lt;/cmd&gt;
            &lt;txt&gt;Set ''Initial output'' to ''[]'' for ''{0}''.&lt;/txt&gt;
        &lt;/action&gt;
    &lt;/actions&gt;
    </entry>
    <entry key="OutputBufferInfNanDetectedError">ブロック ''{0}'' は、{4} のタイム ステップ {5} で、&lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;出力端子 {3,number,integer}&lt;/sldiag&gt; の要素 {2,number,integer} に対する ''{1}'' を出力します。このブロックは値が派生したブロックではない可能性があります。値が派生したブロックを検出するには、アクセラレータ モードの代わりにノーマル モードで実行してください</entry>
    <entry key="OutputNotConnected">ブロック ''{1_SLObject}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1_SLObject}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; は接続されていません。</entry>
    <entry key="OutputPortMultiDDimsDisallowed">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の次元を {2} に設定できません。このブロックは、2 次元より大きい次元の信号を取り扱うよう設定されていません。</entry>
    <entry key="OutputPortTrailingUnityDimsDisallowed">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の次元を {2} に初期化できません。行列の次元数が 2 を超える場合、後続の次元のサイズは 1 より大きくなければなりません。</entry>
    <entry key="OverLicenseBlockLimit">ブロック線図 ''{0}'' 内のブロックとそれを参照するすべてのモデルの数は、{1,number,integer} 個の非バーチャル ブロックのライセンスの制限を超えています。</entry>
    <entry key="LicenseNoAcceleratorWarning">モデル ''{0}'' はアクセラレータまたはラピッド アクセラレータ モードを使用します。このライセンスはこれらのモードをサポートしません。シミュレーションはノーマル モードで実行されます。</entry>
    <entry key="ExplicitPartitionsNotSupportedInXIL">明示的な分割を使用したモデルは、最上位モデルの SIL または PIL シミュレーション モードではサポートされません。ただし、このモデルは、SIL または PIL シミュレーション モードでモデル ブロックとして参照されることで、同様に検証できます。</entry>
    <entry key="PLCCoder_LicenseError">コードの生成に必要な Simulink PLC Coder のライセンスを照合できません</entry>
    <entry key="ParamDataTypeNotSupportedInRTP">ブロック線図 ''{0}'' には、データ型 ''{2}'' をもつチューナブル パラメーター ''{1}'' があります。このデータ型は rsimgetrtp、または、ラピッド アクセラレータ モードでサポートされていません。</entry>
    <entry key="NotSupportRSIMWithMessages">モデル ''{0}'' はシステム ターゲット ファイル rsim.tlc を使用して構成されており、メッセージの送受信を行うブロック ''{1}'' が含まれます。システム ターゲット ファイル rsim.tlc では、このブロックのメッセージ パッシングはサポートされていません。別のシステム ターゲット ファイルを選択してください。</entry>
    <entry key="NotSupportExtModeWithMessages">モデル ''{0}'' はエクスターナル モードを使用するよう構成されており、メッセージの送受信を行うブロック ''{1}'' が含まれます。エクスターナル モードでは、このブロックのメッセージ パッシングはサポートされていません。モデル コンフィギュレーション パラメーター [エクスターナル モード] をオフにします。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''ExtMode'',''off'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="ExtMode"&gt;[エクスターナル モード]&lt;/sldiag&gt; を無効にする。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="NotSupportLogToMDFWithMessages">モデル ''{0}'' は信号を MDF ファイルに記録するように構成されており、メッセージを送受信するブロック ''{1}'' を含んでいます。MDF ファイルの信号ログでは、このブロックのメッセージ パッシングはサポートされていません。モデル コンフィギュレーション パラメーター [LogToMDFFile] を 'off' に設定します。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="DisableMDF"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''LogToMDFFile'',''off'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="LogToMDFFile"&gt;[信号を MDF ファイルに記録]&lt;/sldiag&gt; を無効にする。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="ModelParameterNotFoundInCAPI"> モデル パラメーター ''{0}'' が C-API で見つかりませんでした。 </entry>
    <entry key="BlockParameterNotFoundInCAPI"> ブロック パスが ''{1}'' になっているブロック パラメーター ''{0}'' が C-API で見つかりませんでした。 </entry>
    <entry key="RSimGetRtpGeneratedCodeDoesNotExist"> ホストの C-API ライブラリ ''{0}'' が見つかりませんでした。 </entry>
    <entry key="RSimGetRtpCannotUsePreCompiledModel">RSimGetRTP は、プリコンパイルされたモデルでは動作しません。</entry>
    <entry key="RSimGetRtpChecksumMismatch">RSimGetRTP に与えられた rtp のチェックサムが、生成されたコードのチェックサムと一致しません。</entry>
    <entry key="ParameterDataNotReusableSCForCPP">パラメーター ''{0}'' のストレージ クラスはグローバルのため、生成されたコードは C++ クラス インターフェイスに準拠していません。ストレージ クラス ''Auto'' を使用するか、あるいは [コード インターフェイスのパッケージ化] オプションを [C++ クラス] 以外の値に設定することを検討してください</entry>
    <entry key="ParentInitTimeVariableSizeSubsystemExecTimeVariableSize">サブシステム ''{0}'' は、[実行中に可変サイズの信号のサイズを伝播] に設定されています。しかし、親のサブシステムは、[可変サイズの信号のサイズを伝播: イネーブルのときのみ/リセット時のみ/実行の再開時のみ] に設定されています。''{1}'' の [可変サイズの信号のサイズを伝播] パラメーターを [イネーブルのときのみ] に変更することを検討してください。</entry>
    <entry key="ResetSSParentInitTimeVariableSizeSubsystemExecTimeVariableSize">サブシステム ''{0}'' は、[実行中に可変サイズの信号のサイズを伝播] に設定されています。しかし、親のサブシステムは、[可変サイズの信号のサイズを伝播: イネーブルのときのみ/リセット時のみ/実行の再開時のみ] に設定されています。''{1}'' の [可変サイズの信号のサイズを伝播] パラメーターを [リセット時のみ] に変更することを検討してください。</entry>
    <entry key="EmlParseCompilationError">コード置換ライブラリで指定された導出式 ''{0}'' は、コード生成でサポートされていません。</entry>
    <entry key="PartialCompileEarlyTerminate">要求に従ってパラメーターの評価後にコンパイルを終了します</entry>
    <entry key="PassThroughBusTypeMismatch">''{0}'' は無効なデータ型です。ブロックには、入力端子 {1,number,integer} と出力端子 {2,number,integer} がモデル実行中等しくなければならないことを示すフラグ (S-Function に対する ssSetInputDimsSameAsOutputDims) が設定されています。Simulink では、入力端子と出力端子が同じバス型をもつ必要があります。</entry>
    <entry key="PassThroughCompStageMismatch">Simulink は ''{0}'' で S-function に対する ''ssSetInputPortDimsSameAsOutputPortDims'' の不正な使用を検出しました。この関数 SimStruct は ''mdlSetWorkWidths'' メソッドでのみ使用できます。</entry>
    <entry key="PassThroughDimsMismatch">The maximum dimensions of the variable-size signals at the &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;input port {1,number,integer}&lt;/sldiag&gt; and the &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{0}"&gt;output port {2,number,integer}&lt;/sldiag&gt; of block ''{0}'' are ''{3}'' and ''{4}'' respectively. These values at the input and the output port of this block must match.</entry>
    <entry key="PassThroughDimsModeMismatch">''{0}'' には無効な次元モードの設定があります。そのブロックには、入力端子 {1,number,integer} と出力端子 {2,number,integer} の次元がモデル実行中等しくなければならないことを示すフラグ (S-Function に対する ssSetInputDimsSameAsOutputDims) があります。Simulink では、入力端子と出力端子が同じ次元モードをもつ必要があります。</entry>
    <entry key="PassThroughInvalidDirectFeedThroughSetting">可変サイズのモードの ''{0}'' には無効な直達が設定されています。そのブロックには、入力端子 {1,number,integer} と出力端子 {2,number,integer} の次元がモデル実行中等しくなければならないことを示すフラグ (S-Function に対する ssSetInputDimsSameAsOutputDims) があります。Simulink では、入力端子に対する直達の設定を ''オン'' にしなければなりません。</entry>
    <entry key="PathEmpty">空のパスが指定されました</entry>
    <entry key="PathInvalid">無効なパスが指定されました</entry>
    <entry key="PeriodicFCSSMustHaveScalarCall">関数呼び出しブロック ''{0}'' は周期的なサンプル時間をもつため、実行できるのは 1 つの関数呼び出し開始プログラムのみです。</entry>
    <entry key="PerturbationMustBeScalar">ブロック ''{0}'' の端子 {1,number,integer} に対する端子の摂動レベルは、スカラー変数でなければなりません。</entry>
    <entry key="PerturbationNotValidOnOutputPort">端子の摂動レベルは、Simulink の出力端子に対して有効ではありません</entry>
    <entry key="PerturbationWithNonDoubleData">ブロックは数値摂動法を使って線形化されます。少なくとも入力端子の 1 つは、double でなく、摂動ではありません。</entry>
    <entry key="PortBasedTsNeedsPorts">ブロック ''{0}'' は端子がないため、PORT_BASED_SAMPLE_TIMES を指定できません。</entry>
    <entry key="PortDimsMismatch11">端子幅または次元のエラー。''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に無効な次元が指定されています。次元は NULL にはできません。</entry>
    <entry key="PortDimsMismatch12">端子幅または次元のエラー。''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に無効な次元が指定されています。次元は NULL にはできません。</entry>
    <entry key="PortDimsMismatch21">端子幅または次元のエラー。''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に無効な次元が指定されています。</entry>
    <entry key="PortDimsMismatch22">端子幅または次元のエラー。''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に無効な次元が指定されています。</entry>
    <entry key="PortDimsMismatch31">端子幅または次元のエラー。''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に {2,number,integer} 要素があります。この端子は、入力信号で指定された次元 (または方向) を受け入れません。</entry>
    <entry key="PortDimsMismatch32">端子幅または次元のエラー。''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に {2,number,integer} 要素があります。この端子は、出力信号で指定された次元 (または方向) を受け入れません。</entry>
    <entry key="PortDimsMismatch41">端子幅または次元のエラー。''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; は、{2,number,integer} 要素がある 1 次元ベクトルです。</entry>
    <entry key="PortDimsMismatch42">端子幅または次元のエラー。''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; は、{2,number,integer} 要素がある 1 次元ベクトルです。</entry>
    <entry key="BusSelectorAoBInputErr">Bus Selector ブロック ''{0}'' にはバスが必要ですが、バスの配列を受け取っています。バスの配列から要素を選択するには、Bus Selector ブロックの代わりに Selector ブロックを使用します。</entry>
    <entry key="PortDimsMismatch51">端子幅または次元のエラー。''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; は、{2} 行列です。</entry>
    <entry key="PortDimsMismatch52">端子幅または次元のエラー。''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; は、{2} 行列です。</entry>
    <entry key="PortHandleNotAvailable">線形化ポイントに対応する端子のハンドルの少なくとも 1 つが利用できません。ブロック線図から削除されているブロックがないことを確認してください。たとえば、モデルのコールバック関数やマスクの初期化コードなどです。</entry>
    <entry key="PortSampHitForNonPST">''{0}'' の ''IsSampleHit'' メソッドは、サンプル時間を持たない端子を呼び出せません</entry>
    <entry key="PortTypeDomainDifference">端子タイプ ''{0}'' と端子タイプ ''{1}'' は異なる領域をもつため接続できません。</entry>
    <entry key="PortVarDimsMismatch31">端子幅または次元のエラー。''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; は最大で {2,number,integer} 要素があります。この端子は、入力信号で指定された次元 (または方向) を受け入れません。</entry>
    <entry key="PortVarDimsMismatch32">端子幅または次元のエラー。''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; は最大で {2,number,integer} 要素があります。この端子は、出力信号で指定された次元 (または方向) を受け入れません。</entry>
    <entry key="PortVarDimsMismatch41">端子幅または次元のエラー。''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; は最大で {2,number,integer} 要素をもつ 1 次元ベクトルです。</entry>
    <entry key="PortVarDimsMismatch42">端子幅または次元のエラー。''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; は最大で {2,number,integer} 要素をもつ 1 次元ベクトルです。</entry>
    <entry key="PortVarDimsMismatch51">端子幅または次元のエラー。''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; は、最大サイズが {2} の行列です。</entry>
    <entry key="PortVarDimsMismatch52">端子幅または次元のエラー。''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; は、最大サイズが {2} の行列です。</entry>
    <entry key="PrintAlgLoopFound">次を含む代数ループが見つかりました: {0} </entry>
    <entry key="ProfileInitErrWithErrContext">Simulink プロファイラーに対するエラーのコンテキストの初期化中にエラーが発生しました</entry>
    <entry key="ProfileInitErrWithMsgContext">Simulink プロファイラーに対するメッセージのコンテキストの初期化中にエラーが発生しました</entry>
    <entry key="ProfileReportGenErr">モデル ''{0}'' に対するプロファイル レポートを生成中にエラーが発生しました。</entry>
    <entry key="ProfilingNotSupportedForFixedAndDiscrete">ソルバーのプロファイリングは、固定ステップ ソルバーと状態を持たないモデルに対してサポートされていません。\n固定ステップの ODE ソルバーか、または離散状態に関連して生成されるソルバー情報はありません\n</entry>
    <entry key="ProjStateNotFinite">時間 {0} において不変量を設定した後は、''{2}'' の状態 ''{1}'' は Inf または NaN になります。シミュレーションを停止します。</entry>
    <entry key="ProjectionsNotSupported">サポートされていない State プロジェクションが必要なため、モデル ''{0}'' のコードを生成できません。</entry>
    <entry key="RTI_ASSIGN_COMPLEX_MISMATCH">''{0}'' に無効な指定: ''複素数'' を ''実数'' に割り当てようとしています</entry>
    <entry key="RTI_ASSIGN_DATA_TYPE_MISMATCH">''{0}'' に無効な指定: ''{1}'' を ''{2}'' に割り当てようとしています</entry>
    <entry key="RTI_ASSIGN_DIMS_MISMATCH">''{0}'' に無効な指定: 次元 {1} の行列を次元 {2} の行列に割り当てようとしています</entry>
    <entry key="RTI_ASSIGN_INVALID_DATA">''{0}'' の割り当てが無効です。データは数値か論理配列でなければなりません。</entry>
    <entry key="RTI_ASSIGN_NUM_DIMS_MISMATCH">''{0}'' に無効な指定: 行列をベクトルに割り当てようとしています</entry>
    <entry key="RTI_ASSIGN_VECT_WIDTH_MISMATCH">''{0}'' に無効な指定: 幅 {1,number,integer} のベクトルを幅 {2,number,integer} のベクトルに割り当てようとしています</entry>
    <entry key="RTI_ContStatesInvalidComplexity">''{0}'' の連続状態に指定されたデータの complexity が無効です。データの complexity は、''Real'' か ''Complex'' でなければなりません</entry>
    <entry key="RTI_ContStatesInvalidDatatype">''{0}'' の連続状態に指定されたデータ型が無効です。連続状態のデータ型 ID は ''double'' に対して 0 でなければなりません。</entry>
    <entry key="RTI_ContStatesInvalidDims">''{0}'' の連続状態に指定された次元が無効です。連続状態に対する次元は、正の整数でなければなりません。</entry>
    <entry key="RTI_DataAsDouble_NonBuiltInNotSupported">''{0}'' の DataAsDouble メソッドは組み込みでないデータ型に対してサポートされません</entry>
    <entry key="RTI_DataStoreCmplxReadOnly">''{1}'' 内の DataStore ''{0,number,integer}'' の読み取り専用の ''Complexity'' フィールドを設定できません</entry>
    <entry key="RTI_DataStoreDimsReadOnly">''{1}'' 内の DataStore ''{0,number,integer}'' の読み取り専用の ''Dimensions'' フィールドを設定できません</entry>
    <entry key="RTI_DataStoreDtypeReadOnly">''{1}'' 内の DataStore ''{0,number,integer}'' の読み取り専用の ''DataType'' フィールドを設定できません</entry>
    <entry key="RTI_Data_NonBuiltInNotSupported">''{0}'' 内の組み込みでないデータ型をもつデータのアクセスはサポートされません</entry>
    <entry key="RTI_DerivativesInvalidComplexity">''{0}'' の微係数に指定されたデータの complexity が無効です。データの complexity は、''Real'' か ''Complex'' でなければなりません</entry>
    <entry key="RTI_DerivativesInvalidDatatype">''{0}'' の微係数に指定されたデータ型が無効です。微係数のデータ型 ID は ''double'' に対して 0 でなければなりません</entry>
    <entry key="RTI_DerivativesInvalidDims">''{0}'' の微係数に指定された次元が無効です。連続状態に対する次元は、正の整数でなければなりません。</entry>
    <entry key="RTI_DlgPrmInvalidComplexity">''{1}'' のダイアログ パラメーター {0,number,integer} に指定されたデータの complexity が無効です。データの complexity は、''Real'' か ''Complex'' でなければなりません</entry>
    <entry key="RTI_DlgPrmInvalidDatatype">''{1}'' のダイアログ パラメーター {0,number,integer} に指定されたデータ型が無効です。データ型 ID は、以下のいずれかでなければなりません: ''double'' は 0、''single'' は 1、''int8'' は 2、''uint8'' は 3、''int16'' は 4、''uint16'' は 5、''int32'' は 6、''uint32'' は 7、''boolean'' は 8</entry>
    <entry key="RTI_DlgPrmInvalidDims">''{1}'' のダイアログ パラメーター {0,number,integer} に指定された次元が無効です。次元は正の整数の配列でなければなりません。</entry>
    <entry key="RTI_DworkInvalidComplexity">''{1}'' の Dwork {0,number,integer} に指定されたデータの complexity が無効です。データの complexity は、''Real'' か ''Complex'' でなければなりません</entry>
    <entry key="RTI_DworkInvalidDatatype">''{1}'' のDwork {0,number,integer} に指定されたデータ型が無効です。Dwork のデータ型 ID は、以下のいずれかでなければなりません: ''double'' は 0、''single'' は 1、''int8'' は 2、''uint8'' は 3、''int16'' は 4、''uint16'' は 5、''int32'' は 6、''uint32'' は 7、''boolean'' または固定小数点データ型は 8</entry>
    <entry key="RTI_DworkInvalidDims">''{1}'' の Dwork {0,number,integer} に指定された次元が無効です。Dwork は、ベクトルで、そのベクトルの幅は正の整数でなければなりません。</entry>
    <entry key="RTI_EmptyDataStoreName">''{1}'' の DataStore {0,number,integer} の名前は、空の文字ベクトルにはできません</entry>
    <entry key="RTI_EmptyDworkName">''{1}'' の Dwork {0,number,integer} の名前は、空の文字ベクトルにはできません</entry>
    <entry key="RTI_FullDimInfoUnknown">''{1}'' のDwork {0,number,integer} の次元情報が完全に指定されていません。</entry>
    <entry key="RTI_IdxForNoDataStore">''{0}'' の DataStore のインデックスが無効です。このブロックには登録された DataStores はありません。</entry>
    <entry key="RTI_IdxForNoDlgPrm">''{0}'' のダイアログ パラメーターのインデックスが無効です。このブロックにはダイアログ パラメーターがありません。</entry>
    <entry key="RTI_IdxForNoDwork">''{0}'' の Dwork のインデックスが無効です。このブロックには登録された Dwork はありません。</entry>
    <entry key="RTI_IdxForNoInputPort">''{0}'' に指定された入力端子のインデックスが無効です。このブロックには入力端子がありません。</entry>
    <entry key="RTI_IdxForNoOutputPort">''{0}'' に指定された出力端子のインデックスが無効です。このブロックには出力端子がありません。</entry>
    <entry key="RTI_IdxForNoRTP">''{0}'' の実行時のパラメーターのインデックスが無効です。このブロックには実行時のパラメーターがありません</entry>
    <entry key="RTI_InputPortInvalidComplexity">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に指定された信号の複素数が無効です。信号の実数/複素数は、''Real''、''Complex'' または ''Inherited'' でなければなりません</entry>
    <entry key="RTI_InputPortInvalidDatatype">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に指定されたデータ型が無効です。入力端子のデータ型 ID は、以下のいずれかでなければなりません: ''継承'' は -1、''double'' は 0、''single'' は 1、''int8'' は 2、''uint8'' は 3、''int16'' は 4、''uint16'' は 5、''int32'' は 6、''uint32'' は 7、''boolean'' または固定小数点データ型は 8</entry>
    <entry key="RTI_InputPortInvalidDims">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に指定された次元が無効です。次元は正の整数 (あるいは継承は -1) の配列でなければなりません。</entry>
    <entry key="RTI_InputPortInvalidDimsMode">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に指定された次元モードが無効です。次元モードは、''Fixed''、''Variable''、''Inherited'' のいずれかでなければなりません</entry>
    <entry key="RTI_InputPortInvalidFrameness">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に指定されたサンプリング モードが無効です。サンプリング モードは ''Sample''、''Frame''、''Inherited'' のいずれかでなければなりません</entry>
    <entry key="RTI_InputPortInvalidOverwriteDatatype">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; のデータ型 ID を {2,number,integer} から {3,number,integer} に変更できません</entry>
    <entry key="RTI_InputPortInvalidReuseSetting">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に指定された再利用性 (reusability) が無効です。入力端子の再利用性は、''NotReusableAndGlobal'' または ''ReusableAndLocal'' でなければなりません</entry>
    <entry key="RTI_InputPortOverwriteComplexity">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; の信号の複素数を ''{2}'' から ''{3}'' に変更できません</entry>
    <entry key="RTI_InputPortOverwriteDims">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; の次元を {2} から {3} に変更できません</entry>
    <entry key="RTI_InputPortOverwriteDimsMode">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; の次元モードを ''{2}'' から ''{3}'' に変更できません</entry>
    <entry key="RTI_InputPortOverwriteFrameness">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; のサンプリング モードを ''{2}'' から ''{3}'' に変更できません</entry>
    <entry key="RTI_InvalidDataStoreIdx">''{0}'' の DataStore のインデックスが無効です。Dwork のインデックスは 1 から {1,number,integer} の範囲でなければなりません</entry>
    <entry key="RTI_InvalidDlgPrmIdx">''{0}'' のダイアログ パラメーターのインデックスが無効です。ダイアログ パラメーターのインデックスは 1 から {1,number,integer} の範囲でなければなりません</entry>
    <entry key="RTI_InvalidDworkIdx">''{0}'' の Dwork のインデックスが無効です。Dwork のインデックスは 1 から {1,number,integer} の範囲でなければなりません</entry>
    <entry key="RTI_InvalidInputPortIdx">''{0}'' に指定された入力端子のインデックスが無効です。入力端子のインデックスは 1 から {1,number,integer} の範囲でなければなりません</entry>
    <entry key="RTI_InvalidInputPortIdx2">ブロック "''{1}''" に対して指定されている入力端子のインデックス ({0,number,integer}) が無効です。このブロックには {2,number,integer} の入力端子があります。ヒント:端子の番号は 1、2、3... と付けられています</entry>
    <entry key="RTI_InvalidOutputPortIdx">''{0}'' の出力端子のインデックスが無効です。出力端子のインデックスは 1 から {1,number,integer} の範囲でなければなりません</entry>
    <entry key="RTI_InvalidRTPIdx">''{0}'' の実行時のパラメーターのインデックスが無効です。実行時のパラメーターのインデックスは 1 から {1,number,integer} の範囲でなければなりません</entry>
    <entry key="RTI_INVALID_INSTANTIATE_DIRECTLY">ランタイム オブジェクトを直接インスタンス化することはできません。"get_param" を使用してください。</entry>
    <entry key="RTI_INVALID_INSTANTIATE_BLOCK_DATA">Simulink.BlockData オブジェクトを直接インスタンス化できません。</entry>
    <entry key="RTI_INVALID_COPY_BLOCK_DATA_VALUE">"Copy メソッドは BlockDataValues データ型向けに実装されていません。"</entry>
    <entry key="RTI_Listener_TIDs_ExecOnly">''{0}'' のイベント リスナー TID は、シミュレーション実行中にのみアクセス可能です</entry>
    <entry key="RTI_Listener_Const_SampleTime">一定しないサンプル時間をもつブロックにのみ実行イベント リスナーを追加できます。ブロック ''{0}'' には一定したサンプル時間があります。</entry>
    <entry key="RTI_MATLAB_BLK_ONLY">プロパティ ''{0}'' は MATLAB S-Function ブロックにのみ設定可能です</entry>
    <entry key="RTI_MATLAB_BLK_OR_EVENT_CALLBACK_ONLY">プロパティ ''{0}'' は MATLAB S-Function ブロックに対して、またはイベント リスナーからのみ設定可能です</entry>
    <entry key="RTI_NULL_DATA">''{0}'' のデータにアクセスできません。このエラーから推定される原因は、シミュレーション実行中にのみ利用可能なデータにアクセスしていることです</entry>
    <entry key="RTI_OutputPortInvalidComplexity">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に指定された信号の複素数が無効です。信号の実数/複素数は、''Real''、''Complex'' または ''Inherited'' でなければなりません</entry>
    <entry key="RTI_OutputPortInvalidDatatype">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に指定されたデータ型が無効です。出力端子のデータ型 ID は、以下のいずれかでなければなりません: ''継承'' は -1、''double'' は 0、''single'' は 1、''int8'' は 2、''uint8'' は 3、''int16'' は 4、''uint16'' は 5、''int32'' は 6、''uint32'' は 7、''boolean'' または固定小数点データ型は 8</entry>
    <entry key="RTI_OutputPortInvalidDims">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に指定された次元が無効です。次元は正の整数 (あるいは継承は -1) の配列でなければなりません。</entry>
    <entry key="RTI_OutputPortInvalidDimsMode">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に指定された次元モードが無効です。サンプル モードは、''Fixed''、''Variable''、''Inherited'' のいずれかでなければなりません</entry>
    <entry key="RTI_OutputPortInvalidFrameness">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に指定されたサンプリング モードが無効です。サンプリング モードは ''Sample''、''Frame''、''Inherited'' のいずれかでなければなりません</entry>
    <entry key="RTI_OutputPortInvalidOverwriteDatatype">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; のデータ型 ID を {2,number,integer} から {3,number,integer} に変更できません</entry>
    <entry key="RTI_OutputPortInvalidReuseSetting">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に指定された再利用性が無効です。出力端子の再利用性は、''NotReusableAndGlobal'' または ''ReusableAndLocal'' でなければなりません</entry>
    <entry key="RTI_OutputPortOverwriteComplexity">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の信号の複素数を ''{2}'' から ''{3}'' に変更できません</entry>
    <entry key="RTI_OutputPortOverwriteDims">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の次元を {2} から {3} に変更できません</entry>
    <entry key="RTI_OutputPortOverwriteDimsMode">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の次元モードを ''{2}'' から ''{3}'' に変更できません</entry>
    <entry key="RTI_OutputPortOverwriteFrameness">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; のサンプリング モードを ''{2}'' から ''{3}'' に変更できません</entry>
    <entry key="RTI_PROPERTY_READONLY">プロパティ ''{0}'' は読み取り専用であるため、設定できません。</entry>
    <entry key="RTI_REDUCED_BLOCK">''{0}'' に対する実行時のオブジェクトを作成できません。このブロックは、ブロック削減の最適化によって削除されています</entry>
    <entry key="RTI_RTPInvalidComplexity">''{1}'' の実行時のパラメーター {0,number,integer} に指定されたデータの complexity が無効です。データの complexity は、''Real'' か ''Complex'' でなければなりません</entry>
    <entry key="RTI_RTPInvalidDatatype">''{1}'' の実行時のパラメーター {0,number,integer} に指定されたデータ型が無効です。データ型 ID は、以下のいずれかでなければなりません: ''double'' は 0、''single'' は 1、''int8'' は 2、''uint8'' は 3、''int16'' は 4、''uint16'' は 5、''int32'' は 6、''uint32'' は 7、''boolean'' は 8</entry>
    <entry key="RTI_RTPInvalidDims">''{1}'' の実行時のパラメーター {0,number,integer} に指定された次元が無効です。次元は正の整数の配列でなければなりません。</entry>
    <entry key="RTI_SetEvaledDlgParamsNotPerm">''{1}'' のダイアログ パラメーター {0,number,integer} に対するデータが読み取り専用で設定できません。</entry>
    <entry key="RTI_SetInputVarDimsNotPerm">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に対する可変次元は読み取り専用であるため、設定できません</entry>
    <entry key="RTI_SparseMatrixNotSupported">''{0}'' 内で使われているブロックの実行時のインターフェイスは、MATLAB のスパース行列をサポートしていません</entry>
    <entry key="RTI_WRITE_TO_BUS_NOT_SUPPORTED">データをバス オブジェクトに書き込むために ''{0}'' の実行時のオブジェクトを使用できません</entry>
    <entry key="RTWBoolsToBitsWithStructAlignment">明示的に構造体の割り当てを指定するターゲットが使われる場合、boolean をビットフィールドにパッキングしてはなりません。[コンフィギュレーション パラメーター] ダイアログ ボックスでオプション [boolean データをビットフィールドにパッキング] をオフにしてください。</entry>
    <entry key="RTWCSCStructureFieldIdConflict">カスタム ストレージ クラスの構造体フィールド ''{0}'' が、プログラミングの予約識別子と競合しています。</entry>
    <entry key="RTWCSCStructureMacroIdConflict">カスタム ストレージ クラスの構造体フィールド ''{0}'' が、別のカスタム ストレージ クラス マクロの指定と競合しています</entry>
    <entry key="RTWBusElementNameReservedIdConflictCSC">バス オブジェクト ''{0}'' には、カスタム ストレージ マクロの指定されたパラメーターと競合する ''{1}'' という名前の要素があるため、これを使用してコードを生成できません</entry>
    <entry key="RTWDataTypeNameReservedIdConflictCSC">ユーザー定義のデータ型 ''{0}'' は、カスタム ストレージ マクロの指定された ''{1}'' パラメーターと競合するため、これを使用してコードを生成できません</entry>
    <entry key="RTWCSCStructFieldIdConflictEnum">ユーザー定義のデータ型 ''{0}'' を使用したコード生成はできません。このデータ型にはカスタム ストレージ構造体の仕様と競合する要素 ''{1}'' があるためです。</entry>
    <entry key="RTWBusElementNameReservedIdConflict">Unable to generate code using bus object ''{0}'' because it has an element named ''{1}'' which conflicts with a programming language reserved identifier.</entry>
    <entry key="RTWBusElementNameAliasConflict">バス オブジェクト ''{0}'' には、エイリアス タイプの名前と競合する ''{1}'' という名前の要素があるため、これを使用してコードを生成できません。</entry>
    <entry key="RTWCGAutosarEmptyConfigurationError">AUTOSAR モデル ''{0}'' が AUTOSAR ソフトウェア コンポーネントにマッピングされていません。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion" btn="open" id="launchWizard" retvalue="false"&gt; &lt;cmd&gt;autosar.ui.app.quickstart.WizardManager.wizard(''{0}'');&lt;/cmd&gt; &lt;txt&gt;"AUTOSAR コンポーネント クイック スタート" を使用してモデルを AUTOSAR ソフトウェア コンポーネントにマッピングする。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="RTWCGAutosarEmptySSConfigurationError">サブシステム ''{0}'' に対するコードを生成するときに AUTOSAR ターゲットを使おうとしていますが、サブシステムに対して作成された適切な AUTOSAR インターフェイスがありません。サブシステムに AUTOSAR インターフェイスを指定するには、サブシステムをモデルに変換してモデルを設定します。</entry>
    <entry key="RTWCGAutosarValidateError">AUTOSAR 構成の検証中にエラーが発生: {0}</entry>
    <entry key="RTWCGAutosarConditionalImplicitWrite">出力端子ブロック ''{0}'' の現在のコンフィギュレーションにより、条件付きの暗黙的な書き込みが行われますが、これは未定義の動作が含まれています。そのデータ アクセス·モードを ExplicitSend に変更する、またはそのサンプル時間を変更してモデルの基本サンプル時間と一致させます。</entry>
    <entry key="RTWCGAutosarMergedIRVConditionalWrite">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; が、Merge ブロック ''{2}'' に条件付き書き込みを行う可能性があります。これは、ランナブルとしてエクスポートされる複数の関数呼び出しサブシステムによって書き込まれます。このモデル化のパターンは AUTOSAR ターゲットではサポートされていません。ただし、必ず一貫した動作になるように、&lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;[指定不足の初期化の検出]&lt;/sldiag&gt; を [簡易] に設定している場合は例外です。結果として、生成されたコードの動作がシミュレーションと矛盾することがあります。モデルのサイズが大きいか複雑な場合は、モデル アドバイザー [Outport と Merge ブロックに対する初期化パラメーターの整合性をチェック] 機能をこのタスクに利用してください。この条件の報告を制御するには、&lt;sldiag objui="configset" objparam="ModelReferenceIOMsg"&gt;[無効なルートの Inport/Outport ブロックの接続]&lt;/sldiag&gt; を使用してください。</entry>
    <entry key="RTWCGAutosarInvalidIRVSSLoopback">サブシステム ''{0}'' の端子 ''{1}'' における信号出力は AUTOSAR IRV です。IRV 信号をサブシステム ''{0}'' にフィードバックすると、生成コードで初期化されていない変数へのアクセスが発生する可能性があります。</entry>
    <entry key="RTWCGAutosarNvmRwInvReadBlockArgSpec">Function Caller ブロック ''{0}'' は、ReadBlock または RestoreBlockDefaults の AUTOSAR 不揮発性メモリ サービス オペレーションにマッピングされています。これらのオペレーションには 1 つの入力引数のみ必要です。出力を Data Store Write ブロックに接続し、このデータ ストア メモリ端子を入力引数にマッピングしてオペレーションに直接渡されるようにします。</entry>
    <entry key="RTWCGAutosarNvmRwInvWriteBlockArgSpec">Function Caller ブロック ''{0}'' が WriteBlock の AUTOSAR 不揮発性メモリ サービス オペレーションにマッピングされています。このオペレーションには 1 つの入力引数のみ必要です。入力を直接 Data Store Read ブロックに接続し、このデータ ストア メモリ端子を入力引数にマッピングしてオペレーションに直接渡されるようにします。</entry>
    <entry key="RTWCGAutosarNvmRwInvReadBlockInoutArg">Function Caller ブロック ''{0}'' は、ReadBlock または RestoreBlockDefaults の AUTOSAR 不揮発性メモリ サービス オペレーションにマッピングされています。&lt;sldiag objui="outport" objparam="{1}" objname="{0}"&gt;出力端子 {1}&lt;/sldiag&gt; は入出力引数として指定できません。</entry>
    <entry key="RTWCGAutosarNvmRwInvWriteBlockInoutArg">Function Caller ブロック ''{0}'' が WriteBlock の AUTOSAR 不揮発性メモリ サービス オペレーションにマッピングされています。データ ストア メモリの入力端子は入出力引数として指定できません。</entry>
    <entry key="RTWCGAutosarNvmRwUnsupportedWriteBlockSrc">Function Caller ブロック ''{0}'' が WriteBlock の AUTOSAR 不揮発性メモリ サービス オペレーションにマッピングされています。入力を直接 Data Store Read ブロックに接続して、データ ストア メモリをオペレーションに直接渡してください。同じタイム ステップで実行し、要素の割り当ての指定をすべて削除するように Data Store Read ブロックを構成してください。Function Caller ブロックの実行順序が Data Store Read ブロックの直後であることを確認します。</entry>
    <entry key="RTWCGAutosarNvmRwUnsupportedReadBlockDst">Function Caller ブロック ''{0}'' は、ReadBlock または RestoreBlockDefaults の AUTOSAR 不揮発性メモリ サービス オペレーションにマッピングされています。データ ストア メモリをオペレーションに直接渡すために、Data Store Write ブロックに接続できるのは、&lt;sldiag objui="outport" objparam="{1}" objname="{0}"&gt;出力端子 {1}&lt;/sldiag&gt; だけです。同じタイム ステップで実行し、要素の割り当ての指定をすべて削除するように Data Store Write ブロックを構成してください。Data Store Write ブロックの実行順序が Function Caller ブロックの直後であることを確認します。</entry>
    <entry key="RTWCGAutosarNvmRwUnsupportedReadBlockTestpointSignal">Function Caller ブロック ''{0}'' は、ReadBlock または RestoreBlockDefaults の AUTOSAR 不揮発性メモリ サービス オペレーションにマッピングされています。&lt;sldiag objui="outport" objparam="{1}" objname="{0}"&gt;出力端子 {1}&lt;/sldiag&gt; に接続された信号は、生成されたコード内においてテスト ポイントとして指定できません。AUTOSAR ターゲット用に生成されたコード内では、データ ストア メモリがオペレーションに直接渡されるためです。</entry>
    <entry key="RTWCGAutosarNvmRwUnsupportedReadBlockNonvirtualSignal">Function Caller ブロック ''{0}'' は、ReadBlock または RestoreBlockDefaults の AUTOSAR 不揮発性メモリ サービス オペレーションにマッピングされています。&lt;sldiag objui="outport" objparam="{1}" objname="{0}"&gt;出力端子 {1}&lt;/sldiag&gt; に接続された信号に信号名を指定することはできません。AUTOSAR ターゲット用に生成されたコード内では、データ ストア メモリがオペレーションに直接渡されるためです。</entry>
    <entry key="RTWCGAutosarNvmRwValidationFailure">Function Caller ブロック ''{0}'' が WriteBlock、ReadBlock または RestoreBlockDefaults の AUTOSAR 不揮発性メモリ サービス オペレーションにマッピングされています。コード ジェネレーターはデータ ストア メモリをオペレーションに直接渡すことができません。</entry>
    <entry key="RTWCGAutosarNvmRwUnaddressableDstore">Function Caller ブロック ''{0}'' が WriteBlock、ReadBlock または RestoreBlockDefaults の AUTOSAR 不揮発性メモリ サービス オペレーションにマッピングされています。データ ストア メモリの信号をオペレーションに直接渡すには、アドレス指定可能でなければなりません。たとえば、AUTOSAR.Signal オブジェクトを作成することで、データ ストア メモリを指定できます。</entry>
    <entry key="RTWCGCPPClassGenStr">C++ クラス インターフェイス</entry>
    <entry key="RTWCGCPPClassGenValidateError">モデル ''{0}'' の C++ クラス インターフェイス仕様を検証する際にエラーが発生しました: {1}</entry>
    <entry key="RTWCGCPPClassMdlRefContStates">[コード インターフェイスのパッケージ化] オプションの [C++ クラス] は、モデル ''{0}'' に対して選択できません。連続時間を使用するブロックがモデルに含まれているためです。これは、モデル リファレンス ターゲットのコードを生成する場合はサポートされません</entry>
    <entry key="RTWCGCPPClassMdlRefVoidStyleNotSupported">参照モデルとして使用されるモデル ''{0}'' には、[I/O 引数の step メソッド] スタイルの C++ クラス インターフェイスのみがサポートされます。</entry>
    <entry key="RTWCGCPPClassSetNotAllowed">C++ クラス インターフェイスのカスタマイズは ERT ベース以外のターゲットでは許可されていません。</entry>
    <entry key="RTWCGCPPClassIOMessagePort">モデル ''{0}'' がメッセージを送信または受信するように構成されている場合、[I/O 引数 step メソッド] タイプの [関数の仕様] はサポートされていません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion" btn="apply"&gt; &lt;cmd&gt;set_param(''{0}'', ''RTWCPPFcnClass'', RTW.ModelCPPDefaultClass); get_param(''{0}'',''RTWCPPFcnClass'').setStepMethodName(''Step''); get_param(''{0}'',''RTWCPPFcnClass'').setClassName(''{0}ModelClass'');&lt;/cmd&gt; &lt;txt&gt;[関数の仕様] の設定を [既定の step メソッド] に変更する (参照元または参照先のモデルに影響が及ぶ場合あり)。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="RTWCGCPPMdlRefInstanceVariables">C++ クラス生成の I/O 引数の step メソッドに対してモデル リファレンスのインスタンス変数を読み取り中にエラーが発生しました</entry>
    <entry key="RTWCGEmptyCPPEncapConfigurationError">Model ''{0}'' has code interface packaging set to ''C++ class'', but a C++ class interface configuration is not specified for the model.
    
             &lt;actions exclusiveFixIts="yes"&gt;
             &lt;action type="suggestion"&gt;
             &lt;cmd&gt;simulinkcoder.internal.slfpc.FunctionControlDialogManager.openEntryFcnDialog(''{0}'')&lt;/cmd&gt;
             &lt;txt&gt;Specify a C++ class interface&lt;/txt&gt;
             &lt;/action&gt;
             &lt;/actions&gt;
    </entry>
    <entry key="RTWCGFcnProtoCtlMdlRefOutUpdCombined">モデル関数プロトタイプのコントロールは、モデル リファレンス ターゲットに対するコードの生成中にその出力と更新関数を結合しないため、''{0}'' に対して使用できません &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion" id="FPCMdlRefOutUpdCombined"&gt; &lt;cmd&gt;simulinkcoder.internal.slfpc.FunctionControlDialogManager.openEntryFcnDialog(''{0}'')&lt;/cmd&gt; &lt;txt&gt;前のエラーを修正するか、[ステップ関数プロトタイプの引数を設定] チェック ボックスをオフにする&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="RTWCGFcnProtoCtlMdlRefVirtualBusRootIO">モデル関数プロトタイプのコントロールは、ルートの I/O 端子 ''{1}'' にバーチャル バスをもつ参照モデルであるため、''{0}'' に対して使用できません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion" id="FPCMdlRefVirtualBusRootIO"&gt; &lt;cmd&gt;simulinkcoder.internal.slfpc.FunctionControlDialogManager.openEntryFcnDialog(''{0}'')&lt;/cmd&gt; &lt;txt&gt;前のエラーを修正するか、[ステップ関数プロトタイプの引数を設定] チェック ボックスをオフにする&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;Simulink.internal.OpenBlockParamsDialog(''{1}'',''BusOutputAsStruct'')&lt;/cmd&gt; &lt;txt&gt;[非バーチャル バスとして出力] をオンにする&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
   </entry>
    <entry key="RTWCGFcnProtoCtlIOMessagePort">Model function prototype
    control cannot be used for ''{0}'' because it has
    a root I/O port that sends or receives messages.
    
             &lt;actions exclusiveFixIts="yes"&gt;
             &lt;action type="fixit" id="MessageIOFPC" retvalue="false"&gt;
             &lt;cmd&gt;simulinkcoder.internal.slfpc.FunctionControlDialogManager.openEntryFcnDialog(''{0}'', Simulink.CodeMapping.get(''{0}'', ''CoderDictionary'').OutputFunctionMappings(1), ''OutputFunctionMappings'')&lt;/cmd&gt;
             &lt;txt&gt;Fix preceding errors or clear checkbox for ''Configure arguments for Step function prototype''&lt;/txt&gt;
             &lt;/action&gt;
             &lt;/actions&gt;
    </entry>
    <entry key="RTWCGFcnProtoCtlMdlRefVirtualBusRootIOBEP">モデル関数プロトタイプのコントロールは、ルートの I/O 端子 ''{1}'' にバーチャル バスをもつ参照モデルであるため、''{0}'' に対して使用できません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion" id="FPCMdlRefVirtualBusRootIOBEP"&gt; &lt;cmd&gt;simulinkcoder.internal.slfpc.FunctionControlDialogManager.openEntryFcnDialog(''{0}'')&lt;/cmd&gt; &lt;txt&gt;前のエラーを修正するか、[ステップ関数プロトタイプの引数を設定] チェック ボックスをオフにする&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
   </entry>
    <entry key="RTWCGCPPClassMdlRefVirtualBusRootIO">Configuration of referenced
    model ''{0}'' does not support using a virtual bus at root I/O port ''{1}''.
    &lt;actions exclusiveFixIts="yes"&gt;
    &lt;action type="suggestion"&gt;
    &lt;cmd&gt;Simulink.internal.OpenBlockParamsDialog(''{1}'',''BusOutputAsStruct'')&lt;/cmd&gt;
    &lt;txt&gt;Select ''Output as nonvirtual bus''&lt;/txt&gt;
    &lt;/action&gt;
    &lt;action type="suggestion"&gt;
    &lt;cmd&gt;configset.internal.open(''{0}'',''CodeInterfacePackaging'')&lt;/cmd&gt;
    &lt;txt&gt;Change the setting of ''Code interface packaging'' (might impact referenced or referencing models)&lt;/txt&gt;
    &lt;/action&gt;
    &lt;action type="suggestion"&gt;
    &lt;cmd&gt;simulinkcoder.internal.slfpc.FunctionControlDialogManager.openEntryFcnDialog(''{0}'')&lt;/cmd&gt;
    &lt;txt&gt;Change the setting of ''Function specification'' to ''Default step method''.&lt;/txt&gt;
    &lt;/action&gt;
    &lt;/actions&gt;
    
    </entry>
    <entry key="RTWCGFcnProtoCtlValidateError">''{0}'' のモデル関数プロトタイプの検証中にエラーが発生しました: {1} &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion" id="FPCValidateError"&gt; &lt;cmd&gt;simulinkcoder.internal.slfpc.FunctionControlDialogManager.openEntryFcnDialog(''{0}'')&lt;/cmd&gt; &lt;txt&gt;前のエラーを修正するか、[ステップ関数プロトタイプの引数を設定] チェック ボックスをオフにする&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="RTWCGArchSpecValidateError">モデル ''{0}'' の {2} を検証中にエラーが発生しました。参照モデル ''{1}'' が C-API インターフェイスを生成しており、このモデルのルートの Inport に接続されている信号のいずれかがテスト ポイント属性を設定していますが、このコンフィギュレーションの組み合わせはこの機能ではサポートされません。この組み合わせを使用しないようにエラーを修正するか、テスト ポイントが設定されている信号の接続先になっている参照モデルのルートの Inport に、Signal Conversion を挿入することを検討してください。</entry>
    <entry key="RTWCGInternalError">コード生成中にエラーが発生しました。 {0}</entry>
    <entry key="RTWCGInvalidDTReasonUnknownInternal">ブロック ''{0}'' のデータ型 ''{1}'' はコード生成でサポートされていません。</entry>
    <entry key="RTWCGInvalidDTSize">ブロック ''{0}'' は {2,number,integer} ビットを必要とするデータ型 ''{1}'' を使っていますが、コード生成に対するブロックでサポートされる最大値は {3,number,integer} であるため、このモデルに対してコードを生成できません。</entry>
    <entry key="RTWCGInvalidDTSize2Internal">ブロック ''{0}'' は {2,number,integer} ビットを必要とするデータ型 ''{1}'' を使っていますが、コード生成に対してサポートされる最大値は {3,number,integer} であるため、このモデルに対してコードを生成できません。入力信号、出力信号、実行時パラメーター、dwork 状態に対して、サポートされないデータ型は、通常、コード生成過程の初期にエラーになります。このエラーは後の段階で発生しました。そのため、サポートされないデータ型がローカル変数で内部的にブロックに使われている可能性があります。ローカル変数は中間の計算結果を保持する可能性があります。中間の計算を保持するために選択したデータ型とスケーリングは、モデルのテスト ハードウェアに依存する可能性があります。テスト ハードウェアは 32 より大きい long あたりのビット数を指定する可能性があります。[コンフィギュレーション パラメーター] ダイアログ ボックスで ''テスト ハードウェア'' を検索し、テスト ハードウェアを設定してください。</entry>
    <entry key="RTWCGInvalidTargetLongSize">コードを生成できません。[テスト ハードウェアの long あたりのビット数] ({0,number,integer}) は 32 以上でなければなりません。</entry>
    <entry key="RTWCGModelReferenceStackSizeConflict">''{2}'' によって参照されるモデル ''{1}'' の推定必要スタック サイズ {0,number,integer} バイトが、''{4}'' の [コンフィギュレーション パラメーター] ダイアログ ボックスの [最大スタック サイズ] パラメーターで指定した最大スタック サイズ {3,number,integer} バイトより大きくなっています。この矛盾を解決するには、''{5}'' の [最大スタック サイズ] パラメーターを {6,number,integer} バイト以上に増やして変更するか、''{7}'' を選択します。他の解決策として、モデル ''{9}'' の [コンフィギュレーション パラメーター] ダイアログ ボックスで [最大スタック サイズ] パラメーターを {8,number,integer} バイト以下に指定することもできます。</entry>
    <entry key="RTWCGTargetStackSizeConflict">モデル ''{0}'' で [最大スタック サイズ (バイト)] が {1,number,integer} バイトに指定されています。しかし、現在のシステム ターゲットが必要としている最大スタック サイズは {2,number,integer} バイト以下です。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''MaxStackSize'')&lt;/cmd&gt; &lt;txt&gt;[最大スタック サイズ (バイト)] を {3,number,integer} 以下か文字列 ''{4}'' に変更する&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;現在のシステム ターゲットの最大スタック サイズの値を大きくする (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="SLCGStackSizeAndGlobalDataAccessConflict">[最大スタック サイズ] が '0' に設定されているため、[グローバル データ アクセスの最適化] を [グローバル データ アクセスの最小化] に設定することはサポートされません。</entry>
    <entry key="RTWCGMissingCSCRegistration">ストレージ クラス ''{0}'' は Embedded Coder ディクショナリで定義されていません。ディクショナリ内でストレージ クラスを定義するか、ディクショナリで使用されているパッケージ内でコード定義を変更した場合は、コマンド refreshPackage(coder.dictionary.open(''{1}'')) を使用してパッケージを再読み込みしてください。</entry>
    <entry key="RTWCGReusableCSCMultipleEndpoints">''{1}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{1}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; にある再利用可能な CSC ''{0}'' が一意のエンドポイントではありません。エンドポイントは、他に下流のない、再利用可能な CSC の 1 つの用法です。値が適切に定義されていないため、ランタイム環境でこの変数を読み取らないようにしてください。</entry>
    <entry key="RTWCGReusableCSCNotRenamable">再利用可能なバッファーの仕様の問題: ''{0}'' の出力端子は再利用したり名前を変更したりできません。</entry>
    <entry key="RTWCGReusableCSCNotInTheSameNonVirtualSS">再利用可能なバッファー指定に問題があります: ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の再利用可能な CSC は、他の再利用可能な CSC と同じ非バーチャル サブシステム上にありません。</entry>
    <entry key="RTWCGReusableCSCNotOnAContinuousPath">再利用可能なバッファー指定に問題があります: ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の再利用可能な CSC は、他の再利用可能な CSC と連続したパス上にありません。またはモデルのコンパイルによって新しいブロックが導入されたことにより、再利用可能な CSC 指定が不連続になります。</entry>
    <entry key="RTWCGReusableCSCMultipleOutputs">ブロック ''{3}'' の出力端子 {1,number,integer} と {2,number,integer} で、同じ再利用可能な CSC ''{0}'' が指定されています。同じブロックの 2 つ以上の出力で同じ再利用可能な CSC を指定することはできません。</entry>
    <entry key="RTWCGReusableCSCMultipleInputs">ブロック ''{3}'' の入力端子 {1,number,integer} と {2,number,integer} で、同じ再利用可能な CSC ''{0}'' が指定されています。同じブロックの 2 つ以上の入力で同じ再利用可能な CSC を指定することはできません。</entry>
    <entry key="RTWCGReusableCSCHasNoBuffer">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に指定された再利用可能な CSC が無効です。これは、生成されたコード内にこの信号に対応する変数がないためです。この原因として、サブシステムの Output Port ブロックが接続されていない可能性があります。</entry>
    <entry key="RTWCGReusableCSCOutputCannotOverwriteInput">再利用可能なバッファー指定に問題があります: ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; は、''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; を上書きできません。</entry>
    <entry key="RTWCGReusableCSCDataTypesMismatch">再利用可能なバッファー指定に問題があります: ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に接続されている信号のデータ型/形状が、''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; に接続されている信号のデータ型/形状と一致しません。</entry>
    <entry key="RTWCGReusableCSCMappingsCodePropertiesMismatch">''{4}'' の再利用可能なバッファー指定に問題があります。''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に接続されている信号のコード パースペクティブのコード生成プロパティが、''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; に接続されている信号と一致しません。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;信号に同じプロパティ ''DataScope''、''HeaderFile''、''DefinitionFile'' および ''Owner'' を指定する&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="RCSCRenamedMsg"&gt;[再利用されないカスタム ストレージ クラスを検出]&lt;/sldiag&gt; を [なし] に設定することにより、このメッセージを非表示にする&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="RTWCGReusableFPCDataTypesMismatch">Function prototype control problem: the data type/shape of the non-virtual signal connected to the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' does not match with the data type/shape of the non-virtual signal connected to the &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;input port {2,number,integer}&lt;/sldiag&gt; of ''{3}''.</entry>
    <entry key="RTWCGReusableCSCRootMustBeSameSize">再利用可能なカスタム ストレージ クラス ''{0}'' のある信号線は、ルートの Inport ブロック ''{1}'' と、''{2}'' 端子 ''{3,number,integer}'' に接続するルートの Outport ブロックに接続します。ルート端子のサイズが異なります。</entry>
    <entry key="RTWCGReusableCSCVariantMismatch">再利用可能なストレージ クラスの指定が同じすべての信号は、同じバリアント条件をもたなければなりません。''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に接続される信号は、''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; に接続される信号と同じバリアント条件をもっていません。</entry>
    <entry key="RTWCGReusableModelReferenceTarget">再利用可能な CSC 指定に問題があります: 再利用可能な CSC 指定は、Model ブロック内では使用できません。{1} の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; でそのようなインスタンスが 1 つ見つかりました。</entry>
    <entry key="RTWCGReusableModelReferenceInputNotOutput">&lt;sldiag objui="inport" objparam="{0}" objname="{1}"&gt;Inport {0}&lt;/sldiag&gt; およびブロック ''{1}'' の内部で再利用可能な CSC が指定されています。出力端子にも指定がある場合を除き、モデル参照ではこれは許可されていません。</entry>
    <entry key="RTWCGReusableCSCDifferentSampleTimesInMultiTaskingMode">再利用可能なバッファー指定に問題があります: ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に接続されている信号と ''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; に接続されている信号が、マルチタスクのソルバー モードで異なるレートをもっています。これはサポートされていません。</entry>
    <entry key="RTWCGReusableFPCDifferentSampleTimesInMultiTaskingMode">関数プロトタイプの制御の問題: ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に接続している信号と、''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; に接続している信号では、マルチタスク ソルバー モードのレートが異なります。これはサポートされていません。</entry>
    <entry key="RTWCGReusableCSCDifferentSampleTimes">再利用可能なバッファー指定に問題があります: ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に接続されている信号と ''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; に接続されている信号が、異なるレートをもっています。これはサポートされていません。</entry>
    <entry key="RTWCGReusableFPCDifferentSampleTimes">関数プロトタイプの制御の問題: ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に接続している信号と、''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; に接続している信号では、レートが異なります。これはサポートされていません。</entry>
    <entry key="RTWCGReusableCSCRootIOCannotReuseState">再利用可能な CSC 指定に問題があります。Unit Delay ブロック ''{0}'' の状態が、ルート IO を再利用できません。</entry>
    <entry key="RTWCGReusableCSCStateProblem">現在のモデル設定では、ブロック ''{0}'' の状態を再利用可能なカスタム ストレージ クラスとして指定できません。</entry>
    <entry key="RTWCGReusableCSCStateWithPackedBool">データ型が boolean で、&lt;sldiag objui="configset" objparam="BooleansAsBitfields"&gt;[Boolean データをビットフィールドにパッキング]&lt;/sldiag&gt; がオンに設定されている場合、ブロック ''{0}'' の状態は再利用可能なカスタム ストレージ クラスとして指定できません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''BooleansAsBitfields'',''off'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="BooleansAsBitfields"&gt;[Boolean データをビットフィールドにパッキング]&lt;/sldiag&gt; をオフに設定する&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;再利用可能な CSC 指定を ''{0}'' から削除する&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="RTWCGReusableCSCStateWithStateRW">ブロック ''{0}'' の状態が使用している再利用可能なカスタム ストレージ クラスは、State Read ブロックまたは State Write ブロックと互換性がありません。</entry>
    <entry key="RTWCGReusableCSCStateNotERT">ブロック ''{0}'' の状態が使用している再利用可能なカスタム ストレージ クラスでは、モデルのシステム ターゲット ファイルを ert.tlc に設定する必要があります。</entry>
    <entry key="RTWCGReusableCSCStateNeedLocalReuse">ブロック ''{0}'' の状態が、&lt;sldiag objui="configset" objparam="LocalBlockOutputs"&gt;[Local Block Outputs]&lt;/sldiag&gt; パラメーターおよび &lt;sldiag objui="configset" objparam="BufferReuse"&gt;[ローカル ブロック出力の再利用]&lt;/sldiag&gt; パラメーターをオンに設定する必要のある再利用可能なカスタム ストレージ クラス指定を使用しています。</entry>
    <entry key="RTWCGReusableCSCStateWithSLCI">&lt;sldiag objui="configset" objparam="AdvancedOptControl"&gt;[AdvancedOptControl]&lt;/sldiag&gt; パラメーターが有効になっている場合、ブロック ''{0}'' の状態は再利用可能なカスタム ストレージ クラスを使用できません。状態に関する再利用可能なストレージ クラスの指定に Simulink Code Inspector との互換性がないためです。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''AdvancedOptControl'','''')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="AdvancedOptControl"&gt;[AdvancedOptControl]&lt;/sldiag&gt; をオフに設定する&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="RTWCGReusableCSCStateMustUseItsIO">再利用可能な CSC 指定に問題があります。Unit Delay ブロック ''{0}'' の状態は、自身の IO バッファーのみとのマージがサポートされています。</entry>
    <entry key="RTWCGReusableCSCPairsCannotReuseStates">再利用可能な CSC 指定に問題があります: ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; はモデルの境界において他の信号を再利用しているため、Unit Delay ブロック ''{2}'' の状態を再利用できません。</entry>
    <entry key="RTWCGReusableCSCStateCannotUseBackPropedSig">再利用可能な CSC 指定に問題があります。Unit Delay ブロック ''{0}'' の状態が、モデルから伝播された再利用可能な CSC を使用できません。</entry>
    <entry key="RTWCGReusableCSCAtMultipleInputs">同じ再利用可能なカスタム ストレージ クラスの指定が複数のルート入力端子にあります: ''{0}'' および ''{1}''。これは許可されません。</entry>
    <entry key="RTWCGReusableCSCAtMultipleOutputs">同じ再利用可能なカスタム ストレージ クラスの指定が複数のルート出力端子にあります: ''{1}'' の端子 {0,number,integer} に接続するルート出力端子と、''{3}'' の端子 {2,number,integer} に接続するルート出力端子。これは許可されません。</entry>
    <entry key="RTWCGReusableCSCAtMultipleOutputsOfABlock">再利用可能な CSC 指定に問題があります: 複数の出力 (''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; と ''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt;) で同じ指定が検出されました。これは許可されません。</entry>
    <entry key="RTWCGReusableCSCAtMultipleInputsOfABlock">再利用可能な CSC 指定に問題があります: 複数の入力 (''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; と ''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt;) で同じ指定が検出されました。これは許可されません。</entry>
    <entry key="RTWCGReusableCSCSignalsNotAtModelBoundary">再利用可能な CSC 指定に問題があります。重複指定は、ルート IO 信号またはブロックの境界でのみサポートされているため、一方の再利用可能な CSC がルート IO 端子にある場合、もう一方もルート IO 端子になければなりません。この場合、''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に接続されている信号または ''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; に接続されている信号のいずれかまたはその両方が、仕様を満たしていません。</entry>
    <entry key="RTWCGReusableCSCSignalsCannotBeInClassicMode">再利用可能な CSC 指定に問題があります。重複指定は、簡易初期化モードのモデル IO 信号に対してのみサポートされています。この場合、''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に接続されている信号または ''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; に接続されている信号のいずれかまたはその両方は、モデル IO 端子にあります。</entry>
    <entry key="RTWCGReusableFPCMdlRefCannotRequireGlobalAccess">FPC IO 再利用の指定に問題があります。IO 端子 ''{0}'' は、モデル参照ビルドでグローバル アクセスを要求できません。</entry>
    <entry key="RTWCGReusableCSCSignalsLiferangeOverlapped">再利用可能な CSC 指定に問題があります: ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に接続されている信号と ''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; に接続されている信号を再利用できません。これらが有効な期間の範囲がオーバーラップしている可能性があります。</entry>
    <entry key="RTWCGReusableCSCBlockORenamed">ブロック ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; は、再利用可能な CSC ''{2}'' の他の用法では再利用できません。ほとんどの場合、生成されたコードにバッファーが追加される結果となります。</entry>
    <entry key="RTWCGReusableCSCDworkRenamed">状態 ''{0}'' は、再利用可能な CSC ''{1}'' の他の用法では再利用できません。ほとんどの場合、生成されたコードにバッファーが追加される結果となります。</entry>
    <entry key="RTWCGReusableCSCSignalsMustBeAtTheSameModel">Reusable CSC specification problem: the duplicate specification is supported only for model IO signals of the same model. In this case, the signal connected to the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is defined in a different model.</entry>
    <entry key="RTWCGReusableCSCSignalsInTwoModels">同じ再利用可能なカスタム ストレージ クラス信号 ''{0}'' が、Model ブロック ''{1}'' と ''{2}'' のルート端子に指定されています。これは、&lt;sldiag objui="configset" objparam="RCSCRenamedMsg"&gt;RCSCRenamedMsg&lt;/sldiag&gt; が [エラー] に設定されていない限りサポートされません。&lt;actions exclusiveFixIts="no"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="RCSCRenamedMsg"&gt;RCSCRenamedMsg&lt;/sldiag&gt; を [エラー] に設定する&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;ビルドの失敗を避けるには、すべての子モデルの RCSCRenamedMsg パラメーターを [エラー] に設定するか、&lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''], ''configuration_reference_dialog'')"&gt;コンフィギュレーション参照&lt;/a&gt;を使用する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="RTWCGReusableCSCSignalsInModelAndBlock">同じ再利用可能なカスタム ストレージ クラス信号 ''{0}'' が、Model ブロック ''{1}'' のルート端子に指定され、ブロック ''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; にも指定されています。これは、&lt;sldiag objui="configset" objparam="RCSCRenamedMsg"&gt;RCSCRenamedMsg&lt;/sldiag&gt; が [エラー] に設定されていない限りサポートされません。&lt;actions exclusiveFixIts="no"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="RCSCRenamedMsg"&gt;RCSCRenamedMsg&lt;/sldiag&gt; を [エラー] に設定する&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;ビルドの失敗を避けるには、すべての子モデルの RCSCRenamedMsg パラメーターを [エラー] に設定するか、&lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''], ''configuration_reference_dialog'')"&gt;コンフィギュレーション参照&lt;/a&gt;を使用する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="RTWCGReusableCSCSignalAtModelBoundMustHaveSingleUse">再利用可能な CSC 指定に問題があります: ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に接続された信号を、複数のブロックに接続できません。</entry>
    <entry key="RTWCGReusableCSCSignalsCannotBeInsideModelBlock">再利用可能な CSC 指定に問題があります: 再利用可能な CSC は参照モデル内では使用できません。この場合、''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に接続されている信号か、''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; に接続されている信号のどちらか、あるいはその両方が参照モデル内にあります。</entry>
    <entry key="RTWCGReusableCSCCannotBeUsedByMultipleStates">再利用可能な CSC 指定に問題があります。複数の単位遅延状態で同じ再利用可能な CSC は使用できません。今の場合、''{0}'' および ''{1}'' の両方で同じ再利用可能な CSC を使用しています。</entry>
    <entry key="RTWCGReusableCSCInterceptingOutputHiddenBuffer1">再利用可能な CSC 指定に問題があります: ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に内部バッファーがあります。</entry>
    <entry key="RTWCGReusableCSCInterceptingOutputHiddenBuffer">再利用可能な CSC 指定に問題があります。重複指定は、モデルまたはルート IO 信号に対してのみサポートされています。この場合、''{0}'' の入力端子に接続されている信号または ''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; に接続されている信号のいずれかまたはその両方は、モデルまたはルート IO 端子に存在しません。原因: ''{4}'' の&lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;出力端子 {3,number,integer}&lt;/sldiag&gt; に内部バッファーがあります。</entry>
    <entry key="RTWCGReusableCSCInterceptingInputHiddenBuffer">再利用可能な CSC 指定に問題があります。重複指定は、モデルまたはルート IO 信号に対してのみサポートされています。この場合、''{0}'' の入力端子に接続されている信号または ''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; に接続されている信号のいずれかまたはその両方は、モデルまたはルート IO 端子に存在しません。原因: 入力端子 ''{3}'' に内部バッファーがあります。</entry>
    <entry key="RTWCGReusableCSCInputMustBeDirectFeedThrough">再利用可能な CSC 指定に問題があります: ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; は、直達でなければなりません。</entry>
    <entry key="RTWCGReusableCSCOutputCannotBeInDifferentRate">再利用可能なバッファー指定に問題があります: ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; が、モデルの基本レートよりも遅いサンプルレートで実行しています。このため、出力端子が条件付きで割り当てられたままになる可能性があります。出力端子を再利用しないことを検討してください。</entry>
    <entry key="RTWCGReusableCSCOutputCannotBeConditional">再利用可能なバッファー指定に問題があります: ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; は、条件付きにはできなりません。</entry>
    <entry key="RTWCGReusableCSCMultipleSource">再利用可能なバッファー指定に問題があります。出力端子 ''{0}'' が単一のデータ ソースによって駆動されていません。</entry>
    <entry key="RTWCGReusableCSCInterceptingHiddenBufferAtModelBound">再利用可能な CSC 指定に問題があります。重複指定は、ルート IO 信号に対して、またはブロックの境界でのみサポートされています。原因: ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; または ''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; に内部バッファーがあります。</entry>
    <entry key="RTWCGReusableCSCEmbeddedSigObj">再利用可能なカスタム ストレージ クラスおよび同じ信号名を持つ複数の信号はすべて、単一の Simulink 信号オブジェクトに関連付けられなければなりません。{1} の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; は Simulink 信号オブジェクトに関連付けられていません。</entry>
    <entry key="RTWCGReusableCSCSimulinkFcnUnsupported">再利用可能な CSC の仕様は Simulink Function ブロック内では許可されていません。{1} の端子 {0,number,integer} でそのようなインスタンスが 1 つ見つかりました。</entry>
    <entry key="RTWCGReusableCSCDimVarUnsupportedAtBO">再利用可能な CSC の指定は、次元のバリアントをもつブロックでは利用できません。{1} の端子 {0,number,integer} でそのようなインスタンスが 1 つ見つかりました。</entry>
    <entry key="RTWCGReusableCSCDimVarUnsupportedAtDW">再利用可能な CSC の指定は、次元のバリアントをもつブロックでは利用できません。{0} の状態でそのようなインスタンスが 1 つ見つかりました。</entry>
    <entry key="RTWCGReusableCSCVarDimsUnsupported">{0} で再利用可能な CSC の指定に問題があります。再利用可能な CSC 指定は、モデルのいずれかの場所に可変次元タイプの信号が存在している場合は許可されません。</entry>
    <entry key="RTWCGReusableCSCExportFcnUnsupported">{0} で再利用可能な CSC の指定に問題があります。再利用可能な CSC 指定は、エクスポート関数をもつモデル内では許可されません。</entry>
    <entry key="RTWCGReusableCSCInportOverwrittenExportFcn">{0} 内の再利用可能な CSC 指定はルート Inport を上書きするため、モデル内でエクスポートされた関数を非同期実行すると誤った結果が得られる場合があります</entry>
    <entry key="RTWCGReusableCSCInDifferentTasksInExportFcn">{0} 内に再利用可能なバッファーの仕様の問題があります。''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; に接続されている信号と、''{4}'' の&lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;出力端子 {3,number,integer}&lt;/sldiag&gt; に接続されている信号は、別々のタスクで実行されます。これは、エクスポート関数をもつモデルではサポートされていません</entry>
    <entry key="RTWCGReusableCSCNotAtRootIOInExportFcn">{0} 内に再利用可能なバッファーの仕様の問題があります。再利用可能な CSC 指定は、''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; に接続されている信号には適用できません。エクスポート関数をもつモデルでは、再利用可能な CSC 指定は、ルート Inport、およびルート Outport を駆動する信号でのみサポートされます</entry>
    <entry key="RTWCGReusableCSCAtModelBlockIOInExportFcn">{0} 内に再利用可能なバッファーの仕様の問題があります。再利用可能な CSC 指定は、''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; に接続されている信号には適用できません。エクスポート関数をもつモデルでは、再利用可能な CSC 指定は、Model ブロックのルート端子における信号ではサポートされません</entry>
    <entry key="RTWCGReusableCSCNotAtTopLevelInExportFcn">{0} 内に再利用可能なバッファーの仕様の問題があります。再利用可能な CSC 指定は、''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; に接続されている信号には適用できません (非バーチャル サブシステム内にあるため)。エクスポート関数をもつモデルでは、再利用可能な CSC 指定は、最上位の信号でのみサポートされます</entry>
    <entry key="RTWCGReusableCSCFcnProtoControlUnsupported">{0} で再利用可能な CSC の指定に問題があります。再利用可能な CSC 指定は、関数プロトタイピングのコントロールが有効になっている場合は許可されません。</entry>
    <entry key="RTWCGReusableCSCEncapCPPIOUnsupported">{0} で再利用可能な CSC の指定に問題があります。再利用可能な CSC 指定は、C++ クラス インターフェイスを生成する場合は許可されません。</entry>
    <entry key="RTWCGReusableCSCMoreThanOnePair">{0} で再利用可能な CSC の指定に問題があります。再利用可能な CSC 指定は 1 組の入力信号と出力信号に対してのみ許可されます。</entry>
    <entry key="RTWCGReusableCSCRootIORenameWithVC">再利用可能なストレージ クラス指定が同じであるルート IO は、バリアント条件をもつ場合にすべて再利用しなければなりません。''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に接続されたルート入力信号、および ''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; に接続されたルート出力信号にはバリアント条件がありますが、再利用されていません</entry>
    <entry key="RTWCGReusableCSCRootIOAtIRT">''{1}'' の&lt;sldiag objui="outport" objparam="{0, number, integer}" objname="{1}"&gt;出力端子 {0, number, integer}&lt;/sldiag&gt; と ''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; では、再利用可能な CSC 指定は許可されていません。これは、''{1}''、''{3}''、あるいはその両方が Initialize Subsystem、Reinitialize Subsystem、Reset Subsystem、または Terminate Subsystem に接続されるルート IO 信号であるためです。</entry>
    <entry key="RTWCGReusableFPCSwitchedNonreusedToReused">サブシステムは再利用可能な IO 引数に FPC でアクセスするため、サブシステム ''{0}'' の [再利用できない関数] のパッケージ化設定を [再利用可能な関数] に変換しています</entry>
    <entry key="RTWCGReusableFPCCannotSwitchNonreusedToReusedO">関数のプロトタイピング制御 IO の再利用に問題があります: ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; にアクセスするサブシステムの設定を [再利用できない関数] にすることはできません</entry>
    <entry key="RTWCGReusableFPCCannotSwitchNonreusedToReusedI">関数のプロトタイピング制御 IO の再利用に問題があります: ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; にアクセスするサブシステムの設定を [再利用できない関数] にすることはできません</entry>
    <entry key="RTWCGReusableFPCCannotSpecifyPointerBusOnInport">Inport ブロック ''{0}'' はポインター バスに接続しているため、そのブロックに関数のプロトタイピング制御 IO の再利用を適用できません。</entry>
    <entry key="RTWCGReusableMatlabIOCannotReusePartialI">MATLAB Function ブロックのインプレース最適化の問題: ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; にフルのメモリ領域をもつバッファーがありません。</entry>
    <entry key="RTWCGReusableMatlabIOCannotReuseNoBufferI">MATLAB Function ブロックのインプレース最適化の問題: ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; にバッファーがありません。</entry>
    <entry key="RTWCGReusableMatlabIOCannotReuseNoBufferO">MATLAB Function ブロックのインプレース最適化の問題: ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; にバッファーがありません。</entry>
    <entry key="RTWCGConcurrentAccessOnlyDSM">信号 {0} の属性が無効です。同時アクセス属性はデータ ストア メモリ上の信号にのみ有効です。</entry>
    <entry key="RTWDataTypeNameReservedIdConflict">{1} の言語の予約識別子と競合するため、ユーザー定義のデータ型 ''{0}'' を使ってコードを生成できません。</entry>
    <entry key="RTWEmptyNamingRule">''{1}'' に指定された命名規則 ''{0}'' により、空の string となります。別の命名規則を指定するか、命名規則に必ず $M または $N が含まれているようにします。 </entry>
    <entry key="RTWExternNameClash">識別子 ''{0}'' の使用と競合している可能性があります: {1}</entry>
    <entry key="RTWExternNameClash2">識別子 ''{0}'' が競合している可能性があります。これは、複数の参照モデルに同様のモデル名と同様の命名規則がある場合に発生する可能性があります。この競合を解決するには、[コンフィギュレーション パラメーター] ダイアログの [識別子] ペインで [識別子の最大の長さ] パラメーターを大きくする、参照モデルごとに識別子の命名規則に異なるリテラル文字ベクトルを追加する、あるいは参照モデルごとに異なる名前を使用する、のいずれかを行うことができます</entry>
    <entry key="RTWExternNameClashWithNamespace">Potential conflicting usages of type ''{0}''; this name is already in use as a namespace. Please change the type name or namespace name.</entry>
    <entry key="RTWExternNameClashWithTypeName">Potential conflicting usages of identifier: ''{0}'' is a field name and a field type name in a C++ class or struct.</entry>
    <entry key="RTWIDInMakingSynthesizedExternNameClash">Potential conflicting usages of identifier ''{0}'': {1}.\n\nThe identifier ''{0}'' for ''{2}'' was generated because it is individually mapped to a non-Auto storage class and the Identifier field is empty.</entry>
    <entry key="RTWIDInMemSynthesizedExternNameClash">Potential conflicting usages of identifier ''{0}'': {1}.\n\nThe identifier ''{0}'' for ''{2}'' was generated because it is individually mapped to a non-Auto storage class and the Identifier field is empty.</entry>
    <entry key="RTWBothIDsSynthesizedExternNameClash">Potential conflicting usages of identifier ''{0}'': {1}.\n\nThe identifier ''{0}'' was generated for both ''{2}'' and ''{3}'' because both blocks are individually mapped to a non-Auto storage class and the Identifier field for each block is empty.</entry>
    <entry key="RTWIDSynthesizedIDIsEmpty">ブロック ''{0}'' が個別に非自動ストレージ クラスにマッピングされ、ブロックの [識別子] フィールドが空であったため、そのブロックの識別子が生成されました。ただし、有効な識別子のルールをすべて適用した後、生成された識別子は空になりました。ブロックの名前を 1 文字以上の有効な ANSI-C 文字に変更してください。</entry>
    <entry key="RTWIDSynthesizedIDForIOBufferIsEmpty">ブロック ''{0}'' の端子 ''{1}'' に関連付けられている信号が個別に非自動ストレージ クラスにマッピングされ、信号の [識別子] フィールドが空であったため、その信号の識別子が生成されました。ただし、有効な識別子のルールをすべて適用した後、生成された識別子は空になりました。ブロックの名前を 1 文字以上の有効な ANSI-C 文字に変更してください。</entry>
    <entry key="RTWIDSynthesizedStateIDIsEmpty">ブロック ''{0}'' の所有する状態が個別に非自動ストレージ クラスにマッピングされ、状態の [識別子] フィールドが空であったため、その状態の識別子が生成されました。ただし、有効な識別子のルールをすべて適用した後、生成された識別子は空になりました。状態を所有するブロック ''{0}'' の名前を、1 文字以上の有効な ANSI-C 文字に変更してください。</entry>
    <entry key="RTWRelaxNameForVariantsNotPossibleForCSC"> ストレージ クラスを組み込みストレージ クラスのいずれかに変更してみてください。</entry>
    <entry key="RTWReusedFcnNameClashIntraModel"> ''{0}'' と ''{1}'' の関数名は同じですが、チェックサムは異なっています。そのため、同じ関数名 ''{2}'' を 2 つのサブシステムに指定することはできません。\n このエラーを回避するために、以下を試してください:\n\n1. ライブラリの [Subsystem] &gt; [ブロック パラメーター] &gt; [コード生成] で、[関数名オプション] を [自動] に指定して、2 つの関数シグネチャの違いを見つけます。次に、「&lt;a href="matlab:helpview([docroot '/ecoder/ug/determine-why-subsystem-code-is-not-reused.html'])"&gt;サブシステム コードが再利用されない理由&lt;/a&gt;」で、チェックサムの違いを解決するためのヒントを参照します。\n\n2. ライブラリの [Subsystem] &gt; [ブロック パラメーター] &gt; [コード生成] &gt; [関数名] で関数名を ''{2}'' から ''{2}$C'' に変更してサブシステム チェックサムを関数名に追加し、関数名を一意にすることを検討してください。これによって、競合するインスタンスに別々の関数が生成され、コード再利用の最適化がオフになることに注意してください</entry>
    <entry key="RTWGenBadParamValue">rtwgen パラメーター ''{0}'' に対して指定された値が無効です</entry>
    <entry key="RTWGenBuildAdvisorWarning">Code generation advisor detects potential issues with model ''{0}''.
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="suggestion"&gt;
          &lt;cmd&gt;coder.advisor.internal.open&lt;/cmd&gt;
          &lt;txt&gt;Address issues in advisor window.&lt;/txt&gt;
        &lt;/action&gt;
        &lt;action type="suggestion"&gt;
          &lt;txt&gt;Turn off the advisor by selecting "Off" for &lt;sldiag objui="configset" objparam="CheckMdlBeforeBuild"&gt;Check model before generating code&lt;/sldiag&gt; on the Code Generation pane of the Configuration Parameters dialog.&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="RTWGenDupParam">重複する rtwgen パラメーター ''{0}'' が指定されました</entry>
    <entry key="RTWGenExportedIdClash1">同じ名前 ''{0}'' を使って 2 つの異なる関数呼び出しをエクスポートしようとしています。</entry>
    <entry key="RTWGenExportedIdClash2">エクスポートした関数名 ''{0}'' は、関数呼び出しのエクスポート先のシステム名と衝突します。</entry>
    <entry key="RTWGenExportedIdClash3">エクスポートした関数名 ''{0}'' は、サブシステム ''{1}'' の関数名と競合します。</entry>
    <entry key="RTWGenNoInliningSubsysOfSeparateData">エクスポートした関数名 ''{0}'' は、サブシステム ''{1}'' の関数名と競合します。名前の矛盾を回避するには、サブシステムのパラメーター ダイアログで [別々のデータをもつ関数] をオフにするか、関数名の 1 つを変更してください。</entry>
    <entry key="RTWGenNoInliningSubsysOfReusableFunction">エクスポートした関数名 ''{0}'' は、サブシステム ''{1}'' の関数名と競合します。名前の矛盾を回避するには、サブシステムのパラメーター ダイアログで [関数のパッケージ化] を [関数] に設定するか、関数名の 1 つを変更してください。</entry>
    <entry key="RTWGenMdlInputDataSpec">モデル ''{0}'' のルートの Inport に対して外部入力データが指定されています。これは、生成コード内で自動的には組み込まれません。そのターゲットは、非零信号をルートの Inport に接続するために、生成コードに対して固有の実行時インターフェイスを作成しなければなりません</entry>
    <entry key="RTWGenSyntaxErr">使用法:rtwgen(''BlockDiagram'')</entry>
    <entry key="RTWGenModelNameTooLong">名前が {1,number,integer} 文字を超えるため、モデル ''{0}'' のコードを生成できません</entry>
    <entry key="RTWGenUnknownParam">不明な rtwgen パラメーター ''{0}'' が指定されました</entry>
    <entry key="RTWIllegalUseOfReservedId">プログラム言語の予約された識別子であるため識別子 ''{0}'' を "{1}" に利用できません</entry>
    <entry key="RTWReservedIdentifier">その識別子 ''{0}'' は既に登録されています。</entry>
    <entry key="RTWIdentifierServiceCodeGenNotStarted">コード生成のコンテキストが利用できないため、識別子を利用できません。</entry>
    <entry key="RTWIdentifierServiceCodeGenStarted">コード生成を開始したため、識別子を予約できません。コード生成中に識別子を要求するには、requestIdentifier を使用してください。</entry>
    <entry key="RTWInvalidExportFunctionsCall">TLC オプション ''ExportFunctionsMode'' はモデルから生成するコードに対してサポートされていません。オプションはサブシステムからコードを生成するためにのみ適用します。</entry>
    <entry key="RTWNameUnableToLocateRootBlock">モデル {1} のルート ウィンドウ内の ''{0}'' の位置を特定できませんでした</entry>
    <entry key="RTWNameUnableToLocateSubsystemBlock">モデル {3} のサブシステム ''{1}'' (S{2,number,integer}) に ''{0}'' の位置を特定できませんでした</entry>
    <entry key="RTWNonReuseWideGroundCanInputGrnd">Subsystem ブロック ''{0}'' に対して関数を生成できません。このサブシステムは、非スカラーの出力信号をもつ Ground ブロック ''{1}'' で接続されています。Ground ブロックをすべての値がゼロの Constant ブロックに置き換えるか、あるいは Subsystem ブロックの [関数のパッケージ化] の設定を、[インライン]、または [関数インターフェイス] が [void_void] に設定された [再利用できない関数] に変更してください</entry>
    <entry key="RTWNonReuseWideGroundCanInputGrndCPP">C++ クラス インターフェイスを生成する際に必要な Subsystem ブロック ''{0}'' に対し、関数を生成できません。このサブシステムは、非スカラーの出力信号をもつ Ground ブロック ''{1}'' で接続されています。Ground ブロックをすべての値がゼロの Constant ブロックに置き換えるか、&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;[コード インターフェイスのパッケージ化]&lt;/sldiag&gt; を [C++ クラス] 以外の値に設定してください</entry>
    <entry key="RTWNonReuseWideGroundCanInputUnconn">Subsystem ブロック ''{0}'' に対して再利用可能な関数を生成できません。この Subsystem ブロックの入力端子の要素のいくつかは、実際の (すなわち非バーチャル) 信号に、直接的にも間接的にも接続されていません。Subsystem ブロックの接続されていない入力を 0 の値の Constant ブロックに接続するか、Subsystem ブロックの [関数のパッケージ化] の設定を Inline または Function に変更してください。</entry>
    <entry key="RTWNonReuseWideGroundCanInputUnconnCPP">C++ クラス インターフェイスを生成する際に必要な Subsystem ブロック ''{0}'' に対し、再利用可能な関数を生成できません。この Subsystem ブロックの入力端子の要素の一部は、直接的または間接的にも実際の (すなわち非バーチャル) 信号に接続されていません。Subsystem ブロックの接続されていない入力を値がゼロの Constant ブロックに接続するか、&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;[コード インターフェイスのパッケージ化]&lt;/sldiag&gt; を [C++ クラス] 以外の値に設定してください</entry>
    <entry key="RTWNotConfigForExtMode">現在モデル ''{0}'' のコード生成ターゲットは、エクスターナル モードに設定されていないか、またはサポートされていません。サポートされるターゲットでエクスターナル モードを有効にするには、&lt;sldiag objui="configset" objparam="ExtMode"&gt;[エクスターナル モード]&lt;/sldiag&gt; を選択してください</entry>
    <entry key="RTWSFcnComplexTunableParameterNotSupported">S-function パラメーター ''{0}'' は、その値が複素数であるため、調整可能にすることはできません</entry>
    <entry key="RTWSFcnNonBuiltInTunableParameterNotSupported">S-function パラメーター ''{0}'' は、そのデータ型が組み込み型ではないため、調整可能にすることはできません</entry>
    <entry key="RTWSFcnTransformedTunableParameterNotSupported">S-function パラメーター ''{0}'' は、その値、または、データ型が対応する外部パラメーターに対して変換されているため、調整可能にすることはできません</entry>
    <entry key="RTWSimRunning">現在 ''{0}'' はシミュレーションを実行しているため、このモデルに対してコードを生成できません。</entry>
    <entry key="RTWStateFlowBitSetsWithStructAlignment">明示的に構造体の割り当てを指定するターゲットが使われる場合、ビットセットを使用してはなりません。[コンフィギュレーション パラメーター] ダイアログ ボックスで [ステート構成を保存するためにビットセットを使用] と [boolean データを保存するためにビットセットを使用] オプションをオフにしてください。</entry>
    <entry key="RTWDataTypeElementNameReservedIdConflict">Unable to generate code using user-defined data type ''{0}'' because it has an element named ''{1}'' which conflicts with a programming language reserved identifier</entry>
    <entry key="RTWAnonStructElementNameReservedIdConflict">"Unable to generate code for ''{0}'' because it is used in a tunable expression and contains name ''{1}'' in struct that is a programming language reserved identifier."</entry>
    <entry key="RateTransBlkNotAllowedAtMergeBlk">Rate Transition ブロックは Merge ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; で利用できません。Rate Transition ブロックを挿入する前に Merge ブロックの入力端子で Signal Conversion を置くことを検討してください。</entry>
    <entry key="RateTransBlkDoesntSupportMoreThanTwoTasks" context="error">Rate Transition block ''{0}'' with ''Ensure data integrity'' set to ''on'' does not support multiple read and write transitions involving Union rate.

         &lt;actions exclusiveFixIts="yes"&gt;
         &lt;action type="fixit" id="DisableDataTransferProtection" retvalue="false"&gt;
         &lt;cmd&gt;set_param(''{0}'', ''Integrity'', ''off'');&lt;/cmd&gt;
         &lt;txt&gt;Disable the ''Ensure data integrity'' setting for Rate Transition block ''{0}''.&lt;/txt&gt;
         &lt;/action&gt;
         &lt;/actions&gt;

</entry>
    <entry key="VirtualBusRootOutportWithUnionTsUnsupported" context="error">バーチャル バス入力をもつルート Outport ブロック ''{0}'' は、union サンプル時間をサポートしません。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion" id="ReplaceOutportBlockWithBEP"&gt; &lt;txt&gt;ルート Outport ブロック ''{0}'' を Out Bus Element ブロックに置き換える。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;

</entry>
    <entry key="SuggestForMultiWordCSC">
  
           &lt;actions&gt; &lt;action type="suggestion" id="rtw_suggestion" retvalue="false"&gt; &lt;txt&gt; 代わりに、Embedded Coder ディクショナリで定義されているカスタム ストレージ クラスの使用を試みることができます。&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit" id="rtw_fixit" retvalue="false"&gt; &lt;cmd&gt;set_param(''{0}'',''ProdLongLongMode'',''on'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="ProdLongLongMode"&gt;[long long のサポート]&lt;/sldiag&gt; を [オン] に設定することにより、このメッセージを非表示にする。この変更は、モデルの階層構造内のすべてのモデルに対して行わなければなりません。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
  
</entry>
    <entry key="RTWCGInvalidCSCDataTypeForOutput">Output port {0,number,integer} of ''{1}'' has a legacy custom storage class as well as a data type having {2,number,integer} bits. This data type is multi-word because the largest integer type supported on the target has only {3,number,integer} bits. Custom storage classes are not supported in conjunction with multi-word data types.
    
      &lt;actions exclusiveFixIts="yes"&gt;
      &lt;action_catalog id="Simulink:Engine:SuggestForMultiWordCSC" enabled="true" ids="{5}"&gt;
          &lt;arg&gt;{4}&lt;/arg&gt;
      &lt;/action_catalog&gt;
      &lt;/actions&gt;
        
    </entry>
    <entry key="RTWCGInvalidCSCDataTypeForState">''{0}'' の状態には、レガシ カスタム ストレージ クラスと、{1,number,integer} ビットをもつマルチワードのデータ型があります。ターゲット上でサポートされている最大の整数型には {2,number,integer} ビットしかないため、このデータ型はマルチワードです。カスタム ストレージ クラスは、マルチワード データ型との併用ではサポートされません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action_catalog id="Simulink:Engine:SuggestForMultiWordCSC" enabled="true" ids="{4}"&gt; &lt;arg&gt;{3}&lt;/arg&gt; &lt;/action_catalog&gt; &lt;/actions&gt;

</entry>
    <entry key="RTWCGInvalidCSCDataTypeForParam">''{0}'' のパラメーターには、レガシ カスタム ストレージ クラスと、{1,number,integer} ビットをもつマルチワードのデータ型があります。ターゲット上でサポートされている最大の整数型には {2,number,integer} ビットしかないため、このデータ型はマルチワードです。カスタム ストレージ クラスは、マルチワード データ型との併用ではサポートされません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action_catalog id="Simulink:Engine:SuggestForMultiWordCSC" enabled="true" ids="{4}"&gt; &lt;arg&gt;{3}&lt;/arg&gt; &lt;/action_catalog&gt; &lt;/actions&gt;

</entry>
    <entry key="RTWCGInvalidCSCDataTypeForWSParam">The workspace parameter ''{0}'' has a legacy custom storage class as well as a multi-word data type having {1,number,integer} bits. This data type is multi-word because the largest integer type supported on the target has only {2,number,integer} bits. Custom storage classes are not supported in conjunction with multi-word data types.
    
      &lt;actions exclusiveFixIts="yes"&gt;
      &lt;action_catalog id="Simulink:Engine:SuggestForMultiWordCSC" enabled="true" ids="{4}"&gt;
          &lt;arg&gt;{3}&lt;/arg&gt;
      &lt;/action_catalog&gt;
      &lt;/actions&gt;
    
    </entry>
    <entry key="RTWCGInvalidCSCDataTypeForRootOutport">ルート出力端子 ''{0}'' には、レガシ カスタム ストレージ クラスと、{1,number,integer} ビットをもつマルチワードのデータ型があります。ターゲット上でサポートされている最大の整数型には {2,number,integer} ビットしかないため、このデータ型はマルチワードです。カスタム ストレージ クラスは、マルチワード データ型との併用ではサポートされません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action_catalog id="Simulink:Engine:SuggestForMultiWordCSC" enabled="true" ids="{4}"&gt; &lt;arg&gt;{3}&lt;/arg&gt; &lt;/action_catalog&gt; &lt;/actions&gt;

</entry>
    <entry key="RTWFuncScopeGlobal">''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; の信号 ''{0}'' には自動スコープが指定されていますが、ローカルに設定できませんでした。{3}</entry>
    <entry key="RTWAutoScopeDuplicatedGlobal">同じ名前 ''{0}'' をもつ複数の信号が、[Localizable] の [ストレージ クラス] をもつか、または [自動] の [データ スコープ] をもっていますが、これらのいずれかが強制的にグローバル変数に設定されます。これらは、''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt;、および ''{4}'' の&lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;出力端子 {3,number,integer}&lt;/sldiag&gt; で見つけることができます。</entry>
    <entry key="RTWAutoScopeDuplicatedRoot">同じ名前 ''{0}'' をもつ複数の信号が、[Localizable] の [ストレージ クラス] をもつか、または [自動] の [データ スコープ] をもっており、また、再利用可能なサブシステムの外部にあります。これらは、''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt;、および ''{4}'' の&lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;出力端子 {3,number,integer}&lt;/sldiag&gt; で見つけることができます。</entry>
    <entry key="RTWAutoScopeDuplicatedSubsys">同じ ID ''{0}'' をもつ複数の信号が、[Localizable] の [ストレージ クラス] をもつか、または [自動] の [データ スコープ] をもっており、また、同一の再利用可能なサブシステム ''{1}'' の内部にあります。これらは、''{3}'' の&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt;、および ''{5}'' の&lt;sldiag objui="outport" objparam="{4,number,integer}" objname="{5}"&gt;出力端子 {4,number,integer}&lt;/sldiag&gt; で見つけることができます。</entry>
    <entry key="RTWAutoScopeDuplicatedNonAutoScope">複数の信号で同じ信号名 ''{0}'' が使用され、そのうち 1 つのみが [Localizable] の [ストレージ クラス] をもつか、または [自動] の [データ スコープ] をもっています。これらは、''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt;、および ''{4}'' の&lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;出力端子 {3,number,integer}&lt;/sldiag&gt; で見つけることができます。</entry>
    <entry key="RapidAcceleratorCantUploadDataNoDWork">アップロード可能な dwork が存在しないため、ラピッド アクセラレータ モードでは ''{0}'' を更新できません</entry>
    <entry key="RapidAcceleratorCantUploadDataNoInputPorts">入力端子が存在しないため、ラピッド アクセラレータ モードでは ''{0}'' を更新できません</entry>
    <entry key="RapidAcceleratorCantUploadDataNoConnectedSignals">接続されている信号が存在しないため、ラピッド アクセラレータ モードでは ''{0}'' を更新できません</entry>
    <entry key="RapidAcceleratorCantUploadDataPortBasedSampleTime">ブロックまたはそのソース ブロックの 1 つに端子ベースのサンプル時間があるため、ラピッド アクセラレータ モードで ''{0}'' を更新できません</entry>
    <entry key="RapidAcceleratorCantUploadDataConstantSampleTime">ブロックまたはそのソース ブロックの 1 つに定数のサンプル時間があるため、ラピッド アクセラレータ モードで ''{0}'' を更新できません</entry>
    <entry key="RapidAcceleratorCantUploadDataMultipleRates">シングル レートではないため、ラピッド アクセラレータ モードでは ''{0}'' を更新できません。</entry>
    <entry key="RapidAcceleratorCantUploadDataRootInport">駆動ブロックの 1 つが最上位の Inport であるため、ラピッド アクセラレータ モードでは ''{0}'' を更新できません</entry>
    <entry key="RapidAcceleratorCantUploadDataCSC">ソース信号の 1 つがカスタム ストレージ クラスを使用しているため、ラピッド アクセラレータ モードでは ''{0}'' を更新できません</entry>
    <entry key="RapidAcceleratorCantUploadDataNoConvertFunc">ソース信号の 1 つがラピッド アクセラレータ モードでサポートされていないデータ型を使用しているため、ラピッド アクセラレータ モードでは ''{0}'' を更新できません</entry>
    <entry key="RapidAcceleratorCantUploadDataVarDims">ソース信号の 1 つが可変サイズであるため、ラピッド アクセラレータ モードでは ''{0}'' を更新できません</entry>
    <entry key="RapidAcceleratorUnableToOpenModelParameterInfoFile">モデル パラメーター情報の MAT ファイル ''{0}'' を開くことができません。</entry>
    <entry key="RateTransBlkNotAllowedInTrigSubsys">Rate Transition ブロック ''{0}'' は、入力端子または出力端子のサンプル時間が非同期のサンプル時間でない限り、{1} のサブシステム ''{2}'' 内では利用できません。Rate Transition ブロックを {3} のサブシステムの外に置くことを検討してください。</entry>
    <entry key="RateTransBlkNotAllowedToHaveTrigRateWithConstSrc">{2} サブシステム ''{3}'' の {1} 端子が切断されているか接地されているため、Rate Transition ブロック ''{0}'' によってトリガーされるサンプル時間にはソースがありません。{2} サブシステム ''{3}'' の {1} 端子を、接地以外の任意の有効なソースに接続してください。</entry>
    <entry key="RemoveNonRemovableItem">項目 ''{0}'' を削除できません。</entry>
    <entry key="RemovedSysDoesNotHaveThis">サブシステム ''{0}'' は、SimViewingDevice でコードを生成しないため、''{1}'' を持ちません。</entry>
    <entry key="ResetSignalMustBeScalar">''{0}'' のリセット入力端子の次元を設定できません。リセット信号はスカラーの信号でなければなりません。</entry>
    <entry key="ResettableSubsystemMustBeSingleRate">リセット端子 ''{1}'' を含め、サブシステム ''{0}'' 内のすべてのブロックではサンプル時間が同じでなければなりません。</entry>
    <entry key="ReturnWkspOutputOptNotSupported">ReturnWorkspaceOutputs オプションの [オフ] への設定があいまいです。このエラーを回避するには次のいずれかを実行します。\n\t1) sim コマンドの呼び出し時に戻り引数を 1 つのみ使用する。\n\t2) モデルでパラメーター ReturnWorkspaceOutputs を&lt;a href="matlab:set_param(bdroot,'ReturnWorkspaceOutputs','off');"&gt;オフにして&lt;/a&gt;、sim コマンドの呼び出し時にオプション ReturnWorkspaceOutputs を指定しない。</entry>
    <entry key="RightClickBuildFailInsertRateTransBlkInput">右クリックでビルドしたサブシステムは、ブロック ({1}) の入力端子 {0,number,integer} に Rate Transition ブロックを挿入できませんでした。以下を検証することでオリジナル モデル内のこの問題を調べてください \n - 元のモデルが固定ステップ ソルバーを使用している \n - サブシステム内の Inport と Outport ブロックのサンプル時間パラメーターがすべて -1 に設定されている \n - サブシステムの入力信号に定数のサンプル時間がない</entry>
    <entry key="RightClickBuildFailInsertRateTransBlkOutput">右クリックでビルドしたサブシステムは、ブロック ({1}) の出力端子 {0,number,integer} に Rate Transition ブロックを挿入できませんでした。以下を検証することでオリジナル モデル内のこの問題を調べてください \n - 元のモデルが固定ステップ ソルバーを使用している \n - サブシステム内の Inport と Outport ブロックのサンプル時間パラメーターがすべて -1 に設定されている \n - サブシステムの入力信号に定数のサンプル時間がない</entry>
    <entry key="InsertRTBWithEnumTypeNotPermitted">
  列挙データ型の信号に Rate Transition ブロックを自動挿入することは、サポートされていません。\nブロック ''{2}'' の {0} の端子 {1,number,integer} に Rate Transition ブロックを手動で挿入し、\n[初期条件] を有効な列挙値に設定してください。
</entry>
    <entry key="InsertRTBNotPermittedOnInputPortVariantSubsystem">
  バリアント ブロック ''{1}'' の入力端子 {0,number,integer} で Rate Transition ブロックを自動挿入することはサポートされていません。\nサブシステム ''{2}'' の入力端子 {0,number,integer} で Rate Transition ブロックを手動で挿入してください。
</entry>
    <entry key="InsertRTBNotPermittedOnOutputPortVariantSubsystem">
  バリアント ブロック ''{1}'' の出力端子 {0,number,integer} で Rate Transition ブロックを自動挿入することはサポートされていません。\nサブシステム ''{2}'' の出力端子 {0,number,integer} で Rate Transition ブロックを手動で挿入してください。
</entry>
    <entry key="InsertRTBWithAliasEnumTypeNotPermitted">
  列挙データ型のエイリアスをもつ信号に Rate Transition ブロックを自動挿入することは、サポートされていません。\nブロック ''{2}'' の {0} の端子 {1,number,integer} に Rate Transition ブロックを手動で挿入し、\n[初期条件] を有効な列挙値に設定してください。
</entry>
    <entry key="InsertBlkAtVirtualBlkInputError">Simulink はバーチャル ブロックの下流に Rate Transition ブロックを自動的に挿入できません。\n''{0}'' よりも上流にあるバーチャル ブロックの入力端子に Rate Transition ブロックを手動で挿入してください。</entry>
    <entry key="RootInportCannotCodeGenForVarDims">The root-level input port ''{0}'' is carrying a variable-size signal with finite upper bound.  This is supported only for the following targets:\n\t
    - Model reference\n\t
    - Accelerator\n\t
    - GRT (except GRT malloc)\n\t
    - ERT\n\t
    - S-function\n
    However, even for the above targets, variable-size signals with finite upper bounds are not supported when:\n\t
    - 'Code interface packaging' is set to either 'C++ class' or 'Reusable function' on the Interface pane of the Configuration Parameters dialog box\n</entry>
    <entry key="RunTimeChangeDimsFixedDimsMode">この端子には固定サイズの信号があるため、Simulink は ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の次元を変更できません。</entry>
    <entry key="RunTimeChangeDimsFixedDimsNVBus">この端子には固定サイズの要素のみをもつ非バーチャル バスがあるため、Simulink は ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の次元を変更できません。</entry>
    <entry key="RunTimeChangeDimsPassThruOutput">Simulink は ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の次元を変更できません。ブロックはこの出力端子の次元が入力端子の次元と一致しなければならないことを示しているため、次元を変更することが許可されません。(S-Function の場合は、''ssSetInputDimsSameAsOutputDims'' が使われます)。</entry>
    <entry key="RunTimeChangeNumRowsFrameOutputSignal">サンプリング モードがフレームベースのため、Simulink は ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の 1 番目の次元を変更できません。この端子のサンプリング モードをサンプル ベースに変更することを検討してください。</entry>
    <entry key="RunTimeInvalidDims">Simulink は ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に対して現在の次元を設定できません。指定した次元 ({2,number,integer}) は、0 から {3,number,integer} の範囲になければなりません。</entry>
    <entry key="RunTimeInvalidDimsNVBus">Simulink は ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に対して現在の次元を設定できません。バス要素 ''{3}'' に対して指定した次元 ({2,number,integer}) は 0 から {4,number,integer} までの範囲でなければなりません。</entry>
    <entry key="RunTimeExceedNumDims">Simulink は ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に対して現在の次元を設定できません。出力端子の次元数が {4,number,integer} であるため、指定した次元のインデックス ({2,number,integer}) は 0 から {3,number,integer} までの範囲でなければなりません。</entry>
    <entry key="RunTimeExceedNumDimsNVBus">Simulink は ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に対して現在の次元を設定できません。可変サイズ要素の次元の総数が {4,number,integer} であるため、指定した次元のインデックス ({2,number,integer}) は 0 から {3,number,integer} までの範囲でなければなりません。</entry>
    <entry key="RuntimeMethodCalledInUnallowedPhase">''{1}'' の ''{0}'' メソッドは、シミュレーション実行中にのみ呼び出し可能です。</entry>
    <entry key="SFSfcnFunctionToReusableFunctionCPP">Stateflow チャート ''{0}'' の [関数のパッケージ化] 設定を [再利用できない関数] から [再利用可能な関数] に変換しています。これは、チャートにサブ関数が含まれており、コード生成で C++ クラス インターフェイスを生成する際にチャートの [関数のパッケージ化] 設定に [再利用可能な関数] を使用する必要があるためです。</entry>
    <entry key="SFSfcnInlinedToFunction">チャートはサブ関数を含み、完全にインライン化できないため、Stateflow チャート ''{0}'' の [関数のパッケージ化] の設定を [インライン] から ''{1}'' に変換します</entry>
    <entry key="SFSfcnReusableToFunction">Stateflow チャート ''{0}'' の [関数のパッケージ化] の設定を [再利用可能な関数] から [再利用できない関数] に変換します。このチャートはエクスポートされたグラフィカル関数を含み、再利用可能な関数として生成できないためです</entry>
    <entry key="SFcnAPICannotChangeTXUDuringSim">シミュレーション時間の状態とモデルの入力は、シミュレーション中にモデルをプログラム的に呼び出した場合、変更できません</entry>
    <entry key="SFcnAPIInvalidExtInputs">モデル ''{0}''は、非 double または複素信号を含んでいます。非 double または複素数の外部入力を設定できません。Data Type Conversion を使ってください</entry>
    <entry key="SFcnAPIInvalidExtInputs1">指定したモデルの入力 ({0,number,integer}) の数は、実際の入力の数 ({1,number,integer}) と一致しません。</entry>
    <entry key="SFcnAPIInvalidInputs">シミュレーションの入力は double のベクトルとして指定しなければなりません</entry>
    <entry key="SFcnAPIInvalidExtOutputs">モデル ''{0}''は、非 double または複素信号を含んでいます。外部出力を保存できません。Data Type Conversion を使ってください</entry>
    <entry key="ModelCommandSingleTaskingModeOnly">メソッド ''{0}'' は、シングルタスク実行モードのモデルでのみサポートされています。</entry>
    <entry key="SFcnAPIInvalidSyntax">モデル ''{0}'' にアクセスするプログラムの構文が無効です</entry>
    <entry key="SFcnAPIInvalidTime1">シミュレーション時間は、実数の double のスカラー値でなければなりません</entry>
    <entry key="SFcnAPIInvalidTime2">指定したシミュレーション時間 ({0}) の値が無効です。シミュレーションの開始 ({1}) と終了 ({2}) 時間の間の double のスカラーでなければなりません</entry>
    <entry key="SFcnAPIInvalidStates">シミュレーションの状態は、実数の double のベクトルまたは構造体として指定しなければなりません</entry>
    <entry key="SFcnAPIInvalidTs">サンプル時間の値は、空、あるいは double の非負のスカラーのいずれかでなければなりません</entry>
    <entry key="SFcnAPITerminationDeferred">''{0}'' の終了は延期されました</entry>
    <entry key="SFcnCannotChangeSampleTime">S-function ''{0}'' のメソッド {1} は、設定された端子のサンプル時間を変更できません。</entry>
    <entry key="SFcnDidNotSetSampleTime">S-function は、''{2}'' の {0} 端子 {1,number,integer} のサンプル時間を、メソッド {3} の sample および offset time 引数で指定した値に設定します。</entry>
    <entry key="SFcnDidnotSetPortFrameData">S-function は、''{2}'' の {0} 端子 {1,number,integer} のフレーム データを、メソッド {3} の入力引数で指定されたフレーム データに設定する必要があります。</entry>
    <entry key="SFcnDoesNotExist">S-function ''{0}'' のエラー: S-Function ''{1}'' は存在しません</entry>
    <entry key="SFcnInvConstantTs">''{1}'' の S-function {0} に割り当てられたサンプル時間が無効です。定数 (inf) サンプル時間を利用するには、オプション SS_OPTION_ALLOW_CONSTANT_PORT_SAMPLE_TIME を指定しなければなりません。</entry>
    <entry key="SFcnInvInputPortTsAssigned">''{2}'' の S-Function {1} の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; に割り当てられたサンプル時間が無効です。端子に割り当てられたサンプル時間は、登録されたサンプル時間のいずれかでなければなりません。</entry>
    <entry key="SFcnInvName">S-function ''{0}'' のエラー: ''{1}'' は、無効なモデル名の指定です</entry>
    <entry key="SFcnInvNumSampleTimes">''{1}'' の S-function ''{0}'' によって出力されたサンプル時間の数が無効です。</entry>
    <entry key="SFcnInvOutputPortTsAssigned">''{2}'' の S-Function {1} の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に割り当てられたサンプル時間が無効です。端子に割り当てられたサンプル時間は、登録されたサンプル時間のいずれかでなければなりません。</entry>
    <entry key="SFcnMissingSetInputFrameData">S-function ''{0}'' in ''{1}'' does not have a mdlSetInputPortFrameData routine. When an S-function with multiple output ports has dynamic frame data (inherit SamplingMode) setting for any of its ports, it is necessary to define a mdlSetInputPortFrameData routine</entry>
    <entry key="SFcnMissingSetInputPortSampleTime">''{1}'' の S-Function ''{0}'' は PORT_BASED_SAMPLE_TIMES を使用していますが、mdlSetInputPortSampleTime ルーチンが含まれていません。</entry>
    <entry key="SFcnMissingSetOutputPortSampleTime">''{1}'' の S-Function ''{0}'' は PORT_BASED_SAMPLE_TIMES を使用していますが、mdlSetOutputPortSampleTime ルーチンが含まれていません。</entry>
    <entry key="SFcnNeedsContTs">''{1}'' の S-function {0} は連続状態をもつため、連続的なサンプル時間を持たなければなりません。</entry>
    <entry key="SFcnNoUnorientedFrameData">''{1}'' の S-function ''{0}'' は、端子がフレームベースであっても次元数をその {2} の端子 {3,number,integer} に対して 1 になるよう設定します。端子がフレームベースの場合、次元数は少なくとも 2 となる必要があることに注意してください。</entry>
    <entry key="SFcnUnableToAcqFcnHdl">S-function ''{0}'' のエラー: MATLAB 関数 ''{1}'' のハンドルを取得できません</entry>
    <entry key="SFcnUseDisallowConstTs">''{0}'' は不変になります (シミュレーション開始時にのみ 1 回実行します)。しかし、状態があります。mdlInitializeSizes メソッドで ssSetOptions(S, SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME) を用いて、不変になるのを回避することを推奨します</entry>
    <entry key="SIDCannotAllowCopiedSID">最高水準が 0 ではないため、コピーしたオブジェクトは同じ Simulink ID にすることはできません。</entry>
    <entry key="SIDCannotSetHighWatermark">最高水準を変更できません。新規の最高水準は現在の最高水準より大きくなければなりません。</entry>
    <entry key="SIDNoSIDSpace">Simulink ID 空間は存在しません。</entry>
    <entry key="SLDV_PrecisionLost">    ''{0}'' 内の信号タイプに値を変換するときに精度が失われました。</entry>
    <entry key="SLDV_PrecisionLostErr">''{0}'' で信号タイプとパラメーター値のタイプが一致しないため、桁落ちが発生しています</entry>
    <entry key="SLDV_ProofViolation">Proof プロパティは時間 {1} に ''{0}'' での違反がありました</entry>
    <entry key="SLDV_SigObjWithICIgnored">''{0}'' の初期出力値は信号オブジェクトから継承されているため、無視されます。このブロックのダイアログ パラメーターを使用して、必要な初期値を指定してください。</entry>
    <entry key="SLDV_UnknownBlockType"> 不明な Simulink Design Verifier ブロック タイプ ''{0}''</entry>
    <entry key="SLType_MI_NoPublicCtor">クラス ''{0}'' に対するパブリック コンストラクターがありません。</entry>
    <entry key="SLType_MI_OneIndexed">インデックス値は 1 以上でなければなりません</entry>
    <entry key="SLType_ModifyLockedType">ロックされたタイプ オブジェクトを変更できません</entry>
    <entry key="SampHitInvalidTid">''{1}'' のメソッド ''{0}'' に渡されたサンプル時間のインデックスは、0 から {2,number,integer} の範囲でなければなりません。</entry>
    <entry key="SampHitInvalidTidForSingleRate">''{1}'' のメソッド ''{0}'' に渡されたサンプル時間のインデックスは、このモデルが 1 つのサンプル時間のみをもつため、0 でなければなりません。</entry>
    <entry key="SaveWithDisabledLinks_Error">ブロック線図 ''{0}'' は、無効なライブラリ リンクを含んでいるため、保存されない可能性があります。この制約を無効にするには、set_param(''{1}'',''SaveWithDisabledLinksMsg'',''none'') と入力し、再度保存してください。無効なライブラリ リンクを見つけるには、モデル アドバイザーを使用します。</entry>
    <entry key="SaveWithParameterizedLinks_Error">ブロック線図 ''{0}'' は、パラメーター付きのライブラリ リンクを含んでいるため、保存されない可能性があります。この制約を無効にするには、set_param(''{1}'',''SaveWithParameterizedLinksMsg'',''none'') と入力し、再度保存してください。パラメーター付きのライブラリ リンクを見つけるには、モデル アドバイザーを使用します。</entry>
    <entry key="SetCurrentOutputDimsRunTime">Simulink は、ブロック線図の実行中に ''{1}'' の S-function ''{0}'' に対してメソッド ''ssSetCurrentOutputPortDimensions'' のみを呼び出せます。</entry>
    <entry key="SetDirty_MdlFileChangedOnDisk">ブロック線図 ''{0}'' は編集されていますが、そのファイルは読み込まれてからディスク上で変更されています。ブロック線図を閉じて再読み込みする必要があります。</entry>
    <entry key="SetDstateNotPerm">離散時間状態数は読み取り専用です。離散時間状態は、''UsedAsDiscState'' フラグを通して状態として適切な Dworks を作成することで登録できます</entry>
    <entry key="SetNumCStatesEvalOrPostPropTaskOnly">連続状態数は、''{0}'' の Initialize と PostPropagationSetup メソッドのみ設定できます。</entry>
    <entry key="SetNumDataStoresEvalOnly">DataStores 数は、''{0}'' の CheckPrms メソッドのみ設定可能です</entry>
    <entry key="SetNumDworksPostPropOnly">Dwork 数は、''{0}'' の PostPropagationSetup メソッドのみ設定可能です。</entry>
    <entry key="SetNumInputPortsInitOnly">入力端子の数は、''{0}'' の Initialize メソッドのみ設定可能です。</entry>
    <entry key="SetNumOutputPortsInitOnly">出力端子数は、''{0}'' の Initialize メソッドのみ設定可能です。</entry>
    <entry key="SetSampleTimeEvalOnly">サンプル時間は、''{0}'' の Initialize メソッド内でのみ設定可能です。</entry>
    <entry key="SettingAliasedThroughDatatypeIdNotPermitted">''{0}'' の aliasedthrough のデータ型 ids は読み取り専用であるため、設定できません。</entry>
    <entry key="SettingAliasedThroughDatatypeNameNotPermitted">''{0}'' の aliasedthrough のデータ型の名前は読み取り専用であるため、設定できません。</entry>
    <entry key="SettingBlockHandleNotPermitted">''{0}'' のブロック ハンドルは読み取り専用であるため、設定できません。</entry>
    <entry key="SettingBlockPortNameNotPermitted">ブロック ''{0}'' に対する端子名は読み取り専用であるため、設定できません</entry>
    <entry key="SettingDatatypeNameNotPermitted">''{0}'' のデータ型の名前は読み取り専用であるため、設定できません。</entry>
    <entry key="SettingNotPermitted">プロパティ ''{0}'' は読み取り専用であるため、設定できません。</entry>
    <entry key="SettingNumDlgPrmsNotPermitted">''{0}'' のダイアログ パラメーターの数は読み取り専用であるため、設定できません。</entry>
    <entry key="SettingNumRuntimePrmsNotPermitted">''{0}'' の実行時のパラメーターの数が読み取り専用で設定できません。</entry>
    <entry key="SettingObjectTypeEnumNotPermitted">''{0}'' のオブジェクト タイプの一覧は読み取り専用であるため、設定できません。</entry>
    <entry key="NoDStateNumInfoForModelRef">Model ブロック ''{0}'' は R2020b 以前の保護モデルを参照するため、離散状態の線形化はサポートされません。 </entry>
    <entry key="CannotLinearizeModelRefInAccelMode">Model ブロック ''{0}'' はアクセラレータ モードであるため、離散状態の線形化はサポートされません。 </entry>
    <entry key="SfcnCannotUseDefaultDimsMethods_s">S-function ''{0}'' は、mdlSetInputPortDimensionInfo (mdlSetInputPortWidth) と mdlSetOutputPortDimensionInfo (mdlSetOutputPortWidth) メソッドがありません。既定の規則に従わないため、端子の幅と次元を設定するために Simulink の既定のメソッドを使用できません。上記のメソッドを追加することで S-function を更新してください。『Writing S-functions』にこれらのメソッドについての詳細が記載されています。</entry>
    <entry key="SfcnHasBothReuseAndssWriteRTW">S-function ''{0}'' は、オプション SS_OPTION_WORKS_WITH_CODE_REUSE が設定されていますが、関数 mdlRTW で ssWriteRTWParameters を使用するか、ssSetSFcnParamTunable を使ったパラメーターの調整を明示的に設定していません。コードの再利用のため、S-function の実行時パラメーターの登録が必要です。具体的な登録方法は S-function のドキュメンテーションを参照してください</entry>
    <entry key="SfcnInvalidOutputAsMatrix">S-function ''{0}'' の mdlRTW でエラーが発生しました。このブロックは、.rtw ファイルに 2 次元の形式でパラメーターを書き出すために旧式のマクロを使用しています。2 次元でパラメーターを書き出すためには、S-function をアップグレードして、実行時パラメーターを登録する必要があります。例としては、''sfundemo'' の中の実行時パラメーター デモを参照してください</entry>
    <entry key="SfcnJacobianConfigButNoMethod">S-Function ''{0}'' は関数 mdlSetWorkWidths 内でヤコビアンの次元を構成しましたが、mdlJacobian メソッドの実装に失敗しました。</entry>
    <entry key="SfcnJacobianMethodButNoConfig">S-Function ''{0}'' は mdlJacobian メソッドを実装していますが、関数 mdlSetWorkWidths 内でのヤコビアンの次元の構成に失敗しました</entry>
    <entry key="SfcnJacobianMethodButNoIrJc">S-Function ''{0}'' は mdlJacobian メソッドを実装していますが、関数 mdlStart 内でのヤコビ構造 (Ir, Jc) の初期化に失敗しました</entry>
    <entry key="SfcnMissingDefinedDimsDependRuleVarDims">''{1}'' の S-function ''{0}'' は、''ssSetSignalSizesComputeType'' が SS_VARIABLE_SIZE_FROM_INPUT_SIZE になるよう宣言されています。したがって、&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{0}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; の次元依存の規則を登録するために ''ssAddOutputDimsDependencyRule'' メソッドを使用しなければなりません。</entry>
    <entry key="SfcnMissingReqTLCforSetVarDims">''{1}'' の S-function ''{0}'' には TLC ファイルがありません。S-function に可変サイズの信号をサポートするよう出力次元依存の規則が登録されているため、この S-function には TLC ファイルが必要です。</entry>
    <entry key="SfcnMustHaveMdlDimsFcn_ss">S-function ''{0}'' は関数 {1} を持たなければなりません。</entry>
    <entry key="SfcnRedundantDimsDepRule">''{1}'' の S-Function ''{0}'' には、&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{0}"&gt;出力端子 {2,number,integer}&lt;/sldiag&gt; に対して冗長な出力次元依存の規則が登録されています。規則 {3,number,integer} に登録された入力のインデックスは既存の規則のサブセット、または、スーパーセットです。たとえば、別の規則が入力のインデックス "0"、"1" または "0, 1" に既に含まれている場合、入力のインデックス "0, 1" を含む規則は冗長になります。</entry>
    <entry key="SfcnTsNotMatchGlbDSMTs">ブロック ''{0}'' にはサンプル時間 {1} がありますが、Simulink.Signal オブジェクトが競合するサンプル時間 {3} をもつデータ ストア メモリ ''{2}'' にアクセスしています。</entry>
    <entry key="SfsDomainMustBeFirst">{0} のシンボル形式の文字列でエラーが発生しました。ドメインのマクロ ''$D'' をシンボル形式の文字列内で指定する場合、シンボル形式の文字列の先頭に置かなければなりません。</entry>
    <entry key="SfsInvalid1stChar">{0} のシンボル形式の文字列でエラーが発生しました。1 番目の文字は指定されたマクロ、英字、アンダースコアでなければなりません。</entry>
    <entry key="SfsInvalidChar">{0} のシンボル形式の文字列でエラーが発生しました。''{1}'' は有効なマクロ、または C 言語の識別子として認識されません。</entry>
    <entry key="SfsInvalidMacro">{0} のシンボル形式の文字列でエラーが発生しました。''${1}'' は有効なマクロとして認識されません。</entry>
    <entry key="SfsMangleMacroCount">{0} のシンボル形式の文字列でエラーが発生しました。少なくとも 1 つのマングル (mangle) マクロ ($M) がなければなりません。</entry>
    <entry key="SfsMangleRequired">モデル ''{0}'' のシンボル名の計算中にエラーが発生しました。識別子の最大の長さ ''{1,number,integer}'' にシンボル形式の文字列 ''{2}'' を使ってシンボル名を固有にするための十分な容量が与えられていません。識別子の最大の長さを増やすことを検討してください。</entry>
    <entry key="SfsMangleOrChange">モデル ''{0}'' のシンボル名の計算中にエラーが発生しました。次のシンボル ''{1}'' を変更またはマングルし、シンボル形式の文字列 ''{2}'' を使用してシンボル名を一意にする必要があります。いずれかのシンボルを変更するか、シンボル形式の文字列に $M を追加することを検討してください。</entry>
    <entry key="SfsMangleOrChangeWithBlockPath">モデル ''{0}'' のシンボル名の計算中にエラーが発生しました。ブロック ''{2}'' から発生する次のシンボル ''{1}'' を変更またはマングルし、シンボル形式の文字列 ''{3}'' を使用してシンボル名を一意にする必要があります。いずれかのシンボルを変更するか、シンボル形式の文字列に $M を追加することを検討してください。</entry>
    <entry key="SfsNoMethod">{0} のシンボル形式の文字列でエラーが発生しました。メソッド名 ''$F'' に対するマクロは、このシンボル形式の文字列ではサポートされません。</entry>
    <entry key="SfsNoRoot">{0} のシンボル形式の文字列でエラーが発生しました。モデル名 ''$R'' に対するマクロは、このシンボル形式の文字列ではサポートされません。</entry>
    <entry key="SfsNoSysId">{0} のシンボル形式の文字列でエラーが発生しました。システムの階層番号 ''$H'' に対するマクロは、このシンボル形式の文字列ではサポートされません。</entry>
    <entry key="SfsNoType">{0} のシンボル形式の文字列でエラーが発生しました。データ型 ''$A'' に対するマクロは、このシンボル形式の文字列ではサポートされません。</entry>
    <entry key="SfsTooLong">{0} のシンボル形式の文字列、識別子の最大の長さ、マングルの最小の長さの設定に互換性がありません。識別子の最大の長さは、予約された長さ {1,number,integer}、マングルの最小の長さ、および {2} のシンボル形式の文字列におけるリテラル文字列の長さの合計より長くなければなりません。</entry>
    <entry key="NamingRuleParsingError">シンボル形式の文字列 ''{0}'' を解析できません。命名規則の部分文字列 ''{2}'' で {1} が検出されています。{3}</entry>
    <entry key="NamingRuleParsingEmptyRule">空の命名規則</entry>
    <entry key="NamingRuleParsingInvalidToken">無効なトークン</entry>
    <entry key="NamingRuleParsingInvalidDecorator">無効なデコレータ</entry>
    <entry key="NamingRuleParsingUnclosedDecorator">デコレータで ']' が見つかりません</entry>
    <entry key="NamingRuleParsingUnexpectedOpenBracket">デコレータに予期せぬ '[' があります</entry>
    <entry key="NamingRuleParsingUnexpectedCloseBracket">デコレータに予期せぬ ']' があります</entry>
    <entry key="NamingRuleParsingInvalidLiteral">無効なシンボル</entry>
    <entry key="ExtendedDecoratorNotAllowedOnUnsupportedToken">正規表現に基づく文字列置換をサポートするデコレータは、$N、$G、または $R としか併用できません。</entry>
    <entry key="DecoratorParsingError">トークン デコレータ ''{0}'' を解析できません。{1}</entry>
    <entry key="DecoratorParsingNoBackSlash">'/' 区切りが見つかりません。</entry>
    <entry key="DecoratorParsingTooManyBackSlashes">2 個を超える '/' 区切りが見つかりました。</entry>
    <entry key="DecoratorParsingWrongPrefix">文字列は 'r' または 'r/' で開始する必要があります。</entry>
    <entry key="DecoratorParsingEmptySpecId">指定 ID が無効です。</entry>
    <entry key="DecoratorParsingInvalidIdentifierCharacter">識別子では ''{0}'' は許可されていません。</entry>
    <entry key="DecoratorParsingIdentifierStartsWithNumber">識別子が、数字 ''{0}'' で始まっています。</entry>
    <entry key="RegexprepDecoratorOptionsParsingError">トークン デコレータ オプションの文字列 ''{0}'' を解析できません。{1}</entry>
    <entry key="RegexprepDecoratorOptionNotApplicable">オプション ''{0}'' を適用できません。{1}</entry>
    <entry key="RegexprepDecoratorOptionUnknownOption">不明なオプションです。</entry>
    <entry key="RegexprepDecoratorOptionConflictingOption">''{0}'' は、前のオプション ''{1}'' と互換性がありません。</entry>
    <entry key="SfsMangleTooLong">マングルの長さは 15 文字を超えてはなりません。</entry>
    <entry key="SfsChecksumTooLong">共有チェックサム長は 15 文字を超えてはなりません。</entry>
    <entry key="SignalBasedLinearizationBusNotSupported">信号ベースの線形化を実行する場合、モデル パラメーター ''InjectionData'' は、バス信号にある IO ポイントに対して空でない ''BusSignalName'' フィールドを含む必要があります。</entry>
    <entry key="SignalBasedLinearizationInvalidInjectionData">モデル パラメーター ''InjectionData'' が無効です。モデル パラメーター ''InjectionData'' は、空、端子のハンドルの double 配列または ''PortHandle''、''InputWKSVariable''、''OutputWKSVariable''、''SignalInjectionData'' フィールドをもつ MATLAB 構造体のいずれかである必要があります。また、''SignalInjectionData'' フィールドは、''IOType''、''DataType''、''Dimensions''、''PortDataSize''、''SampleTime''、''BusSignalName''、''SignalIndex''フィールドをもつ別の構造体にする必要があります。</entry>
    <entry key="IdentifierLengthDiagnosticTableHeaderIdentifier">識別子</entry>
    <entry key="IdentifierLengthDiagnosticTableHeaderType">タイプ</entry>
    <entry key="IdentifierLengthDiagnosticTableHeaderFormat">形式</entry>
    <entry key="IdentifierLengthDiagnosticSuggestedActionGRT">
      モデル ''{0}'' の識別子は、識別子の最大の長さを満たすために切り捨てられました。識別子の長さは {1} 文字を超えてはなりません。{2} &lt;actions exclusiveFixIts="no"&gt; &lt;action type="fixit" id="EliminateMessage"&gt; &lt;cmd&gt;Simulink.ModelReference.internal.ModelRefFixes(''DisableIdentifierLengthMessage'',''{0}'',''none'')&lt;/cmd&gt; &lt;txt&gt;次回からこのメッセージを表示しない。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" id="HelpMaxIdentifierLength"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''MaxIdLength'')&lt;/cmd&gt; &lt;txt&gt;識別子の最大の長さを増やす (参照先や参照元のモデルに影響する可能性があります)。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="IdentifierLengthDiagnosticSuggestedActionERT">
      モデル ''{0}'' の識別子は、識別子の最大の長さを満たすために切り捨てられました。識別子の長さは {1} 文字を超えてはなりません。{2} &lt;actions exclusiveFixIts="no"&gt; &lt;action type="fixit" id="EliminateMessage"&gt; &lt;cmd&gt;Simulink.ModelReference.internal.ModelRefFixes(''DisableIdentifierLengthMessage'',''{0}'',''none'')&lt;/cmd&gt; &lt;txt&gt;次回からこのメッセージを表示しない。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" id="HelpMaxIdentifierLength"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''MaxIdLength'')&lt;/cmd&gt; &lt;txt&gt;識別子の最大の長さを増やす (参照先や参照元のモデルに影響する可能性があります)。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" id="HelpStringFormat"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''CustomSymbolStrGlobalVar'')&lt;/cmd&gt; &lt;txt&gt;識別子の形式を変更する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="IdentifierLengthDiagnosticSuggestedActionGRTError">
      モデル ''{0}'' の識別子は、識別子の最大の長さの設定を満たすために切り捨てなければなりません。識別子の長さは {1} 文字を超えてはなりません。{2} &lt;actions exclusiveFixIts="no"&gt; &lt;action type="fixit" id="EliminateMessage"&gt; &lt;cmd&gt;Simulink.ModelReference.internal.ModelRefFixes(''DisableIdentifierLengthMessage'',''{0}'',''none'')&lt;/cmd&gt; &lt;txt&gt;次回からこのメッセージを表示しない。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" id="HelpMaxIdentifierLength"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''MaxIdLength'')&lt;/cmd&gt; &lt;txt&gt;識別子の最大の長さを増やす (参照先や参照元のモデルに影響する可能性があります)。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="IdentifierLengthDiagnosticSuggestedActionERTError">
      Identifiers for model ''{0}'' must be truncated to satisfy maximum identifier length setting. 
      Identifier length must not exceed {1} characters. {2} 
      
      &lt;actions exclusiveFixIts="no"&gt;
          &lt;action type="fixit" id="EliminateMessage"&gt;
            &lt;cmd&gt;Simulink.ModelReference.internal.ModelRefFixes(''DisableIdentifierLengthMessage'',''{0}'',''none'')&lt;/cmd&gt;
            &lt;txt&gt;Do not show this message again.&lt;/txt&gt;
          &lt;/action&gt;
          &lt;action type="suggestion" id="HelpMaxIdentifierLength"&gt;
            &lt;cmd&gt;configset.internal.open(''{0}'',''MaxIdLength'')&lt;/cmd&gt;
            &lt;txt&gt;Increase maximum identifier length which might impact referenced or referencing models.&lt;/txt&gt;
          &lt;/action&gt;
          &lt;action type="suggestion" id="HelpStringFormat"&gt;
            &lt;cmd&gt;configset.internal.open(''{0}'',''CustomSymbolStrGlobalVar'')&lt;/cmd&gt;
            &lt;txt&gt;Change identifier format.&lt;/txt&gt;
          &lt;/action&gt;
        &lt;/actions&gt;
    </entry>
    <entry key="IdentifierLengthDiagnosticMessageReportAction">コマンド set_param(''{0}'',''ModelReferenceSymbolNameMessage'',''none'') を実行しました。</entry>
    <entry key="SignalDataNotReusableSC">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に接続された信号のストレージ クラスはグローバルのため、生成されたコードは再利用可能ではありません。ストレージ クラス "Auto" を使用するか、&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;[コード インターフェイスのパッケージ化]&lt;/sldiag&gt; を [再利用できない関数] に設定するか、あるいは &lt;sldiag objui="configset" objparam="MultiInstanceErrorCode"&gt;[マルチインスタンス コードのエラーの診断]&lt;/sldiag&gt; を [なし] または [警告] に設定することを検討してください</entry>
    <entry key="SignalDimNotReusableSC">モデルは再利用可能なコードを生成できません。''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; に接続された信号のストレージ クラスがグローバルで、可変サイズの次元をもちます。信号に対してストレージ クラス ''Auto'' を使用するか、モデルの &lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;[コード インターフェイスのパッケージ化]&lt;/sldiag&gt; を [再利用できない関数] に設定することを検討してください。</entry>
    <entry key="RootOutportSignalDataNotReusableSC">ルートの出力端子 ''{0}'' のストレージ クラスがグローバルであるため、生成されたコードは再利用可能ではありません。ストレージ クラス ''Auto'' を使用するか、[コンフィギュレーション パラメーター]、[コード生成]、[インターフェイス] ペインで [コード インターフェイスのパッケージ化] オプションを [再利用できない関数] に設定するか、または [マルチインスタンス コードのエラーの診断] オプションを [なし] か [警告] に設定することを検討してください</entry>
    <entry key="InvalidSettingInLinearAnalysisIOBusElement">線形化 IO 指定で与えられたバス要素に対するバス要素が見つかりません。 </entry>
    <entry key="ArrayOfBusesLinearAnalysisIOBusElement">配列のバスの要素に線形化解析点を設定できません。</entry>
    <entry key="LinearAnalysisIOBusElementOnNonBusSignal">非バス信号のバス要素を使用して線形化解析点を設定することはできません。</entry>
    <entry key="DuplicatedLinearAnalysisIOOnInport">''{0}'' の重複する端子に複数の線形化 I/O ポイントを設定できません。</entry>
    <entry key="LinearAnalysisIOOnDuplicateInportWarning">線形化 I/O ポイントが ''{0}'' またはその重複する端子に指定されています。重複する端子およびマスター端子からのすべてのパスが、この線形化 I/O で考慮されます。</entry>
    <entry key="SignalBasedLinearizationIOOnABus">バス信号を信号ベースの線形化の I/O ポイントとして使用できません。</entry>
    <entry key="SignalDimsLargerThan32">''{0}'' で指定された次元数が最大 (32) を超えています。</entry>
    <entry key="SignalWidthLargerThanProductLongIntSize">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; のサイズが、組み込みハードウェアの long int サイズ (''{2,number,integer}'' ビット) またはテスト ハードウェアの long int サイズ (''{3,number,integer}'' ビット) を超えています。これは実行中にオーバー フローを引き起こします。</entry>
    <entry key="SigobjConsistencyDWork">信号の属性の矛盾がブロック ''{0}'' の状態で見つかりました。ここで、状態の属性は、状態で参照される信号オブジェクト ''{1}'' と一致しません:\n   状態の属性 ({2}): {3}\n オブジェクトの設定 ({4}): {5}</entry>
    <entry key="SigobjConsistencyDWork2">信号の属性の矛盾がブロック ''{0}'' の状態で見つかりました。ここで、ブロックの属性は、状態で参照される信号オブジェクト ''{1}'' と一致しません:\n   ブロックの属性 ({2}): {3}\n オブジェクトの設定 ({4}): {5}</entry>
    <entry key="SigobjConsistencyPort">信号の属性の矛盾がブロック ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; で見つかりました。ここで、端子の設定はブロック ''{4}'' の&lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;出力端子 {3,number,integer}&lt;/sldiag&gt; の信号オブジェクト ''{2}'' とは一致しません:\n 端子の設定 ({5}): {6}\n オブジェクトの設定 ({7}): {8}</entry>
    <entry key="SimCantChangeBDPropDuringExtModeSim">モデル ''{1}'' をエクスターナル モードで実行している間は、パラメーター ''{0}'' を変更できません</entry>
    <entry key="SimCantChangeBDPropDuringSim">モデル ''{1}'' をシミュレーション中にパラメーター ''{0}'' を変更できません</entry>
    <entry key="SimCantChangeBDPropInFastRestart">モデル ''{1}'' が高速リスタートで初期化されている場合、''{0}'' パラメーターは変更できません。</entry>
    <entry key="SimCantChangeInputGlobalAttrDuringSim">シミュレーションの実行中に、''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; のグローバル属性を変更できません</entry>
    <entry key="SimCantChangeInputReusableAttrDuringSim">シミュレーションの実行中に、''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; の再利用可能な属性を変更できません</entry>
    <entry key="SimCantChangeOutputReusableAttrDuringSim">シミュレーションの実行中に、''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の再利用可能な属性を変更できません</entry>
    <entry key="SimCantChangeOutputTestPointAttrDuringSim">シミュレーションの実行中に、''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; のテスト ポイントの属性を変更できません</entry>
    <entry key="SimCantChangeOverWritableAttrDuringSim">シミュレーションの実行中に、''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; の上書き可能な属性を変更できません</entry>
    <entry key="SimOptInitStepTooLarge">初期ステップ サイズ ({0}) は最大ステップ サイズ ({1}) より大きくなっています。</entry>
    <entry key="SimOptInitStepTooSmall">初期ステップ サイズ ({0}) は最小ステップ サイズ ({1}) より小さくなっています。</entry>
    <entry key="SimOptMinEqualToMax">最大ステップ サイズ ({0}) は最小ステップ サイズ ({1}) と等しくなっています。固定ステップ サイズの問題については、固定ステップ ソルバーを使用してください。</entry>
    <entry key="SimOptMinLargerThanMax">最大ステップ サイズ ({0}) は、最小ステップ サイズ ({1}) より大きくなければなりません。</entry>
    <entry key="SimOptMinLargerThanSample">最小ステップ サイズ ({0}) は離散サンプリング周 期({1}) より大きくなっています。</entry>
    <entry key="SimOptMinLargerThanTotalTime">最小ステップ サイズ ({0}) は、時間区間の総計 ({1}) より大きくなっています。最小ステップ サイズを減らしてください。</entry>
    <entry key="SimOptMinStepIgnoredInVarStepDisc">最小ステップ サイズ ({0}) は、モデルが可変ステップの離散ソルバーを使用しているため、無視されます</entry>
    <entry key="SimOptRelTolTooSmall">相対許容誤差 {0} が小さすぎます。相対許容誤差を {1} に設定してください</entry>
    <entry key="SimStatusBuilding">ビルド中</entry>
    <entry key="SimStatusBuildingAsModelRef">参照モデルとしてビルド中</entry>
    <entry key="SimStatusExternal">エクスターナル</entry>
    <entry key="SimStatusExternalAsModelRef">参照モデルとしてエクスターナル</entry>
    <entry key="SimStatusExternalAsNormalModelRef">参照モデルがエクスターナル シミュレーションに接続されていません</entry>
    <entry key="SimStatusInitializing">初期化中</entry>
    <entry key="SimStatusRestarting">再開中</entry>
    <entry key="SimStatusInitializingAsModelRef">参照モデルとして初期化中</entry>
    <entry key="SimStatusRestartingAsModelRef">参照モデルとして再開中</entry>
    <entry key="SimStatusPaused">一時停止</entry>
    <entry key="SimStatusPausedAsModelRef">参照モデルとして一時停止</entry>
    <entry key="SimStatusPausedInDebugger">デバッガーで停止</entry>
    <entry key="SimStatusPausedInDebuggerAsModelRef">参照モデルとしてデバッガーで停止</entry>
    <entry key="SimStatusCompiled">コンパイル済み</entry>
    <entry key="SimStatusCompiledAsModelRef">参照モデルとしてコンパイル済み</entry>
    <entry key="SimStatusRunning">実行中</entry>
    <entry key="SimStatusRunningAsModelRef">参照モデルとして実行中</entry>
    <entry key="SimStatusPacingUtilization">: {0,number,integer} の利用</entry>
    <entry key="SimStatusPacingOverrun">: シミュレーションを定間隔で進められません</entry>
    <entry key="SimStatusPacingPollMode">進行中 (ポーリング){0}</entry>
    <entry key="SimStatusPacingPollModeAsModelRef">参照モデル {0} として進行中 (ポーリング)</entry>
    <entry key="SimStatusPacingSleepMode">進行中 (スリープ){0}</entry>
    <entry key="SimStatusPacingSleepModeAsModelRef">参照モデル {0} として進行中 (スリープ)</entry>
    <entry key="SimStatusStopped">停止</entry>
    <entry key="SimStatusStoppedAsModelRef">参照モデルとして停止</entry>
    <entry key="SimStatusTerminating">終了中</entry>
    <entry key="SimStatusTerminatingAsModelRef">参照モデルとして終了中</entry>
    <entry key="SimStatusUpdating">更新中</entry>
    <entry key="SimStatusUpdatingAsModelRef">参照モデルとして更新中</entry>
    <entry key="SimStatusCanceling">キャンセル中</entry>
    <entry key="SimStatusCancel">キャンセル</entry>
    <entry key="SimIsStoppedDuringConditionalStopRequest">非アクティブなシミュレーションを条件付きで停止できません</entry>
    <entry key="PortTypePropagationStatusPausing">一時停止中</entry>
    <entry key="PortTypePropagationPause">一時停止</entry>
    <entry key="PortTypePropagationPauseTooltip">複素端子のドメイン タイプの伝播を一時停止</entry>
    <entry key="PortTypePropagationStatusMsgInProgress">端子のドメイン タイプの伝播: 処理中</entry>
    <entry key="PortTypePropagationStatusMsgPaused">端子のドメイン タイプの伝播: 複素接続のため一時停止</entry>
    <entry key="PortTypePropagationStatusResuming">再開中</entry>
    <entry key="PortTypePropagationResume">再開</entry>
    <entry key="PortTypePropagationResumeTooltip">複素端子のドメイン タイプの伝播を再開</entry>
    <entry key="PortTypePropagation">端子のドメイン タイプの伝播</entry>
    <entry key="PortTypePropagationPaused">一時停止</entry>
    <entry key="StopRequestedBy">{0} の要求により停止されました</entry>
    <entry key="StopCommandIssued">停止コマンドによりシミュレーションが停止しました</entry>
    <entry key="ReachedStopTime">{0} の停止時間に到達しました</entry>
    <entry key="SimulationTimedOut">シミュレーションがタイムアウトしました</entry>
    <entry key="StartTimeGreaterThanStop">開始時間が停止時間よりも後になっています</entry>
    <entry key="SimTypeMismatch">モデル ''{0}'' は、現在 ''{1}'' のシミュレーション タイプをコンパイルしています。モデルが指定したシミュレーション タイプ ''{2}'' をコンパイルする前に、現在のコンパイル作業を終了する必要があります。</entry>
    <entry key="SimViewingDeviceNotAtomic">''{0}'' は ''SimViewingDevice'' として指定されていますが、Atomic ではありません。''SimViewingDevices'' のサブシステムは、Atomic でなければなりません。</entry>
    <entry key="SimulationCommandInNoDisplay">Issuing simulation commands using the set_param function is not supported for MATLAB sessions that do not have a display, such as MATLAB sessions started using the -nodisplay option.</entry>
    <entry key="SimCommandInModelAPI">'SimulationCommand' action using set_param function is not supported for models compiled using the model function.</entry>
    <entry key="SingularJacobian" context="error">微分代数方程式系がインデックス 1 でないか、代数方程式が制約を満たさないため、ブロック ''{0}'' を含む代数ループにおいて、時間 {1} で特異なヤコビアンが計算されました。[固定ステップ サイズ (基本サンプル時間)] または [相対許容誤差] のパラメーター値を小さくしてソルバーのステップ サイズを小さくすることを試みてください。</entry>
    <entry key="SlType_IndexOutOfRange">インデックス値は範囲外です。</entry>
    <entry key="SlType_InvalidElementName">無効な要素名</entry>
    <entry key="NeedsToUseDAEOrAutoSolver"> モデル "{0}" に動的方程式と代数方程式の両方が含まれています。これらの方程式を生成する Descriptor State Space ブロックが含まれる場合があります。ソルバーを、DAE ソルバー (ode15s、ode23t、ode14x、ode1be、自動ソルバーなど) に切り替えてください。</entry>
    <entry key="ODENNeedsImplicitIntegrationMethod"> モデル "{0}" に動的方程式と代数方程式の両方が含まれています。これらの方程式を生成する Descriptor State Space ブロックが含まれる場合があります。このモデルをシミュレートするには、ODEN で ode14x や ode1be のような陰的な積分手法を使用する必要があります。</entry>
    <entry key="SaveWithDisabledLinks_Warning">ブロック線図 ''{0}'' は、無効なライブラリ リンクを含んでいます。ライブラリでないモデル内の無効なリンクを見つけるにはモデル アドバイザーを使用します。ブロック線図は保存されましたが、意図した情報を含んでいない可能性があります。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;editedlinkstool('Create',''{0}'',0);&lt;/cmd&gt; &lt;txt&gt;ライブラリ リンク ツールを使用して、モデル内の無効なリンクを復元またはプッシュする。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;

</entry>
    <entry key="SaveWithParameterizedLinks_Warning">
      ブロック線図 ''{0}'' は、1 つ以上のパラメーター付きのライブラリ リンクを含んでいます。パラメーター付きのライブラリ リンクを見つけるには、モデル アドバイザーを使用します。ブロック線図は保存されましたが、意図した動作にならない可能性があります。パラメーター付きのリンクのサポートは将来のリリースで削除される予定です。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;editedlinkstool('Create',''{0}'',1);&lt;/cmd&gt; &lt;txt&gt;ライブラリ リンク ツールを使用して、モデル内のパラメーター付きのリンクを復元またはプッシュする。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
      
    </entry>
    <entry key="SlvrJacobianMethodCorrected">指定されている [ソルバーのヤコビ メソッド] は ''{0}'' ですが、{3} のため、Simulink では ''{1}'' メソッドが選択されました &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{2}'',''SolverJacobianMethodControl'',''{1}'');&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="SolverJacobianMethodControl"&gt;[ソルバーのヤコビ メソッド]&lt;/sldiag&gt; を明示的に ''{1}'' に設定してこの診断を無効にできる。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" btn="apply"&gt; &lt;cmd&gt;set_param(''{2}'',''SolverPrmCheckMsg'',''none'');&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="SolverPrmCheckMsg"&gt;[自動ソルバー パラメーターの選択]&lt;/sldiag&gt; の診断を [なし] に設定する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="SlvrJacobianPatternNotSupported">slvrJacobian パターン情報を得るには、モデル ''{0}'' のソルバーは陰的なソルバーでなければならず、スパース ヤコビ メソッドを使用しなければなりません。</entry>
    <entry key="SlvrAnalyticJacobianPatternNotSupported">解析的な線形化を使用して、モデル "{0}" のソルバーのヤコビ パターンを取得できません。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="SlvrAnalyticJacobianPatternNotSupportedFix" retvalue="false"&gt; &lt;cmd&gt;set_param(''{0}'',''AnalyticLinearization'',''off'');&lt;/cmd&gt; &lt;txt&gt;モデル "{0}" の解析的な線形化を無効にする。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    
    </entry>
    <entry key="SlvrAnalyticJacobianValueNotSupported">解析的な線形化を使用して、モデル "{0}" のソルバーのヤコビアン値を取得できません。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="SlvrAnalyticJacobianValueNotSupportedFix" retvalue="false"&gt; &lt;cmd&gt;set_param(''{0}'',''AnalyticLinearization'',''off'');&lt;/cmd&gt; &lt;txt&gt;モデル "{0}" の解析的な線形化を無効にする。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    
    </entry>
    <entry key="SlvrJacobianValueNotSupported">slvrJacobian 値の情報を得るには、モデル ''{0}'' のソルバーは陰的なソルバーでなければなりません。値 A B C D を得るには、解析的ヤコビ メソッドを使用しなければなりません。</entry>
    <entry key="MassMatrixNotSupported">モデル ''{0}'' の質量行列がありません。</entry>
    <entry key="SolverConsecutiveZCNum">時間 {0} で、シミュレーションは、({1,number,integer}) の連続的なゼロクロッシングにヒットします。連続的なゼロクロッシングは、シミュレーションの速度を遅くし、シミュレーションがハングする原因になります。&lt;actions exclusiveFixIts="no"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{3}'',''ZeroCrossAlgorithm'',''Adaptive'');&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="ZeroCrossAlgorithm"&gt;ゼロクロッシング検出アルゴリズム&lt;/sldiag&gt;を [適応] に変更してみる。適応アルゴリズムを使用している場合、&lt;sldiag objui="configset" objparam="MaxConsecutiveZCsMsg"&gt;[連続的なゼロクロッシング違反]&lt;/sldiag&gt; の診断を [なし] に設定してこのメッセージをオフにできます。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;以下の表に示すブロックのゼロクロッシングを無効にする。 \n {2}&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" btn="apply"&gt; &lt;cmd&gt;set_param(''{3}'',''MaxConsecutiveZCsMsg'',''none'');&lt;/cmd&gt; &lt;txt&gt;この診断を無効にするには、&lt;sldiag objui="configset" objparam= "MaxConsecutiveZCsMsg"&gt;[連続的なゼロクロッシング違反]&lt;/sldiag&gt; の診断を [なし] に設定する&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
  </entry>
    <entry key="SolverDerivConsistencyCheckFailure">''{0}'' のシミュレーションは、時間 {1} において微分の整合性チェックの失敗を引き起こします</entry>
    <entry key="SolverIgnoredZCBracketing"> シミュレーションは、({1,number,integer}) のゼロクロッシング信号に対して、時間 {0} のゼロクロッシング イベントの検索を無視しました。これらの信号は、その値がゼロクロッシングの許容誤差より小さいため、または複数の連続するゼロクロッシングが発生したため、無視されています。これは、システムに強力なチャタリングがあることを示します。 \n {2} &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion" btn="apply"&gt; &lt;cmd&gt;set_param(''{3}'',''IgnoredZcDiagnostic'',''none'');&lt;/cmd&gt; &lt;txt&gt;この診断を無効にするには、&lt;sldiag objui="configset" objparam= "IgnoredZcDiagnostic"&gt;[無視されたゼロクロッシング]&lt;/sldiag&gt; の診断を [なし] に設定する&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="SolverMaskedZC">時間 {0} で、シミュレーションによって ({1,number,integer}) 個のマスクされたゼロクロッシング (偶数のゼロクロッシング イベントをもつ信号) が見つかりました。検索アルゴリズムがこれらのゼロクロッシングのみを検出したのは、このタイム ステップに他のゼロクロッシングが存在するためです。マスクされたゼロクロッシングは、現在のタイム ステップ内に偶数のゼロクロッシングをもつゼロクロッシング信号が 1 つ以上あることにより発生します。マスクされたゼロクロッシングは、すべての場合に検出されるとは限りません。 \n {3} &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{4}'',''Refine'')&lt;/cmd&gt; &lt;txt&gt;[リファイン ファクター] を ({2,number,integer}) からさらに大きい値に増加させる&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" btn="apply"&gt; &lt;cmd&gt;set_param(''{4}'',''MaskedZcDiagnostic'',''none'');&lt;/cmd&gt; &lt;txt&gt;この診断を無効にするには、&lt;sldiag objui="configset" objparam= "MaskedZcDiagnostic"&gt;[マスクされたゼロクロッシング]&lt;/sldiag&gt; を [なし] に設定する&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="SolverMaxConsecutiveMinStepsViolated">時間 {2} で {1,number,integer} 回連続で {0} の最小ステップ サイズに違反しないようステップ サイズを減らすことはできません。シミュレーションは停止しました。これは通常、システムのスティッフが高いために発生します。モデル ''{3}'' をチェックするか、&lt;sldiag objui="configset" objparam="MaxConsecutiveMinStep"&gt;[連続的な最小ステップ数]&lt;/sldiag&gt; を増やしてください</entry>
    <entry key="SolverMaxConsecutiveMinStepsViolatedForDAE">時間 {2} で {1,number,integer} 回連続で {0} の最小ステップ サイズに違反しないようステップ サイズを減らすことはできません。シミュレーションは停止しました。これは通常、微分代数系における代数制約が違反しているか、システムのスティッフが高いために発生します。許容誤差や、整合条件の計算の許容限界を厳しくしてみてください。問題が解決しない場合は、モデル ''{3}'' をチェックするか、&lt;sldiag objui="configset" objparam="MaxConsecutiveMinStep"&gt;[連続的な最小ステップ数]&lt;/sldiag&gt; を増やしてください</entry>
    <entry key="SolverMinStepErr">モデル ''{2}'' の時間 {1} において、最小ステップ サイズ {0} の制限のためステップ サイズを小さくできません。</entry>
    <entry key="SolverMinStepNonlinearIterWarnForDAE">
 時間 {2} で {1,number,integer} 回連続で {0} の最小ステップ サイズに違反しないようステップ サイズを減らすことはできません。これは通常、微分代数系における代数制約に違反しているか、システムのスティッフが高いために発生します。許容誤差や、整合条件の計算の許容限界を厳しくしてみてください。問題が解決しない場合は、モデル ''{3}'' をチェックするか、&lt;sldiag objui="configset" objparam="MaxConsecutiveMinStep"&gt;[連続的な最小ステップ数]&lt;/sldiag&gt; を増やしてください&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;solverprofiler.launchSolverProfiler&lt;/cmd&gt; &lt;txt&gt;ソルバー プロファイラーを開いてこのような問題を探す&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="SolverMinStepSizeCausedByShapePreserveErr">時間 {1} において {0} の最小ステップ サイズを違反せずに状態の形状の保存制約を満足するためのステップ サイズを減らすことはできません。</entry>
    <entry key="SolverMinStepSizeCausedByShapePreserveWarn">時間 {1} において {0} の最小ステップ サイズを違反せずに状態の形状の保存制約を満足するためのステップ サイズを減らすことはできません。{2} に制限したステップ サイズでシミュレーションを継続し、状態の形状の保存制約を満足するために 1 次オイラー積分手法を使用してください</entry>
    <entry key="SolverMinStepSizeWarn">時間 {2} で {1,number,integer} 回連続で {0} の最小ステップ サイズに違反しないようステップ サイズを減らすことはできません。指定した {5} の相対許容誤差を超える {4} の有効な相対許容誤差を使って、{3} に制限したステップ サイズでシミュレーションを続けます。これは通常、システムのスティッフが高いために発生します。モデル ''{6}'' をチェックするか、&lt;sldiag objui="configset" objparam="MaxConsecutiveMinStep"&gt;[連続的な最小ステップ数]&lt;/sldiag&gt; を増やしてください</entry>
    <entry key="SolverMinStepSizeWarnForDAE">
 時間 {2} で {1,number,integer} 回連続で {0} の最小ステップ サイズに違反しないようステップ サイズを減らすことはできません。指定した {5} の相対許容誤差を超える {4} の有効な相対許容誤差を使って、{3} に制限したステップ サイズでシミュレーションを続けます。これは通常、微分代数系における代数制約に違反しているか、システムのスティッフが高いために発生します。許容誤差や、整合条件の計算の許容限界を厳しくしてみてください。問題が解決しない場合は、モデル ''{6}'' をチェックするか、&lt;sldiag objui="configset" objparam="MaxConsecutiveMinStep"&gt;[連続的な最小ステップ数]&lt;/sldiag&gt; を増やしてください。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;solverprofiler.launchSolverProfiler&lt;/cmd&gt; &lt;txt&gt;ソルバー プロファイラーを開いてこのような問題を探す&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="SolverNonlIterMinStepErr">
 非線形の反復が時間 {1} で hmin {0} に縮小されたステップ サイズに収束していません。最小ステップ サイズを小さくしたり、相対許容誤差を緩和してみてください。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;solverprofiler.launchSolverProfiler&lt;/cmd&gt; &lt;txt&gt;ソルバー プロファイラーを開いてこのような問題を探す&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="SolverOutputAssertConsoleErrMsg">出力の整合性チェックは、''{3}'' の端子 {2,number,integer} の出力要素 {1,number,integer} に対して時間 {0} で失敗しました。\n</entry>
    <entry key="SolverOutputAssertDlgErrMsg">''{0}'' のシミュレーションは、出力の不整合のため停止しました</entry>
    <entry key="SolverOutputAssertForDblsConsoleErrMsg">出力の整合性チェックは、''{3}'' の端子 {2,number,integer} の出力要素 {1,number,integer} に対して時間 {0} で失敗しました。\n   予想値: {4}\n   実際の値  :{5}\n</entry>
    <entry key="SolverStateConsistencyCheckFailure">''{0}'' のシミュレーションは、時間 {1} において状態の整合性チェックの失敗を引き起こします</entry>
    <entry key="SolverZCConsistencyCheckFailure">
 ''{0}'' のシミュレーションにより、時間 {1} にゼロクロッシング整合性チェック エラーが発生します&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;solverprofiler.launchSolverProfiler&lt;/cmd&gt; &lt;txt&gt;ソルバー プロファイラーを開いてこのような問題を探す&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="SortAlgLoopThruIntegrator" context="warning">Integrator ブロックのリセット端子または初期条件端子が 1 つ以上の代数ループ パスの一部であるため、シミュレーション結果が予期しない、または直観的ではないものになることがあります。Integrator ブロックの使用時に代数ループを避けるには、状態端子を使用してください。</entry>
    <entry key="SortDiscontinuityInAlgLoop" context="warning">1 つ以上の代数ループで検出された不連続が原因で、代数ループ ソルバーのループ解決が妨げられることがあります。</entry>
    <entry key="SortICInAlgLoop" context="warning">IC ブロック ''{0}'' は ''{1}'' ''{2}'' によって駆動されているため、代数ループの一部である IC ブロック ''{0}'' は無視されます。</entry>
    <entry key="SourceLoopError">信号の次元を定義できません。信号の次元が巡回的な関係で定義されるため、''{0}'' から構成される関連付けられないループがあります。Inport、Mux、Selector、Demux 上の信号の次元を指定すると、ループ内の信号の次元を関連付けるのに役立ちます。信号の次元を定義するために、Signal Specification ブロックを使用することもできます。</entry>
    <entry key="SrcsCannotHaveDynamicDimensionsMode">ソース ''{0}'' は、その出力端子 {1,number,integer} に設定している次元モードを継承できませんでした。すべてのソースのすべての出力端子を固定サイズまたは可変サイズのモードに明示的に設定する必要があります。</entry>
    <entry key="SrcsCannotHaveDynamicFrameData">Source ''{0}'' cannot have dynamic frame data (inherit SamplingMode) setting for its output port {1,number,integer}. All sources should explicitly set all their output ports to be FRAME_YES (Frame) or FRAME_NO (Sample)</entry>
    <entry key="StandaloneNoCStates">サブシステム ''{0}'' は、別々のデータと初期化をもつ関数として設定されています。この設定を使用するサブシステムに連続状態を含めることはできません。Subsystem ブロックの ''別々のデータと初期化'' オプションの選択を解除してください。</entry>
    <entry key="StandaloneNoContTime">サブシステム ''{0}'' は別々のデータと初期化をもつ関数として設定されており、連続サンプル時間をもつブロックがあります。この設定を使用するサブシステムは、離散サンプル時間のみ持たなければなりません。</entry>
    <entry key="StandaloneNoMdlRef">モデル ''{0}'' は、別々のデータと初期化をもつ関数として設定されたサブシステム ''{1}'' を含みます。この設定を使用するサブシステムは、モデル参照のコード生成ターゲットをサポートしません。</entry>
    <entry key="StandaloneNoMultiInstanceERT">モデル ''{0}'' に、別個のデータと初期化をもつ関数として構成されたサブシステム ''{1}'' が含まれています。この構成を使用するサブシステムは、&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;[コード インターフェイスのパッケージ化]&lt;/sldiag&gt; が [C++ クラス] または [再利用可能な関数] に設定されている場合はサポートされません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;Simulink.internal.OpenBlockParamsDialog(''{1}'',''FunctionWithSeparateData'')&lt;/cmd&gt; &lt;txt&gt;[別々のデータをもつ関数] をオフにする&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''CodeInterfacePackaging'')&lt;/cmd&gt; &lt;txt&gt;[コード インターフェイスのパッケージ化] を [再利用できない関数] に設定する (参照先や参照元のモデルに影響する可能性があります)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="StandaloneNoMultiRate">サブシステム ''{0}'' は別々のデータと初期化をもつ関数として設定されており、複数のサンプル時間を持ちます。この設定を使用するサブシステムは、単一のレートでなければなりません。</entry>
    <entry key="StandaloneNoNoninlinedSfcns">サブシステム ''{0}'' は別々のデータと初期化をもつ関数として設定されており、TLC ファイルを持たない S-Function ''{1}'' を含みます。この設定を使用するサブシステムは、インライン化された S-Function のみサポートします。</entry>
    <entry key="StandaloneOutFedByProbeBlock">Probe ブロック ''{0}'' は、別々のデータと初期化をもつ関数として設定されているサブシステム ''{1}'' の出力端子に接続されています。Probe ブロックはグローバル データをサポートしないため、Probe ブロックとサブシステムの出力端子間に Signal Conversion ブロックを置いてください。</entry>
    <entry key="StandaloneOutFedByWidthBlock">Width ブロック ''{0}'' は、別々のデータと初期化をもつ関数として設定されているサブシステム ''{1}'' の出力端子に接続されています。Width ブロックはグローバル データをサポートしないため、Width ブロックとサブシステムの出力端子間に Signal Conversion ブロックを置いてください。</entry>
    <entry key="StandaloneOutputFcnCall">サブシステム ''{0}'' は、別々のデータと初期化をもつ関数として設定されています。サブシステムは、関数呼び出し信号を出力できません。Subsystem ブロックの ''別々のデータと初期化'' オプションの選択を解除してください。</entry>
    <entry key="StartTimeCorrected">  指定されたシミュレーションの開始時間 ({0}) は固定ステップ サイズ ({1}) の整数倍ではありません。開始時間を ({2}) に変更しています。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" retvalue="false"&gt; &lt;cmd&gt;set_param(''{3}'',''StartTime'',''__startTime__'');&lt;/cmd&gt; &lt;cargs&gt; &lt;carg name="__startTime__" type="text"&gt; &lt;txt_prompt&gt;開始時間を入力:&lt;/txt_prompt&gt; &lt;/carg&gt; &lt;/cargs&gt; &lt;txt&gt;シミュレーションの開始時間に固定ステップ サイズの整数倍を指定する。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" btn="apply"&gt; &lt;cmd&gt;set_param(''{3}'', ''SolverPrmCheckMsg'',''none'');&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="SolverPrmCheckMsg"&gt;[自動ソルバー パラメーターの選択]&lt;/sldiag&gt; の診断を [なし] に設定する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
  </entry>
    <entry key="StateEnableSignalMustBeScalar">''{0}'' の イネーブル入力端子の次元を設定できません。イネーブル信号はスカラーの信号でなければなりません。</entry>
    <entry key="StateEnabledOrTriggeredSubsystemMustBeSingleRate1">サブシステム ''{0}'' は enable 端子または trigger 端子を含んでおり、同期モードであるため、そのサブシステム内のすべてのブロックは同じサンプル時間でなければなりません。</entry>
    <entry key="StateEnabledOrTriggeredSubsystemMustBeSingleRate2">サブシステム ''{0}'' は enable 端子または trigger 端子を含んでおり、同期モードであるため、そのサブシステムへのすべての信号はサブシステムと同じサンプル時間でなければなりません。</entry>
    <entry key="StateEnabledOrTriggeredSubsystemMustHaveDiscreteOrTrigTs">サブシステム ''{0}'' は enable 端子または trigger 端子を含んでいるため、離散サンプル時間またはトリガー サンプル時間でなければなりません。</entry>
    <entry key="BlockWithStatesModifiedInOutputUpdateInAlgLoop">''{0}'' またはこれによって参照されるモデルには、出力の計算中に永続変数または状態変数を更新するブロックが含まれていて、1 つの代数ループではサポートされていません。これは、次のブロックをもつ代数ループです。</entry>
    <entry key="BlocksInSubsystemWithStatesModifiedInOutputUpdateInAlgLoop">''{0}'' またはこれによって参照されるモデルには、出力の計算中に永続変数または状態変数を更新する複数のブロックが含まれていて、代数ループではサポートされていません。親サブシステム ''{1}'' は、次のブロックをもつ代数ループです。</entry>
    <entry key="StatePerturbationMustBeScalar">ブロック ''{0}'' に対する状態の摂動レベルは、スカラー変数でなければなりません。</entry>
    <entry key="StatePortCannotFeedOutport">状態端子は、非バーチャル サブシステムの出力端子に接続できません。出力端子 ''{0}'' に接続違反があります</entry>
    <entry key="StateResetForFCSSWithNonExplicitInit">ブロック ''{0}'' の"イネーブル時の状態" パラメーターは "リセット" に設定できません。関数呼び出し開始プログラム ''{1}'' がその接続先を明示的にイネーブルまたはディセーブルに設定しないため、"継承" か "保持" のみに設定できます。</entry>
    <entry key="StopAndCloseRunningModel">''{0}'' は実行中です。実行を停止してモデルを閉じますか?</entry>
    <entry key="StopAndCloseRunningModelInFastRestart">''{0}'' は高速リスタートで実行中です。高速リスタートを終了し、モデルを閉じますか?</entry>
    <entry key="StopAndCloseModelInitializedInFastRestart">''{0}'' は高速リスタートで初期化されます。高速リスタートを終了し、モデルを閉じますか?</entry>
    <entry key="StopAndCloseRunningModelInExternalMode">''{0}'' はエクスターナル モードでターゲットに接続されています。接続を切断してモデルを閉じますか?</entry>
    <entry key="CannotChangeFastRestartWhenStepping">シミュレーション中に高速リスタートを有効または無効にできません</entry>
    <entry key="FastRestartNotSupportedInThisMode">高速リスタートは、ノーマル モードまたはアクセラレータ モードでのみサポートされています。''set_param(''{0}'', ''FastRestart'', ''off'')'' を使用して高速リスタートを無効にできます。</entry>
    <entry key="FastRestartArgNotSupportedInThisMode">高速リスタートは、ノーマル モードまたはアクセラレータ モードでのみサポートされています。</entry>
    <entry key="FastRestartSingleSimulationOutput">複数の出力引数を返す関数 sim の構文は一般的に推奨されず、また、モデル ''{0}'' で高速リスタートが有効になっている場合はサポートされません。シミュレーション結果を単一の出力引数として返す、ドキュメント化された構文を使用してください。</entry>
    <entry key="LiveTuningArgNotSupportedInThisMode">オプション ''LiveTuning'' は、ノーマル モードおよびアクセラレータ モードでのみ有効です。</entry>
    <entry key="StopTimeCorrected">  指定されたシミュレーションの終了時間 ({0}) は固定ステップ サイズ ({1}) の整数倍ではありません。終了時間を ({2}) に変更しています。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" retvalue="false"&gt; &lt;cmd&gt;set_param(''{3}'',''StopTime'',''__stopTime__'');&lt;/cmd&gt; &lt;cargs&gt; &lt;carg name="__stopTime__" type="text"&gt; &lt;txt_prompt&gt;終了時間を入力:&lt;/txt_prompt&gt; &lt;/carg&gt; &lt;/cargs&gt; &lt;txt&gt;シミュレーションの終了時間に固定ステップ サイズの整数倍を指定する。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" btn="apply"&gt; &lt;cmd&gt;set_param(''{3}'', ''SolverPrmCheckMsg'',''none'');&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="SolverPrmCheckMsg"&gt;[自動ソルバー パラメーターの選択]&lt;/sldiag&gt; の診断を [なし] に設定する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
  </entry>
    <entry key="StructFormatNotCompatible">与えられた MATLAB 配列の構造体データは、Simulink の非バーチャル バス データと互換性がありません</entry>
    <entry key="SubsystemCannotBeReusableForMultiInstanceCode">''{0}'' が再利用可能な関数を生成できないため、モデルは、入出力が個別の引数として渡される再利用可能なコードを生成できません。&lt;sldiag objui="configset" objparam="RootIOFormat"&gt;[ルートレベル I/O を以下として渡す]&lt;/sldiag&gt; を [構造体参照] に変更することを検討してください。または &lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;[コード インターフェイスのパッケージ化]&lt;/sldiag&gt; を [再利用できない関数] に設定することを検討してください。</entry>
    <entry key="SubsystemCannotBeReusableForMultiInstanceCodeCPP">''{0}'' は、C++ クラス インターフェイスを生成する際に必要とされる再利用可能な関数を生成できません。&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;[コード インターフェイスのパッケージ化]&lt;/sldiag&gt; を [C++ クラス] 以外の値に設定することを検討してください</entry>
    <entry key="SubsystemChangedToBeReusableNotSupportedInInplace">''{0}'' の実装を再利用可能な関数に変更しなければならない場合、上書き指定はサポートされません。このブロックの [関数のパッケージ化] を [再利用可能な関数] に設定してください。</entry>
    <entry key="SubsystemChangedToBeReusableForMultiInstanceCode">生成されたコードが再利用可能になるように、''{0}'' の実行を再利用可能な関数に変更しようとしています。</entry>
    <entry key="SubsystemChangedToBeReusableInsideServer">''{0}'' はサーバー ブロック ''{1}'' の内部にあるため、その実装を再利用可能な関数に変更しています</entry>
    <entry key="StandaloneNoServer">モデル ''{0}'' は、別個のデータと初期化をもつ関数として構成されたサブシステム ''{1}'' を含みます。この構成を使用するサブシステムはサーバー ブロックの内部ではサポートされていませんが、そのサブシステムはサーバー ブロック ''{2}'' の内部にあります</entry>
    <entry key="SubsystemNonReusableInReusableSubsysCPP">''{0}'' は、[コード生成関数のパッケージ化] パラメーターの値 [再利用できない関数] を使用するサブシステム、または Simulink Function ですが、その先祖サブシステム ''{1}'' では [再利用可能な関数] オプションを使用しています。これは、C++ クラス インターフェイスを生成する場合は許可されません。前者のサブシステムのオプションを [再利用可能な関数] に変更するか、後者のサブシステムのオプションを [再利用できない関数] に変更することを検討してください</entry>
    <entry key="SuppressErrStNotSupportNonInlinedSF">ブロック ''{0}'' はインラインでない S-Function ブロックです。これは、&lt;sldiag objui="configset" objparam="SuppressErrorStatus"&gt;[リアルタイム モデル データ構造体のエラー ステータス フィールドを削除]&lt;/sldiag&gt; がオンの場合はサポートされません。オプションの選択を解除するか、またはブロックを削除することを検討してください。</entry>
    <entry key="SuppressErrorStatusNotSupportCTime">モデル ''{0}'' で、&lt;sldiag objui="configset" objparam="SupportContinuousTime"&gt;[サポート] の [連続時間]&lt;/sldiag&gt; と &lt;sldiag objui="configset" objparam="SuppressErrorStatus"&gt;[リアルタイム モデル データ構造体のエラー ステータス フィールドを削除]&lt;/sldiag&gt; の両方がオンになっています。この構成はサポートされません。これらのオプションの 1 つは、このモデルをビルドするために選択をはずさなければなりません。</entry>
    <entry key="SwitchedReusedToNonreused">子システムが明示的に再利用不可とマークされている、または再利用不可の設定で利用されているため、サブシステム ''{0}'' の ''Reusable function'' 設定を ''Nonreused function'' に変換します。コードを生成する時、HTML レポートを作成してください。詳細は「Subsystems」節を参照してください</entry>
    <entry key="ConnToModelRefFcnCallInitiator">Subsystem ブロック ''{0}'' に、Model 参照ブロックの関数呼び出し端子に接続された出力関数呼び出しがあります。このため、''{0}'' サブシステムが再利用されません。この警告を回避するには、''{0}'' の [関数のパッケージ化] パラメーターを [インライン] に変更してください。</entry>
    <entry key="CompositeRateSubsysToRootOutport">Subsystem ブロック ''{0}'' はエクスポート関数モデル内にあります。Subsystem ブロックは、共用体のレートをもち、ルート出力端子に接続されています。このため、''{0}'' サブシステムが再利用されません。この警告を回避するには、''{0}'' の [関数のパッケージ化] パラメーターを [インライン] に変更してください。</entry>
    <entry key="SysGenSameFcnAsMdl">サブシステム ''{0}'' で設定されている関数名 ({1}) は、モデル ''{2}'' と同じ名前です。このサブシステムに設定されている関数名を変更してください</entry>
    <entry key="SysGenSameFileAsMdl">サブシステム ''{0}'' は、モデル ''{2}'' に対して予約されているファイル ({1}) へのコードを生成しようとしています。このサブシステムに設定されているファイル名を変更してください</entry>
    <entry key="SysIllegalFileName">サブシステム ''{0}'' は、名前が ''rt_sys'' で始まるファイル ({1}) にコードを生成しようとしています。これは、Simulink Coder で予約されている識別子です。このサブシステムのファイル名設定を変更してください</entry>
    <entry key="TagEmpty">タグは空にできません</entry>
    <entry key="Target_BadTFLSource">コード置換ライブラリ ''{0}'' が見つからないか、有効なテーブルを含んでいません。</entry>
    <entry key="Target_FailedToGetHostWordLengths">ホストの語長の取得がエラーで失敗しました。</entry>
    <entry key="TipAlert_AutoConnectionDescription">ブロックを簡単に結合するには、ソース ブロックを選択し、CTRL キー\nを押しながら目的のブロックを左クリックしてください。</entry>
    <entry key="TipAlert_AutoConnectionTitle">自動ブロック結合のヒント</entry>
    <entry key="TnextMustBeScalar">flag={2,number,integer} の呼び出し中に ''{1}'' の S-function ''{0}'' で出力された次のヒット時間は、実数のスカラーでなければなりません。</entry>
    <entry key="TrigSSDataInputPortsInLoop">''{1}'' の入力端子 {0} は、ループ内にあります。Triggered Subsystem や Model ブロックを含むループを削除するには、適切な入力端子で [外部信号を遅延して入力をラッチ] を指定してください。</entry>
    <entry key="TrigSSEnabPortInLoop">Enabled and Triggered Subsystem のイネーブル入力端子または Model ブロック ''{0}'' がループ内にあります。これにより、時間 t でのイネーブル信号が時間 t でのサブシステムまたは Model ブロックの出力に依存するため、あいまいな実行を引き起こします。Memory ブロックを使用してループを解除できます。</entry>
    <entry key="TrigSSTrigPortInLoop">Triggered Subsystem または Model ブロック ''{0}'' のトリガー入力端子がループ内にあります。これにより、時間 t でのトリガー信号が時間 t における Triggered Subsystem または Model ブロックの出力に依存するため、あいまいな実行順序を引き起こします。Memory を使ってループを解除できます。</entry>
    <entry key="TrigSigMustBeRealDouble">エクスターナル モードのトリガー信号は、ターゲットのみの整数に対して ''int32'' のタイプ、それ以外のすべてに対して ''double'' か非複素数でなければなりません。</entry>
    <entry key="TrigStateflowDataInputPortsInLoop">Triggered Stateflow チャート ''{1}'' の入力端子 {0} は、ループ内にあります。Memory ブロックを使って Triggered Stateflow チャート内のループを削除できます</entry>
    <entry key="TriggerECPotentialPreStartOutputDiff">''{0}'' の出力は、''{1}'' が t = 0 でトリガーされていない場合、以前の Simulink のリリースと異なる結果を生成する可能性があります。ブロック ''{2}'' はゼロの入力に対して非ゼロの出力を生成する可能性があり、''{3}'' の実行コンテキストが継承されています。以前のリリースでは、''{4}'' は実行コンテキストは継承されず、条件付きサブシステムの開始前に非ゼロの出力を生成した可能性があります。コンテキストを継承させないようにするには、再計算させたい信号のレートに ''{5}'' のサンプル時間を明示的に設定します。この警告メッセージをオフにするには、&lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;[実行コンテキストのアクティブになる前の出力をチェック]&lt;/sldiag&gt; をオフにしてください。</entry>
    <entry key="TriggerECPotentialPreStartOutputDiffConsistentOutportInit">''{0}'' の出力は、''{1}'' が t = 0 でトリガーされていない場合、以前の Simulink のリリースと異なる結果を生成する可能性があります。ブロック ''{2}'' はゼロの入力に対して非ゼロの出力を生成する可能性があり、''{3}'' の実行コンテキストが継承されています。以前のリリースでは、''{4}'' は実行コンテキストは継承されず、条件付きサブシステムの開始前に非ゼロの出力を生成した可能性があります。コンテキストを継承させないようにするには、再計算させたい信号のレートに ''{5}'' のサンプル時間を明示的に設定します。この警告メッセージをオフにするには、&lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;[実行コンテキストのアクティブになる前の出力をチェック]&lt;/sldiag&gt; をオフにしてください。</entry>
    <entry key="TriggeredFcnCallCannotBeITVS">Function-Call Port ブロック ''{0}'' は [サンプル時間タイプ] パラメーターの設定が無効です。[可変サイズの信号のサイズを伝播] が ''イネーブルのときのみ'' に設定されている場合、[サンプル時間タイプ] オプションは ''周期的'' でなければなりません。</entry>
    <entry key="InitTrigStateCannotBeNegative">対応する親サブシステムのトリガー端子のデータ型 ''{1}'' が符号なしであるため、Trigger Port ブロック ''{0}'' のパラメーター [トリガー信号の初期状態] に [負] を指定できません。</entry>
    <entry key="UnableRepresentDataInFi">ブロック ''{1}'' に関連する固定小数点データ型 ''{0}'' に対して fi オブジェクトを作成できません。</entry>
    <entry key="UnableRepresentModelDataInFi">固定小数点データ型 ''{0}'' の fi オブジェクトは作成できません。</entry>
    <entry key="UnableRepresentDataInMatlab">Simulink の内部データを保存するための適切な MATLAB データ型が見つかりません</entry>
    <entry key="UnableRepresentDataInMatlabErr">''{1}'' に対するタイプ ''{0}'' の Simulink の内部データを保存するための適切な MATLAB データ型が見つかりません</entry>
    <entry key="UnableToHonorPriority">ユーザー指定のブロック優先順位に従うことができません。データの依存関係を満たすには、ブロック優先順位 {1} をもつ ''{0}'' を、より高いブロック優先順位 {3} をもつ ''{2}'' より前に実行しなければなりません。</entry>
    <entry key="UnableToHonorPriorityInTask">サンプル時間 {5} を使ってブロックの実行をスケジュールするタスク {4,number,integer} で、ユーザー指定のブロック優先順位に従うことができません。データの依存関係を満たすには、ブロック優先順位 {1} をもつ ''{0}'' を、より高いブロック優先順位 {3} をもつ ''{2}'' より前に実行しなければなりません。</entry>
    <entry key="UnableToHonorPriorityInTask0">離散または連続のサンプル時間を使ってブロックの実行をスケジュールするタスク {4,number,integer} で、ユーザー指定のブロック優先順位に従うことができません。データの依存関係を満たすには、ブロック優先順位 {1} をもつ ''{0}'' を、より高いブロック優先順位 {3} をもつ ''{2}'' より前に実行しなければなりません。</entry>
    <entry key="UnableToHonorPriorityInConstTask">定数のサンプル時間をもつブロックについて、ユーザー指定のブロック優先順位に従うことができません。データの依存関係を満たすには、ブロック優先順位 {1} をもつ ''{0}'' を、より高いブロック優先順位 {3} をもつ ''{2}'' より前に実行しなければなりません。</entry>
    <entry key="UnableToLoadBd">ブロック線図 ''{0}'' を読み込むことができません</entry>
    <entry key="PossibleSimulationResultsMismatchForCodeGen">ルートの入力端子 ''{0}'' およびルートの出力端子 ''{1}'' が再利用されるため、.mat ファイルから取得した結果と他のシミュレーション モードからの結果が同一であると保証できません。</entry>
    <entry key="UnableToLocateRTWNameInBd">モデル ''{1}'' 内の Simulink Coder ブロックまたはシステム名 ''{0}'' の位置を特定できませんでした</entry>
    <entry key="UnableToSolveAlgLoop">ブロック ''{0}'' を含む代数ループを解くことができません。これは、Stateflow チャート、非バーチャル サブシステム、複素出力信号をもつブロック、離散サンプル時間または double 以外のデータ型の出力をもつブロックなど、代数変数の代入をサポートしない 1 つ以上のブロックがループに含まれているためです。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;ループ内の信号が離散サンプル時間をもつ場合、ループに Delay ブロックや Memory ブロックなどのブロックを追加して、ループを中断する。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;ループ内の信号が連続サンプル時間をもつ場合、システム ダイナミクスに影響を与えないように十分に小さい時定数で 1 次システムを実装する Transfer Function ブロックのような連続ブロックを追加して、ループを中断する。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;ループの詳細情報を得るために、関数 Simulink.BlockDiagram.getAlgebraicLoops を使用する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;</entry>
    <entry key="UnableToUpdateDisplayInRapidAccelMode">ラピッド アクセラレータ モードは、''{0}'' のようないくつかの可視化ブロックを更新しません。可視化ブロックを最大限に活用するには、ノーマル モードまたはアクセラレータ モードでモデルを実行してください。</entry>
    <entry key="UnconnLine">未接続のラインが ''{0}'' で見つかりました (ビューの左から {1,number,integer}% および最上部から {2,number,integer}% で開始)</entry>
    <entry key="UnconnLineOutsideWindow">接続されていないラインが ''{0}'' で見つかりました (現在のビューの外側)</entry>
    <entry key="UnnamedRegsitryItem">名前のない項目をレジストリに追加することはできません。</entry>
    <entry key="UnresolvedPassThroughLoop">Simulink は、''{0}'' で可変サイズのブロックを含む無効なループを検出しました。ループはブロックと対応する端子で構成されています。これらの出力端子の次元を示すブロックのすべては、個別の入力端子の次元と一致しなければなりません。(S-function の場合は、''ssSetInputDimsSameAsOutputDims'' が使われます)。その結果、ループ内のブロックは、どのタイム ステップにおいても実際の端子次元が設定されません。次のループの外部の入力端子に対応するブロックと端子インデックス: {1}。</entry>
    <entry key="UnsupportedBlockJacobian">このブロックのヤコビアンはサポートされません。</entry>
    <entry key="VerySmallMaxStepSize">モデル ''{0}'' には高周波数のソース ブロックがあるため、そのモデルの自動ステップ サイズとして {1} が選択されています。シミュレーションを完了するには、少なくとも {2} 個のシミュレーション ステップが必要です。シミュレーション ステップ数を削減するには、停止時間を減少させるか、あるいは最大ステップ サイズを大きくします。</entry>
    <entry key="VerySmallFixedStepSize">モデル ''{0}'' には高周波数のソース ブロックがあるため、そのモデルの自動ステップ サイズとして {1} が選択されています。シミュレーションを完了するには、{2} 個のシミュレーション ステップが必要です。シミュレーション ステップ数を削減するには、停止時間を減少させるか、あるいは固定ステップ サイズを大きくします。</entry>
    <entry key="UsingDefaultMaxStepSize">モデル ''{0}'' は、最大ステップ サイズに {1} の既定値を使用しています。&lt;sldiag objui="configset" objparam="SolverPrmCheckMsg"&gt;[自動ソルバー パラメーターの選択]&lt;/sldiag&gt; を [なし] に設定することで、この診断を無効にできます</entry>
    <entry key="UsingDiscreteSolver">モデル ''{0}'' は連続の状態を含みません。したがって、Simulink はソルバー ''{2}'' の代わりに ''{1}'' のソルバーを使用しています。&lt;sldiag objui="configset" objparam="Solver"&gt;[ソルバー]&lt;/sldiag&gt; で離散ソルバーを明示的に指定するか &lt;sldiag objui="configset" objparam="SolverPrmCheckMsg"&gt;[自動ソルバー パラメーターの選択]&lt;/sldiag&gt; を [なし] に設定することで、この診断を無効にできます</entry>
    <entry key="AutoSolverHighNx">このモデルについて、自動ソルバーのスティッフ チェックはサポートされていません。連続状態の数 ''{0}'' がしきい値 ''{1}'' を超えているためです。しきい値を変更するには、MATLAB コマンド ラインで ''NumStatesForStiffnessChecking'' モデル パラメーターを設定します。</entry>
    <entry key="EnableRuntimeSolverSwitching">ブロック線図 ''{0}'' のヒューリスティックをオンにする前に、実行時のソルバーの切り替えを有効にしなければなりません。</entry>
    <entry key="RuntimeSolverSwitchingInvalidSolver">実行時のソルバーの切り替えは VariableStepAuto ソルバーでのみサポートされています。ブロック線図 ''{0}'' のソルバーを変更してください。</entry>
    <entry key="AutoSolverRuntimeInvalidParamNames">ブロック線図 ''{0}'' で EnableRuntimeSolverSwitching には無効な入力が指定されました。次のパラメーター名が無効です: ''{1}''。</entry>
    <entry key="AutoSolverRuntimeInvalidParamValues">ブロック線図 ''{0}'' の EnableRuntimeSolverSwitching には無効な入力です。次のパラメーターの値が無効です: ''{1}''。</entry>
    <entry key="AutoSolverRuntimeInvalidParamNamesAndValues">ブロック線図 ''{0}'' の EnableRuntimeSolverSwitching には無効な入力です。次のパラメーター名が無効です: ''{1}''。次のパラメーターの値が無効です: ''{2}''。</entry>
    <entry key="ValueLabelSignalReuseClashPart1">[信号ストレージの再利用] はこのモデルでオンです。そのため、ブロックの出力端子の表示は正しくない可能性があります。</entry>
    <entry key="ValueLabelSignalReuseClashPart2">かまわずに端子表示をオンにする場合は [OK] を選択し、現在の設定を保持する場合は [キャンセル] を選択します。</entry>
    <entry key="VarDimRulesExceedMaxNumber">''{1}'' の伝播する次元依存の規則 ({0,number,integer}) の数は、モデル内で許可された最大の規則数 ({2,number,integer}) を超えました。''set_param(modelname, ''MaxNumVariableDimRules'', N)'' を使用してこの設定を変更できますが、ブロック線図を更新することで同じ結果になる可能性があります。</entry>
    <entry key="VarDimsBlockExecTimeWithBlockRequestStateResetSizeVary">ブロック ''{0}'' には、入力信号のサイズが変わるたびにリセットが必要な状態が含まれています。このブロックのプロパティは、''{1}'' のブロックのプロパティと一致しません。ブロック ''{2}'' の出力信号のサイズは入力信号の値に依存します。Enabled/Function-Call/Action/Resettable Subsystem 内に ''{3}'' を配置し、対応する制御端子ブロックのパラメーター [可変サイズの信号のサイズを伝播] を [イネーブルのときのみ] (Enabled Subsystem または Function-Call Subsystem の場合)、[実行の再開時のみ] (Action Subsystem の場合) または [リセット時のみ] (Resettable Subsystem の場合) に設定することを検討してください。</entry>
    <entry key="VarDimsBlockRequestStateResetNonModelRef">ブロック ''{0}'' には、入力信号のサイズが変わるたびにリセットが必要な状態が含まれています。しかし、Simulink はこのブロックがイネーブルの場合にのみ信号のサイズを設定できます。Enabled/Function-Call/Action/Resettable Subsystem 内に ''{1}'' を配置し、対応する制御端子ブロックのパラメーター [可変サイズの信号のサイズを伝播] を [イネーブルのときのみ] (Enabled Subsystem または Function-Call Subsystem の場合)、[実行の再開時のみ] (Action Subsystem の場合) または [リセット時のみ] (Resettable Subsystem の場合) に設定することを検討してください。</entry>
    <entry key="VarDimsBusElementNotAllowed">{0} は、可変サイズの要素を含む非バーチャル バスをサポートしません。</entry>
    <entry key="VarDimsContextNotResetBlockRequestStateResetSizeVary1">ブロック ''{0}'' は、入力信号のサイズを変更したときにリセットする必要のある状態を含んでいます。''{1}'' の [イネーブル時の状態] パラメーターを ''リセット'' に変更することを検討してください。</entry>
    <entry key="VarDimsContextNotResetBlockRequestStateResetSizeVary2">ブロック ''{0}'' は、入力信号のサイズを変更したときにリセットする必要のある状態を含んでいます。''{1}'' の [実行を再開時の状態] パラメーターを ''リセット'' に変更することを検討してください。</entry>
    <entry key="VarDimsExecTimeContextModelBlockInitTime">サブシステム ''{0}'' には、制御端子ブロック ''{1}'' とモデル ブロック ''{2}'' が含まれています。制御端子ブロック ''{3}'' に対して、[可変サイズの信号のサイズを伝播] のパラメーターは ''実行中'' に設定されています。加えて、モデル ブロックには次のいずれかのプロパティがあります。1) モデル ブロックは、入力信号のサイズを変更したときにリセットする必要のある状態を含んでいます。2) 参照モデル ''{4}'' の [コンフィギュレーション パラメーター] &gt; [モデル参照] &gt; [可変サイズの信号のサイズを伝播] が ''イネーブルのときのみ'' に設定されています。''{5}'' の [可変サイズの信号のサイズを伝播] パラメーターを ''イネーブルのときのみ'' に変更することを検討してください。</entry>
    <entry key="VarDimsExecTimeContextModelBlockInitTimeAction">サブシステム ''{0}'' には、制御端子ブロック ''{1}'' とモデル ブロック ''{2}'' が含まれています。制御端子ブロック ''{3}'' に対して、[可変サイズの信号のサイズを伝播] のパラメーターは ''実行中'' に設定されています。加えて、モデル ブロックには次のいずれかのプロパティがあります。1) モデル ブロックは、入力信号のサイズを変更したときにリセットする必要のある状態を含んでいます。2) 参照モデル ''{4}'' の [コンフィギュレーション パラメーター] &gt; [モデル参照] &gt; [可変サイズの信号のサイズを伝播] が ''イネーブルのときのみ'' に設定されています。''{5}'' の [可変サイズの信号のサイズを伝播] パラメーターを ''実行の再開時のみ'' に変更することを検討してください。</entry>
    <entry key="VarDimsExecTimeContextModelBlockInitTimeReset">サブシステム ''{0}'' には、制御端子ブロック ''{1}'' とモデル ブロック ''{2}'' が含まれています。制御端子ブロック ''{3}'' に対して、[可変サイズの信号のサイズを伝播] のパラメーターは [実行中] に設定されています。加えて、モデル ブロックは次のいずれかの特性をもちます。1) モデル ブロックは、入力信号のサイズが変更されたときにリセットが必要な状態を含む。2) 参照モデル ''{4}'' の [コンフィギュレーション パラメーター]、[モデル参照]、[可変サイズの信号のサイズを伝播] が [イネーブルのときのみ] に設定されている。''{5}'' の [可変サイズの信号のサイズを伝播] パラメーターを [リセット時のみ] に変更することを検討してください。</entry>
    <entry key="VarDimsExecTimeContextRequestStateResetSizeVary">ブロック ''{0}'' は、入力信号のサイズを変更したときにリセットする必要のある状態を含んでいます。しかし、このブロックを含むサブシステムは、[実行中に可変サイズの信号のサイズを伝播] に設定されています。''{1}'' に対する状態のリセットは、サブシステムをイネーブルにしたときのみ発生します。''{2}'' の [可変サイズの信号のサイズを伝播] パラメーターを ''イネーブルのときのみ'' に変更することを検討してください。</entry>
    <entry key="VarDimsExecTimeContextRequestStateResetSizeVaryAction">ブロック ''{0}'' は、入力信号のサイズを変更したときにリセットする必要のある状態を含んでいます。しかし、このブロックを含むサブシステムは、[実行中に可変サイズの信号のサイズを伝播] に設定されています。''{1}'' に対する状態のリセットは、サブシステムの実行を再開したときのみ発生します。''{2}'' の [可変サイズの信号のサイズを伝播] パラメーターを ''実行の再開時のみ'' に変更することを検討してください。</entry>
    <entry key="VarDimsExecTimeContextRequestStateResetSizeVaryReset">ブロック ''{0}'' には、入力信号のサイズが変更されたときにリセットが必要な状態が含まれています。しかし、このブロックを含むサブシステムは、[実行中に可変サイズの信号のサイズを伝播] に設定されています。''{1}'' の状態のリセットは、サブシステムをリセットしたときにのみ発生します。''{2}'' の [可変サイズの信号のサイズを伝播] パラメーターを [リセット時のみ] に変更することを検討してください。</entry>
    <entry key="VarDimsInitTimeContextModelBlockExecTime">サブシステム ''{0}'' には、制御端子ブロック ''{1}'' とモデル ブロック ''{2}'' が含まれています。制御端子ブロック ''{3}'' に対して、[可変サイズの信号のサイズを伝播] のパラメーターは ''イネーブルのときのみ'' に設定されています。加えて、モデル ブロックには次のいずれかのプロパティがあります。1) モデル ブロックには、出力信号のサイズが入力信号の値によって変わるブロックが含まれています。2) 参照モデル ''{4}'' の [コンフィギュレーション パラメーター] &gt; [モデル参照] &gt; [可変サイズの信号のサイズを伝播] が ''実行中'' に設定されています。''{5}'' の [可変サイズの信号のサイズを伝播] パラメーターを ''実行中'' に変更することを検討してください。</entry>
    <entry key="VarDimsInitTimeContextSizeDependOnValue">ブロック ''{0}'' の出力信号サイズは入力信号の値に依存します。しかし、このブロックを含むサブシステムは、[イネーブル時のみ可変サイズの信号のサイズを伝播] に設定されています。このパラメーター設定をもつサブシステムの外にこのブロックを配置するか、''{1}'' の [可変サイズの信号のサイズを伝播] パラメーターを [実行中] に変更することを検討してください。</entry>
    <entry key="ResetSSVarDimsInitTimeContextSizeDependOnValue">ブロック ''{0}'' の出力信号サイズは入力信号の値に依存します。しかし、このブロックを含むサブシステムは、[可変サイズの信号のサイズを伝播: リセット時のみ] に設定されています。''{1}'' の [可変サイズの信号のサイズを伝播] パラメーターを ''実行中'' に変更することを検討してください。</entry>
    <entry key="VarDimsInputEmpty">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; の信号を空のサイズにはできません。</entry>
    <entry key="VarDimsInputRequireDiscreteST">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; の信号は、離散でないサンプル時間をもつ可変サイズの信号です。可変サイズの信号に対するサンプル時間は離散でなければなりません。</entry>
    <entry key="VarDimsBusInputRequireDiscreteST">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; の信号は、離散でないサンプル時間をもつ可変サイズのバスです。可変サイズの信号に対するサンプル時間は離散でなければなりません。</entry>
    <entry key="VarDimsInvalidDrivingSS">Outport ''{0}'' はサブシステム ''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; で直接駆動されています。''{3}'' は可変サイズの入力をもち、実行中に可変サイズ信号のサイズを伝播するサブシステムの内部にあるため、イネーブル時、リセット時または実行の再開時のみ可変サイズ信号のサイズを伝播するサブシステムにより直接駆動することはできません。これを解決するには、[出力] パラメーターが [信号のコピー] に設定され、[最適化をオーバーライドして常に信号をコピー] パラメーターがオンである Signal Conversion ブロックを 2 つの Outport ブロックの間に挿入するか、あるいは &lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;[指定不足の初期化の検出]&lt;/sldiag&gt; を [簡易] に設定して簡易初期化モードを有効にします。新規の初期化モードで必要なモデリング標準に準拠するために、いくつかの変更が必要になる可能性があることに注意してください。詳細は、モデル アドバイザーのチェック ''Outport と Merge ブロックに対する初期化パラメーターの整合性をチェック'' のドキュメンテーションを参照してください。</entry>
    <entry key="VarDimsInvalidDrivingMdlRef">Outport ''{0}'' は Model ブロック ''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; により直接駆動されています。''{3}'' は可変サイズの入力をもち、実行中に可変サイズ信号のサイズを伝播するサブシステムの内部にあるため、イネーブル時、リセット時または実行の再開時のみ可変サイズ信号のサイズを伝播する参照モデル内のサブシステムにより直接駆動することはできません。これを解決するには、[出力] パラメーターが [信号のコピー] に設定され、[最適化をオーバーライドして常に信号をコピー] パラメーターがオンである Signal Conversion ブロックを 2 つの Outport ブロックの間に挿入するか、あるいは &lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;[指定不足の初期化の検出]&lt;/sldiag&gt; を [簡易] に設定して簡易初期化モードを有効にします。新規の初期化モードで必要なモデリング標準に準拠するために、いくつかの変更が必要になる可能性があることに注意してください。詳細は、モデル アドバイザーのチェック ''Outport と Merge ブロックに対する初期化パラメーターの整合性をチェック'' のドキュメンテーションを参照してください。</entry>
    <entry key="VarDimsInvalidInputIndexDimsDependencyRule">''{0}'' に対して指定された次元依存の規則が無効です。入力端子のインデックスは、0 から {1,number,integer} までの範囲になければなりません (ここで {2,number,integer} は入力端子の数が -1 です)。</entry>
    <entry key="VarDimsInvalidInputModeDimsDependencyRule">''{0}'' に対して指定された次元依存の規則が無効です。入力端子 {1,number,integer} を固定サイズのモードにすることはできません。</entry>
    <entry key="VarDimsMultiModeLoopInputError">Simulink は、''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; を含むループに対して次元依存の規則を定義できません。次元依存の規則が巡回的な関係で定義されるため、関連付けることができません。</entry>
    <entry key="VarDimsMultiModeLoopOutputError">Simulink は、''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; を含むループに対して次元依存の規則を定義できません。次元依存の規則が巡回的な関係で定義されるため、関連付けることができません。</entry>
    <entry key="VarDimsOutportInitOutConflict">同じ信号で駆動される &lt;sldiag objui="outport" objparam="{0}" objname="{1}"&gt;Outport {0}&lt;/sldiag&gt; と ''{1}'' は、パラメーター [初期出力] に対して競合する値を指定しています。初期出力は同じ名前でなければなりません。</entry>
    <entry key="VarDimsSfChartOutportInitOutConflict">Stateflow チャート ''{0}'' と Outport ブロック ''{1}'' は、競合する初期出力値を指定しています。初期出力は同じ名前でなければなりません。</entry>
    <entry key="VarDimsOutputRequireDiscreteST">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の信号は、離散でないサンプル時間をもつ可変サイズの信号です。可変サイズの信号に対するサンプル時間は離散でなければなりません。</entry>
    <entry key="VarDimsBusOutputRequireDiscreteST">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の信号は、離散でないサンプル時間をもつ可変サイズのバスです。可変サイズの信号に対するサンプル時間は離散でなければなりません。</entry>
    <entry key="VarDimsOutputRequireNonCustomStorageClass">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の信号は、カスタム ストレージ クラスをもつ可変サイズの信号です。しかし、可変サイズの信号はカスタムのストレージ クラスをサポートしていません。[信号プロパティ...] ダイアログでリストからカスタムでないストレージ クラスを選択してください。(信号線を右クリックすることで [信号プロパティ...] ダイアログが開きます)。</entry>
    <entry key="UnboundedDimsOutputRequireBuiltInStorageClass">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt; の信号に、サポートされていないストレージ クラスをもつ制限なしの可変サイズ信号が含まれています。ストレージ クラスは 'Auto'、'Exported Global'、'Imported Extern'、'Imported Extern Pointer' のいずれかでなければなりません。</entry>
    <entry key="UnboundedDimsInputRequireBuiltInStorageClass">''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; の信号に、サポートされていないストレージ クラスをもつ制限なしの可変サイズ信号が含まれています。ストレージ クラスは 'Auto'、'Exported Global'、'Imported Extern'、'Imported Extern Pointer' のいずれかでなければなりません。</entry>
    <entry key="VarDimsRequireContiguousInput">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; は可変サイズの信号を受け入れるよう設定されていますが、その端子は不連続なメモリを使用しています。S-Function を使用する場合、''ssSetInputPortRequiredContiguous'' をオンにすることを検討してください。そうでない場合、この入力端子の上流に Signal Conversion ブロックを挿入することを検討してください。</entry>
    <entry key="VarDimsSSExecTimeWithBlockRequestStateResetSizeVary">ブロック ''{0}'' には、入力信号のサイズが変わるたびにリセットが必要な状態が含まれています。このブロックのプロパティは、サブシステム ''{2}'' のブロック ''{1}'' のブロック パラメーター設定と不整合です。具体的には、[可変サイズの信号のサイズを伝播] パラメーターを [実行中] に変更することを検討してください。Enabled/Function-Call/Action/Resettable Subsystem 内に ''{3}'' を配置し、対応する制御端子ブロックのパラメーター [可変サイズの信号のサイズを伝播] を [イネーブルのときのみ] (Enabled Subsystem または Function-Call Subsystem の場合)、[実行の再開時のみ] (Action Subsystem の場合) または [リセット時のみ] (Resettable Subsystem の場合) に設定することを検討してください。あるいは、''{4}'' の [可変サイズの信号のサイズを伝播] パラメーターを [イネーブルのときのみ] に変更してください。</entry>
    <entry key="VarDimsSSExecTimeWithBlockRequestStateResetSizeVaryAction">ブロック ''{0}'' には、入力信号のサイズが変わるたびにリセットが必要な状態が含まれています。このブロックのプロパティは、サブシステム ''{2}'' のブロック ''{1}'' のブロック パラメーター設定と不整合です。具体的には、[可変サイズの信号のサイズを伝播] パラメーターを [実行中] に変更することを検討してください。Enabled/Function-Call/Action/Resettable Subsystem 内に ''{3}'' を配置し、対応する制御端子ブロックのパラメーター [可変サイズの信号のサイズを伝播] を [イネーブルのときのみ] (Enabled Subsystem または Function-Call Subsystem の場合)、[実行の再開時のみ] (Action Subsystem の場合) または [リセット時のみ] (Resettable Subsystem の場合) に設定することを検討してください。あるいは、''{4}'' の [可変サイズの信号のサイズを伝播] パラメーターを [実行の再開時のみ] に変更してください。</entry>
    <entry key="VarDimsSSExecTimeWithBlockRequestStateResetSizeVaryReset">ブロック ''{0}'' には、入力信号のサイズが変わるたびにリセットが必要な状態が含まれています。このブロックのプロパティは、サブシステム ''{2}'' のブロック ''{1}'' のブロック パラメーター設定と不整合です。具体的には、[可変サイズの信号のサイズを伝播] パラメーターを [実行中] に変更することを検討してください。Enabled/Function-Call/Action/Resettable Subsystem 内に ''{3}'' を配置し、対応する制御端子ブロックのパラメーター [可変サイズの信号のサイズを伝播] を [イネーブルのときのみ] (Enabled Subsystem または Function-Call Subsystem の場合)、[実行の再開時のみ] (Action Subsystem の場合) または [リセット時のみ] (Resettable Subsystem の場合) に設定することを検討してください。あるいは、''{4}'' の [可変サイズの信号のサイズを伝播] パラメーターを [リセット時のみ] に変更してください。</entry>
    <entry key="VarDimsSfcnRequireContiguous">S-Function ブロック ''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; は、可変サイズの信号を受け入れるよう設定されています。S-Function ''{2}'' は、メソッド ''ssSetInputPortRequiredContiguous(S,port,true)'' を呼び出さなければなりません。</entry>
    <entry key="VarDimsMultiRateEnableNotSupported"> 可変サイズ入力に設定されたマルチレートの Enabled サブシステム ''{0}'' はサポートされていません。サブシステム ''{1}'' がマルチレートで、制御端子 ''{2}'' のパラメーター ''実行中に可変サイズの信号のサイズを伝播'' が ''イネーブルのときのみ'' に設定されているため、このサブシステムでは可変サイズの信号を入力として受け入れることができません。シングル レートの Enabled サブシステムを代わりに使用することを検討してください。</entry>
    <entry key="VarDimsTrivialRTBNotAllowed">ブロック パラメーター [データ転送中の整合性を確保] がオフの場合、Rate Transition ブロック ''{0}'' は可変サイズの信号では使用できません。このメッセージを消去するには、パラメーターを有効にしてください。</entry>
    <entry key="VarDimsDeferredRTBNotAllowed">Rate Transition ブロック ''{0}'' は遅延モードの場合、可変サイズの信号と共に使用することはできません。</entry>
    <entry key="VarSTInpPortIsFrameBased">''{1}'' の&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;入力端子 {0,number,integer}&lt;/sldiag&gt; は、この端子が可変のサンプル時間をもつにもかかわらずフレームベースに設定されています。フレームベースの信号は離散サンプル時間をもつ必要があります。</entry>
    <entry key="VectToMatrixConversionByBlock">1 次元配列と 2 次元ベクトル (行列) の混在する信号は、''{0}'' を駆動しています。1 次元信号は 2 次元ベクトル信号に自動的に変換されています。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;Reshape を使用する&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''VectorMatrixConversionMsg'',''none'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="VectorMatrixConversionMsg"&gt;[ベクトル/行列ブロック入力変換]&lt;/sldiag&gt; を [なし] に設定して、このメッセージを非表示にする。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="VirtSubsysDoesNotHaveThis">非アクティブなバリアント、コメント化されたブロック階層、またはバーチャル サブシステムの一部である可能性があるため、サブシステム ''{0}'' には ''{1}'' がありません</entry>
    <entry key="ModelIsNotYetLinked">このコマンドは、モデルが初期化されていない場合は使用できません。まず、feval(bdroot, ''Init'') を実行してください。</entry>
    <entry key="VirtSubsysHasNoSList">バーチャル サブシステム ''{0}'' は、並べ替えリストをもちません。</entry>
    <entry key="WaitingForDisconnectResponse">切断メッセージが数秒前にターゲット {0,number,integer} に送信されました。応答待ち..</entry>
    <entry key="WaitingForFinalLogBufferTerminator">数秒前にターゲット {0,number,integer} からシャットダウン メッセージを受け取りました。最終のデータ ログのバッファーとログ終了の準備中..</entry>
    <entry key="WarnAlgLoopsFound" context="warning">モデル''{0}'' に {1,number,integer} 個の代数ループが含まれています。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;Simulink.BlockDiagram.getAlgebraicLoops(''{0}'');&lt;/cmd&gt; &lt;txt&gt;関数 Simulink.BlockDiagram.getAlgebraicLoops を使用して、モデル内の代数ループに関する情報を強調表示して表示する。&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{0}'','AlgebraicLoopMsg', 'none');&lt;/cmd&gt; &lt;txt&gt;[代数ループ] 診断パラメーターを [なし] に設定して、この診断を非表示にする。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="WarnAlgLoopsFoundInDebugger" context="warning">モデル''{0}'' に {1,number,integer} 個の代数ループが含まれています。モデル内のループに関する情報を得るには、関数 sldebug を使用して Simulink のデバッグ用のプログラム インターフェイスを起動した後で、関数 ashow を使用してください。</entry>
    <entry key="WarnArtAlgLoopMdlPortDF" context="warning">モデル ''{1}'' に、入力端子 ''{0}'' から 1 つ以上のルートレベル出力端子への直達パスがあるため、モデル ''{1}'' への参照を含む疑似代数ループを削除できません。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;疑似代数ループを削除できるようにしてこの警告を解決するには、モデル ''{1}'' の内容を変更して、入力端子 ''{0}'' にルートレベル出力端子への直達が存在しないようにする。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;モデルの内容を変更せずにこの警告を回避するには、モデル ''{1}'' の [疑似代数ループの発生の最小化] コンフィギュレーション パラメーターをオフにする。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;</entry>
    <entry key="WarnArtAlgLoopSysPortDF">Subsystem ''{1}'' contains a direct feedthrough path from input port ''{0}'' to one or more subsystem output ports that prevents the software from removing artificial algebraic loops that involve subsystem ''{1}''.
	&lt;actions exclusiveFixIts="yes"&gt;
    &lt;action type="suggestion"&gt;
    &lt;txt&gt;To resolve this warning by enabling the software to remove the artificial algebraic loop, modify the contents of subsystem ''{1}'' such that input port ''{0}'' does not have direct feedthrough to any output ports of subsystem ''{1}''.&lt;/txt&gt;
    &lt;/action&gt;
	&lt;action type="suggestion"&gt;
    &lt;txt&gt;To eliminate this warning without modifying the contents of the subsystem, clear the ''Minimize artificial algebraic loop occurrences'' parameter of subsystem ''{1}''.&lt;/txt&gt;
    &lt;/action&gt;
    &lt;/actions&gt;</entry>
    <entry key="WarnArtAlgLoopLoggingDF">Atomic サブシステムまたは参照モデル ''{0}'' が疑似代数ループの一部である場合、ソフトウェアはループを削除できません。直達パスの 1 つ以上の信号は、信号のログ、またはデータのログを記録するブロックを使用してログが記録されているためです。 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;疑似代数ループを削除できるようにしてこの警告を回避するには、ブロック ''{1}'' の出力 (''{0}'' の内部の直達パスにある) などの信号のログを記録しない。&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;疑似代数ループを削除せずにこの警告を解決するには、Atomic サブシステムまたは参照モデル ''{0}'' の [疑似代数ループの発生の最小化] パラメーターをオフにする。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="WarnForFrameUpgrade">ブロック ''{0}'' は信号のフレーム状態を使用しています。モデルを更新して、サンプルベースおよびフレームベースの処理の制御を、信号のフレーム状態からブロック ダイアログ パラメーターに移動させてください。この問題やその他のアップグレードの問題を解決するには、&lt;a href="matlab:{1}"&gt;Simulink アップグレード アドバイザー&lt;/a&gt;で [コンパイル時の情報を必要とするブロックのアップグレードについてモデルをチェック] チェックを実行してください。\n\nフレーム アップグレードでのユーザー作成のライブラリ ブロックの問題を特定するには、アップグレード アドバイザーで [Check model for custom library blocks that rely on frame status of the signal] チェックを実行してください。\n\nフレームベースの処理の変更に関する一般的な情報については、製品固有のリリース ノートを参照してください。</entry>
    <entry key="WarnForFrameObjUpgrade">モデルには、[SamplingMode] が [フレーム ベース] に設定された Simulink.Signal オブジェクトが、少なくとも 1 つ含まれています。手動で [自動] に変更してください。</entry>
    <entry key="WebBlockCallbackEvalErr">''{1}'' の ''{0}'' コールバックの評価中にエラーが発生しました。 \nコールバック文字列は ''{2}'' です</entry>
    <entry key="WebBlockInPanelCallbackEvalErr">パネル ''{2}'' における ''{1}'' の ''{0}'' コールバックの評価中にエラーが発生しました。 \nコールバック文字列は ''{3}'' です</entry>
    <entry key="WidthNotMatchMatlab">与えられた MATLAB 配列の幅は、Simulink の内部データの幅と一致しません</entry>
    <entry key="kthDimensionsNotMatchMatlab">与えられた MATLAB 配列の {0,number,integer} 番目の次元は、Simulink の内部データの次元と一致しません</entry>
    <entry key="SimStepperWrongStage"> 現段階でメソッドを呼び出すことはできません。 </entry>
    <entry key="SimStepperWrongMode">現在のシミュレーション モードで SimStepper は使用できません。現時点では、SimStepper はノーマル モードのモデルでのみ使用可能です。</entry>
    <entry key="SimStepperModelExistsWhileInit">モデル ''{0}'' は既に実行しています。</entry>
    <entry key="SimStepperOnlySingleTasking">[コンフィギュレーション パラメーター]、[ソルバー]、[各離散レートを個別のタスクとして扱う] オプションの選択は SimStepper ではサポートされていません。</entry>
    <entry key="StringNumberConsecutiveZc">連続的なゼロクロッシングの数</entry>
    <entry key="StringZcSignalName">ゼロクロッシング信号の名前</entry>
    <entry key="StringZcSignalIndex">ゼロクロッシング信号のインデックス</entry>
    <entry key="StringBlockType">ブロック タイプ</entry>
    <entry key="StringBlockPath">ブロック パス</entry>
    <entry key="StringTime">時刻</entry>
    <entry key="StringReason">原因</entry>
    <entry key="StringSuggestion">提案</entry>
    <entry key="SparseMethodMayCauseProblem">モデル ''{0}'' では、[ソルバーのヤコビ メソッド] パラメーターが [スパース] 手法に設定されています。モデルのサイズが大きい場合、この設定によってシミュレーション時間が遅くなったり、メモリの割り当てエラーが発生したりする可能性があります。このような問題が発生した場合は、このパラメーターで [フル摂動] メソッドを選択してください。</entry>
    <entry key="AnalyticalJacobianNotSupportPlugin">モデル ''{0}'' の [ソルバーのヤコビ メソッド] パラメーターの値は [フル摂動] または [スパース摂動] でなければなりません。</entry>
    <entry key="NoAnalyticalSlvrJacobian">次の理由\n{0}\n </entry>
    <entry key="NoAnalyticalJacobian">ブロックに解析ヤコビアンがありません</entry>
    <entry key="AnalyticalJacobianIsNotExact">解析ヤコビアンが正確ではありません</entry>
    <entry key="AnalyticalJacobianIsNotExactSuggestion">[ブロック パラメーター] ダイアログ ボックスの [線形化時にゲインとして扱う] をオフにします</entry>
    <entry key="HasDataStoreForSlvrJacobian">モデル内に Data Read または Data Write ブロックがあります。 </entry>
    <entry key="TooMuchMemoryForSlvrJacobian">元のメソッドが選択された場合、大量のメモリが必要になります。 </entry>
    <entry key="UseFullPerturbationToAvoidMemoryError">ソルバーのヤコビ行列パターンを計算するためのメモリが不足しています。 このエラーを修正するには、[コンフィギュレーション パラメーター] ダイアログ ボックスの [ソルバー] ペインで [ソルバーのヤコビ メソッド] を [フル摂動] に設定します。</entry>
    <entry key="EmptySlvrJacobian">ソルバーのヤコビ行列が空行列です。</entry>
    <entry key="ContainsLocalSolversForSolverJacobian">モデルには、ローカル ソルバーを使用するように構成された 1 つ以上の参照モデルが含まれています。 </entry>
    <entry key="InvalidArraySize">Simulink は最大 {0,number,integer} バイト数の信号サイズをサポートしています。信号サイズは、データ型のサイズ、要素数、信号タイプ (実信号/複素信号) に基づいて計算されます。ブロック ''{2}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; から発生した信号の信号サイズが {0,number,integer} を超えています。モデルのコンパイルやシミュレーションを実行する前に、信号サイズを減らすことを検討してください。</entry>
    <entry key="InvalidBlockIOSize">Simulink は最大 {0,number,integer} バイト数の合計ブロック I/O バッファー サイズをサポートしています。合計ブロック I/O サイズは、データ型のサイズ、要素数、モデル内のすべての信号の信号タイプ (実信号/複素信号) に基づいて計算されます。モデルのコンパイルやシミュレーションを実行する前に、信号サイズを減らすことを検討してください。</entry>
    <entry key="InvalidParameterSize">Simulink は {0,number,integer} バイトまでのパラメーター サイズをサポートしています。このサイズは、データ型のサイズ、要素数、および信号の型 (実数/複素数) に基づいて計算されます。ブロック ''{2}'' のパラメーター ''{1}'' のサイズが {0,number,integer} を超えています。モデルのコンパイルまたはシミュレーションを実行する前に、パラメーターのサイズを減らすことを検討してください。</entry>
    <entry key="InputPortStrLC">入力端子</entry>
    <entry key="OutputPortStrLC">出力端子</entry>
    <entry key="InvSignalDimensionSize">Simulink でサポートされる信号の最大次元サイズは、許容される 32 ビット符号付き整数の最大値である {0,number,integer} です。''{3}'' の {1} {2,number,integer} で指定または計算された次元サイズがこの制限を超えています。モデルのコンパイルやシミュレーションを実行する前に、信号サイズを減らすことを検討してください。</entry>
    <entry key="InvDimensionSize">Simulink でサポートされる信号およびパラメーターの最大次元サイズは、許容される 32 ビット符号付き整数の最大値である {0,number,integer} です。モデルのコンパイルやシミュレーションを実行する前に、信号またはパラメーターのサイズを減らすことを検討してください。</entry>
    <entry key="CannotMixDynAndInfInDimensionSpec">次元指定には、継承された (-1) 値と非有界 (inf) の値を組み合わせて含めることはできません。</entry>
    <entry key="InfDimensionSpecRequiresNumDimensions">非有界 (inf) の値を含む次元指定は次元数を提供しなければなりません。</entry>
    <entry key="InvalidDWorkOffsetSize">Simulink は、{0,number,integer} バイトまでの離散系状態量/dwork サイズをサポートしています。各離散系状態量のサイズを使用して、内部メモリの配置に必要なオフセットが計算されます。オフセットのサイズは、データ型のサイズ、要素の数、および型 (実数/複素数) に基づいて計算されます。離散系状態量またはブロック ''{1}'' の dwork の計算されたオフセットは、{2,number,integer} より大きい値です。離散系状態量/dwork、または、モデルをコンパイルあるいはシミュレートする前の信号幅を減らすことを検討してください。</entry>
    <entry key="InvalidModelRefAccelDWorkSize">Simulink では、アクセラレータ モードのモデル参照について、{0,number,integer} バイトまでの離散系状態量/dwork サイズをサポートしています。Model ブロック ''{1}'' の離散系状態量または dwork のサイズが、{2,number,integer} を超えています。モデルのコンパイルまたはシミュレーションの前に、離散系状態量/dwork または信号幅を減らすことを検討してください。</entry>
    <entry key="InvalidVarDimsRootInportForEnabledModel">The root inport ''{0}'' has an output
      that is a variable-size signal. This is not allowed because the model has a root-level Enable port ''{1}''.</entry>
    <entry key="InvalidVarDimsRootOutportForEnabledModel">The root outport ''{0}'' has an input
      that is a variable-size signal. This is not allowed because the model has a root-level Enable port ''{1}''.</entry>
    <entry key="ParamNotAllowed">モデル ''{1}'' のパラメーター ''{0}'' を設定できませんでした。パラメーター ''{0}'' はライブラリにのみ適用されます。</entry>
    <entry key="ParamNotAllowedGeneric">許可されていないため、''{0}'' を設定できません ({1}: ''{2}'')</entry>
    <entry key="Model">モデル</entry>
    <entry key="Library">ライブラリ</entry>
    <entry key="Subsystem">サブシステム</entry>
    <entry key="STFNotSupported">選択したシステム ターゲット ファイル ''{0}''は、現在の同時実行用にサポートされていません。</entry>
    <entry key="SILPILNotSupportedForConcurrency">現在、SIL モードと PIL モードの同時実行をサポートしていません。</entry>
    <entry key="IDsLessThanDynamic">動的未満の ID をもつことはできません。</entry>
    <entry key="DynamicMixError">「常に必要」と「動的に必要」を混在させることはできません</entry>
    <entry key="ConditionalMixError">入力端子と出力端子に同じ条件付き ID を含めることはできません</entry>
    <entry key="NoCompiledModel">終了するコンパイル済みモデルがありません</entry>
    <entry key="UseTopModel">この API は参照モデル ''{0}'' 上では呼び出せません。代わりに、コンパイルした階層の最上位モデルを使用してください: ''{1}''。</entry>
    <entry key="InvalidBlockDiagram">無効なブロック線図</entry>
    <entry key="UninitializedModel">モデルが初期化されていません</entry>
    <entry key="ModelNotCompiledForQuery">このクエリについてモデルがコンパイルされていません</entry>
    <entry key="UnknownModel">不明なモデル</entry>
    <entry key="FixUseDblUsage">グローバル変数 'FixUseDbl' の旧式の使用法を検出します。データ型オーバーライド ステータスを設定するには、モデル レベルまたはサブシステム レベルで 'DataTypeOverride' のパラメーターを設定してください。</entry>
    <entry key="FixLogPrefUsage">グローバル変数 'FixLogPref' の旧式の使用法を検出します。最小/最大/オーバーフローのログ ステータスを設定するには、モデル レベルまたはサブシステム レベルで 'MinMaxOverflowLogging' のパラメーターを設定してください。</entry>
    <entry key="InvalidRTWIndex">内部エラー: ''{0}'' に無効な RTWIndex があります</entry>
    <entry key="NotCurrentNetList">内部エラー: ''{0}'' は現在のネットリストの一部ではありません。</entry>
    <entry key="CompRTWCGDiffRTWIndex">内部エラー: ''{0}'' に、最初のインスタンス ''{3}'' とは異なる RTWIndex {1,number,integer} != {2,number,integer} があります。</entry>
    <entry key="CompRTWCGDiffInputType">内部エラー: ''{0}'' に、最初のインスタンス ''{3}'' とは異なる入力型 {1,number,integer} != {2,number,integer} があります。</entry>
    <entry key="CompRTWCGDiffOutputType">内部エラー: ''{0}'' に、最初のインスタンス ''{3}'' とは異なる出力型 {1,number,integer} != {2,number,integer} があります。</entry>
    <entry key="SubsystemHiddenParameterImproperlyAccessed">テスト用の get_param の使用は、model([],[],[],'compileForRTW') を最初に実行する場合にのみ有効です。</entry>
    <entry key="VirtualSubsystemHiddenParameterImproperlyAccessed">非バーチャル サブシステムに対してのみ有効なテスト用の get_param の使用。</entry>
    <entry key="RealizingTransformedBlocksIsDebugOnly">変換したグラフから表示可能なグラフへのブロックの実現は、内部デバッグとテストでのみ使用される機能です。</entry>
    <entry key="ShadowedModelName">優先順位の低いモデル名</entry>
    <entry key="CannotInitMLSysForCodeGen">モデル ''{0}'' には 1 つまたは複数の MATLAB システム ブロックが含まれ、初期状態を読み込むように設定されています。この機能は、ノーマル モードでのみサポートされます。
</entry>
    <entry key="ConflictingEnumerationAlreadyPresentInModelReference">
      参照モデル {1} 内のステート アクティビティの出力に使用される列挙値 ''{0}'' は、参照モデル {2} 内のステート アクティビティの出力に使用される列挙値と競合しています。
    </entry>
    <entry key="DisableVolatileCSCForCPPClass">C++ クラス コード生成でのカスタム ストレージ クラス ''{0}'' の使用はサポートされません。このカスタム ストレージ クラスでは ''Volatile'' 指定が使用されているためです。</entry>
    <entry key="DisableOtherTypeCSCForCPPClass">カスタム ストレージ クラス ''{0}'' での C++ クラス コード生成の使用はサポートされません。このカスタム ストレージ クラスの CSCType が [その他] であるためです。</entry>
    <entry key="DisableVolatileMemSecForCPPClass">C++ クラス コード生成では、パラメーター ''{1}'' に対するメモリ セクション ''{0}'' の使用はサポートされていません。このメモリ セクションでは ''Volatile'' 指定が使用されているためです。</entry>
    <entry key="StateOwnerRequirementsForStateReader">ブロック ''{0}'' に State Reader ブロック ''{1}'' によってサポートされない属性または設定があります。</entry>
    <entry key="StateOwnerRequirementsForStateWriter">ブロック ''{0}'' に State Writer ブロック ''{1}'' によってサポートされない属性または設定があります。</entry>
    <entry key="StateOwnerRequirementsForStateAccessInChart">ブロック ''{0}'' には、チャート ''{1}'' でのテキストによる状態アクセスではサポートされない属性またはコンフィギュレーションがあります。</entry>
    <entry key="StateOwnerFrameInput">ブロック ''{0}'' の&lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;入力端子 {1,number,integer}&lt;/sldiag&gt; にフレームベース信号があります。</entry>
    <entry key="StateOwnerFrameOutput">ブロック ''{0}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; にフレームベース信号があります。</entry>
    <entry key="StateOwnerVarDimsInput">ブロック ''{0}'' の&lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;入力端子 {1,number,integer}&lt;/sldiag&gt; に可変サイズの信号があります。</entry>
    <entry key="StateOwnerVarDimsOutput">ブロック ''{0}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; に可変サイズの信号があります。</entry>
    <entry key="StateOwnerVirtualBusInput">ブロック ''{0}'' の入力端子 {1,number,integer} にバーチャル バス信号があります。ドキュメンテーションを参照して、ブロック ''{2}'' が非バーチャル バスをサポートするかどうかを確認してください。</entry>
    <entry key="StateOwnerVirtualBusOutput">ブロック ''{0}'' の出力端子 {1,number,integer} にバーチャル バス信号があります。ドキュメンテーションを参照して、ブロック ''{2}'' が非バーチャル バスをサポートするかどうかを確認してください。</entry>
    <entry key="StateOwnerStatePort">ブロック ''{0}'' に状態端子があります。</entry>
    <entry key="StateOwnerResetPort">ブロック ''{0}'' にリセット端子があります。</entry>
    <entry key="StateOwnerInitCondPort">ブロック ''{0}'' に初期条件端子があります。</entry>
    <entry key="StateOwnerInInitSS">ブロック ''{0}'' が Initialize Function ブロック内にあります。</entry>
    <entry key="StateOwnerInSubsystemResettingStates">ブロック ''{0}'' は、Resettable Subsystem や、Enable Port ブロックのパラメーター [イネーブル時の状態] が [リセット] に設定されている Enabled Subsystem のように、状態をリセットできるサブシステム内に存在します。</entry>
    <entry key="StateOwnerFrameBasedProcessing">ブロック ''{0}'' で、パラメーター [入力処理] が [チャネルとしての列 (フレーム ベース)] に設定されています。パラメーターを [チャネルとしての要素 (サンプル ベース)] に設定することを検討してください。</entry>
    <entry key="StateOwnerCircularBuffer">ブロック ''{0}'' のパラメーター [リング バッファーを使用] をオフにしなければなりません。</entry>
    <entry key="StateOwnerZeroDelay">ブロック ''{0}'' のパラメーター [遅延の長さ] が 0 に設定されています。</entry>
    <entry key="StateOwnerDiscIntegratorInTrigSS">パラメーター [積分手法] が [積分:] に設定されている Discrete-Time Integrator ブロック ''{0}'' は、Triggered Subsystem 内には配置できません。積分手法を [累積:] タイプに切り替えてください。</entry>
    <entry key="StateOwnerDiscIntegratorICMode">Discrete-Time Integrator ブロック ''{0}'' ではパラメーター [初期条件設定] が [自動] に設定されていなければなりません。</entry>
    <entry key="StateOwnerDiscIntegratorLimitOutput">Discrete-Time Integrator ブロック ''{0}'' のパラメーター [出力を制限する] をオフにしなければなりません。</entry>
    <entry key="StateAccessForOutportResetWhenDisabled">Outport ブロック ''{0}'' のパラメーター [ディセーブル時の出力] が [保持] に設定されていなければなりません。</entry>
    <entry key="StateAccessForOutportInheritIC">Outport ブロック ''{0}'' は初期出力値をそのソースから継承しています。この問題を修正するには、[初期出力] パラメーターが空の行列 ([]) ではない値に設定されていることを確認してください。</entry>
    <entry key="StateAccessForMessageOutport">Outport ブロック ''{0}'' はメッセージを出力しています。</entry>
    <entry key="StateAccessSrcDataTypeMismatch">Outport ブロック ''{0}'' の入力データ型は ''{1}'' です。一方で、ソース ブロック ''{2}'' の出力データ型は ''{3}'' です。Outport ブロックが状態オーナーである場合、これら 2 つの型は一致する必要があります。 </entry>
    <entry key="StateAccessForMergedOutport">Outport ブロック ''{0}'' に対応するサブシステムの出力は Merge ブロック ''{1}'' に接続されています。</entry>
    <entry key="StateAccessForSignedTriggerPort">Trigger Port ブロック ''{0}'' について、対応する親サブシステムのトリガー端子のデータ型 ''{1}'' が符号付きです。''boolean'' や ''uint32'' など、符号なしデータ型を使用することを検討してください。</entry>
    <entry key="StateAccessForEitherRisingOrFallingTriggerPort">Trigger Port ブロック ''{0}'' では、State Reader ブロックまたは State Writer ブロックをサポートするためにパラメーター [トリガー タイプ] が [両方] に設定されている場合、パラメーター [トリガー信号の初期状態] が [ゼロ] または [正] に設定されていなければなりません。</entry>
    <entry key="StateOwnerFcnCall">ブロック ''{0}'' の状態のデータ型は関数呼び出しです。State Reader ブロックおよび State Writer ブロックでは、関数呼び出しをサポートしていません。</entry>
    <entry key="StateOwnerEmptyStates">ブロック ''{0}'' の状態は空です。</entry>
    <entry key="StateAccessContStateMultiState">ブロック ''{0}'' には複数の状態があります。外部からの状態へのアクセスでは、1 つの状態のみがサポートされます。</entry>
    <entry key="StateAccessContStateInvalidName">''{1}'' のパラメーター ''{0}'' の識別子が、アクセスに有効な状態名ではありません。外部から状態にアクセスする場合、有効な状態名は引用符で囲まれ、英字または ''_'' 文字で始まり、英数字または ''_'' 文字が続きます。</entry>
    <entry key="TextualAccessStateInvalidName">''{1}'' の状態に割り当てられた名前 ''{0}'' は、有効な識別子ではありません。テキスト形式の状態にアクセスするための有効な識別子は、英字または ''_'' 文字で始まり、英数字または ''_'' 文字が続きます。</entry>
    <entry key="State">状態</entry>
    <entry key="Parameter">パラメーター</entry>
    <entry key="InconsistentReaderDims">ブロック ''{2}'' によって計算された {0} の次元 {1} が、{0} Reader ブロック ''{4}'' によって計算された出力信号の次元 {3} と一致していません。</entry>
    <entry key="InconsistentWriterDims">ブロック ''{2}'' によって計算された {0} の次元 {1} が、{0} Writer ブロック ''{4}'' によって計算された入力信号の次元 {3} と一致していません。</entry>
    <entry key="InconsistentParameterWriterDims">Parameter Writer ブロック ''{4}'' の入力信号の次元は {3} であるのに対し、ブロック ''{2}'' が所有するパラメーター ''{0}'' は次元 ''{1}'' をもちます。Parameter Writer ブロックに指定した次元がパラメーターの次元と同じであることを確認してください。</entry>
    <entry key="InconsistentDefaultReaderDims">仕様が不十分であるため、Simulink ではブロック ''{0}'' の信号の次元を決定するためにヒューリスティックな方法を使用しました。しかし、このブロックによって計算された結果の次元 {1} は、Reader ブロック ''{3}'' によって計算された出力信号の次元 {2} と一致していません。この問題を回避するには、ブロック ''{4}'' のすべての入力信号と出力信号の次元を完全に指定することを検討してください。</entry>
    <entry key="InconsistentDefaultWriterDims">仕様が不十分であるため、Simulink ではブロック ''{0}'' の信号の次元を決定するためにヒューリスティックな方法を使用しました。しかし、このブロックによって計算された結果の状態の次元 {1} は、Writer ブロック ''{3}'' によって計算された入力信号の次元 {2} と一致していません。この問題を回避するには、ブロック ''{4}'' のすべての入力信号と出力信号の次元を完全に指定することを検討してください。</entry>
    <entry key="InconsistentReaderDataType">ブロック ''{2}'' によって計算された {0} のデータ型 ''{1}'' が、{0} Reader ブロック ''{4}'' によって計算された出力信号のデータ型 ''{3}'' と一致していません。</entry>
    <entry key="InconsistentWriterDataType">ブロック ''{2}'' によって計算された {0} のデータ型 ''{1}'' が、{0} Writer ブロック ''{4}'' によって計算された入力信号のデータ型 ''{3}'' と一致していません。</entry>
    <entry key="InconsistentParameterWriterDataType">Parameter Writer ブロック ''{4}'' の入力信号のデータ型が {3} であるのに対し、ブロック ''{2}'' が所有するパラメーター ''{0}'' はデータ型 ''{1}'' をもちます。Parameter Writer ブロックに対する入力のデータ型がパラメーターのデータ型と同じであることを確認してください。</entry>
    <entry key="InconsistentParameterWriterToWSVarDims">Parameter Writer ブロック ''{3}'' の入力信号の次元は {2} であるのに対し、現在のモデル ワークスペース内のパラメーター ''{0}'' は次元 ''{1}'' をもちます。Parameter Writer ブロックに指定した次元がパラメーターの次元と同じであることを確認してください。</entry>
    <entry key="InconsistentChartAndOwnerDataType">ブロック ''{1}'' によって計算される状態のデータ型 ''{0}'' は、チャート ''{3}'' によって計算されるデータ型 ''{2}'' と互換性がありません。</entry>
    <entry key="InconsistentDefaultReaderDataType">仕様が不十分であるため、Simulink ではブロック ''{0}'' の信号のデータ型を決定するためにヒューリスティックな方法を使用しました。しかし、このブロックによって計算された結果のデータ型 ''{1}'' は、Reader ブロック ''{3}'' によって計算された出力信号のデータ型 ''{2}'' と一致していません。この問題を回避するには、ブロック ''{4}'' のすべての入力信号と出力信号のデータ型を完全に指定することを検討してください。</entry>
    <entry key="InconsistentDefaultWriterDataType">仕様が不十分であるため、Simulink ではブロック ''{0}'' の信号のデータ型を決定するためにヒューリスティックな方法を使用しました。しかし、このブロックによって計算された結果のデータ型 ''{1}'' は、Writer ブロック ''{3}'' によって計算された入力信号のデータ型 ''{2}'' と一致していません。この問題を回避するには、ブロック ''{4}'' のすべての入力信号と出力信号のデータ型を完全に指定することを検討してください。</entry>
    <entry key="InconsistentReaderComplexSignal1">ブロック ''{1}'' によって計算された {0} の信号タイプ ''real'' が、{0} Reader ブロック ''{2}'' によって計算された出力信号タイプ ''complex'' と一致していません。</entry>
    <entry key="InconsistentReaderComplexSignal2">ブロック ''{1}'' によって計算された {0} の信号タイプ ''complex'' が、{0} Reader ブロック ''{2}'' によって計算された出力信号タイプ ''real'' と一致していません。</entry>
    <entry key="InconsistentWriterComplexSignal1">ブロック ''{1}'' によって計算された {0} の信号タイプ ''real'' が、{0} Writer ブロック ''{2}'' によって計算された入力信号タイプ ''complex'' と一致していません。</entry>
    <entry key="InconsistentWriterComplexSignal2">ブロック ''{1}'' によって計算された {0} の信号タイプ ''complex'' が、{0} Writer ブロック ''{2}'' によって計算された入力信号タイプ ''real'' と一致していません。</entry>
    <entry key="InconsistentParameterWriterComplexSignal1">ブロック ''{1}'' が所有するパラメーター ''{0}'' の信号タイプ ''real'' が、Parameter Writer ブロック ''{2}'' によって計算された入力信号タイプ ''complex'' と一致していません。</entry>
    <entry key="InconsistentParameterWriterComplexSignal2">ブロック ''{1}'' が所有するパラメーター ''{0}'' の信号タイプ ''complex'' が、Parameter Writer ブロック ''{2}'' によって計算された入力信号タイプ ''real'' と一致していません。</entry>
    <entry key="InconsistentDefaultReaderComplexSignal1">仕様が不十分であるため、Simulink ではブロック ''{0}'' の信号タイプを決定するためにヒューリスティックな方法を使用しました。しかし、このブロックによって計算された結果の信号タイプ ''real'' は、Reader ブロック ''{1}'' によって計算された出力信号タイプ ''complex'' と一致していません。この問題を回避するには、ブロック ''{2}'' のすべての入力信号と出力信号の信号タイプを完全に指定することを検討してください。</entry>
    <entry key="InconsistentDefaultReaderComplexSignal2">仕様が不十分であるため、Simulink ではブロック ''{0}'' の信号タイプを決定するためにヒューリスティックな方法を使用しました。しかし、このブロックによって計算された結果の信号タイプ ''complex'' は、Reader ブロック ''{1}'' によって計算された出力信号タイプ ''real'' と一致していません。この問題を回避するには、ブロック ''{2}'' のすべての入力信号と出力信号の信号タイプを完全に指定することを検討してください。</entry>
    <entry key="InconsistentDefaultWriterComplexSignal1">仕様が不十分であるため、Simulink ではブロック ''{0}'' の信号タイプを決定するためにヒューリスティックな方法を使用しました。しかし、このブロックによって計算された結果の信号タイプ ''real'' は、Writer ブロック ''{1}'' によって計算された入力信号タイプ ''complex'' と一致していません。この問題を回避するには、ブロック ''{2}'' のすべての入力信号と出力信号の信号タイプを完全に指定することを検討してください。</entry>
    <entry key="InconsistentDefaultWriterComplexSignal2">仕様が不十分であるため、Simulink ではブロック ''{0}'' の信号タイプを決定するためにヒューリスティックな方法を使用しました。しかし、このブロックによって計算された結果の信号タイプ ''complex'' は、Writer ブロック ''{1}'' によって計算された入力信号タイプ ''real'' と一致していません。この問題を回避するには、ブロック ''{2}'' のすべての入力信号と出力信号の信号タイプを完全に指定することを検討してください。</entry>
    <entry key="SFcnStateWidthChangeInMdlSetWorkWidths">S-Function ブロック ''{1}'' の作業ベクトルの幅 ''{0}'' が mdlInitializeSizes の {2,number,integer} から mdlSetWorkWidths の {3,number,integer} に変化します。ssSetDWorkWidth への呼び出しを mdlSetWorkWidths から削除することを検討するか、ssSetDWorkWidth によりこの作業ベクトルで mdlInitializeSizes の幅が必ず DYNAMICALLY_SIZED に設定されるようにしてください。</entry>
    <entry key="SFcnStateDataTypeChangeInMdlSetWorkWidths">S-Function ブロック ''{1}'' の作業ベクトル ''{0}'' のデータ型が mdlInitializeSizes の ''{2}'' から mdlSetWorkWidths の ''{3}'' に変化します。ssSetDWorkDataType への呼び出しを mdlSetWorkWidths から削除することを検討するか、ssSetDWorkDataType によりこの作業ベクトルで mdlInitializeSizes のデータ型が必ず DYNAMICALLY_TYPED に設定されるようにしてください。</entry>
    <entry key="SFcnStateComplexSignalChangeInMdlSetWorkWidths1">S-Function ブロック ''{1}'' の作業ベクトル ''{0}'' の信号タイプが mdlInitializeSizes の ''real'' から mdlSetWorkWidths の ''complex'' に変化します。ssSetDWorkComplexSignal への呼び出しを mdlSetWorkWidths から削除することを検討するか、ssSetDWorkComplexSignal によりこの作業ベクトルで mdlInitializeSizes の信号タイプが必ず DYNAMICALLY_TYPED に設定されるようにしてください。</entry>
    <entry key="SFcnStateComplexSignalChangeInMdlSetWorkWidths2">S-Function ブロック ''{1}'' の作業ベクトル ''{0}'' の信号タイプが mdlInitializeSizes の ''complex'' から mdlSetWorkWidths の ''real'' に変化します。ssSetDWorkComplexSignal への呼び出しを mdlSetWorkWidths から削除することを検討するか、ssSetDWorkComplexSignal によりこの作業ベクトルで mdlInitializeSizes の信号タイプが必ず DYNAMICALLY_TYPED に設定されるようにしてください。</entry>
    <entry key="InconsistentStateReaderDimsSFcn">S-Function ブロック ''{2}'' の作業ベクトル ''{1}'' の次元 {0} は、State Reader ブロック ''{4}'' の出力信号の次元 {3} と一致していません。ssSetDWorkWidth への呼び出しをこの作業ベクトルの mdlSetWorkWidths から mdlInitializeSizes に移動させることを検討してください。あるいは、Signal Specification ブロックを使用するなどして、State Reader ブロックの出力端子が一致する次元を必ずもつようにしてください。</entry>
    <entry key="InconsistentStateReaderDimsSFcnDefault">Simulink では S-Function ブロック ''{2}'' の作業ベクトル ''{1}'' の次元 {0} を決定するためにヒューリスティックな方法を使用しました。しかし、その結果は State Reader ブロック ''{4}'' の出力信号の次元 {3} と一致していません。mdlInitializeSizes または mdlSetWorkWidths の ssSetDWorkWidth を使用して、この作業ベクトルの次元を指定することを検討してください。</entry>
    <entry key="InconsistentStateWriterDimsSFcnDefault">Simulink では S-Function ブロック ''{2}'' の作業ベクトル ''{1}'' の次元 {0} を決定するためにヒューリスティックな方法を使用しました。しかし、その結果は State Writer ブロック ''{4}'' の入力信号の次元 {3} と一致していません。mdlInitializeSizes または mdlSetWorkWidths の ssSetDWorkWidth を使用して、この作業ベクトルの次元を指定することを検討してください。</entry>
    <entry key="InconsistentStateReaderDataTypeSFcn">S-Function ブロック ''{2}'' の作業ベクトル ''{1}'' のデータ型 ''{0}'' は、State Reader ブロック ''{4}'' の出力信号のデータ型 ''{3}'' と一致していません。ssSetDWorkDataType への呼び出しを、この作業ベクトルの mdlSetWorkWidths から mdlInitializeSizes に移動させることを検討してください。あるいは、Signal Specification ブロックを使用するなどして、State Reader ブロックの出力端子には一致するデータ型を必ず指定してください。</entry>
    <entry key="InconsistentStateWriterDataTypeSFcn">S-Function ブロック ''{2}'' の作業ベクトル ''{1}'' のデータ型 ''{0}'' は、State Writer ブロック ''{4}'' の入力信号のデータ型 ''{3}'' と一致していません。ssSetDWorkDataType への呼び出しを、この作業ベクトルの mdlSetWorkWidths から mdlInitializeSizes に移動させることを検討してください。あるいは、Signal Specification ブロックを使用するなどして、State Writer ブロックの入力端子に一致するデータ型を必ず指定してください。</entry>
    <entry key="InconsistentStateReaderDataTypeSFcnDefault">Simulink では S-Function ブロック ''{2}'' の作業ベクトル ''{1}'' のデータ型 ''{0}'' を決定するためにヒューリスティックな方法を使用しました。しかし、その結果は State Reader ブロック ''{4}'' の出力信号のデータ型 ''{3}'' と一致していません。mdlInitializeSizes または mdlSetWorkWidths の ssSetDWorkDataType を使用して、この作業ベクトルのデータ型を指定することを検討してください。</entry>
    <entry key="InconsistentStateWriterDataTypeSFcnDefault">Simulink では S-Function ブロック ''{2}'' の作業ベクトル ''{1}'' のデータ型 ''{0}'' を決定するためにヒューリスティックな方法を使用しました。しかし、その結果は State Writer ブロック ''{4}'' の入力信号のデータ型 ''{3}'' と一致していません。mdlInitializeSizes または mdlSetWorkWidths の ssSetDWorkDataType を使用して、この作業ベクトルのデータ型を指定することを検討してください。</entry>
    <entry key="InconsistentStateReaderComplexSignalSFcn1">S-Function ブロック ''{1}'' の作業ベクトル ''{0}'' の信号タイプ ''real'' は、State Reader ブロック ''{2}'' の出力信号タイプ ''complex'' と一致していません。ssSetDWorkComplexSignal への呼び出しを、この作業ベクトルの mdlSetWorkWidths から mdlInitializeSizes に移動させることを検討してください。あるいは、Signal Specification ブロックを使用するなどして、State Reader ブロックの出力端子の信号タイプと必ず一致させてください。</entry>
    <entry key="InconsistentStateReaderComplexSignalSFcn2">S-Function ブロック ''{1}'' の作業ベクトル ''{0}'' の信号タイプ ''complex'' は、State Reader ブロック ''{2}'' の出力信号タイプ ''real'' と一致していません。ssSetDWorkComplexSignal への呼び出しを、この作業ベクトルの mdlSetWorkWidths から mdlInitializeSizes に移動させることを検討してください。あるいは、Signal Specification ブロックを使用するなどして、State Reader ブロックの出力端子の信号タイプと必ず一致させてください。</entry>
    <entry key="InconsistentStateWriterComplexSignalSFcn1">S-Function ブロック ''{1}'' の作業ベクトル ''{0}'' の信号タイプ ''real'' は、State Writer ブロック ''{2}'' の入力信号タイプ ''complex'' と一致していません。ssSetDWorkComplexSignal への呼び出しを、この作業ベクトルの mdlSetWorkWidths から mdlInitializeSizes に移動させることを検討してください。あるいは、Signal Specification ブロックを使用するなどして、一致する信号タイプを State Writer ブロックの入力端子に必ず指定してください。</entry>
    <entry key="InconsistentStateWriterComplexSignalSFcn2">S-Function ブロック ''{1}'' の作業ベクトル ''{0}'' の信号タイプ ''complex'' は、State Writer ブロック ''{2}'' の入力信号タイプ ''real'' と一致していません。ssSetDWorkComplexSignal への呼び出しを、この作業ベクトルの mdlSetWorkWidths から mdlInitializeSizes に移動させることを検討してください。あるいは、Signal Specification ブロックを使用するなどして、一致する信号タイプを State Writer ブロックの入力端子に必ず指定してください。</entry>
    <entry key="InconsistentStateReaderComplexSignalSFcnDefault1">Simulink では S-Function ブロック ''{1}'' の作業ベクトル ''{0}'' の信号タイプ ''real'' を決定するためにヒューリスティックな方法を使用しました。しかし、その結果は State Reader ブロック ''{2}'' の出力信号タイプ ''complex'' と一致していません。mdlInitializeSizes または mdlSetWorkWidths の ssSetDWorkComplexSignal を使用して、この作業ベクトルの信号タイプを指定することを検討してください。</entry>
    <entry key="InconsistentStateReaderComplexSignalSFcnDefault2">Simulink では S-Function ブロック ''{1}'' の作業ベクトル ''{0}'' の信号タイプ ''complex'' を決定するためにヒューリスティックな方法を使用しました。しかし、その結果は State Reader ブロック ''{2}'' の出力信号タイプ ''real'' と一致していません。mdlInitializeSizes または mdlSetWorkWidths の ssSetDWorkComplexSignal を使用して、この作業ベクトルの信号タイプを指定することを検討してください。</entry>
    <entry key="InconsistentStateWriterComplexSignalSFcnDefault1">Simulink では S-Function ブロック ''{1}'' の作業ベクトル ''{0}'' の信号タイプ ''real'' を決定するためにヒューリスティックな方法を使用しました。しかし、その結果は State Writer ブロック ''{2}'' の入力信号タイプ ''complex'' と一致していません。mdlInitializeSizes または mdlSetWorkWidths の ssSetDWorkComplexSignal を使用して、この作業ベクトルの信号タイプを指定することを検討してください。</entry>
    <entry key="InconsistentStateWriterComplexSignalSFcnDefault2">Simulink では S-Function ブロック ''{1}'' の作業ベクトル ''{0}'' の信号タイプ ''complex'' を決定するためにヒューリスティックな方法を使用しました。しかし、その結果は State Writer ブロック ''{2}'' の入力信号タイプ ''real'' と一致していません。mdlInitializeSizes または mdlSetWorkWidths の ssSetDWorkComplexSignal を使用して、この作業ベクトルの信号タイプを指定することを検討してください。</entry>
    <entry key="SubsysFcnOptionNotSupported">サブシステム ''{0}'' には State/Parameter Reader/Writer ブロックが含まれていますが、対応する状態/パラメーター オーナー ブロックは含まれておらず、For Each Subsystem ''{1}'' の内部にあります。また、そのパラメーター [コード生成関数のパッケージ化] が [再利用可能な関数] に設定されています。このシナリオは Simulink ではサポートされません。サブシステム ''{2}'' のパラメーター [コード生成関数のパッケージ化] を [インライン] または [自動] に変更することを検討してください。</entry>
    <entry key="InvMcosObjectForInitState">&lt;sldiag objui="configset" objparam="InitialState"&gt;[初期状態]&lt;/sldiag&gt; で指定された MATLAB オブジェクトからモデル ''{0}'' の初期状態を読み込むことはサポートされていません。初期状態を指定するには、Simulink.op.ModelOperatingPoint または Simulink.SimulationData.Dataset のタイプの空でないスカラー オブジェクトを使用してください。</entry>
    <entry key="SimModeAuto">自動</entry>
    <entry key="SimModeNormal">ノーマル</entry>
    <entry key="SimModeAccelerated">アクセラレータ</entry>
    <entry key="SimModeRapidAccel">ラピッド アクセラレータ</entry>
    <entry key="SimModeSIL">ソフトウェアインザループ (SIL)</entry>
    <entry key="SimModePIL">プロセッサインザループ (PIL)</entry>
    <entry key="SimModeExternal">エクスターナル</entry>
    <entry key="NormalModeOptimizationAuto">自動</entry>
    <entry key="NormalModeOptimizationInitialization">初期化</entry>
    <entry key="NormalModeOptimizationExecution">実行</entry>
    <entry key="AutoOnOffAuto">自動</entry>
    <entry key="AutoOnOffOn">オン</entry>
    <entry key="AutoOnOffOff">オフ</entry>
    <entry key="ClearAccelCacheNone">なし</entry>
    <entry key="ClearAccelCacheMemory">メモリ</entry>
    <entry key="ClearAccelCacheAll">すべて</entry>
    <entry key="SimRollbackUninitialized">未初期化</entry>
    <entry key="SimRollbackCompliant">準拠</entry>
    <entry key="SimRollbackNonCompliantNeutral">非準拠 - ニュートラル</entry>
    <entry key="SimRollbackNonCompliantFatal">非準拠 - 致命的</entry>
    <entry key="RapidAccelSimStatusInactive">非アクティブ</entry>
    <entry key="RapidAccelSimStatusDormant">休止中</entry>
    <entry key="RapidAccelSimStatusStarting">起動中</entry>
    <entry key="RapidAccelSimStatusEditing">編集中</entry>
    <entry key="RapidAccelSimStatusInitializing">初期化中</entry>
    <entry key="RapidAccelSimStatusBuilding">ビルド中</entry>
    <entry key="RapidAccelSimStatusUpdating">更新中</entry>
    <entry key="RapidAccelSimStatusConnecting">接続中</entry>
    <entry key="RapidAccelSimStatusRunning">実行中</entry>
    <entry key="RapidAccelSimStatusTerminating">終了中</entry>
    <entry key="RapidAccelMenuSimStatusUnused">未使用</entry>
    <entry key="RapidAccelMenuSimStatusReady">準備完了</entry>
    <entry key="RapidAccelMenuSimStatusActive">アクティブ</entry>
    <entry key="RapidAccelMenuSimStatusPassed">成功</entry>
    <entry key="RapidAccelMenuSimStatusFailed">失敗</entry>
    <entry key="IncompleteVarUsageInfo">変数使用法に関する情報が不完全な可能性があります。調整可能でない変数の完全なリストを取得するには、モデルを FastRestart で初期化しなければなりません</entry>
    <entry key="NonTunableVarChangedInFastRestart">変数 ''{0}'' は変更されましたが、''{1}'' の調整不可能なパラメーターで使用されています。モデルが高速リスタートで初期化されているため、新しい値は使用されません。新しい値を使用する場合は、高速リスタートをオフにします。 </entry>
    <entry key="NonTunableVarChanged">変数 ''{0}'' は変更されましたが、''{1}'' の調整不可能なパラメーターで使用されています。新しい値は現在のシミュレーションで使用されません。新しい値を使用する場合は、シミュレーションを再実行してください。 </entry>
    <entry key="NonTunableVarChangedMaxWarnings">調整不可能なパラメーターで使用されている変数の変更は他にもありましたが、警告メッセージ数の制限により報告はされませんでした</entry>
    <entry key="WarnModelClose">モデル {0} はコンパイルまたはシミュレーション中に閉じられました。</entry>
    <entry key="SlFcnFpcUnsupportedVoidPtr">Simulink Function ブロック ''{1}'' の引数 ''{0}'' が ''void*'' 型に設定されています。AUTOSAR コード生成では Function Caller ブロックに対してのみこれがサポートされています。AUTOSAR ターゲットでは、特定の不揮発性メモリ (NvM) オペレーションにマッピングされた Function Caller ブロックは自動的に ''void*'' 型の引数を用いて設定されます。その場合、対応する Simulink Function ブロックは、シミュレーション用にのみ定義可能となります。</entry>
    <entry key="SlFcnFpcUnsupportedCaller"> Simulink Function ブロック ''{0}'' の呼び出し元はコード生成でサポートされていません。Function Caller ブロックを少なくとも 1 つ使用して Simulink Function ブロックを呼び出してください。</entry>
    <entry key="RTWDataTypeHeaderFileIdConflict">型 ''{1}'' 用に指定されているヘッダー ファイルが、モデルで生成されたファイルと競合するので、型 ''{0}'' を使用してコードを生成できません。</entry>
    <entry key="ExpFcnRootOutportDrivenByStatePort">ルート Outport ブロック ''{0}'' は、エクスポート関数モデル内のブロック ''{1}'' の状態端子によって駆動することはできません。</entry>
    <entry key="VirtualBusDrivingVirtualRootOutport">ルート Outport ブロック ''{0}'' はバーチャルでなければならないため、バーチャル バス信号を受け入れることができません。</entry>
    <entry key="DiscontigVirtualRootOutport">ルート Outport ブロック ''{0}'' はバーチャルでなければなりません。ソース出力端子から Outport ブロックへの接続は、要素の並べ替えや選択が行われない、端子のみによる直線の接続であることを確認してください。</entry>
    <entry key="NoBranchingToSameVirtualRootOutport">ブロック ''{0}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; からバーチャル ルート Outport ブロック ''{2}'' への接続が無効です。出力信号を分岐した後で、同じバーチャル ルート Outport ブロックを駆動するために再結合することはできません。</entry>
    <entry key="NoBranchingToTwoVirtualRootOutports">ブロック ''{0}'' の&lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;出力端子 {1,number,integer}&lt;/sldiag&gt; からルート Outport ブロック ''{2}'' および ''{3}'' への接続が無効です。出力信号は、複数のバーチャル ルート Outport ブロックに分岐できません。</entry>
    <entry key="BufferRequiredOnInitResetTermOutport">Outport ブロック ''{0}'' は、ソース信号が Initialize Function、Terminate Function、Reinitialize Function または Reset Function ブロック内から派生しているため、バーチャルである必要があります。しかし、Simulink はその接続パス上のある位置に信号バッファーが必要と判定しました。ソース出力端子から Outport ブロックへの接続は、要素の並べ替えや選択が行われない、端子のみによる直線の接続であることを確認してください。</entry>
    <entry key="BufferRequiredOnVirtualOutport">Outport ブロック ''{0}'' はバーチャルでなければなりません。しかし、Simulink はソース出力端子からのパス上のある位置に信号バッファーが必要と判定しました。ソース出力端子から Outport ブロックへの接続は、要素の並べ替えや選択が行われない、端子のみによる直線の接続であることを確認してください。</entry>
    <entry key="NonEmptyICOnInitResetTermParentOutport">Outport ブロック ''{0}'' は初期出力値をもつことができません。そのソース信号が、Initialize Function、Terminate Function、Reinitialize Function または Reset Function ブロックから発生するためです。この問題を修正するには、Outport ブロックのパラメーター ''{1}'' を ''on'' に設定してください。あるいは、Outport ブロックのパラメーター [初期出力] を空行列 ([]) に設定してください。</entry>
    <entry key="VirtualOutportCodeGenErrorDueToDataConnector">Outport ブロック ''{0}'' のパラメーター ''{1}'' がオンになっていますが、Simulink は以下の理由により、生成されたコード内で出力端子がバーチャルになることを保証できません。この問題を修正する方法の 1 つは、パラメーター ''{1}'' を ''off'' に設定することです。 </entry>
    <entry key="InitTermResetCodeGenErrorDueToDataConnector">Outport ブロック ''{0}'' は、Initialize Function ブロック、Reinitialize Function ブロック、Reset Function ブロック、または Terminate Function ブロックによって駆動されるため、生成されたコード内でバーチャルである必要があります。しかし、Simulink は以下の理由により、この条件を満たすことができません。</entry>
    <entry key="OutportNeedsToBeVirtualForUnionRate">Outport ブロック ''{0}'' は、レートの結合の下で Simulink Function Call Subsystem によって駆動されるため、生成されたコード内ではバーチャルである必要があります。しかし、Simulink は以下の理由により、この条件を満たすことができません。</entry>
    <entry key="ReusableSSDrivingRootOutportWithEnsureVirtualSpec">Outport ブロック ''{0}'' は、再利用可能な関数を生成するように設定されたサブシステム ''{1}'' によって駆動されています。この問題を修正するには、サブシステムのパラメーター [関数のパッケージ化] を [インライン] または [再利用できない関数] に設定します。</entry>
    <entry key="NoDataConnectorRootOutportWithEnsureVirtualSpec">生成されたコード内でルート Outport ブロック ''{0}'' がバーチャルであることを確認できません。この問題を修正するには、Outport ブロックのパラメーター ''{1}'' を ''off'' に設定してください。</entry>
    <entry key="DifferentWidthsRootOutportWithEnsureVirtualSpec">ルート Outport ブロック ''{0}'' とそのソース ブロック ''{1}'' の幅が異なっています。この問題を修正するには、Outport ブロック ''{0}'' とそのソースの両方の幅が必ず同じになるようにしてください。
</entry>
    <entry key="VarDimsRootOutportEnsureVirtualSpec">ルート Outport ブロック ''{0}'' の入力は可変次元です (または可変次元の要素を含みます)。
</entry>
    <entry key="SourceWithConstSampleTimeRootOutportWithEnsureVirtualSpec">ルート Outport ブロック ''{0}'' のソース ブロック ''{1}'' は定数のサンプル時間をもつため、Simulink はルート Outport ブロックがバーチャルであることを確認できません。この問題を修正するには、ソース ブロック ''{1}'' が定数でないサンプル時間を必ず使用するようにしてください。
</entry>
    <entry key="VirtualOutportDueToSpecification">Outport ブロック ''{0}'' は、そのパラメーター ''{1}'' が ''on'' に設定されているため、バーチャルでなければなりません。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{0}'',''EnsureOutportIsVirtual'',''off'')&lt;/cmd&gt; &lt;txt&gt;''copy'' セマンティクスに切り替える (また、可能であれば異なる結果を得る) ため、ブロック ''{0}'' のパラメーター ''{1}'' を ''off'' に設定する&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="VirtualOutportDueToIRT">The Outport block ''{0}'' must be virtual because its source signal originates from an Initialize, Terminate, Reinitialize or Reset Function block.</entry>
    <entry key="VirtualOutportDueToExpFcn">エクスポート関数モデルのルート Outport ブロック ''{0}'' は、以下のいずれかの理由によりバーチャルでなければなりません:\n (1) Merge ブロックにより駆動されている。\n (2) Mux ブロックにより駆動されている。\n (3) パラメーター ''{1}'' が ''on'' に設定されている Outport ブロックにより駆動されている。\n (4) 別のエクスポート関数モデルを参照している Model ブロックの出力端子により駆動されており、参照モデルの対応するルート出力端子が、上記いずれかの理由によりバーチャルであるよう求められている。</entry>
    <entry key="NoDataConnectorVirtualRootOutport">ルート Outport ブロック ''{0}'' はバーチャルでなければなりません。ただし、生成されたコード内ではこの条件は保証されません。このエラー メッセージの詳細については MathWorks にお問い合わせください</entry>
    <entry key="InitResetTermNeedSimplifiedInitMode">The Initialize, Reinitialize, Reset, or Terminate Function block ''{0}'' requires simplified initialization mode for model ''{1}''. For more information, see &lt;a href="matlab:helpview([docroot '/simulink/ug/simplified-initialization-mode.html'])"&gt;Simplified initialization mode&lt;/a&gt;.
&lt;actions exclusiveFixIts="yes"&gt;
&lt;action type="fixit"&gt;
&lt;cmd&gt;configset.internal.fixIt(''{1}'',''UnderspecifiedInitializationDetection'',''Simplified'')&lt;/cmd&gt;
&lt;txt&gt;Set the parameter &lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;"Underspecified initialization detection"&lt;/sldiag&gt; in the Diagnostics page of the Configuration Parameters dialog to ''Simplified''.&lt;/txt&gt;
&lt;/action&gt;
&lt;/actions&gt;
</entry>
    <entry key="SimulinkStateNeedSimplifiedInitMode">モデル ''{1}'' では、Simulink ステート ''{0}'' に簡易初期化モードが必要です。詳細については、「&lt;a href="matlab:helpview([docroot '/simulink/ug/simplified-initialization-mode.html'])"&gt;簡易初期化モード&lt;/a&gt;」を参照してください。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{1}'',''UnderspecifiedInitializationDetection'',''Simplified'')&lt;/cmd&gt; &lt;txt&gt;[コンフィギュレーション パラメーター] ダイアログの [診断] ページにある &lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;[指定不足の初期化の検出]&lt;/sldiag&gt; パラメーターを [簡易] に設定する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="OutportStateAccessNeedSimplifiedInitMode">Outport ブロック ''{1}'' の読み取り/書き込みをサポートするために、モデル ''{0}'' は簡易初期化モードを使用しなければなりません。詳細については、「&lt;a href="matlab:helpview([docroot '/simulink/ug/simplified-initialization-mode.html'])"&gt;簡易初期化モード&lt;/a&gt;」を参照してください。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''UnderspecifiedInitializationDetection'',''Simplified'')&lt;/cmd&gt; &lt;txt&gt;[コンフィギュレーション パラメーター] ダイアログの [診断] ページにある &lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;[指定不足の初期化の検出]&lt;/sldiag&gt; パラメーターを [簡易] に設定する。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="InvalidVariableSizeSignalForRootOutport"> Outport ブロック ''{0}'' には、非自動ストレージ クラスの信号オブジェクトがあります。しかし、可変サイズの信号により駆動されています。現在、このような場合に可変サイズの信号は使用できません。 </entry>
    <entry key="UnableToUpdateModel"> モデル ''{0}'' を更新できません。 </entry>
    <entry key="AlgConstBlockMultipleConfigs">同じ代数ループ内にある {0,number,integer} 個の Algebraic Constraint ブロックの一部は、同じソルバーと許容誤差の値を指定していません。</entry>
    <entry key="FMUModeDisallowedSS">''{0}'' は {1} モードの FMU ブロックです。{1} モードの FMU ブロックは、{2} Subsystem ''{3}'' 内部で許可されていません。</entry>
    <entry key="FMUModeDisallowedSSState">''{0}'' は {1} モードの FMU ブロックです。{1} モードの FMU ブロックは、状態が ''{4}'' の {2} Subsystem ''{3}'' 内部で許可されていません。</entry>
    <entry key="FMUModeIsNotRecognized">FMU モード ''{0}'' は ''{1}'' ブロックでは認識されません。</entry>
    <entry key="SameNamedModelSourceAndDataFile">モデルは、ソース ファイル ''{0}''、および同じ名前のデータ ファイル ''{0}'' を生成しようとしています。ソース ファイル名/データ ファイル名の設定を変更するか、ファイル パッケージ形式を [コンパクト] に変更してください。</entry>
    <entry key="BlockMultiThreadCoSimThreadSafeWarning">S-Function が実行時スレッドセーフとして宣言されていない場合であっても、''{0}'' ブロックに関連付けられている S-Function は実行時スレッドセーフとして強制的に実行されます。警告を回避するには、''ssSetRuntimeThreadSafetyCompliance(S, RUNTIME_THREAD_SAFETY_COMPLIANCE_TRUE)'' で S-Function を実行時スレッドセーフとして宣言してください。</entry>
    <entry key="BlockMultiThreadCoSimThreadSafeError">The S-function associated with ''{0}'' block will not be forced to run as run-time thread-safe because the S-function has been declared as not run-time thread-safe. To set the S-function as run-time thread-safe, use ''ssSetRuntimeThreadSafetyCompliance(S, RUNTIME_THREAD_SAFETY_COMPLIANCE_TRUE)''.</entry>
    <entry key="MTCSGlobalErrorStatus">1 つ以上のマルチスレッド ブロックが "ssSetErrorStatus" を使用することで、エラーを不正確に報告する可能性があります。正確なエラー レポートの詳細については、代わりに "ssSetLocalErrorStatus" を使用します。</entry>
    <entry key="MTCSBlocker_Accel">アクセラレータ モードの Model ブロックでは、マルチスレッディングがサポートされます。Model ブロックをアクセラレータ モードに設定してください。</entry>
    <entry key="MTCSBlocker_BlkSetting">ブロック プロパティ ''MultithreadedSim'' がオフになっています。ブロック設定を有効にするには、set_param(blockName, ''MultithreadedSim'', ''auto'') を使用してください。</entry>
    <entry key="MTCSBlocker_CompChk">S-Function アナライザーがオンの場合、マルチスレッディングは有効になりません。ノーマル モードでマルチスレッディングを試してください。</entry>
    <entry key="MTCSBlocker_ConstBlock">定数のサンプル時間をもつブロックでは、マルチスレッディングは有効になりません。</entry>
    <entry key="MTCSBlocker_ContStChk">S-Function に連続状態があり、ソルバーが固定ステップである場合、マルチスレッディングは有効になりません。これは、この両方が揃うと連続状態の整合性チェックがトリガーされるためです。連続状態の整合性チェックを無効にするには、関数 ''ssSetSkipContStatesConsistencyCheck'' を使用します。</entry>
    <entry key="MTCSBlocker_ContTS">S-Function に連続サンプル時間がある場合、マルチスレッディングは有効になりません。別の &lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''],''specifying_sample_time'')"&gt;"サンプル時間設定"&lt;/a&gt; の使用を検討してください。</entry>
    <entry key="MTCSBlocker_Coverage">カバレッジ (内部で使用)。</entry>
    <entry key="MTCSBlocker_Debugger">Simulink デバッガーがオンの場合、マルチスレッディングは有効になりません。Simulink デバッガーをオフにしてください。</entry>
    <entry key="MTCSBlocker_MRToFile">モデルに To File ブロックが含まれている場合、マルチスレッディングは有効になりません。&lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''],''data_logging_summary'')"&gt;"シミュレーション データのエクスポート"&lt;/a&gt; には別の方法を使用することを検討してください。</entry>
    <entry key="MTCSBlocker_MRFromFile">モデルに From File ブロックが含まれている場合、マルチスレッディングは有効になりません。最上位モデルからのインポートによって参照モデルにデータを入力することを検討してください。</entry>
    <entry key="MTCSBlocker_MRDSM">モデルがグローバル データストアを使用している場合、マルチスレッディングは有効になりません。</entry>
    <entry key="MTCSBlocker_MRConstant">モデルに定数のサンプル時間がある場合、マルチスレッディングは有効になりません。</entry>
    <entry key="MTCSBlocker_MRRuntimeDiag">実行時の診断を発行するブロックが参照モデルに含まれている場合、マルチスレッディングは有効になりません。</entry>
    <entry key="MTCSBlocker_MRCoverage">カバレッジ (内部で使用)。</entry>
    <entry key="MTCSBlocker_MRSLFunc">モデルに Simulink Function ブロックが含まれている場合、マルチスレッディングは有効になりません。</entry>
    <entry key="MTCSBlocker_DebugLog">FMU ブロックのデバッグ ログが有効な場合、マルチスレッディングは有効になりません。FMU ブロックのデバッグ ログを無効にするには、set_param(blockName, ''FMUDebugLogging'', ''off'') を使用します。</entry>
    <entry key="MTCSBlocker_CrossplatformSim">FMU ブロックがクロスプラットフォーム シミュレーションを実行している場合、マルチスレッディングは有効になりません。</entry>
    <entry key="MTCSBlocker_DynProf">計算コストでは、マルチスレッディングの {0} メソッドのオーバーヘッド コストは正当化されません。「&lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''],''comp_based_model_guidelines'')"&gt;コンポーネントベースのモデル化のガイドライン&lt;/a&gt;」を参照してください。</entry>
    <entry key="MTCSBlocker_DynProfNotFinished">{0} メソッドの動特性を測定するための十分なステップ数がシミュレーションにはありませんでした。シミュレーションをより長く実行してみてください。</entry>
    <entry key="MTCSBlocker_EventPort">Model ブロックにイベント端子がある場合、マルチスレッディングは有効になりません。</entry>
    <entry key="MTCSBlocker_ExcFree">マルチスレッディングでは、例外のないオプションを宣言するために S-Function が必要です。詳細については、&lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''],''guidelines_for_threadsafe_sfunctions'')"&gt;「Guidelines for Writing Thread-Safe S-Functions」&lt;/a&gt;を参照してください。</entry>
    <entry key="MTCSBlocker_FMUME">マルチスレッディングは、コシミュレーション モードでのみ有効です。Co-Simulation FMU の代わりに Model Exchange FMU を使用することを検討してください。</entry>
    <entry key="MTCSBlocker_ForEachSS">Model ブロックが For Each Subsystem 内にある場合、マルチスレッディングは有効になりません。Model ブロックを For Each Subsystem から移動することを検討してください。</entry>
    <entry key="MTCSBlocker_Graph">ブロックは、マルチスレッド化できない別のブロックに依存しています。Unit Delay ブロックを使用するなどして依存関係を解消することを検討してください。</entry>
    <entry key="MTCSBlocker_TOPO_Source_Node_RTTS_YES_BUT_DF">開始ブロックは直達入力をもつことができません。</entry>
    <entry key="MTCSBlocker_MdlSetting">マルチスレッディングのモデル設定がオフになっています。モデルのマルチスレッディングを有効にするには、set_param(modelName, ''MultithreadedSim'', ''auto'') を使用してください。</entry>
    <entry key="MTCSBlocker_Multirate">マルチスレッディングはシングルレート ブロックでサポートされます。マルチスレッディングを有効にするには、マルチレート ブロックをシングルレート ブロックに変換してください。</entry>
    <entry key="MTCSBlocker_NoBlock">マルチスレッディングの条件を満たすブロックがありません。既存のブロックのマルチスレッディング条件が満たすか、新しいブロックを追加してください。</entry>
    <entry key="MTCSBlocker_NoOutput">マルチスレッディングでは、出力メソッドと更新メソッドが同時に実行されます。ブロックに出力メソッドがありません。</entry>
    <entry key="MTCSBlocker_NotDefault">既定のブロック ケースではありません (内部で使用)。</entry>
    <entry key="MTCSBlocker_NoUpdate">マルチスレッディングでは、出力メソッドと更新メソッドが同時に実行されます。ブロックに更新メソッドがありません。</entry>
    <entry key="MTCSBlocker_OOP">FMU がプロセス外で実行されている場合、マルチスレッディングはサポートされません。この設定を無効にするには、set_param(blockName, ''DebugExecutionForFMUViaOutOfProcess'', ''off'') を使用してください。</entry>
    <entry key="MTCSBlocker_RTAPI">S-Function ランタイム モデル API のサポートがオフです (内部で使用)。</entry>
    <entry key="MTCSBlocker_RTThrSafe">マルチスレッディングでは、ランタイムのスレッドセーフティに対するコンプライアンス オプションを true に設定するために S-Function が必要です。詳細については、&lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''],''guidelines_for_threadsafe_sfunctions'')"&gt;「Guidelines for Writing Thread-Safe S-Functions」&lt;/a&gt;を参照してください。</entry>
    <entry key="MTCSBlocker_RTThrSafeFCGen">Function-Call Generator ブロックでマルチスレッディングが有効になっていません。</entry>
    <entry key="MTCSBlocker_SimMode">マルチスレッディングは、ノーマル シミュレーション モードでのみサポートされます。</entry>
    <entry key="MTCSBlocker_VarTS">マルチスレッディングでは可変サンプル時間はサポートされません。「&lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''],''specifying_sample_time'')"&gt;サンプル時間の設定&lt;/a&gt;」を参照してください。</entry>
    <entry key="MTCSBlockerBlockOutputIn">並列出力メソッドの実行に参加している</entry>
    <entry key="MTCSBlockerBlockUpdateIn">並列更新メソッドの実行に参加している</entry>
    <entry key="MTCSBlockerBlockOut">並列実行に参加していない</entry>
    <entry key="MTCSBlockerBlockName">MTCS ブロック: ''{0}''</entry>
    <entry key="MTCSBlockerBlockType">ブロック タイプ: {0}</entry>
    <entry key="MTCSBlockerBlockUnknown">不明なブロッカー</entry>
    <entry key="MTCSBlockerBlockCommon">共通ブロッカー</entry>
    <entry key="MTCSBlockerBlockOutput">出力メソッド固有のブロッカー</entry>
    <entry key="MTCSBlockerBlockUpdate">更新メソッド固有のブロッカー</entry>
    <entry key="MTCSBlockerModelName">モデル: ''{0}''</entry>
    <entry key="MTCSBlockerModelIn">並列実行に参加している</entry>
    <entry key="MTCSBlockerModelOut">並列実行に参加していない</entry>
    <entry key="MTCSBlockerModelUnknown">不明なブロッカー</entry>
    <entry key="MTCSBlockerModelAll">ブロッカー</entry>
    <entry key="MTCSBlockerHeader">マルチスレッド シミュレーション ブロッカーの開始</entry>
    <entry key="MTCSBlockerFooter">マルチスレッド シミュレーション ブロッカーの終了</entry>
    <entry key="TruncateWrittenStringParam"> ブロック ''{1}'' のパラメーター ''{0}'' には、すべての文字を格納するための ''{2, number, integer}'' バイトのバッファー サイズと、末尾に null 終端が必要です。この必要なバッファー サイズが、コンフィギュレーション パラメーター [動的サイズ文字列のバッファー サイズ] によって指定される動的文字列のバッファー サイズを超過しています。生成されたコードに対して、ブロックは ''{3, number, integer}'' バイトのバッファーに収まるようにパラメーター値を打ち切ります。打ち切りを避けるには、文字列バッファーのサイズを増やすことを検討してください。</entry>
    <entry key="TruncateWrittenStringOutput"> ブロック ''{1}'' の&lt;sldiag objui="outport" objparam="{0, number, integer}" objname="{1}"&gt;出力端子 {0, number, integer}&lt;/sldiag&gt; の初期値には、すべての文字を格納するための ''{2, number, integer}'' バイトのバッファー サイズと、末尾に null 終端が必要です。この必要なバッファー サイズが、コンフィギュレーション パラメーター [動的サイズ文字列のバッファー サイズ] によって指定される動的文字列のバッファー サイズを超過しています。生成されたコードに対して、ブロックは ''{3, number, integer}'' バイトのバッファーに収まるように初期値を打ち切ります。打ち切りを避けるには、文字列バッファーのサイズを増やすことを検討してください。</entry>
    <entry key="CrossModelModification">別のモデルの InitFcn コールバックによってモデル ''{0}'' を変更するのは誤りです。</entry>
    <entry key="ErrCreateBlockDiagramThroughMCOS">MCOS を介して直接ブロック線図を作成するのは誤りです。</entry>
    <entry key="SolverProfileLevelInvalidName">ソルバー プロファイラーのログ レベルのフィールド名 ''{0}'' が無効です。</entry>
    <entry key="SolverProfileLevelMustBeStruct">パラメーター SolverProfileInfoLevel は MATLAB struct でなければなりません。</entry>
    <entry key="ErrCallDeleteOnObject">このオブジェクトは削除操作をサポートしません。</entry>
    <entry key="ErrGetUDIWithFeatureON">UDDToMCOS 機能がオンのときに、get_udi を呼び出してはなりません。</entry>
    <entry key="ArchitectureExportToPreviousNotSupported">アーキテクチャ モデルを Simulink R2019a 以前のバージョンにエクスポートすることはサポートされていません。</entry>
    <entry key="NotAcyclicGraph">この基となるグラフは非循環グラフではありません。</entry>
    <entry key="InvalidSubsysDiffPross">サブシステムの比較処理が無効です。チェックサムを比較するために、厳密に 2 つのサブシステムがマークされていなければなりません。</entry>
    <entry key="BusElementEmptySLValueType">バス オブジェクト ''{1}'' のバス要素 ''{0}'' は空の ValueType を指定しています。 </entry>
    <entry key="BusElementCannotFindSLValueType">バス オブジェクト ''{2}'' のバス要素 ''{1}'' に指定された 'ValueType' ''{0}'' が見つかりません。 </entry>
    <entry key="BlockCannotFindSLValueType">ブロック ''{1}'' 用に指定された 'Simulink.ValueType' ''{0}'' が見つかりません。 </entry>
    <entry key="SimulinkTypeCannotBeEmpty">ブロック ''{1}'' 用に指定された Simulink.ValueType ''{0}'' は、プロパティの値を指定しなければなりません。 </entry>
    <entry key="SlDataObjectEmptySLValueType">Simulink データ オブジェクト ''{0}'' が空の値タイプを指定しています。 </entry>
    <entry key="SlDataObjectCannotFindSLValueType">Simulink データ オブジェクト ''{1}'' に指定されている値タイプ ''{0}'' が見つかりません。 </entry>
    <entry key="SlParameterValueMismatchValueTypeDataType">値タイプ ''{0}'' はバス オブジェクトを指定していますが、Simulink.Parameter オブジェクト ''{1}'' の ''Value'' の数値は構造体ではありません。データ型は一致していなければなりません。</entry>
    <entry key="SlParameterValueMismatchValueTypeDataTypeEnum">Simulink.Parameter オブジェクト ''{0}'' の ''Value'' プロパティには列挙データ型の値 ''{1}'' が指定されていますが、''DataType'' プロパティにはデータ型 ''{3}'' の Simulink.ValueType オブジェクト ''{2}'' が指定されています。データ型は一致していなければなりません。</entry>
    <entry key="SlParameterValueMismatchValueTypeDimensions">値タイプ ''{0}'' と、Simulink.Parameter オブジェクト ''{1}'' の ''Value'' の数値の次元は一致していなければなりません。</entry>
    <entry key="SlParameterValueMismatchValueTypeComplexity">値タイプ ''{0}'' と、Simulink.Parameter オブジェクト ''{1}'' の ''Value'' の数値の実数/複素数は一致していなければなりません。</entry>
    <entry key="ModelNotLoaded">No model loaded.</entry>
    <entry key="SymbolicDimsWithVariableDimsUnsupportedCause">ブロック ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt;</entry>
    <entry key="SymbolicDimsWithVariableDimsUnsupported">シンボリック次元は固定サイズの信号でのみサポートされます。次のブロック端子を更新して、シンボリック次元と可変サイズ信号のいずれか一方のみを使用するようにします。</entry>
    <entry key="InvalidBlockIOBufferSizeCause">ブロック ''{1}'' の&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;出力端子 {0,number,integer}&lt;/sldiag&gt;</entry>
    <entry key="InvalidBlockIOBufferSize">Simulink は個々のブロックで最大 {0,number,integer} バイトの I/O 信号サイズをサポートします。信号サイズは、データ型のサイズ、要素数、信号の実数/複素数に基づいて計算されます。次のブロック端子がこの限度を超過しています。</entry>
    <entry key="HeaderGuardPrefixInvalidStr">カスタム ヘッダー ガード接頭辞が無効です。スペースのない文字列リテラルのみ使用できます。</entry>
    <entry key="HalideFolderInvalidAccess">フォルダーへのアクセス権がありません。</entry>
    <entry key="PromptForChange">変更</entry>
    <entry key="PromptForIgnore">無視</entry>
    <entry key="PromptForAlwaysIgnore">常に無視</entry>
    <entry key="PointerBusNameNotFound">ポインター バス名 ''{0}'' はバス オブジェクトを指定していますが、そのようなバス オブジェクトはワークスペースまたはデータ ディクショナリ内に見つかりません。</entry>
    <entry key="EditTimeDashBoardOpenTip">モデリング ガイダンスの表示</entry>
    <entry key="EditTimeDashBoardNoIssuesTip">モデル内に問題は見つかりません</entry>
    <entry key="EditTimeDashBoardIssuesFoundTip">モデル化の問題が検出されました。クリックして表示してください。</entry>
    <entry key="OpaqueEnumFeatureConflict">次のいずれかの機能を既定値から変更するには、調整可能な列挙型の機能を無効にする必要があります: RangeAnalysisForEnums、ShrinkCfgSwitchPruning、または PreserveEnumsWithDuplicateValues。MathWorks のテクニカル サポートにお問い合わせください</entry>
    <entry key="OpaqueEnumFeatureConflict2">次の機能は将来のリリースで削除される予定です: RangeAnalysisForEnums、ShrinkCfgSwitchPruning、PreserveEnumsWithDuplicateValues。代わりに調整可能な列挙型を使用してください。</entry>
    <entry key="BlockNotAvailable">ブロック ''{0}'' はシミュレーションから削除されているため、その出力にマークされた線形化ポイントは利用できなくなりました。</entry>
    <entry key="LinearizationWithSFuncArrayOfBus">Linearization points cannot be placed on signals that are arrays of buses.</entry>
    <entry key="SLFcnNameClashWithMdlCppConstructor"> Simulink function name ''{0}'' clashes with the C++ class constructor name of the model ''{1}''. Consider changing the function name or changing the 'Code interface packaging' parameter to a setting other than 'C++ class'</entry>
    <entry key="FallBackToNonVm"/>
    <entry key="BlkInAlgLoopWarnInfo"> ''{0}''{1}{2}\n</entry>
    <entry key="Comp_CompileDone"/>
    <entry key="Comp_Model_Terminated"> </entry>
    <entry key="DomainDynamicPortTypeInternalError">Internal error: Error encountered while setting up port type ''{0}'' in domain ''{1}''.  However, unable to remove port type due to subsequent errors.  See attached cause for original error encountered while setting up the port type.</entry>
    <entry key="TipAlert_AutoConnectionPrefsKey">SimulinkTipAlertAutoConnectTip</entry>
    <entry key="MxArrayIsNotSparse">
      The matrix is not sparse.
    </entry>
    <entry key="PrArrayIsNULL">
      Its Pr array is NULL.
    </entry>
    <entry key="PiArrayIsNULL">
      Its Pi array is NULL.
    </entry>
    <entry key="IrArrayIsNULL">
      Its Ir array is NULL.
    </entry>
    <entry key="JcArrayIsNULL">
      Its Jc array is NULL.
    </entry>
    <entry key="PrArrayIsNotZero">
      Its Pr array is Pr = '{'{0}'}' now. However, it should be Pr = '{'0'}'.
    </entry>
    <entry key="PiArrayIsNotZero">
      Its Pi array is Pi = '{'{0}'}' now. However, it should be Pi = '{'0'}'.
    </entry>
    <entry key="IrArrayIsNotZero">
      Its Ir array is Ir = '{'{0}'}' now. However, it should be Ir = '{'0'}'.
    </entry>
    <entry key="JcArrayNotOneZero">
      Its Jc array is Jc = '{'{0}'}' now. However, it should be Jc = '{'0'}'.
    </entry>
    <entry key="JcArrayTailWrong">
      The last element of Jc array does not equal to nzmax. nCols == {0}, Jc[nCols] == {1}, nzmax == {2}.
    </entry>
    <entry key="AllZeroButNzmax">
      Its Ir and Jc arrays'' elements are all zero, but nzmax is {0}.
    </entry>
    <entry key="PassFormatCheck">
      Pass the check.
    </entry>
    <entry key="IrArrayWrongOrder">
      The order of element in Ir array's is wrong at row {0} (the first row's index is 0).
    </entry>
    <entry key="JcArrayWrongOrder">
      Jc[{0}] is larger than Jc[{1}].
    </entry>
    <entry key="JcArrayNotAllZero">
      Its Jc array has Jc[{0}] == {1}. However, Jc should be a all zero array.
    </entry>
    <entry key="JcArrayHeadWrong">
      Its nzmax &gt; 0, the Jc array has Jc[0] = {0} now. However, there should always be Jc[0] = 0.
    </entry>
    <entry key="NzmaxNotMatch">
      Its Jc[nCols] == 0, nzmax == {0}. However, there should be Jc[nCols] == nzmax or Jc[nCols] == 0, nzmax == 1.
    </entry>
    <entry key="RapidAccelCmdlSim">cmdlsim</entry>
    <entry key="RapidAccelMenuSim">menusim</entry>
    <entry key="RapidAccelCmdlBuildOnly">buildonly</entry>
    <entry key="AlgConstBlockInAlgLoopInfo"> ''{0}'' ({1,number,integer})</entry>
  </message>
</rsccat>
