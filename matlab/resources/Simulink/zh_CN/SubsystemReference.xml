<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="zh_CN" product="Simulink" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="SRTabText">子系统引用</entry>
    <entry key="SRParameterPrompt">子系统文件名:</entry>
    <entry key="SRConvert">转换</entry>
    <entry key="SRCancel">取消</entry>
    <entry key="SRIconNotFound">未找到</entry>
    <entry key="SRIconNotLoaded">未加载</entry>
    <entry key="SRIconInvalidBdType">不是有效的文件类型</entry>
    <entry key="SRIconCircularLoop">导致循环</entry>
    <entry key="SRTabHelpText">从文件中引用子系统内容。</entry>
    <entry key="OpenSubsysButtonText">打开</entry>
    <entry key="OpenReferencedSubsysMenuText">打开引用子系统</entry>
    <entry key="ConvertToSRMenuText">引用子系统...</entry>
    <entry key="ConvertToSRButtonText">转换...</entry>
    <entry key="ConvertToSRDlgTitleText">转换为子系统引用</entry>
    <entry key="ErrorDuringTransferOfTH">测试框架转移过程中出错</entry>
    <entry key="ConvertToSRHelpText">将子系统转换为引用子系统且内容保存在单独文件中。</entry>
    <entry key="ConvertingText">正在转换...</entry>
    <entry key="ConvertToSRInputGroupPrompt">输入参数</entry>
    <entry key="OpenMasterGraphMenuText">打开已编辑的实例</entry>
    <entry key="OpenSimulatingGraphMenuText">打开正在仿真的实例</entry>
    <entry key="GoToInstancesMenuText">转至实例</entry>
    <entry key="BrowseSubsystemFile">选择子系统文件</entry>
    <entry key="SaveSubsystemFile">保存子系统文件</entry>
    <entry key="SelectedSubsystemNotOnPath">引用子系统模块图 ''{0}'' 必须在 MATLAB 路径中。</entry>
    <entry key="SelectedSubsystemPathIssueTitle">解决所选子系统的路径问题</entry>
    <entry key="MoveTestHarnessPrompt">迁移测试框架</entry>
    <entry key="MovingTestHarnessMessage">将测试框架迁移到子系统模块图</entry>
    <entry key="InstallTestHarness">安装测试框架以启用该选项</entry>
    <entry key="NoAssociatedTestHarness">Subsystem 模块没有任何测试框架</entry>
    <entry key="CannotUpdateReadOnlyBlock">Failed to update block ''{0}'' because it is a write-protected subsystem</entry>
    <entry key="CannotChangeParamReadOnlyBlock">Failed to change 'ReferencedSubsystem' parameter value of block ''{0}'' because it is a write-protected subsystem</entry>
    <entry key="CannotChangeParamFromMaskCallback">由于封装回调正在执行，无法更改模块 ''{0}'' 的 'ReferencedSubsystem' 参数值</entry>
    <entry key="SRBadSetParamValue">Parameter 'ReferencedSubsystem' is not supported for block ''{0}''.</entry>
    <entry key="InvalidConversionInArchitecture">架构模型不支持具有参数 'ReferencedSubsystem' 的子系统转换。</entry>
    <entry key="SRNameMustBeValid">Invalid name ''{0}''. Subsystem file name must be a valid Simulink model name.</entry>
    <entry key="UnsupportedBlockAtRootLevel">子系统在顶层包含不支持的模块类型 ''{0}''。</entry>
    <entry key="UnsupportedOutportBlockAsStateOwnerAtTopLevel">Subsystem 模块 ''{0}'' 在顶层中有 Outport 模块 ''{1}''，其状态正在由 State Reader 或 State Writer 模块访问。</entry>
    <entry key="UnableToDeleteHarnessDuringConversion">无法将子系统转换为子系统模型，因为子系统中的某些模块具有与之相关联的测试框架。无法为子系统模型内的模块创建测试框架。在转换之前，请删除这些框架或将它们导出为独立模型。使用命令 ''sltest.harness.find'' 并指定子系统路径来查找相关框架。 </entry>
    <entry key="SRLockViolation">无法修改 ''{0}''，因为它被 ''{1}'' 锁定。</entry>
    <entry key="SSRefLockedBecauseOfSimulation">无法修改 ''{0}''。''{0}'' 因仿真而锁定。</entry>
    <entry key="OnlySubsystemCanBeConverted">转换不正确。只有子系统模块可以转换为 Subsystem Reference 模块。</entry>
    <entry key="OnlySubsystemReferenceCanBeConverted">Incorrect conversion. Only a Subsystem Reference block can be converted to subsystem.</entry>
    <entry key="VSSBlockCannotBeConverted">无法将模块 ''{0}'' 转换为 Subsystem Reference 模块，因为它是 Variant Subsystem 模块。</entry>
    <entry key="StateflowBlockCannotBeConverted">无法将模块 ''{0}'' 转换为 Subsystem Reference 模块，因为它是 Stateflow 模块。</entry>
    <entry key="ConfigurableSubsystemBlockCannotBeConverted">无法将模块 ''{0}'' 转换为 Subsystem Reference 模块，因为它是 Configurable Subsystem 模块。</entry>
    <entry key="NoReadOrWriteSubsystemCannotBeConverted">无法将模块 ''{0}'' 转换为 Subsystem Reference 模块，因为它具有 ''{1}'' 权限。</entry>
    <entry key="SimFunctionBlockCannotBeConverted">无法将模块 ''{0}'' 转换为 Subsystem Reference 模块，因为它是 Simulink Function 模块。</entry>
    <entry key="InitTermOrResetCannotBeConverted">无法将模块 ''{0}'' 转换为 Subsystem Reference 模块，因为无法转换 Initialize Function、Terminate Function 或 Reset Function 子系统。</entry>
    <entry key="StateOwnerAndAccessorNotInsideSameSubsystemCannotBeConverted">无法将模块 ''{0}'' 转换为 Subsystem Reference 模块，因为 State Reader 或 State Writer 模块及其所有者模块不在同一子系统中。</entry>
    <entry key="SSWithReinitPortCannotBeConverted">无法将模块 ''{0}'' 转换为 Subsystem Reference 模块，因为它具有重新初始化端口。</entry>
    <entry key="SSWithMaskHideContentsCannotBeConverted">无法将模块 ''{0}'' 转换为 Subsystem Reference 模块，因为其参数 'MaskHideContents' 设置为 'on'。</entry>
    <entry key="HarnessCUTCannotBeConverted">无法将模块 ''{0}'' 转换为 Subsystem Reference 模块，因为它指向测试框架中的在测组件。</entry>
    <entry key="SSRefBlockCannotBeConverted">Unable to convert block ''{0}'' to Subsystem Reference block as it is already a Subsystem Reference block.</entry>
    <entry key="LinkedBlockCannotBeConverted">无法将模块 ''{0}'' 转换为 Subsystem Reference 模块，因为它是链接模块。</entry>
    <entry key="FaultSSBlockCannotBeConverted">无法将模块 ''{0}'' 转换为 Subsystem Reference 模块，因为它是 Fault Subsystem 模块。</entry>
    <entry key="ConvertNotSupportForHarnessCUT">测试框架中的在测组件 ''{0}'' 无法转换为子系统引用。</entry>
    <entry key="CycleNotAllowed">不支持子系统引用循环。模型 ''{0}'' 有子系统引用循环: ''{1}''</entry>
    <entry key="SSRefLoopDetected">Subsystem Reference loop detected: ''{0}''</entry>
    <entry key="FoundMissingSubModel">Subsystem Reference 模块 ''{0}'' 缺失子模型 ''{1}''。</entry>
    <entry key="IncorrectChildModelType">无效的模块图类型 ''{0}''。Subsystem Reference 模块 ''{1}'' 必须引用一个子系统文件。</entry>
    <entry key="CannotMaskSubsystemReferenceBlock">Masking the Subsystem Reference block ''{0}'' is not supported. Use a system mask instead.</entry>
    <entry key="SaveBlockAlertTitle">保存引用子系统</entry>
    <entry key="SaveBlockAlertMessage">Subsystem Reference 模块 ''{0}'' 正在引用模型 ''{1}''。模型 ''{2}'' 有未保存的更改。选择: &lt;ul&gt; &lt;li&gt; &lt;b&gt;保存&lt;/b&gt;可保存 ''{3}''。&lt;li&gt; &lt;b&gt;全部保存&lt;/b&gt;可对有未保存更改的引用模型递归重复上述操作。&lt;li&gt; &lt;b&gt;取消&lt;/b&gt;可取消此模型及其父模型的保存操作。&lt;/ul&gt; </entry>
    <entry key="SaveButton">以保存 ''{0}''。</entry>
    <entry key="SaveAllButton">以对有未保存更改的引用子系统递归重复上述操作。</entry>
    <entry key="CancelButton">以取消对此模型及其父模型的保存操作。</entry>
    <entry key="BDAlreadyLoaded">无法创建 ''{0}''。''{1}'' 上存在同名的模块图并且已加载。</entry>
    <entry key="FileExists">文件 ''{0}'' 已存在。是否要替换它?</entry>
    <entry key="CannotCreateFile">无法创建 ''{0}''。文件 ''{0}'' 已存在。</entry>
    <entry key="CannotPointToParentBD">转换失败。''{0}'' 不能指向其父模块图 ''{1}''。</entry>
    <entry key="UnsupportedGapPortOnSSRef">无法将模块 ''{0}'' 转换为 Subsystem Reference 模块，因为它包含无序端口模块。端口必须从 1 开始连续编号。</entry>
    <entry key="UnableToModifyByModelCallback">无法从模型 ''{1}'' 的回调中修改 Subsystem Reference 模块 ''{0}'' 的内容。要修改内容，请在 Subsystem Reference 模块上使用自修改系统封装。</entry>
    <entry key="UnableToModifyByOutsideAncestorBlockCallback">无法从模块 ''{1}'' 的回调中修改 Subsystem Reference 模块 ''{0}'' 的内容。请改用来自 Subsystem Reference 模块 "{0}" 内部的模块的回调。</entry>
    <entry key="ContentMustModifiedByNearestParentMaskedBlock">无法从模块 ''{1}'' 的回调中修改 Subsystem Reference 模块 ''{0}'' 的内容。请使用直接封装的父模块 "{2}" 的封装回调。</entry>
    <entry key="UnableToModifyWithoutSelfModifyingMask">无法修改 Subsystem Reference 模块 ''{0}'' 的内容。要修改内容，请在 Subsystem Reference 模块上创建一个自修改系统封装。</entry>
    <entry key="SaveSystemWithDirtyReferencedSubsystems">文件 ''{0}'' 未保存，因为它包含脏引用子系统文件。要保存文件及其脏引用文件，请使用 save_system 函数并将 'SaveDirtyReferencedModels' 名称-值参量设置为 'on'。
    </entry>
    <entry key="InvalidFileSelected">Invalid file ''{0}'' specified. Specify a subsystem file.</entry>
    <entry key="SSRefBlockUnknownParameter">更新模块 ''{0}'' 时遇到问题: {1}</entry>
    <entry key="InvalidStateBlockOnSSRef">无法将模块 ''{0}'' 转换为 Subsystem Reference 模块。该子系统有一个 State Reader/Writer 模块，该模块访问跨子系统边界的状态。</entry>
    <entry key="SkippingParametersWhileSSRefConversion">Skipped mask parameter(s) ''{0}'' while converting subsystem mask to system mask as these parameters are not supported on system mask.</entry>
    <entry key="ChecksumViolation">Invalid use of Subsystem Reference block ''{0}''. ''{0}'' must match at least one unit test signature.
           
               &lt;actions exclusiveFixIts="yes"&gt;
                   &lt;action type="suggestion"&gt;
                       &lt;cmd&gt;Simulink.SubsystemReference.showSignatureDiffDialogForUnitTests(''{1}'');&lt;/cmd&gt;
                       &lt;txt&gt;Open the Signature Difference Viewer to understand the difference&lt;/txt&gt;
                   &lt;/action&gt;
                   &lt;action type="suggestion"&gt;
                       &lt;cmd&gt;configset.highlightParameter(bdroot(''{0}''),''SubsystemReferenceDiagnosticForUnitTest'');&lt;/cmd&gt;
                       &lt;txt&gt;Signature check can be disabled through diagnostic setting in configuration parameters&lt;/txt&gt;
                   &lt;/action&gt;
               &lt;/actions&gt;
           
    </entry>
    <entry key="ChecksumViolationInsideTH">测试框架 ''{1}'' 中 Subsystem Reference 模块 ''{0}'' 的使用无效。请打开并编译 ''{1}'' 以了解更详细的错误信息。</entry>
    <entry key="ChecksumViolationInsideModelRef">Subsystem Reference 模块 ''{0}'' 的用法无效。''{0}'' 必须匹配至少一个单元测试签名。模块 ''{0}'' 是通过模型引用模块编译的。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;Simulink.SubsystemReference.showSignatureDiffDialogForUnitTests(''{1}'', ''forModelRef'', true);&lt;/cmd&gt; &lt;txt&gt;打开签名差异查看器了解差异&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.highlightParameter(bdroot(''{0}''),''SubsystemReferenceDiagnosticForUnitTest'');&lt;/cmd&gt; &lt;txt&gt;可以通过配置参数中的诊断设置禁用签名检查&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
           
    </entry>
    <entry key="NoSignaturesGenerated">Subsystem Reference 模块 ''{0}'' 的用法无效。''{0}'' 必须匹配至少一个单元测试签名。''{1}'' 有尚未生成签名的单元测试。</entry>
    <entry key="SSRefMustBeAtomicInTH">测试框架 ''{0}'' 使用非原子的 Subsystem Reference 模块。只有原子 Subsystem Reference 模块可用于验证签名。</entry>
    <entry key="SSRefMustBeAtomic">无法引用 ''{0}''。''{1}'' 必须为原子模块才能引用 ''{0}''，因为 ''{0}'' 经过单元测试。</entry>
    <entry key="THCUTShouldBeSSRef">测试框架 ''{0}'' 不使用 Subsystem Reference 模块。使用 Subsystem Reference 模块的测试框架可用于验证签名。</entry>
    <entry key="RemovedCUTfromCompGraph">在测试框架 ''{0}'' 中，从编译的图中删除了 ''{1}''。</entry>
    <entry key="MarkSSRefAtomic">''{0}'' must be atomic to reference ''{1}'', as ''{1}'' is unit tested.</entry>
    <entry key="MarkSSRefReusable">''{0}'' 的函数打包必须可重用才能引用 ''{1}''，因为 ''{1}'' 经过了单元测试。</entry>
    <entry key="InvalidUnitTestInput">输入格式无效。输入必须为字符串或字符串的元胞数组。</entry>
    <entry key="InvalidTHName">测试框架名称 ''{0}'' 无效。''{1}'' 没有任何名为 ''{0}'' 的测试框架。</entry>
    <entry key="InvalidUnitTestName">无效的单元测试名称 ''{0}''。''{1}'' 没有任何名为 ''{0}'' 的单元测试。</entry>
    <entry key="GenerateSignature">以下单元测试需要生成签名: ''{0}''。</entry>
    <entry key="InvalidBDType">set_param 无效。模块图必须属于 '子系统' 类型</entry>
    <entry key="SaveUpdatedChecksum">已更新单元测试 ''{0}'' 的签名。请保存 ''{1}'' 以保存更新后的签名。</entry>
    <entry key="ErrorDuringSave">无法更新 ''{0}''</entry>
    <entry key="InvalidBlockOrBDType">Invalid Input. Block or Block diagram must be of type 'subsystem'</entry>
    <entry key="InputMustBeBD">Input must be a block diagram.</entry>
    <entry key="InputMustBeBlock">Input must be a block.</entry>
    <entry key="InputMustBeSSBD">Invalid input. Input must be a block diagram of type 'subsystem'.</entry>
    <entry key="InputTypeMustBeSSBD">Invalid input. ''{0}'' must be a block diagram of type 'subsystem'.</entry>
    <entry key="InputMustBeCellArrayOfUTNames">Invalid input. 2nd argument must be a cellarray of unit test names.</entry>
    <entry key="GenSignatureStage">生成签名</entry>
    <entry key="SelectUnitTestStage">选择单元测试</entry>
    <entry key="NoSignatureForSSBD">''{0}'' must have signatures generated to compare.</entry>
    <entry key="NoSignatureForCodeGen">''{0}'' 必须生成代码生成签名才能进行比较。</entry>
    <entry key="NoSignatureForSim">''{0}'' 必须生成仿真签名才能进行比较。</entry>
    <entry key="NoSigForUnitTests">单元测试 ''{0}'' 必须生成签名才能进行比较。</entry>
    <entry key="NoSimSigForUnitTests">单元测试 ''{0}'' 必须生成仿真签名才能进行比较。</entry>
    <entry key="NoCodeGenSigForUnitTests">单元测试 ''{0}'' 必须生成代码生成签名才能进行比较。</entry>
    <entry key="ContextSTFNonERT">单元测试 ''{0}'' 未指定 ERT 或 ERT 派生的系统目标文件。请指定一个 ERT 或 ERT 派生的系统目标文件，以在单元测试中编译此函数接口。</entry>
    <entry key="AUTOSARFunctionInterface">单元测试 ''{0}'' 的 "SystemTargetFile" 属性设置为 "autosar.tlc"。单元测试代码生成不支持 AUTOSAR 代码生成。</entry>
    <entry key="ContextSharedCodePlacementAuto">单元测试 ''{0}'' 的配置参数 '共享代码位置' 设置为 '自动'。因此，此单元测试不会生成任何子系统代码。请将该参数值设置为 '共享位置' 以允许此单元测试生成子系统代码。</entry>
    <entry key="CodeGenContextBuildFailed">代码生成器无法为子系统 ''{1}'' 编译单元测试 ''{0}''。\n要为该单元测试启用代码生成，请修复错误。您可以尝试将单元测试导出为独立模型，修复错误并将单元测试重新导入子系统文件。\n</entry>
    <entry key="ReuseBlocker"> 子系统 ''{0}'' 的生成代码无法跨模型重用，因此子系统 ''{0}'' 无法生成单元测试代码。\n \n子系统 ''{0}'' 的生成代码无法跨模型重用，因为存在如下模块和原因: \n 模块: ''{1}'' \n 原因: ''{2}'' \n</entry>
    <entry key="ChecksumDiffDialogTitle">签名差异查看器</entry>
    <entry key="SignatureDiffDialogDescUnitTest">这些表列出了模型和单元测试中 Subsystem Reference 模块的签名之间的差异。解析端口属性和编译的模块属性中的差异通常会匹配签名。</entry>
    <entry key="SignatureDiffDialogDescSubsystems">这些表列出了两个子系统的签名之间的差异。解析端口属性的差异和编译属性的差异通常会使签名匹配。</entry>
    <entry key="MismatchInPortProps">端口属性不匹配</entry>
    <entry key="MismatchInCompiledProps">编译模块属性不匹配</entry>
    <entry key="MismatchInCompilationFlags">编译属性不匹配</entry>
    <entry key="MismatchInInternalDetails">属性中不匹配的内部细节</entry>
    <entry key="InternalCompiledProps">内部编译属性</entry>
    <entry key="InternalCompiledContentProps">子模块内部编译属性</entry>
    <entry key="DiffInConfigSet">模型配置参数不匹配</entry>
    <entry key="DiffInSharedFcn">共享函数不匹配</entry>
    <entry key="CannotChangePermitHRParam">Unable to set 'Permit Hierarchical Resolution' (PermitHierarchicalResolution) parameter of Subsystem Reference ''{0}'' because the referenced subsystem ''{1}'' has linked external data sources.</entry>
    <entry key="DisplaySSRefDDVarResolutionInfo">在子系统引用工作区中解析的变量 ''{0}''。</entry>
    <entry key="NoMatchingContext">No unit tests in subsystem file ''{0}'' match subsystem ''{1}''.</entry>
    <entry key="SharedUtilsCSMismatch">Subsystem Reference 模块 ''{0}'' 无法重用单元测试代码，因为模型和单元测试的共享实用工具校验和不匹配。</entry>
    <entry key="NoCachedFolder">The Subsystem Reference block''{0}'' cannot reuse unit test code because the unit test code folder ''{1}'' or its shared code database does not exist. Verify that the subsystem file and unit test code are in the same folder the client model is generating code in.</entry>
    <entry key="ModelLibraryCodeFolderMismatch">Subsystem Reference 模块 ''{0}'' 无法重用单元测试代码，因为其父模型在 ''{1}'' 中生成代码，而单元测试代码位于 ''{2}'' 中。请在同一目录中为模型和单元测试生成代码以支持重用。 </entry>
    <entry key="ModelUsingModelSpecificFolderStructure">The Subsystem Reference block ''{0}'' cannot reuse unit test code because it is using 'ModelSpecific' code generation folder structure. Choose 'TargetEnvironmentSubfolder' code generation folder structure to enable the Subsystem Reference to reuse unit test code.
     
        &lt;actions exclusiveFixIts="yes"&gt;
            &lt;action type="fixit"&gt;
                &lt;cmd&gt;Simulink.SubsystemReference.internal.SSRefFixits.fixTargetEnvironmentSubfolder;&lt;/cmd&gt;
                &lt;txt&gt;Set file generation control parameter 'CodeGenFolderStructure' to 'TargetEnvironmentSubfolder'&lt;/txt&gt;
            &lt;/action&gt;
        &lt;/actions&gt;
        
    </entry>
    <entry key="FolderStructureActionPerformed">'CodeGenFolderStructure' 设置为 'TargetEnvironmentSubfolder'。</entry>
    <entry key="CodeOutofDate">Subsystem Reference 模块 ''{0}'' 无法重用单元测试代码，因为单元测试及其代码已过期。</entry>
    <entry key="ModelSSNotRLS">Subsystem Reference block ''{0}'' cannot generate code that can be reused across models. As a result, it cannot reuse unit test code. </entry>
    <entry key="ErrorDuringUnitTestSetup">设置单元测试期间遇到错误</entry>
    <entry key="SSMustBeAtomicForChecksumGeneration">Subsystem blocks ''{0}'' and ''{1}'' must be atomic to compute signature. </entry>
    <entry key="SSMustBeActiveForChecksumGeneration">Subsystem 模块 ''{0}'' 必须处于活动状态才能计算签名。 </entry>
    <entry key="InputMustBeSubsystemBlock">输入必须为 Subsystem 模块。</entry>
    <entry key="InputMustBeAtomicSS">Input must be an atomic Subsystem block.</entry>
    <entry key="InputMustBeSSRefBlock">输入必须为 Subsystem Reference 模块。</entry>
    <entry key="NoSubsystemCodeGenerated">没有为子系统 ''{0}'' 生成新代码。</entry>
    <entry key="InputMustBeNonVirtualSS">Subsystem 模块 ''{0}'' 必须为非虚拟模块才能计算签名。&lt;actions&gt; &lt;action id="help" type="suggestion"&gt; &lt;cmd&gt;helpview('Simulink', 'VirtualBlocks');&lt;/cmd&gt; &lt;msg id="MATLAB:MException:MoreInformation"&gt;&lt;/msg&gt; &lt;/action&gt; &lt;/actions&gt;
        
    </entry>
    <entry key="MismatchedSubDomainType">Subsystem Reference block ''{0}'' expects a subsystem in ''{1}'' sub-domain, but ''{2}'' is in ''{3}'' sub-domain.</entry>
    <entry key="MSVCBuild">单元测试 ''{0}'' 将模板联编文件指定为 'RTW.MSVCBuild'。单元测试代码生成当前不支持此设置。</entry>
    <entry key="SaveFileForSignatureGen">无法为 ''{0}'' 生成签名，因为父级 Subsystem Reference 模块 ''{1}'' 引用了已修改的子系统文件 ''{2}''。请保存 ''{2}'' 并生成签名。</entry>
    <entry key="CannotCrossSSRefBoundaryByParamRWBlock">在加速模式下，无法跨 Subsystem Reference 模块 ''{1}'' 的边界访问 ''{0}'' 的模块参数。</entry>
    <entry key="CannotCrossSSRefBoundaryByStateRWBlock">Cannot access block state of ''{0}'' across the boundary of Subsystem Reference block ''{1}'' in accelerator mode.</entry>
    <entry key="UnsupportedExecutionDomainInAccelMode">'SetExecutionDomain' 模块参数必须设置为 'off' 才能在加速模式下仿真 Subsystem Reference 模块 ''{0}''。</entry>
    <entry key="NoUnitTestSelectedForSSRef">Subsystem ''{0}'' must have at least one unit test for simulating Subsystem Reference block ''{1}'' in accelerator mode.</entry>
    <entry key="UnsupportedSSRefWithGlobalDSM">无法为测试框架 ''{0}'' 生成加速模式工件。在加速模式下仿真 Subsystem Reference 模块时，不支持全局数据存储内存。</entry>
    <entry key="UnsupportedSSRefInAccelModeWithGlobalDSMBLock">Subsystem Reference 模块 ''{0}'' 包含全局数据存储内存。在加速模式下仿真 Subsystem Reference 模块 ''{0}'' 时，不支持此配置。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;Simulink.SubsystemReference.internal.SSRefFixits.fixSimulationModeSetToNormal(''{0}'');&lt;/cmd&gt; &lt;txt&gt;将 '仿真模式' 参数设置为 '普通'&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
        
      </entry>
    <entry key="SimulationModeSetToNormalActionPerformed">'仿真模式' 设置为 '普通'。</entry>
    <entry key="UnsupportedSSRefCUTInAccelMode">在加速模式下无法仿真测试框架中的在测组件 ''{0}''。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;Simulink.SubsystemReference.internal.SSRefFixits.fixSimulationModeSetToNormal(''{0}'');&lt;/cmd&gt; &lt;txt&gt;将 '仿真模式' 参数设置为 '普通'&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
        
      </entry>
    <entry key="MEXFileNotFound">无法在加速模式下仿真 Subsystem Reference 模块 ''{0}''，因为路径中不存在 MEX 文件 ''{1}''。</entry>
    <entry key="FailedToGeneratedAccelModeArtifactsNoReusableCode">无法为测试框架 ''{0}'' 生成加速模式工件，因为没有生成可重用的代码。</entry>
    <entry key="FailedToGeneratedAccelModeArtifactsForNoUnitTest">Subsystem file ''{0}'' must have at least one unit test to generate accelerator mode artifacts.</entry>
    <entry key="UnsupportedBusElementPorts">无法为子系统文件 ''{0}'' 生成加速模式工件，因为它在其接口处包含 'In Bus Element' 或 'Out Bus Element' 模块。</entry>
    <entry key="UnsupportedMaskParameters">无法为子系统文件 ''{0}'' 生成加速模式工件，因为其系统封装包含封装初始化代码。</entry>
    <entry key="UnsupportedFcnCallSSRef">加速模式仿真不支持函数调用子系统引用。</entry>
    <entry key="UnsupportedTriggeredSSRef">加速模式仿真不支持触发子系统引用。</entry>
    <entry key="NumIOPortMismatch">子系统文件 "{2}" 的根级的 {0} 数目({1,number,integer})与生成代码接口中列出的 {0} 的数目({3,number,integer})不匹配。优化过程可能是不匹配的原因。在子系统的加速模式仿真中，图形接口和生成的代码接口必须匹配。</entry>
    <entry key="CodeInfoInportUnsupportedImplementation">以下输入端口具有加速模式仿真不支持的实现:\n\n{0}\n</entry>
    <entry key="CodeInfoOutportUnsupportedImplementation">以下输出端口具有加速模式仿真不支持的实现:\n\n{0}\n</entry>
    <entry key="UnsupportedZeroCrossing">无法为子系统文件 ''{0}'' 生成加速模式工件，因为其可重用代码包含过零逻辑。</entry>
    <entry key="ReadOnlyDataInterface">无法为子系统文件 ''{0}'' 生成加速模式工件，因为它在生成的代码中包含根端口 ''{1}'' 的只读数据元素。</entry>
    <entry key="UnsupportedVariantBlocks">无法为子系统文件 ''{0}'' 生成加速模式工件，因为它包含变体模块 ''{1}'' 且其变体激活时间设置为 ''{2}''。必须将变体模块的 'VariantActivationTime' 设置为 '更新图' 或 '更新图时分析所有选择项' 才能生成仿真模式工件。</entry>
    <entry key="UnsupportedLoadInitialStateInTopModel">模型 ''{0}'' 配置为从工作区加载初始状态，在加速模式下仿真 Subsystem Reference 模块 ''{1}'' 时不支持这种情况。请将配置参数 'LoadInitialState' 设置为 'off' 或选择普通模式仿真。</entry>
    <entry key="UnsupportedCodeInfoParametersWithExportedClass">无法为子系统文件 ''{0}'' 生成加速模式工件，因为它将参数 ''{1}'' 与导出的存储类一起使用。</entry>
    <entry key="NoMatchingSignatureFoundForAccelSSRef">无法在加速模式下仿真 Subsystem Reference 模块 ''{0}''。模块 ''{0}'' 必须匹配至少一个单元测试签名。</entry>
  </message>
</rsccat>
