<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="zh_CN" product="Simulink" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="DSReadBlockDescription">从指定的数据存储中读取值。使用 '元素选择' 选项卡选择要读取的特定元素。如果不选择任何元素，将读取整个数据存储。</entry>
    <entry key="DSWriteBlockDescription">将值写入指定的数据存储。使用 '元素赋值' 选项卡对特定元素赋值。如果不选择任何元素，将对整个数据存储执行写入操作。</entry>
    <entry key="DSMDynamicIndexingBlockDescription">对于动态索引，使用索引端口标签(例如 idx1、idx2)作为元素选择表达式中的索引变量。</entry>
    <entry key="busSupportForDSMIsUnavailable">Data Store Memory 模块 ''{0}'' 的数据类型是总线类型。Data Store Memory 模块仅当严格总线建模为 ON 时支持总线类型。要启用此诊断，请在 "配置参数" 对话框 -&gt; "诊断" -&gt; "连接" 窗格中将 ''Mux 模块用于创建总线信号'' 选项设置为 ''错误''。</entry>
    <entry key="hiddenGlobalDSMBlockMessage">The above message is related to a hidden Data Store Memory block. This block is inserted to support a global data store corresponding to the Simulink.Signal object ''{0}''.</entry>
    <entry key="hiddenModelDSMBlockMessage">上述消息与隐藏的 Data Store Memory 模块有关。插入此模块是为了支持与模型工作区中的 Simulink.Signal 对象 ''{0}'' 对应的局部数据存储。</entry>
    <entry key="hiddenDSMRefBlockMessage">上述消息与对子模型的数据存储 ''{0}'' 的引用有关。</entry>
    <entry key="dsmLoggingNotSupportedWithBusesInBlocks">Data Store Memory 模块 ''{0}'' 配置为执行数据存储内存记录，且该模块的数据类型为总线类型。仅非总线类型支持数据存储内存记录。要消除此警告，请清除 ''模块参数'' 对话框 ''记录'' 窗格上的 ''记录信号数据'' 选项。</entry>
    <entry key="dsmLoggingNotSupportedWithBusesInObjects">Simulink.Signal 对象 ''{0}'' 配置为执行数据存储内存记录，且此对象的数据类型是总线类型。仅非总线类型支持数据存储内存记录。要消除此警告，请关闭此 Simulink.Signal 对象的 DataLogging。</entry>
    <entry key="dsmLoggingNotSupportedInsideForEachSS">Data Store Memory 模块 ''{0}'' 配置为执行数据存储内存记录。但是，当该模块包含在含有 For Each 模块的子系统中时，不支持数据存储内存记录。要消除此警告，请清除 ''模块参数'' 对话框的 ''记录'' 窗格上的 ''记录信号数据'' 选项。</entry>
    <entry key="dsmLoggingNotSupportedInsideMLSystemBlk">在加速模式和快速加速模式仿真期间，不支持记录 MATLAB System 模块 ''{0}'' 内的数据存储。要记录此数据，请在普通模式下运行仿真。</entry>
    <entry key="dsmLoggingNotSupportedForDynamicArray">在加速和快速加速模式仿真过程中，无法记录 Data Store Memory 模块 ''{0}'' 的变量，因为该数据是无界可变大小信号。</entry>
    <entry key="busDSMCannotBeComplex">The data type of the Data Store Memory block ''{0}'' is a bus type and its complexity is set as ''complex''. Please change the complexity of this block or the associated Simulink.Signal object to ''real''.</entry>
    <entry key="InvDSMSettingWithStringType">Invalid parameter setting in Data Store Memory block ''{0}'' with string data type:</entry>
    <entry key="busDSMCannotHaveVarDims">All signals in the bus object hierarchy must be fixed-sized when bus objects are used in Data Store Memory blocks. The Data Store Memory block ''{0}'' specifies a bus object ''{1}'' for its data type, and this bus object has one or more variable-sized signals in its hierarchy.</entry>
    <entry key="DSMemoryICDimsMismatch">The dimensions of the ''InitialValue'' parameter of the Data Store Memory block ''{0}'' is inconsistent with the value specified for the ''Dimensions'' parameter of this block. To infer dimensions from ''InitialValue'' specify ''-1'' in the ''Dimensions'' parameter.</entry>
    <entry key="DSMemoryBlockNotFound">对于模块 ''{1}''，找不到名为 ''{0}'' 的数据存储内存 &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;slprivate(''createMissingDataStore_cb'', ''missingDataStoreCompileTime'', ''{0}'', ''{1}'')&lt;/cmd&gt; &lt;txt&gt;请创建数据存储。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
     </entry>
    <entry key="DSMemoryBlockNotFoundForDataStoreReference">Unable to find data store ''{0}'' for Data Store Memory block ''{1}'' placed inside the model referenced by Model block ''{2}'' with parameter &lt;sldiag objui="blockdlg" objparam="DataStoreReference"&gt;''Data store reference''&lt;/sldiag&gt; selected.
    &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;add_block(''simulink/Signal Routing/Data Store Memory'', ''{3}'', ''MakeNameUnique'', ''on'', ''DataStoreName'', ''{0}'');&lt;/cmd&gt;
            &lt;txt&gt;Add a Data Store Memory block with &lt;sldiag objui="blockdlg" objparam="DataStoreName"&gt;''Data store name''&lt;/sldiag&gt; ''{0}''.&lt;/txt&gt;
        &lt;/action&gt;
     &lt;/actions&gt;
    </entry>
    <entry key="DSMemoryBlockNotFoundForDataStoreReferenceNonDSM">对于参数 &lt;sldiag objui="blockdlg" objparam="DataStoreReference"&gt;''数据存储引用''&lt;/sldiag&gt; 处于选中状态并位于 Model 模块 ''{2}'' 引用的模型中的类型为 ''{3}'' 的数据存储模块 ''{1}''，无法找到其数据存储 ''{0}''。</entry>
    <entry key="DSMemoryRenamed">
      名为 ''{0}'' 的数据存储内存已在模块 ''{4}'' 的 {2} 中重命名为 ''{1}'' &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;slprivate(''robustVarRefHotlink_cb'', ''renameRef'', ''{6}'', ''{2}'', ''{1}'', ''{0}'', ''{3}'', ''{4}'', ''{5}'')&lt;/cmd&gt; &lt;txt&gt;更新引用以使用 ''{1}''。&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;slprivate(''robustVarRefHotlink_cb'', ''copyEntry'', ''{6}'', ''{2}'', ''{1}'', ''{0}'', ''{5}'')&lt;/cmd&gt; &lt;txt&gt;创建名为 ''{0}'' 的新变量作为 ''{1}'' 的副本。&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;slprivate(''createMissingDataStore_cb'', ''missingDataStoreCompileTime'', ''{0}'', ''{4}'')&lt;/cmd&gt; &lt;txt&gt;创建数据存储。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    
    </entry>
    <entry key="DSMemoryDeleted">
      模块 ''{5}'' 中名为 ''{0}'' 的数据存储内存已从 {4} 中删除&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;slprivate(''robustVarRefHotlink_cb'', ''revertCache'', ''{2}'', ''{1}'', ''{0}'', ''{3}'')&lt;/cmd&gt; &lt;txt&gt;撤消删除。&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;slprivate(''createMissingDataStore_cb'', ''missingDataStoreCompileTime'', ''{0}'', ''{5}'')&lt;/cmd&gt; &lt;txt&gt;创建数据存储。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    
    </entry>
    <entry key="DSMemoryBlockNotFound3">Data store memory with name ''{0}'' was not found</entry>
    <entry key="DupDSMemoryBlockFound0">Duplicate data store blocks of block type ''{1}'' named ''{0}'' found.</entry>
    <entry key="DupDSMemoryBlockFound1">First reference is in ''{0}''</entry>
    <entry key="DupDSMemoryBlockFound2">Second reference is in ''{0}''</entry>
    <entry key="InvDataStoreName">''{0}'' 中指定的数据存储名称是无效标识符。有效的标识符以字母开头，不包含空格或特殊字符，最长为 {1,number,integer} 个字符</entry>
    <entry key="UniqueDataStoreMemory"> Data store memory name ''{0}'' is used for block ''{1}'' and block ''{2}''.
    &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;set_param_action(''{3}'', 'UniqueDataStoreMsg', 'none');&lt;/cmd&gt;
            &lt;txt&gt;Consider setting the configuration parameter &lt;sldiag objui="configset" objparam="UniqueDataStoreMsg" objname="{0}"&gt;''Duplicate data store names''&lt;/sldiag&gt; to ''none''.&lt;/txt&gt;
        &lt;/action&gt;
        &lt;action type="suggestion"&gt;
            &lt;txt&gt;Alternatively, make &lt;sldiag objui="blockdlg" objparam="DataStoreName"&gt;''Data store name''&lt;/sldiag&gt; parameters of these two blocks different.&lt;/txt&gt;
        &lt;/action&gt;
     &lt;/actions&gt;
</entry>
    <entry key="DSReadDiagnosticsNotReported">模块 ''{0}'' 正在从数据存储 ''{1}'' 中读取总线元素。不会报告数据存储读取/写入诊断，因为此模块位于以加速模式执行的模型中，或位于仿真模式设置为加速的引用模型中。要关闭此警告，请使用: warning(''off'',''Simulink:DataStores:DSReadDiagnosticsNotReported'')</entry>
    <entry key="DSWriteDiagnosticsNotReported">模块 ''{0}'' 正在将总线元素写入数据存储 ''{1}''。不会报告数据存储读取/写入诊断，因为此模块位于以加速模式执行的模型中，或位于仿真模式设置为加速的引用模型中。要关闭此警告，请使用: warning(''off'',''Simulink:DataStores:DSWriteDiagnosticsNotReported'')</entry>
    <entry key="DSDiagnosticsNotReported">模块 ''{0}'' 正在访问由模块 ''{1}'' 定义的数据存储。不会报告数据存储读取/写入诊断，因为数据存储具有 2 个或更多维度，且此模块位于以加速模式执行的模型中，或位于仿真模式设置为加速的引用模型中。要关闭此警告，请使用: warning(''off'',''Simulink:DataStores:DSDiagnosticsNotReported'')</entry>
    <entry key="DSReadBeforeWrite">在时间 {2}，模块 ''{0}'' 正在从数据存储 ''{1}'' 中读取数据，而此时还没有任何模块向此内存区域写入数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSReadBeforeWriteInMinor">在时间 {2}，模块 ''{0}'' 正在从数据存储 ''{1}'' 中读取数据，而此时还没有任何模块向此内存区域写入数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSReadBeforeWriteInMWE">在事件 ''{3}'' 期间的时间 {2}，模块 ''{0}'' 正在从数据存储 ''{1}'' 中读取数据，而此时还没有任何模块向此内存区域写入数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSReadBeforeWriteOfElement">在时间 {3}，模块 ''{0}'' 正在从数据存储 ''{2}'' 的元素 {1,number,integer} 中读取数据，而此时还没有任何模块向此内存写入数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSReadBeforeWriteOfElementInMinor">在时间 {3}，模块 ''{0}'' 正在从数据存储 ''{2}'' 的元素 {1,number,integer} 中读取数据，而此时还没有任何模块向此内存写入数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSReadBeforeWriteOfElementInMWE">在事件 ''{4}'' 期间的时间 {3}，模块 ''{0}'' 正在从数据存储 ''{2}'' 的元素 {1,number,integer} 中读取数据，而此时还没有任何模块向此内存写入数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSReadBeforeWriteOfRegionExpr">在时间 {3}，模块 ''{0}'' 正在从数据存储内存 ''{2}'' 的区域 ''{1}'' 中读取数据，而此时其他模块尚未完成对此区域的写入。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSReadBeforeWriteOfRegionExprInMinor">在时间 {3}，模块 ''{0}'' 正在从数据存储内存 ''{2}'' 的区域 ''{1}'' 中读取数据，而此时其他模块尚未完成对此区域的写入。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSReadBeforeWriteOfRegionExprInMWE">在事件 ''{4}'' 期间的时间 {3}，模块 ''{0}'' 正在从数据存储内存 ''{2}'' 的区域 ''{1}'' 中读取数据，而此时其他模块尚未完成对此区域的写入。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSWriteAfterRead">在时间 {3}，模块 ''{0}'' 正在向数据存储 ''{1}'' 写入数据，而此时模块 ''{2}'' 已从此内存的部分区域或整个区域读取了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSWriteAfterReadInMinor">在时间 {3}，模块 ''{0}'' 正在向数据存储 ''{1}'' 写入数据，而此时模块 ''{2}'' 已从此内存的部分区域或整个区域读取了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSWriteAfterReadInMWE">在事件 ''{4}'' 期间的时间 {3}，模块 ''{0}'' 正在向数据存储 ''{1}'' 写入数据，但此时模块 ''{2}'' 已从此内存的部分区域或整个区域读取了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSWriteAfterReadOfElement">在时间 {4}，模块 ''{0}'' 正在向数据存储 ''{2}'' 的元素 {1,number,integer} 写入数据，但此时模块 ''{3}'' 已从此内存中读取了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSWriteAfterReadOfElementInMinor">在时间 {4}，模块 ''{0}'' 正在向数据存储 ''{2}'' 的元素 {1,number,integer} 写入数据，但此时模块 ''{3}'' 已从此内存中读取了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSWriteAfterReadOfElementInMWE">在事件 ''{5}'' 期间的时间 {4}，模块 ''{0}'' 正在向数据存储 ''{2}'' 的元素 {1,number,integer} 写入数据，但此时模块 ''{3}'' 已从此内存中读取了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSWriteAfterReadOfRegionExpr">在时间 {4}，模块 ''{0}'' 正在向数据存储内存 ''{2}'' 的区域 ''{1}'' 写入数据，但此时其数据已被模块 ''{3}'' 部分读取或全部读取。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSWriteAfterReadOfRegionExprInMinor">在时间 {4}，模块 ''{0}'' 正在向数据存储内存 ''{2}'' 的区域 ''{1}'' 写入数据，但此时其数据已被模块 ''{3}'' 部分读取或全部读取。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSWriteAfterReadOfRegionExprInMWE">在事件 ''{5}'' 期间的时间 {4}，模块 ''{0}'' 正在向数据存储内存 ''{2}'' 的区域 ''{1}'' 写入数据，但此时其数据已被模块 ''{3}'' 部分读取或全部读取。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSWriteAfterWrite">在时间 {3}，模块 ''{0}'' 正在向数据存储 ''{1}'' 写入数据，但此时模块 ''{2}'' 已向此内存的部分区域或整个区域写入了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSWriteAfterWriteInMinor">在时间 {3}，模块 ''{0}'' 正在向数据存储 ''{1}'' 写入数据，但此时模块 ''{2}'' 已向此内存的部分区域或整个区域写入了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSWriteAfterWriteInMWE">在事件 ''{4}'' 期间的时间 {3}，模块 ''{0}'' 正在向数据存储 ''{1}'' 写入数据，但此时模块 ''{2}'' 已向此内存的部分区域或整个区域写入了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSWriteAfterWriteOfElement">在时间 {4}，模块 ''{0}'' 正在向数据存储 ''{2}'' 的元素 {1,number,integer} 写入数据，但此时模块 ''{3}'' 已向此内存写入了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSWriteAfterWriteOfElementInMinor">在时间 {4}，模块 ''{0}'' 正在向数据存储 ''{2}'' 的元素 {1,number,integer} 写入数据，但此时模块 ''{3}'' 已向此内存写入了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSWriteAfterWriteOfElementInMWE">在事件 ''{5}'' 期间的时间 {4}，模块 ''{0}'' 还正在向数据存储 ''{2}'' 的元素 {1,number,integer} 写入数据，但此时模块 ''{3}'' 已向此内存写入了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSWriteAfterWriteOfRegionExpr">在时间 {4}，模块 ''{0}'' 正在向数据存储内存 ''{2}'' 的区域 ''{1}'' 写入数据，但此时模块 ''{3}'' 已向此内存的部分区域或整个区域写入了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSWriteAfterWriteOfRegionExprInMinor">在时间 {4}，模块 ''{0}'' 正在向数据存储内存 ''{2}'' 的区域 ''{1}'' 写入数据，但此时模块 ''{3}'' 已向此内存的部分区域或整个区域写入了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="DSWriteAfterWriteOfRegionExprInMWE">在事件 ''{5}'' 期间的时间 {4}，模块 ''{0}'' 正在向数据存储内存 ''{2}'' 的区域 ''{1}'' 写入数据，但此时模块 ''{3}'' 已向此内存的部分区域或全部区域写入了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSReadBeforeWrite">在时间 {2}，模块 ''{0}'' 正在从与 Simulink.Signal 对象 ''{1}'' 对应的数据存储中读取数据，而此时还没有任何模块向此内存区域写入数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSReadBeforeWriteInMinor">在时间 {2}，模块 ''{0}'' 正在从与 Simulink.Signal 对象 ''{1}'' 对应的数据存储中读取数据，而此时还没有任何模块向此内存区域写入数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSReadBeforeWriteInMWE">在事件 ''{3}'' 期间的时间 {2}，模块 ''{0}'' 正在从与 Simulink.Signal 对象 ''{1}'' 对应的数据存储中读取数据，而此时还没有任何模块向此内存区域写入数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSReadBeforeWriteOfElement">在时间 {3}，模块 ''{0}'' 正在从与 Simulink.Signal 对象 ''{2}'' 对应的数据存储的元素 {1,number,integer} 中读取数据，而此时还没有任何模块向此内存写入数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSReadBeforeWriteOfElementInMinor">在时间 {3}，模块 ''{0}'' 正在从与 Simulink.Signal 对象 ''{2}'' 对应的数据存储的元素 {1,number,integer} 中读取数据，而此时还没有任何模块向此内存写入数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSReadBeforeWriteOfElementInMWE">在事件 ''{4}'' 期间的时间 {3}，模块 ''{0}'' 正在从与 Simulink.Signal 对象 ''{2}'' 对应的数据存储的元素 {1,number,integer} 中读取数据，而此时还没有任何模块向此内存写入数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSReadBeforeWriteOfRegionExpr">在时间 {3}，模块 ''{0}'' 正在从与 Simulink.Signal 对象 ''{2}'' 对应的数据存储内存的区域 ''{1}'' 中读取数据，而此时其他模块尚未完成对此区域的写入。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSReadBeforeWriteOfRegionExprInMinor">在时间 {3}，模块 ''{0}'' 正在从与 Simulink.Signal 对象 ''{2}'' 对应的数据存储内存的区域 ''{1}'' 中读取数据，而此时其他模块尚未完成对此区域的写入。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSReadBeforeWriteOfRegionExprInMWE">在事件 ''{4}'' 期间的时间 {3}，模块 ''{0}'' 正在读取与 Simulink.Signal 对象 ''{2}'' 对应的数据存储内存的区域 ''{1}'' 中的数据，而此时其他模块尚未完成对此区域的写入。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSWriteAfterRead">在时间 {3}，模块 ''{0}'' 正在向与 Simulink.Signal 对象 ''{1}'' 对应的数据存储写入数据，但此时模块 ''{2}'' 已从此内存的部分区域或整个区域读取了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSWriteAfterReadInMinor">在时间 {3}，模块 ''{0}'' 正在向与 Simulink.Signal 对象 ''{1}'' 对应的数据存储写入数据，但此时模块 ''{2}'' 已从此内存的部分区域或整个区域读取了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSWriteAfterReadInMWE">在事件 ''{4}'' 期间的时间 {3}，模块 ''{0}'' 正在向与 Simulink.Signal 对象 ''{1}'' 对应的数据存储写入数据，但此时模块 ''{2}'' 已从此内存的部分区域或整个区域读取了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSWriteAfterReadOfElement">在时间 {4}，模块 ''{0}'' 正在向与 Simulink.Signal 对象 ''{2}'' 对应的数据存储的元素 {1,number,integer} 写入数据，但此时模块 ''{3}'' 已从此内存中读取了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSWriteAfterReadOfElementInMinor">在时间 {4}，模块 ''{0}'' 正在向与 Simulink.Signal 对象 ''{2}'' 对应的数据存储的元素 {1,number,integer} 写入数据，但此时模块 ''{3}'' 已从此内存中读取了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSWriteAfterReadOfElementInMWE">在事件 ''{5}'' 期间的时间 {4}，模块 ''{0}'' 正在向与 Simulink.Signal 对象 ''{2}'' 对应的数据存储的元素 {1,number,integer} 写入数据，但此时模块 ''{3}'' 已从此内存中读取了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSWriteAfterReadOfRegionExpr">在时间 {4}，模块 ''{0}'' 正在向与 Simulink.Signal 对象 ''{2}'' 对应的数据存储内存的区域 ''{1}'' 写入数据，但此时其数据已被模块 ''{3}'' 部分读取或全部读取。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSWriteAfterReadOfRegionExprInMinor">在时间 {4}，模块 ''{0}'' 正在向与 Simulink.Signal 对象 ''{2}'' 对应的数据存储内存的区域 ''{1}'' 写入数据，但此时其数据已被模块 ''{3}'' 部分读取或全部读取。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSWriteAfterReadOfRegionExprInMWE">在事件 ''{5}'' 期间的时间 {4}，模块 ''{0}'' 正在向与 Simulink.Signal 对象 ''{2}'' 对应的数据存储内存的区域 ''{1}'' 写入数据，但此时其数据已被模块 ''{3}'' 部分读取或全部读取。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSWriteAfterWrite">在时间 {3}，模块 ''{0}'' 正在向与 Simulink.Signal 对象 ''{1}'' 对应的数据存储写入数据，但此时模块 ''{2}'' 已向此内存的部分区域或整个区域写入了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSWriteAfterWriteInMinor">在时间 {3}，模块 ''{0}'' 正在向与 Simulink.Signal 对象 ''{1}'' 对应的数据存储写入数据，但此时模块 ''{2}'' 已向此内存的部分区域或整个区域写入了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSWriteAfterWriteInMWE">在事件 ''{4}'' 期间的时间 {3}，模块 ''{0}'' 正在向与 Simulink.Signal 对象 ''{1}'' 对应的数据存储写入数据，但此时模块 ''{2}'' 已向此内存的的部分区域或整个区域写入了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSWriteAfterWriteOfElement">在时间 {4}，模块 ''{0}'' 正在向与 Simulink.Signal 对象 ''{2}'' 对应的数据存储的元素 {1,number,integer} 写入数据，但此时模块 ''{3}'' 已向此内存写入了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSWriteAfterWriteOfElementInMinor">在时间 {4}，模块 ''{0}'' 正在向与 Simulink.Signal 对象 ''{2}'' 对应的数据存储的元素 {1,number,integer} 写入数据，但此时模块 ''{3}'' 已向此内存写入了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSWriteAfterWriteOfElementInMWE">在事件 ''{5}'' 期间的时间 {4}，模块 ''{0}'' 正在向与 Simulink.Signal 对象 ''{2}'' 对应的数据存储的元素 {1,number,integer} 写入数据，但此时模块 ''{3}'' 已向此内存写入了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSWriteAfterWriteOfRegionExpr">在时间 {4}，模块 ''{0}'' 正在向与 Simulink.Signal 对象 ''{2}'' 对应的数据存储内存的区域 ''{1}'' 写入数据，但此时模块 ''{3}'' 已向此内存的部分区域或整个区域写入了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSWriteAfterWriteOfRegionExprInMinor">在时间 {4}，模块 ''{0}'' 正在向与 Simulink.Signal 对象 ''{2}'' 对应的数据存储内存的区域 ''{1}'' 写入数据，但此时模块 ''{3}'' 已向此内存的部分区域或整个区域写入了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="GlobalDSWriteAfterWriteOfRegionExprInMWE">在事件 ''{5}'' 期间的时间 {4}，模块 ''{0}'' 正在向与 Simulink.Signal 对象 ''{2}'' 对应的数据存储内存的区域 ''{1}'' 写入数据，但此时模块 ''{3}'' 已向此内存的部分区域或整个区域写入了数据。出于性能原因，在其他仿真时间步中，不再对此内存执行此诊断。</entry>
    <entry key="RegionValidationDimsMismatch">The number of dimensions is specified as ''{0,number,integer}'' for the region of memory ''{1}'' associated with the block ''{2}''. This does not match the actual number of dimensions ''{3,number,integer}'' associated with this memory</entry>
    <entry key="RegionValidationInvalidBusElementIdx">The index of the bus element is specified as ''{0,number,integer}''. This value is not valid for the region of memory ''{1}'' associated with the block ''{2}''</entry>
    <entry key="RegionValidationIndexSpecifiedWhenSelectingAll">当使用选项 MEM_REGION_SELECT_ALL 时，不应指定任何索引。但与模块 ''{1}'' 关联的内存区域 ''{0}'' 却指定了索引</entry>
    <entry key="RegionValidationDiscontiguousAtNonLeaf">Accessing dis-contiguous memory regions is supported only at non-bus nodes. This was specified for the region of memory ''{0}'' associated with the block ''{1}''</entry>
    <entry key="RegionValidationInvalidStartIncrEnd">Invalid indices specified for the indexing option MEM_REGION_STARTIDX_INCR_ENDIDX. This was specified for the region of memory ''{0}'' associated with the block ''{1}''</entry>
    <entry key="RegionValidationIndexOutOfBounds">The indices specified for the region of memory ''{0}'' associated with the block ''{1}'' is out of bounds</entry>
    <entry key="RegionValidationInvalidIndexingMode">为与模块 ''{1}'' 关联的内存区域 ''{0}'' 指定的索引模式无效</entry>
    <entry key="ExpressionValidationMissingField">在 ''{5}'' 选项卡中为表达式 ''{1}'' 指定并与模块 ''{3}'' 的端口 {2} 相关联的字段 ''{0}'' 在相关联的总线对象 ''{4}'' 中没有对应的同名总线元素。请将表达式中的字段名称修改为匹配的总线元素名称，或通过添加具有此名称的新总线元素来更新总线对象。</entry>
    <entry key="ExpressionValidationFieldSpecifiedForNonBus">在 ''{4}'' 选项卡中为表达式 ''{1}'' 指定并与模块 ''{3}'' 的端口 {2} 相关联的字段 ''{0}'' 在相关联的数据存储内存的数据类型中没有匹配的总线元素。请从表达式中删除该字段，或将关联数据存储内存的数据类型更新为包含具有此字段名称的总线元素的总线对象。</entry>
    <entry key="ExpressionValidationParseError">在 ''{4}'' 选项卡中指定的与模块 ''{2}'' 的端口 {1} 相关联的表达式 ''{0}'' 使用了无效的 MATLAB 语法: ''{3}''</entry>
    <entry key="ExpressionValidationUnsupportedOps">在 ''{3}'' 选项卡中指定的与模块 ''{2}'' 的端口 {1} 相关联的表达式 ''{0}'' 使用了此模块不支持的运算符、变量或函数。有关详细信息，请参阅此模块的文档。</entry>
    <entry key="ExpressionValidationInvalidRootName">在 ''{4}'' 选项卡中指定并与模块 ''{2}'' 的端口 {1} 相关联的表达式 ''{0}'' 未以相关联的数据存储内存名称 ''{3}'' 开头，或未引用该名称。</entry>
    <entry key="ExpressionValidationDisContiguous">The expression ''{0}'' specified in the ''{4}'' tab and associated with port {1} of block ''{2}'' is associated with non-contiguous elements. Non-contiguous element access is only supported at terminal nodes. ''{3}'' in the given expression is not a terminal node.</entry>
    <entry key="ExpressionValidationDimsMismatch">The expression ''{0}'' specified in the ''{5}'' tab and associated with port {1} of block ''{2}'' specifies an invalid number of dimensions at node ''{3}''. The expected number of dimensions for this node is {4}.</entry>
    <entry key="ExpressionValidationDimsMismatchWithDetail">在 ''{5}'' 选项卡中指定并与模块 ''{2}'' 的端口 {1} 相关联的表达式 ''{0}'' 在节点 ''{3}'' {6} 处指定了无效的维数。此节点的维数应为 {4}。</entry>
    <entry key="ExpressionValidationIndexOutOfBounds">The expression ''{0}'' specified in the ''{5}'' tab and associated with port {1} of block ''{2}'' specifies one or more indices that are out of bounds at node ''{3}''. Indices are one-based and must be greater than zero in each dimension. The maximum allowed values for indices (in each dimension) at this node is ''{4}''.</entry>
    <entry key="ExpressionValidationIndexRepeats">The expression ''{0}'' specified in the ''{4}'' tab and associated with port {1} of block ''{2}'' specifies one or more indices that repeat at node ''{3}''. Indices must be unique in each dimension.</entry>
    <entry key="IndexLabelsNotMatching">''{1}'' 选项卡中与模块 ''{2}'' 相关联的表达式 ''{0}'' 包含一个或多个与索引端口标签不匹配的索引变量。</entry>
    <entry key="ElementsNotSupportedForDynamicArrays">无法针对元素选择配置模块 ''{0}''，因为数据存储内存与无界可变大小信号或包含无界可变大小元素的总线相关联。</entry>
    <entry key="ScopedDSMSignalAttribMismatch1">模块类型为 ''{3}'' 的数据存储模块 ''{0}'' 和 ''{1}'' 必须指定相同的信号属性，因为它们指定了相同的数据存储名称 ''{2}''，并且 ''{1}'' 的 &lt;sldiag objui="blockdlg" objparam="DataStoreReference"&gt;'引用'&lt;/sldiag&gt; 参数处于选中状态。</entry>
    <entry key="ScopedDSMSignalAttribMismatch2">模块类型为 ''{3}'' 的数据存储模块 ''{0}'' 和 ''{1}'' 必须指定相同的信号属性，因为这两个模块指定了相同的数据存储名称 ''{2}''，并且它们的 &lt;sldiag objui="blockdlg" objparam="DataStoreReference"&gt;'引用'&lt;/sldiag&gt; 参数都处于选中状态。</entry>
    <entry key="ScopedDSMSignalAttribMismatch3">模型 ''{2}'' 的模型工作区中的 Simulink.Signal 对象 ''{0}'' 和模块类型为 ''{2}'' 的数据存储模块 ''{1}'' 必须指定相同的信号属性，因为它们使用了相同的数据存储名称，并且 ''{1}'' 的 &lt;sldiag objui="blockdlg" objparam="DataStoreReference"&gt;'引用'&lt;/sldiag&gt; 参数处于选中状态。</entry>
    <entry key="ScopedDSMBusSignalPropNotSupported">Unable to set &lt;sldiag objui="blockdlg" objparam="OutDataTypeStr"&gt;''Data type''&lt;/sldiag&gt; of Data Store Memory block ''{0}'' with data store name ''{1}'' to ''Inherit: auto'' when the corresponding data store reference ''{2}'' inside the model referenced by Model block ''{3}'' specifies a bus data type ''{4}''.
    &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="fixit" retvalue="false"&gt;
            &lt;cmd&gt;set_param(''{0}'', 'OutDataTypeStr', ''{4}'');&lt;/cmd&gt;
            &lt;txt&gt;Set &lt;sldiag objui="blockdlg" objparam="OutDataTypeStr"&gt;''Data type''&lt;/sldiag&gt; of ''{0}'' to ''{4}''.&lt;/txt&gt;
        &lt;/action&gt;
    &lt;/actions&gt;
    </entry>
    <entry key="ScopedDSMImageTypePropNotSupported">当 Model 模块 ''{3}'' 引用的模型内的对应数据存储引用 ''{2}'' 指定图像类型 ''{4}'' 时，无法将数据存储名称为 ''{1}'' 的 Data Store Memory 模块 ''{0}'' 的 &lt;sldiag objui="blockdlg" objparam="OutDataTypeStr"&gt;''数据类型''&lt;/sldiag&gt; 设置为 ''继承: 自动''。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" retvalue="false"&gt; &lt;cmd&gt;set_param(''{0}'', 'OutDataTypeStr', ''{4}'');&lt;/cmd&gt; &lt;txt&gt;将 ''{0}'' 的 &lt;sldiag objui="blockdlg" objparam="OutDataTypeStr"&gt;''数据类型''&lt;/sldiag&gt; 设置为 ''{4}''。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="ScopedDSMDataTypeMismatch">''{0}'' 和 ''{1}'' 分别将其各自的数据类型设置为 ''{2}'' 和 ''{3}''。</entry>
    <entry key="ScopedDSMComplexityMismatch">''{0}'' 和 ''{1}'' 分别将 &lt;sldiag objui="blockdlg" objparam="SignalType"&gt;'信号类型'&lt;/sldiag&gt; 设置为 ''{2}'' 和 ''{3}''。</entry>
    <entry key="ScopedDSMOneDVectorMismatch">''{0}'' 和 ''{1}'' 分别将 &lt;sldiag objui="blockdlg" objparam="VectorParams1D"&gt;'将向量参数解释为一维向量'&lt;/sldiag&gt; 设置为 ''{2}'' 和 ''{3}''。</entry>
    <entry key="ScopedDSMDimensionMismatch">''{0}'' 和 ''{1}'' 分别将 &lt;sldiag objui="blockdlg" objparam="Dimensions"&gt;'维度'&lt;/sldiag&gt; 设置为 ''{2}'' 和 ''{3}''。</entry>
    <entry key="DupDataStoreReferences1">当 Data Store Memory 模块 ''{0}'' 配置为数据存储引用时，不允许将此模型中的任何其他 Data Store Memory 模块配置为具有相同数据存储名称 ''{2}'' 的数据存储引用。但是，''{1}'' 违反了此规则。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" retvalue="false"&gt; &lt;cmd&gt;add_block(''{0}'', ''{3}'', ''MakeNameUnique'', ''on''); delete_block(''{0}''); delete_block(''{1}'');&lt;/cmd&gt; &lt;txt&gt;在更高级别的图中定义数据存储引用 ''{2}''，并删除 ''{0}'' 和 ''{1}''。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="DupDataStoreReferences2">当 Data Store Memory 模块 ''{0}'' 配置为数据存储引用时，不允许将此模型中的任何其他 Data Store Memory 模块配置为具有相同数据存储名称 ''{2}'' 的数据存储引用。但是，''{1}'' 违反了此规则。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" retvalue="false"&gt; &lt;cmd&gt;delete_block(''{1}'');&lt;/cmd&gt; &lt;txt&gt;删除 ''{1}''。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="DupDataStoreReferences3">当 Data Store Memory 模块 ''{0}'' 配置为数据存储引用时，不允许将此模型中的任何其他 Data Store Memory 模块配置为具有相同数据存储名称 ''{2}'' 的数据存储引用。但是，Model 模块 ''{1}'' 在其引用模型层次结构中包含同名的数据存储引用，需要定义数据存储引用的模块违反了此规则。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" retvalue="false"&gt; &lt;cmd&gt;add_block(''{0}'', ''{3}'', ''MakeNameUnique'', ''on''); delete_block(''{0}'');&lt;/cmd&gt; &lt;txt&gt;将 ''{0}'' 移至更高级别的图。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="ScopedDSMNameShadowing">当类型为 ''{3}'' 的数据存储模块 ''{0}'' 配置为数据存储引用时，不支持类型为 ''{3}'' 的任何其他数据存储模块在其更高级别子系统中指定相同的数据存储名称 ''{2}''。''{1}'' 违反此规则。</entry>
    <entry key="ScopedDSMNameShadowing_HiddenLocalDSM">当 Data Store Memory 模块 ''{1}'' 配置为数据存储引用时，不支持任何其他 Data Store Memory 模块在其更高级别的子系统中指定相同的数据存储名称 ''{0}''。然而，由于模型 ''{2}'' 在模块 ''{3}'' 所访问的模型工作区中具有一个与数据存储同名 ''{0}'' 的 Simulink.Signal 对象，这将导致 Data Store Memory 模块被隐式放置于此模型的根图中，从而违反了此规则。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" retvalue="false"&gt; &lt;cmd&gt;h=add_block(''{6}'', ''{5}'', ''MakeNameUnique'', ''on''); set_param(h,''DataStoreName'', ''{0}'');&lt;/cmd&gt; &lt;txt&gt;在 ''{4}'' 中显式添加 Data Store Memory 模块。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="DSMRefStdStringUnsupported">数据存储引用 ''{0}'' 实现为 std::string，这不受支持。</entry>
    <entry key="DataStoreRefShadowedByGlobalDSM">Data Store Memory 模块 ''{0}'' 位于子系统内且选择了参数 &lt;sldiag objui="blockdlg" objparam="DataStoreReference"&gt;''数据存储引用''&lt;/sldiag&gt;，在这种情况下，不允许模型的子系统层次结构中更高层级上有另一个具有相同 ''数据存储名称'' 的 Data Store Memory 模块。但是，充当全局数据存储的 Simulink.Signal 对象 ''{1}'' 违反了此规则。</entry>
    <entry key="DataStoreRefFromChildMdlShadowedByGlobalDSM">Data Store Memory 模块 ''{0}'' 位于 Model 模块 ''{2}'' 所引用的模型内且选择了参数 &lt;sldiag objui="blockdlg" objparam="DataStoreReference"&gt;''数据存储引用''&lt;/sldiag&gt;，在这种情况下，不允许在模型层次结构中更高层级的子系统内有另一个具有相同 ''数据存储名称'' 的 Data Store Memory 模块。但是，充当全局数据存储的 Simulink.Signal 对象 ''{1}'' 违反了此规则。</entry>
    <entry key="InvalidSharedDSMDefMemForDataStoreRef">在为选择了 &lt;sldiag objui="blockdlg" objparam="DataStoreReference"&gt;'数据存储引用'&lt;/sldiag&gt; 参数的 Data Store Memory 模块 ''{0}'' 定义数据存储时，不支持选择了 &lt;sldiag objui="blockdlg" objparam="ShareAcrossModelInstances"&gt;'跨模型实例共享'&lt;/sldiag&gt; 的 Data Store Memory 模块 ''{1}''。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param_action(''{1}'', ''ShareAcrossModelInstances'', ''off'');&lt;/cmd&gt; &lt;txt&gt;清除 &lt;sldiag objui="blockdlg" objparam="ShareAcrossModelInstances"&gt;'跨模型实例共享'&lt;/sldiag&gt;。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="DataTypeNotSpecifiedForDataStoreRef">在选择了参数 &lt;sldiag objui="blockdlg" objparam="DataStoreReference"&gt;''数据存储引用''&lt;/sldiag&gt; 的模块 ''{0}'' 中，参数 &lt;sldiag objui="blockdlg" objparam="OutDataTypeStr"&gt;''数据类型''&lt;/sldiag&gt; 设置为 ''继承: 自动'' 无效。请从下拉选项中显式选择 &lt;sldiag objui="blockdlg" objparam="OutDataTypeStr"&gt;''数据类型''&lt;/sldiag&gt;。</entry>
    <entry key="DimensionNotSpecifiedForDataStoreRef">在选择了参数 &lt;sldiag objui="blockdlg" objparam="DataStoreReference"&gt;''数据存储引用''&lt;/sldiag&gt; 的模块 ''{0}'' 中，参数 &lt;sldiag objui="blockdlg" objparam="Dimensions"&gt;''维度''&lt;/sldiag&gt; 设置为 ''-1'' 无效。请显式指定 &lt;sldiag objui="blockdlg" objparam="Dimensions"&gt;''维度''&lt;/sldiag&gt;。</entry>
    <entry key="ComplexityNotSpecifiedForDataStoreRef">在选择了参数 &lt;sldiag objui="blockdlg" objparam="DataStoreReference"&gt;''数据存储引用''&lt;/sldiag&gt; 的模块 ''{0}'' 中，参数 &lt;sldiag objui="blockdlg" objparam="SignalType"&gt;''信号类型''&lt;/sldiag&gt; 设置为 ''自动'' 无效。请从下拉选项中显式选择 &lt;sldiag objui="blockdlg" objparam="SignalType"&gt;''信号类型''&lt;/sldiag&gt;。</entry>
    <entry key="UnableToRenameDataStoreRefInProtectedMdl">Data Store Memory 模块位于 Model 模块 ''{2}'' 所引用的模型内且选择了 &lt;sldiag objui="blockdlg" objparam="DataStoreReference"&gt;''数据存储引用''&lt;/sldiag&gt; 参数，在这种情况下，无法将该模块的 &lt;sldiag objui="blockdlg" objparam="DataStoreName"&gt;''数据存储名称''&lt;/sldiag&gt; 参数从 ''{0}'' 更改为 ''{1}''，因为引用模型 ''{3}'' 是作为受保护模型保存的。</entry>
    <entry key="UnableToRenameLibLinkedStateflowDataStoreName">无法将 ''{2}'' 中的数据存储从 ''{0}'' 重命名为 ''{1}''。这是因为 ''{2}'' 是 Stateflow 图或从库中链接的 MATLAB 函数。</entry>
    <entry key="RefdDSMIndMapToNonAddr">无法使用对不可寻址的存储类 ''{1}'' 的引用来设置数据存储内存 ''{0}''</entry>
    <entry key="RefdDSMDefMapToNonAddr">由于内部数据的默认存储类设置为不可寻址的存储类 ''{1}''，无法使用对 ''模型默认'' 的引用来设置数据存储内存 ''{0}''。</entry>
    <entry key="DSMRefIndMapToLegacy">Cannot set the storage class of data store reference ''{0}'' to ''{1}'' because that storage class is a built-in storage class, or a storage class that is defined in a package. The storage class of a data store reference must be configured as Auto or a storage class defined in the Embedded Coder dictionary</entry>
    <entry key="DSMRefDefMapToLegacy">Cannot set the storage class of data store reference ''{0}'' to 'Model default' because the default storage class for internal data, ''{1}'', is a built-in storage class or a storage class that is defined in a package. The storage class of a data store reference must be Auto or a storage class defined in the Embedded Coder dictionary</entry>
    <entry key="RefdDSMIndPreserveND">无法设置引用 ''{1}'' 的数据存储内存 ''{0}'' 的存储类，因为它选择了 ''保留数组维度'' </entry>
    <entry key="RefdDSMDefPreserveND">无法设置引用 ''模型默认'' 的数据存储内存 ''{0}'' 的存储类，因为内部数据的默认存储类设置为选择了 ''保留数组维度'' 的存储类 ''{1}''。</entry>
    <entry key="DSMRefIndPreserveND">无法将数据存储引用 ''{0}'' 的存储类设置为 ''{1}''，因为它选择了 ''保留数组维度''</entry>
    <entry key="DSMRefDefPreserveND">无法将数据存储引用 ''{0}'' 的存储类设置为 '模型默认'，因为内部数据的默认存储类 ''{1}'' 选择了 ''保留数组维度''</entry>
    <entry key="DynamicallySizedDataStoreReference">数据存储引用 ''{0}'' 必须具有有限维度</entry>
    <entry key="DataStoreReferenceRequiresPublic">The data store reference accessed by ''{0}'' requires the ''Data Visibility'' of ''Signals, states, and internal data'' to be set to ''public''</entry>
    <entry key="DSMDataTypeAuto">{1} 使用的数据存储内存 {0} 不支持数据类型 'auto'。请在 "Simulink 数据存储内存" 对话框中指定数据类型。</entry>
    <entry key="DSMSignalTypeAuto">{1} 使用的数据存储内存 ''{0}'' 不支持信号类型 'auto'。请在 "Simulink 数据存储内存" 对话框中指定信号类型。</entry>
    <entry key="ScopedDSMICDimensionMismatch">''{0}'' set the dimensions of &lt;sldiag objui="blockdlg" objparam="InitialValue"&gt;'Initial value'&lt;/sldiag&gt; to ''{2}''. But ''{1}'' set &lt;sldiag objui="blockdlg" objparam="Dimensions"&gt;'Dimensions'&lt;/sldiag&gt; to ''{3}''.</entry>
  </message>
</rsccat>
