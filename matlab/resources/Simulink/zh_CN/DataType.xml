<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="zh_CN" product="Simulink" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="AliasTypeEmissionRequiresECoderLicense">在生成的代码中保留别名数据类型的名称需要 ERT 或 ERT 派生目标。在代码生成期间会还原为内置类型。</entry>
    <entry key="AliasTypesNotSupportedForMultiWordCodeGen">别名数据类型 ''{0}'' 具有多字基类型 ''{1}''。代码生成不支持多字别名；将还原为基类型。</entry>
    <entry key="AliasType_BaseType_Auto">Invalid BaseType specified; BaseType may not be set to ''auto''</entry>
    <entry key="AliasType_BaseType_Bus">BaseType ''{0}'' must not be specified as a bus.</entry>
    <entry key="AliasType_BaseType_ValueType">不能使用 Simulink.ValueType 对象指定 BaseType ''{0}''。</entry>
    <entry key="AliasType_ErrResolvingDataType">Error resolving BaseType ''{0}''</entry>
    <entry key="AliasType_Invalid_BaseType">指定的 BaseType 无效；BaseType 必须为有效的标识符</entry>
    <entry key="AliasType_Invalid_ResolvedDataType">BaseType ''{0}'' did not resolve to a valid data type</entry>
    <entry key="AliasType_Invalid_ResolvedDataType_Bus">BaseType ''{0}'' did not resolve to a valid data type.  Cannot specify BaseType to be a bus object</entry>
    <entry key="AliasType_Invalid_ResolvedDataType_Enum">BaseType ''{0}'' 未解析为有效的枚举数据类型</entry>
    <entry key="AliasType_Invalid_ResolvedDataType_EnumMetaClassObj">BaseType ''{0}'' is invalid because it resolves to a meta.class object that represents an enumerated data type.  To create an alias to this enumerated data type set the BaseType to ''Enum: {1}''</entry>
    <entry key="AliasType_Invalid_ResolvedDataType_Unscaled">BaseType ''{0}'' is invalid because it does not contain scaling information</entry>
    <entry key="AliasType_Invalid_ResolvedDataType_DataScope">Simulink.AliasType object ''{0}'' and its base type, ''{1}'', have inconsistent scopes. Set ''DataScope'' to ''Exported'' for ''{2}'', or set ''DataScope'' to ''Auto'' and ''HeaderFile'' to '''' for ''{3}''.</entry>
    <entry key="BlockDataTypeError">Datatype error reported from block ''{0}''</entry>
    <entry key="UnknownBusType">Bus type ''{0}'' is not registered with the block diagram ''{1}''.</entry>
    <entry key="Bus_Invalid_Elements">Invalid Elements specified for bus object ''{0}''; the Elements must be an empty array, or array of objects of the class Simulink.BusElement</entry>
    <entry key="Bus_Invalid_Elements2">指定的元素无效；元素必须为空数组，或 Simulink.BusElement 类的对象数组</entry>
    <entry key="Bus_Invalid_Elements3">''Elements'' must be an empty array or an array of Simulink.ConnectionElement objects.</entry>
    <entry key="Bus_Invalid_Elements4">''Elements'' must be an empty array or an array of Simulink.FunctionElement objects.</entry>
    <entry key="BusElementCannotBeComplex">Element ''{0}'' of data type ''{1}'' may not be complex since it is of the bus type ''{2}''; set its ''Complexity'' to ''real''</entry>
    <entry key="BusDoesNotEvalToServiceBus">客户端服务器端口 ''{2}'' 需要 Simulink.ServiceBus 对象，但参数 ''{1}'' 的数据类型 ''{0}'' 解析为 Simulink.Bus</entry>
    <entry key="BusElementCannotBeNonScalar">Element ''{0}'' of data type ''{1}'' must be scalar since it is of the bus type ''{2}''; set its ''Dimensions'' to 1. Alternately, consider setting the ''Mux blocks used to create bus signals'' diagnostic in the Connectivity pane of the Configuration Parameters dialog to ''error'' to support arrays of buses.</entry>
    <entry key="BusElementCannotHaveSameNameAsType">Both the name and the data type of element ''{0}'' in the bus type ''{1}'' are same; this is not allowed when the target language is C++. Consider specifying a different name for the element or its data type.</entry>
    <entry key="BusElementCannotHaveSameNameAsTypeForSim">总线类型 ''{1}'' 中元素 ''{0}'' 的名称和数据类型相同；当仿真目标语言为 C++ 时，不允许出现这种情况。请考虑为该元素或其数据类型指定不同名称。</entry>
    <entry key="BusElementMustInheritSampleTime">Element ''{0}'' of data type ''{1}'' must inherit its sample time since it is of the bus type ''{2}''; set its ''SampleTime'' to -1</entry>
    <entry key="BusElementNonInheritSampleTimeSpecified">Sample time of ''{1}'' in bus object ''{2}'' (specified as the data type for block ''{3}'') must be inherited (-1). To specify a non-inherited sample time (''{0}'') for a bus element, use the SampleTime parameter of the block that produces the signal corresponding to this element.</entry>
    <entry key="BusElementNonInheritSampleTimeSpecifiedNoBlock">Sample time of ''{1}'' in bus object ''{2}'' must be inherited (-1). To specify a non-inherited sample time (''{0}'') for a bus element, use the SampleTime parameter of the block that produces the signal corresponding to this element.</entry>
    <entry key="BusElementMustUseNonFramedSamplingMode">Element ''{0}'' of data type ''{1}'' may not specify a framed sampling mode since it is of the bus type ''{2}''; set its ''SamplingMode'' to ''Sample based''</entry>
    <entry key="BusElementMustUseNonFramedSamplingMode_Not2D">Element ''{0}'' of data type ''{1}'' may not specify a framed sampling mode since it is not 2-Dimensional; set its ''SamplingMode'' to ''Sample based''</entry>
    <entry key="InvalidInterfaceSimscapeBus">Invalid interface, ''{0}'', specified. Supported interfaces are of the format "Bus: &lt;object name&gt;" and "Inherit: auto".</entry>
    <entry key="InvalidInterfacePMIOPort">Invalid interface, ''{0}'', specified. Supported interfaces are of the format "Bus: &lt;object name&gt;", "Connection: &lt;domain name&gt;", and "Inherit: auto".</entry>
    <entry key="InvalidInterfaceSimscapeBusSupportCompositeDomain">指定的接口 ''{0}'' 无效。支持的接口格式为 "总线: &lt;对象名称&gt;"、"CompositeConnection: &lt;域名称&gt;" 和 "继承: 自动"。</entry>
    <entry key="InvalidInterfacePMIOPortSupportCompositeDomain">指定的接口 ''{0}'' 无效。支持的接口格式为 "总线: &lt;对象名称&gt;"，"CompositeConnection: &lt;域名称&gt;"、"连接: &lt;域名称&gt;" 和 "继承: 自动"。</entry>
    <entry key="BusElementIncompatibleType">Invalid data type ''{2}'' specified for Simulink.BusElement object ''{0}'' in Simulink.Bus object ''{1}''. Specify a valid data type that is compatible with bus elements.</entry>
    <entry key="ConnectionElementIncompatibleType">为 Simulink.ConnectionBus object 对象 ''{1}'' 中的 Simulink.ConnectionElement 对象 ''{0}'' 指定的类型 ''{2}'' 无效。请指定有效的 Simscape 域类型或 Simulink.ConnectionBus 对象来创建分层连接。</entry>
    <entry key="SignalBusObjectOnPhysmodBlock">Specifying Simulink.Bus object ''{0}'' for block ''{1}'' is not supported. Specify Simulink.ConnectionBus objects for Simscape Bus connections.</entry>
    <entry key="SimscapeBusConnectionNameErrorChild">Child port {0,number,integer} for block ''{1}'' specifies an invalid connection name, ''{2}''. Use any of the element names defined under the interface, ''{3}'', or use the "Inherit: auto" interface option to specify custom names.</entry>
    <entry key="SimscapeBusConnectionTypeErrorChild">Child port {0,number,integer} (''{1}'') for block ''{2}'' expects a ''{3}'' domain connection according to the interface, ''{4}'', but is connected to a different type. Use the same domain type to connect to this port, or "Inherit: auto" interface option to infer types from connections.</entry>
    <entry key="SimscapeBusConnectionNameErrorChildResolvedBus">模块 ''{1}'' 的子端口 {0,number,integer} 指定了无效的连接名称 ''{2}''。请使用在接口 ''{3}'' 下定义的任意元素名称。</entry>
    <entry key="SimscapeBusConnectionTypeErrorChildResolvedBus">根据接口 ''{4}''，模块 ''{2}'' 的子端口 {0,number,integer} (''{1}'')需要 ''{3}'' 域连接，但实际上连接到了不同类型的连接。请使用相同的域类型连接到此端口。</entry>
    <entry key="SimscapeBusConnectionTypeErrorParent">Parent bus port for block ''{0}'' expects a ''{1}'' bus but is connected to a different type. Use the same bus type to connect to this port, or specify the "Inherit: auto" option to remove the interface specification.</entry>
    <entry key="FlexibleBusConnectedToSimscapeComponentError">连接类型为 "继承: 自动" 的 Simscape Bus 模块 ''{0}'' 连接到了具有指定接口的 Simscape 模块。请使用总线模块上的同一接口连接这两个模块。</entry>
    <entry key="PMIOPortConnectionTypeErrorBus">Connection Port 模块 ''{0}'' 需要的是 ''{1}'' 总线连接，但却被连接到了不同的类型。请使用相同的总线类型连接到此端口，或指定 "继承: 自动" 选项以删除接口设定。</entry>
    <entry key="PMIOPortConnectionTypeErrorSimscape">Connection Port 模块 ''{0}'' 需要 ''{1}'' Simscape 域，但却被连接到了不同的类型。请使用相同的域连接到此端口，或指定 "继承: 自动" 选项以删除接口设定。</entry>
    <entry key="PMIOPortConnectionTypeErrorBusForParentSS">根据 Connection Port 模块 ''{1}'' 上指定的接口，Subsystem 模块 ''{0}'' 需要 ''{2}'' 总线连接，但实际上连接到了不同类型的连接。请使用相同的总线类型连接到此端口，或指定 "继承: 自动" 选项以删除接口设定。</entry>
    <entry key="PMIOPortConnectionTypeErrorSimscapeForParentSS">根据 Connection Port 模块 ''{1}'' 上指定的接口，Subsystem 模块 ''{0}'' 需要 ''{2}'' Simscape 域，但实际上连接了到不同类型的连接。请使用相同的域连接到此端口，或指定 "继承: 自动" 选项以删除接口设定。</entry>
    <entry key="BusObjectAndElementsModeMismatch">总线元素 ''{1}'' 的模式与总线对象 ''{0}'' 的模式不匹配。请将元素模式和对象模式都指定为 '信号' 或 '连接'。</entry>
    <entry key="BusObjectNotInScope">Simulink.Bus object ''{0}'' is not in scope from ''{1}''</entry>
    <entry key="BusParameterMustBeZeroOrStruct">Invalid value specified for the parameter {0} of block ''{1}''. The incoming signal is a non-virtual bus with datatype ''{2}'' and the acceptable values for the parameter are zero or a finite numeric MATLAB structure. Specify zero or use Simulink.Bus.createMATLABStruct to create a MATLAB structure from the bus signal</entry>
    <entry key="BusParameterMustBeZeroOrStructVCNV">Invalid value specified for parameter {0} of block ''{1}''. The incoming signal is a virtual bus that contains an nonvirtual bus. Acceptable values for the parameter are zero or a finite numeric MATLAB structure. Specify zero or use Simulink.Bus.createMATLABStruct to create a MATLAB structure from the bus signal.</entry>
    <entry key="BusParameterMustBeStruct">模块 ''{1}'' 的参数 {0} 必须为有效的结构体。</entry>
    <entry key="BusSameNameAsExistingType">Cannot register bus data type ''{0}'' because another type with this name already exists</entry>
    <entry key="CanAcceptOnlyDblAndBool">The input and output port data types of {0} must be either ''double'' or ''boolean''.  However, the input (or output) port of ''{1}'' is driven by (or driving) signal of data type ''{2}''</entry>
    <entry key="CannotDispMergedSignal">The selected signal originating from &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; on ''{1}'' cannot be displayed because it is being merged</entry>
    <entry key="CannotInitSomeDStates">Not all discrete states in model ''{0}'' could be initialized.  This generally happens when a model contains non-double or complex discrete states.  Use ''Structure with time'' or ''Structure'' format to initialize states</entry>
    <entry key="ConstantNonBuiltinOutportDtype">The sample time of &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of block ''{1}'' is constant, yet its data type is ''{2}''; the sample time of an output port may be constant only if its data type is stored in a built-in type.  If the block has an input port, consider placing a Zero Order Hold block at the input port, to force a non-constant sample time.  Alternatively, if this block is an S-Function, consider using the option SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME</entry>
    <entry key="DataTypeIsNotAnEnumType">''{0}'' attempts to access an enumerated value from data type ''{1}'' but this is not an enumerated data type</entry>
    <entry key="DataTypeObjectNotInScope">Simulink.DataType 对象 ''{0}'' 不在 ''{1}'' 的作用域内</entry>
    <entry key="DataTypeObjectNotInScopeHitCross">Simulink.DataType 对象 ''{0}'' 不在 ''{1}'' 的范围内。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;feval(''Simulink.createHitCrossMessage'');&lt;/cmd&gt; &lt;txt&gt;在 MATLAB 命令行窗口中，运行 'Simulink.createHitCrossMessage' 以在基础工作区中创建一个穿越消息总线对象。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="DataTypePropertiesNotSet">''{0}'' cannot get the properties of data type ''{1}'' since they have not been set</entry>
    <entry key="DataTypeSizeHasNotBeenSet">Size of data type ''{0}'' has not been set</entry>
    <entry key="DataType_InvalidHeaderFile">The data type must specify a HeaderFile property that has no delimiters (''\'' will be implied), or matching delimiters</entry>
    <entry key="DataType_ErrNonAsciiPropertyValue"> Invalid value ''{0}'' for property ''{1}'' because this property only supports ascii characters.</entry>
    <entry key="DataType_InvalidCharsInHeaderFileName">属性 ''HeaderFile'' 的值 ''{0}'' 无效，因为不支持以下字符: ''*?"&lt;&gt;|''。</entry>
    <entry key="DataType_WithIntrinsicFixptName">Invalid name ''{0}'' for data type object; you cannot specify the names of data type objects as "int", "uint", "sfix", "ufix", or "flt" followed by a numeric value since this format is reserved for built-in and intrinsic fixed point types. For example, instead of specifying a data type object with the name 'uint33', you can set the name of the object to 'uint33_T'. </entry>
    <entry key="DefaultDataTypeMethodInRightClickBuild">子系统 ''{0}'' 内的模块的数据类型未定。Simulink 正在使用启发式方法为这些模块选择数据类型。这可能导致使用 ''编译子系统'' 为该子系统生成的代码的行为与完整模型中的行为不一致。请考虑将 "配置参数" 对话框的 ''诊断'' 选项卡的 ''数据有效性 '' 组中指定的 ''未定数据类型'' 参数设置为 ''警告'' 或 ''错误''，以便查看相关模块的列表</entry>
    <entry key="DefaultDataTypeMethodUsedAtPort">此模型中某些信号的数据类型未定。Simulink 正在使用启发式方法来选择这些数据类型。在大多数情况下，启发式方法能做出合理的选择。通过使用 Signal Specification 模块或信号对象设置信号数据类型，可以避免使用启发式方法。具有欠定数据类型的信号的列表如下:</entry>
    <entry key="DefaultDataTypeMethodUsedAtOutPortBlk">Signal with under-specified data types: &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}''.</entry>
    <entry key="DefaultDataTypeMethodUsedAtInPortBlk">Signal with under-specified data types: &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of ''{1}''.</entry>
    <entry key="DworkNamesMustBeUnique">Data type work vector names must be unique.  Data type work {0,number,integer} and {1,number,integer} of ''{2}'' have the same name ''{3}''</entry>
    <entry key="EnablePortsMustHaveIsPositiveRegistered">The enable signal of ''{0}'' may not be of data type ''{1}'' because that type has no positive function registered</entry>
    <entry key="TrigPortsDataTypeNeedRepresentZero">The trigger signal of ''{0}'' may not be of data type ''{1}'' because that type can't represent zero</entry>
    <entry key="EnablePortsDataTypeNeedRepresentZero">The enable signal of ''{0}'' may not be of data type ''{1}'' because that type can't represent zero</entry>
    <entry key="EnumTypeInvalidClass">无法注册枚举数据类型 ''{0}''。</entry>
    <entry key="EnumTypeInvalidClassWithBlock">''{0}'' cannot register enumerated data type ''{1}''.</entry>
    <entry key="EnumTypeInvalidIndex">''{0}'' attempts to access enumerated value with index {1,number,integer} from enumerated data type ''{2}''. This data type has {3,number,integer} enumerated values so the index must be in the range 0:{4,number,integer}</entry>
    <entry key="EnumTypeInvalidValue">''{0}'' attempts to access enumerated value with underlying value {1,number,integer} from enumerated data type ''{2}'' but this data type does not have an enumerated value with this underlying value</entry>
    <entry key="EnumTypeOverflowDuringConversion">Overflow occurred in ''{0}'' during the conversion from data type ''{1}'' to enumerated data type ''{2}''</entry>
    <entry key="EnumTypePrecisionLossDuringConversion">Loss of precision occurred in ''{0}'' during the conversion from data type ''{1}'' to enumerated data type ''{2}''</entry>
    <entry key="EnumTypeValuesDoNotFitIntoProdTargetInt">''{0}'' cannot register enumerated data type ''{1}'' because its underlying values do not fit into the integer type on the production target hardware ({2,number,integer} bits).</entry>
    <entry key="EnumTypeValuesDoNotFitIntoTargetInt">''{0}'' cannot register enumerated data type ''{1}'' because its underlying values do not fit into the integer type on the current target hardware ({2,number,integer} bits).</entry>
    <entry key="EnumTypeNotAClass">Cannot register enumerated data type because value specified is not a class.</entry>
    <entry key="EnumTypeNotAClassWithName">Cannot register enumerated data type ''{0}'' because there is no class with this name.</entry>
    <entry key="EnumTypeNotAnEnumerationClass">Cannot register enumerated data type ''{0}'' because it is not a valid enumeration class.</entry>
    <entry key="EnumTypeWithInvalidSuperclass">Cannot register enumerated data type ''{0}'' because it has an invalid superclass.</entry>
    <entry key="EnumTypeWithMultipleInheritance">Cannot register enumerated data type ''{0}'' because it has multiple superclasses.</entry>
    <entry key="EnumTypeInsidePackage">无法在命名空间内注册枚举数据类型 ''{0}''，因为它不扩展 Simulink.IntEnumType。</entry>
    <entry key="EnumTypeWithComplexValues">Cannot register enumerated data type ''{0}'' with complex values</entry>
    <entry key="EnumTypeWithInvalidIntValues">无法注册枚举值大于或等于 2^31 的枚举数据类型 ''{0}''。</entry>
    <entry key="EnumTypeWithNoEnumStrings">Cannot register enumerated data type ''{0}'' with no enumerated values</entry>
    <entry key="EnumType_ReturnArgumentMustBeAString">Static method {0} must return a character vector</entry>
    <entry key="EnumType_ReturnArgumentMustBeBoolean">Static method {0} must return a scalar logical number (true/false)</entry>
    <entry key="GetEnumTypeInfoArg1">输入参数 1 必须为有效枚举数据类型的名称</entry>
    <entry key="GetEnumTypeInfoArg2">Input argument 2 must be a valid property name ({0})</entry>
    <entry key="EnumType_CannotHandleNamespaceOverride">无法使用枚举类型 ''{0}'' 的定义，因为使用了方法 "generatedCodeIdentifier"</entry>
    <entry key="EnumTypeCannotRetrieveProperty">检索 ''{0}'' 的值时出错。</entry>
    <entry key="EnumType_SameNameAsExistingType">Cannot register enumerated data type ''{0}'' because another type with this name already exists</entry>
    <entry key="EnumType_SameNameAsExistingTypeWithBlock">无法为 ''{1}'' 注册枚举数据类型 ''{0}''，因为已存在另一个同名的类型</entry>
    <entry key="EnumType_SameNameAsWorkspaceVar">Cannot register enumerated data type ''{0}'' because there is a global variable with the same name as this type</entry>
    <entry key="EnumType_SameNameAsWorkspaceVarWithBlock">Cannot register enumerated data type ''{0}'' for ''{1}'' because there is a global variable with the same name as this type</entry>
    <entry key="EnumType_SameNameAsAnyOtherWorkspaceVar">Failed to register enumerated data type ''{0}'' because a variable with the same name exists in the ''{1}''</entry>
    <entry key="EnumType_SameNameAsAnyOtherWorkspaceVarWithBlock">Failed to register enumerated data type ''{0}'' for block ''{1}'' because a variable with the same name exists in the ''{2}''</entry>
    <entry key="EnumType_ValuesDoNotFitIntoStorageType">''{0}'' cannot register enumerated data type ''{1}'' because its underlying values do not fit into the storage type ''{2}''.</entry>
    <entry key="EnumType_InvalidValueForSort">Sort only supports 2-dimensional matrices for distinct enumerations with duplicate underlying values.</entry>
    <entry key="DynamicEnum_CannotConvertFromOtherClass">Cannot convert objects of class ''{0}'' to enumeration class ''{1}''</entry>
    <entry key="DynamicEnum_InvalidNumericValue">The input array could not be converted to the ''{0}'' enumeration class because not all elements match the underlying values of the enumerated list</entry>
    <entry key="DynamicEnum_DuplicateAttributeDefinition">Cannot specify ''{0}'' more than once</entry>
    <entry key="DynamicEnum_DuplicateEnumUsage">使用相同成员标识符 ''{0}'' 的枚举类型 ''{1}'' 和 ''{2}''。即使设置 'EnumMemberNameClash' 设置为 ''{3}''，此设置也仅适用于具有相同值的导入类型和独立于目标的数据类型</entry>
    <entry key="DynamicEnum_EmptyDescription">Cannot specify empty description</entry>
    <entry key="DynamicEnum_EmptyHeaderFile">Cannot specify empty header file</entry>
    <entry key="DynamicEnum_EmptyCppNamespace">无法指定空 CppNamespace</entry>
    <entry key="DynamicEnum_InvalidDefaultValue">默认值与任何枚举名称都不匹配</entry>
    <entry key="DynamicEnum_InvalidStorageType">存储类型不是 Simulink 中内置整数类型的名称</entry>
    <entry key="DynamicEnum_NotEnoughInputs">输入参数的数目不足。必须提供至少 3 个输入</entry>
    <entry key="DynamicEnum_MismatchInPVPairs">Invalid number of input arguments</entry>
    <entry key="DynamicEnum_InvalidClassName">Invalid name for enumeration class ''{0}''</entry>
    <entry key="DynamicEnum_EmptyEnumStrings">No enumeration names specified</entry>
    <entry key="DynamicEnum_MismatchInNumberOfValues">基础数值数目({0,number,integer})与枚举名称的数目({1,number,integer})不匹配</entry>
    <entry key="DynamicEnum_EnumValuesNotInteger">基础数值必须为小于 2^31 的标量实整数。</entry>
    <entry key="DynamicEnum_EnumValuesOutOfRange">Underlying numeric values do not fit into the specified StorageType</entry>
    <entry key="DynamicEnum_EnumValuesComplexOrSparse">Underlying numeric values cannot be complex or sparse</entry>
    <entry key="DynamicEnum_SecondArgMustBeCellOfStrings">Second argument must be a cell array of character vectors, where each character vector is a valid enumeration name</entry>
    <entry key="DynamicEnum_InvalidEnumString">无法使用名称 ''{0}'' 定义枚举，因为这不是有效的 MATLAB 标识符</entry>
    <entry key="DynamicEnum_DuplicateEnumString">无法多次定义具有相同名称 ''{0}'' 的枚举</entry>
    <entry key="DynamicEnum_AttributeNameMustBeString">Input argument {0,number,integer} must be a character vector</entry>
    <entry key="DynamicEnum_AttributeValueMustBeString">Value of ''{0}'' must be specified as a character vector</entry>
    <entry key="DynamicEnum_AttributeValueMustBeLogical">Value of ''{0}'' must be specified as a logical scalar</entry>
    <entry key="UnsupportedDataScopeForIsTunableInCode">To set 'IsTunableInCode' to true for enumeration type ''{0}'', 'DataScope' must be 'Imported' or 'Auto' and 'HeaderFile' must be specified. </entry>
    <entry key="TunableEnumWithDuplicateValues">不支持代码生成，因为枚举类型 ''{0}'' 有重复或无效的值，并且 ''IsTunableInCode'' 设置为 true</entry>
    <entry key="InvalidTunableEnumSimImportDefn">不支持仿真和代码生成，因为模型 ''{0}'' 具有枚举类型 ''{1}''，其中 ''IsTunableInCode'' 属性设置为 ''true'' 并且配置参数 ''SimGenImportedTypeDefs'' 设置为 ''off''</entry>
    <entry key="DynamicEnum_InvalidAttributeName">Invalid attribute for enumeration class ''{0}''</entry>
    <entry key="DynamicEnum_CannotClearClass">无法清除类 ''{0}''，因为还存在该类的实例。</entry>
    <entry key="DynamicEnum_CannotClearClassCreatedByDictionary">Cannot clear enumeration class ''{0}'' because it was defined by a data dictionary.</entry>
    <entry key="DynamicEnum_CannotClearClassCreatedByStateflow">无法清除枚举类 ''{0}''，因为它是由 Stateflow 定义的。</entry>
    <entry key="DynamicEnum_CannotClearClassCreatedByMask">无法清除枚举类 ''{0}''，因为它是由 Simulink Mask 定义的。</entry>
    <entry key="DynamicEnum_CannotClearClassCreatedBySllogging">无法清除枚举类 ''{0}''，因为它是由 Simulink Logging 定义的。</entry>
    <entry key="DynamicEnum_CannotRedefineClassCreatedByDictionary">无法定义枚举类 ''{0}''，因为另一个数据字典中加载了同名的枚举类。请关闭链接到现有数据字典的 Simulink 模型，或执行命令 ''Simulink.data.dictionary.closeAll''。</entry>
    <entry key="DynamicEnum_CannotRedefineClassCreatedByMask">无法定义枚举类 ''{0}''，因为它之前已由 Simulink Mask 定义。</entry>
    <entry key="DynamicEnum_CannotRedefineClassCreatedByStateflow">Cannot define enumeration class ''{0}'' because it was previously defined by Stateflow.  To manually clear the class, type:\nSimulink.clearIntEnumType(''{0}'')</entry>
    <entry key="DynamicEnum_CannotRedefineClass">无法定义枚举类 ''{0}''，因为它之前已定义。</entry>
    <entry key="DynamicEnum_DictionaryCannotClearClass">Dictionary cannot define enumeration class ''{0}'' because it already exists.  Use Simulink.clearIntEnumType to clear the existing class.</entry>
    <entry key="DynamicEnum_StateflowCannotClearClass">Stateflow cannot define enumeration class ''{0}'' because it already exists.  Use Simulink.clearIntEnumType to clear the existing class.</entry>
    <entry key="DynamicEnum_NowNotOwnedByDictionary">Cannot clear enumeration class ''{0}'' because instances of the class still exist.  Class is no longer owned by a data dictionary.</entry>
    <entry key="DynamicEnum_NowNotOwnedByStateflow">无法清除枚举类 ''{0}''，因为还存在该类的实例。类不再由 Stateflow 拥有。</entry>
    <entry key="DynamicEnum_NowNotOwnedByMask">无法清除枚举类 ''{0}''，因为还存在该类的实例。类不再由 Simulink Mask 拥有。</entry>
    <entry key="DynamicEnum_NowNotOwnedBySllogging">无法清除枚举类 ''{0}''，因为还存在该类的实例。类不再由 Simulink Logging 拥有。</entry>
    <entry key="DynamicEnum_CannotModifyStorageType">无法修改现有类 ''{0}'' 的存储类型</entry>
    <entry key="DynamicEnum_TypeNotAClass">类 ''{0}'' 不存在。</entry>
    <entry key="DynamicEnum_TypeNotAnEnumerationClass">Cannot clear class ''{0}'' because it is not a valid enumeration class.</entry>
    <entry key="ErrOverFlowDetected">Overflow condition has been detected at time {0} in ''{1}''&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="ErrSaturationOccurred">Saturation has occurred at time {0} in ''{1}''&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="ErrorDownCastOfInterfacedVar">''{1}'' 的参数 {0} 正在从数据类型 ''{2}'' 转换为数据类型 ''{3}''。对于可调参数表达式，不允许执行向下转换或出现有符号/无符号不匹配的情况，以便于确保仿真和生成的代码之间行为一致&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="FixedPointLicenseFailDt">''{0}'' 指定了数据类型 ''{1}''。使用此数据类型需要 &lt;a href="matlab:web('https://www.mathworks.com/products/fixed-point-designer.html')"&gt;Fixed-Point Designer&lt;/a&gt; 许可证，但许可证签出失败。&lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="DTO"&gt; &lt;cmd&gt;fxptui.removeFixptUsageFromModel(gcs)&lt;/cmd&gt; &lt;txt&gt;点击 "修复" 以用双精度覆盖模型中的数据类型。\n如果模型仍使用定点数据类型，您可能需要重新配置模型以使用浮点类型。有关详细信息，请参阅&lt;a href="matlab:helpview(fullfile(docroot,'fixedpoint','fixedpoint.map'), 'dto_nolicense')"&gt;文档&lt;/a&gt;。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="FixedPointLicenseFailLog">''{0}'' requested logging of min, max or overflow. Logging requires a &lt;a href="matlab:web('https://www.mathworks.com/products/fixed-point-designer.html')"&gt;Fixed-Point Designer&lt;/a&gt;, but license checkout failed.
        &lt;actions exclusiveFixIts="yes"&gt;
            &lt;action type="fixit"&gt;
                &lt;cmd&gt;fxptui.removeMMOFromModel(gcs)&lt;/cmd&gt;
                &lt;txt&gt;Turn off fixed-point instrumentation.&lt;/txt&gt;
            &lt;/action&gt;
        &lt;/actions&gt;
    </entry>
    <entry key="CVTLicenseFailDt">''{0}'' 指定了数据类型 ''{1}''。使用此数据类型需要 &lt;a href="matlab:web('https://www.mathworks.com/products/computer-vision.html')"&gt;Computer Vision Toolbox&lt;/a&gt; 许可证，但许可证签出失败&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="HDLFloatTypecastInvInputPortDataType">Invalid data type ''{0}'' specified for ''{1}'' on the input. Only half, single, double, uint16, uint32 and uint64 data types are supported.</entry>
    <entry key="HDLBitSliceIdxRangeError">Invalid slice index specified for ''{0}'' on the input. MSB and LSB positions must be less than or equal to the word length of the input data type.</entry>
    <entry key="HDLBitSliceIdxValueError">Invalid slice index specified for ''{0}'' on the input. MSB position must be greater than or equal to LSB position.</entry>
    <entry key="HDLBitSliceInvInputPortDataType">为输入中的 ''{1}'' 指定的数据类型 ''{0}'' 无效。仅支持整数、布尔或定点数据类型。</entry>
    <entry key="HDLBitSliceFixptSlopeBiasError">Invalid data type ''{0}'' specified for ''{1}'' on the input. Fixed-point input types should have slope in powers of 2 and zero bias.</entry>
    <entry key="ImportedTypeWithNoHeader">''{0}'' has DataScope set to ''Imported'' and no header file specified. A header file must be specified for ''Imported'' data types.</entry>
    <entry key="InitComplexFlagOfBoolDTypeError">布尔信号不能为复数</entry>
    <entry key="InitComplexFlagOfOpaqueDTypeError">自定义信号不能为复数</entry>
    <entry key="InitComplexFlagOfStructDTypeError">结构体信号不能为复数</entry>
    <entry key="InitComplexSignalError">An error occurred while initializing a signal''s numeric type (real or complex)</entry>
    <entry key="InitDataTypeError">An error occurred while initializing a signal''s data type</entry>
    <entry key="InputMustBeBoolOrDbl">Cannot set the input port data type of ''{0}'' to ''{1}''.  The input port data type must be either ''double'' or ''boolean''.  Signals of other data types can be converted to ''double'' or ''boolean'' by using a Data Type Conversion</entry>
    <entry key="InputMustBeIntegerForConvertToEnumType">''{0}'' 无法将信号从数据类型 ''{1}'' 转换为枚举数据类型 ''{2}''。输入信号的数据类型必须为整数类型</entry>
    <entry key="InputPortCannotAcceptMixedDataType">输入端口无法接受混合数据类型。''{1}'' 的&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;输入端口 {0,number,integer}&lt;/sldiag&gt; 应接受具有唯一数据类型的信号。但它由包含不同数据类型元素的信号驱动。</entry>
    <entry key="InputPortCannotAcceptMixedDataTypeVirtualBus">Outport 模块 ''{1}'' 的&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;输入端口 {0,number,integer}&lt;/sldiag&gt; 预期接收具有唯一数据类型的信号，但收到的却是具有不同数据类型元素的虚拟总线。请使用 Out Bus Element 模块输出包含不同数据类型元素的虚拟总线。</entry>
    <entry key="InputPortCannotAcceptMixedDataTypeForVSSWithHint">The inport block ''{0}'' cannot accept a signal with elements of differing data types. This can be usually fixed by inserting a Signal Conversion block with the ''Signal copy'' option selected, inside the choice blocks of ''{1}''.</entry>
    <entry key="InputPortCannotAcceptMixedDataTypeWithHint">The inport block ''{0}'' is directly connected to outport ''{1}'' and therefore cannot accept a signal with elements of differing data types. This can be usually fixed by inserting a Signal Conversion block with the ''Signal copy'' option selected, at the output of the inport block ''{0}''. Alternatively, if this input port is within a function-call subsystem, consider checking the ''Latch input for feedback signals of function-call subsystem outputs'' option.</entry>
    <entry key="InputPortCannotAcceptMixedDataTypeWithHint_Feedback">Input port cannot accept mixed data types. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' expects a signal with unique data type. However, it is driven by a signal with elements of differing data types. If this input port is within a function-call subsystem, consider checking the ''Latch input for feedback signals of function-call subsystem outputs'' option. Otherwise, insert a Signal Conversion block with the ''Signal copy'' option selected, at the output of block ''{2}''. </entry>
    <entry key="InputPortCannotAcceptMixedSignal">Input port cannot accept mixed numeric types. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' expects a real or complex signal. However, it is driven by a signal that includes both real and complex elements</entry>
    <entry key="InputPortCannotAcceptMixedSignalWithHint">Input port cannot accept mixed numeric types. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' expects a real or complex signal. However, it is driven by a signal that includes both real and complex elements. This can be usually fixed by inserting a Signal Conversion block with the ''Signal copy'' option selected, at the output of block ''{2}''.  Alternatively, if this input port is within a function-call subsystem, consider checking the ''Latch input for feedback signals of function-call subsystem outputs'' option.</entry>
    <entry key="InputPortComplexSignalMismatch">复信号不匹配。''{1}'' 的&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;输入端口 {0,number,integer}&lt;/sldiag&gt; 应接受 {2} 的信号。但它由 {3} 的信号驱动</entry>
    <entry key="InputPortDataTypeMismatch">数据类型不匹配。''{1}'' 的&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;输入端口 {0,number,integer}&lt;/sldiag&gt; 应接受 {2} 的信号。但它由 {3} 的信号驱动。</entry>
    <entry key="InvBoolPortDType">{0} does not accept ''boolean'' signals. The input signal(s) of ''{1}'' must be ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', or ''double''</entry>
    <entry key="InvBuiltinPortDType">{0} 不接受数据类型为 ''{1}'' 的信号。''{2}'' 仅接受 ''boolean''、''uint8''、''uint16''、''uint32''、''int8''、''int16''、''int32''、''single''、''double'' 数据类型</entry>
    <entry key="InvDataConstructForParameter">The parameter {0} of ''{1}'' is not being successfully constructed</entry>
    <entry key="InvConvertBetweenForParameter">The parameter {0} of ''{1}'' is not being successfully converted from type ''{2}'' to ''{3}''{4}{5}</entry>
    <entry key="InvConvertBetweenForPortDType">''{0}'' 的输入信号未成功从类型 ''{1}'' 转换为 ''{2}''{3} {4}</entry>
    <entry key="InvConvertBetweenForTriggerPortDType">The trigger signal of ''{0}'' is not being successfully converted from data type ''{1}'' to ''{2}''</entry>
    <entry key="InvDWorkBooleanComplexDwork">Boolean dworks cannot be complex. Dwork index {0,number,integer} of ''{1}'' is a ''boolean'' dwork. It cannot be complex</entry>
    <entry key="InvDWorkEnumTypeComplexDwork">Enumerated dworks cannot be complex. Dwork index {0,number,integer} of ''{1}'' is a dwork with enumerated data type ''{2}''. It cannot be complex</entry>
    <entry key="InvDWorkOpaqueComplexDwork">Custom dworks cannot be complex. Dwork index {0,number,integer} of ''{1}'' is a dwork with data type ''{2}''. It cannot be complex</entry>
    <entry key="InvDWorkStructComplexDwork">Struct dworks cannot be complex. Dwork index {0,number,integer} of ''{1}'' is a dwork with data type ''{2}''. It cannot be complex</entry>
    <entry key="InvDisagreeInternalRuleDType">数据类型不匹配。内部规则确定 ''{0}'' 的输出为 ''{1}'' 数据类型的信号。但是，它正在驱动数据类型为 ''{2}'' 的信号。</entry>
    <entry key="InvFixptAndBuiltinPortDType">{0} 不接受数据类型为 ''{1}'' 的信号。''{2}'' 仅接受 ''boolean''、''uint8''、''uint16''、''uint32''、''int8''、''int16''、''int32''、''single''、''double'' 和定点数据类型</entry>
    <entry key="InvFixptBoolOutPortDType">{0} 在输出端口上不接受 ''布尔'' 信号。''{1}'' 的输出信号必须为 ''uint8''、''uint16''、''uint32''、''int8''、''int16''、''int32''、''single''、''double'' 或定点数据类型之一</entry>
    <entry key="InvFixptBoolOutputPortDType">Output port(s) of {0} does not accept ''boolean'' signals. The output signal(s) of ''{1}'' must be ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', or ''double'', or one of the fixed-point data types</entry>
    <entry key="InvFixptBoolPortDType">{0} does not accept ''boolean'' signals. The input and output signal(s) of ''{1}'' must be ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', ''double'', or one of the fixed-point data types</entry>
    <entry key="InvInputBooleanComplexSignal">Boolean signals cannot be complex. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a ''boolean'' signal. It cannot be complex</entry>
    <entry key="InvInputHalfComplexSignal">Half-precision signals cannot be complex. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a ''half-precision'' signal. It cannot be complex</entry>
    <entry key="InvInputEnumTypeComplexSignal">Enumerated signals cannot be complex. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a signal with enumerated data type ''{2}''. It cannot be complex</entry>
    <entry key="InvInputFixptComplexSignal">&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a fixed-point signal of data type ''{2}'' with non-zero bias or slope that is not a power of 2. The signal cannot be complex</entry>
    <entry key="InvInputOpaqueComplexSignal">自定义信号不能为复数。''{1}'' 的&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;输入端口 {0,number,integer}&lt;/sldiag&gt; 是数据类型为 ''{2}'' 的信号。在代码生成过程中，它不能为复数。</entry>
    <entry key="InvInputPortComplexSignalSetting">Input port complex signal mismatch.  &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' expects a {2} signal. Based on the output port complex signal, the input port must be a {3} signal</entry>
    <entry key="InvInputPortDType">{0} 的输入端口数据类型必须为 MATLAB 数据类型之一。但 ''{1}'' 的输入端口由数据类型为 ''{2}'' 的信号驱动</entry>
    <entry key="InvInputPortDTypeNotSupported">The input port of {0} does not support the data type ''{1}''. However, the input port of ''{2}'' is driven by a signal of this data type</entry>
    <entry key="InvInputPortDataType">Invalid data type ''{0}'' specified for ''{1}'' input port {2,number,integer}</entry>
    <entry key="InvInputStructComplexSignal">Struct signals cannot be complex. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a signal with data type ''{2}''. It cannot be complex</entry>
    <entry key="InvIsPositiveForEnablePortDType">The enable port signal of ''{0}'' is not being successfully processed by the positive function registered for data type ''{1}''</entry>
    <entry key="InvMPSwtControlPortOutOfBounds">为 ''{0}'' 指定了越界的开关输入。如果使用从 1 开始的索引，则控制输入必须大于或等于 1，并且小于或等于输入数目；如果使用从 0 开始的索引，则控制输入必须大于或等于 0 且小于输入数目</entry>
    <entry key="InvMPSwtPortDataTypes">数据类型不匹配。''{0}'' 的输入端口的主要数据类型为 ''{1}''。但输出端口的数据类型为 ''{2}''。它们应匹配</entry>
    <entry key="InvNonDoublePortDType">模块类型 {0} 只接受 ''double'' 信号。''{1}'' 的端口处的信号的数据类型为 ''{2}''。</entry>
    <entry key="InvNonFloatPortDType">Only ''single'' or ''double'' signals are accepted by block type {0}.  The signals at the ports of ''{1}'' are of data type ''{2}''.</entry>
    <entry key="InvOPortDTypeChooseIntrinsic">''{0}'' cannot set its output port data type to ''{1}''; one way to avoid this problem is to explicitly choose an intrinsic output data type</entry>
    <entry key="InvOutputBooleanComplexSignal">Boolean signals cannot be complex. &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a ''boolean'' signal. It cannot be complex</entry>
    <entry key="InvOutputHalfComplexSignal">Half-precision signals cannot be complex. &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a ''half-precision'' signal. It cannot be complex</entry>
    <entry key="InvOutputEnumTypeComplexSignal">Enumerated signals cannot be complex. &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a signal with enumerated data type ''{2}''. It cannot be complex</entry>
    <entry key="InvOutputFixptComplexSignal">&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a fixed-point signal of data type ''{2}'' with non-zero bias or slope that is not a power of 2. The signal cannot be complex</entry>
    <entry key="InvOutputOpaqueComplexSignal">自定义信号不能为复数。''{1}'' 的&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;输出端口 {0,number,integer}&lt;/sldiag&gt; 是数据类型为 ''{2}'' 的信号。在代码生成过程中，它不能为复数。</entry>
    <entry key="InvOutputPortComplexSignalSetting">Output port complex signal mismatch.  &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a {2} signal. Based on the input port complex signal, the output port must be a {3} signal</entry>
    <entry key="InvOutputPortDTypeNotSupported">The output port of {0} does not support the data type ''{1}''. However, the output port of ''{2}'' is driven by a signal of this data type</entry>
    <entry key="InvOutputPortDataType">Invalid data type ''{0}'' specified for ''{1}'' output port {2,number,integer}</entry>
    <entry key="InvOutputStructComplexSignal">Struct signals cannot be complex. &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a signal with data type ''{2}''. It cannot be complex</entry>
    <entry key="InvPortDType">''{0}'' does not support signals of data type ''{1}''. {2} supports only ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', or ''double'' built-in data types</entry>
    <entry key="InvPortDTypeFunctionName">Signals of type ''{0}'' are not supported by ''{1}'' block. {2} supports only data types of ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', ''double'', or ''half''</entry>
    <entry key="InvPortDTypeSupport">Invalid {0} port data type ''{1}'' in ''{2}''. The data type must be ''boolean'', ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', ''double'', or one of the fixed-point data types</entry>
    <entry key="InvPortDTypeWithoutConvertBetween">''{0}'' 的输入信号可能不是 ''{1}'' 类型，因为该类型没有注册类型转换函数</entry>
    <entry key="InvalidDataType">由 ''{1}'' 指定的数据类型 ''{0}'' 不是有效的标识符</entry>
    <entry key="InvalidDataTypeElementIndex">''{0}'' 尝试对数据类型 ID {2,number,integer} 使用无效的元素索引 {1,number,integer}</entry>
    <entry key="InvalidDataTypeId">''{0}'' 尝试使用无效的数据类型 ID {1,number,integer}</entry>
    <entry key="InvalidDataTypeNumElements">由于以下错误，无法为 ''{1}'' 注册数据类型 ''{0}'': 此数据类型的元素数必须大于零。</entry>
    <entry key="InvalidTypeNumElements">Unable to register type ''{0}'' for ''{1}'' due to the following error: The number of elements must be greater than zero for this type.</entry>
    <entry key="InvalidInputPortComplexSignal">Invalid input port numeric type. Numeric type (real or complex) of &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is invalid</entry>
    <entry key="BuiltinDataTypeNameNotAllowed">Invalid bus object name ''{0}''. Bus object name must not be a built-in data type name or 'auto'.</entry>
    <entry key="InvalidInputPortDataType">Invalid input port data type. Data type of &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is invalid</entry>
    <entry key="InvalidOutputPortComplexSignal">Invalid output port numeric type. Numeric type (real or complex) of &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is invalid</entry>
    <entry key="InvalidOutputPortDataType">输出端口数据类型无效。''{1}'' 的&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;输出端口 {0,number,integer}&lt;/sldiag&gt; 的数据类型无效。</entry>
    <entry key="InvalidResetInputDataType">Cannot set the reset input port data type of ''{0}'' to ''{1}''. The reset input port data type must be ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', ''double'', ''boolean'', or ''ufix1''. Signals of other data types can be converted to these data types by using a Data Type Conversion block.</entry>
    <entry key="InvalidEnableInputDataType">Cannot set the enable input port data type of ''{0}'' to ''{1}''. The enable input port data type must be ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', ''double'', ''boolean'', or ''ufix1''. Signals of other data types can be converted to these data types by using a Data Type Conversion block.</entry>
    <entry key="LoggingNonBuiltInSignalNotSupported">无法记录非内置数据类型的信号</entry>
    <entry key="MdlRefInputPortCannotAcceptMixedDataTypeWithHint">Input port cannot accept mixed data types. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of model block ''{1}'' expects a signal with unique data type. However, it is driven by a signal with elements of differing data types. This can be usually fixed by inserting a Signal Conversion block with the ''Signal copy'' option selected, at the output of Inport block {2,number,integer} of the referenced model. Alternatively, if this input port is within a function-call model, consider checking the ''Latch input for feedback signals of function-call subsystem outputs'' option.</entry>
    <entry key="MdlRefInputPortCannotAcceptMixedSignalWithHint">Input port cannot accept mixed numeric types. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of model block ''{1}'' expects a real or complex signal. However, it is driven by a signal that includes both real and complex elements. This can be usually fixed by inserting a Signal Conversion block with the ''Signal copy'' option selected, at the output of Inport block {2} of the referenced model.  Alternatively, if this input port is within a function-call model, consider checking the ''Latch input for feedback signals of function-call subsystem outputs'' option.</entry>
    <entry key="MustSpecifyAllOrNoneDWorkNames">Some of data type work vector names of ''{0}'' are not specified.  Either all or none of data type work vector names must be specified</entry>
    <entry key="NonSingleOrDoubleComplexSignal">Input port and output port of ''{0}'' must be of type ''single'' or ''double'' when complex</entry>
    <entry key="NumericType_CannotBeAlias">未定标的数值类型不能是别名数据类型</entry>
    <entry key="NumericType_DirectUseOfUnscaled">Invalid attempt to use the unscaled numeric type ''{0}'' directly as a data type</entry>
    <entry key="NumericType_DisableIsAlias">未定标的数值类型不能是别名数据类型。将对象的 IsAlias 属性设置为 false</entry>
    <entry key="NumericType_WarnForOldProperties">属性 ''{0}'' 已弃用，将在以后的版本中删除。请更新您的代码以改用属性 ''{1}''</entry>
    <entry key="NumericType_WarnForOldProperties2">属性 ''{0}'' 已弃用，将在以后的版本中删除。请更新您的代码以改用属性 ''{1}''。如果您在加载 MAT 文件的过程中收到此警告，请重新保存您的 MAT 文件</entry>
    <entry key="NumericType_WarnForOldMethods">方法 ''{0}'' 已弃用，将在以后的版本中删除。请更新您的代码以改用属性 ''{1}''</entry>
    <entry key="OpaqueType_Empty_HeaderFile">数据类型对象 ''{0}'' 必须指定 HeaderFile 属性</entry>
    <entry key="OpaqueType_Invalid_Size">Invalid Size specified; the Size must be greater than 0</entry>
    <entry key="ObjectInScopeNotBus">Variable or object ''{0}'' in scope from ''{1}'' is not a Simulink.Bus object</entry>
    <entry key="ObjectInScopeNotDataType">Variable or object ''{0}'' in scope from ''{1}'' is not a Simulink.DataType object</entry>
    <entry key="OutputMustBeBoolOrDbl">Cannot set the output port data type of ''{0}'' to ''{1}''.  The output port data type must be either ''double'' or ''boolean''</entry>
    <entry key="OutputMustBeInt8OrDbl">Cannot set the output port {0,number,integer} data type of ''{1}'' to ''{2}''.  The output port data type must be either ''double'' or ''int8''</entry>
    <entry key="OutputPortCannotAcceptMixedDataType">Output port cannot have mixed data types. &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' expects a signal with unique data type. However, it is driving a signal with elements of differing data types</entry>
    <entry key="OutputPortCannotAcceptMixedDataTypeWithHint">Output port cannot have mixed data types. &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' expects a signal with unique data type. However, it is driving a signal with elements of differing data types. This can be usually fixed by inserting a Signal Conversion block with the ''Signal copy'' option selected, at its output</entry>
    <entry key="OutputPortCannotAcceptMixedSignal">Output port cannot have mixed numeric types. &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' expects a real or complex signal. However, it is driving a signal that includes both real and complex elements</entry>
    <entry key="OutputPortCannotAcceptMixedSignalWithHint">Output port cannot have mixed numeric types. &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' expects a real or complex signal. However, it is driving a signal that includes both real and complex elements This can be usually fixed by inserting a Signal Conversion block with the ''Signal copy'' option selected, at its output</entry>
    <entry key="OutputPortComplexSignalMismatch">复信号不匹配。''{1}'' 的&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;输出端口 {0,number,integer}&lt;/sldiag&gt; 的信号类型是 {2}。但它驱动的是 {3} 类型的信号</entry>
    <entry key="OutputPortDataTypeMismatch">数据类型不匹配。''{1}'' 的&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;输出端口 {0,number,integer}&lt;/sldiag&gt; 的信号类型是 {2}。但它驱动的是 {3} 类型的信号。</entry>
    <entry key="StringParameterMustBeZero">Invalid value for parameter {0} of block ''{1}''. The incoming signal is either a string data type or a bus signal with at least one element that is a string data type. String data types must have 0 as an initial value.</entry>
    <entry key="ParameterMustBeZero">''{0}'' cannot specify a nonzero value for parameter {1}.  The parameter needs to be converted to the datatype ''{2}'', which does not have a datatype conversion function registered.  Register a datatype conversion function, or use the value zero</entry>
    <entry key="ParameterNoConversionOfEnums">''{0}'' 无法将参数 {1} 从数据类型 ''{2}'' 转换为数据类型 ''{3}''，因为不支持转换具有枚举数据类型的参数</entry>
    <entry key="ParameterNoEmptyValueForTunableEnums">''{0}'' 无法将 ''[]'' 指定为值 {1}，因为具有可调枚举类型 ''{2}'' 的参数不支持空值</entry>
    <entry key="ParameterNoConversionOfTunableEnums">''{0}'' 无法将参数 {1} 从数据类型 ''{2}'' 转换为数据类型 ''{3}''，因为不支持转换具有可调枚举数据类型的参数</entry>
    <entry key="ParameterNoConversionOfStructTypes">''{0}'' cannot convert parameter {1} from data type ''{2}'' to data type ''{3}'' because conversion of parameters with struct data types is not supported</entry>
    <entry key="ParameterNoConversionOfStrings">''{0}'' 不支持将参数 ''{1}'' 从数据类型 ''{2}'' 转换为数据类型 ''{3}''，因为不支持字符串与非字符串数据类型之间的转换。</entry>
    <entry key="PortComplexSignalMismatch">Port complex signal mismatch.  If any input of {0} is a complex signal, then the output must be a complex signal.  The &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;input port {1,number,integer}&lt;/sldiag&gt; of ''{2}'' is a complex signal.  However, the output port is a real signal.</entry>
    <entry key="ProdHWPromotion">''{0}'' 配置为通过内部规则自动选择输出数据类型。它选择了一个具有至少 {1,number,integer} 位的整数数据类型。根据生产硬件特性，不允许使用此大小。要更改生产硬件特性，请从模型的 "仿真" 菜单中选择 "配置参数"，然后选择 "硬件实现" 页。</entry>
    <entry key="PropBackwardComplexSignalError">从 ''{1}'' 的&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{1}"&gt;输入端口 {2,number,integer}&lt;/sldiag&gt; 传播 {0} 时出错。</entry>
    <entry key="PropBackwardDataTypeError">从 ''{1}'' 的&lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{1}"&gt;输入端口 {2,number,integer}&lt;/sldiag&gt; 传播 {0} 时出错。</entry>
    <entry key="PropForwardComplexSignalError">从 ''{1}'' 的&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{1}"&gt;输出端口 {2,number,integer}&lt;/sldiag&gt; 传播 {0} 时出错。</entry>
    <entry key="PropForwardDataTypeError">从 ''{1}'' 的&lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{1}"&gt;输出端口 {2,number,integer}&lt;/sldiag&gt; 传播 {0} 时出错。</entry>
    <entry key="RealInputsComplexOutputErr">输出端口复信号不匹配。如果 {0} 的所有输入均为实信号，则输出也必须为实信号。''{1}'' 的所有输入均为实信号。但输出端口的信号是复信号</entry>
    <entry key="ReqInvalidDiagnostic">Block {0} requested an invalid diagnostic</entry>
    <entry key="ResetPortsMustBeBoolOrDbl">Cannot set the data type of &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' to ''{2}''. The reset signal of an integrator must be of type ''double'' or ''boolean''. Signals of other data types can be converted to ''double'' or ''boolean'' by using a Data Type Conversion</entry>
    <entry key="ServiceBusDoesNotEvalToBus">端口 {2} 需要 Simulink.Bus 对象，但对于参数 ''{1}''，数据类型 ''{0}'' 解析为 Simulink.ServiceBus。 </entry>
    <entry key="SFcnInputPortComplexSignalHasNotBeenSet">Input port complex signal of S-function ''{0}'' has not been set properly</entry>
    <entry key="SFcnInputPortDataTypeHasNotBeenSet">Input port data type of S-function ''{0}'' has not been set properly</entry>
    <entry key="SFcnOutputPortComplexSignalHasNotBeenSet">Output port complex signal of S-function ''{0}'' has not been set properly</entry>
    <entry key="SFcnOutputPortDataTypeHasNotBeenSet">Output port data type of S-function ''{0}'' has not been set properly</entry>
    <entry key="SharedBusAliasedToAnonStruct">Simulink is mapping bus type ''{0}'' to structure type ''{1}'' (defined for a parameter structure). As a result, the bus type cannot be exported. Change the DataScope of the bus object from ''Exported'' to ''Auto''.</entry>
    <entry key="SignalAttribPropDataTypeMixed">混合数据类型</entry>
    <entry key="SignalAttribPropDataTypeFullyKnown">数据类型 ''{0}''</entry>
    <entry key="SignalAttribPropDataTypePartiallyKnown">数据类型 '{'{0}, unknown'}'</entry>
    <entry key="SignalAttribPropNumericTypeMixed">混合数值类型</entry>
    <entry key="SignalAttribPropNumericTypeFullyKnown">数值类型 {0}</entry>
    <entry key="SignalAttribPropDataNumericTypePartiallyKnown">数值类型 '{'{0}, unknown'}'</entry>
    <entry key="SignedOnlyPortDType">{0} does not accept ''boolean'' or ''unsigned'' signals. The input and output signal(s) of ''{1}'' must be ''int8'', ''int16'', ''int32'', ''single'', or ''double'', or one of the signed fixed-point data types</entry>
    <entry key="SpecificInvConvertBetweenForTriggerPortDType">''{0}'' 的触发信号未能从数据类型 ''{1}'' 成功转换为 ''{2}''；{3}</entry>
    <entry key="SpecificInvIsPositiveForEnablePortDType">The enable port signal of ''{0}'' is not being successfully processed by the positive function registered for data type ''{1}''; {2}</entry>
    <entry key="StructElementCannotBeComplexBoolean">Element ''{0}'' of data type ''{1}'' may not be of boolean data type ''{2}'' since that element is complex</entry>
    <entry key="StructElementCannotBeComplexOpaque">Element ''{0}'' of data type ''{1}'' may not be of custom data type ''{2}'' since that element is complex</entry>
    <entry key="StructElementCannotBeComplexStruct">Element ''{0}'' of data type ''{1}'' may not be of struct data type ''{2}'' since that element is complex</entry>
    <entry key="StructElementCannotBeComplexEnum">Element ''{0}'' of data type ''{1}'' may not be of enumerated data type ''{2}'' since that element is complex</entry>
    <entry key="StructElementCannotBeCustomOpaque">Element ''{0}'' of data type ''{1}'' may not be of custom data type ''{2}'' since custom elements are not supported in bus</entry>
    <entry key="StructElement_Invalid_DType">Invalid bus type specified for registration: non-numeric element(s) found.</entry>
    <entry key="StructElement_DataTypeEvalErr">Error evaluating DataType property.</entry>
    <entry key="StructElement_DataType_Auto">指定的数据类型无效；数据类型无法设置为 ''auto''</entry>
    <entry key="StructElement_Type_Empty">指定的类型无效；类型不能为空。</entry>
    <entry key="StructElement_DataType_FcnCall">Invalid DataType specified; function-call signals are not supported as data types on elements.</entry>
    <entry key="StructElement_DataType_Struct">Invalid DataType specified; ''struct'' is not supported as data type on elements.</entry>
    <entry key="StructElement_ErrResolvingDataType">Error resolving DataType ''{0}''</entry>
    <entry key="StructElement_ErrResolvingType">解析类型 ''{0}'' 时出错</entry>
    <entry key="StructElement_Invalid_Name">名称 ''{0}'' 必须以字母或 '''' 字符开头，后跟字母数字或 '''' 字符。名称不能以 ''sl_padding'' 开头。</entry>
    <entry key="StructElement_Invalid_NumDimensions">''Dimensions'' 必须为由正元素组成的双精度向量。对于维数超过 2 的信号，尾部维度不能为 1。</entry>
    <entry key="StructElement_Invalid_NumDimensions_WithName">''{0}'' 的 ''Dimensions'' 必须为由正元素组成的双精度向量。对于维数超过 2 的信号，尾部维度不能为 1。</entry>
    <entry key="StructElement_Invalid_ResolvedDataType">DataType ''{0}'' did not resolve to a valid data type</entry>
    <entry key="StructElement_Invalid_ResolvedDataType_Enum">DataType ''{0}'' did not resolve to a valid enumerated data type</entry>
    <entry key="StructElement_Invalid_ResolvedDataType_Unscaled">DataType ''{0}'' is invalid because it does not contain scaling information</entry>
    <entry key="StructType_Duplicate_Names">指定的元素无效；元素必须有唯一名称</entry>
    <entry key="StructType_Duplicate_Names2">Invalid Elements specified for data type ''{0}''; Elements must have unique names</entry>
    <entry key="StructType_Invalid_Elements">Invalid Elements specified; the Elements must be an empty array, or array of objects of the class Simulink.StructElement</entry>
    <entry key="StructParam_DifferentAttrib">Inconsistent field ''{0}'':\n Expected: {1}\n   Actual: {2}</entry>
    <entry key="StructParam_DifferentNamesOrder">Fields of structure ''{0}'' do not match:\n Expected fields:\n\t {1}\n   Actual fields:\n\t {2}</entry>
    <entry key="StructParam_ExtraNames">结构体 ''{0}'' 的字段不匹配:\n 额外字段:\n\t{1}\n 预期字段:\n\t{2}\n\n 实际字段:\n\t{3}</entry>
    <entry key="StructParam_MissedExtraNames">结构体 ''{0}'' 的字段不匹配:\n 缺失字段:\n\t{1}\n 额外字段:\n\t{2}\n 预期字段:\n\t{3}\n\n 实际字段:\n\t{4}</entry>
    <entry key="StructParam_MissedNames">结构体 ''{0}'' 的字段不匹配:\n 缺失字段:\n\t{1}\n 预期字段:\n\t{2}\n\n 实际字段:\n\t{3}</entry>
    <entry key="SwtDataTypeOutputDisagreeRule">An error occurred while the Simulink model was propagating data types. Data type propagation proposed that the Switch block ''{0}'' accept data type ''{1}'' for input port 1 and data type ''{2}'' for &lt;sldiag objui="inport" objparam="2" objname="{0}"&gt;input port 2&lt;/sldiag&gt;. This Switch block is configured to inherit its output data type via an internal rule which determined that the output data type should be ''{3}''.  However, the data type of the output signal had already been set to ''{4}''. There are several actions you can take to resolve this error. You can change the data type settings for the Switch block. Alternately, you can change the data type settings of the blocks connected to the Switch block''s inputs and/or outputs. You can also insert Data Type Conversion blocks or Signal Specification blocks on the Switch block''s input and/or output signals to resolve data type propagation errors</entry>
    <entry key="TowksCannotLogNonDblOrComplexInMatFormat">''矩阵'' 格式用于 ''{0}'' 的数据记录。''矩阵'' 格式不支持记录非双精度信号或复信号。请使用 ''带时间的结构体'' 或 ''结构体'' 格式(参阅参数对话框中的 "保存格式")</entry>
    <entry key="TriggerSignalCannotBeEnumType">The trigger signal of ''{0}'' is invalid because it has an enumerated data type ''{1}''</entry>
    <entry key="TriggerPortsMustHaveConvertBetweenRegistered">The trigger signal of ''{0}'' may not be of type ''{1}'' because that type has no type conversion function registered</entry>
    <entry key="UdtDoesNotEvalToDataType">''{0}'' 未解析为 ''{2}'' 中参数 ''{1}'' 的有效数据类型。</entry>
    <entry key="UdtDoesNotEvalToEnum">''{0}'' does not resolve to an enumerated data type for parameter ''{1}'' in ''{2}''.</entry>
    <entry key="UdtDoesNotEvalToBus">''{0}'' 未解析为 ''{2}'' 中参数 ''{1}'' 的 Simulink.Bus 对象。</entry>
    <entry key="UdtEmptyDataType">参数 ''{0}'' 不能为空。</entry>
    <entry key="UdtEvalsToFixdtWithNoScaling">''{0}'' resolves to a fixed-point data type with unspecified scaling for parameter ''{1}'' in ''{2}'', but such data type is not supported by this parameter.</entry>
    <entry key="UdtEvalsToUnsupportedBuiltin">''{0}'' resolves to a built-in data type, but the parameter ''{1}'' in ''{2}'' does not support this built-in data type.</entry>
    <entry key="UdtEvalsToUnsupportedEnum">''{0}'' resolves to an enumerated data type, but the parameter ''{1}'' in ''{2}'' does not support enumerated data types.</entry>
    <entry key="UdtEvalsToImplicitBus">''{0}'' resolves to a bus data type for parameter ''{1}'' in ''{2}''. However, if you want to specify a bus data type for a block data type parameter, you must do so explicitly by prefixing it with ''Bus: ''.</entry>
    <entry key="UdtEvalsToUnsupportedFixdt">''{0}'' resolves to a fixed-point data type for parameter ''{1}'' in ''{2}'', but fixed-point data types are not supported by this parameter.</entry>
    <entry key="UdtEvalsToUnsupportedFixdtScalingMode">''{0}'' resolves to a fixed-point data type for parameter ''{1}'' in ''{2}'', but the scaling mode of the resolved data type is not supported by this parameter.</entry>
    <entry key="UdtEvalsToUnsupportedHalfPrecisionType">''{0}'' resolves to half precision floating-point data type for parameter ''{1}'' in ''{2}'', but half precision floating-point data type is not supported by this parameter.</entry>
    <entry key="UdtEvalsToUnsupportedFixdtSignMode">''{0}'' 解析为 ''{2}'' 中参数 ''{1}'' 的定点数据类型，但此参数不支持解析的数据类型的符号模式。</entry>
    <entry key="UdtEvalsToUnsupportedInheritRule">''{0}'' resolves to an inheritance rule, but the parameter ''{1}'' in ''{2}'' does not support this inheritance rule.</entry>
    <entry key="UdtInvBuiltin">''{0}'' 为参数 ''{1}'' 指定了不支持的内置数据类型。</entry>
    <entry key="UdtInvEnumName">''{0}'' 没有为参数 ''{1}'' 提供有效的枚举数据类型名称。</entry>
    <entry key="UdtInvBusName">''{0}'' 没有为参数 ''{1}'' 提供有效的总线数据类型名称。</entry>
    <entry key="UdtInvFixdt">''{0}'' 为参数 ''{1}'' 指定了定点数据类型，但表达式的语法不正确。</entry>
    <entry key="UdtInvInherit">''{0}'' 为参数 ''{1}'' 指定了不支持的继承规则。</entry>
    <entry key="UdtInvalidValue">''{0}'' 中的数据类型设定无效。</entry>
    <entry key="UdtNoEnum">''{0}'' 指定了枚举数据类型，但参数 ''{1}'' 不支持枚举数据类型。</entry>
    <entry key="UdtNoBus">''{0}'' 指定了总线数据类型，但参数 ''{1}'' 不支持总线数据类型。</entry>
    <entry key="UdtReplaceExprHint">''{0}'' is not a valid data type for parameter ''{1}'' in ''{2}''. It needs to be replaced with a MATLAB expression that resolves to a valid Simulink data type object</entry>
    <entry key="UndefinedDataTypeToBeAliasedTo">''{0}'' cannot define data type ''{1}'' to be aliased to id {2,number,integer} because no data type with that id exists</entry>
    <entry key="UnscaledFixptTypeByBlkParam">The data type ''{0}'' specified by block parameter ''{1}'' at ''{2}'' is not valid here because no scaling information is available</entry>
    <entry key="WarnDownCastOfInterfacedVar">''{1}'' 的参数 {0} 正在从数据类型 ''{2}'' 转换为数据类型 ''{3}''。对于可调参数表达式，不建议执行向下转换或出现有符号/无符号不匹配的情况，以便于确保仿真和生成的代码之间行为一致&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="WarningEnumSafeCastDetected">Safe cast detected at time {0} in ''{1}''.&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="WarningOverFlowDetected">Wrap on overflow detected at time {0} in ''{1}''.&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="WarningSaturationOccurred">Saturate on overflow detected at time {0} in ''{1}''.&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="AbsTimeOverflowDetected">Overflow condition detected while evaluating absolute time at {0} for model ''{1}''. This indicates the simulation time is greater than the ''Application life span(days)''.&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="RTWOverFlowDetected">Overflow detected while evaluating the output of ''{0}''.&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="RTWEnumSafeCastDetected">Safe cast detected while evaluating the output of ''{0}''.&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="NumericType_InvalidInput">Input must be of type ''embedded.numerictype''</entry>
    <entry key="NumericType_ScaledDoubleType">Invalid datatype ''Scaled Double'' for Simulink.NumericType object</entry>
    <entry key="EnumDataTypeNotSupportMinMax">Minimum and maximum are not supported for enumerated data type ''{0}''</entry>
    <entry key="EnumDataTypeNotSupportMinMaxOnBusElement">元素 ''{1}'' 上的枚举数据类型 ''{0}'' 不支持最小值和最大值</entry>
    <entry key="StringDataTypeNotSupportMinMaxOnBusElement">元素 ''{0}'' 上的字符串数据类型不支持最小值和最大值</entry>
    <entry key="BusDataTypeNotSupportMinMaxOnBusElement">总线数据类型不支持最小值和最大值。请指定元素 ''{1}'' 上总线对象 ''{0}'' 的叶元素的最小值和最大值</entry>
    <entry key="BusElement_Inconsistent">不一致的元素指定</entry>
    <entry key="BusElementMinValueMustBeFiniteRealDoubleScalar">Minimum on element ''{0}'' must be a finite real double scalar value</entry>
    <entry key="BusElementMaxValueMustBeFiniteRealDoubleScalar">Maximum on element ''{0}'' must be a finite real double scalar value</entry>
    <entry key="SignalTypeMinValueMustBeFiniteRealDoubleScalar">Minimum of a Signal Type object must be a finite real double scalar value</entry>
    <entry key="SignalTypeMaxValueMustBeFiniteRealDoubleScalar">Signal Type 对象的最大值必须为有限双精度实数标量值</entry>
    <entry key="BusElementMinGreaterThanMax">元素 ''{2}'' 上的最小值({0})大于最大值({1})</entry>
    <entry key="BusElementMinIsOutOfDTRange">最小值({0})超出元素 ''{3}'' 的数据类型范围 [{1}, {2}]</entry>
    <entry key="BusElementMaxIsOutOfDTRange">最大值({0})超出元素 ''{3}'' 的数据类型范围 [{1}, {2}]</entry>
    <entry key="CustomDataTypeNotSupportMinMax">元素 ''{1}'' 上的数据类型 ''{0}'' 不支持最小值和最大值</entry>
    <entry key="StringType_InvalidMaxLength">Maximum length argument must be an integer from {0} to {1}, inclusive, or a string representing a valid symbolic dimension expression that can evaluate to an integer from {0} to {1}.</entry>
    <entry key="StringType_NotSupportedInAliasType">AliasType 不支持字符串数据类型作为基类型。</entry>
    <entry key="StringType_ExprMustResolveSymDimsId">
        
                 The expression ''{0}'' of the maximum length argument in the "stringtype" function must be a valid symbolic dimension expression. For more information, see &lt;a href="matlab:helpview(''ecoder'',''dim_variants_for_array_sizes'')"&gt;symbolic dimension&lt;/a&gt;.
        
    </entry>
    <entry key="StringType_SymbolicDimensionDisabled">不支持对模型 ''{1}'' 中 stringtype 的最大长度参量 ''{0}'' 使用符号变量，因为该模型将 '允许符号维度设定' 设置为 off 或使用非 ERT 目标文件。表达式的数值用于字符串数据类型的最大长度参量。</entry>
    <entry key="StringType_ExprMustBeScalar">The expression ''{0}'' of the maximum length argument of the string data type must evaluate to a scalar.</entry>
    <entry key="StringType_ExprMustBePositiveInteger">The expression ''{0}'' of the maximum length argument of the string data type must evaluate to a positive integer.</entry>
    <entry key="StringType_SymbolicDimensionIgnoredByStateflow1">Stateflow 模块、MATLAB Function 模块和 MATLAB System 模块不支持字符串数据类型的最大长度参量的符号表达式。表达式 ''{0}'' 的数值用于模块 ''{1}'' 生成的代码中。</entry>
    <entry key="StringType_SymbolicDimensionIgnoredByStateflow2">Stateflow 模块、MATLAB Function 模块和 MATLAB System 模块不支持字符串数据类型的最大长度参量的符号表达式。字符串数据类型 ''{0}'' 中的符号表达式的数值用于模块 ''{1}'' 生成的代码中。</entry>
    <entry key="StringType_NotSupportedInSlDataObject">数据类型 ''{0}'' 解析为字符串数据类型，不受 {1} 对象支持。</entry>
    <entry key="SpecifyParamsForBestPrecisionMode">已为 ''{1}'' 中的数据类型参数 ''{0}'' 指定最佳精度模式。为了正确计算最佳定标，应指定至少一个以下模块参数: ''{2}''</entry>
    <entry key="InvalidDataScope">''{0}'' is not a valid value for DataScope. Values must be one of ''Auto'', ''Exported'', or ''Imported''</entry>
    <entry key="InvalidImageTypeName">''{0}'' 不是图像类型的有效名称。名称的格式必须为 ''Image_COLORFORMAT_(Row|Col)_UNDERLYINGCLASS_(\\d+_)?\\d+_\\d+$''，其中 COLORFORMAT 必须为 ''BGRA''、''RGB''、''BGR'' 或 ''Grayscale'' 之一，UNDERLYINGCLASS 必须为 ''int8''、''uint8''、''int16''、''uint16''、''int32''、''uint32''、''double''、''single'' 或 ''boolean'' 之一</entry>
    <entry key="InvalidImageTypeColorFormat">''{0}'' 不是 ColorFormat 的有效值。值必须为 ''BGRA''、''RGB''、''BGR'' 或 ''Grayscale'' 之一</entry>
    <entry key="InvalidImageTypeNumChannels">{0,number,integer} is not a valid number of channels for the ColorFormat ''{1}''; the expected number of channels is {2,number,integer}</entry>
    <entry key="InvalidImageTypeNumChannels2">{0,number,integer} is not a valid number of channels for the ColorFormat ''{1}''; the expected number of channels is greater than zero</entry>
    <entry key="InvalidImageTypeNumRows">{0} 不是有效的行数；行数应为大于零的整数</entry>
    <entry key="InvalidImageTypeNumConstructorArgs">{0,number,integer} 不是 ImageType 构造函数的有效参数个数。支持的构造函数是 Simulink.ImageType() 和 Simulink.ImageType(ROWS, COLUMNS, NUMCHANNELS, Name, Value)，其中支持的名称-值对组是 ClassUnderlying、ColorFormat 和 Layout。</entry>
    <entry key="InvalidImageTypeNumCols">{0} 不是有效的列数；列数应为大于零的整数</entry>
    <entry key="InvalidImageTypeLayout">''{0}'' 不是布局的有效值。值必须为 ''RowMajor'' 或 ''ColumnMajor'' 之一</entry>
    <entry key="InvalidImageTypeBaseType">''{0}'' is not a valid value for BaseType. Values must be one of ''Double'', ''Single'', ''int8'', ''uint8'', ''int16'', ''uint16'', ''int32'', ''uint32'', or ''boolean''</entry>
    <entry key="InvalidImageTypeDataScope">图像类型的 DataScope 必须设置为 ''Auto''</entry>
    <entry key="InvalidImageTypeHeaderFile">图像类型的 HeaderFile 必须设置为 ''''</entry>
    <entry key="ImageType_NotSupportedInAliasType">AliasType 不支持图像数据类型作为基类型。</entry>
    <entry key="BlockObjectDTONameClashEditTime">''{0}'' is not a valid identifier for parameter ''{1}'' in ''{2}''. Starting identifiers with ''dtoDbl'', ''dtoSgl'', or ''dtoScl'' is not allowed as this name space is reserved for internal use with data type override mode.</entry>
    <entry key="BlockObjectDTONameClashCompileTime">Potential name clash found for identifier ''{0}'' for parameter ''{1}'' in ''{2}''. This error is caused by one of two conditions. First, entering a parameter value that starts with ''dtoDbl'', ''dtoSgl'', or ''dtoScl'' is not allowed as this name space is reserved for internal use with data type override mode. Second, if your model has active data type override settings and the software has created overridden identifier ''{3}'', a variable cannot exist with this same name in any workspace visible to the model.</entry>
    <entry key="BlockObjectDTONameTooLong">''{2}'' 中参数 ''{1}'' 的标识符 ''{0}'' 太长。模型具有活动数据类型覆盖设置，并且软件创建了覆盖的标识符 ''{3}''，该标识符超过最大长度 {4, number, integer}。请缩短 ''{0}'' 标识符的长度。 </entry>
    <entry key="NoMatchingDataTypeConstructor">未找到具有匹配签名的构造函数 ''{0}''。</entry>
    <entry key="setInvalidUse">You cannot use SET to change the properties of a {0} object; \n use dot notation instead.</entry>
    <entry key="UndefinedMethod">没有为类 ''{1}'' 找到具有匹配签名的方法 ''{0}''。</entry>
    <entry key="AbstractAttribute">Abstract classes cannot be instantiated.  Class ''{0}'' is declared as Abstract.</entry>
    <entry key="OldDataTypeSpecificationBlock">数据类型是使用旧的结构体格式指定的。对此格式的支持将在以后的版本中删除。数值类型对象是设定的首选形式。要构造 Numeric Type 对象，请使用 NUMERICTYPE 或 FIXDT。要将原有结构体设定转换为数值类型对象，请参阅 FIXDTUPDATE。''{0}'' 曾经使用该数据类型。</entry>
    <entry key="OldDataTypeSpecification">A data type has been specified using the old structure format. Support for this format will be removed in a future release. Numeric type objects are the preferred form of specification.  To construct a Numeric Type object use NUMERICTYPE or FIXDT. To convert a legacy structure specification to a numeric type object see FIXDTUPDATE.</entry>
    <entry key="StructToMultiBuses">Structured value of model argument ''{0}'' of ''{1}'' might be mapped to duplicates of bus type {2}. This may result in uncompilable code.</entry>
    <entry key="RefreshDataTypeInWorkspace">--- 刷新数据类型 ---</entry>
    <entry key="DataTypeExpression">&lt;数据类型表达式&gt;</entry>
    <entry key="HalfRapidAccelNotSupported">Rapid accelerator simulation is not supported when the model contains ''half-precision'' data type. </entry>
    <entry key="HalfGPUCodeNotSupported">当模型的结构体类型中包含 ''半精度'' 数据类型时，不支持 GPU 代码生成。 </entry>
    <entry key="HalfGPUMallocModeNotSupported">必须将 Malloc 模式设置为离散模式，才能生成具有 ''半精度'' 数据类型的 GPU 代码。</entry>
    <entry key="HalfGPUComputeCapabilityNotSupported">生成具有 ''半精度'' 数据类型的 GPU 代码需要 5.3 或更高的计算能力。 </entry>
    <entry key="HalfExternalModeNotSupported">When the model contains ''half-precision'' data types, external mode simulation is supported only if the transport layer of the communication channel uses XCP.</entry>
    <entry key="PointerExternalModeNotSupported">当模型包含 ''指针'' 数据类型时，不支持外部模式仿真。</entry>
    <entry key="HalfCPPCodegenNotSupported">C++ code generation is not supported when the model contains ''half'' data type. </entry>
    <entry key="ValueTypeDoesNotSupportBuses">不支持将 Simulink.Bus 对象 ''{0}'' 指定为 Simulink.ValueType 对象 ''{1}'' 的数据类型。</entry>
    <entry key="ValueTypeDoesNotSupportBusesLocal">不支持将 Simulink.Bus 对象指定为 Simulink.ValueType 对象的数据类型。</entry>
    <entry key="ValueTypeDoesNotSupportRecursiveValueType">不支持将 Simulink.ValueType 对象指定为 Simulink.ValueType 对象的数据类型。</entry>
    <entry key="ValueTypeDoesNotSupportEmptyDataType">值类型对象的数据类型不能设置为空字符串。</entry>
    <entry key="OpaqueDataTypeMismatch">{4} &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;{0}(''{1}'',{2,number,integer},''{3,number,integer}'')&lt;/cmd&gt; &lt;txt&gt;设置 {1} 的输出以匹配输入。&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;</entry>
    <entry key="OpaqueDataTypeMismatchFixed">模块 ''{0}'' 现已更新。请重新运行仿真。</entry>
  </message>
</rsccat>
