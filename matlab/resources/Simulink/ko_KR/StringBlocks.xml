<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ko_KR" product="Simulink" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="StringInvalidInputTypeSetting">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;는 데이터형 ''{2}''의 신호를 지원하지 않습니다. 신호의 데이터형은 string형이어야 합니다.</entry>
    <entry key="StringInvalidOutputTypeSetting">&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of block ''{1}'' does not support signals of data type ''{2}''. The signal must be of data type string.</entry>
    <entry key="InvalidNumberofInputs">Block ''{0}'' expects between {1, number, integer} and {2, number, integer} input ports, but currently has {3, number, integer} input ports.</entry>
    <entry key="InvalidNumberofOutputs">Block ''{0}'' expects between {1, number, integer} and {2, number, integer} output ports, but currently has {3, number, integer} output ports.</entry>
    <entry key="InvalidFormatString">The format string ''{0}'' in block ''{1}'' is not valid.</entry>
    <entry key="SL_DSCPT_STRLEN">입력 문자열의 문자 개수를 출력합니다.</entry>
    <entry key="SL_DSCPT_UINT8TOSTRING">uint8형 벡터를 string형 신호로 변환합니다. 변환하는 동안 입력 벡터의 각 요소는 ASCII 값으로 처리됩니다.\n\n예를 들어, 입력 벡터 [72 101 108 108 111]은 문자열 "Hello"로 변환됩니다.</entry>
    <entry key="SL_DSCPT_STRINGTOUINT8">string형 신호를 uint8형 벡터로 변환합니다. 문자열의 각 문자는 이에 대응하는 ASCII 값으로 변환됩니다.\n\n예를 들어, 입력 문자열 “Hello”는 [72 101 108 108 111]로 변환됩니다.</entry>
    <entry key="SL_DSCPT_STR2NUM">입력 문자열을 double형 신호로 변환합니다.</entry>
    <entry key="SL_DSCPT_STR2ENUM">입력 문자열을 열거형 신호로 변환합니다.</entry>
    <entry key="NoEnumValueFound">Input string ''{0}'' of block ''{2}'' does not match any enumerated value in enumerated data type ''{1}''.</entry>
    <entry key="SL_DSCPT_STRCMP">두 입력 문자열을 비교합니다.</entry>
    <entry key="SL_DSCPT_SUBSTR">string형 신호에서 부분문자열을 추출합니다. 부분문자열에는 인덱스 ''idx''의 문자부터 시작하여 ''len''개의 문자가 포함되어 있습니다.\n\n''len''으로 인해 부분문자열이 문자열의 끝을 벗어나는 경우, 출력 신호에는 ''len''개 미만의 문자가 포함됩니다.\n\n''''idx''부터 끝까지의 문자열 출력'' 체크박스가 선택된 경우, 부분문자열에는 ''idx''의 문자부터 시작하여 문자열 끝까지의 문자가 포함됩니다.\n\n예를 들어, 입력 문자열이 “hello 123”, 입력 ''idx''가 1, 입력 ''len''이 5이면 출력은 "hello"가 됩니다. 블록은 1에서 시작하여 그다음에 오는 4자까지 총 5자(hello)의 부분문자열을 추출합니다.</entry>
    <entry key="SubstringIndexOutOfRange">In block ''{0}'' the starting index value is out of range. The starting index ('idx') must be between 1 and the length of the input string ({1, number, integer}).</entry>
    <entry key="SL_DSCPT_STRFIND">텍스트 문자열 ''str''에서 패턴 문자열 ''sub''이 처음 발견된 문자열의 인덱스를 반환합니다.\n\n패턴 문자열이 텍스트 문자열의 일부가 아닌 경우에는 -1을 반환합니다.</entry>
    <entry key="SL_DSCPT_TOSTRING">입력 신호를 string형 신호로 변환합니다.</entry>
    <entry key="StringCompareCaseSensitive">대/소문자 구분</entry>
    <entry key="StringCompareNumOfChars">문자 수:</entry>
    <entry key="StringValue">문자열:</entry>
    <entry key="MaximumLength">출력 벡터 크기:</entry>
    <entry key="SL_DSCPT_STRINGCONSTANT">''문자열'' 파라미터로 지정된 문자열을 출력합니다.</entry>
    <entry key="StringBufferOverflow">The string at &lt;sldiag objui="outport" objparam="{0, number, integer}" objname="{1}"&gt;output port {0, number, integer}&lt;/sldiag&gt; of block ''{1}'' has a length of {2, number, integer} characters, which is larger than the maximum length of {3, number, integer} characters specified by the block.</entry>
    <entry key="SubStringMismatchedStringDataTypes">In block ''{0}'', the output data type was already set to {1}, but a data type {2} was propagated.</entry>
    <entry key="SubstringIndexInvalidDataType">In block ''{0}'', &lt;sldiag objui="inport" objparam="2" objname="{0}"&gt;input port 2&lt;/sldiag&gt; must have an integer data type.</entry>
    <entry key="SubstringLengthInvalidDataType">In block ''{0}'', &lt;sldiag objui="inport" objparam="3" objname="{0}"&gt;input port 3&lt;/sldiag&gt; must have an unsigned integer data type.</entry>
    <entry key="NonExtendedASCIIString">블록 ''{0}''은(는) 확장 ASCII 문자(ISO-8859-1)만 지원합니다. 파라미터 ''{1}''에 지원되지 않는 문자가 포함되어 있습니다.</entry>
    <entry key="ParamValueExceedMaxStringLength">블록 ''{1}''의 파라미터 ''{0}''은(는) 값이 {2}입니다. 문자열의 최대 문자 수는 {3}개 이하여야 합니다.</entry>
    <entry key="VectorSizeExceedMaxStringLength">블록 ''{1}''의 입력 벡터 크기 {0}이(가) 문자열의 최대 문자 수를 초과합니다. 문자열의 최대 문자 수는 {2}개 이하여야 합니다.</entry>
    <entry key="StringLengthOverFlow">''{0}''에서 오류 발생함: ''{1}''의 문자 수가 {2, number, integer}을(를) 초과합니다.</entry>
    <entry key="SL_PARAM_COMPLEXITY">실수/복소수 여부: </entry>
    <entry key="InvalidComplexOutput">출력은 실수여야 합니다.</entry>
    <entry key="SL_DSCPT_FORMATSTRING">''형식'' 파라미터 및 입력 신호를 기준으로 출력 string형 신호를 구성합니다. ''형식'' 파라미터에 따라 입력 신호 개수가 결정됩니다.\n\n예를 들어, ''형식'' 파라미터가 "%s is %f."(으)로 설정된 경우, 블록에는 2개의 입력, 즉 한 개의 string형 신호 및 한 개의 single형 또는 double형 신호가 필요합니다. 첫 번째 입력이 문자열 "Pi"이고 두 번째 입력이 double형 값 3.14인 경우 출력은 "Pi is 3.14."입니다.</entry>
    <entry key="SL_DSCPT_SCANSTRING">입력 문자열을 스캔한 후 ''형식'' 파라미터로 지정된 형식에 따라 신호로 변환합니다. 결과를 숫자형 또는 string형 신호로 출력합니다.\n\n예를 들어, ''형식'' 파라미터가 "%s is %f."(으)로 설정된 경우 블록은 2개의 부분, 즉 한 개의 string형 신호와 한 개의 single형 신호를 출력합니다. 입력이 문자열 "Pi is 3.14"인 경우 2개의 출력은 "Pi"와 "3.14"입니다.</entry>
    <entry key="SL_DSCPT_STRCAT">입력 문자열을 결합하여 하나의 출력 문자열을 형성합니다.</entry>
    <entry key="SL_PARAM_INPUTFORMAT">형식:</entry>
    <entry key="InvalidInputDataType">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0, number, integer}" objname="{1}"&gt;{0, number, integer}번 입력 포트&lt;/sldiag&gt;는 데이터형이 ''{2}''인 신호를 지원하지 않습니다. 입력 포트에는 데이터형이 ''{3}''인 신호가 필요합니다.</entry>
    <entry key="InvalidInputDataTypeFloat">&lt;sldiag objui="inport" objparam="{0, number, integer}" objname="{1}"&gt;Input port {0, number, integer}&lt;/sldiag&gt; of block ''{1}'' does not support a signal of data type ''{2}''. The input port expects a signal of data type ''single'' or ''double''.</entry>
    <entry key="InvalidInputDataTypeInteger">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0, number, integer}" objname="{1}"&gt;{0, number, integer}번 입력 포트&lt;/sldiag&gt;는 데이터형이 ''{2}''인 신호를 지원하지 않습니다. 이 입력 포트에 대해 데이터형 ''{3}''을(를) 사용해 보십시오.</entry>
    <entry key="InvalidInputDataTypeUnsupportedInteger">&lt;sldiag objui="inport" objparam="{0, number, integer}" objname="{1}"&gt;Input port {0, number, integer}&lt;/sldiag&gt; of block ''{1}'' does not support format specifier ''{2}''. An integer format specifier must match an integer type in the Hardware Implementation device detail settings with 8, 16, 32, or 64 number of bits.</entry>
    <entry key="InvParameterDatatypeNotSupportString">String data type, specified in parameter ''{0}'', is not supported for block ''{1}''.</entry>
    <entry key="InvalidInputDataTypeString">&lt;sldiag objui="inport" objparam="{0, number, integer}" objname="{1}"&gt;Input port {0, number, integer}&lt;/sldiag&gt; of block ''{1}'' does not support a signal of data type ''{2}''. The input port expects a signal of data type ''string''.</entry>
    <entry key="OnlyScalarString">Parameter ''{0}'' of block ''{1}'' only accepts scalar string value. Simulink has no support for array of strings yet.</entry>
    <entry key="ParameterValueIsNotString">블록 ''{1}''의 파라미터 ''{0}''은(는) string형 값만 받습니다. 표현식 ''{2}''의 평가된 값이 string형이 아닙니다.</entry>
    <entry key="CompareAll">전체 문자열</entry>
    <entry key="CompareFirstN">처음 N개 문자</entry>
    <entry key="Compare_Option">비교 옵션:</entry>
    <entry key="InheritMaximumLength">입력에서 최대 길이 상속</entry>
    <entry key="StringFromIdxToEnd">''idx''부터 끝까지의 문자열 출력</entry>
    <entry key="ScanNotAllOutputsWritten">블록 ''{0}''에서 입력 string형 신호가 ''형식'' 파라미터와 일치하지 않습니다. {2,number,integer}개 출력 포트 중 {1,number,integer}개가 성공적으로 할당되었습니다.</entry>
    <entry key="ScanStringInvalidIntegerType">At &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of block ''{1}'', the ''{2}'' specifier is not supported with a target integer width of {3,number,integer} bits. Only integer widths of 16, 32, and 64 bits are supported. Consider using a different length specifier.</entry>
    <entry key="NoC89SupportForBlock">Failed to generate C code for block {0}. A common solution is to set ''Language standard'' to ''C99 (ISO)''.
      &lt;actions exclusiveFixIts="yes"&gt;
         &lt;action type="fixit"&gt;
           &lt;cmd&gt;configset.internal.fixIt(''{0}'',''TargetLangStandard'',''C99 (ISO)'')&lt;/cmd&gt;
           &lt;txt&gt;Select the ''C99 (ISO)'' &lt;sldiag objui="configset" objparam="TargetLangStandard"&gt;Language standard&lt;/sldiag&gt;.&lt;/txt&gt;
         &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="InvStringSignalAsBusElement"> Element ''{0}'', of ''{1}'', is a string data type that is invalid: </entry>
    <entry key="InvPrmSettingWithStringType">Invalid setting in block ''{0}'' for parameter ''{1}'' when output data type is string.</entry>
    <entry key="RapidAccelNotSupported"> Rapid accelerator simulation is not supported when the model contains Simulink string data type. </entry>
    <entry key="RapidAccelCmdSimNotSupported">Rapid accelerator simulation from the MATLAB command line (''sim'' function) is not supported when the model contains Simulink string data type. Instead, simulate the model from Simulink Editor.</entry>
    <entry key="ExtModeSimNotSupported"> External mode simulation is not supported when the model contains Simulink string data type. </entry>
    <entry key="AsciiToStringOverflowTruncation"> 모든 문자와 끝에 있는 null 종결자를 저장하려면 ''{0}''의 입력 벡터의 버퍼 크기가 ''{1, number, integer}''바이트여야 합니다. 필요한 이 버퍼 크기가 구성 파라미터 “동적 크기 문자열의 버퍼 크기”에 의해 지정된 동적 문자열의 버퍼 크기(''{2,number, integer}''바이트)를 초과합니다. 생성된 코드의 경우 ASCII To String 블록이 ''{3,number, integer}''바이트 버퍼에 맞도록 문자열 출력을 자릅니다. 자르는 동작을 방지하려면 문자열 버퍼 크기를 늘려 보십시오. </entry>
    <entry key="Contains">패턴을 포함</entry>
    <entry key="StartsWith">패턴으로 시작</entry>
    <entry key="EndsWith">패턴으로 끝남</entry>
    <entry key="ContainsDescription">문자열(str)에 패턴(sub)이 포함되어 있는지 또는 패턴으로 시작하거나 끝나는지 확인합니다.</entry>
    <entry key="CountDescription">문자열(str)에서 패턴(sub)이 나타나는 횟수를 셉니다. 횟수를 셀 때 중첩되지 않는 방식을 사용합니다. 패턴이 나타나는 두 부분이 서로 중첩될 경우 한 번으로 계산합니다.</entry>
    <entry key="Count">개수</entry>
    <entry key="ContainsFunction">함수: </entry>
    <entry key="OutputOverflowError">The output of block ''{0}'' at port {1,number,integer} is {2,number,integer} and overflows its current data type ''{3}''. Consider another output data type that can fit the value of the output. </entry>
    <entry key="TargetDataTypeNotInSupportedList">Output signal of block ''{0}'' drives signal of data type ''{1}''. Output data type of this block must be ''{2}''.</entry>
    <entry key="UnsupportedCPPStringInBus">Delay block ''{0}'' does not support bus with string elements when 'Show enable port' is selected and string is generated as C++ std::string.</entry>
    <entry key="StringStripCharNotEqualOne">Invalid ''Character'' setting in ''{0}'': ''{1}'' contains multiple characters. The removal of more than one character is not supported.</entry>
    <entry key="StripLeft">왼쪽에서 제거</entry>
    <entry key="StripRight">오른쪽에서 제거</entry>
    <entry key="StripBoth">왼쪽 및 오른쪽에서 제거</entry>
    <entry key="StripChar_Options">제거할 문자</entry>
    <entry key="StripCharValue">문자</entry>
    <entry key="StripWhiteSpace">공백, 탭, 줄 바꿈</entry>
    <entry key="ReplaceDescription">발견된 이전 부분문자열을 모두 새 부분문자열로 바꿉니다.</entry>
    <entry key="Replace">바꾸기</entry>
    <entry key="Erase">지우기</entry>
    <entry key="ReplaceBetweenDescription">str의 부분문자열을 newStr의 텍스트로 바꿉니다. 대체되는 부분문자열은 부분문자열 startStr과 endStr 사이에 있습니다. 또는 str에서 str의 위치 startPos와 endPos 사이에 있는 부분문자열을 바꿉니다.</entry>
    <entry key="ReplaceBetween">다음 사이 바꾸기</entry>
    <entry key="EraseBetween">다음 사이 지우기</entry>
    <entry key="RangeTypeSubstring">시작 부분문자열과 끝 부분문자열의 모든 쌍</entry>
    <entry key="RangeTypeIndex">시작 인덱스 및 끝 인덱스</entry>
    <entry key="RangeType">다음 사이의 범위:</entry>
    <entry key="Boundary">경계 포함</entry>
    <entry key="ReplaceBetweenStartIndexOOR">블록 ''{0}''의 시작 인덱스({1,number,integer})의 입력값은 경계 불포함 설정의 경우 0보다 작지 않아야 하고 경계 포함 설정의 경우 1보다 작지 않아야 합니다.</entry>
    <entry key="ReplaceBetweenEndIndexOOR">블록 ''{0}''에서 입력 문자열의 길이가 {1,number,integer}입니다. 끝 인덱스({2,number,integer})의 입력값은 경계 포함 설정의 경우 {1,number,integer}보다 크지 않아야 하고 경계 불포함 설정의 경우 {3,number,integer}보다 크지 않아야 합니다.</entry>
    <entry key="ReplaceBetweenInconsistentStartEndIndex">블록 ''{0}''의 시작 인덱스({1,number,integer})와 끝 인덱스({2,number,integer})의 조합이 유효하지 않습니다.</entry>
    <entry key="ReplaceBetweenUnsupportedIndexTypeIndex">Input port {1,number,integer} of block ''{0}'' must have 8-, 16- or 32-bit integer type.</entry>
    <entry key="MaxNumCharacters">최대 문자 개수:</entry>
  </message>
</rsccat>
