<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ko_KR" product="Simulink" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="AliasTypeEmissionRequiresECoderLicense">생성 코드에서 별칭 데이터형의 이름을 유지하려면 ERT 또는 ERT 파생 타깃이 필요합니다. 코드 생성 중 내장 유형으로 되돌리는 중입니다.</entry>
    <entry key="AliasTypesNotSupportedForMultiWordCodeGen">별칭 데이터형 ''{0}''이(가) 멀티워드 기본 유형 ''{1}''을(를) 갖습니다. 코드 생성 시 멀티워드 별칭은 지원되지 않습니다. 기본 유형으로 되돌립니다.</entry>
    <entry key="AliasType_BaseType_Auto">Invalid BaseType specified; BaseType may not be set to ''auto''</entry>
    <entry key="AliasType_BaseType_Bus">BaseType ''{0}'' must not be specified as a bus.</entry>
    <entry key="AliasType_BaseType_ValueType">BaseType ''{0}''은(는) Simulink.ValueType 객체를 사용하여 지정하면 안 됩니다.</entry>
    <entry key="AliasType_ErrResolvingDataType">Error resolving BaseType ''{0}''</entry>
    <entry key="AliasType_Invalid_BaseType">지정된 BaseType이 유효하지 않습니다. BaseType은 유효한 식별자여야 합니다.</entry>
    <entry key="AliasType_Invalid_ResolvedDataType">BaseType ''{0}'' did not resolve to a valid data type</entry>
    <entry key="AliasType_Invalid_ResolvedDataType_Bus">BaseType ''{0}'' did not resolve to a valid data type.  Cannot specify BaseType to be a bus object</entry>
    <entry key="AliasType_Invalid_ResolvedDataType_Enum">BaseType ''{0}''이(가) 유효한 열거형 데이터형으로 확인되지 않았습니다.</entry>
    <entry key="AliasType_Invalid_ResolvedDataType_EnumMetaClassObj">BaseType ''{0}'' is invalid because it resolves to a meta.class object that represents an enumerated data type.  To create an alias to this enumerated data type set the BaseType to ''Enum: {1}''</entry>
    <entry key="AliasType_Invalid_ResolvedDataType_Unscaled">BaseType ''{0}'' is invalid because it does not contain scaling information</entry>
    <entry key="AliasType_Invalid_ResolvedDataType_DataScope">Simulink.AliasType object ''{0}'' and its base type, ''{1}'', have inconsistent scopes. Set ''DataScope'' to ''Exported'' for ''{2}'', or set ''DataScope'' to ''Auto'' and ''HeaderFile'' to '''' for ''{3}''.</entry>
    <entry key="BlockDataTypeError">Datatype error reported from block ''{0}''</entry>
    <entry key="UnknownBusType">Bus type ''{0}'' is not registered with the block diagram ''{1}''.</entry>
    <entry key="Bus_Invalid_Elements">Invalid Elements specified for bus object ''{0}''; the Elements must be an empty array, or array of objects of the class Simulink.BusElement</entry>
    <entry key="Bus_Invalid_Elements2">유효하지 않은 요소가 지정되었습니다. 요소는 빈 배열이거나 Simulink.BusElement 클래스의 객체로 구성된 배열이어야 합니다</entry>
    <entry key="Bus_Invalid_Elements3">''Elements''는 빈 배열이거나 Simulink.ConnectionElement 객체로 구성된 배열이어야 합니다.</entry>
    <entry key="Bus_Invalid_Elements4">''Elements''는 빈 배열이거나 Simulink.FunctionElement 객체로 구성된 배열이어야 합니다.</entry>
    <entry key="BusElementCannotBeComplex">Element ''{0}'' of data type ''{1}'' may not be complex since it is of the bus type ''{2}''; set its ''Complexity'' to ''real''</entry>
    <entry key="BusDoesNotEvalToServiceBus">클라이언트 서버 포트 ''{2}''에는 Simulink.ServiceBus 객체가 필요한데, 데이터형 ''{0}''은(는) 파라미터 ''{1}''에 대한 Simulink.Bus로 연결이 맺어집니다</entry>
    <entry key="BusElementCannotBeNonScalar">Element ''{0}'' of data type ''{1}'' must be scalar since it is of the bus type ''{2}''; set its ''Dimensions'' to 1. Alternately, consider setting the ''Mux blocks used to create bus signals'' diagnostic in the Connectivity pane of the Configuration Parameters dialog to ''error'' to support arrays of buses.</entry>
    <entry key="BusElementCannotHaveSameNameAsType">Both the name and the data type of element ''{0}'' in the bus type ''{1}'' are same; this is not allowed when the target language is C++. Consider specifying a different name for the element or its data type.</entry>
    <entry key="BusElementCannotHaveSameNameAsTypeForSim">버스 유형 ''{1}''의 요소 ''{0}''의 이름과 데이터형이 동일합니다. 이는 시뮬레이션 타깃 언어가 C++인 경우 허용되지 않습니다. 요소에 대해 다른 이름을 지정하거나 다른 데이터형을 지정해 보십시오.</entry>
    <entry key="BusElementMustInheritSampleTime">Element ''{0}'' of data type ''{1}'' must inherit its sample time since it is of the bus type ''{2}''; set its ''SampleTime'' to -1</entry>
    <entry key="BusElementNonInheritSampleTimeSpecified">Sample time of ''{1}'' in bus object ''{2}'' (specified as the data type for block ''{3}'') must be inherited (-1). To specify a non-inherited sample time (''{0}'') for a bus element, use the SampleTime parameter of the block that produces the signal corresponding to this element.</entry>
    <entry key="BusElementNonInheritSampleTimeSpecifiedNoBlock">Sample time of ''{1}'' in bus object ''{2}'' must be inherited (-1). To specify a non-inherited sample time (''{0}'') for a bus element, use the SampleTime parameter of the block that produces the signal corresponding to this element.</entry>
    <entry key="BusElementMustUseNonFramedSamplingMode">Element ''{0}'' of data type ''{1}'' may not specify a framed sampling mode since it is of the bus type ''{2}''; set its ''SamplingMode'' to ''Sample based''</entry>
    <entry key="BusElementMustUseNonFramedSamplingMode_Not2D">Element ''{0}'' of data type ''{1}'' may not specify a framed sampling mode since it is not 2-Dimensional; set its ''SamplingMode'' to ''Sample based''</entry>
    <entry key="InvalidInterfaceSimscapeBus">Invalid interface, ''{0}'', specified. Supported interfaces are of the format "Bus: &lt;object name&gt;" and "Inherit: auto".</entry>
    <entry key="InvalidInterfacePMIOPort">Invalid interface, ''{0}'', specified. Supported interfaces are of the format "Bus: &lt;object name&gt;", "Connection: &lt;domain name&gt;", and "Inherit: auto".</entry>
    <entry key="InvalidInterfaceSimscapeBusSupportCompositeDomain">유효하지 않은 인터페이스 ''{0}''이(가) 지정되었습니다. 지원되는 인터페이스의 형식은 "Bus: &lt;object name&gt;", "CompositeConnection: &lt;domain name&gt;", "Inherit: auto"입니다.</entry>
    <entry key="InvalidInterfacePMIOPortSupportCompositeDomain">유효하지 않은 인터페이스 ''{0}''이(가) 지정되었습니다. 지원되는 인터페이스의 형식은 "Bus: &lt;object name&gt;", "CompositeConnection: &lt;domain name&gt;", "Connection: &lt;domain name&gt;", "Inherit: auto"입니다.</entry>
    <entry key="BusElementIncompatibleType">Invalid data type ''{2}'' specified for Simulink.BusElement object ''{0}'' in Simulink.Bus object ''{1}''. Specify a valid data type that is compatible with bus elements.</entry>
    <entry key="ConnectionElementIncompatibleType">Invalid type ''{2}'' specified for Simulink.ConnectionElement object ''{0}'' in Simulink.ConnectionBus object ''{1}''. Specify a valid Simscape domain type or a Simulink.ConnectionBus object to create hierarchical connections.</entry>
    <entry key="SignalBusObjectOnPhysmodBlock">Specifying Simulink.Bus object ''{0}'' for block ''{1}'' is not supported. Specify Simulink.ConnectionBus objects for Simscape Bus connections.</entry>
    <entry key="SimscapeBusConnectionNameErrorChild">Child port {0,number,integer} for block ''{1}'' specifies an invalid connection name, ''{2}''. Use any of the element names defined under the interface, ''{3}'', or use the "Inherit: auto" interface option to specify custom names.</entry>
    <entry key="SimscapeBusConnectionTypeErrorChild">Child port {0,number,integer} (''{1}'') for block ''{2}'' expects a ''{3}'' domain connection according to the interface, ''{4}'', but is connected to a different type. Use the same domain type to connect to this port, or "Inherit: auto" interface option to infer types from connections.</entry>
    <entry key="SimscapeBusConnectionNameErrorChildResolvedBus">Child port {0,number,integer} for block ''{1}'' specifies an invalid connection name, ''{2}''. Use any of the element names defined under the interface, ''{3}''.</entry>
    <entry key="SimscapeBusConnectionTypeErrorChildResolvedBus">Child port {0,number,integer} (''{1}'') for block ''{2}'' expects a ''{3}'' domain connection according to the interface, ''{4}'', but is connected to a different type. Use the same domain type to connect to this port.</entry>
    <entry key="SimscapeBusConnectionTypeErrorParent">Parent bus port for block ''{0}'' expects a ''{1}'' bus but is connected to a different type. Use the same bus type to connect to this port, or specify the "Inherit: auto" option to remove the interface specification.</entry>
    <entry key="FlexibleBusConnectedToSimscapeComponentError">연결 유형 "Inherit: auto"를 사용하는 Simscape Bus 블록 ''{0}''이(가) 지정된 인터페이스를 사용하는 Simscape 블록에 연결되어 있습니다. 이 버스 블록에 동일한 인터페이스를 사용하여 두 블록을 연결하십시오.</entry>
    <entry key="PMIOPortConnectionTypeErrorBus">Connection Port block ''{0}'' expects a ''{1}'' bus connection, but is connected to a different type. Use the same bus type to connect to this port, or specify the "Inherit: auto" option to remove the interface specification.</entry>
    <entry key="PMIOPortConnectionTypeErrorSimscape">Connection Port block ''{0}'' expects a ''{1}'' Simscape domain, but is connected to a different type. Use the same domain to connect to this port, or specify the "Inherit: auto" option to remove the interface specification.</entry>
    <entry key="PMIOPortConnectionTypeErrorBusForParentSS">Subsystem block ''{0}'' expects a ''{2}'' bus connection according to the interface specified on Connection Port block ''{1}'', but is connected to a different type. Use the same bus type to connect to this port, or specify the "Inherit: auto" option to remove the interface specification.</entry>
    <entry key="PMIOPortConnectionTypeErrorSimscapeForParentSS">Subsystem block ''{0}'' expects a ''{2}'' Simscape domain according to the interface specified on Connection Port block ''{1}'', but is connected to a different type. Use the same domain to connect to this port, or specify the "Inherit: auto" option to remove the interface specification.</entry>
    <entry key="BusObjectAndElementsModeMismatch">Mode for bus element ''{1}'' does not match mode of bus object ''{0}''. Specify both element and object modes to be either 'Signal', or 'Connection'.</entry>
    <entry key="BusObjectNotInScope">Simulink.Bus object ''{0}'' is not in scope from ''{1}''</entry>
    <entry key="BusParameterMustBeZeroOrStruct">Invalid value specified for the parameter {0} of block ''{1}''. The incoming signal is a non-virtual bus with datatype ''{2}'' and the acceptable values for the parameter are zero or a finite numeric MATLAB structure. Specify zero or use Simulink.Bus.createMATLABStruct to create a MATLAB structure from the bus signal</entry>
    <entry key="BusParameterMustBeZeroOrStructVCNV">Invalid value specified for parameter {0} of block ''{1}''. The incoming signal is a virtual bus that contains an nonvirtual bus. Acceptable values for the parameter are zero or a finite numeric MATLAB structure. Specify zero or use Simulink.Bus.createMATLABStruct to create a MATLAB structure from the bus signal.</entry>
    <entry key="BusParameterMustBeStruct">블록 ''{1}''의 파라미터 {0}은(는) 유효한 구조체여야 합니다.</entry>
    <entry key="BusSameNameAsExistingType">Cannot register bus data type ''{0}'' because another type with this name already exists</entry>
    <entry key="CanAcceptOnlyDblAndBool">The input and output port data types of {0} must be either ''double'' or ''boolean''.  However, the input (or output) port of ''{1}'' is driven by (or driving) signal of data type ''{2}''</entry>
    <entry key="CannotDispMergedSignal">The selected signal originating from &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; on ''{1}'' cannot be displayed because it is being merged</entry>
    <entry key="CannotInitSomeDStates">Not all discrete states in model ''{0}'' could be initialized.  This generally happens when a model contains non-double or complex discrete states.  Use ''Structure with time'' or ''Structure'' format to initialize states</entry>
    <entry key="ConstantNonBuiltinOutportDtype">The sample time of &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of block ''{1}'' is constant, yet its data type is ''{2}''; the sample time of an output port may be constant only if its data type is stored in a built-in type.  If the block has an input port, consider placing a Zero Order Hold block at the input port, to force a non-constant sample time.  Alternatively, if this block is an S-Function, consider using the option SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME</entry>
    <entry key="DataTypeIsNotAnEnumType">''{0}'' attempts to access an enumerated value from data type ''{1}'' but this is not an enumerated data type</entry>
    <entry key="DataTypeObjectNotInScope">Simulink.DataType 객체 ''{0}''이(가) ''{1}''의 범위 내에 없음</entry>
    <entry key="DataTypeObjectNotInScopeHitCross">Simulink.DataType object ''{0}'' is not in scope from ''{1}''. 
        &lt;actions exclusiveFixIts="yes"&gt;
            &lt;action type="fixit"&gt;
                &lt;cmd&gt;feval(''Simulink.createHitCrossMessage'');&lt;/cmd&gt;
                &lt;txt&gt;In the MATLAB Command Window, run 'Simulink.createHitCrossMessage' to create a hit crossing message bus object in the base workspace.&lt;/txt&gt;
            &lt;/action&gt;
        &lt;/actions&gt;
    </entry>
    <entry key="DataTypePropertiesNotSet">''{0}'' cannot get the properties of data type ''{1}'' since they have not been set</entry>
    <entry key="DataTypeSizeHasNotBeenSet">Size of data type ''{0}'' has not been set</entry>
    <entry key="DataType_InvalidHeaderFile">The data type must specify a HeaderFile property that has no delimiters (''\'' will be implied), or matching delimiters</entry>
    <entry key="DataType_ErrNonAsciiPropertyValue"> Invalid value ''{0}'' for property ''{1}'' because this property only supports ascii characters.</entry>
    <entry key="DataType_InvalidCharsInHeaderFileName">다음 문자가 지원되지 않아 속성 ''HeaderFile''에 대한 값 ''{0}''이(가) 유효하지 않습니다: ''*?"&lt;&gt;|''.</entry>
    <entry key="DataType_WithIntrinsicFixptName">Invalid name ''{0}'' for data type object; you cannot specify the names of data type objects as "int", "uint", "sfix", "ufix", or "flt" followed by a numeric value since this format is reserved for built-in and intrinsic fixed point types. For example, instead of specifying a data type object with the name 'uint33', you can set the name of the object to 'uint33_T'. </entry>
    <entry key="DefaultDataTypeMethodInRightClickBuild">서브시스템 ''{0}'' 내부에 있는 블록들의 데이터형이 과소 지정되었습니다. Simulink는 이러한 블록의 데이터형을 선택하는 데 발견법(Heuristic)을 사용하고 있습니다. 이로 인해 ''서브시스템 빌드''를 사용하여 이 서브시스템에 대해 생성된 코드의 동작과 전체 모델의 동작 사이에 불일치가 발생할 수 있습니다. 관련 블록의 목록을 보려면 구성 파라미터 대화 상자에서 ''진단'' 탭의 ''데이터 유효성'' 그룹에 지정된 ''과소 지정된 데이터형'' 파라미터를 ''경고'' 또는 ''오류''로 설정해 보십시오.</entry>
    <entry key="DefaultDataTypeMethodUsedAtPort">이 모델의 일부 신호에 대한 데이터형이 과소 지정되었습니다. Simulink는 이러한 데이터형을 선택하는 데 발견법(Heuristics)을 사용하고 있습니다. 발견법은 대부분의 경우에 타당한 선택지를 제공합니다. Signal Specification 블록 또는 Signal 객체를 사용하여 신호의 데이터형을 설정하면 발견법 사용을 피할 수 있습니다. 과소 지정된 데이터형을 갖는 신호 목록은 다음과 같습니다:</entry>
    <entry key="DefaultDataTypeMethodUsedAtOutPortBlk">과소 지정된 데이터형을 갖는 신호: ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;.</entry>
    <entry key="DefaultDataTypeMethodUsedAtInPortBlk">과소 지정된 데이터형을 갖는 신호: ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;.</entry>
    <entry key="DworkNamesMustBeUnique">Data type work vector names must be unique.  Data type work {0,number,integer} and {1,number,integer} of ''{2}'' have the same name ''{3}''</entry>
    <entry key="EnablePortsMustHaveIsPositiveRegistered">The enable signal of ''{0}'' may not be of data type ''{1}'' because that type has no positive function registered</entry>
    <entry key="TrigPortsDataTypeNeedRepresentZero">The trigger signal of ''{0}'' may not be of data type ''{1}'' because that type can't represent zero</entry>
    <entry key="EnablePortsDataTypeNeedRepresentZero">The enable signal of ''{0}'' may not be of data type ''{1}'' because that type can't represent zero</entry>
    <entry key="EnumTypeInvalidClass">열거형 데이터형 ''{0}''을(를) 등록할 수 없습니다.</entry>
    <entry key="EnumTypeInvalidClassWithBlock">''{0}'' cannot register enumerated data type ''{1}''.</entry>
    <entry key="EnumTypeInvalidIndex">''{0}'' attempts to access enumerated value with index {1,number,integer} from enumerated data type ''{2}''. This data type has {3,number,integer} enumerated values so the index must be in the range 0:{4,number,integer}</entry>
    <entry key="EnumTypeInvalidValue">''{0}'' attempts to access enumerated value with underlying value {1,number,integer} from enumerated data type ''{2}'' but this data type does not have an enumerated value with this underlying value</entry>
    <entry key="EnumTypeOverflowDuringConversion">Overflow occurred in ''{0}'' during the conversion from data type ''{1}'' to enumerated data type ''{2}''</entry>
    <entry key="EnumTypePrecisionLossDuringConversion">Loss of precision occurred in ''{0}'' during the conversion from data type ''{1}'' to enumerated data type ''{2}''</entry>
    <entry key="EnumTypeValuesDoNotFitIntoProdTargetInt">''{0}'' cannot register enumerated data type ''{1}'' because its underlying values do not fit into the integer type on the production target hardware ({2,number,integer} bits).</entry>
    <entry key="EnumTypeValuesDoNotFitIntoTargetInt">''{0}'' cannot register enumerated data type ''{1}'' because its underlying values do not fit into the integer type on the current target hardware ({2,number,integer} bits).</entry>
    <entry key="EnumTypeNotAClass">Cannot register enumerated data type because value specified is not a class.</entry>
    <entry key="EnumTypeNotAClassWithName">Cannot register enumerated data type ''{0}'' because there is no class with this name.</entry>
    <entry key="EnumTypeNotAnEnumerationClass">유효한 열거형 클래스가 아니기 때문에 열거형 데이터형 ''{0}''을(를) 등록할 수 없습니다.</entry>
    <entry key="EnumTypeWithInvalidSuperclass">유효하지 않은 슈퍼클래스를 갖기 때문에 열거형 데이터형 ''{0}''을(를) 등록할 수 없습니다.</entry>
    <entry key="EnumTypeWithMultipleInheritance">여러 개의 슈퍼클래스를 갖기 때문에 열거형 데이터형 ''{0}''을(를) 등록할 수 없습니다.</entry>
    <entry key="EnumTypeInsidePackage">열거형 데이터형 ''{0}''이(가) Simulink.IntEnumType을 확장하지 않으므로 이 데이터형을 네임스페이스 내에 등록할 수 없습니다.</entry>
    <entry key="EnumTypeWithComplexValues">복소수 값이 있는 열거형 데이터형 ''{0}''을(를) 등록할 수 없습니다.</entry>
    <entry key="EnumTypeWithInvalidIntValues">2^31보다 크거나 같은 열거형 값을 갖는 열거형 데이터형 ''{0}''을(를) 등록할 수 없습니다.</entry>
    <entry key="EnumTypeWithNoEnumStrings">열거형 값이 없는 열거형 데이터형 ''{0}''을(를) 등록할 수 없습니다.</entry>
    <entry key="EnumType_ReturnArgumentMustBeAString">Static method {0} must return a character vector</entry>
    <entry key="EnumType_ReturnArgumentMustBeBoolean">Static method {0} must return a scalar logical number (true/false)</entry>
    <entry key="GetEnumTypeInfoArg1">입력 인수 1은 유효한 열거형 데이터형의 이름이어야 함</entry>
    <entry key="GetEnumTypeInfoArg2">입력 인수 2는 유효한 속성 이름({0})이어야 함</entry>
    <entry key="EnumType_CannotHandleNamespaceOverride">메서드 "generatedCodeIdentifier"로 인해 열거형 ''{0}''의 정의를 사용할 수 없습니다</entry>
    <entry key="EnumTypeCannotRetrieveProperty">''{0}''에 대한 값을 검색하는 중 오류가 발생했습니다.</entry>
    <entry key="EnumType_SameNameAsExistingType">Cannot register enumerated data type ''{0}'' because another type with this name already exists</entry>
    <entry key="EnumType_SameNameAsExistingTypeWithBlock">이 이름을 가진 다른 유형이 이미 있기 때문에 ''{1}''에 열거형 데이터형 ''{0}''을(를) 등록할 수 없습니다.</entry>
    <entry key="EnumType_SameNameAsWorkspaceVar">Cannot register enumerated data type ''{0}'' because there is a global variable with the same name as this type</entry>
    <entry key="EnumType_SameNameAsWorkspaceVarWithBlock">Cannot register enumerated data type ''{0}'' for ''{1}'' because there is a global variable with the same name as this type</entry>
    <entry key="EnumType_SameNameAsAnyOtherWorkspaceVar">Failed to register enumerated data type ''{0}'' because a variable with the same name exists in the ''{1}''</entry>
    <entry key="EnumType_SameNameAsAnyOtherWorkspaceVarWithBlock">Failed to register enumerated data type ''{0}'' for block ''{1}'' because a variable with the same name exists in the ''{2}''</entry>
    <entry key="EnumType_ValuesDoNotFitIntoStorageType">''{0}'' cannot register enumerated data type ''{1}'' because its underlying values do not fit into the storage type ''{2}''.</entry>
    <entry key="EnumType_InvalidValueForSort">Sort only supports 2-dimensional matrices for distinct enumerations with duplicate underlying values.</entry>
    <entry key="DynamicEnum_CannotConvertFromOtherClass">Cannot convert objects of class ''{0}'' to enumeration class ''{1}''</entry>
    <entry key="DynamicEnum_InvalidNumericValue">The input array could not be converted to the ''{0}'' enumeration class because not all elements match the underlying values of the enumerated list</entry>
    <entry key="DynamicEnum_DuplicateAttributeDefinition">Cannot specify ''{0}'' more than once</entry>
    <entry key="DynamicEnum_DuplicateEnumUsage">열거형 ''{1}'' 및 ''{2}''이(가) 동일한 멤버 식별자 ''{0}''을(를) 사용합니다. 'EnumMemberNameClash'가 ''{3}''(으)로 설정된 경우에도 이 설정은 값이 동일하고 타깃에 독립적인 데이터형의 가져온 유형에만 적용됩니다</entry>
    <entry key="DynamicEnum_EmptyDescription">Cannot specify empty description</entry>
    <entry key="DynamicEnum_EmptyHeaderFile">Cannot specify empty header file</entry>
    <entry key="DynamicEnum_EmptyCppNamespace">빈 CppNamespace를 지정할 수 없음</entry>
    <entry key="DynamicEnum_InvalidDefaultValue">디폴트 값이 어떤 열거형 이름과도 일치하지 않음</entry>
    <entry key="DynamicEnum_InvalidStorageType">저장공간 유형이 Simulink의 내장 정수형의 이름이 아님</entry>
    <entry key="DynamicEnum_NotEnoughInputs">입력 인수가 부족합니다. 최소 3개의 입력값을 제공해야 합니다</entry>
    <entry key="DynamicEnum_MismatchInPVPairs">입력 인수의 개수가 올바르지 않음</entry>
    <entry key="DynamicEnum_InvalidClassName">Invalid name for enumeration class ''{0}''</entry>
    <entry key="DynamicEnum_EmptyEnumStrings">No enumeration names specified</entry>
    <entry key="DynamicEnum_MismatchInNumberOfValues">기본 숫자형 값의 개수({0,number,integer})가 열거형 이름의 개수({1,number,integer})와 일치하지 않음</entry>
    <entry key="DynamicEnum_EnumValuesNotInteger">기본 숫자형 값은 2^31보다 작은 실수형 스칼라 정수여야 합니다.</entry>
    <entry key="DynamicEnum_EnumValuesOutOfRange">Underlying numeric values do not fit into the specified StorageType</entry>
    <entry key="DynamicEnum_EnumValuesComplexOrSparse">Underlying numeric values cannot be complex or sparse</entry>
    <entry key="DynamicEnum_SecondArgMustBeCellOfStrings">Second argument must be a cell array of character vectors, where each character vector is a valid enumeration name</entry>
    <entry key="DynamicEnum_InvalidEnumString">이름 ''{0}''이(가) 유효한 MATLAB 식별자가 아니기 때문에 이 이름으로 열거형을 정의할 수 없음</entry>
    <entry key="DynamicEnum_DuplicateEnumString">동일한 이름 ''{0}''(으)로 두 번 이상 열거형을 정의할 수 없음</entry>
    <entry key="DynamicEnum_AttributeNameMustBeString">Input argument {0,number,integer} must be a character vector</entry>
    <entry key="DynamicEnum_AttributeValueMustBeString">Value of ''{0}'' must be specified as a character vector</entry>
    <entry key="DynamicEnum_AttributeValueMustBeLogical">Value of ''{0}'' must be specified as a logical scalar</entry>
    <entry key="UnsupportedDataScopeForIsTunableInCode">To set 'IsTunableInCode' to true for enumeration type ''{0}'', 'DataScope' must be 'Imported' or 'Auto' and 'HeaderFile' must be specified. </entry>
    <entry key="TunableEnumWithDuplicateValues">열거형 ''{0}''에 중복되거나 유효하지 않은 값이 있고 ''IsTunableInCode''가 true로 설정되었으므로 코드 생성이 지원되지 않음</entry>
    <entry key="InvalidTunableEnumSimImportDefn">모델 ''{0}''에 열거형 ''{1}''이(가) 있고 ''IsTunableInCode'' 속성이 ''true'''로 설정되고 구성 파라미터 ''SimGenImportedTypeDefs''가 ''off''로 설정되었기 때문에, 시뮬레이션과 코드 생성이 지원되지 않습니다</entry>
    <entry key="DynamicEnum_InvalidAttributeName">Invalid attribute for enumeration class ''{0}''</entry>
    <entry key="DynamicEnum_CannotClearClass">클래스 ''{0}''의 인스턴스가 아직 존재하기 때문에 이 클래스를 지울 수 없습니다.</entry>
    <entry key="DynamicEnum_CannotClearClassCreatedByDictionary">Cannot clear enumeration class ''{0}'' because it was defined by a data dictionary.</entry>
    <entry key="DynamicEnum_CannotClearClassCreatedByStateflow">Stateflow에 의해 정의되었기 때문에 열거형 클래스 ''{0}''을(를) 지울 수 없습니다.</entry>
    <entry key="DynamicEnum_CannotClearClassCreatedByMask">Simulink Mask에 의해 정의되었기 때문에 열거형 클래스 ''{0}''을(를) 지울 수 없습니다.</entry>
    <entry key="DynamicEnum_CannotClearClassCreatedBySllogging">Simulink Logging에 의해 정의되었기 때문에 열거형 클래스 ''{0}''을(를) 지울 수 없습니다.</entry>
    <entry key="DynamicEnum_CannotRedefineClassCreatedByDictionary">동일한 이름을 가진 열거형 클래스를 다른 데이터 사전으로 불러왔기 때문에 열거형 클래스 ''{0}''을(를) 정의할 수 없습니다. 기존 데이터 사전에 연결된 Simulink 모델을 닫거나 명령 ''Simulink.data.dictionary.closeAll''을 실행하십시오.</entry>
    <entry key="DynamicEnum_CannotRedefineClassCreatedByMask">Cannot define enumeration class ''{0}'' because it was previously defined by a Simulink Mask.</entry>
    <entry key="DynamicEnum_CannotRedefineClassCreatedByStateflow">Cannot define enumeration class ''{0}'' because it was previously defined by Stateflow.  To manually clear the class, type:\nSimulink.clearIntEnumType(''{0}'')</entry>
    <entry key="DynamicEnum_CannotRedefineClass">Cannot define enumeration class ''{0}'' because it was previously defined.</entry>
    <entry key="DynamicEnum_DictionaryCannotClearClass">Dictionary cannot define enumeration class ''{0}'' because it already exists.  Use Simulink.clearIntEnumType to clear the existing class.</entry>
    <entry key="DynamicEnum_StateflowCannotClearClass">Stateflow cannot define enumeration class ''{0}'' because it already exists.  Use Simulink.clearIntEnumType to clear the existing class.</entry>
    <entry key="DynamicEnum_NowNotOwnedByDictionary">Cannot clear enumeration class ''{0}'' because instances of the class still exist.  Class is no longer owned by a data dictionary.</entry>
    <entry key="DynamicEnum_NowNotOwnedByStateflow">열거형 클래스 ''{0}''의 인스턴스가 아직 존재하기 때문에 이 클래스를 지울 수 없습니다. Stateflow가 클래스를 더 이상 소유하지 않습니다.</entry>
    <entry key="DynamicEnum_NowNotOwnedByMask">열거형 클래스 ''{0}''의 인스턴스가 아직 존재하기 때문에 이 클래스를 지울 수 없습니다. Simulink Mask가 클래스를 더 이상 소유하지 않습니다.</entry>
    <entry key="DynamicEnum_NowNotOwnedBySllogging">열거형 클래스 ''{0}''의 인스턴스가 아직 존재하기 때문에 이 클래스를 지울 수 없습니다. Simulink Logging이 클래스를 더 이상 소유하지 않습니다.</entry>
    <entry key="DynamicEnum_CannotModifyStorageType">기존 클래스 ''{0}''의 저장공간 유형을 수정할 수 없음</entry>
    <entry key="DynamicEnum_TypeNotAClass">''{0}'' 클래스가 존재하지 않습니다.</entry>
    <entry key="DynamicEnum_TypeNotAnEnumerationClass">Cannot clear class ''{0}'' because it is not a valid enumeration class.</entry>
    <entry key="ErrOverFlowDetected">Overflow condition has been detected at time {0} in ''{1}''&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="ErrSaturationOccurred">Saturation has occurred at time {0} in ''{1}''&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="ErrorDownCastOfInterfacedVar">''{1}''의 파라미터 {0}을(를) 데이터형 ''{2}''에서 데이터형 ''{3}''(으)로 형변환하는 중입니다. 시뮬레이션과 생성 코드 간에 일관된 동작을 보장하기 위해, 조정 가능형 파라미터 표현식을 내림 형변환하거나 부호 여부가 불일치하는 것은 허용되지 않습니다&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="FixedPointLicenseFailDt">''{0}''은(는) ''{1}''의 데이터형을 지정합니다. 이 데이터형을 사용하려면 &lt;a href="matlab:web('https://www.mathworks.com/products/fixed-point-designer.html')"&gt;Fixed-Point Designer&lt;/a&gt; 라이선스가 필요한데 라이선스 체크아웃에 실패했습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="DTO"&gt; &lt;cmd&gt;fxptui.removeFixptUsageFromModel(gcs)&lt;/cmd&gt; &lt;txt&gt;모델에서 데이터형을 double형으로 재정의하려면 "수정"을 클릭하십시오.\n모델이 여전히 고정소수점 데이터형을 사용하는 경우 부동소수점 유형을 사용하도록 모델을 다시 구성해야 할 수 있습니다. 자세한 내용은 &lt;a href="matlab:helpview(fullfile(docroot,'fixedpoint','fixedpoint.map'), 'dto_nolicense')"&gt;문서&lt;/a&gt;를 참조하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="FixedPointLicenseFailLog">''{0}'' requested logging of min, max or overflow. Logging requires a &lt;a href="matlab:web('https://www.mathworks.com/products/fixed-point-designer.html')"&gt;Fixed-Point Designer&lt;/a&gt;, but license checkout failed.
        &lt;actions exclusiveFixIts="yes"&gt;
            &lt;action type="fixit"&gt;
                &lt;cmd&gt;fxptui.removeMMOFromModel(gcs)&lt;/cmd&gt;
                &lt;txt&gt;Turn off fixed-point instrumentation.&lt;/txt&gt;
            &lt;/action&gt;
        &lt;/actions&gt;
    </entry>
    <entry key="CVTLicenseFailDt">''{0}''은(는) ''{1}''의 데이터형을 지정합니다. 이 데이터형을 사용하려면 &lt;a href="matlab:web('https://www.mathworks.com/products/computer-vision.html')"&gt;Computer Vision Toolbox&lt;/a&gt; 라이선스가 필요한데 라이선스 체크아웃에 실패했습니다&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="HDLFloatTypecastInvInputPortDataType">Invalid data type ''{0}'' specified for ''{1}'' on the input. Only half, single, double, uint16, uint32 and uint64 data types are supported.</entry>
    <entry key="HDLBitSliceIdxRangeError">Invalid slice index specified for ''{0}'' on the input. MSB and LSB positions must be less than or equal to the word length of the input data type.</entry>
    <entry key="HDLBitSliceIdxValueError">Invalid slice index specified for ''{0}'' on the input. MSB position must be greater than or equal to LSB position.</entry>
    <entry key="HDLBitSliceInvInputPortDataType">입력에서 ''{1}''에 대해 지정된 데이터형 ''{0}''이(가) 유효하지 않습니다. 정수 데이터형, 부울 데이터형 또는 고정소수점 데이터형만 지원됩니다.</entry>
    <entry key="HDLBitSliceFixptSlopeBiasError">Invalid data type ''{0}'' specified for ''{1}'' on the input. Fixed-point input types should have slope in powers of 2 and zero bias.</entry>
    <entry key="ImportedTypeWithNoHeader">''{0}'' has DataScope set to ''Imported'' and no header file specified. A header file must be specified for ''Imported'' data types.</entry>
    <entry key="InitComplexFlagOfBoolDTypeError">부울 신호는 복소수일 수 없습니다.</entry>
    <entry key="InitComplexFlagOfOpaqueDTypeError">사용자 지정 신호는 복소수일 수 없습니다.</entry>
    <entry key="InitComplexFlagOfStructDTypeError">구조체 신호는 복소수일 수 없습니다.</entry>
    <entry key="InitComplexSignalError">An error occurred while initializing a signal''s numeric type (real or complex)</entry>
    <entry key="InitDataTypeError">An error occurred while initializing a signal''s data type</entry>
    <entry key="InputMustBeBoolOrDbl">Cannot set the input port data type of ''{0}'' to ''{1}''.  The input port data type must be either ''double'' or ''boolean''.  Signals of other data types can be converted to ''double'' or ''boolean'' by using a Data Type Conversion</entry>
    <entry key="InputMustBeIntegerForConvertToEnumType">''{0}''이(가) 데이터형 ''{1}''의 신호를 열거형 데이터형 ''{2}''(으)로 변환할 수 없습니다. 입력 신호의 데이터형은 정수형이어야 합니다</entry>
    <entry key="InputPortCannotAcceptMixedDataType">입력 포트는 혼합 데이터형을 받을 수 없습니다. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;''{1}''의 {0,number,integer}번 입력 포트&lt;/sldiag&gt;에는 고유한 데이터형을 가진 신호가 필요합니다. 하지만 이 입력 포트는 서로 다른 데이터형의 요소를 가진 신호로 구동됩니다.</entry>
    <entry key="InputPortCannotAcceptMixedDataTypeVirtualBus">Outport 블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;는 고유한 데이터형을 가진 신호가 필요하지만 서로 다른 데이터형을 갖는 요소들이 포함된 가상 버스를 수신하고 있습니다. 서로 다른 데이터형의 요소를 갖는 가상 버스를 출력하려면 Out Bus Element 블록을 사용하십시오.</entry>
    <entry key="InputPortCannotAcceptMixedDataTypeForVSSWithHint">The inport block ''{0}'' cannot accept a signal with elements of differing data types. This can be usually fixed by inserting a Signal Conversion block with the ''Signal copy'' option selected, inside the choice blocks of ''{1}''.</entry>
    <entry key="InputPortCannotAcceptMixedDataTypeWithHint">The inport block ''{0}'' is directly connected to outport ''{1}'' and therefore cannot accept a signal with elements of differing data types. This can be usually fixed by inserting a Signal Conversion block with the ''Signal copy'' option selected, at the output of the inport block ''{0}''. Alternatively, if this input port is within a function-call subsystem, consider checking the ''Latch input for feedback signals of function-call subsystem outputs'' option.</entry>
    <entry key="InputPortCannotAcceptMixedDataTypeWithHint_Feedback">Input port cannot accept mixed data types. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' expects a signal with unique data type. However, it is driven by a signal with elements of differing data types. If this input port is within a function-call subsystem, consider checking the ''Latch input for feedback signals of function-call subsystem outputs'' option. Otherwise, insert a Signal Conversion block with the ''Signal copy'' option selected, at the output of block ''{2}''. </entry>
    <entry key="InputPortCannotAcceptMixedSignal">Input port cannot accept mixed numeric types. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' expects a real or complex signal. However, it is driven by a signal that includes both real and complex elements</entry>
    <entry key="InputPortCannotAcceptMixedSignalWithHint">Input port cannot accept mixed numeric types. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' expects a real or complex signal. However, it is driven by a signal that includes both real and complex elements. This can be usually fixed by inserting a Signal Conversion block with the ''Signal copy'' option selected, at the output of block ''{2}''.  Alternatively, if this input port is within a function-call subsystem, consider checking the ''Latch input for feedback signals of function-call subsystem outputs'' option.</entry>
    <entry key="InputPortComplexSignalMismatch">복소 신호가 일치하지 않습니다. ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에는 {2} 신호가 필요합니다. 하지만 이 입력 포트는 {3} 신호로 구동됩니다</entry>
    <entry key="InputPortDataTypeMismatch">데이터형이 일치하지 않습니다. ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에는 {2} 신호가 필요합니다. 하지만 이 입력 포트는 {3} 신호로 구동됩니다.</entry>
    <entry key="InvBoolPortDType">{0} does not accept ''boolean'' signals. The input signal(s) of ''{1}'' must be ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', or ''double''</entry>
    <entry key="InvBuiltinPortDType">{0}은(는) 데이터형이 ''{1}''인 신호를 허용하지 않습니다. ''{2}''은(는) ''boolean'', ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', ''double'' 데이터형만 허용합니다.</entry>
    <entry key="InvDataConstructForParameter">The parameter {0} of ''{1}'' is not being successfully constructed</entry>
    <entry key="InvConvertBetweenForParameter">The parameter {0} of ''{1}'' is not being successfully converted from type ''{2}'' to ''{3}''{4}{5}</entry>
    <entry key="InvConvertBetweenForPortDType">''{0}''의 입력 신호 유형이 ''{1}''에서 ''{2}''{3}{4}(으)로 변환되지 않습니다</entry>
    <entry key="InvConvertBetweenForTriggerPortDType">The trigger signal of ''{0}'' is not being successfully converted from data type ''{1}'' to ''{2}''</entry>
    <entry key="InvDWorkBooleanComplexDwork">Boolean dworks cannot be complex. Dwork index {0,number,integer} of ''{1}'' is a ''boolean'' dwork. It cannot be complex</entry>
    <entry key="InvDWorkEnumTypeComplexDwork">Enumerated dworks cannot be complex. Dwork index {0,number,integer} of ''{1}'' is a dwork with enumerated data type ''{2}''. It cannot be complex</entry>
    <entry key="InvDWorkOpaqueComplexDwork">Custom dworks cannot be complex. Dwork index {0,number,integer} of ''{1}'' is a dwork with data type ''{2}''. It cannot be complex</entry>
    <entry key="InvDWorkStructComplexDwork">Struct dworks cannot be complex. Dwork index {0,number,integer} of ''{1}'' is a dwork with data type ''{2}''. It cannot be complex</entry>
    <entry key="InvDisagreeInternalRuleDType">데이터형이 일치하지 않습니다. 내부 규칙에 따라 ''{0}''의 출력이 데이터형이 ''{1}''인 신호로 확인됩니다. 그러나 이 출력은 데이터형이 ''{2}''인 신호를 구동하는 중입니다.</entry>
    <entry key="InvFixptAndBuiltinPortDType">{0}은(는) 데이터형이 ''{1}''인 신호를 허용하지 않습니다. ''{2}''은(는) ''boolean'', ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', ''double'', 고정소수점 데이터형만 허용합니다.</entry>
    <entry key="InvFixptBoolOutPortDType">{0}은(는) 출력 포트에서 ''boolean'' 신호를 허용하지 않습니다. ''{1}''의 출력 신호는 ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', ''double'' 데이터형이거나 고정소수점 데이터형 중 하나여야 합니다</entry>
    <entry key="InvFixptBoolOutputPortDType">Output port(s) of {0} does not accept ''boolean'' signals. The output signal(s) of ''{1}'' must be ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', or ''double'', or one of the fixed-point data types</entry>
    <entry key="InvFixptBoolPortDType">{0} does not accept ''boolean'' signals. The input and output signal(s) of ''{1}'' must be ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', ''double'', or one of the fixed-point data types</entry>
    <entry key="InvInputBooleanComplexSignal">Boolean signals cannot be complex. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a ''boolean'' signal. It cannot be complex</entry>
    <entry key="InvInputHalfComplexSignal">Half-precision signals cannot be complex. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a ''half-precision'' signal. It cannot be complex</entry>
    <entry key="InvInputEnumTypeComplexSignal">Enumerated signals cannot be complex. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a signal with enumerated data type ''{2}''. It cannot be complex</entry>
    <entry key="InvInputFixptComplexSignal">&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a fixed-point signal of data type ''{2}'' with non-zero bias or slope that is not a power of 2. The signal cannot be complex</entry>
    <entry key="InvInputOpaqueComplexSignal">사용자 지정 신호는 복소수일 수 없습니다. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;''{1}''의 {0,number,integer}번 입력 포트&lt;/sldiag&gt;는 데이터형이 ''{2}''인 신호입니다. 이 신호는 코드 생성 시 복소수일 수 없습니다.</entry>
    <entry key="InvInputPortComplexSignalSetting">Input port complex signal mismatch.  &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' expects a {2} signal. Based on the output port complex signal, the input port must be a {3} signal</entry>
    <entry key="InvInputPortDType">{0}의 입력 포트 데이터형이 MATLAB 데이터형 중 하나여야 합니다. 하지만 ''{1}''의 입력 포트는 ''{2}'' 데이터형 신호에 의해 구동됩니다</entry>
    <entry key="InvInputPortDTypeNotSupported">The input port of {0} does not support the data type ''{1}''. However, the input port of ''{2}'' is driven by a signal of this data type</entry>
    <entry key="InvInputPortDataType">Invalid data type ''{0}'' specified for ''{1}'' input port {2,number,integer}</entry>
    <entry key="InvInputStructComplexSignal">Struct signals cannot be complex. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a signal with data type ''{2}''. It cannot be complex</entry>
    <entry key="InvIsPositiveForEnablePortDType">The enable port signal of ''{0}'' is not being successfully processed by the positive function registered for data type ''{1}''</entry>
    <entry key="InvMPSwtControlPortOutOfBounds">''{0}''에 범위를 벗어나는 스위치 입력이 지정되었습니다. 1부터 시작하는 인덱싱을 사용하는 경우 제어 입력은 1보다 크거나 같고 입력 수보다 작거나 같아야 합니다. 0부터 시작하는 인덱싱을 사용하는 경우 제어 입력은 0보다 크거나 같고 입력 수보다 작아야 합니다.</entry>
    <entry key="InvMPSwtPortDataTypes">데이터형이 일치하지 않습니다. ''{0}''의 입력 포트의 상위(Dominant) 데이터형은 ''{1}''입니다. 하지만, 출력 포트의 데이터형은 ''{2}''입니다. 두 데이터형이 일치해야 합니다</entry>
    <entry key="InvNonDoublePortDType">블록 유형 {0}에는 ''double''형 신호만 허용됩니다. ''{1}''의 포트에 있는 신호는 데이터형이 ''{2}''입니다.</entry>
    <entry key="InvNonFloatPortDType">Only ''single'' or ''double'' signals are accepted by block type {0}.  The signals at the ports of ''{1}'' are of data type ''{2}''.</entry>
    <entry key="InvOPortDTypeChooseIntrinsic">''{0}''은(는) 출력 포트 데이터형을 ''{1}''(으)로 설정할 수 없습니다. 이 문제가 발생하지 않도록 하는 한 가지 방법은 내재 출력 데이터형을 명시적으로 선택하는 것입니다.</entry>
    <entry key="InvOutputBooleanComplexSignal">Boolean signals cannot be complex. &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a ''boolean'' signal. It cannot be complex</entry>
    <entry key="InvOutputHalfComplexSignal">Half-precision signals cannot be complex. &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a ''half-precision'' signal. It cannot be complex</entry>
    <entry key="InvOutputEnumTypeComplexSignal">Enumerated signals cannot be complex. &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a signal with enumerated data type ''{2}''. It cannot be complex</entry>
    <entry key="InvOutputFixptComplexSignal">&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a fixed-point signal of data type ''{2}'' with non-zero bias or slope that is not a power of 2. The signal cannot be complex</entry>
    <entry key="InvOutputOpaqueComplexSignal">사용자 지정 신호는 복소수일 수 없습니다. &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;''{1}''의 {0,number,integer}번 출력 포트&lt;/sldiag&gt;는 데이터형이 ''{2}''인 신호입니다. 이 신호는 코드 생성 시 복소수일 수 없습니다.</entry>
    <entry key="InvOutputPortComplexSignalSetting">Output port complex signal mismatch.  &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a {2} signal. Based on the input port complex signal, the output port must be a {3} signal</entry>
    <entry key="InvOutputPortDTypeNotSupported">The output port of {0} does not support the data type ''{1}''. However, the output port of ''{2}'' is driven by a signal of this data type</entry>
    <entry key="InvOutputPortDataType">Invalid data type ''{0}'' specified for ''{1}'' output port {2,number,integer}</entry>
    <entry key="InvOutputStructComplexSignal">Struct signals cannot be complex. &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a signal with data type ''{2}''. It cannot be complex</entry>
    <entry key="InvPortDType">''{0}'' does not support signals of data type ''{1}''. {2} supports only ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', or ''double'' built-in data types</entry>
    <entry key="InvPortDTypeFunctionName">Signals of type ''{0}'' are not supported by ''{1}'' block. {2} supports only data types of ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', ''double'', or ''half''</entry>
    <entry key="InvPortDTypeSupport">Invalid {0} port data type ''{1}'' in ''{2}''. The data type must be ''boolean'', ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', ''double'', or one of the fixed-point data types</entry>
    <entry key="InvPortDTypeWithoutConvertBetween">유형 ''{1}''에는 등록된 유형 변환 함수가 없으므로 ''{0}''의 입력 신호는 이 유형이 아닐 수 있습니다</entry>
    <entry key="InvalidDataType">''{1}''에 의해 지정된 데이터형 ''{0}''이(가) 유효한 식별자가 아닙니다</entry>
    <entry key="InvalidDataTypeElementIndex">''{0}''이(가) 데이터형 id {2,number,integer}에 유효하지 않은 요소 인덱스 {1,number,integer}을(를) 사용하려고 합니다</entry>
    <entry key="InvalidDataTypeId">''{0}''이(가) 유효하지 않은 데이터형 id {1,number,integer}을(를) 사용하려고 합니다</entry>
    <entry key="InvalidDataTypeNumElements">다음 오류로 인해 ''{1}''에 대해 데이터형 ''{0}''을(를) 등록할 수 없습니다. 이 데이터형의 경우 요소 개수가 0보다 커야 합니다.</entry>
    <entry key="InvalidTypeNumElements">Unable to register type ''{0}'' for ''{1}'' due to the following error: The number of elements must be greater than zero for this type.</entry>
    <entry key="InvalidInputPortComplexSignal">Invalid input port numeric type. Numeric type (real or complex) of &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is invalid</entry>
    <entry key="BuiltinDataTypeNameNotAllowed">Invalid bus object name ''{0}''. Bus object name must not be a built-in data type name or 'auto'.</entry>
    <entry key="InvalidInputPortDataType">Invalid input port data type. Data type of &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is invalid</entry>
    <entry key="InvalidOutputPortComplexSignal">Invalid output port numeric type. Numeric type (real or complex) of &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is invalid</entry>
    <entry key="InvalidOutputPortDataType">출력 포트 데이터형이 유효하지 않습니다. ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;의 데이터형이 유효하지 않습니다.</entry>
    <entry key="InvalidResetInputDataType">Cannot set the reset input port data type of ''{0}'' to ''{1}''. The reset input port data type must be ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', ''double'', ''boolean'', or ''ufix1''. Signals of other data types can be converted to these data types by using a Data Type Conversion block.</entry>
    <entry key="InvalidEnableInputDataType">Cannot set the enable input port data type of ''{0}'' to ''{1}''. The enable input port data type must be ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', ''double'', ''boolean'', or ''ufix1''. Signals of other data types can be converted to these data types by using a Data Type Conversion block.</entry>
    <entry key="LoggingNonBuiltInSignalNotSupported">내장 데이터형이 아닌 신호는 기록할 수 없습니다</entry>
    <entry key="MdlRefInputPortCannotAcceptMixedDataTypeWithHint">Input port cannot accept mixed data types. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of model block ''{1}'' expects a signal with unique data type. However, it is driven by a signal with elements of differing data types. This can be usually fixed by inserting a Signal Conversion block with the ''Signal copy'' option selected, at the output of Inport block {2,number,integer} of the referenced model. Alternatively, if this input port is within a function-call model, consider checking the ''Latch input for feedback signals of function-call subsystem outputs'' option.</entry>
    <entry key="MdlRefInputPortCannotAcceptMixedSignalWithHint">Input port cannot accept mixed numeric types. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of model block ''{1}'' expects a real or complex signal. However, it is driven by a signal that includes both real and complex elements. This can be usually fixed by inserting a Signal Conversion block with the ''Signal copy'' option selected, at the output of Inport block {2} of the referenced model.  Alternatively, if this input port is within a function-call model, consider checking the ''Latch input for feedback signals of function-call subsystem outputs'' option.</entry>
    <entry key="MustSpecifyAllOrNoneDWorkNames">Some of data type work vector names of ''{0}'' are not specified.  Either all or none of data type work vector names must be specified</entry>
    <entry key="NonSingleOrDoubleComplexSignal">Input port and output port of ''{0}'' must be of type ''single'' or ''double'' when complex</entry>
    <entry key="NumericType_CannotBeAlias">스케일링되지 않은 숫자형은 별칭 데이터형일 수 없습니다.</entry>
    <entry key="NumericType_DirectUseOfUnscaled">Invalid attempt to use the unscaled numeric type ''{0}'' directly as a data type</entry>
    <entry key="NumericType_DisableIsAlias">스케일링되지 않은 숫자형은 별칭 데이터형일 수 없습니다. 객체의 IsAlias 속성이 false로 설정됩니다.</entry>
    <entry key="NumericType_WarnForOldProperties">속성 ''{0}''은(는) 더 이상 사용되지 않으며 향후 릴리스에서 제거될 예정입니다. 대신 속성 ''{1}''을(를) 사용하도록 코드를 업데이트하십시오.</entry>
    <entry key="NumericType_WarnForOldProperties2">속성 ''{0}''은(는) 더 이상 사용되지 않으며 향후 릴리스에서 제거될 예정입니다. 대신 속성 ''{1}''을(를) 사용하도록 코드를 업데이트하십시오. MAT 파일을 불러오는 동안 이 경고를 받은 경우 MAT 파일을 다시 저장하십시오.</entry>
    <entry key="NumericType_WarnForOldMethods">메서드 ''{0}''은(는) 더 이상 사용되지 않으며 향후 릴리스에서 제거될 예정입니다. 대신 속성 ''{1}''을(를) 사용하도록 코드를 업데이트하십시오.</entry>
    <entry key="OpaqueType_Empty_HeaderFile">데이터형 객체 ''{0}''은(는) HeaderFile 속성을 지정해야 합니다.</entry>
    <entry key="OpaqueType_Invalid_Size">지정된 크기가 유효하지 않습니다. 크기는 0보다 커야 합니다.</entry>
    <entry key="ObjectInScopeNotBus">Variable or object ''{0}'' in scope from ''{1}'' is not a Simulink.Bus object</entry>
    <entry key="ObjectInScopeNotDataType">Variable or object ''{0}'' in scope from ''{1}'' is not a Simulink.DataType object</entry>
    <entry key="OutputMustBeBoolOrDbl">Cannot set the output port data type of ''{0}'' to ''{1}''.  The output port data type must be either ''double'' or ''boolean''</entry>
    <entry key="OutputMustBeInt8OrDbl">Cannot set the output port {0,number,integer} data type of ''{1}'' to ''{2}''.  The output port data type must be either ''double'' or ''int8''</entry>
    <entry key="OutputPortCannotAcceptMixedDataType">Output port cannot have mixed data types. &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' expects a signal with unique data type. However, it is driving a signal with elements of differing data types</entry>
    <entry key="OutputPortCannotAcceptMixedDataTypeWithHint">Output port cannot have mixed data types. &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' expects a signal with unique data type. However, it is driving a signal with elements of differing data types. This can be usually fixed by inserting a Signal Conversion block with the ''Signal copy'' option selected, at its output</entry>
    <entry key="OutputPortCannotAcceptMixedSignal">Output port cannot have mixed numeric types. &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' expects a real or complex signal. However, it is driving a signal that includes both real and complex elements</entry>
    <entry key="OutputPortCannotAcceptMixedSignalWithHint">Output port cannot have mixed numeric types. &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' expects a real or complex signal. However, it is driving a signal that includes both real and complex elements This can be usually fixed by inserting a Signal Conversion block with the ''Signal copy'' option selected, at its output</entry>
    <entry key="OutputPortComplexSignalMismatch">복소 신호가 일치하지 않습니다. ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;는 {2} 신호입니다. 그러나 이 출력 포트는 {3} 신호를 구동하는 중입니다</entry>
    <entry key="OutputPortDataTypeMismatch">데이터형이 일치하지 않습니다. ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;는 {2} 신호입니다. 그러나 이 출력 포트는 {3} 신호를 구동하는 중입니다.</entry>
    <entry key="StringParameterMustBeZero">Invalid value for parameter {0} of block ''{1}''. The incoming signal is either a string data type or a bus signal with at least one element that is a string data type. String data types must have 0 as an initial value.</entry>
    <entry key="ParameterMustBeZero">''{0}'' cannot specify a nonzero value for parameter {1}.  The parameter needs to be converted to the datatype ''{2}'', which does not have a datatype conversion function registered.  Register a datatype conversion function, or use the value zero</entry>
    <entry key="ParameterNoConversionOfEnums">열거형 데이터형을 갖는 파라미터의 변환은 지원되지 않기 때문에 ''{0}''은(는) 파라미터 {1}을(를) 데이터형 ''{2}''에서 데이터형 ''{3}''(으)로 변환할 수 없음</entry>
    <entry key="ParameterNoEmptyValueForTunableEnums">조정 가능한 열거형 ''{2}''을(를) 갖는 파라미터에는 빈 값이 지원되지 않으므로 ''{0}''은(는) ''[]''을 {1}의 값으로 지정할 수 없음</entry>
    <entry key="ParameterNoConversionOfTunableEnums">조정 가능한 열거형 데이터형을 갖는 파라미터의 변환은 지원되지 않기 때문에 ''{0}''은(는) 파라미터 {1}을(를) 데이터형 ''{2}''에서 데이터형 ''{3}''(으)로 변환할 수 없음</entry>
    <entry key="ParameterNoConversionOfStructTypes">''{0}'' cannot convert parameter {1} from data type ''{2}'' to data type ''{3}'' because conversion of parameters with struct data types is not supported</entry>
    <entry key="ParameterNoConversionOfStrings">string형과 string형 이외의 데이터형 간 변환이 지원되지 않으므로, ''{0}''에서는 파라미터 ''{1}''을(를) 데이터형 ''{2}''에서 데이터형 ''{3}''(으)로 변환하는 것이 지원되지 않습니다.</entry>
    <entry key="PortComplexSignalMismatch">Port complex signal mismatch.  If any input of {0} is a complex signal, then the output must be a complex signal.  The &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;input port {1,number,integer}&lt;/sldiag&gt; of ''{2}'' is a complex signal.  However, the output port is a real signal.</entry>
    <entry key="ProdHWPromotion">''{0}''은(는) 내부 규칙을 통해 출력 데이터형을 자동으로 선택하도록 구성되어 있습니다. 최소 {1,number,integer}비트의 정수 데이터형이 선택되었습니다. 프로덕션 하드웨어 특성에 따라 이 크기는 허용되지 않습니다. 프로덕션 하드웨어 특성을 변경하려면 모델의 시뮬레이션 메뉴에서 "구성 파라미터"를 선택한 다음 하드웨어 구현 페이지를 선택하십시오.</entry>
    <entry key="PropBackwardComplexSignalError">''{1}''의 &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{1}"&gt;{2,number,integer}번 입력 포트&lt;/sldiag&gt;에서 {0}을(를) 전파하는 중 오류가 발생했습니다.</entry>
    <entry key="PropBackwardDataTypeError">''{1}''의 &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{1}"&gt;{2,number,integer}번 입력 포트&lt;/sldiag&gt;에서 {0}을(를) 전파하는 중 오류가 발생했습니다.</entry>
    <entry key="PropForwardComplexSignalError">''{1}''의 &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{1}"&gt;{2,number,integer}번 출력 포트&lt;/sldiag&gt;에서 {0}을(를) 전파하는 중 오류가 발생했습니다.</entry>
    <entry key="PropForwardDataTypeError">''{1}''의 &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{1}"&gt;{2,number,integer}번 출력 포트&lt;/sldiag&gt;에서 {0}을(를) 전파하는 중 오류가 발생했습니다.</entry>
    <entry key="RealInputsComplexOutputErr">출력 포트의 복소 신호가 일치하지 않습니다. {0}의 모든 입력이 실수 신호이면 출력은 실수 신호여야 합니다. ''{1}''의 모든 입력이 실수 신호입니다. 하지만, 출력 포트는 복소 신호입니다</entry>
    <entry key="ReqInvalidDiagnostic">Block {0} requested an invalid diagnostic</entry>
    <entry key="ResetPortsMustBeBoolOrDbl">Cannot set the data type of &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' to ''{2}''. The reset signal of an integrator must be of type ''double'' or ''boolean''. Signals of other data types can be converted to ''double'' or ''boolean'' by using a Data Type Conversion</entry>
    <entry key="ServiceBusDoesNotEvalToBus">포트 {2}에는 Simulink.Bus 객체가 필요한데, 데이터형 ''{0}''은(는) 파라미터 ''{1}''에 대한 Simulink.ServiceBus로 연결이 맺어집니다. </entry>
    <entry key="SFcnInputPortComplexSignalHasNotBeenSet">Input port complex signal of S-function ''{0}'' has not been set properly</entry>
    <entry key="SFcnInputPortDataTypeHasNotBeenSet">Input port data type of S-function ''{0}'' has not been set properly</entry>
    <entry key="SFcnOutputPortComplexSignalHasNotBeenSet">Output port complex signal of S-function ''{0}'' has not been set properly</entry>
    <entry key="SFcnOutputPortDataTypeHasNotBeenSet">Output port data type of S-function ''{0}'' has not been set properly</entry>
    <entry key="SharedBusAliasedToAnonStruct">Simulink is mapping bus type ''{0}'' to structure type ''{1}'' (defined for a parameter structure). As a result, the bus type cannot be exported. Change the DataScope of the bus object from ''Exported'' to ''Auto''.</entry>
    <entry key="SignalAttribPropDataTypeMixed">혼합된 데이터형</entry>
    <entry key="SignalAttribPropDataTypeFullyKnown">데이터형 ''{0}''</entry>
    <entry key="SignalAttribPropDataTypePartiallyKnown">데이터형 '{'{0}, unknown'}'</entry>
    <entry key="SignalAttribPropNumericTypeMixed">혼합된 숫자형</entry>
    <entry key="SignalAttribPropNumericTypeFullyKnown">숫자형 {0}</entry>
    <entry key="SignalAttribPropDataNumericTypePartiallyKnown">숫자형 '{'{0}, unknown'}'</entry>
    <entry key="SignedOnlyPortDType">{0} does not accept ''boolean'' or ''unsigned'' signals. The input and output signal(s) of ''{1}'' must be ''int8'', ''int16'', ''int32'', ''single'', or ''double'', or one of the signed fixed-point data types</entry>
    <entry key="SpecificInvConvertBetweenForTriggerPortDType">''{0}''의 트리거 신호가 데이터형 ''{1}''에서 ''{2}''(으)로 변환되지 않았습니다. {3}</entry>
    <entry key="SpecificInvIsPositiveForEnablePortDType">The enable port signal of ''{0}'' is not being successfully processed by the positive function registered for data type ''{1}''; {2}</entry>
    <entry key="StructElementCannotBeComplexBoolean">Element ''{0}'' of data type ''{1}'' may not be of boolean data type ''{2}'' since that element is complex</entry>
    <entry key="StructElementCannotBeComplexOpaque">Element ''{0}'' of data type ''{1}'' may not be of custom data type ''{2}'' since that element is complex</entry>
    <entry key="StructElementCannotBeComplexStruct">Element ''{0}'' of data type ''{1}'' may not be of struct data type ''{2}'' since that element is complex</entry>
    <entry key="StructElementCannotBeComplexEnum">Element ''{0}'' of data type ''{1}'' may not be of enumerated data type ''{2}'' since that element is complex</entry>
    <entry key="StructElementCannotBeCustomOpaque">사용자 지정 요소는 버스에서 지원되지 않으므로 데이터형 ''{1}''의 요소 ''{0}''은(는) 사용자 지정 데이터형 ''{2}''일 수 없습니다.</entry>
    <entry key="StructElement_Invalid_DType">Invalid bus type specified for registration: non-numeric element(s) found.</entry>
    <entry key="StructElement_DataTypeEvalErr">Error evaluating DataType property.</entry>
    <entry key="StructElement_DataType_Auto">유효하지 않은 DataType이 지정되었습니다. DataType은 ''auto''로 설정할 수 없습니다</entry>
    <entry key="StructElement_Type_Empty">Invalid Type specified; Type may not be empty.</entry>
    <entry key="StructElement_DataType_FcnCall">Invalid DataType specified; function-call signals are not supported as data types on elements.</entry>
    <entry key="StructElement_DataType_Struct">Invalid DataType specified; ''struct'' is not supported as data type on elements.</entry>
    <entry key="StructElement_ErrResolvingDataType">Error resolving DataType ''{0}''</entry>
    <entry key="StructElement_ErrResolvingType">유형 ''{0}''을(를) 확인하는 중 오류가 발생함</entry>
    <entry key="StructElement_Invalid_Name">이름 ''{0}''은(는) 영문자 또는 '''' 문자로 시작한 다음 영숫자 또는 '''' 문자가 와야 합니다. 이름은 ''sl_padding''으로 시작해서는 안 됩니다.</entry>
    <entry key="StructElement_Invalid_NumDimensions">''차원''은 양의 요소로 구성된 double형 벡터여야 합니다. 2차원보다 큰 신호의 경우에는 후행 차원이 1이 아니어야 합니다.</entry>
    <entry key="StructElement_Invalid_NumDimensions_WithName">''{0}''의 ''차원''은 양의 요소로 구성된 double형 벡터여야 합니다. 2차원보다 큰 신호의 경우에는 후행 차원이 1이 아니어야 합니다.</entry>
    <entry key="StructElement_Invalid_ResolvedDataType">DataType ''{0}'' did not resolve to a valid data type</entry>
    <entry key="StructElement_Invalid_ResolvedDataType_Enum">DataType ''{0}'' did not resolve to a valid enumerated data type</entry>
    <entry key="StructElement_Invalid_ResolvedDataType_Unscaled">DataType ''{0}'' is invalid because it does not contain scaling information</entry>
    <entry key="StructType_Duplicate_Names">유효하지 않은 요소가 지정되었습니다. 요소는 고유한 이름을 가져야 합니다</entry>
    <entry key="StructType_Duplicate_Names2">Invalid Elements specified for data type ''{0}''; Elements must have unique names</entry>
    <entry key="StructType_Invalid_Elements">Invalid Elements specified; the Elements must be an empty array, or array of objects of the class Simulink.StructElement</entry>
    <entry key="StructParam_DifferentAttrib">Inconsistent field ''{0}'':\n Expected: {1}\n   Actual: {2}</entry>
    <entry key="StructParam_DifferentNamesOrder">Fields of structure ''{0}'' do not match:\n Expected fields:\n\t {1}\n   Actual fields:\n\t {2}</entry>
    <entry key="StructParam_ExtraNames">Fields of structure ''{0}'' do not match:\n   Extra fields:\n\t{1}\n Expected fields:\n\t{2}\n\n Actual fields:\n\t{3}</entry>
    <entry key="StructParam_MissedExtraNames">Fields of structure ''{0}'' do not match:\n Missing fields:\n\t{1}\n Extra fields:\n\t{2}\n Expected fields:\n\t{3}\n\n Actual fields:\n\t{4}</entry>
    <entry key="StructParam_MissedNames">Fields of structure ''{0}'' do not match:\n Missing fields:\n\t{1}\n Expected fields:\n\t{2}\n\n Actual fields:\n\t{3}</entry>
    <entry key="SwtDataTypeOutputDisagreeRule">An error occurred while the Simulink model was propagating data types. Data type propagation proposed that the Switch block ''{0}'' accept data type ''{1}'' for input port 1 and data type ''{2}'' for &lt;sldiag objui="inport" objparam="2" objname="{0}"&gt;input port 2&lt;/sldiag&gt;. This Switch block is configured to inherit its output data type via an internal rule which determined that the output data type should be ''{3}''.  However, the data type of the output signal had already been set to ''{4}''. There are several actions you can take to resolve this error. You can change the data type settings for the Switch block. Alternately, you can change the data type settings of the blocks connected to the Switch block''s inputs and/or outputs. You can also insert Data Type Conversion blocks or Signal Specification blocks on the Switch block''s input and/or output signals to resolve data type propagation errors</entry>
    <entry key="TowksCannotLogNonDblOrComplexInMatFormat">''{0}'' 데이터 기록에 ''matrix'' 형식이 사용됩니다. 비double형 신호 또는 복소 신호는 ''matrix'' 형식으로 기록할 수 없습니다. ''시간값을 갖는 구조체'' 또는 ''구조체'' 형식을 사용하십시오(파라미터 대화 상자에서 저장 형식 참조)</entry>
    <entry key="TriggerSignalCannotBeEnumType">The trigger signal of ''{0}'' is invalid because it has an enumerated data type ''{1}''</entry>
    <entry key="TriggerPortsMustHaveConvertBetweenRegistered">The trigger signal of ''{0}'' may not be of type ''{1}'' because that type has no type conversion function registered</entry>
    <entry key="UdtDoesNotEvalToDataType">''{0}''이(가) ''{2}''의 파라미터 ''{1}''에 대한 유효한 데이터형으로 확인되지 않습니다.</entry>
    <entry key="UdtDoesNotEvalToEnum">''{0}''이(가) ''{2}''의 파라미터 ''{1}''에 대한 열거형 데이터형으로 확인되지 않습니다.</entry>
    <entry key="UdtDoesNotEvalToBus">''{0}''이(가) ''{2}''의 파라미터 ''{1}''에 대한 Simulink.Bus 객체로 확인되지 않습니다.</entry>
    <entry key="UdtEmptyDataType">파라미터 ''{0}''은(는) 비어 있을 수 없습니다.</entry>
    <entry key="UdtEvalsToFixdtWithNoScaling">''{0}''이(가) ''{2}''의 파라미터 ''{1}''에 대해 스케일링이 지정되지 않은 고정소수점 데이터형으로 확인되지만, 이 데이터형은 이 파라미터에서 지원되지 않습니다.</entry>
    <entry key="UdtEvalsToUnsupportedBuiltin">''{0}'' resolves to a built-in data type, but the parameter ''{1}'' in ''{2}'' does not support this built-in data type.</entry>
    <entry key="UdtEvalsToUnsupportedEnum">''{0}'' resolves to an enumerated data type, but the parameter ''{1}'' in ''{2}'' does not support enumerated data types.</entry>
    <entry key="UdtEvalsToImplicitBus">''{0}''이(가) ''{2}''의 파라미터 ''{1}''에 대한 버스 데이터형으로 확인됩니다. 그러나 블록 데이터형 파라미터에 대해 버스 데이터형을 지정하려는 경우, 앞에 ''Bus: ''를 추가하여 명시적으로 지정해야 합니다.</entry>
    <entry key="UdtEvalsToUnsupportedFixdt">''{0}'' resolves to a fixed-point data type for parameter ''{1}'' in ''{2}'', but fixed-point data types are not supported by this parameter.</entry>
    <entry key="UdtEvalsToUnsupportedFixdtScalingMode">''{0}''이(가) ''{2}''의 파라미터 ''{1}''에 대해 고정소수점 데이터형으로 확인되지만, 확인된 데이터형의 스케일링 모드는 이 파라미터에서 지원되지 않습니다.</entry>
    <entry key="UdtEvalsToUnsupportedHalfPrecisionType">''{0}''이(가) ''{2}''의 파라미터 ''{1}''에 대한 반정밀도 부동소수점 데이터형으로 확인됩니다. 하지만 반정밀도 부동소수점 데이터형은 이 파라미터에서 지원되지 않습니다.</entry>
    <entry key="UdtEvalsToUnsupportedFixdtSignMode">''{0}''이(가) ''{2}''의 파라미터 ''{1}''에 대해 고정소수점 데이터형으로 확인되지만, 확인된 데이터형의 부호 모드는 이 파라미터에서 지원되지 않습니다.</entry>
    <entry key="UdtEvalsToUnsupportedInheritRule">''{0}'' resolves to an inheritance rule, but the parameter ''{1}'' in ''{2}'' does not support this inheritance rule.</entry>
    <entry key="UdtInvBuiltin">''{0}''이(가) 파라미터 ''{1}''에 내장 데이터형을 지정합니다. 하지만 이 파라미터는 내장 데이터형을 지원하지 않습니다.</entry>
    <entry key="UdtInvEnumName">''{0}''이(가) 파라미터 ''{1}''에 유효한 열거형 데이터형을 제공하지 않습니다.</entry>
    <entry key="UdtInvBusName">''{0}''이(가) 파라미터 ''{1}''에 유효한 버스 데이터형 이름을 제공하지 않습니다.</entry>
    <entry key="UdtInvFixdt">''{0}''이(가) 파라미터 ''{1}''에 고정소수점 데이터형을 지정하지만, 표현식의 구문이 올바르지 않습니다.</entry>
    <entry key="UdtInvInherit">''{0}''이(가) 파라미터 ''{1}''에 상속 규칙을 지정합니다. 하지만 이 파라미터는 상속 규칙을 지원하지 않습니다.</entry>
    <entry key="UdtInvalidValue">''{0}''에 유효하지 않은 데이터형 사양입니다.</entry>
    <entry key="UdtNoEnum">''{0}''이(가) 열거형 데이터형을 지정합니다. 하지만 파라미터 ''{1}''은(는) 열거형 데이터형을 지원하지 않습니다.</entry>
    <entry key="UdtNoBus">''{0}''이(가) 버스 데이터형을 지정합니다. 하지만 파라미터 ''{1}''은(는) 버스 데이터형을 지원하지 않습니다.</entry>
    <entry key="UdtReplaceExprHint">''{0}''은(는) ''{2}''의 파라미터 ''{1}''에 유효한 데이터형이 아닙니다. 유효한 Simulink 데이터형 객체로 확인되는 MATLAB 표현식으로 대체해야 합니다.</entry>
    <entry key="UndefinedDataTypeToBeAliasedTo">''{0}'' cannot define data type ''{1}'' to be aliased to id {2,number,integer} because no data type with that id exists</entry>
    <entry key="UnscaledFixptTypeByBlkParam">''{2}''의 블록 파라미터 ''{1}''에 의해 지정된 데이터형 ''{0}''은(는) 여기에 유효하지 않습니다. 사용 가능한 스케일링 정보가 없기 때문입니다.</entry>
    <entry key="WarnDownCastOfInterfacedVar">''{1}''의 파라미터 {0}을(를) 데이터형 ''{2}''에서 데이터형 ''{3}''(으)로 형변환하는 중입니다. 시뮬레이션과 생성 코드 간에 일관된 동작을 보장하기 위해, 조정 가능형 파라미터 표현식을 내림 형변환하거나 부호 여부가 불일치하는 것은 권장되지 않습니다.&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="WarningEnumSafeCastDetected">Safe cast detected at time {0} in ''{1}''.&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="WarningOverFlowDetected">Wrap on overflow detected at time {0} in ''{1}''.&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="WarningSaturationOccurred">Saturate on overflow detected at time {0} in ''{1}''.&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="AbsTimeOverflowDetected">Overflow condition detected while evaluating absolute time at {0} for model ''{1}''. This indicates the simulation time is greater than the ''Application life span(days)''.&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="RTWOverFlowDetected">Overflow detected while evaluating the output of ''{0}''.&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="RTWEnumSafeCastDetected">Safe cast detected while evaluating the output of ''{0}''.&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="NumericType_InvalidInput">입력은 ''embedded.numerictype'' 유형이어야 함</entry>
    <entry key="NumericType_ScaledDoubleType">Invalid datatype ''Scaled Double'' for Simulink.NumericType object</entry>
    <entry key="EnumDataTypeNotSupportMinMax">Minimum and maximum are not supported for enumerated data type ''{0}''</entry>
    <entry key="EnumDataTypeNotSupportMinMaxOnBusElement">요소 ''{1}''의 열거형 데이터형 ''{0}''에 대해서는 최솟값 및 최댓값이 지원되지 않습니다</entry>
    <entry key="StringDataTypeNotSupportMinMaxOnBusElement">요소 ''{0}''의 string형 데이터형에 대해서는 최솟값 및 최댓값이 지원되지 않습니다</entry>
    <entry key="BusDataTypeNotSupportMinMaxOnBusElement">버스 데이터형에 대해서는 최솟값 및 최댓값이 지원되지 않습니다. 요소 ''{1}''의 Bus 객체 ''{0}''의 리프 요소에 대한 최솟값 및 최댓값을 지정하십시오</entry>
    <entry key="BusElement_Inconsistent">요소 사양이 일치하지 않음</entry>
    <entry key="BusElementMinValueMustBeFiniteRealDoubleScalar">Minimum on element ''{0}'' must be a finite real double scalar value</entry>
    <entry key="BusElementMaxValueMustBeFiniteRealDoubleScalar">Maximum on element ''{0}'' must be a finite real double scalar value</entry>
    <entry key="SignalTypeMinValueMustBeFiniteRealDoubleScalar">Signal Type 객체의 최솟값은 유한한 double형 실수 스칼라 값이어야 합니다.</entry>
    <entry key="SignalTypeMaxValueMustBeFiniteRealDoubleScalar">Signal Type 객체의 최댓값은 유한한 double형 실수 스칼라 값이어야 합니다.</entry>
    <entry key="BusElementMinGreaterThanMax">최솟값({0})이 요소 ''{2}''의 최댓값({1})보다 큽니다</entry>
    <entry key="BusElementMinIsOutOfDTRange">최솟값({0})이 요소 ''{3}''의 데이터형 범위 [{1}, {2}]을(를) 벗어납니다</entry>
    <entry key="BusElementMaxIsOutOfDTRange">최댓값({0})이 요소 ''{3}''의 데이터형 범위 [{1}, {2}]을(를) 벗어납니다</entry>
    <entry key="CustomDataTypeNotSupportMinMax">요소 ''{1}''의 데이터형 ''{0}''에 대해서는 최솟값 및 최댓값이 지원되지 않습니다</entry>
    <entry key="StringType_InvalidMaxLength">Maximum length argument must be an integer from {0} to {1}, inclusive, or a string representing a valid symbolic dimension expression that can evaluate to an integer from {0} to {1}.</entry>
    <entry key="StringType_NotSupportedInAliasType">AliasType은 string 데이터형을 기본 유형으로 지원하지 않습니다.</entry>
    <entry key="StringType_ExprMustResolveSymDimsId">
        
                 The expression ''{0}'' of the maximum length argument in the "stringtype" function must be a valid symbolic dimension expression. For more information, see &lt;a href="matlab:helpview(''ecoder'',''dim_variants_for_array_sizes'')"&gt;symbolic dimension&lt;/a&gt;.
        
    </entry>
    <entry key="StringType_SymbolicDimensionDisabled">모델 ''{1}''에서 stringtype의 최대 길이 인수 ''{0}''에는 기호 변수를 사용할 수 없습니다. 모델에 '기호 차원 지정 허용'이 off로 설정되어 있거나 비 ERT 타깃 파일이 사용되기 때문입니다. string 데이터형의 최대 길이 인수에는 표현식의 숫자형 값이 사용됩니다.</entry>
    <entry key="StringType_ExprMustBeScalar">The expression ''{0}'' of the maximum length argument of the string data type must evaluate to a scalar.</entry>
    <entry key="StringType_ExprMustBePositiveInteger">The expression ''{0}'' of the maximum length argument of the string data type must evaluate to a positive integer.</entry>
    <entry key="StringType_SymbolicDimensionIgnoredByStateflow1">Stateflow 블록, MATLAB Function 블록 및 MATLAB System 블록에는 string 데이터형의 최대 길이 인수에 대한 기호 표현식을 사용할 수 없습니다. 표현식 ''{0}''의 숫자형 값이 블록 ''{1}''에서 생성된 코드에 사용됩니다.</entry>
    <entry key="StringType_SymbolicDimensionIgnoredByStateflow2">Stateflow 블록, MATLAB Function 블록 및 MATLAB System 블록에는 string 데이터형의 최대 길이 인수에 대한 기호 표현식을 사용할 수 없습니다. string 데이터형 ''{0}''(으)로 표현된 기호 표현식의 숫자형 값이 블록 ''{1}''에서 생성된 코드에 사용됩니다.</entry>
    <entry key="StringType_NotSupportedInSlDataObject">DataType ''{0}''이(가) {1} 객체에서 지원되지 않는 string 데이터형으로 확인되었습니다.</entry>
    <entry key="SpecifyParamsForBestPrecisionMode">''{1}''의 데이터형 파라미터 ''{0}''에 대해 최적 정밀도 모드가 지정되었습니다. 최적 스케일링을 정확하게 계산하기 위해 다음 블록 파라미터 중 적어도 하나를 지정해야 합니다: ''{2}''</entry>
    <entry key="InvalidDataScope">''{0}'' is not a valid value for DataScope. Values must be one of ''Auto'', ''Exported'', or ''Imported''</entry>
    <entry key="InvalidImageTypeName">''{0}''은(는) 이미지 유형에 유효한 이름이 아닙니다. 이름은 ''Image_COLORFORMAT_(Row|Col)_UNDERLYINGCLASS_(\\d+_)?\\d+_\\d+$'' 형식이어야 합니다. 여기서 COLORFORMAT는 ''BGRA'', ''RGB'', ''BGR'', ''Grayscale'' 중 하나이고 UNDERLYINGCLASS는 ''int8'', ''uint8'', ''int16'', ''uint16'', ''int32'', ''uint32'', ''double'', ''single'', ''boolean'' 중 하나여야 합니다</entry>
    <entry key="InvalidImageTypeColorFormat">''{0}''은(는) 유효한 ColorFormat 값이 아닙니다. 값은 ''BGRA'', ''RGB'', ''BGR'', ''Grayscale'' 중 하나여야 합니다</entry>
    <entry key="InvalidImageTypeNumChannels">{0,number,integer} is not a valid number of channels for the ColorFormat ''{1}''; the expected number of channels is {2,number,integer}</entry>
    <entry key="InvalidImageTypeNumChannels2">{0,number,integer} is not a valid number of channels for the ColorFormat ''{1}''; the expected number of channels is greater than zero</entry>
    <entry key="InvalidImageTypeNumRows">{0}은(는) 유효한 행 개수가 아닙니다. 행 개수는 0보다 큰 정수여야 합니다</entry>
    <entry key="InvalidImageTypeNumConstructorArgs">{0,number,integer}은(는) ImageType 생성자에 대한 유효한 인수 개수가 아닙니다. 지원되는 생성자는 Simulink.ImageType() 및 Simulink.ImageType(ROWS, COLUMNS, NUMCHANNELS, Name, Value)입니다. 여기서 지원되는 이름, 값 쌍은 ClassUnderlying, ColorFormat, Layout입니다.</entry>
    <entry key="InvalidImageTypeNumCols">{0}은(는) 유효한 열 개수가 아닙니다. 열 개수는 0보다 큰 정수여야 합니다</entry>
    <entry key="InvalidImageTypeLayout">''{0}''은(는) 유효한 Layout 값이 아닙니다. 값은 ''RowMajor'', ''ColumnMajor'' 중 하나여야 합니다</entry>
    <entry key="InvalidImageTypeBaseType">''{0}''은(는) 유효한 BaseType 값이 아닙니다. 값은 ''Double'', ''Single'', ''int8'', ''uint8'', ''int16'', ''uint16'', ''int32'', ''uint32'', ''boolean'' 중 하나여야 합니다.</entry>
    <entry key="InvalidImageTypeDataScope">이미지 유형의 DataScope는 ''Auto''로 설정되어야 함</entry>
    <entry key="InvalidImageTypeHeaderFile">이미지 유형의 HeaderFile은 ''''로 설정되어야 함</entry>
    <entry key="ImageType_NotSupportedInAliasType">AliasType은 이미지 데이터형을 기본 유형으로 지원하지 않습니다.</entry>
    <entry key="BlockObjectDTONameClashEditTime">''{0}'' is not a valid identifier for parameter ''{1}'' in ''{2}''. Starting identifiers with ''dtoDbl'', ''dtoSgl'', or ''dtoScl'' is not allowed as this name space is reserved for internal use with data type override mode.</entry>
    <entry key="BlockObjectDTONameClashCompileTime">Potential name clash found for identifier ''{0}'' for parameter ''{1}'' in ''{2}''. This error is caused by one of two conditions. First, entering a parameter value that starts with ''dtoDbl'', ''dtoSgl'', or ''dtoScl'' is not allowed as this name space is reserved for internal use with data type override mode. Second, if your model has active data type override settings and the software has created overridden identifier ''{3}'', a variable cannot exist with this same name in any workspace visible to the model.</entry>
    <entry key="BlockObjectDTONameTooLong">''{2}''의 파라미터 ''{1}''에 대한 식별자 ''{0}''이(가) 너무 깁니다. 모델에 활성 상태의 데이터형 재정의 설정이 있으며, 소프트웨어에서 최대 길이인 {4, number, integer}을(를) 초과하는 재정의된 식별자 ''{3}''을(를) 생성했습니다. ''{0}'' 식별자의 길이를 줄이십시오. </entry>
    <entry key="NoMatchingDataTypeConstructor">시그니처가 일치하는 생성자 ''{0}''을(를) 찾을 수 없습니다.</entry>
    <entry key="setInvalidUse">You cannot use SET to change the properties of a {0} object; \n use dot notation instead.</entry>
    <entry key="UndefinedMethod">''{1}'' 클래스에 대해 시그니처가 일치하는 메서드 ''{0}''을(를) 찾을 수 없습니다.</entry>
    <entry key="AbstractAttribute">Abstract classes cannot be instantiated.  Class ''{0}'' is declared as Abstract.</entry>
    <entry key="OldDataTypeSpecificationBlock">데이터형이 이전 구조체 형식을 사용하여 지정되었습니다. 이 형식은 향후 릴리스에서 지원되지 않을 예정입니다. 선호되는 사양 형식은 Numeric Type 객체입니다. Numeric Type 객체를 생성하려면 NUMERICTYPE 또는 FIXDT를 사용하십시오. 기존 구조체 사양을 Numeric Type 객체로 변환하려면 FIXDTUPDATE를 확인하십시오. 해당 데이터형은 ''{0}''에 의해 사용되었습니다.</entry>
    <entry key="OldDataTypeSpecification">A data type has been specified using the old structure format. Support for this format will be removed in a future release. Numeric type objects are the preferred form of specification.  To construct a Numeric Type object use NUMERICTYPE or FIXDT. To convert a legacy structure specification to a numeric type object see FIXDTUPDATE.</entry>
    <entry key="StructToMultiBuses">''{1}''의 모델 인수 ''{0}''의 구조화된 값이 중복된 버스 유형 {2}에 매핑될 수 있습니다. 이 경우 컴파일할 수 없는 코드가 생성될 수 있습니다.</entry>
    <entry key="RefreshDataTypeInWorkspace">--- 데이터형 새로 고침 ---</entry>
    <entry key="DataTypeExpression">&lt;데이터형 표현식&gt;</entry>
    <entry key="HalfRapidAccelNotSupported">Rapid accelerator simulation is not supported when the model contains ''half-precision'' data type. </entry>
    <entry key="HalfGPUCodeNotSupported">모델에서 구조체형에 ''반정밀도'' 데이터형이 포함된 경우 GPU 코드 생성이 지원되지 않습니다. </entry>
    <entry key="HalfGPUMallocModeNotSupported">''반정밀도'' 데이터형을 갖는 GPU 코드를 생성하려면 malloc 모드를 이산으로 설정해야 합니다.</entry>
    <entry key="HalfGPUComputeCapabilityNotSupported">''반정밀도'' 데이터형으로 GPU 코드를 생성하려면 Compute Capability가 5.3 이상이어야 합니다. </entry>
    <entry key="HalfExternalModeNotSupported">When the model contains ''half-precision'' data types, external mode simulation is supported only if the transport layer of the communication channel uses XCP.</entry>
    <entry key="PointerExternalModeNotSupported">모델에 ''포인터'' 데이터형이 포함된 경우 외부 모드 시뮬레이션이 지원되지 않습니다.</entry>
    <entry key="HalfCPPCodegenNotSupported">C++ code generation is not supported when the model contains ''half'' data type. </entry>
    <entry key="ValueTypeDoesNotSupportBuses">Simulink.Bus 객체 ''{0}''을(를) Simulink.ValueType 객체 ''{1}''의 데이터형으로 지정할 수 없습니다.</entry>
    <entry key="ValueTypeDoesNotSupportBusesLocal">Simulink.Bus 객체를 Simulink.ValueType 객체의 데이터형으로 지정할 수 없습니다.</entry>
    <entry key="ValueTypeDoesNotSupportRecursiveValueType">Simulink.ValueType 객체를 Simulink.ValueType 객체의 데이터형으로 지정할 수 없습니다.</entry>
    <entry key="ValueTypeDoesNotSupportEmptyDataType">값 유형 객체의 데이터형은 빈 문자열로 설정되어서는 안 됩니다.</entry>
    <entry key="OpaqueDataTypeMismatch">{4} &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;{0}(''{1}'',{2,number,integer},''{3,number,integer}'')&lt;/cmd&gt; &lt;txt&gt;입력과 일치하도록 {1}의 출력을 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;</entry>
    <entry key="OpaqueDataTypeMismatchFixed">이제 블록 ''{0}''이(가) 업데이트되었습니다. 시뮬레이션을 다시 실행하십시오.</entry>
  </message>
</rsccat>
