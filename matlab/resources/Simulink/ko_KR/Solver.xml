<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2024 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ko_KR" product="Simulink" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="Error">
      시간 {1}에서 모델 ''{0}''을(를) 시뮬레이션하는 동안 솔버에서 오류가 발생하여 실행을 계속할 수 없습니다. 모델에 오류가 있는지 확인하십시오.
    </entry>
    <entry key="Warning">
      솔버가 시간 {1}에 모델 ''{0}''을(를) 시뮬레이션하는 데 문제가 생겼습니다. Simulink에서 경고가 발생하지만 시뮬레이션을 계속합니다. 모델에 오류가 있는지 확인하십시오.
    </entry>
    <entry key="StateNotFinite">시간 {2}에서 ''{1}''의 연속 상태 ''{0}''이(가) 유한하지 않습니다. Simulink가 시뮬레이션을 종료합니다. 해에 특이점이 있을 수 있습니다. 모델 ''{3}''에 오류가 있는지 확인하십시오. 고정 스텝 크기를 줄이거나 가변 스텝 솔버의 오차 허용오차를 더 엄격한 값으로 조정해 보십시오.
    </entry>
    <entry key="InvSrcBlkOutBeingMergedAndUsedToComputeDeriv">
      블록 ''{0}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;의 불연속 신호를 다른 연속 신호와 병합하는 것은 유효하지 않습니다. 병합된 신호가 연속 상태의 도함수를 계산하는 데 사용되는 입력 포트를 구동하고 있기 때문입니다.
    </entry>
    <entry key="ZeroCrossingIntervalNotBracketedDueToConsecutiveEvents">
  
  시간 {1}에서 시작하여, Simulink가 시간 간격 {3} 내에서 {2,number,integer}개의 연속 영점교차를 발견했습니다. 시뮬레이션이 중단되지 않고 계속 진행되도록 하기 위해, 적응형 영점교차 검출 알고리즘은 현재 스텝 크기({4})를 더 줄이지 않고 그대로 받습니다. 연속 이벤트를 일으키는 영점교차 신호나 탐색 구간이 설정되지 않은 이벤트를 갖는 영점교차 신호가 아래에 나열되어 있습니다.\n {5} &lt;actions exclusiveFixIts="no"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt; set_param(''{0}'',''IgnoredZcDiagnostic'',''none''); &lt;/cmd&gt; &lt;txt&gt; '무시된 영점교차'를 '없음'으로 설정하여 이 진단 기능을 끄십시오. &lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt; 위에 나열된, 영점교차 개수가 가장 많은 블록에서 영점교차 검출을 비활성화하십시오. &lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
  
</entry>
    <entry key="ZeroCrossingNotBracketedDueToSmallSignalValues">
      
      시간 {1} 및 스텝 크기 {2}에서 아래 나열된 신호로 인한 {3,number,integer}개의 영점교차를 찾았습니다. 하지만 이 시간 스텝 동안 영점교차가 있는 신호의 크기가 허용오차({4})보다 작으므로, 적응형 영점교차 검출 알고리즘은 스텝 크기를 더 줄이지 않습니다.\n {5} &lt;actions exclusiveFixIts="no"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{0}'',''IgnoredZcDiagnostic'',''none'');&lt;/cmd&gt; &lt;txt&gt; '무시된 영점교차'를 '없음'으로 설정하여 이 진단 기능을 끄십시오. &lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt; 위에 나열된 블록에서 영점교차 검출을 비활성화하면 시뮬레이션 속도를 높일 수 있습니다. &lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
      
    </entry>
    <entry key="SomeZeroCrossingNotBracketedDueToSmallSignalValues">
  
  시간 {1} 및 스텝 크기 {2}에서 {3,number,integer}개의 영점교차를 찾았습니다. 하지만 신호 크기가 허용오차({5})보다 작으므로, 아래에 나열된 {4,number,integer}개의 신호에 따른 적응형 영점교차 검출 알고리즘은 영점교차의 탐색 구간을 설정하지 않습니다.\n {6} &lt;actions exclusiveFixIts="no"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{0}'',''IgnoredZcDiagnostic'',''none'');&lt;/cmd&gt; &lt;txt&gt; '무시된 영점교차'를 '없음'으로 설정하여 이 진단 기능을 끄십시오. &lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt; 위에 나열된 블록에서 영점교차 검출을 비활성화하면 시뮬레이션 속도를 높일 수 있습니다. &lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
  
</entry>
    <entry key="MaxConsecutiveZeroCrossingsError">
      
      아래에 식별된 {1, number, integer}개의 영점교차 신호가 {3}~{4} 사이의 시간 간격에서 {2,number,integer}개의 연속 영점교차 이벤트를 발생시켰으므로 Simulink가 모델 ''{0}''의 시뮬레이션을 중지합니다.\n {5} &lt;actions exclusiveFixIts="no"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt; set_param(''{0}'',''ZeroCrossAlgorithm'',''Adaptive'',''IgnoredZcDiagnostic'',''none''); &lt;/cmd&gt; &lt;txt&gt; &lt;sldiag objui="configset" objparam="ZeroCrossAlgorithm"&gt; 영점교차 검출 알고리즘&lt;/sldiag&gt;을 ''적응형''으로 전환하고 &lt;sldiag objui="configset" objparam="IgnoredZcDiagnostic"&gt;무시된 영점교차&lt;/sldiag&gt; 진단을 ''없음''으로 설정하면 진단 결과를 표시하지 않고 해당 영점교차의 탐색 구간을 설정하지 않은 채로 시뮬레이션을 계속할 수 있습니다. &lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt; 위에 나열된, 가장 많은 이벤트를 발생시킨 블록에서 영점교차 검출을 비활성화하십시오. &lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
      
    </entry>
    <entry key="DetectedMaskedZeroCrossings">
      {0}에서 {1}까지의 시뮬레이션 시간 스텝(스텝 크기 = {2}) 동안 다음 {3,number,integer}개의 마스크 처리된 영점교차, 즉 짝수 개의 영점교차 이벤트를 갖는 신호를 발견했습니다.\n {4} 이 시간 스텝에 다른 영점교차가 있기 때문에 검색 알고리즘에 이러한 영점교차만 감지되었습니다. 마스크 처리된 영점교차는 현재 시간 스텝에 짝수의 영점교차를 갖는 하나 이상의 영점교차 신호에 의해 발생합니다. 마스크 처리된 영점교차는 경우에 따라 감지되지 않을 수 있습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{6}'',''Refine'')&lt;/cmd&gt; &lt;txt&gt;''세분화 인자''를 ({5,number,integer})에서 더 큰 값으로 높이십시오&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" btn="apply"&gt; &lt;cmd&gt;set_param(''{6}'',''MaskedZcDiagnostic'',''none'');&lt;/cmd&gt; &lt;txt&gt;이 진단을 비활성화하려면 &lt;sldiag objui="configset" objparam="MaskedZcDiagnostic"&gt;마스크 처리된 영점 교차&lt;/sldiag&gt; 진단을 ''안 함''으로 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;

      
    </entry>
    <entry key="UnsupportedSolverForRSim">
      지정된 솔버 ''{0}''이(가) RSIM 타깃과 호환되지 않습니다. 따라서 모델 ''{1}''에 대한 RSIM 타깃 빌드가 중지됩니다. \n RSIM에 지원되는 다음 솔버 중 하나를 사용하십시오. \n "ode1" \n "ode14x" \n "ode15s" \n "ode113" \n "ode2" \n "ode23" \n "ode23s" \n "ode23t" \n "ode23tb" \n "ode3" \n "ode4" \n "ode45" \n "ode5" \n "ode8" \n
    </entry>
    <entry key="FixedStepZeroCrossingNotSupportedForRSim">
      RSIM 타깃에 대해 고정 스텝 영점교차 검출이 지원되지 않으므로 모델 ''{0}''에 대한 RSIM 타깃 빌드가 중지됩니다.\n &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param( ''{0}'', ''EnableFixedStepZeroCrossing'', ''off'');&lt;/cmd&gt; &lt;txt&gt;고정 스텝 시뮬레이션에 대한 영점교차 검출을 비활성화하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="SolverInputCompensationSupportZOHonly">
      솔버 ''{1}''이(가) ''{0}'' 입력 신호 처리를 지원하지 않으므로, Model 블록 ''{2}''이(가) 참조하는 모델 ''{3}''에 영차 유지 입력 처리가 사용됩니다.
    </entry>
    <entry key="SolverOutputApproximationSupportZOHonly">
         솔버 ''{1}''은(는) ''{0}'' 출력 신호 처리를 지원하지 않으므로 Model 블록 ''{2}''은(는) 영차 유지 출력 신호 처리를 사용해야 합니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="UseZOHOutputHandling"&gt; &lt;cmd&gt;set_param(''{2}'', ''OutputSignalHandling'', ''Zero-order hold'')&lt;/cmd&gt; &lt;txt&gt;Model 블록 ''{2}''에 대한 ''출력 신호 처리'' 파라미터 값을 ''영차 유지''로 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt; 			
         
    </entry>
    <entry key="SolverChangeInFastRestartExplicitToImplicit">모델 ''{1}''이(가) 빠른 재시작에서 양함수 솔버를 사용하여 초기화되었습니다. 모델 재컴파일 없이 야코비 행렬이 필요한 ''{0}''(으)로의 변경을 지원하기 위해 솔버 야코비 방법 제어가 ''{2}''에서 비희소 섭동으로 전환됩니다.</entry>
    <entry key="InvalidSolverChangeInFastRestartOdeN">음함수 솔버를 사용하여 빠른 재시작으로 초기화되는 모델과 질량 행렬을 갖는 모델의 경우 솔버를 양함수 적분 방법 ''{0}''을(를) 사용하는 odeN으로 변경할 수 없습니다. 모델 ''{1}''에 대한 새 솔버 odeN은 사용되지 않습니다. odeN의 적분 방법을 음함수 솔버로 설정하십시오. 유효한 방법은 'ode14x' 및 'ode1be'입니다.</entry>
    <entry key="InvalidIntMethodChangeInFastRestartOdeN">음함수 솔버를 사용하여 빠른 재시작으로 초기화되는 모델과 질량 행렬을 갖는 모델의 경우 솔버를 양함수 적분 방법 ''{0}''을(를) 사용하는 odeN으로 변경할 수 없습니다. 모델 ''{1}''에서 새 적분 방법이 사용되지 않습니다. odeN의 적분 방법을 음함수 솔버로 설정하십시오. 유효한 방법은 'ode14x' 및 'ode1be'입니다.</entry>
    <entry key="InvalidSolverChangeInFastRestartImplicitToExplicit">음함수 솔버를 사용하여 빠른 재시작으로 초기화되는 모델과 질량 행렬을 갖는 모델의 경우 솔버를 양함수 솔버로 변경할 수 없습니다. 모델 ''{1}''에 대한 새 솔버 ''{0}''은(는) 사용되지 않습니다. 솔버를 음함수 솔버로 설정하십시오.</entry>
    <entry key="InvalidSolverChangeInFastRestartVarToFixed">가변 스텝 솔버를 사용하여 빠른 재시작으로 초기화되는 모델의 경우 솔버를 고정 스텝 솔버로 변경할 수 없습니다. 모델 ''{1}''에 대한 새 솔버 ''{0}''은(는) 사용되지 않습니다. 솔버를 가변 스텝 솔버로 설정하십시오.</entry>
    <entry key="SolverChangeNotSupportedFixedStep">고정 스텝 솔버의 경우 빠른 재시작을 사용하여 솔버를 변경할 수 없습니다. 솔버를 변경하려면 현재 컴파일 작업을 종료해야 합니다.</entry>
    <entry key="FixedStepIsNotDiscreteDivisor">
    모델 ''{1}''의 고정 스텝 크기({0}) 설정이 유효하지 않습니다. 모델의 모든 샘플 시간은 고정 스텝 크기의 정수 배수여야 합니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="SetFixedStepToDivisor"&gt; &lt;cmd&gt;set_param(''{1}'', 'FixedStep', ''{2}'')&lt;/cmd&gt; &lt;txt&gt;고정 스텝 크기를 {2}(으)로 설정&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;

    
    </entry>
  </message>
</rsccat>
