<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ko_KR" product="Simulink" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="ModelCompileDuringSymbolLookup">블록 파라미터는 자신이 소유한 블록 다이어그램 ''{0}''을(를) 참조할 수 없습니다.</entry>
    <entry key="AVT_LicenseError">설계를 변환하는 데 필요한 Simulink Design Verifier 라이선스를 체크아웃할 수 없습니다.</entry>
    <entry key="AbsoluteTimeNotSupported">블록 ''{0}''이(가) 절대 시간을 사용하는데, 이는 현재 구성에서 지원되지 않습니다. &lt;sldiag objui="configset" objparam="SupportAbsoluteTime"&gt;절대 시간 지원&lt;/sldiag&gt;을 선택해 보십시오</entry>
    <entry key="InvCallToSubstituteCS">substituteTmpConfigSetForBuild 및 restoreOrigConfigSetForBuild 호출이 유효하지 않습니다. 2개의 인수를 사용하고 반환 값 없이 호출해야 합니다.</entry>
    <entry key="InvalidModelRefTargetTypeForVmExecution">The model reference target type ''{0}'' is invalid for JIT accelerated simulations</entry>
    <entry key="AbortingCompilation">모델 컴파일을 중단하는 중</entry>
    <entry key="AbortCompilation">모델 컴파일이 중단되었습니다.</entry>
    <entry key="AccErrorStatus">Error reported when running the Accelerated simulation ''{0}'' :\n{1}</entry>
    <entry key="AccModelNameTooLong">Unable to accelerate model ''{0}'' because the resulting accelerator MEX-file name would be too long. Please rename your model and reduce name length to less than {1,number,integer} characters</entry>
    <entry key="AccelCodeGenError">모델 ''{0}''에 대한 액셀러레이터 MEX 파일을 만드는 중 문제가 발생했습니다.</entry>
    <entry key="AccelCodeGenErrorTellAboutVerbose">모델 ''{0}''에 대한 액셀러레이터 MEX 파일을 만드는 중 문제가 발생했습니다.\n 빌드 출력을 보려면 set_param(''{1}'',''AccelVerboseBuild'',''on'')을 사용하십시오</entry>
    <entry key="AccelJITErrorTellAboutVerbose">모델 ''{0}''을(를) JIT 가속화하는 중 오류가 발생했습니다.\n 자세한 내용을 보려면 set_param(''{1}'',''AccelVerboseBuild'',''on'')을 사용하십시오</entry>
    <entry key="AccelJITError">모델 ''{0}''을(를) JIT 가속화하는 중 오류가 발생했습니다.</entry>
    <entry key="AccelInvCalltoRunBlock">sleAccRunBlock 호출이 유효하지 않음</entry>
    <entry key="AccelMexLoadError">액셀러레이터 MEX 파일 ''{0}''을(를) 불러오는 중 오류가 발생했습니다.</entry>
    <entry key="AccelNameConflict">The model ''{0}'' must be renamed since the Accelerator uses this name for the accelerated mex file</entry>
    <entry key="AccelNotSupportedAlgLoopsWithCertainBlocks">모델 ''{0}''의 대수 루프에 블록 ''{1}''이(가) 포함되어 있기 때문에 이 모델에서는 액셀러레이터 모드가 지원되지 않습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{0}'','SimulationMode','Normal')&lt;/cmd&gt; &lt;txt&gt;대신 표준 모드를 사용하여 모델 ''{0}''을(를) 시뮬레이션하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
	</entry>
    <entry key="AccelNotSupportedWithSFcnAPI">모델의 이름을 함수로 사용하여 실행되는 시뮬레이션에는 액셀러레이터 모드가 지원되지 않습니다.</entry>
    <entry key="AccelUnableToAcqFoundFcnHdl">액셀러레이터 모드에서 모델 ''{0}''을(를) 시뮬레이션하는 동안 Simulink가 MATLAB 함수 ''{1}''과(와) 일치하는 항목을 찾았지만 이를 실행하지 못했습니다. 일반적으로 이 문제는 찾아낸 MATLAB 함수가 원하는 함수와 대/소문자만 다르기 때문에 발생합니다. 현재 모델의 이름을 바꾸거나, MATLAB 경로에서 이 또 다른 MATLAB 함수를 제거하십시오. 그렇게 하려면 이 함수를 삭제하거나 이름을 바꾸거나 MATLAB 경로에서 이 함수가 포함된 폴더를 제거하면 됩니다. </entry>
    <entry key="AccelUnableToAcqFcnHdl">MATLAB 함수 ''{0}''에 대한 핸들을 가져올 수 없음</entry>
    <entry key="AccelBuildNoModelName">Unable to obtain current model name.</entry>
    <entry key="ActionECPotentialPreStartOutputDiff">''{1}''이(가) t = 0에서 활성화되지 않은 경우 ''{0}''의 출력이 이전 Simulink 릴리스와 다른 결과를 생성할 수 있습니다. ''{2}'' 블록은 영(0) 입력에 대해 0이 아닌 출력을 생성할 수 있으며 ''{3}'' 실행 컨텍스트에 의해 상속되었습니다. 이전 릴리스에서 ''{4}''은(는) 실행 컨텍스트에 의해 상속되지 않았으며 조건부 서브시스템 시작 전에 0이 아닌 출력을 생성했을 수 있습니다. 컨텍스트의 상속을 방지하려면 ''{5}''의 샘플 시간을 신호를 다시 계산하고자 하는 레이트로 명시적으로 설정하십시오. 이 경고 메시지를 끄려면 &lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;실행 컨텍스트의 사전 활성화 출력 확인&lt;/sldiag&gt;을 선택 취소하십시오.</entry>
    <entry key="ActionECPotentialPreStartOutputDiffConsistentOutportInit">''{1}''이(가) t = 0에서 활성화되지 않은 경우 ''{0}''의 출력이 이전 Simulink 릴리스와 다른 결과를 생성할 수 있습니다. ''{2}'' 블록은 영(0) 입력에 대해 0이 아닌 출력을 생성할 수 있으며 ''{3}'' 실행 컨텍스트에 의해 상속되었습니다. 이전 릴리스에서 ''{4}''은(는) 실행 컨텍스트에 의해 상속되지 않았으며 조건부 서브시스템 시작 전에 0이 아닌 출력을 생성했을 수 있습니다. 컨텍스트의 상속을 방지하려면 ''{5}''의 샘플 시간을 신호를 다시 계산하고자 하는 레이트로 명시적으로 설정하십시오. 이 경고 메시지를 끄려면 &lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;실행 컨텍스트의 사전 활성화 출력 확인&lt;/sldiag&gt;을 선택 취소하십시오.</entry>
    <entry key="AddDimsDependRuleCompStageMismatch">Simulink가 ''{0}''에서 S-Function에 대해 ''ssAddOutputDimsDependencyRule''의 사용이 올바르지 않음을 감지했습니다. 이 SimStruct 함수는 ''mdlSetWorkWidths'' 메서드에서만 사용할 수 있습니다.</entry>
    <entry key="AlgLoopFrozenModesNoConvergence" context="warning">디폴트 알고리즘이 시간 {1}에서 수렴하지 않았기 때문에 블록 ''{0}''을(를) 포함하는 대수 루프의 해를 구하기 위해 모드 반복 알고리즘으로 전환합니다. 해에 수렴하는 데 시간이 오래 걸릴 수 있는 모드 반복 알고리즘을 시도하는 대신 오류를 보고하려면 다음 명령을 사용하십시오: feature(''{2}'',0).</entry>
    <entry key="AlgLoopFrozenModesOscilationDetected" context="warning">모드 진동으로 인해 디폴트 알고리즘이 시간 {1}에서 수렴하지 않았기 때문에 블록 ''{0}''을(를) 포함하는 대수 루프의 해를 구하기 위해 모드 반복 알고리즘으로 전환합니다. 해에 수렴하는 데 시간이 오래 걸릴 수 있는 모드 반복 알고리즘을 시도하는 대신 오류를 보고하려면 다음 명령을 사용하십시오: feature(''{2}'',0).</entry>
    <entry key="AlgLoopFrozenModesTooManyModeChanges" context="warning">모드가 {0,number,integer}회 이상 변경되어 디폴트 알고리즘이 시간 {2}에서 수렴하지 않았기 때문에 블록 ''{1}''을(를) 포함하는 대수 루프의 해를 구하기 위해 모드 반복 알고리즘으로 전환합니다. 해에 수렴하는 데 시간이 오래 걸릴 수 있는 모드 반복 알고리즘을 시도하는 대신 오류를 보고하려면 다음 명령을 사용하십시오: feature(''{3}'',0).</entry>
    <entry key="AlgLoopNoSupportOfVarSizeSig" context="error">Block ''{0}'' is part of an algebraic loop and has variable-size inputs or outputs, which are not supported in algebraic loops.</entry>
    <entry key="AlgLoopMemoryAllocationError" context="error">Unable to allocate memory to solve the algebraic loop that contains ''{0}'' as one of {2,number,integer} total blocks in the loop. Eliminate the algebraic loop or reduce the number of algebraic variables ({1,number,integer}) in the loop.</entry>
    <entry key="AlgLoopTroubleInFixedStep">
      모델이 잘못 정의되어 있거나, 시스템 방정식에 해가 없거나, 대수 루프 솔버가 수치 문제로 인해 수렴하지 못하기 때문에 {2} 기반 알고리즘을 사용하여 시간 {1}에서 블록 ''{0}''을(를) 포함하는 대수 루프의 해를 구할 수 없습니다. 제안된 조치를 시도한 후에도 오류가 계속되면 모델이 잘못 정의된 것일 수 있습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{3}'','AlgebraicLoopSolver',''{4}'');&lt;/cmd&gt; &lt;txt&gt;대수 루프 솔버 알고리즘을 ''auto''로 변경하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{3}'');configset.highlightParameter(''{3}'','FixedStep');&lt;/cmd&gt; &lt;txt&gt;''고정 스텝 크기(기본 샘플 시간)'' 파라미터 값을 줄이십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;</entry>
    <entry key="AlgLoopTroubleInVariableStep">
      모델이 잘못 정의되어 있거나, 시스템 방정식에 해가 없거나, 대수 루프 솔버가 수치 문제로 인해 수렴하지 못하기 때문에 {2} 기반 알고리즘을 사용하여 시간 {1}에서 블록 ''{0}''을(를) 포함하는 대수 루프의 해를 구할 수 없습니다. 제안된 조치를 시도한 후에도 오류가 계속되면 모델이 잘못 정의된 것일 수 있습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{3}'','AlgebraicLoopSolver',''{4}'');&lt;/cmd&gt; &lt;txt&gt;대수 루프 솔버 알고리즘을 ''auto''로 변경하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{3}'');configset.highlightParameter(''{3}'','RelTol');&lt;/cmd&gt; &lt;txt&gt;솔버가 더 작은 시간 스텝을 갖도록 ''Relative tolerance'' 파라미터 값을 줄이십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
      
    </entry>
    <entry key="SetAlgebraicLoopSolverToAutoForBlock">set_param(''{0}'', 'Solver', 'auto');</entry>
    <entry key="AlgLoopTroubleInFixedStepWithAlgebraicConstraintBlock">
      Unable to solve the algebraic loop that contains block ''{0}'' at time {1} using the {2}-based algorithm because the model is ill-defined, the system equations do not have a solution, or numerical issues prevented the algebraic loop solver from converging. If the error persists after trying the suggested actions, the model is likely ill-defined.
      &lt;actions exclusiveFixIts="yes"&gt;
      &lt;action type="fixit"&gt;
      &lt;cmd&gt;{3}&lt;/cmd&gt;
      &lt;txt&gt;Change the algebraic loop solver algorithm to "auto".&lt;/txt&gt;
      &lt;/action&gt;
      &lt;action type="suggestion"&gt;
      &lt;cmd&gt;load_system(''{4}'');configset.highlightParameter(''{4}'','FixedStep');&lt;/cmd&gt;
      &lt;txt&gt;Reduce the ''Fixed-step size (fundamental sample time)'' parameter value.&lt;/txt&gt;
	  &lt;/action&gt;
      &lt;/actions&gt;</entry>
    <entry key="AlgLoopTroubleInVariableStepWithAlgebraicConstraintBlock">
      Unable to solve the algebraic loop that contains block ''{0}'' at time {1} using the {2}-based algorithm because the model is ill-defined, the system equations do not have a solution, or numerical issues prevented the algebraic loop solver from converging. If the error persists after trying the suggested actions, the model is likely ill-defined.
      &lt;actions exclusiveFixIts="yes"&gt;
      &lt;action  type="fixit"&gt;
      &lt;cmd&gt;{3}&lt;/cmd&gt;
      &lt;txt&gt;Change the algebraic loop solver algorithm to ''auto''.&lt;/txt&gt;
      &lt;/action&gt;
      &lt;action type="suggestion"&gt;
      &lt;cmd&gt;load_system(''{4}'');configset.highlightParameter(''{4}'','RelTol');&lt;/cmd&gt;
      &lt;txt&gt;Reduce the ''Relative tolerance'' parameter value so that the solver takes smaller time steps.&lt;/txt&gt;
      &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="AlgLoopTroubleInFixedStepNoSolverSwitch">
      모델이 잘못 정의되어 있거나, 시스템 방정식에 해가 없거나, 대수 루프 솔버가 수치 문제로 인해 수렴하지 못하기 때문에 {2} 기반 알고리즘을 사용하여 시간 {1}에서 블록 ''{0}''을(를) 포함하는 대수 루프의 해를 구할 수 없습니다. 제안된 조치를 시도한 후에도 오류가 계속되면 모델이 잘못 정의된 것일 수 있습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{2}'');configset.highlightParameter(''{2}'','FixedStep');&lt;/cmd&gt; &lt;txt&gt;''고정 스텝 크기(기본 샘플 시간)'' 파라미터 값을 줄이십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
      
    </entry>
    <entry key="AlgLoopTroubleInVariableStepNoSolverSwitch">
      모델이 잘못 정의되어 있거나, 시스템 방정식에 해가 없거나, 대수 루프 솔버가 수치 문제로 인해 수렴하지 못하기 때문에 {2} 기반 알고리즘을 사용하여 시간 {1}에서 블록 ''{0}''을(를) 포함하는 대수 루프의 해를 구할 수 없습니다. 제안된 조치를 시도한 후에도 오류가 계속되면 모델이 잘못 정의된 것일 수 있습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{2}'');configset.highlightParameter(''{2}'','RelTol');&lt;/cmd&gt; &lt;txt&gt;솔버가 더 작은 시간 스텝을 갖도록 ''상대 허용오차'' 파라미터 값을 줄이십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="AlgLoopTroubleInFixedStepWithAlgebraicConstraintBlockNoSolverSwitch">
      Unable to solve the algebraic loop that contains block ''{0}'' at time {1} using the {2}-based algorithm because the model is ill-defined, the system equations do not have a solution, or numerical issues prevented the algebraic loop solver from converging. If the error persists after trying the suggested actions, the model is likely ill-defined.
      &lt;actions exclusiveFixIts="yes"&gt;
      &lt;action type="suggestion"&gt;
      &lt;cmd&gt;load_system(''{2}'');configset.highlightParameter(''{2}'','FixedStep');&lt;/cmd&gt;
      &lt;txt&gt;Reduce the ''Fixed-step size (fundamental sample time)'' parameter value.&lt;/txt&gt;
      &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="AlgLoopTroubleInVariableStepWithAlgebraicConstraintBlockNoSolverSwitch">
      모델이 잘못 정의되어 있거나, 시스템 방정식에 해가 없거나, 대수 루프 솔버가 수치 문제로 인해 수렴하지 못하기 때문에 {2} 기반 알고리즘을 사용하여 시간 {1}에서 블록 ''{0}''을(를) 포함하는 대수 루프의 해를 구할 수 없습니다. 제안된 조치를 시도한 후에도 오류가 계속되면 모델이 잘못 정의된 것일 수 있습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{2}'');configset.highlightParameter(''{2}'','RelTol');&lt;/cmd&gt; &lt;txt&gt;솔버가 더 작은 시간 스텝을 갖도록 ''상대 허용오차'' 파라미터 값을 줄이십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="AlgLoopsDisabled">"대수 루프" 파라미터 값이 대수 루프 솔버를 비활성화하는 ''error''이므로 모델 ''{0}''에서 대수 루프의 해를 구할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{0}'');configset.highlightParameter(''{0}'','AlgebraicLoopMsg');&lt;/cmd&gt; &lt;txt&gt;''대수 루프'' 파라미터 값을 ''warning'' 또는 ''none''으로 변경하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
	</entry>
    <entry key="AlgStateNotFinite">블록 "{0}"을(를) 포함하는 대수 루프에 있는 대수 변수에 대해 시간 {1}에서 Inf 또는 NaN 값이 계산되었으며 이는 시스템 방정식에 특이점이 있음을 나타낼 수 있습니다. "상대 허용오차" 또는 "고정 스텝 크기(기본 샘플 시간)" 파라미터 값을 줄여 솔버가 취하는 스텝 크기를 줄여 보거나 대수 루프 변수 값에 대한 초기 추측값을 조정하십시오.</entry>
    <entry key="AlgebraicLoopsNotSupportedInRTWGEN">대수 루프가 포함된 모델에 대해서는 코드 생성이 지원되지 않습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;모델에서 대수 루프를 강조 표시하려면 Simulink.BlockDiagram.getAlgebraicLoops 함수를 사용하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;"코드 생성 및 시뮬레이션을 위한 출력 메서드와 업데이트 메서드의 결합" 파라미터를 지우십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="AmbiguousCRLRegisteredType">코드 대체 라이브러리에서 ''{0}'' 유형의 여러 정의가 발견되었습니다. 이 유형에 대해 하나의 정의를 제공하십시오.</entry>
    <entry key="AmbiguousCRLAndSimDataDictType">유형 ''{0}''이(가) 모호합니다. 이름이 동일한 다른 유형이 Simulink 또는 데이터 사전에 이미 존재합니다. 이 유형에 대해 하나의 정의를 제공하십시오.</entry>
    <entry key="ApplicationInvalid">지정된 애플리케이션이 유효하지 않음</entry>
    <entry key="ArtificialAlgLoopModelRefNote">대수 루프 내에서 참조된 모델 각각에 대해 ''인위적 대수 루프 발생 최소화'' 모델 파라미터를 선택하면 이 대수 루프가 해결될 수도 있습니다.</entry>
    <entry key="ArtificialAlgLoopNote">루프 내에서 하나 이상의 Atomic Subsystem 및 Enabled Subsystem에 대해 ''인위적 대수 루프 발생 최소화'' 블록 파라미터를 선택하거나 이 루프 내에서 참조된 모델에 대해 "대수 루프 발생 최소화" 모델 구성 파라미터를 선택하면 이 대수 루프가 해결될 수도 있습니다.
	</entry>
    <entry key="ArtificialAlgLoopSubsystemNote">루프 내에서 하나 이상의 Atomic Subsystem 및 Enabled Subsystem에 대해 "인위적 대수 루프 발생 최소화" 블록 파라미터를 선택하면 이 대수 루프가 해결될 수도 있습니다.</entry>
    <entry key="AsyncGlobalDSM">In model ''{0}'', one or more of the blocks that reference a global data store defined by the global Simulink.Signal object ''{1}'' are configured to execute in an asynchronous task. Global data stores accessed within a model must all execute in a single, periodic task.</entry>
    <entry key="AsyncRateTransBlkHasInvalidDst">Rate Transition 블록 ''{0}''을(를) 대상 ''{1}''에 연결할 수 없습니다. 대상 블록이 우선 순위가 Rate Transition 블록 출력 샘플 시간 우선 순위와 다른 비동기식으로 실행된 함수 호출 블록에 있습니다.</entry>
    <entry key="AsyncRateTransBlkHasInvalidMultipleDsts">Rate Transition 블록 ''{0}''에 대상이 여러 개 있습니다. 모든 대상은 동일한 샘플 시간을 가지거나 우선 순위가 동일한 비동기식으로 실행된 함수 호출 블록에 있어야 합니다.</entry>
    <entry key="AsyncRateTransBlkHasInvalidMultipleSrcs">The Rate Transition block ''{0}'' has multiple asynchronously executed sources having different sample times. All asynchronously executed sources must have the same sample time.</entry>
    <entry key="BackPropDoesNotSupportND">{0,number,integer}차원 신호를 블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;에서 블록 ''{4}''의 &lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;{3,number,integer}번 출력 포트&lt;/sldiag&gt;로 전파할 수 없습니다. 이 두 번째 블록은 전체적으로 또는 해당 현재 구성 내에서 2차원보다 큰 신호를 받지 않습니다.</entry>
    <entry key="BackPropDoesNotSupportNDCompSig">하나 이상의 {0,number,integer}차원 신호를 포함하는 복합 신호를 블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;에서 블록 ''{4}''의 &lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;{3,number,integer}번 출력 포트&lt;/sldiag&gt;로 전파할 수 없습니다. 이 두 번째 블록은 전체적으로 또는 해당 현재 구성 내에서 2차원보다 큰 신호를 받지 않습니다.</entry>
    <entry key="BadFeedbackConn">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에서 시작하는 하나 이상의 가상 블록이 포함된 피드백 연결이 잘못됨</entry>
    <entry key="BusSourcePropBadFeedbackConn">Erroneous feedback connection involving one or more virtual blocks starting at &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}''</entry>
    <entry key="AutoInsertedBlocksDataListAssignmentNotAllowed">블록 데이터 목록을 수정할 수 없으므로 인덱스 참조 값 할당이 지원되지 않습니다.</entry>
    <entry key="AutoInsertedBlockDataListInvalidBlockName">Invalid block name specified.</entry>
    <entry key="AutoInsertedBlockDataListContainerNotFound">Simulink.AutoInsertedBlockDataList 객체를 불러올 때 컨테이너 ''{1}''에 대한 {0}을(를) 찾을 수 없습니다. 올바른 모델을 열고 객체를 다시 불러오십시오.</entry>
    <entry key="AutoInsertedBlockDataBlockDiagramObjectNotFound">MAT 파일에서 Simulink.AutoInsertedBlockData 객체를 불러오는 동안 이 객체의 자동 삽입을 담당하는 블록 ''{0}''을(를) 찾을 수 없습니다. 올바른 모델을 열고 객체를 다시 불러오십시오.</entry>
    <entry key="BadInportNum">시스템 ''{0}''에 {1,number,integer}번 입력 포트에 대응하는 블록이 누락되었습니다. 포트 번호는 1부터 연속적으로 지정되어야 합니다.</entry>
    <entry key="BadOutportNum">시스템 ''{0}''에 {1,number,integer}번 출력 포트에 대응하는 블록이 누락되었습니다. 포트 번호는 1부터 연속적으로 지정되어야 합니다.</entry>
    <entry key="BadPropDimsInfoNoUnifyIO">Simulink는 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에서 ''{3}''의 &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 출력 포트&lt;/sldiag&gt;로 차원 정보를 전파할 수 없습니다. ''{5}''의 입력 차원 '{'{4}'}'의 차원이 다중화된 출력 신호 '{'{6}'}'과(와) 일치하지 않습니다.</entry>
    <entry key="BadPropDimsInfoNoUnifyOI">Simulink cannot propagate dimension information from &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' to &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;input port {2,number,integer}&lt;/sldiag&gt; of ''{3}''. The dimension of the multiplexed output signal '{'{4}'}' does not match the input dimension '{'{5}'}' of ''{6}''.</entry>
    <entry key="BadPropDimsInfoUnifyOI">''{3}''의 &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 입력 포트&lt;/sldiag&gt;의 입력 차원과 일치하도록 Simulink가 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 있는 다중화된 신호 차원을 통일할 수 없습니다. 특히 Simulink는 {5}과(와) 일치하도록 '{'{4}'}'을(를) 통일할 수 없습니다. 결과적으로 Simulink는 ''{7}''의 &lt;sldiag objui="outport" objparam="{6,number,integer}" objname="{7}"&gt;{6,number,integer}번 출력 포트&lt;/sldiag&gt;에 있는 차원 정보를 ''{9}''의 &lt;sldiag objui="inport" objparam="{8,number,integer}" objname="{9}"&gt;{8,number,integer}번 입력 포트&lt;/sldiag&gt;로 전파할 수 없습니다.</entry>
    <entry key="BadPropDimsInfoUnifyMatrixOI"> 입력 신호 중 하나 이상이 행렬 유형이므로, Simulink가 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 있는 다중화된 신호에 대한 통합 차원을 결정할 수 없습니다. 특히 Simulink는 '{'{2}'}'을(를) 통일할 수 없습니다. 결과적으로 Simulink는 ''{4}''의 &lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;{3,number,integer}번 출력 포트&lt;/sldiag&gt;에 있는 차원 정보를 ''{6}''의 &lt;sldiag objui="inport" objparam="{5,number,integer}" objname="{6}"&gt;{5,number,integer}번 입력 포트&lt;/sldiag&gt;로 전파할 수 없습니다.</entry>
    <entry key="BdNotCompiled">모델 ''{0}''에 프로그래밍 방식으로 액세스하려면 먼저 이 모델을 컴파일해야 합니다.</entry>
    <entry key="BdCommandDisallowedDuringSim">모델 ''{0}''이(가) 시뮬레이션되는 중이므로 프로그래밍 인터페이스를 통해 명령 ''{1}''을(를) 처리할 수 없습니다.</entry>
    <entry key="BdSettingChangeNotAllowed">Cannot change parameter ''{0}'' of model ''{1}'' when it is being compiled or while the simulation is running.</entry>
    <entry key="BdSimRunningAlready">블록 다이어그램 ''{0}''의 시뮬레이션이 현재 실행 중입니다. 두 번째 시뮬레이션을 시작할 수 없습니다.</entry>
    <entry key="BdWriteCloseError">{0}을(를) 처리하는 중 파일 닫기 오류가 발생했습니다. 오류 코드는 {1,number,integer}({2})입니다.</entry>
    <entry key="BdWriteInvBlockParamType">오류. 파라미터 유형이 유효하지 않은 ''{1}'' 호출 ssWriteRTWParameters에 S-Function ''{0}''의 mdlRTW가 있습니다.</entry>
    <entry key="BdWriteInvIndentLevel">{0}을(를) 쓰는 동안 발견된 레코드 시작 '''{''' 또는 종료 '''}''' 문자의 수가 일치하지 않습니다.</entry>
    <entry key="BdWriteMxArrayFailure">메서드 BdWriteMxArray가 실패함: ''{0}''</entry>
    <entry key="BdWriteParamInvComplexSig">파라미터 ''{0}''은(는) 실수여야 합니다. 복소수 파라미터를 쓰려면 SS_WRITE_VALUE_DTYPE_VECT를 사용하십시오.</entry>
    <entry key="BdWriteParamInvParamValue">{0} 파라미터의 ''{1}'' 값을 ''{2}.rtw'' 파일에 쓰는 중 오류가 발생했습니다.</entry>
    <entry key="BdWriteParamNameTooLong">파라미터 이름의 길이({0})는 {1,number,integer}자보다 작아야 합니다.</entry>
    <entry key="BdWriteParamNonBuiltInDType">MATLAB 데이터형이 아닌 파라미터 ''{0}''은(는) 쓸 수 없습니다.</entry>
    <entry key="BlkIgnoringUsedAsDStateFlag">''{0}''의 이산 상태가 기록되지 않습니다. 해당 데이터형 ''{1}''이(가) 내장형이 아니기 때문입니다.</entry>
    <entry key="BlkInAlgLoopErr">''{0}''에 대수 루프 오류가 있음\n</entry>
    <entry key="BlkInAlgLoopErrWithInfo">다음 블록을 포함하는 대수 루프에 오류가 있습니다: ''{0}''{1}{2}\n</entry>
    <entry key="BlkInLoop">''{0}'' is involved in the loop.</entry>
    <entry key="BlkInTrigSSLoop">''{1}''의 입력 포트({0})가 Triggered Subsystem 및/또는 트리거된 Model 블록을 포함하는 루프에 연결되어 있습니다.</entry>
    <entry key="BlkWithFcnCallRetValInLoop">Simulink has inserted an implicit signal conversion block after the inport blocks {0} of subsystem ''{1}'' to ensure that the corresponding signals are contiguous in memory. This may cause a one-step delay for the function-call initiator block(s) {2} that are observing these signals as return values from the function-call subsystem(s) they are calling. To avoid this condition, ensure that each function-call return value originates from a single block in the function-call subsystem being called.</entry>
    <entry key="BlkWithPortInLoop">''{1}''의 입력 포트({0})가 루프에 연결되어 있습니다.</entry>
    <entry key="BlkWithPortInLoopWithConstTs">''{1}''의 입력 포트({0})가 루프에 연결되어 있습니다. 이 블록이 상수 샘플 시간을 갖습니다.</entry>
    <entry key="BlkWithPortInLoopWithConstTsInside">''{1}''의 입력 포트({0})가 루프에 연결되어 있습니다. 이 Subsystem 블록이 상수 샘플 시간을 갖거나, 이 서브시스템 내에 상수 샘플 시간을 갖는 블록이 있습니다.</entry>
    <entry key="BlkWithPortInLoopWithAsyncTs">''{1}''의 입력 포트({0})가 루프에 연결되어 있습니다. 이 블록이 비동기 샘플 시간을 갖습니다.</entry>
    <entry key="BlkWithPortInLoopWithMultiTs">''{1}''의 입력 포트({0})가 루프에 연결되어 있습니다. 이 블록이 여러 개의 샘플 시간을 갖습니다.</entry>
    <entry key="BlkWithParamWriteInLoop">Parameter Writer 블록이거나 Parameter Writer 블록의 부모 서브시스템 블록인 ''{0}''을(를) 포함하고 있으면서, Parameter Writer 블록에 의해 파라미터가 작성되는 블록 ''{1}''을(를) 포함하고 있어서 유효하지 않은 대수 루프입니다.</entry>
    <entry key="Blk_Support_IR_Conditional_Init">더미 메시지</entry>
    <entry key="BlockBusObjectTsClash">The block ''{0}'' specifies conflicting sample time information: the block specifies bus object ''{1}'', whose elements define the block''s sample time to be {2}, yet the block''s Sample time property specifies {3}.  Either set the sample time of the block, or the object''s elements to inherited (-1).</entry>
    <entry key="BlockCStateArrayBoundsError">''{2}''에서 S-Function ''{1}''의 ''mdl{0}'' 함수를 실행한 후 모델 전체에 적용되는 연속 상태 배열이 손상되었습니다. 이 손상은 주로 S-Function의 소스 코드에 있는 오류(즉, S-Function의 연속 상태 포인터가 할당된 제한을 넘어 증가/감소했음) 때문에 발생합니다. 이러한 유형의 메모리 오류가 발생하면 MATLAB이 비정상적으로 종료되거나 잘못된 시뮬레이션 결과가 생성될 수 있습니다.</entry>
    <entry key="BlockDWorkArrayBoundsError">''{2}''에서 S-Function ''{1}''의 ''mdl{0}'' 함수를 실행한 후 모델 전체에 적용되는 작업 벡터 배열(DSTATES, RWORK, IWORK, PWORK, DWORK 및 MODE 벡터 포함)이 손상되었습니다. 이 손상은 주로 S-Function의 소스 코드에 있는 오류(즉, S-Function의 작업 벡터 포인터 중 하나가 할당된 제한을 넘어 증가/감소했음) 때문에 발생합니다. 이러한 유형의 메모리 오류가 발생하면 MATLAB이 비정상적으로 종료되거나 잘못된 시뮬레이션 결과가 생성될 수 있습니다.</entry>
    <entry key="BlockIO_Complexity">블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 {0} 입력 신호를 해당 {3} {4,number,integer}번 출력 포트가 덮어쓸 수 없습니다. 두 신호의 실수/복소수 여부가 같아야 하기 때문입니다.</entry>
    <entry key="BlockIO_Datatypes">블록 ''{3}''의 &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 신호 소스 블록 ''{1}''의 {0,number,integer}번 출력 포트를 해당 {4,number,integer}번 출력 포트가 덮어쓸 수 없습니다. 신호의 데이터형이 서로 다르기 때문입니다.</entry>
    <entry key="BlockIO_DifferentOutportReuse">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 입력 신호를 해당 {2,number,integer}번 출력 포트가 덮어쓰지 않았습니다. 대신, {3,number,integer}번 출력 포트가 덮어썼습니다.</entry>
    <entry key="BlockIO_GlobalLocal">블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 {0} 입력 신호를 해당 {3} {4,number,integer}번 출력 포트가 덮어쓸 수 없습니다. 두 포트의 범위가 동일해야 합니다.</entry>
    <entry key="BlockIO_GroundBlock">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 입력 신호를 해당 {2,number,integer}번 출력 포트가 덮어쓸 수 없습니다. 이 신호 소스가 GROUND 블록이기 때문입니다.</entry>
    <entry key="BlockIO_InputSignalGreaterThanOutput">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 입력 신호를 해당 {2,number,integer}번 출력 포트가 덮어쓸 수 없습니다. 신호의 크기가 출력 포트보다 크기 때문입니다. 이는 제한 사항이며 이후 릴리스에서 해결될 예정입니다.</entry>
    <entry key="BlockIO_InputSignalIsNoncontiguous">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 입력 신호를 해당 {2,number,integer}번 출력 포트가 덮어쓸 수 없습니다. 이 신호가 여러 출력 포트에서 나오기 때문입니다.</entry>
    <entry key="BlockIO_InputSignalIsRootInport">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 입력 신호를 해당 {2,number,integer}번 출력 포트가 덮어쓸 수 없습니다. 이 신호 소스가 ROOT 포트이기 때문입니다.</entry>
    <entry key="BlockIO_InputSignalSmallerThanOutput">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 입력 신호를 해당 {2,number,integer}번 출력 포트가 덮어쓸 수 없습니다. 신호의 크기가 출력 포트보다 작기 때문입니다.</entry>
    <entry key="BlockIO_InputSignalStillUsed">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 신호 값을 해당 {2,number,integer}번 출력 포트가 덮어쓸 수 없습니다. 이 신호 값이 아직 실행되지 않은 블록 ''{4}''의 &lt;sldiag objui="inport" objparam="{3,number,integer}" objname="{4}"&gt;{3,number,integer}번 입력 포트&lt;/sldiag&gt;에 여전히 필요하기 때문입니다.</entry>
    <entry key="BlockIO_MarkedNonReusable">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 입력 신호를 해당 {2,number,integer}번 출력 포트가 덮어쓸 수 없습니다. 입력 신호가 재사용할 수 없는 것으로 표시되었기 때문입니다.</entry>
    <entry key="BlockIO_NoBufferReuse">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 입력 신호를 해당 {2,number,integer}번 출력 포트가 덮어쓸 수 없습니다. 이 블록 다이어그램에 대해 버퍼 재사용 최적화가 꺼져 있기 때문입니다.</entry>
    <entry key="BlockIO_SignalSourceGreaterThanOutput">블록 ''{3}''의 &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 신호 소스 블록 ''{1}''의 {0,number,integer}번 출력 포트를 해당 {4,number,integer}번 출력 포트가 덮어쓸 수 없습니다. 포트의 크기가 출력 포트의 크기보다 크기 때문입니다. 이는 제한 사항이며 이후 릴리스에서 해결될 예정입니다.</entry>
    <entry key="BlockIO_SignalSourceSmallerThanOutput">블록 ''{3}''의 &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 신호 소스 블록 ''{1}''의 {0,number,integer}번 출력 포트를 해당 {4,number,integer}번 출력 포트가 덮어쓸 수 없습니다. 포트의 크기가 출력 포트의 크기보다 작기 때문입니다.</entry>
    <entry key="BlockIO_Systems">블록 ''{3}''의 &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 신호 소스 블록 ''{1}''의 {0,number,integer}번 출력 포트를 해당 {4,number,integer}번 출력 포트가 덮어쓸 수 없습니다. 신호가 서로 다른 시스템에 있기 때문입니다.</entry>
    <entry key="BlockIO_AlgebraicLoop">블록 ''{3}''의 &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 신호 소스 블록 ''{1}''의 {0,number,integer}번 출력 포트를 해당 {4,number,integer}번 출력 포트가 덮어쓸 수 없습니다. 대수 루프의 일부이기 때문입니다.</entry>
    <entry key="BlockIO_Testpoint">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 입력 신호를 해당 {2,number,integer}번 출력 포트가 덮어쓸 수 없습니다. 신호 중 적어도 하나가 테스트 지점이기 때문입니다.</entry>
    <entry key="BlockIO_Logging">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 입력 신호를 해당 {2,number,integer}번 출력 포트가 덮어쓸 수 없습니다. 신호 중 적어도 하나가 현재 기록 중이기 때문입니다.</entry>
    <entry key="BlockIO_UnequalSampleTimes">블록 ''{3}''의 &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 신호 소스 블록 ''{1}''의 {0,number,integer}번 출력 포트를 해당 {4,number,integer}번 출력 포트가 덮어쓸 수 없습니다. 신호의 샘플 시간이 서로 다르기 때문입니다.</entry>
    <entry key="BlockIO_UnknownReason">알 수 없는 이유로 인해 블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 입력 신호를 해당 {2,number,integer}번 출력 포트가 덮어쓸 수 없습니다.</entry>
    <entry key="BlockJacobianMethodButNoConfig">''{0}''이(가) 야코비 방법을 구현하지만 DoPostPropagationTasks 함수에 해당 야코비 행렬 차원을 구성하지 못했습니다.</entry>
    <entry key="BlockJacobianNumElementsOverflow">The Jacobian elements number of ''{0}'' exceeds {1, number, integer}, the maximum Jacobian elements allowed in memory.</entry>
    <entry key="ModelJacobianNumElementsOverflow">모델 ''{0}''의 야코비 행렬 요소 개수가 메모리에 허용된 최대 야코비 행렬 요소 개수인 {1, number, integer}을(를) 초과합니다.</entry>
    <entry key="BlockJacobianMethodButNoIrJc">''{0}''이(가) 야코비 방법을 구현하지만 메서드 JacobianIrJc에서 해당 야코비 행렬 구조 (Ir, Jc)를 초기화하지 못했습니다.</entry>
    <entry key="BlockNotFoundMessage">라이브러리 블록 ''{0}''을(를) 찾을 수 없음</entry>
    <entry key="BlockNotFoundTitle">블록을 찾을 수 없음</entry>
    <entry key="BlockOutputArrayBoundsError">''{2}''에서 S-Function ''{1}''의 ''mdl{0}'' 함수를 실행한 후 모델 전체에 적용되는 블록 출력 신호 배열이 손상되었습니다. 이 손상은 주로 S-Function의 소스 코드에 있는 오류(즉, S-Function의 출력 포트 신호 포인터 중 하나가 할당된 제한을 넘어 증가/감소했음) 때문에 발생합니다. 이러한 유형의 메모리 오류가 발생하면 MATLAB이 비정상적으로 종료되거나 잘못된 시뮬레이션 결과가 생성될 수 있습니다.</entry>
    <entry key="BlockOutputInfNanDetectedError">블록 ''{0}''이(가) {4} 시간 스텝 {5}에서 &lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;{3,number,integer}번 출력 포트&lt;/sldiag&gt;의 요소 {2,number,integer}에 대해 ''{1}''을(를) 출력합니다 &lt;actions exclusiveFixIts="no"&gt; &lt;action type="suppression"&gt;&lt;/action&gt; &lt;/actions&gt;</entry>
    <entry key="BlockOutputBufferExceedsMaxlimit">블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에서 나오는 문자열 신호가 시간 스텝 {2}에서 잘렸습니다. 신호의 길이가 상한인 {3,number,integer}자를 초과합니다. &lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="BlockOutputBufferOverflowDetectedError">블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에서 나오는 문자열 신호가 시간 스텝 {2}에서 잘렸습니다. 신호의 길이가 출력 데이터형에 지정된 최대 길이인 {3,number,integer}자를 초과했습니다. 출력 string 데이터형의 최대 길이를 늘려 보십시오. &lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="BlockOutputStringContainsNullChar">블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에서 나오는 문자열 신호가 null 문자 ''char(0)''을 지원하지 않습니다.</entry>
    <entry key="CANNOT_ACCESS_BUS">''{1}''의 버스 신호의 ''{0}''에 액세스할 수 없음</entry>
    <entry key="CannotDeleteBusySystem">콜백 또는 파라미터 평가를 처리하는 동안에는 ''{0}''을(를) 삭제할 수 없습니다.</entry>
    <entry key="ParamEvalDelete">Cannot delete ''{0}'' while it is evaluating parameter.</entry>
    <entry key="CallbackDelete">콜백 내에 있는 동안에는 ''{0}''을(를) 삭제할 수 없음</entry>
    <entry key="CallbackEvalErr">{1} ''{2}''의 &lt;sldiag objui="callback" objparam="{0}"&gt;&lt;/sldiag&gt; 콜백을 실행하는 중 오류가 발생했습니다. \n콜백 문자열은 ''{3}''입니다</entry>
    <entry key="CallbackRecursion">이전 콜백이 아직 실행 중인데 ''{1}''의 {0} 콜백을 다시 호출하려고 합니다.</entry>
    <entry key="CombineOutputUpdateFcnMinorTimeSteps">The output(s) read after the base-rate model step reflects intervening minor time steps. To observe data that is a snapshot of output(s) at major time steps, do one of the following:\n * Place a Zero-Order Hold block before the continuous output port ''{0}''. \n * Clear &lt;sldiag objui="configset" objparam="CombineOutputUpdateFcns"&gt;Single output/update function&lt;/sldiag&gt;, and read model output values after model_output call and before model_update call.</entry>
    <entry key="CannotChangeBlkParamsInsideParameterizedForEachSS">고속 액셀러레이터 모드에서 시뮬레이션이 실행되는 동안 For Each Subsystem ''{2}'' 내에 있는 블록 ''{1}''의 파라미터 ''{0}''을(를) 변경할 수 없습니다. 이는 서브시스템이 하나 이상의 분할된 마스크 파라미터를 포함하기 때문입니다.</entry>
    <entry key="CannotChangeBlkParamsInPFESSFromPToNP"> Parameter ''{0}'' of block ''{1}'' must reference at least one For Each subsystem partitioned mask parameter during simulation. This is because the parameter value was configured to directly or indirectly reference one or more partitioned mask parameters of a For Each subsystem.</entry>
    <entry key="CannotChangeBlkParamsInPFESSFromNPToP">Cannot change parameter ''{0}'' of block ''{1}'' to a value that directly or indirectly references a partitioned mask parameter of a For Each subsystem during simulation. This is because this block parameter value was configured not to reference any For Each subsystem partitioned mask parameter.</entry>
    <entry key="CannotSetBlkParamsToPartitionedMaskVarInPFESS">Cannot set parameter ''{0}'' of block ''{1}'' to a value that references a partitioned mask parameter of a For Each subsystem. This parameter does not support referencing partitioned mask parameters.</entry>
    <entry key="CannotSetAnonymousBlkParamsToPartitionedMaskVarInPFESS">Block ''{0}'' cannot reference partitioned mask parameters of For Each subsystems.</entry>
    <entry key="CannotSetBlkParamsInMultiRateDelayBlockInPFESS">Delay 블록 ''{1}''의 파라미터 ''{0}''을(를) For Each Subsystem의 분할된 마스크 파라미터를 참조하는 값으로 설정할 수 없습니다. Delay 블록은 멀티레이트 모드에서 분할된 마스크 파라미터를 참조하는 것을 지원하지 않습니다.</entry>
    <entry key="CannotSetBlkParamsInSFunctionWithoutMdlProcessParameters">Block ''{0}'' does not support referencing partitioned mask parameters in For-Each subsystem ''{1}'' because function mdlProcessParameters is not defined in this S-Function.</entry>
    <entry key="CannotSetBlkParamsInTLCSfcnBlockInPFESS">Cannot set parameter ''{0}'' of block ''{1}'' to a value that references a partitioned mask parameter. S-Functions generated through TLC do not support referencing partitioned mask parameters.</entry>
    <entry key="CannotSetMdlRefArgToPartitionedMaskVarInRTW">Cannot set model argument ''{0}'' of block ''{1}'' to a value that references a partitioned mask parameter during code generation when ''Configuration Parameters &gt; Code Generation &gt; Identifiers &gt; Generate scalar inlined parameters as'' is set to ''Macros''. Consider changing the parameter to ''Literals''.</entry>
    <entry key="CannotReferenceTransformedTunableVarInPFESS">Cannot set parameter ''{0}'' of block ''{1}'' to a value that references a partitioned mask parameter of For Each subsystem ''{2}''. This parameter is a transformation of one or more dialog parameters. Transformed parameters do not support referencing a partitioned mask parameter of a For Each subsystem. To avoid parameter transformation, consider explicitly casting the expression for mask parameter ''{3}'' of block ''{4}'' to data type ''{5}'' via ''{5}(...)'' expression.</entry>
    <entry key="CannotReferenceTransformedTunableVarInPFESSForUserSFcn">블록 ''{1}''의 파라미터 ''{0}''을(를) For Each Subsystem의 분할된 마스크 파라미터를 참조하는 값으로 설정할 수 없습니다. 이 파라미터는 하나 이상의 대화 상자 파라미터가 변환된 것입니다. 변환된 파라미터는 For Each Subsystem의 분할된 마스크 파라미터를 참조하는 것을 지원하지 않습니다.</entry>
    <entry key="PartitionedStructParamNotAllowed">Mask parameter ''{0}'' of For Each subsystem ''{1}'' cannot be partitioned because it evaluates to a non-numeric value or structure containing non-numeric fields.</entry>
    <entry key="CannotChangeConstTsBlks">샘플 시간이 상수(inf)이므로 시뮬레이션 실행 중에 ''{1}''의 파라미터 ''{0}''을(를) 변경할 수 없습니다. 상수 샘플 시간은 일반적으로 ''구성 파라미터 &gt; 코드 생성 &gt; 최적화 &gt; 디폴트 파라미터 동작''이 ''인라인''으로 설정된 경우 발생합니다.</entry>
    <entry key="CannotChangePortFrameData">S-function method {0} cannot change the frame data of {1} port {2,number,integer} of ''{3}'' once the frame data has been set</entry>
    <entry key="CannotChangePostCompileVirtBlks">시뮬레이션이 실행 중일 때는 ''{1}''의 파라미터 ''{0}''을(를) 변경할 수 없습니다. 블록이 시뮬레이션을 위해 최적화되었으므로 가상으로 설정되었습니다</entry>
    <entry key="CannotDisplayFrameSignal">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에서 발생하는 선택된 신호는 프레임 기반 신호이므로 표시할 수 없음</entry>
    <entry key="CannotDisplayWideFrameSignal">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 신호&lt;/sldiag&gt;에서 발생하는 선택된 신호는 프레임 크기가 1보다 큰 프레임 기반 신호이므로 표시할 수 없음</entry>
    <entry key="CannotEvaluateFloatingDuration">플로팅 스코프에 대한 [지속 시간] 필드는 양의 정수가 되는 유효한 MATLAB 표현식이어야 합니다. 디폴트 값 [자동]이 사용됩니다.</entry>
    <entry key="CannotEvaluateDWorkDimArg">파생된 파라미터를 나타내는 표현식 ''{0}''이(가) 스칼라가 아닙니다. 파생된 차원 인수로 지정된 파생된 파라미터는 double형 스칼라여야 합니다.</entry>
    <entry key="CannotExecuteTargDataMap">타깃 데이터 맵 파일 ''{0}{1}{2}''을(를) 실행할 수 없거나 이 파일이 존재하지 않습니다. \n타깃을 중지하고 {3} 실행 파일을 삭제한 다음 코드를 재빌드하고 다시 시도하십시오. 외부 모드를 실행하려면 빌드 디렉터리가 있어야 합니다</entry>
    <entry key="CannotHaveNDFrames">Cannot set port {0,number,integer} of ''{1}'' to be {2,number,integer} dimensional when this port is set to be frame-based. For a frame-based port, the number of dimensions must be 2</entry>
    <entry key="CannotHaveUnorientedFrames">Cannot set port {0,number,integer} of ''{1}'' to have one dimension when this port is set to be frame-based. For a frame-based port, the number of dimensions must be 2</entry>
    <entry key="CannotHaveUnsetOutputDimsMode">The dimension mode of the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is inherited. Whenever the dimension mode is set to either fixed or variable for all input ports, no output ports can have an inherited dimension mode.</entry>
    <entry key="CannotHaveUnsetOutputFrameData">''{0}''이(가) {1,number,integer}번 출력 포트에 대해 알 수 없는 프레임 상태를 가집니다. 모든 입력 포트가 알려진 프레임 상태를 갖는 경우 모든 출력 포트도 알려진 프레임 상태를 가져야 합니다</entry>
    <entry key="CannotPropFixedDimsModeForward">Simulink가 고정 크기 모드를 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에서 ''{3}''의 &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 입력 포트&lt;/sldiag&gt;로 전파할 수 없습니다. 이 입력 포트에는 가변 크기 모드가 필요합니다. ''{4}''을(를) 가변 크기 신호를 출력하는 블록으로 바꾸거나 ''{5}''을(를) 고정 크기 신호가 필요한 블록으로 바꾸십시오.</entry>
    <entry key="CannotPropFixedDimsModeForwardWithSource">Simulink가 고정 크기 모드를 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에서 ''{3}''의 &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 입력 포트&lt;/sldiag&gt;로 전파할 수 없습니다. 이 입력 포트에는 가변 크기 모드가 필요합니다. 고정 크기 모드는 ''{4}''에서 비롯됩니다. ''{5}''을(를) 가변 크기 신호를 출력하는 블록으로 바꾸거나 ''{6}''을(를) 고정 크기 신호가 필요한 블록으로 바꾸십시오.</entry>
    <entry key="CannotPropFrameDataBus">프레임 기반 요소를 갖는 버스 ''{0}''을(를) ''{2}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;로 전파할 수 없습니다. 이 입력 포트에는 샘플 기반 신호가 필요하기 때문입니다.</entry>
    <entry key="CannotPropFrameDataForward">Cannot propagate frame-based signal from &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' to &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;input port {2,number,integer}&lt;/sldiag&gt; of ''{3}'' because this input port expects a sample-based signal. Consider inserting an Unbuffer in the signal path.</entry>
    <entry key="CannotPropFrameDataForwardWithSource">Cannot propagate frame-based signal from &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' to &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;input port {2,number,integer}&lt;/sldiag&gt; of ''{3}'' because this input port expects a sample-based signal. The frame-based signal originates from ''{4}''.  Consider inserting an Unbuffer in the signal path.</entry>
    <entry key="CannotPropFrameDataWhenLatchingOutside">서브시스템 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{2}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;는 프레임 기반 신호를 받을 수 없습니다. 해당하는 Inport 블록 ''{2}''에 파라미터 '외부 신호를 지연시켜 입력 래치'가 선택되어 있기 때문입니다. </entry>
    <entry key="CannotPropFrameDataWhenLatchingOutsideForRootTrigger">The root input port ''{0}''
    cannot output a frame-based signal, because it has the parameter 'Latch by delaying outside signal' selected.
    Consider deselecting the 'Latch by delaying outside signal' or setting the Sampling mode to 'Sample based' by executing set_param(blk,'SamplingMode','Sample based'), where blk is the root input port handle.</entry>
    <entry key="CannotPropFrameDataWhenLatchingOutsideForTriggeredModelBlock">&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of the triggered Model block
    ''{1}'' cannot accept a frame-based signal, because the corresponding Inport block in the referenced model ''{2}'' has the parameter
    'Latch by delaying outside signal' selected. </entry>
    <entry key="CannotPropNonFrameDataForward">Cannot propagate sample-based signal from &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' to &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;input port {2,number,integer}&lt;/sldiag&gt; of ''{3}'' because this input port expects a frame-based signal. Consider inserting a Buffer or a Frame Conversion block in the signal path.</entry>
    <entry key="CannotPropNonFrameDataForwardWithSource">Cannot propagate sample-based signal from &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' to &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;input port {2,number,integer}&lt;/sldiag&gt; of ''{3}'' because this input port expects a frame-based signal. The sample-based signal originates from ''{4}''. Consider inserting a Buffer or a Frame Conversion block in the signal path.</entry>
    <entry key="CannotPropVariableDimsModeForward">Simulink가 가변 크기 모드를 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에서 ''{3}''의 &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 입력 포트&lt;/sldiag&gt;로 전파할 수 없습니다. 이 입력 포트에는 고정 크기 모드가 필요합니다. ''{4}''의 구성을 검토하여 다음 시나리오 중 하나에 해당하는지 확인하십시오: 1) 블록이 가변 크기 신호를 지원하지 않음 2) 블록이 가변 크기 신호를 지원하지만 이러한 신호에 맞게 블록을 구성해야 함.</entry>
    <entry key="CannotPropVariableDimsModeForwardWithSource">Simulink가 가변 크기 모드를 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에서 ''{3}''의 &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 입력 포트&lt;/sldiag&gt;로 전파할 수 없습니다. 이 입력 포트에는 고정 크기 모드가 필요합니다. 가변 크기 모드는 ''{4}''에서 비롯됩니다. ''{5}''의 구성을 검토하여 다음 시나리오 중 하나에 해당하는지 확인하십시오: 1) 블록이 가변 크기 신호를 지원하지 않음 2) 블록이 가변 크기 신호를 지원하지만 이러한 신호에 맞게 블록을 구성해야 함.</entry>
    <entry key="SimFcnInportDoesNotSupportVarDims">Unable to propagate the variable-size signal with finite upper bounds to the Inport block ''{0}'' of the Simulink Function block. Only fixed-size signals or unbounded variable-size signals are supported by the Inport block of the Simulink Function block.</entry>
    <entry key="SimFcnOutportDoesNotSupportVarDims">유한한 상한을 갖는 가변 크기 신호를 Simulink Function 블록의 Outport 블록 ''{0}''에서 전파할 수 없습니다. Simulink Function 블록의 Outport 블록에서는 고정 크기의 신호 또는 비유계 가변 크기 신호만 지원됩니다.</entry>
    <entry key="CannotUnifyDimsMode">Simulink cannot propagate the dimension mode from the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' to the &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;input port {2,number,integer}&lt;/sldiag&gt; of ''{3}''. One of the multiplexed signals at the output of the source has variable-size mode. This multiplexed signal has to be demultiplexed before Simulink can propagate it to the destination.</entry>
    <entry key="CannotUnifyFrameData">Cannot propagate frame data from &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' to &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;input port {2,number,integer}&lt;/sldiag&gt; of ''{3}''. One of the signals that is multiplexed into the signal at the output of the source contains frame-based data. This multiplexed signal has to be demultiplexed before it can be fed to the destination</entry>
    <entry key="CannotUploadTunTransformsOfDstType">타깃에서 파라미터를 업로드할 때 데이터형 ''{0}''을(를) 데이터형 ''{1}''(으)로 변환하는 중 오류가 발생함</entry>
    <entry key="CannotUseSetDefaultDimsFcn">''{0}'' cannot use ''set default dimension function''.</entry>
    <entry key="CantCmdlSimInExternalMode">sim 함수를 사용하여 시작되는 시뮬레이션에는 외부 모드 시뮬레이션이 지원되지 않습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{0}'','SimulationMode','Normal');&lt;/cmd&gt; &lt;txt&gt;표준 모드에서 시뮬레이션하도록 모델을 구성하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;</entry>
    <entry key="CantStepExternalMode">Cannot step external mode</entry>
    <entry key="ChangePortToBlockSampleTimes">Cannot access block-based sample time in ''{0}'' because this block has been set to use port-based sample times</entry>
    <entry key="ExclusiveSignalMustHaveSameStorageClass">Variant Subsystem 내에서 동일한 식별자를 갖는 신호는 스토리지 클래스가 동일해야 합니다.</entry>
    <entry key="ExclusiveSignalOnInport">Variant Subsystem의 서로 다른 두 개의 선택지 인포트에 동일한 signal 객체를 사용하는 것은 허용되지 않습니다. 신호 ''{0}''이(가) ''{1}'' 및 ''{2}''에서 발견되었습니다. Signal Conversion 블록을 추가하고 Signal Conversion 블록의 출력 포트에 대한 신호 속성을 지정해 보십시오.</entry>
    <entry key="Comp_AutoSolver">컴파일 중 : 솔버 자동 선택</entry>
    <entry key="Comp_AdaptBus">컴파일 중 : 버스 이름을 조정하는 중</entry>
    <entry key="Comp_Autosave">자동 저장 : 저장되지 않은 모든 모델을 백업하는 중</entry>
    <entry key="Comp_Blockio">컴파일 중 : 블록 I/O 인덱스를 설정하는 중</entry>
    <entry key="Comp_BusCache">컴파일 중 : 버스 캐시를 새로 고치는 중</entry>
    <entry key="Comp_BusConv">컴파일 중 : 버스 변환 블록을 삽입하는 중</entry>
    <entry key="Comp_CacheMR">컴파일 중 : 시스템의 Model 블록을 캐시하는 중</entry>
    <entry key="Comp_CacheSrcs">컴파일 중 : 실제 소스 및 대상을 캐시하는 중</entry>
    <entry key="Comp_Checksums">컴파일 중 : 체크섬을 계산하는 중</entry>
    <entry key="Comp_Cleanup">컴파일 중 : 메모리를 정리하는 중</entry>
    <entry key="Comp_CompProps">컴파일 중 : 컴파일된 속성을 초기화하는 중</entry>
    <entry key="Comp_CompSet">컴파일 중 : 컴파일된 블록 세트를 만드는 중</entry>
    <entry key="Comp_Complete">컴파일 중 : 컴파일 단계가 완료됨</entry>
    <entry key="Comp_Datatypes">컴파일 중 : 데이터형, 복소 신호, 단위 및 기호 차원을 전파하는 중</entry>
    <entry key="Comp_EvalBlocks">컴파일 중 : 블록 파라미터를 평가하는 중</entry>
    <entry key="Comp_SSCConstruct">컴파일 중 : Simscape 물리 네트워크의 연립방정식을 생성하는 중</entry>
    <entry key="Comp_SSCAnalyze">컴파일 중 : Simscape 물리 네트워크의 연립방정식을 분석하는 중</entry>
    <entry key="Comp_SSCSetup">컴파일 중 : Simscape 물리 네트워크의 시뮬레이션을 설정하는 중</entry>
    <entry key="Comp_SSCInitialize">실행 중 : Simscape 물리 네트워크의 연립방정식을 초기화하는 중</entry>
    <entry key="Comp_ExpandForBus">컴파일 중 : 버스 지원을 위해 블록을 확장하는 중</entry>
    <entry key="Comp_Final">컴파일 중 : 컴파일이 완료됨</entry>
    <entry key="Comp_GenSorted">컴파일 중 : 정렬된 목록을 생성하는 중</entry>
    <entry key="Comp_InitBlocks">컴파일 중 : 모든 블록을 초기화하는 중</entry>
    <entry key="Comp_MR">컴파일 중 : 모델 참조 타깃을 업데이트하는 중</entry>
    <entry key="Comp_RLS">컴파일 중 : 재사용 가능한 라이브러리 서브시스템 타깃을 업데이트하는 중</entry>
    <entry key="Comp_PostProp">컴파일 중 : 전파 후 태스크를 완료하는 중</entry>
    <entry key="Comp_Precompile">컴파일 중 : 컴파일 전 알림을 수행하는 중</entry>
    <entry key="Comp_PropContexts">컴파일 중 : 조건부 컨텍스트를 전파하는 중</entry>
    <entry key="Comp_PropFrames">컴파일 중 : 프레임 데이터 및 차원을 전파하는 중</entry>
    <entry key="Comp_PropLabels">컴파일 중 : 신호 레이블을 전파하는 중</entry>
    <entry key="Comp_PropPassByRef">컴파일 중 : 참조 방식으로 전달을 전파하는 중</entry>
    <entry key="Comp_Reeval">컴파일 중 : 버스 선택기를 다시 평가하는 중</entry>
    <entry key="Comp_References">컴파일 중 : 라이브러리 링크 블록을 업데이트하는 중</entry>
    <entry key="Comp_SF_Post">컴파일 중 : Stateflow 사후 컴파일을 알리는 중</entry>
    <entry key="Comp_SF_Start">컴파일 중 : Stateflow 컴파일을 시작하는 중</entry>
    <entry key="Comp_SampleTimes">컴파일 중 : 샘플 시간을 전파하는 중</entry>
    <entry key="Comp_SortBlocks">컴파일 중 : 전파할 블록 목록을 정렬하는 중</entry>
    <entry key="Comp_Start">컴파일 중 : 모델 컴파일을 시작하는 중</entry>
    <entry key="Comp_SysProps">컴파일 중 : 시스템 수준 속성을 전파하는 중</entry>
    <entry key="Comp_Testpoints">컴파일 중 : 묵시적 테스트 지점을 설정하는 중</entry>
    <entry key="Comp_PostActSrc">컴파일 중 : 서브시스템 출력 포트를 구성하는 중</entry>
    <entry key="Comp_UpdateDisplay">컴파일 중 : 그래픽 표시를 업데이트하는 중</entry>
    <entry key="Comp_UpdateSorted">컴파일 중 : 정렬된 순서 표시를 업데이트하는 중</entry>
    <entry key="Comp_Workspace">컴파일 중 : 모델 작업 공간을 초기화하는 중</entry>
    <entry key="CompactFormatNotSupportnonInlinedSF">Block ''{0}'' is a non-inlined S-function, which is not supported when ''File packaging format'' is ''Compact'' or ''Compact (with separate data file)''.
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;configset.internal.fixIt(''{0}'',''ERTFilePackagingFormat'',''Modular'')&lt;/cmd&gt;
            &lt;txt&gt;Change &lt;sldiag objui="configset" objparam="ERTFilePackagingFormat"&gt;File packaging format&lt;/sldiag&gt; to ''Modular''&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="CompileNeededForSampleTimes">An Update Diagram must be performed in order to access the ''SampleTimes'' information for the model ''{0}''</entry>
    <entry key="CompileNeededForVariantConditions">모델 ''{0}''의 ''VariantConditions'' 정보에 액세스하려면 다이어그램 업데이트를 수행해야 함</entry>
    <entry key="ModelHasNoVariantConditions">The model ''{0}'' has no variant conditions </entry>
    <entry key="CompileNeededForTasks">모델 ''{0}''의 ''Tasks'' 정보에 액세스하려면 다이어그램 업데이트를 수행해야 함</entry>
    <entry key="CompileNeededForClocks">모델 ''{0}''의 ''Clocks'' 정보에 액세스하려면 다이어그램 업데이트를 수행해야 함</entry>
    <entry key="ComplexityNotCompatibleMatlab">지정된 MATLAB 배열의 실수/복소수 여부가 Simulink 내부 데이터와 호환되지 않음</entry>
    <entry key="CompilePhaseStatusBarStart"> : 시작됨</entry>
    <entry key="CompilePhaseStatusBarEnd"> : 완료됨</entry>
    <entry key="ContSTInpPortIsFrameBased">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;가 연속 샘플 시간을 갖는데도 프레임 기반으로 설정되었습니다. 프레임 기반 신호는 이산 샘플 시간을 가져야 합니다.</entry>
    <entry key="ContStateAccessError">Continuous states of ''{0}'' cannot be accessed before the Start method of this block has been executed</entry>
    <entry key="ContinuousTimeNotSupported">블록 ''{0}''이(가) 연속시간을 사용하는데, 이는 현재 구성에서 지원되지 않습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''SupportContinuousTime'',''on'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="SupportContinuousTime"&gt;연속시간 지원&lt;/sldiag&gt;을 선택하십시오&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;</entry>
    <entry key="Conv1DVectToColVectByBlock">''{0}''은(는) 1차원 신호로 구동됩니다. 이로 인해 입력 신호가 열 벡터(행렬)로 자동으로 변환되었습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;Reshape 사용&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''VectorMatrixConversionMsg'',''none'')&lt;/cmd&gt; &lt;txt&gt;이 메시지를 표시하지 않으려면 &lt;sldiag objui="configset" objparam="VectorMatrixConversionMsg"&gt;벡터/행렬 블록 입력 변환&lt;/sldiag&gt;을 ''안 함''으로 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="CovAccessError">커버리지 툴에 액세스하는 중 치명적인 오류가 발생함: {0}</entry>
    <entry key="CovBlockTooManySignals">Too many signals for coverage in: {0}. Signal range coverage is turned off.</entry>
    <entry key="CovGenericBlock">''{0}''을(를) 분석하는 중 커버리지 툴에서 치명적인 오류가 발생했습니다.</entry>
    <entry key="CovGenericModel">모델을 분석하는 중 커버리지 툴에서 치명적인 오류가 발생했습니다.</entry>
    <entry key="CovSetupError">커버리지 툴을 설정하는 중 치명적인 오류가 발생했습니다.</entry>
    <entry key="CovNotSupportedSLDVBlockType">이 데이터형은 ''{0}''에서 지원되지 않음 - 이 블록에 대해 커버리지가 꺼져 있습니다.</entry>
    <entry key="CreateUndoSubsystemWarning">서브시스템 내에서 수행된 모든 그래픽 변경 내용이 제거됩니다.\n 서브시스템의 변경 내용을 복원하려면 [서브시스템 만들기 실행 취소]를 선택하십시오.\n</entry>
    <entry key="CreateUndoWriteProtectedSubsystemError">''ReadOnly'' 또는 ''NoReadWrite''인 서브시스템에 대해서는 [서브시스템 만들기 실행 취소]를 수행할 수 없습니다.\n</entry>
    <entry key="DSMemoryAsyncTsNotMatchObject">모델 ''{0}''에서 데이터 저장소 ''{1}''에 액세스하는 블록 중 하나 이상이 비동기 태스크로 실행됩니다. 이는 {2} 작업 공간에서 Simulink.Signal 객체가 지정한 데이터 저장소 메모리에 대한 샘플 시간 속성과 충돌합니다. 즉, 데이터 저장소가 샘플 시간 {3}의 싱글태스크로 액세스된다는 signal 객체의 지정 내용과 충돌합니다.</entry>
    <entry key="DSMemoryHybridTsNotMatchObject">In model ''{0}'', one or more of the blocks that access data store ''{1}'' execute in multiple tasks. This conflicts with the sample time property specified for the data store by the Simulink.Signal object in the {2} workspace. The signal object specifies that the data store is accessed in a single task having the sample time {3}.</entry>
    <entry key="DSMemoryReaderWriterTsNotMatchObject">In model ''{0}'', one or more of the blocks that access data store ''{1}'' execute in a task whose sample time is {2}. This conflicts with the sample time property for the data store memory specified by the Simulink.Signal object in the {3} workspace, i.e., the fact that the signal object specifies that the data store is accessed  in a single task having the sample time {4}.</entry>
    <entry key="DWorkDataNotReusableSC">The storage class of a state owned by ''{0}'' is global, thus the generated code is not reusable.
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="suggestion"&gt;
            &lt;cmd&gt;Simulink.internal.OpenBlockParamsDialog(''{0}'',''StateStorageClass'')&lt;/cmd&gt;
            &lt;txt&gt;Set ''Storage class'' to ''Auto''&lt;/txt&gt;
        &lt;/action&gt;
        &lt;action type="suggestion"&gt;
            &lt;cmd&gt;configset.internal.open(''{0}'',''CodeInterfacePackaging'')&lt;/cmd&gt;
            &lt;txt&gt;Set ''Code interface packaging'' to ''Nonreusable function'' (might impact referenced or referencing models)&lt;/txt&gt;
        &lt;/action&gt;
        &lt;action type="suggestion"&gt;
            &lt;cmd&gt;configset.internal.open(''{0}'',''MultiInstanceErrorCode'')&lt;/cmd&gt;
            &lt;txt&gt;Set ''Multi-instance code error diagnostic'' to ''None'' or ''Warning'.&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="DWorkDimArgIsNotDerivedParam">인수 ''{0}''은(는) 차원을 나타내는 파생된 인수로 유효하지 않습니다. 인수는 파생된 블록 파라미터여야 합니다.</entry>
    <entry key="DataDimensionMismatch">Data dimension mismatch</entry>
    <entry key="DataTypeHeaderRecursion">데이터형 헤더 파일 종속성에서 재귀가 감지되었습니다. 유형 종속성 체인: ''{0}''. 대응하는 헤더 파일 종속성 체인: ''{1}''.</entry>
    <entry key="DataTypeMismatch">Data type mismatch, a {0} data is given while a {1} data is expected</entry>
    <entry key="DataTypeMismatchField">MATLAB 구조체 필드의 데이터형이 일치하지 않음</entry>
    <entry key="DataTypeMismatchNumField">데이터형이 일치하지 않음. {0,number,integer}개 필드를 갖는 구조체가 지정되었지만 {1,number,integer}개 필드를 갖는 구조체가 필요함</entry>
    <entry key="DataTypeNotCompatibleMatlab">지정된 MATLAB 배열의 데이터형이 Simulink 내부 데이터와 호환되지 않음</entry>
    <entry key="DataUploadNotSupported">''{0}'' 유형의 데이터에 대해서는 업로드가 지원되지 않음</entry>
    <entry key="DefaultBlockDiagramInvalidMethod">Method ''{0}'' is not implemented for that object</entry>
    <entry key="DefaultDimsListHasBeenTruncated">과소 지정된 차원의 이 목록이 잘렸습니다.</entry>
    <entry key="DefaultDimsMethodUsed">모델 ''{0}''에 과소 지정된 신호 차원이 있으며 Simulink가 기본으로 이러한 차원을 할당했습니다. 모호함을 없애기 위해 블록 대화 상자에서 이러한 차원을 지정해 보십시오. 또는 필요에 따라 ''Signal Specification'' 블록을 추가하십시오. Simulink가 다음과 같은 신호 차원을 할당했습니다:{1}</entry>
    <entry key="DefaultDimsMightHaveCausedError">
      
               과소 지정된 신호 차원을 해결하는 중 모델 ''{0}''의 컴파일에 실패했습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{0}'');configset.highlightParameter(''{0}'','UnderSpecifiedDimensionMsg');&lt;/cmd&gt; &lt;txt&gt;과소 지정된 신호 차원 목록에 대해 ''경고'' 또는 ''오류'' 진단을 활성화하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
      
    </entry>
    <entry key="DefaultDimsLinkToDisable">
	  
		이 메시지를 끄려면 &lt;sldiag objui="configset" objparam="UnderSpecifiedDimensionMsg"&gt;과소 지정된 차원&lt;/sldiag&gt;을 ''안 함''으로 설정하십시오.
	  
	</entry>
    <entry key="DefaultDimsSetAtBlockInPort">블록 ''{0}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;가 {2}(으)로 설정되었습니다.</entry>
    <entry key="DefaultDimsSetAtBlockOutPort">블록 ''{0}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;가 {2}(으)로 설정되었습니다.</entry>
    <entry key="DefaultGraphPropertyLoadOnly">디폴트 그래프 속성은 모델을 불러오는 동안에만 설정할 수 있습니다. 루트 그래프 속성을 대신 설정하십시오.</entry>
    <entry key="DerivAccessError">이 블록의 Start 메서드가 실행되기 전에는 ''{0}''의 도함수에 액세스할 수 없음</entry>
    <entry key="DerivNotFinite">시간 {2}에서 블록 ''{1}''에 있는 상태 ''{0}''의 도함수가 유한하지 않습니다. 시뮬레이션이 중지됩니다. 해에 특이점이 있을 수 있습니다. 그렇지 않은 경우 고정 스텝 크기를 줄이거나 오차 허용오차를 좁혀 스텝 크기를 줄여 보십시오.</entry>
    <entry key="JacobianMatrixWithNanInf">Auto solver has detected that the Jacobian matrix at time t=0.0 has entries which are not finite. The simulation will be stopped. There may be a singularity in the solution.  If not, try reducing the step size (either by reducing the maximum step size or by tightening the error tolerances)</entry>
    <entry key="Dims1DVectTo2DVectorConversion">1차원 배열이 2차원 벡터(행렬)로 변환되었습니다. ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 의해 생성된 1차원 신호가 자동으로 2차원 벡터(행렬)로 변환되었습니다. 이 신호가 ''{3}''의 &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 입력 포트&lt;/sldiag&gt;를 구동하는 중입니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;Reshape를 사용하십시오&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{1}'',''VectorMatrixConversionMsg'',''none'')&lt;/cmd&gt; &lt;txt&gt;이 메시지를 표시하지 않으려면 &lt;sldiag objui="configset" objparam="VectorMatrixConversionMsg"&gt;벡터/행렬 블록 입력 변환&lt;/sldiag&gt;을 ''안 함''으로 설정하십시오&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="Dims2DVectTo1DVectorConversion">A 2-D Vector (matrix) has been converted to a 1-D array. The 2-D vector (matrix) signal generated by &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' has been automatically converted to a 1-D array. This signal is driving &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;input port {2,number,integer}&lt;/sldiag&gt; of ''{3}''.
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="suggestion"&gt;
            &lt;txt&gt;Use a Reshape&lt;/txt&gt;
        &lt;/action&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;configset.internal.fixIt(''{1}'',''VectorMatrixConversionMsg'',''none'')&lt;/cmd&gt;
            &lt;txt&gt;Suppress this message by setting &lt;sldiag objui="configset" objparam="VectorMatrixConversionMsg"&gt;Vector/matrix block input conversion&lt;/sldiag&gt; to ''none''&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="DimsPropBadDefDims2">''{0}''의 차원을 설정하는 중 오류가 발생했습니다. 모든 입력 포트는 알려진 차원을 가지고 있지만 출력 포트 {1,number,integer}은(는) 알 수 없는 차원을 가지고 있습니다.</entry>
    <entry key="DisableButNotReturnWkspOutput">작업 공간으로의 출력이 비활성화되었습니다. 이는 특히 ''sim''이 ''parfor'' 내에서 호출된 경우 발생합니다. 작업 공간 출력을 저장하려면 ''sim'' 명령 옵션에서 ''SaveWorkspaceOutputs''를 ''on''으로 설정하십시오.</entry>
    <entry key="DomainDataLocked">Data for Domain ''{0}'' is locked.</entry>
    <entry key="DomainHasNoPortTypes">영역 ''{0}''에 포트 유형이 없습니다. 적어도 하나를 지정해야 합니다.</entry>
    <entry key="DomainModelAlreadyRegistered">영역 모델이 이름 ''{0}''(으)로 이미 등록되었습니다.</entry>
    <entry key="DomainModelNotRegistered">Cannot locate domain model definition under the name ''{0}''.</entry>
    <entry key="DomainNotFound">물리 모델링 영역 정의 파일 {0}.m을 찾을 수 없습니다. 이 모델을 시뮬레이션할 수 없습니다. 모델을 닫은 후 영역 정의 파일을 MATLAB 경로에 추가하고 모델을 다시 여십시오.</entry>
    <entry key="DomainParameterNotSet">모든 영역에 대해 영역 파라미터 ''{0}''을(를) 설정해야 합니다. 영역 ''{1}''에서 이 파라미터를 설정하지 않았습니다.</entry>
    <entry key="DomainPortTypeParameterNotSet">모든 포트 유형에 대해 포트 유형 파라미터 ''{0}''을(를) 설정해야 합니다. 포트 유형 ''{1}''에서 이 파라미터를 설정하지 않았습니다.</entry>
    <entry key="DomainConnectIncorrectReturnValue">영역 ''{2}''의 포트 ''{0}'' 및 ''{1}''에 대한 연결 함수 반환 유형이 잘못되었습니다. 연결 함수는 논리형 스칼라를 반환해야 합니다.</entry>
    <entry key="PortTypeNotDefinedForNonDynamicDomain">영역 ''{1}''의 영역 정의에서 포트 유형 ''{0}''을(를) 찾을 수 없으며, 이 영역은 동적 포트 유형을 지원하지 않습니다.
    </entry>
    <entry key="DomainInvalidDynamicPortTypesCallback">영역 ''{0}''에 대한 DynamicPortTypesCallback 속성이 유효하지 않습니다. 이 속성은 MATLAB 함수 핸들로 구성된 1x2 셀형 배열이어야 합니다. 여기서 첫 번째 셀은 설정 함수 핸들이고 두 번째 셀은 연결 함수 핸들입니다.</entry>
    <entry key="DuplicatePortNum">''{0}''에서 중복된 포트 번호가 발견됨</entry>
    <entry key="DuplicatedNameInRegistry">이미 이 레지스트리에 ''{0}'' 이름의 항목이 존재합니다.</entry>
    <entry key="UngroupedCanPrmNotAllowedMulInstSLFcn">파라미터 ''{0}''이(가) 모델 인수로 구성되었으며 다중 인스턴스 코드를 생성하도록 구성된 Simulink 함수 ''{1}''에서 사용됩니다. 이 모델링 조합의 경우 파라미터는 자동이 아닌 스토리지 클래스를 가져야 합니다.</entry>
    <entry key="GroupedCanPrmNotAlloweSLFcnCppClass">파라미터 ''{0}''이(가) 모델 인수로 구성되었으며 Simulink 함수 ''{1}''에서 사용됩니다. 이 모델링 구성에 대해 캡슐화된 C++ 코드를 생성하려면 파라미터가 프라이빗 유효 범위를 가진 클래스 멤버여야 합니다. C++ 코드 매핑 편집기에서 ''Model parameter arguments'' 속성을 ''private''으로 설정하십시오.</entry>
    <entry key="ECPotentialOutputDiffTunablePrm">''{0}''의 출력이 이전 Simulink 릴리스와 다른 결과를 생성할 수 있습니다. 블록 ''{1}''이(가) 조정 가능형 변수를 가지며 조건부 실행 서브시스템 ''{2}''에서 상속되었습니다. ''{3}''의 조정 가능형 파라미터를 변경할 경우 조건부 실행 서브시스템이 실행될 때만 블록의 출력이 다시 계산됩니다. 컨텍스트의 상속을 방지하려면 ''{4}''의 샘플 시간을 신호를 다시 계산하고자 하는 레이트로 명시적으로 설정하십시오. 이 경고 메시지를 끄려면 &lt;sldiag objui="configset" objparam="CheckExecutionContextRuntimeOutputMsg"&gt;실행 컨텍스트의 런타임 출력 확인&lt;/sldiag&gt;을 선택 취소하십시오.</entry>
    <entry key="ECPotentialOutputDiffTunablePrmConsistentOutportInit">''{0}''의 출력이 이전 Simulink 릴리스와 다른 결과를 생성할 수 있습니다. 블록 ''{1}''이(가) 조정 가능형 변수를 가지며 조건부 실행 서브시스템 ''{2}''에서 상속되었습니다. ''{3}''의 조정 가능형 파라미터를 변경할 경우 조건부 실행 서브시스템이 실행될 때만 블록의 출력이 다시 계산됩니다. 컨텍스트의 상속을 방지하려면 ''{4}''의 샘플 시간을 신호를 다시 계산하고자 하는 레이트로 명시적으로 설정하십시오. 이 경고 메시지를 끄려면 &lt;sldiag objui="configset" objparam="CheckExecutionContextRuntimeOutputMsg"&gt;실행 컨텍스트의 런타임 출력 확인&lt;/sldiag&gt;을 선택 취소하십시오.</entry>
    <entry key="ECoder_LicenseError">임베디드 C 코드를 생성하는 데 필요한 Embedded Coder 라이선스를 체크아웃할 수 없음</entry>
    <entry key="MATLABCoder_LicenseError">코드를 생성하는 데 필요한 MATLAB Coder 라이선스를 체크아웃할 수 없음</entry>
    <entry key="EI_BoolParam">엔진 인터페이스 메서드 ''{0}''에 대한 입력 인수가 유효하지 않습니다. 파라미터 ''{1}''은(는) 부울 값 ''on'' 또는 ''off''만 허용합니다.</entry>
    <entry key="EI_UpdateOnlyNotAllowed">UpdateBDOnly is not allowed to be true for HDL or Model Reference style compile using the engine interface.</entry>
    <entry key="EI_CannotCompleteEI">엔진 인터페이스 메서드를 완료할 수 없음</entry>
    <entry key="EI_EINotEnabled">Simulink 엔진 인터페이스가 활성화되어 있지 않습니다.</entry>
    <entry key="EI_ImproperSubclass">입력 클래스가 디폴트 클래스의 적절한 서브클래스가 아님</entry>
    <entry key="EI_InvalidBlock">유효하지 않은 블록임</entry>
    <entry key="EI_VirtualBlockDoesNotHaveCData">The block is virtual and has been optimized away.</entry>
    <entry key="EI_NOTASynthesizedBlock">The block is NOT a synthesized block.</entry>
    <entry key="EI_ObjChanged">모델 컴파일 중에 객체가 변경됨</entry>
    <entry key="EI_InvalidInputPort">유효하지 않은 입력 포트임</entry>
    <entry key="EI_InvalidModel">유효하지 않은 모델임</entry>
    <entry key="EI_InvalidObject">Invalid Simulink object</entry>
    <entry key="EI_InvalidOption">유효하지 않은 옵션임</entry>
    <entry key="EI_InvalidBusSelElIdx">Invalid busSelElIdx. busSelElIdx is always associated with a non-virtual bus source port and must be a valid integer (-1 &gt;= busSelElIdx &gt; maxDFSIdx)</entry>
    <entry key="EI_InvalidVBPort">Port is not associated with a virtual bus signal</entry>
    <entry key="EI_InvalidOutputPort">Invalid output port</entry>
    <entry key="EI_InvalidSimType">유효하지 않은 Sim 유형임</entry>
    <entry key="EI_InvalidUDIHandle">유효하지 않은 UDI 핸들임</entry>
    <entry key="EI_MissingParamValPair">엔진 인터페이스 메서드 ''{0}''에 대한 입력 인수가 유효하지 않습니다. 입력 파라미터 ''{1}''에 일치하는 값이 없습니다.</entry>
    <entry key="EI_ModelInitiated">모델이 이미 시작됨</entry>
    <entry key="EI_UnrecognizedParam">엔진 인터페이스 메서드 ''{0}''에 대한 입력 인수가 유효하지 않습니다. 입력 파라미터 ''{1}''이(가) 유효한 파라미터가 아닙니다.</entry>
    <entry key="EI_UnspecifiedInputPort">블록에 둘 이상의 입력 포트가 있습니다. 하나를 지정하십시오.</entry>
    <entry key="EI_UnspecifiedOutputPort">블록에 둘 이상의 출력 포트가 있습니다. 하나를 지정하십시오.</entry>
    <entry key="ElementNotFound">지정된 요소를 찾을 수 없음</entry>
    <entry key="EI_EIIsLocked">엔진 인터페이스가 잠겼습니다. MATLAB 세션을 다시 시작하거나 디버거를 연결하고 잠긴 값을 재설정해야 합니다. 이 메시지는 릴리스 빌드에는 나타나지 않습니다.</entry>
    <entry key="EnabTrigECPotentialPreStartOutputDiff">''{1}''이(가) t = 0에서 활성화되지 않았고 트리거되지 않은 경우 ''{0}''의 출력이 이전 Simulink 릴리스와 다른 결과를 생성할 수 있습니다. ''{2}'' 블록은 영(0) 입력에 대해 0이 아닌 출력을 생성할 수 있으며 ''{3}'' 실행 컨텍스트에 의해 상속되었습니다. 이전 릴리스에서 ''{4}''은(는) 실행 컨텍스트에 의해 상속되지 않았으며 조건부 서브시스템 시작 전에 0이 아닌 출력을 생성했을 수 있습니다. 컨텍스트의 상속을 방지하려면 ''{5}''의 샘플 시간을 신호를 다시 계산하고자 하는 레이트로 명시적으로 설정하십시오. 이 경고 메시지를 끄려면 &lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;실행 컨텍스트의 사전 활성화 출력 확인&lt;/sldiag&gt;을 선택 취소하십시오.</entry>
    <entry key="EnabTrigECPotentialPreStartOutputDiffConsistentOutportInit">''{1}''이(가) t = 0에서 활성화되지 않았고 트리거되지 않은 경우 ''{0}''의 출력이 이전 Simulink 릴리스와 다른 결과를 생성할 수 있습니다. ''{2}'' 블록은 영(0) 입력에 대해 0이 아닌 출력을 생성할 수 있으며 ''{3}'' 실행 컨텍스트에 의해 상속되었습니다. 이전 릴리스에서 ''{4}''은(는) 실행 컨텍스트에 의해 상속되지 않았으며 조건부 서브시스템 시작 전에 0이 아닌 출력을 생성했을 수 있습니다. 컨텍스트의 상속을 방지하려면 ''{5}''의 샘플 시간을 신호를 다시 계산하고자 하는 레이트로 명시적으로 설정하십시오. 이 경고 메시지를 끄려면 &lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;실행 컨텍스트의 사전 활성화 출력 확인&lt;/sldiag&gt;을 선택 취소하십시오.</entry>
    <entry key="EnabledECPotentialPreStartOutputDiff">''{1}''이(가) t = 0에서 활성화되지 않은 경우 ''{0}''의 출력이 이전 Simulink 릴리스와 다른 결과를 생성할 수 있습니다. ''{2}'' 블록은 영(0) 입력에 대해 0이 아닌 출력을 생성할 수 있으며 ''{3}'' 실행 컨텍스트에 의해 상속되었습니다. 이전 릴리스에서 ''{4}''은(는) 실행 컨텍스트에 의해 상속되지 않았으며 조건부 서브시스템 시작 전에 0이 아닌 출력을 생성했을 수 있습니다. 컨텍스트의 상속을 방지하려면 ''{5}''의 샘플 시간을 신호를 다시 계산하고자 하는 레이트로 명시적으로 설정하십시오. 이 경고 메시지를 끄려면 &lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;실행 컨텍스트의 사전 활성화 출력 확인&lt;/sldiag&gt;을 선택 취소하십시오.</entry>
    <entry key="EnabledECPotentialPreStartOutputDiffConsistentOutportInit">''{1}''이(가) t = 0에서 활성화되지 않은 경우 ''{0}''의 출력이 이전 Simulink 릴리스와 다른 결과를 생성할 수 있습니다. ''{2}'' 블록은 영(0) 입력에 대해 0이 아닌 출력을 생성할 수 있으며 ''{3}'' 실행 컨텍스트에 의해 상속되었습니다. 이전 릴리스에서 ''{4}''은(는) 실행 컨텍스트에 의해 상속되지 않았으며 조건부 서브시스템 시작 전에 0이 아닌 출력을 생성했을 수 있습니다. 컨텍스트의 상속을 방지하려면 ''{5}''의 샘플 시간을 신호를 다시 계산하고자 하는 레이트로 명시적으로 설정하십시오. 이 경고 메시지를 끄려면 &lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;실행 컨텍스트의 사전 활성화 출력 확인&lt;/sldiag&gt;을 선택 취소하십시오.</entry>
    <entry key="RootOutportDirectConnToIRTRootInport">루트 Outport 블록 ''{0}''은(는) 루트 Inport 블록 ''{1}''(으)로 구동될 수 없습니다. 루트 Inport 블록이 또한 Initialize Function, Reinitialize Function, Reset Function 또는 Terminate Function 블록에 연결되어 있기 때문입니다.</entry>
    <entry key="VirtualRootOutportDirectConnToRootInport">가상 루트 Outport 블록 ''{0}''을(를) 루트 Inport 블록 ''{1}''에 직접 연결할 수 없습니다.</entry>
    <entry key="MATFileLoggingDataObjectRootOutport">모델 내 Outport 블록 ''{0}''이(가) 자동이 아닌 스토리지 클래스를 갖는 신호에 의해 구동됩니다. 이 구성에는 MAT 파일 기록이 지원되지 않습니다.</entry>
    <entry key="ErrInExtModeMexFile">외부 모드 MEX 파일 ''{0}''을(를) 실행하는 중 오류가 발생했습니다:\n{1}</entry>
    <entry key="ErrorAnnotationCallback">주석 ''{0}''입니다. ''{1}'' 콜백에 오류가 있습니다.</entry>
    <entry key="ErrorInMultipleDimsModes">Simulink는 차원 모드 정보를 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에서 ''{3}''의 &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 입력 포트&lt;/sldiag&gt;로 전파할 수 없습니다. {4,number,integer}번 출력 포트의 다중화된 신호가 {5,number,integer}번 입력 포트의 다중화된 신호와 일치하지 않는 차원 모드 설정을 갖습니다.</entry>
    <entry key="ErrorInMultipleFrames">프레임 정보를 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에서 ''{3}''의 &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 입력 포트&lt;/sldiag&gt;로 전파하는 중 오류가 발생했습니다. 일치하지 않는 프레임 정보를 갖는 다중화된 신호를 허용하도록 포트가 설정되어 있습니다.</entry>
    <entry key="ErrorNotWrittenYet">''{0}''에서 오류가 발견되었습니다. 오류 메시지를 할당 및/또는 작성해야 합니다.</entry>
    <entry key="ExecEventAccessError">Simulink는 시뮬레이션 동안에만 실행 이벤트 리스너를 블록에 추가하거나 제거할 수 있습니다. 블록 ''{0}''이(가) 현재 실행 중이 아닙니다. 따라서 Simulink가 이벤트 리스너를 이 블록에 추가할 수 없습니다.</entry>
    <entry key="EventCallbackNotSupportedForMultiThreadCoSim">블록이 멀티스레드 모드로 실행 중인 경우에는 실행 이벤트 리스너 콜백이 지원되지 않습니다. ''{1}''에 대한 멀티스레드를 해제하려면 명령 set_param(''{0}'','MultiThreadCoSim','off')를 실행하십시오.</entry>
    <entry key="ExportFcnsMode_AbsoluteTimeNotSupported">블록 ''{0}''이(가) 함수 호출을 내보내기 위한 현재 구성에 지원되지 않는 절대 시간을 사용합니다.</entry>
    <entry key="ExportFcnsMode_NonInlinedSFcnsNotSupported">블록 ''{0}''은(는) 함수 호출을 내보내기 위한 현재 구성에 지원되지 않는, 인라인이 아닌 S-Function입니다.</entry>
    <entry key="ExportedFcnCallSrcInsideContext">함수 호출 블록 ''{0}''의 입력은 그 자신의 출력에 종속됩니다. 따라서 이 블록의 입력이 함수 호출이 수행되는 동안 고정된 상태로 유지되지 않을 수 있습니다. 해당 입력 앞에 Function-Call Feedback Latch 블록을 배치해 보거나, 해당 Inport 블록에 'Function-Call Subsystem 출력의 피드백 신호에 대한 입력 래치' 옵션을 선택하십시오.</entry>
    <entry key="ExportedFcnCallSILSrcInsideContext">블록 ''{0}''의 입력이 그 자신의 출력에 종속되지만, 그래도 여전히 이 블록은 입력을 래치하지 않는 서브시스템에서 내보낸 코드를 시뮬레이션합니다. 따라서 코드의 시뮬레이션 동작이 원래 서브시스템의 시뮬레이션과 다를 수 있습니다. 원래 서브시스템의 해당 입력 앞에 Function-Call Feedback Latch 블록을 배치해 보거나, 해당 Inport 블록에 'Function-Call Subsystem 출력의 피드백 신호에 대한 입력 래치' 옵션을 선택하십시오.</entry>
    <entry key="ExtInpSFExecAtInit">The value at the root inport ''{0}'' is being used by the Stateflow chart ''{1}'' when that chart has the checkbox ''Execute(enter) Chart At Initialization'' selected. This configuration is not supported by the {2}. Consider clearing the chart''s ''Execute(enter) Chart At Initialization'' checkbox, or inserting a signal conversion block immediately after the root inport, making sure the ''Exclude this block from ''Block reduction'' optimization'' checkbox is selected for that signal conversion block</entry>
    <entry key="ExtInpSimscapeWhenFPC">The value at the root inport {0} is being used by the Simscape block ''{1}''. This configuration is not supported by the {2}. Consider inserting a Simulink Signal Conversion Block immediately after the root inport. Be sure to select the Signal Conversion Block parameter "Exclude this block from 'Block reduction' optimization".</entry>
    <entry key="ExtModeCannotDownloadParamBecauseNoHostToTarget">Parameter {0} cannot be downloaded because its type ({1}) has no external mode host-to-target function registered</entry>
    <entry key="ExtModeCantUploadDataCSC">소스 신호 중 하나가 사용자 지정 스토리지 클래스를 사용하기 때문에 Simulink가 ''{0}''에 데이터를 업로드할 수 없음</entry>
    <entry key="ExtModeCantUploadDataConstantSampleTime">블록이나 그 소스 블록들 중 하나가 상수 샘플 시간을 갖기 때문에 Simulink가 데이터를 ''{0}''에 업로드할 수 없음</entry>
    <entry key="ExtModeCantUploadDataMultipleRates">싱글레이트가 아니기 때문에 Simulink가 ''{0}''에 데이터를 업로드할 수 없습니다.</entry>
    <entry key="ExtModeCantUploadDataNoConnectedSignals">연결된 신호가 없기 때문에 Simulink가 ''{0}''에 데이터를 업로드할 수 없음</entry>
    <entry key="ExtModeCantUploadDataNoConvertFunc">소스 신호 중 하나가 외부 모드에서 지원되지 않는 데이터형을 사용하기 때문에 Simulink가 ''{0}''에 데이터를 업로드할 수 없음</entry>
    <entry key="ExtModeCantUploadDataNoDWork">업로드 가능한 dwork가 없기 때문에 Simulink가 ''{0}''에 데이터를 업로드할 수 없음</entry>
    <entry key="ExtModeCantUploadDataNoInputPorts">입력 포트가 없기 때문에 Simulink가 ''{0}''에 데이터를 업로드할 수 없음</entry>
    <entry key="ExtModeCantUploadDataPortBasedSampleTime">블록이나 그 소스 블록들 중 하나가 포트 기반 샘플 시간을 갖기 때문에 Simulink가 데이터를 ''{0}''에 업로드할 수 없음</entry>
    <entry key="ExtModeCantUploadDataRootInport">구동 블록 중 하나가 최상위 Inport이기 때문에 Simulink가 ''{0}''에 데이터를 업로드할 수 없음</entry>
    <entry key="ExtModeCantUploadDataVarDims">소스 신호 중 하나가 가변 크기이기 때문에 Simulink가 ''{0}''에 데이터를 업로드할 수 없습니다. 가변 크기 신호는 외부 모드 TCP/IP 및 직렬 전송 프로토콜에서만 지원됩니다. 또한 타깃 하드웨어와 MATLAB 개발 컴퓨터의 'int' 크기가 일치해야 합니다.</entry>
    <entry key="ExtModeChecksumMismatch">외부 모드에서 실행하려고 시도 중인 모델이 타깃에서 실행 중인 애플리케이션과 일치하지 않습니다. 체크섬 테스트({0})에 실패했습니다. 호스트 모델의 구조적 체크섬은 [{1,number,integer}, {2,number,integer}, {3,number,integer}, {4,number,integer}]이고, 타깃 애플리케이션의 구조적 체크섬은 [{5,number,integer}, {6,number,integer}, {7,number,integer}, {8,number,integer}]입니다. 모델을 재빌드하고 타깃에서 실행한 다음 외부 모드 시뮬레이션을 다시 시작하십시오.</entry>
    <entry key="ExtModeErrorCallingSFcnExtModeFcn">''{0}''에 대해 외부 모드 함수를 호출하는 중 오류가 발생함: {1}</entry>
    <entry key="ExtModeErrorCalllingExtmodeTransports">extmode_transports.m을 호출하는 중 오류가 발생했습니다.</entry>
    <entry key="ExtModeErrorGettingIntrfLevelFromExtmodeTransports">extmode_transports.m에서 ExtModeIntrfLevel에 대한 적절한 값을 가져올 수 없음</entry>
    <entry key="ExtModeErrorGettingMexFileFromExtmodeTransports">Could not get proper value for ExtModeMexFile from extmode_transports.m</entry>
    <entry key="ExtModeFailToWriteMatFile">행렬을 matfile에 쓰지 못함</entry>
    <entry key="ExtModeFileDirNameEmpty">External Data Archiving 대화 상자의 ''Directory'' 및 ''File'' 필드에 디렉터리 및 파일 이름을 지정해야 함</entry>
    <entry key="ExtModeInvTrigDuration">외부 모드 트리거 지속 시간은 0보다 큰 정수 스칼라여야 함</entry>
    <entry key="ExtModeInvalidPositiveValue">''{0}'' must be a positive value.</entry>
    <entry key="ExtModeInvalidNonNegativeValue">''{0}'' must not be a negative value.</entry>
    <entry key="ExtModeInvalidTrigBlock">외부 모드 트리거 신호가 유효하지 않음</entry>
    <entry key="ExtModeInvalidTrigBlockPath">트리거 신호 ''{0}''이(가) 유효하지 않습니다. [외부 신호 및 트리거] 대화 상자를 사용하여 유효한 신호를 지정하십시오.</entry>
    <entry key="ExtModeInvalidTrigElementSpec">외부 모드 트리거 요소 사양은 정수 한 개, 키워드 ''last'' 또는 키워드 ''any''여야 함</entry>
    <entry key="ExtModeInvalidTrigPortSpec">외부 모드 트리거 포트 사양은 정수 한 개 또는 키워드 ''last''여야 함</entry>
    <entry key="ExtModeMultipleTriggers">Multiple External mode triggers found</entry>
    <entry key="ExtModeSFAndMATLABFcnInvalidTriggers">외부 모드는 Stateflow 또는 MATLAB Function 블록을 트리거 신호로 사용할 수 없음</entry>
    <entry key="ExtModeMustBeConnectedToStartTarget">타깃이 연결되어 있지 않으므로 외부 모드 시뮬레이션을 시작할 수 없습니다.</entry>
    <entry key="ExtModeOneClickNeedsSLCoder">Simulink와 타깃 하드웨어가 연결되어 있지 않고 Simulink Coder가 설치되어 있지 않으므로 외부 모드 시뮬레이션을 실행할 수 없습니다. 외부 모드 시뮬레이션을 빌드하고 배포하고 시작하려면 Simulink Coder를 설치하십시오. 이미 배포된 모델의 시뮬레이션을 시작하려면 Simulink를 타깃 하드웨어에 연결하십시오.</entry>
    <entry key="ExtModeUnexpectedIncomingPacketFromTarget">Simulink가 타깃에서 예기치 않은 들어오는 패킷을 수신했기 때문에 외부 모드가 종료되는 중입니다.</entry>
    <entry key="ExtModeNameTooLong">이름이 너무 길어서 접미사를 추가할 수 없음</entry>
    <entry key="ExtModeNoHostToTarget">{0} 유형에 외부 모드 호스트-타깃 함수가 등록되어 있지 않기 때문에 신호가 이 유형이 아닐 수 있음</entry>
    <entry key="ExtModeNoTargetToHost">{0} 유형에 외부 모드 타깃-호스트 함수가 등록되어 있지 않기 때문에 이 유형의 객체를 업로드할 수 없음</entry>
    <entry key="ExtModeNoTrigSpecified">트리거가 지정되지 않음</entry>
    <entry key="ExtModeNotAllRequiredFieldsSet">외부 모드(ExtConnect)의 초기화에서 일부 필수 필드(예: sizeofTargetReal, hostToTargetRealFcn)를 초기화하지 못함</entry>
    <entry key="ExtModeOpenProtocolError">외부 모드 개방형 프로토콜 {0} 명령이 실패함</entry>
    <entry key="ExtModeOpenProtocolErrorWithStatus">외부 모드 개방형 프로토콜 {0} 명령이 실패함(상태: {1,number,integer})</entry>
    <entry key="ExtModeOpenProtocolInvalidTimeSeriesData">소스 신호 중 하나가 형식이 잘못된 데이터를 업로드했기 때문에 ''{0}''에 데이터를 업로드할 수 없습니다. 이는 다음 이유 중 하나 때문일 수 있습니다.\n \t(1) 시간 벡터 및 데이터 벡터의 길이가 다름 \n \t(2) 데이터 벡터와 소스 신호의 유형, 차원 또는 실수/복소수 여부가 일치하지 않음\n \t(3) 시간 벡터의 유형이 ''double''이 아님\n \t(4) 파라미터 ''ExtModeOpenProtocolUploadingEqualLengthVectors''가 ''on''이지만 모든 데이터 벡터의 길이가 같지 않음</entry>
    <entry key="ExtModeOpenProtocolParamNotSupported">Parameter ''{0}'' not supported by the selected External Mode Open Protocol transport layer.</entry>
    <entry key="ExtModeOpenProtocolIntegerOnlyMismatch">Model value for ''PurelyIntegerCode'' does not match the corresponding value in the target application. Update the model value for ''PurelyIntegerCode'' and rebuild the target application.</entry>
    <entry key="ExtModeOpenProtocolDataDrop">타깃 애플리케이션에서 업로드된 신호를 수신하고 표시하는 하나 이상의 블록(예: Floating Scope 및 Scope 블록, Spectrum Analyzer 및 Time Scope 블록, Display 블록 및 To Workspace 블록)에 대해 데이터가 삭제되었습니다. 이는 타깃 애플리케이션에서 샘플링된 시간 변수의 정밀도가 충분하지 않기 때문일 수 있습니다. 이러한 블록을 시뮬레이션 데이터 인스펙터 또는 Dashboard 블록으로 바꿔 보십시오.</entry>
    <entry key="ExtModeTrigElementOutOfRange">''{0}''에 대해 지정된 외부 모드 트리거 요소인 ''{1,number,integer}''번 포트가 음수이거나 범위를 벗어났습니다. 이 포트 너비는 {2,number,integer}입니다. 사용자가 지정한 값은 {3}입니다.</entry>
    <entry key="ExtModeTrigPortOutOfRange">''{0}''에 대해 지정된 외부 모드 트리거 포트가 음수이거나 범위를 벗어났습니다. {1,number,integer}개의 포트가 있습니다. 사용자가 지정한 값은 {2}입니다.</entry>
    <entry key="ExtModeTrigSigInTriggeredSubsys">''{0}''에 대한 입력이 데이터 업로드를 위한 트리거 신호로 지정되었습니다. 트리거 신호는 트리거된 샘플 시간을 갖는 대상을 가질 수 없습니다.</entry>
    <entry key="ExtOutSFExecAtInit">Stateflow 차트 ''{1}''에 체크박스 ''Execute(enter) Chart At Initialization''이 선택되어 있는 경우 루트 아웃포트 ''{0}''의 값이 이 차트에 의해 할당됩니다. {2}에서는 이 구성이 지원되지 않습니다. 차트의 ''Execute(enter) Chart At Initialization'' 체크박스의 선택을 해제하거나 루트 아웃포트 바로 앞에 Signal Conversion 블록을 삽입하여 ''''블록 축소'' 최적화에서 이 블록 제외'' 체크박스가 해당 Signal Conversion 블록에 대해 선택되도록 해 보십시오.</entry>
    <entry key="ExternalDomainRegistrationSymbolNotFound">''{0}''의 등록 기호를 찾을 수 없습니다. \n''{1}''</entry>
    <entry key="InvalidDomainRegistrationKey">''{0}''에 대한 등록 키가 유효하지 않습니다.</entry>
    <entry key="ExternalModeNotReusableUnconditionalError">When external mode simulation is chosen, the generated code is not reusable. Consider setting ''Code interface packaging'' to ''Nonreusable function'' on the Configuration Parameters &gt; Code Generation &gt; Interface pane</entry>
    <entry key="ExternalModeNotReusableMultiInstanceErrorDiagnostic">The generated code for ''{0}'' is not reusable because external mode simulation is chosen.
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt;
            &lt;txt&gt;Set &lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;Code interface packaging&lt;/sldiag&gt; to ''Nonreusable function'' (might impact referenced or referencing models)&lt;/txt&gt;
        &lt;/action&gt;
	    &lt;action type="fixit"&gt;
	        &lt;cmd&gt;configset.internal.fixIt(''{0}'',''MultiInstanceErrorCode'',''None'')&lt;/cmd&gt;
	        &lt;txt&gt;Suppress this message by setting &lt;sldiag objui="configset" objparam="MultiInstanceErrorCode"&gt;Multi-instance code error diagnostic&lt;/sldiag&gt; to ''None''&lt;/txt&gt;
	    &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="ExternalModeCppClassProfilingNotSupportedError">When external mode simulation is chosen and ''Code interface packaging'' is set to ''C++ Class'', code execution profiling is not supported. Consider setting ''CodeExecutionProfiling'' to off.</entry>
    <entry key="ExtraModelrefNoncontSignal">Model 블록 ''{0}''이(가) 불연속이 있는 신호를 출력하고 있으며, 연속 상태를 갖는 블록에 이 신호가 전달되고 있습니다. 올바른 답을 보장하기 위해, 연속 샘플 시간을 갖는 Model 블록의 입력 포트에 전달되고 있는 모든 이산 신호도 추적하는 중입니다. 이로 인해 추가적인 솔버 재설정이 발생할 수 있습니다. &lt;sldiag objui="configset" objparam="ModelReferenceExtraNoncontSigs"&gt;관련 없는 이산 미분 신호&lt;/sldiag&gt;를 ''안 함''으로 설정하여 이 진단을 비활성화할 수 있습니다</entry>
    <entry key="FcnCallActionDataDepViolation">Function-Call Subsystem 또는 Action Subsystem 사용으로 인해 데이터 종속성 위반이 발생했습니다. 루프는 빨간 선을 따라 순방향으로 진행하거나 파란 선을 따라 역방향으로 진행할 수 있습니다. 녹색 선은 루프의 순방향 경로와 역방향 경로가 겹치는 부분을 나타냅니다. 추가적인 정보는 &lt;a href=\"matlab:openExample('simulink_features/SimulinkSubsystemSemanticsExample'); open_system('sl_subsys_semantics/ Function-call subsystems');\"&gt;''sl_subsys_semantics''&lt;/a&gt;에서 Function-Call Subsystem의 유효한 예와 유효하지 않은 예를 참조하십시오.</entry>
    <entry key="MessageServiceDelegationOpNew">모델 {0}에 참조된 모델에서 메시지를 받거나 보내는 블록 {1}이(가) 포함된 경우에는 파라미터 "동적 메모리 할당을 사용해 Model 블록 인스턴스화"가 지원되지 않습니다. 구성 파라미터 &gt; 코드 생성 &gt; 인터페이스 창에서 "동적 메모리 할당을 사용해 Model 블록 인스턴스화" 체크박스의 선택을 해제하십시오. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''UseOperatorNewForModelRefRegistration'',''off'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="'UseOperatorNewForModelRefRegistration'"&gt;&lt;/sldiag&gt; 동적 메모리 할당을 사용해 Model 블록 인스턴스화의 선택을 해제하십시오(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음).&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="FunctionServiceDelegationOpNew">모델 {0}에 함수를 제공하거나 함수를 필요로 하는 버스 요소 포트 {1}이(가) 포함된 경우 파라미터 "동적 메모리 할당을 사용해 Model 블록 인스턴스화"가 지원되지 않습니다. 구성 파라미터 &gt; 코드 생성 &gt; 인터페이스 창에서 "동적 메모리 할당을 사용해 Model 블록 인스턴스화" 체크박스의 선택을 해제하십시오. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''UseOperatorNewForModelRefRegistration'',''off'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="'UseOperatorNewForModelRefRegistration'"&gt;&lt;/sldiag&gt; 동적 메모리 할당을 사용해 Model 블록 인스턴스화의 선택을 해제하십시오(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음).&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="FunctionServiceCircularDependency">모델 {0}에 대한 코드를 생성할 수 없습니다. 모델 {0}에 종속성 루프의 일부인 Model 블록 {1} 및 {2}이(가) 포함되어 있습니다. 종속성 루프를 끊으려면 단일 모델에 클라이언트 및 서버 함수 포트가 함께 있지 않도록 하십시오.</entry>
    <entry key="FunctionServiceUnconnectedClient">함수를 제공하거나 함수를 필요로 하지만 버스 요소 포트 {1}이(가) 연결되지 않은 Model 블록이 포함된 모델 {0}에 대해서는 코드를 생성할 수 없습니다. 코드를 생성하려면 Model 블록의 포트를 입력 또는 출력 블록에 연결하십시오.</entry>
    <entry key="FcnCallActionDataDepViolationWarn">Function-Call Subsystem 또는 Action Subsystem 사용으로 인해 데이터 종속성 위반이 발생했습니다. 이러한 종속성을 추적하려면 ''구성 파라미터'' &gt; ''진단'' &gt; ''연결성'' &gt; ''함수 호출'' &gt; ''유효하지 않은 함수 호출 연결''에서 ''오류''를 선택하십시오. ''경고'' 옵션은 향후 릴리스에서 더 이상 사용되지 않을 예정입니다. 추가적인 정보는 &lt;a href=\"matlab:openExample('simulink_features/SimulinkSubsystemSemanticsExample'); open_system('sl_subsys_semantics/ Function-call subsystems');\"&gt;''sl_subsys_semantics''&lt;/a&gt;에서 Function-Call Subsystem의 유효한 예와 유효하지 않은 예를 참조하십시오.</entry>
    <entry key="FcnCallECPotentialPreStartOutputDiff">''{1}''이(가) t = 0에서 호출되지 않은 경우 ''{0}''의 출력이 이전 Simulink 릴리스와 다른 결과를 생성할 수 있습니다. ''{2}'' 블록은 영(0) 입력에 대해 0이 아닌 출력을 생성할 수 있으며 ''{3}'' 실행 컨텍스트에 의해 상속되었습니다. 이전 릴리스에서 ''{4}''은(는) 실행 컨텍스트에 의해 상속되지 않았으며 조건부 서브시스템 시작 전에 0이 아닌 출력을 생성했을 수 있습니다. 컨텍스트의 상속을 방지하려면 ''{5}''의 샘플 시간을 신호를 다시 계산하고자 하는 레이트로 명시적으로 설정하십시오. 이 경고 메시지를 끄려면 &lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;실행 컨텍스트의 사전 활성화 출력 확인&lt;/sldiag&gt;을 선택 취소하십시오.</entry>
    <entry key="FcnCallECPotentialPreStartOutputDiffConsistentOutportInit">''{1}''이(가) t = 0에서 호출되지 않은 경우 ''{0}''의 출력이 이전 Simulink 릴리스와 다른 결과를 생성할 수 있습니다. ''{2}'' 블록은 영(0) 입력에 대해 0이 아닌 출력을 생성할 수 있으며 ''{3}'' 실행 컨텍스트에 의해 상속되었습니다. 이전 릴리스에서 ''{4}''은(는) 실행 컨텍스트에 의해 상속되지 않았으며 조건부 서브시스템 시작 전에 0이 아닌 출력을 생성했을 수 있습니다. 컨텍스트의 상속을 방지하려면 ''{5}''의 샘플 시간을 신호를 다시 계산하고자 하는 레이트로 명시적으로 설정하십시오. 이 경고 메시지를 끄려면 &lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;실행 컨텍스트의 사전 활성화 출력 확인&lt;/sldiag&gt;을 선택 취소하십시오.</entry>
    <entry key="FcnCallPortGroupedBlkSrcInsideContext">The Model block ''{0}'' has function-call input(s), and its data input(s) depend on its own output(s). This may cause the input(s) of the block to change during the execution. Consider placing Function-Call Feedback Latch block(s) before corresponding input(s). Another option is to select the ''Latch input for feedback signals of function-call subsystem outputs'' parameter on all downstream Inport blocks that connect to corresponding root Inport block(s) inside the Model block ''{1}''.</entry>
    <entry key="FcnCallMdlBlkSrcInsideContext">Model 블록 ''{0}''은(는) 함수 호출 입력을 가지며 그 데이터 입력은 자신의 출력에 종속됩니다. 따라서 실행 중에 블록의 입력이 변경될 수 있습니다. 해당 입력 앞에 Function-Call Feedback Latch 블록을 배치해 보거나 모델 ''{1}''의 대응되는 Inport 블록에 ''Function-Call Subsystem 출력의 피드백 신호에 대한 입력 래치'' 파라미터를 선택해 보십시오.</entry>
    <entry key="FcnCallSSCycleDataDepViolation">함수 호출 블록으로 인해 입력 데이터 종속성 위반이 발생했습니다. 다음 함수 호출 블록들은 순환 관계에 놓여 있고 공통 함수 호출 개시자를 갖지 않습니다. 순환 관계를 끊기 위해 Stateflow Chart 같은 단일 블록을 개시자로 사용할 수 있습니다. 공통 함수 호출 개시자를 사용하면 호출된 함수 호출 블록 간의 모든 데이터 연결이 데이터 저장소(즉, 전역 변수)로 간주되어 처리되며 여기에는 묵시적인 데이터 종속성이 없습니다. 적절한 위치에 메모리 및/또는 단위 지연을 삽입하여 루프를 끊을 수도 있습니다. 추가적인 정보는 &lt;a href=\"matlab:openExample('simulink_features/SimulinkSubsystemSemanticsExample'); open_system('sl_subsys_semantics/ Function-call subsystems');\"&gt;''sl_subsys_semantics''&lt;/a&gt;에서 Function-Call Subsystem의 유효한 예와 유효하지 않은 예를 참조하십시오.</entry>
    <entry key="FcnCallSSSrcInsideContext">The input(s) of the function-call subsystem ''{0}'' depend on the following source blocks, which appear within their own calling context: {1}. This dependency might cause the inputs of the subsystem to not remain fixed over the duration of the function-call. It might also lead to code generation results differing from simulation results. Consider placing Function-Call Feedback Latch block(s) before corresponding input(s), or selecting the ''Latch input for feedback signals of function-call subsystem outputs'' parameter on corresponding Inport blocks of the function-call subsystem.</entry>
    <entry key="FcnCallSSSrcInsideContextStatus">''{0}''에서 하나 이상의 함수 호출 블록에 대한 입력이 그 블록의 호출 컨텍스트 내에 있는 소스 블록에 종속됩니다. &lt;sldiag objui="configset" objparam="FcnCallInpInsideContextMsg"&gt;컨텍스트 종속 입력&lt;/sldiag&gt;에서 ''오류''를 선택했기 때문에 이 상태가 오류로 보고됩니다. 추가적인 정보는 &amp;lt;a href=\"matlab:openExample('simulink_features/SimulinkSubsystemSemanticsExample'); open_system('sl_subsys_semantics/ Function-call subsystems');\"&amp;gt;''sl_subsys_semantics''&amp;lt;/a&amp;gt;에서 Function-Call Subsystem의 유효한 예와 유효하지 않은 예를 참조하십시오.</entry>
    <entry key="FcnCallSSSrcInsideContextGoingToExportStatus">하나 이상의 함수 호출 블록에 대한 입력이 그 블록의 호출 컨텍스트 내에 있는 소스 블록에 종속됩니다. 특히 함수 호출 블록 중 하나 이상은 내보내는 함수에 해당하며, 그 내보낸 코드의 동작이 서브시스템의 동작과 다를 수 있습니다. ''구성 파라미터'' &gt; ''진단'' &gt; ''연결성'' &gt; ''함수 호출'' &gt; ''컨텍스트 종속 입력''에서 ''오류''를 선택했기 때문에 이 상태가 오류로 보고됩니다. 추가적인 정보는 &lt;a href=\"matlab:openExample('simulink_features/SimulinkSubsystemSemanticsExample'); open_system('sl_subsys_semantics/ Function-call subsystems');\"&gt;''sl_subsys_semantics''&lt;/a&gt;에서 Function-Call Subsystem의 유효한 예와 유효하지 않은 예를 참조하십시오.</entry>
    <entry key="FcnCallSSSrcInsideContextGoingToExportTip">하나 이상의 함수 호출 블록에 대한 입력이 그 블록의 호출 컨텍스트 내에 있는 소스 블록에 종속됩니다. 특히 함수 블록 중 하나 이상은 내보내는 Function-Call Subsystem에 해당하며, 그 내보낸 코드의 동작이 서브시스템 동작과 다를 수 있습니다. 이러한 종속성을 추적하려면 ''구성 파라미터'' &gt; ''진단'' &gt; ''연결성'' &gt; ''함수 호출'' &gt; ''컨텍스트 종속 입력''에서 ''오류''를 선택하십시오. ''경고'' 옵션은 향후 릴리스에서 더 이상 사용되지 않을 예정입니다. 추가적인 정보는 &lt;a href=\"matlab:openExample('simulink_features/SimulinkSubsystemSemanticsExample'); open_system('sl_subsys_semantics/ Function-call subsystems');\"&gt;''sl_subsys_semantics''&lt;/a&gt;에서 Function-Call Subsystem의 유효한 예와 유효하지 않은 예를 참조하십시오.</entry>
    <entry key="FcnCallSSSrcInsideContextTip">하나 이상의 함수 호출 블록에 대한 입력이 그 블록의 호출 컨텍스트 내에 있는 소스 블록에 종속됩니다. 이러한 종속성을 추적하려면 ''구성 파라미터'' &gt; ''진단'' &gt; ''연결성'' &gt; ''함수 호출'' &gt; ''컨텍스트 종속 입력''에서 ''오류''를 선택하십시오. ''경고'' 옵션은 향후 릴리스에서 더 이상 사용되지 않을 예정입니다. 추가적인 정보는 &lt;a href=\"matlab:openExample('simulink_features/SimulinkSubsystemSemanticsExample'); open_system('sl_subsys_semantics/ Function-call subsystems');\"&gt;''sl_subsys_semantics''&lt;/a&gt;에서 Function-Call Subsystem의 유효한 예와 유효하지 않은 예를 참조하십시오.</entry>
    <entry key="FcnCallSSMessageSrcInsideContext">The message input(s) of the function-call subsystem ''{0}'' depend on the following source blocks, which appear within their own calling context: {1}. This dependency might cause an infinite cycle condition where messages source from the function-call subsystem are cycling around infinitely without progressing the simulation time. Consider placing Message Delay block(s) before corresponding input(s).</entry>
    <entry key="FileNameCycle">The following subsystems are generating code into files that cause cyclic dependency problem.  Please change the file name(s) for these systems to remove the cycle</entry>
    <entry key="FileNameCycleBlockMsg">File ''{0}'' (via subsystem ''{1}'') includes file ''{2}'' (via subsystem ''{3}'')</entry>
    <entry key="FocingSFcnDFMsg">모델 ''{0}''이(가) 다음을 지정했습니다.\n \tset_param(''{1}'',''TryForcingSFcnDF'',''on'');\n 이 설정은 Simulink 4.0 이하 버전에 있으며 다음과 같이 동작하도록 설정된 S-Function을 보완하려고 하는 특별 실행 모드를 활성화합니다.\n \t(1) mdlInitializeSizes에서 해당 입력 포트에 대한 직접 피드스루를 갖지 않도록 지정합니다.\n \t(2) 그런 다음, mdlOutputs 메서드 또는 mdlGetTimeOfNextVarHit 메서드에서 대응되는 입력 신호에 액세스합니다.\n 이 보완 모드를 사용하면 비가상 서브시스템 내에서 S-Function을 포함하는 모델에 대한 블록 실행 순서가 잘못될 수 있습니다. 모델에서 S-Function을 업데이트하여 mdlOutputs() 또는 mdlGetTimeOfNextVarHit()에서 액세스되는 입력 포트 신호에 대한 직접 피드스루를 지정한 후 다음을 실행하십시오. \tset_param(''{2}'',''TryForcingSFcnDF'',''off'');\n ''직접 피드스루''라는 용어는 오해의 소지가 있을 수 있습니다. 직접 피드스루 설정을 ''입력 필요''라는 설정으로 여기면 혼동을 줄일 수 있습니다. 특히, S-Function이 mdlOutputs() 또는 mdlGetTimeOfNextVarHit()에서 입력 신호에 액세스할 경우 직접 피드스루 플래그가 1(true)로 설정되어야 합니다.\n</entry>
    <entry key="FramesNeedsSigProcLicense">''{0}''은(는) 포트가 프레임 기반 샘플링 모드를 갖는 하나 이상의 블록을 포함합니다. Simulink에서 프레임 기반 처리를 수행하려면 DSP System Toolbox 라이선스가 필요합니다.</entry>
    <entry key="FramesNeedsSigProcLicenseInpPort">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대한 샘플링 모드를 프레임으로 설정하는 중 오류가 발생했습니다. Simulink에서 프레임 기반 처리를 수행하려면 DSP System Toolbox 라이선스가 필요합니다.</entry>
    <entry key="FramesNeedsSigProcLicenseOutPort">블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 대한 샘플링 모드를 프레임으로 설정하는 중 오류가 발생했습니다. Simulink에서 프레임 기반 처리를 수행하려면 DSP System Toolbox 라이선스가 필요합니다.</entry>
    <entry key="FwdPropDoesNotSupportND">{0,number,integer}차원 신호를 블록 ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에서 블록 ''{4}''의 &lt;sldiag objui="inport" objparam="{3,number,integer}" objname="{4}"&gt;{3,number,integer}번 입력 포트&lt;/sldiag&gt;로 전파할 수 없습니다. 이 두 번째 블록은 전체적으로 또는 해당 현재 구성 내에서 2차원보다 큰 신호를 받지 않습니다.</entry>
    <entry key="FwdPropDoesNotSupportNDCompSig">하나 이상의 {0,number,integer}차원 신호를 포함하는 복합 신호를 블록 ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에서 블록 ''{4}''의 &lt;sldiag objui="inport" objparam="{3,number,integer}" objname="{4}"&gt;{3,number,integer}번 입력 포트&lt;/sldiag&gt;로 전파할 수 없습니다. 이 두 번째 블록은 전체적으로 또는 해당 현재 구성 내에서 2차원보다 큰 신호를 받지 않습니다.</entry>
    <entry key="FwdTableNotLibWarn">블록 다이어그램 ''{0}''은(는) 라이브러리가 아니기 때문에 이 다이어그램에 대해 포워딩 테이블을 설정할 수 없습니다. 지정된 포워딩 테이블 정보를 무시합니다.</entry>
    <entry key="FxpPointFiToNoFPSignal">Invalid assignment in ''{0}'': attempt to assign a fi object to a non-fixed-point signal</entry>
    <entry key="FxpPointInvDataTypeID">The data type id does not correspond to a Simulink builtin or fixed-point data type</entry>
    <entry key="FxpPoint_Bias_Mismatch">''{0}''의 할당이 유효하지 않음: 편향이 {1}인 fi 객체를 편향이 {2}인 고정소수점 신호에 할당하려고 함</entry>
    <entry key="FxpPoint_Frac_Length_Mismatch">''{0}''의 할당이 유효하지 않음: 소수부 길이가 {1,number,integer}인 fi 객체를 소수부 길이가 {2,number,integer}인 고정소수점 신호에 할당하려고 함</entry>
    <entry key="FxpPoint_Sign_Mismatch1">''{0}''의 할당이 유효하지 않음: 부호 있는 fi 객체를 부호 없는 신호에 할당하려고 함</entry>
    <entry key="FxpPoint_Sign_Mismatch2">''{0}''의 할당이 유효하지 않음: 부호 없는 fi 객체를 부호 있는 신호에 할당하려고 함</entry>
    <entry key="FxpPoint_Slope_Mismatch">''{0}''의 할당이 유효하지 않음: 기울기가 {1}인 fi 객체를 기울기가 {2}인 고정소수점 신호에 할당하려고 함</entry>
    <entry key="FxpPoint_Word_Length_Mismatch">''{0}''의 할당이 유효하지 않음: 워드 길이가 {1,number,integer}인 fi 객체를 워드 길이가 {2,number,integer}인 고정소수점 신호에 할당하려고 함</entry>
    <entry key="FxpPoint_DataType_Mismatch">Invalid assignment in ''{0}'': attempt to assign a fi object with DataType property ''{1}'', which does not match that of the signal.</entry>
    <entry key="GetCurrentTimeInExecOnly">The current simulation time for ''{0}'' can be accessed only when simulation is running</entry>
    <entry key="HalfUnsupportedForSldv">유효하지 않은 데이터형입니다. Half는 Simulink Design Verifier 또는 고정소수점 툴 범위 워크플로에서 지원되지 않습니다.</entry>
    <entry key="ITVSActionSubsysMustHaveScalarIC">Simulink가 유효하지 않은 초기 출력을 감지했습니다. 스칼라 초기 출력이 ''{2}''의 파라미터 ''가변 크기 신호의 크기 전파''가 ''실행을 재개할 때만''으로 설정된 조건부 실행 서브시스템 ''{1}''에 있는 경우, ''{0}''에서 이 스칼라 초기 출력만 허용됩니다.</entry>
    <entry key="ITVSActionSubsysVarDimsMismatch">''{2}''의 {1,number,integer}번 포트에서 입력 신호의 현재 차원 {0,number,integer}을(를) 시간 {5}에서의 이전 값 {3,number,integer}에서 현재 값 {4,number,integer}(으)로 변경할 수 없습니다. 서브시스템의 ''{6}''에 대해 ''가변 크기 신호의 크기 전파'' 파라미터가 ''실행을 재개할 때만''으로 설정되어 있습니다. 그러나 이 서브시스템 실행이 이 시간 스텝 전에 이미 재개되었으므로 신호 크기를 변경할 수 없습니다. 입력 크기 변동은 서브시스템이 실행을 재개하는 시간 스텝과 동기화되어야 합니다.</entry>
    <entry key="ITVSFcnCallSubsysVarDimsMismatch">The current dimension {0,number,integer} of the input signal at port {1,number,integer} of ''{2}'' cannot change at time {3}. For the ''{4}'' in the subsystem, the parameter of ''Propagate sizes of variable-size signals'' is set to ''Only when enabling''. However, since the subsystem was already enabled prior to this time step, the signal size cannot change. Consider changing the variation of the signal input size such that it is in sync with the time step at which the subsystem is being enabled. If this solution is insufficient, place the function-call initiator inside of an Enabled Subsystem.</entry>
    <entry key="ITVSResetSubsysVarDimsMismatch">The current dimension {0,number,integer} of the input signal at port {1,number,integer} of ''{2}'' cannot change from its previous value {3,number,integer} to the current value of {4,number,integer} at time {5}. For the ''{6}'' in the subsystem, the parameter of ''Propagate sizes of variable-size signals'' is set to ''Only when resetting''. However, since the subsystem is not being reset at this time step, the signal size cannot change. The input size variation should be in sync with the time step at which the subsystem is being reset.</entry>
    <entry key="ITVSSubsysMustHaveScalarIC">Simulink detected an invalid initial output. Only scalar initial output is allowed in ''{0}'' when it is in a conditionally executed subsystem ''{1}'' for which the parameter ''Propagate sizes of variable-size signals'' of ''{2}'' is set  to ''Only when enabling''.</entry>
    <entry key="ITVSSubsysVarDimsMismatch">The current dimension {0,number,integer} of the input signal at port {1,number,integer} of ''{2}'' cannot change from its previous value {3,number,integer} to the current value of {4,number,integer} at time {5}. For the ''{6}'' in the subsystem, the parameter of ''Propagate sizes of variable-size signals'' is set to ''Only when enabling''. However, since the subsystem was already enabled prior to this time step, the signal size cannot change. The input size variation should be in sync with the time step at which the subsystem is being enabled.</entry>
    <entry key="IgnoringDataTypeHeaderFilesForERTSfcn">ERT S-Function 래퍼를 생성할 때 지정된 데이터형 헤더 파일이 무시됨</entry>
    <entry key="IllegalValue">''{0}''의 값이 잘못됨</entry>
    <entry key="ImpIterBlkSrcIsNotInportBlk">Invalid source for &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of Implicit Iterator block ''{1}''. Input ports of Implicit Iterator block must connect directly to Inport blocks.</entry>
    <entry key="PerturbJacNotSupportedInForEachSS">서브시스템 내에 있는 한 블록이 이산 상태를 가지지만 해석적 야코비 행렬을 제공하지 않기 때문에 이 서브시스템은 야코비 행렬을 지원하지 않습니다.</entry>
    <entry key="JacWarningForStateInForEachSSOfOriginalModel">야코비 행렬은 원래 모델의 For Each Subsystem 외부에 있는 블록의 이산 상태만 반영합니다.</entry>
    <entry key="IncorrectNumRTPWritten">Error in mdlRTW of S-function ''{0}''. This function wrote {1,number,integer} run-time parameters whereas it has registered {2,number,integer} run-time parameters</entry>
    <entry key="InitStatesInForEachSSNotSupported">Model ''{0}'' has blocks with states inside one or more subsystems which contain a For Each block. Initialization of such states is not supported.</entry>
    <entry key="InitStatesInArrayFormatShouldBeAvoided">모델 ''{0}''에 대한 초기 상태가 배열로 지정되었습니다. 배열 형식으로 지정된 초기 상태 값이 변경되는 경우 고속 액셀러레이터 타깃이 재빌드됩니다. 재빌드하지 않고 초기 상태의 조정을 허용하는 구조체 형식을 사용해 보십시오.\n이 경고는 &lt;sldiag objui="configset" objparam="InitInArrayFormatMsg"&gt;초기 상태가 배열임&lt;/sldiag&gt; 설정을 사용하여 비활성화할 수 있습니다.</entry>
    <entry key="InitStatesInRefMdlNotSupported">Model ''{0}'' has model blocks with states. Initialization of these states in referenced models is not supported if the initial state is specified in array format.</entry>
    <entry key="InjectionDataMethodCalledNotProperly">For the engine interface method "getInjectionDataForSignalBasedLinearization" to execute properly, the model parameter "CompileForInfoOnSignalBasedLinearization" should be set to "on". Make sure that  you run the command "set_param(mdl,''CompileForInfoOnSignalBasedLinearization'',''on'');" before calling the method.</entry>
    <entry key="InputDimsMismatch">The current dimensions of input port {0,number,integer} and &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;input port {1,number,integer}&lt;/sldiag&gt; of ''{2}'' are different at time {3}. All input ports must have the same dimensions throughout the model execution.</entry>
    <entry key="InputDimsModeInconsistent">The dimension mode of input port {0,number,integer} and &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;input port {1,number,integer}&lt;/sldiag&gt; of ''{2}'' are different. All input ports must have the same dimension mode.</entry>
    <entry key="InputNotConnected">블록 ''{1_SLObject}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1_SLObject}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;가 연결되지 않았습니다.</entry>
    <entry key="InputPortFrameDataMismatch">Input port frame data mismatch.  &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' expects {2} data. However, it is driven by {3} data</entry>
    <entry key="InputPortMultiDDimsDisallowed">Cannot set dimensions of &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' to {2}. This block is not set up to handle signals of dimensions greater than 2 dimensions.</entry>
    <entry key="InputPortTrailingUnityDimsDisallowed">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;의 차원을 {2}(으)로 초기화할 수 없습니다. 행렬의 차원 수가 2를 초과할 경우 후행 차원의 크기는 1보다 커야 합니다.</entry>
    <entry key="InsertBlkAtInportIntroduceNewTsInTrigSys">A Rate Transition block cannot be automatically inserted in a triggered or function-call subsystem because it would introduce an invalid rate in that subsystem. Manually inserting a Rate Transition block at &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of block ''{1}'' can fix this error.</entry>
    <entry key="InsertBlkAtOutportIntroduceNewTsInTrigSys">A Rate Transition block cannot be automatically inserted in a triggered or function-call subsystem because it would introduce an invalid rate in that subsystem. Manually inserting a Rate Transition block at &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of block ''{1}'' can fix this error.</entry>
    <entry key="InsertBlkAtVirtualBlkInput">Simulink가 지정되지 않은 레이트 변경을 감지했습니다. 그러나 Simulink는 가상 블록의 Rate Transition 블록 업스트림을 자동으로 삽입할 수 없습니다. 블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 Rate Transition 블록을 수동으로 삽입하십시오.</entry>
    <entry key="InsertBlkAtVirtualBlkOutput">Simulink가 지정되지 않은 레이트 변경을 감지했습니다. 그러나 Simulink는 가상 블록의 Rate Transition 블록 다운스트림을 자동으로 삽입할 수 없습니다. 블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 Rate Transition 블록을 수동으로 삽입하십시오.</entry>
    <entry key="InsertRTBTypeMismatch2Blks">Unable to insert a rate transition block to ensure deterministic data transfer between &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of block ''{1}'' and &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;input port {2,number,integer}&lt;/sldiag&gt; of block ''{3}'' for one of the following reasons: \n - One of the blocks runs at an asynchronous rate; \n - Sample time of one of the blocks has a nonzero offset; \n - Sample times of two blocks are not an integer multiple pair.
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="suggestion"&gt;
            &lt;cmd&gt;configset.internal.open(''{1}'',''InsertRTBMode'')&lt;/cmd&gt;
            &lt;txt&gt;Set ''Deterministic data transfer'' to ''Whenever possible'' or ''Never (minimum delay)''&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="InvActionDuringCallback">콜백 내에 있는 동안에는 모델 ''{0}''을(를) 변경할 수 없음</entry>
    <entry key="InvAlgLoopInConstRateTask">루프 내 모든 블록이 상수 샘플 시간을 갖기 때문에 모델 ''{0}''에 있는 대수 루프의 해를 구할 수 없습니다.</entry>
    <entry key="InvAlgLoopWithConstTsBlocks">Unable to solve algebraic loop in model ''{0}'' because one or more blocks in the loop with a constant sample time are connected to constant sample time ports of blocks such as ''{1}'' that is outside this loop.</entry>
    <entry key="InvAlgLoopWithMultiTaskBlocks">Unable to solve algebraic loop in multi-tasking model ''{0}'' because one or more blocks in the loop has multiple rates.
    &lt;actions exclusiveFixIts="yes"&gt;
    &lt;action type="fixit"&gt;
    &lt;cmd&gt;set_param_action(''{0}'', ''EnableMultiTasking'', ''off'');&lt;/cmd&gt;
    &lt;txt&gt;Consider unselecting configuration option &lt;sldiag objui="configset" objparam="EnableMultiTasking"&gt;''Treat each discrete rate as a separate task''&lt;/sldiag&gt; to change the model to single tasking mode.&lt;/txt&gt;
    &lt;/action&gt;
    &lt;/actions&gt;
    </entry>
    <entry key="InvAlgLoopWithAsyncTsBlocks">루프 내 하나 이상의 블록이 비동기 샘플 시간을 포함하여 다수의 레이트를 갖기 때문에 모델 ''{0}''에 있는 대수 루프의 해를 구할 수 없습니다.</entry>
    <entry key="InvAsyncTimeSourceNotBaseRate">Model 블록 ''{1}''의 함수 호출 입력 포트 ''{2}''을(를) 구동하는 S-Function ''{0}''에 대해 선택한 시간 소스가 유효하지 않습니다. 참조된 모델에 절대 시간을 필요로 하는 블록이 포함되어 있으므로 S-Function에서 이 옵션을 SS_TIMESOURCE_BASERATE로 설정해야 합니다.</entry>
    <entry key="InvAsyncCustomFlag">The flag SS_OPTION_ASYNCHRONOUS_CUSTOM for S-function ''{0}'' is not supported for its function-call destination ''{1}''.</entry>
    <entry key="ModelRefInitAsyncPriorityNotSpecified">The block ''{0}'' must specify asynchronous task priority of {3,number,integer} to match the priority specified at input port ''{2}'' of function-call Model block ''{1}''.</entry>
    <entry key="ModelRefInitAsyncPriorityMismatch">The asynchronous task priority {1,number,integer} specified by block ''{0}'' does not match the priority {4,number,integer} specified at input port ''{3}'' of function-call Model block ''{2}''.</entry>
    <entry key="ModelRefInvalidInitAsyncPriority">동시 태스크가 활성화될 때 S-Function ''{0}''에 의한 비동기 태스크 우선 순위 지정 {1,number,integer}이(가) 유효하지 않습니다.</entry>
    <entry key="ModelRefFcnPortHasMultipleInitiators">Model 블록 ''{0}''은(는) 입력 포트 ''{1}''에서 비동기 함수 호출에 의해 구동됩니다. 여러 개의 비동기 함수 호출을 직접 또는 간접적으로 포함하는 하나의 비동기 함수 호출은 Model 블록 입력 포트를 구동할 수 없습니다.</entry>
    <entry key="InvBlkInputPortTs">Sample time [{0}, {1}] of ''{2}'' input port
    number {3,number,integer} is invalid. Sample time must be a real double
    scalar (period) or a real double vector of length 2 (period, offset); where
    period, offset must be finite and non-negative and offset must be less than
    period. </entry>
    <entry key="InvBlkOutputPortTs">''{2}'' 출력 포트 번호 {3,number,integer}의 샘플 시간 [{0}, {1}]이(가) 유효하지 않습니다. 샘플 시간은 double형 실수 스칼라(period)이거나 길이가 2인 double형 실수 벡터(period, offset)여야 합니다. 여기서 period, offset은 유한하고 음수가 아니어야 하며 offset은 period보다 작아야 합니다.</entry>
    <entry key="InvBlkTs">''{3}''의 샘플 시간 {2,number,integer}(으)로 지정된 period({0}) 및 offset({1})이 유효하지 않습니다. 샘플 시간은 double형 실수 스칼라(period)이거나 길이가 2인 double형 실수 벡터(period, offset)여야 합니다. 여기서 period, offset은 유한하고 음수가 아니어야 하며 offset은 period보다 작아야 합니다. </entry>
    <entry key="InvBlkUsingElapsedTimeInFcnCallSubsys">Function-call subsystem ''{0}'' cannot contain block ''{1}'' because this block requires a service that maintains the time that has elapsed between two consecutive executions. Since the function-call subsystem is being executed multiple times at t = {2}, the concept of elapsed time is not well-defined between two such executions.</entry>
    <entry key="InvBlkUsingElapsedTimeInIteratorSubsys">Iterator subsystem ''{0}'' cannot contain block ''{1}'' because this block requires a service that maintains the time that has elapsed between two consecutive executions. Since the iterator subsystem can be executed multiple times at a given time step, the concept of elapsed time is not well-defined between two such executions.</entry>
    <entry key="InvBlockAdded">Only Inport, Outport, Connection Port, Subsystem and Model blocks can be added to Variant Subsystem block ''{0}''.</entry>
    <entry key="InvBlockDelete">시뮬레이션 실행 중에는 ''{0}''을(를) 삭제할 수 없음</entry>
    <entry key="InvBlockNameInInitStateStruct">Unable to load the specified initial state for model ''{0}''. The {1}({2,number,integer}).{3} field in the initial state structure must be a character vector specifying the path to a block in the model.</entry>
    <entry key="InvCStateChange">시뮬레이션이 실행 중일 때는 ''{0}''의 연속 상태 수를 변경할 수 없음</entry>
    <entry key="InvCallForFeature">''slfeature'' 옵션을 사용한 ''slInternal'' 호출이 유효하지 않습니다. 이 옵션에는 유효한 하위 옵션이 필요합니다.</entry>
    <entry key="InvCallForFeatureName">지정된 slfeature 이름 ''{0}''이(가) 유효하지 않음</entry>
    <entry key="IncompatibleTypeForInplace">입력 및 출력 유형이 인 플레이스 대체(In-place Replacement)에 적합하지 않습니다.</entry>
    <entry key="InplaceVardimNotSupported">''{0}'' uses variable-size in-place input and output signals which are not supported.</entry>
    <entry key="InvCommandDuringPreLoadFcnCallback">PreLoadFcn 콜백을 처리하는 동안에는 모델 ''{1}''에 대해 명령 ''{0}''을(를) 실행할 수 없음</entry>
    <entry key="InvDFeedChange">Cannot change direct feedthrough of ''{0}'' while simulation is running</entry>
    <entry key="InvDStateChange">시뮬레이션이 실행 중일 때는 ''{0}''의 이산 상태 수를 변경할 수 없음</entry>
    <entry key="InvDisallowConstTsChange">시뮬레이션이 실행 중일 때는 ''{0}''의 disallow_constant_ts 플래그를 변경할 수 없음</entry>
    <entry key="InvCompDiscSampleTime"> ''{0}''에 전파된 샘플 시간이 유효하지 않습니다. 입력 신호의 소스에서 고정 이산 샘플 시간을 지정하여 이 오류를 방지할 수 있습니다. 자세한 내용은 &lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''],''specifying_sample_time'')"&gt;"How to specify the sample time"&lt;/a&gt; 항목을 참조하십시오.</entry>
    <entry key="InvUserDiscSampleTime">블록 ''{0}''은(는) 샘플 시간 {1}을(를) 허용하지 않습니다. ''{2}''에 이산 샘플 시간 또는 상속된 샘플 시간을 입력하십시오.</entry>
    <entry key="InvElementInInitStateStruct">모델 ''{0}''에 대해 지정된 초기 상태를 불러올 수 없습니다. 초기 상태에서 인덱스 {1,number,integer}의 요소의 BlockName/BlockPath가 유효하지 않습니다</entry>
    <entry key="InvExtModeMexFile">외부 모드 MEX 파일 ''{0}''이(가) 존재하지 않거나 MATLAB 경로에 있지 않습니다. 입력한 MEX 파일 이름에는 파일 확장자가 없어야 합니다.</entry>
    <entry key="InvExtModeMexFileArgs">외부 모드 MEX 파일 인수 ''{0}''을(를) 구문 분석하는 중에 오류가 발생했습니다.</entry>
    <entry key="InvExtModeParamVectName">''ExtModeParamVectName'' 속성에 대해 지정된 MATLAB 변수 이름이 유효하지 않음</entry>
    <entry key="InvFMexTsLen">''{1}''의 FORTRAN MEX S-Function ''{0}''에 의해 반환된 샘플 시간(TS) 행렬은 {2,number,integer}x2차원 행렬이어야 합니다.</entry>
    <entry key="InvFMexTsMatrix">''{1}''의 FORTRAN MEX S-Function ''{0}''에 의해 반환된 샘플 시간(TS) 행렬이 유효하지 않습니다.</entry>
    <entry key="InvFcnCallSSDataInput">함수 호출 블록의 데이터 종속성 위반입니다.\n함수 호출 블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;가 ''{2}''(으)로 구동됩니다. 함수 호출 블록이 실행될 때 드라이버의 출력이 유효하도록 하려면 이 드라이버를 함수 호출 개시자 ''{3}'' 전에 실행해야 합니다. 그러나 함수 호출 개시자 출력과 드라이버 출력 사이의 데이터 종속성으로 인해 Simulink가 함수 호출 개시자 전에 드라이버를 실행할 수 없습니다. 개시자와 개시자가 실행하는 블록 간의 함수 호출 수는 {4,number,integer}입니다. Simulink 라이브러리에서 서브시스템 예를 참조하여 함수 호출 블록의 유효한 예와 유효하지 않은 예를 확인하십시오.</entry>
    <entry key="InvFcnCallSSDataInputNoObj">함수 호출 블록의 데이터 종속성 위반입니다.\n함수 호출 블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;가 ''{2}''(으)로 구동됩니다. 함수 호출 블록이 실행될 때 드라이버의 출력이 유효하도록 하려면 이 드라이버를 함수 호출 개시자 ''{3}'' 전에 실행해야 합니다. 그러나 함수 호출 개시자 출력과 드라이버 출력 사이의 데이터 종속성으로 인해 Simulink가 함수 호출 개시자 전에 드라이버를 실행할 수 없습니다. 개시자와 개시자가 실행하는 블록 간의 함수 호출 수는 {4,number,integer}입니다. Simulink 라이브러리에서 서브시스템 예를 참조하여 함수 호출 블록의 유효한 예와 유효하지 않은 예를 확인하십시오.</entry>
    <entry key="InvFieldInInitStateStruct">모델 ''{0}''에 대해 지정된 초기 상태를 불러올 수 없습니다. 초기 상태는 {1} 구조체형 배열을 포함하는 구조체여야 합니다. {2} 구조체는 ''{3}'', ''{4}'', ''{5}'' 필드를 가져야 합니다</entry>
    <entry key="InvInputPortChange">시뮬레이션이 실행 중일 때는 ''{0}''의 입력 포트 속성을 변경할 수 없음</entry>
    <entry key="InvLabelInInitStateStruct">모델 ''{0}''에 대해 지정된 초기 상태를 불러올 수 없습니다. 초기 상태에서 인덱스({2,number,integer})의 요소의 {1} 필드는 유효한 상태 레이블을 지정하는 문자형 벡터여야 합니다</entry>
    <entry key="InvLineAdded">Variant Subsystem 블록 ''{0}''에 선을 추가할 수 없습니다.</entry>
    <entry key="InvLinearAnalysisAttrChange">시뮬레이션이 실행 중일 때는 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;의 선형 분석 특성을 변경할 수 없음</entry>
    <entry key="InvMFileTsLen">''{1}''의 MATLAB S-Function ''{0}''에 의해 반환된 샘플 시간(TS) 행렬은 {2,number,integer}x2차원 행렬이어야 합니다.</entry>
    <entry key="InvMFileTsMatrix">''{1}''의 MATLAB S-Function ''{0}''에 의해 반환된 샘플 시간(TS) 행렬이 유효하지 않습니다.</entry>
    <entry key="InvMatlFeatureCalledViaSlFeature">slfeature는 특징 ''{0}''에 대한 게이트웨이로 사용할 수 없습니다. 이 특징은 (a) Simulink에서 등록되지 않았거나 (b) 이 게이트웨이를 통해 호출할 수 없는 특수 콜백을 가지고 있습니다.</entry>
    <entry key="InvMdlRefFieldInInitStateStruct">Unable to load the specified initial state for model ''{0}''. The {1}({2,number,integer}).{3} field in the initial state structure must be a logical scalar value</entry>
    <entry key="InvMemLayoutConnStatePort">''{2}''의 상태 포트에서 ''{0}'' {1,number,integer}번 입력 포트로의 연결이 유효하지 않습니다. 데이터 출력 포트의 신호만 이 블록에 연결할 수 있습니다.</entry>
    <entry key="InvMemLayoutConnectType">Invalid memory layout connection setting found in ''{0}'' output port {1,number,integer}. Please contact MathWorks for assistance with this error message</entry>
    <entry key="InvMemLayoutLoop">Invalid loop involving blocks {0}</entry>
    <entry key="InvMemLayoutPartialPortSrc">메모리 레이아웃 블록 ''{0}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;와 해당 소스 사이에 유효하지 않은 부분 포트 연결이 발견되었습니다. 이 오류 메시지와 관련하여 도움이 필요하면 MathWorks에 문의하십시오.</entry>
    <entry key="InvModeVectChange">Changing the number of elements in the mode vector of ''{0}'' during simulation is not supported.</entry>
    <entry key="InvModelBusy">콜백 또는 파라미터 평가를 처리하는 동안에는 모델 ''{0}''을(를) 닫을 수 없습니다.</entry>
    <entry key="InvModelChange">시뮬레이션 실행 중에는 모델 ''{0}''을(를) 변경할 수 없음</entry>
    <entry key="InvModelChangeInFastRestart">[빠른 재시작]에서 초기화되는 동안에는 모델 ''{0}''을(를) 변경할 수 없습니다. [빠른 재시작]을 비활성화하려면 &lt;a href=\"matlab:set_param(bdroot,'FastRestart','off')\"&gt;여기&lt;/a&gt;를 클릭하십시오.</entry>
    <entry key="InvModelSimDuringClose">모델 ''{0}''을 닫는 중에는 모델을 시뮬레이션할 수 없습니다.</entry>
    <entry key="InvSimCommandArgumentsForFastRestart">[빠른 재시작]이 활성화된 경우 다음 파라미터는 sim 명령에서 지원되지 않음: ''{0}''</entry>
    <entry key="InvModelClose">모델 ''{0}''이(가) 컴파일되고 있거나 시뮬레이션이 실행 중일 때에는 이 모델을 닫을 수 없음</entry>
    <entry key="InvModelCloseWhenInitializedInFastRestart">모델 ''{0}''이(가) [빠른 재시작]에서 초기화된 경우에는 이 모델을 닫을 수 없음</entry>
    <entry key="InvModelCloseDuringSave">모델 ''{0}''이(가) 저장되는 동안에는 이 모델을 닫을 수 없음</entry>
    <entry key="InvModelInitingModelWS">모델 작업 공간을 초기화하는 동안에는 모델 ''{0}''을(를) 닫을 수 없음</entry>
    <entry key="InvModelCompileWhenInitingModelWS">모델 작업 공간의 초기화 중에 모델 ''{0}''을(를) 컴파일할 수 없습니다.</entry>
    <entry key="InvModelUdim">{0}''{2}''에 제공된 입력 벡터 길이({1,number,integer})가 유효하지 않음. 길이는 {3,number,integer}이어야 함</entry>
    <entry key="InvNameChangeDuringLoad">블록 다이어그램 ''{0}''을(를) 불러오는 중일 때는 이름을 ''{1}''(으)로 변경할 수 없습니다. 블록 다이어그램을 완전히 불러온 후에만 이름을 변경할 수 있습니다.</entry>
    <entry key="InvNumPortsChange">시뮬레이션이 실행 중일 때는 ''{0}''의 포트 수를 변경할 수 없음</entry>
    <entry key="InvOptionForFeature">''slfeature'' 옵션을 사용한 ''slInternal'' 호출에 제공된 하위 옵션 ''{0}''이(가) 유효하지 않음</entry>
    <entry key="InvOptionForFeatureGetSet">get/set slfeature 호출이 유효하지 않음</entry>
    <entry key="InvOptionForFeatureStats">''slfeature'' 옵션을 사용한 ''slInternal'' 호출에서 하위 옵션 ''stats''에 대해 제공된 추가 입력 인수가 유효하지 않습니다. 추가 인수가 필요하지 않습니다.</entry>
    <entry key="InvOutHasDiscontChange">시뮬레이션이 실행 중일 때는 ''{0}''의 output_has_discontinuities 플래그를 변경할 수 없음</entry>
    <entry key="InvParamComplexityChange">Cannot change complexity (real or complex) of parameter {0,number,integer} in ''{1}'' while the simulation is running</entry>
    <entry key="InvParamDTypeChange">Cannot change data type of parameter {0,number,integer} in ''{1}'' while the simulation is running</entry>
    <entry key="InvParamWidthChange">시뮬레이션 실행 중에는 ''{1}''의 {0,number,integer}번 파라미터 너비를 변경할 수 없음</entry>
    <entry key="InvPortCharChange">시뮬레이션이 실행 중일 때는 ''{0}''의 포트 특성을 변경할 수 없음</entry>
    <entry key="InvPortDimsChange">시뮬레이션이 실행 중일 때는 ''{0}''의 포트 차원을 변경할 수 없음</entry>
    <entry key="InvPriOnBEP">Priorities cannot be specified on In Bus Element blocks, or Out Bus Element blocks inside non-virtual subsystems. Ignoring priority {0,number,integer} specified on block ''{1}''.</entry>
    <entry key="InvPriOnFcnCallSS">Ignoring priority {0,number,integer} specified on function-call block ''{1}''. Priorities cannot be specified on function-call blocks since their execution is controlled by their function-call initiators.</entry>
    <entry key="InvPriOnActionSS">Action Subsystem ''{1}''에 지정된 우선 순위 {0,number,integer}을(를) 무시합니다. Action Subsystem의 실행은 If 블록 또는 Switch Case 블록에 의해 제어되므로 Action Subsystem에 대해 우선 순위를 지정할 수 없습니다.</entry>
    <entry key="InvPriOnIteratorBlock">For Iterator 블록 또는 While Iterator 블록 ''{1}''에 지정된 우선 순위 {0,number,integer}을(를) 무시합니다. Iterator 블록은 For Iterator Subsystem 또는 While Iterator Subsystem 내에서 실행되는 첫 번째 블록이어야 하므로 이 블록에 대해 우선 순위를 지정할 수 없습니다.</entry>
    <entry key="InvPriOnMergeBlock">Merge 블록 ''{1}''에 지정된 우선 순위 {0,number,integer}을(를) 무시합니다. Merge 블록의 실행은 해당 입력 포트 소스에 의해 제어되므로 Merge 블록에 대해 우선 순위를 지정할 수 없습니다.</entry>
    <entry key="InvPriOnInjInportOutportBlk">Injector Inport/Outport 블록 ''{1}''에 지정된 우선 순위 {0,number,integer}을(를) 무시합니다. Injector Inport/Outport 블록에 대해 우선 순위를 지정할 수 없습니다.</entry>
    <entry key="InvPriOnMultiTaskBlock">여러 태스크에서 실행되는 블록 ''{1}''에 지정된 우선 순위 {0,number,integer}을(를) 무시합니다.</entry>
    <entry key="InvPriOnIRTFunction">Initialize Function, Reinitialize Function, Reset Function 또는 Terminate Function 블록 ''{1}''에 지정된 우선 순위 {0,number,integer}을(를) 무시합니다. Initialize Function, Reinitialize Function, Reset Function 또는 Terminate Function 블록의 실행은 해당 스케줄러에 의해 제어됩니다.</entry>
    <entry key="InvPriOnSimulinkFunction">Simulink 함수 ''{1}''에 지정된 우선 순위 {0,number,integer}을(를) 무시합니다. Simulink 함수의 실행은 해당 Function Caller 블록에 의해 제어되므로 Simulink 함수에 대해 우선 순위를 지정할 수 없습니다.</entry>
    <entry key="InvPriOnVirtBlock">{1} ''{2}''에 지정된 우선 순위 {0,number,integer}을(를) 무시합니다. 가상 블록에 대해 우선 순위를 지정할 수 없습니다.</entry>
    <entry key="InvCheckActDstOKToReadInputInStart">지정된 출력 포트의 소유자 블록 ''{0}''이(가) 가상 블록 또는 대체된 블록이기 때문에 표시할 정보가 없습니다. 비가상 블록 또는 대체되지 않은 블록에 해당하는 출력 포트를 지정하십시오.</entry>
    <entry key="InvRTWGenSettingsYESNOType">RTWGenSetting 필드 ''{0}''의 값은 ''yes'' 또는 ''no''만 될 수 있음</entry>
    <entry key="InvRTWIdLen">식별자에 대해 지정된 길이가 유효하지 않습니다(구성 파라미터 대화 상자의 코드 생성 ''식별자'' 참조). 식별자 길이는 {0,number,integer}보다 크거나 같아야 합니다.</entry>
    <entry key="InvRapidAccelRTPOpt">고속 액셀러레이터 파라미터 세트의 사양이 유효하지 않습니다. 옵션 ''RapidAcceleratorUpToDateCheck''를 ''off''로 설정해야 합니다</entry>
    <entry key="InvRapidAccelUpdateCheckOpt">Invalid Rapid Accelerator Update Check option</entry>
    <entry key="InvRetForFeature">''slfeature'' 옵션을 사용한 ''slInternal'' 호출에 대한 반환 값 개수가 유효하지 않음</entry>
    <entry key="InvReturnWkspOutputOpt">Invalid value for the option ReturnWorkspaceOutputs</entry>
    <entry key="InvSFcnCall_CommonInit">Invalid configuration for block ''{0}''. The function-calls exported on input ports ''{1,number,integer}'' and ''{2,number,integer}'' are not driven by a common function-call initiator</entry>
    <entry key="InvSFcnCall_InlinedInAccel">Unable to simulate S-Function block ''{0}'' in accelerator mode because its function-call input port {1,number,integer} is driven by block ''{2}'' that is not a noninlined S-function. An S-function is identified as noninlined if it does not use TLC in accelerator mode.</entry>
    <entry key="InvSFcnCall_RTWNotSupported">The S-Function block ''{0}'' does not support code generation because the block is configured to export function calls</entry>
    <entry key="InvSFcnStructParamDType">''{1}''의 파라미터 {0,number,integer}의 값이 유효하지 않습니다. 해당 데이터형이 S-Function이 생성될 때 사용된 구조체 데이터형과 일치하지 않기 때문입니다.</entry>
    <entry key="InvSaveMdlBeforeSaveAs">저장되지 않은 변경 내용이 있으므로 모델을 이전 버전으로 내보낼 수 없습니다. 진행하기 전에 모델을 저장하십시오.</entry>
    <entry key="MDXNotSupportExportToPrevious">Cannot export a model which uses system target file "mdx.tlc" to a release older than R2020a.</entry>
    <entry key="ExportSubsystemUnsupportedRelease">Cannot export a subsystem model to a release older than R2019b.</entry>
    <entry key="InvScopeArrayFormat1">''{0}''은(는) 둘 이상의 입력 포트를 가지며 ''형식'' 파라미터를 ''구조체'' 또는 ''시간값을 갖는 구조체''로 설정하고 ''배열''로 설정하지 않은 경우에만 멀티포트 데이터를 기록할 수 있습니다. 이 파라미터는 ''스코프 파라미터'' 대화 상자의 ''데이터 내역'' 탭에 있습니다. 이 대화 상자는 ''스코프'' 메뉴에서 선택할 수 있습니다.</entry>
    <entry key="InvScopeArrayFormat2">''{0}''에 대한 입력은 행렬 신호입니다. 행렬 신호는 ''형식'' 파라미터를 ''구조체'' 또는 ''시간값을 갖는 구조체''로 설정하고 ''배열''로 설정하지 않은 경우에만 기록할 수 있습니다. 이 파라미터는 ''스코프 파라미터'' 대화 상자의 ''데이터 내역'' 탭에 있습니다. 이 대화 상자는 ''스코프'' 메뉴에서 선택할 수 있습니다.</entry>
    <entry key="InvSignalDims">''{0}''에 지정된 차원이 유효하지 않습니다. 차원은 상속되거나(-1로 설정됨) 양의 정수 값을 포함하는 벡터로 지정되어야 합니다.</entry>
    <entry key="InvSignalDimsDataType">Dimensions specified in ''{0}'' have an invalid data type. Dimensions must be specified with a &lt;a href="matlab:helpview([docroot ''/simulink/ug/simulink_ug.map''], ''dataTypes'')"&gt;Simulink built-in data type&lt;/a&gt;.</entry>
    <entry key="InvSignalDimsWidth">포트 너비 또는 차원에 오류가 있습니다. ''{1}''에 지정된 차원 ''{0}''은(는) 1에서 {2,number,integer} 사이의 크기를 지정해야 합니다.</entry>
    <entry key="InvSimCommandDuringPreLoadFcnCallback">Cannot execute sim command for  model ''{0}'' while processing PreLoadFcn callback</entry>
    <entry key="InvStatePortUsage">상태 포트는 대수 루프를 끊거나 시스템 간에 상태를 "넘겨주기" 위해서만 사용할 수 있습니다. (직접 연결 또는 가상 연결을 통해) ''{1}''(으)로 라우팅되는 신호의 소스로 ''{0}''의 상태 포트 대신 출력 포트를 사용하십시오</entry>
    <entry key="InvSubsystemResetInputSampleTime">서브시스템 ''{0}''에 들어오는 재설정 신호의 샘플 시간이 서브시스템의 샘플 시간과 다릅니다. 서브시스템의 재설정 입력 포트에 Rate Transition 블록을 삽입해 보십시오.</entry>
    <entry key="InvSupAliasTypeChange">시뮬레이션이 실행 중일 때는 ''{0}''의 supports_alias_data_types 플래그를 변경할 수 없음</entry>
    <entry key="InvTnext">''{2}''에서 S-Function ''{1}''에 의해 반환된 다음 적중 시간 {0}은(는) 이전 적중 시간 값 {3}보다 커야 합니다.</entry>
    <entry key="InvTnextForM">flag={3,number,integer} 호출 중에 ''{2}''에서 S-Function ''{1}''에 의해 반환된 다음 적중 시간 {0}은(는) 이전 적중 시간 값 {4}보다 커야 합니다.</entry>
    <entry key="InvTrigSignal">트리거 신호를 정의하는 ''{0}''은(는) 데이터 기록 작업에 맞게 구성되어 있어야 함</entry>
    <entry key="InvTsChange">시뮬레이션이 실행 중일 때는 ''{0}''의 샘플 시간을 변경할 수 없습니다.</entry>
    <entry key="InvValForFeatureSet">slfeature ''{0}''을(를) 설정하는 동안 정수 스칼라 값을 지정해야 함</entry>
    <entry key="InvValuesComplexityInInitStateStruct">Type mismatch in the initial state for model ''{0}''. The {1}({2,number,integer}).{3} field in the initial state structure is complex valued, whereas the corresponding state ''{4}'' in block ''{5}'' is not complex valued</entry>
    <entry key="InvValuesDataTypeInInitStateStruct">Data type mismatch in the initial state for model ''{0}''. The {1}({2,number,integer}).{3} field in the initial state structure is of type {4}, whereas the corresponding state ''{5}'' in block ''{6}'' is of type {7}.</entry>
    <entry key="InvValuesInInitStateStruct">모델 ''{0}''에 대해 지정된 초기 상태를 불러올 수 없습니다. 초기 상태 구조체의 {1}({2,number,integer}).{3} 필드는 유한한 숫자형 배열이어야 합니다</entry>
    <entry key="InvValuesInInitStateStructFixedPt">Unable to load fixed-point data for field {0}({1,number,integer}).{2} in the initial state structure. Use Dataset format to load fixed-point initial state data.</entry>
    <entry key="InvValuesInInitStateRaccelFixedPt">Unable to load fixed-point data for 'values' field at index ({0,number,integer}) in the initial state. Fix point data type is not supported for loading initial states.</entry>
    <entry key="InvValuesInInitStateRaccelHalf">Unable to load half-precision data for 'values' field at index ({0,number,integer}) in the initial state. Half data type is not supported for loading initial states.</entry>
    <entry key="InvValuesInInitState">Unable to load data for 'values' field at index ({0,number,integer}) in the initial state. 'values' field in the initial state must be a finite numeric or logical array.</entry>
    <entry key="InvValuesSizeInInitStateStruct">모델 ''{0}''에 대한 초기 상태의 크기가 일치하지 않습니다. 초기 상태 구조체의 {1}({2,number,integer}).{3} 필드에 {4,number,integer}개의 요소가 있는데 반해, 블록 ''{6}''의 대응하는 상태 ''{5}''에는 {7,number,integer}개의 요소가 있습니다</entry>
    <entry key="InvVarTsLoc">''{0}''은(는) 가변 스텝 크기 샘플 시간을 포함하기 때문에 조건부 실행 서브시스템 내에서 허용되지 않습니다.</entry>
    <entry key="InvVectorModeChange">시뮬레이션이 실행 중일 때는 ''{0}''의 벡터/행렬 연산 모드를 변경할 수 없음</entry>
    <entry key="InvalidBlockConnection">예기치 않거나 유효하지 않은 블록 연결입니다. 이는 라이브러리 블록이 원래 구현과 호환되지 않는 새 영역을 사용하도록 기본 구현을 변경할 때 발생할 수 있습니다. 일관된 영역을 사용하도록 블록 연결을 확인하고 다시 구성하십시오.</entry>
    <entry key="UnknownCharacterEncoding">모델 ''{1}''에 대해 지정된 문자 인코딩 ''{0}''을(를) 알 수 없습니다.</entry>
    <entry key="InvalidCondInput">S-function ''{0}'' indicated that its &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;input port {1,number,integer}&lt;/sldiag&gt; is conditionally needed in the output function. However, the input port direct feed through flag is false. That is, it does not need its input in the output function. This is invalid.</entry>
    <entry key="InvalidDimFromETVSSubsysIC">유효하지 않은 차원이 감지됨: ''{0}''의 초기 출력이 {1,number,integer}의 출력 차원을 {2,number,integer}이(가) 되도록 지정하는데, 이는 최대 차원 {3,number,integer}을(를) 초과합니다.</entry>
    <entry key="InvalidDtypeIDFromDataDictionary">데이터 사전이 유형 ''{0}''에 대해 생성한 유형 ID가 유효하지 않습니다.</entry>
    <entry key="InvalidElementName">이름이 ''{0}''인 요소가 존재함</entry>
    <entry key="InvalidElementType">요소 유형이 유효하지 않음</entry>
    <entry key="InvalidICForBusWithVarDimsElements">Initial output of ''{0}'' block does not support a bus with variable size elements.</entry>
    <entry key="InvalidInitialDimensions_sds">포트 초기 차원이 유효하지 않습니다. ''{2}''의 {0} 포트 {1,number,integer}의 차원이 설정되지 않았습니다.</entry>
    <entry key="InvalidInputTypeForProdWithVardims">The input to ''{0}'' is a variable-size signal with a data type of fixed-point with non-zero bias and/or slope. Product blocks do not support this input. If you wish to use fixed-point data type, consider changing the bias to zero and/or using unitary slope.</entry>
    <entry key="InvalidInputTypeForSumWithVardims">The input to ''{0}'' is a variable-size signal with a data type of fixed-point with non-zero bias. Sum blocks do not support this input. If you wish to use fixed-point data type, consider changing the bias to zero.</entry>
    <entry key="InvalidInputVariableSizeSignal">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 연결된 신호는 가변 크기 신호이며, 이는 현재 코드 생성 시 사용할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{1}'',''SupportVariableSizeSignals'',''on'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="SupportVariableSizeSignals"&gt;가변 크기 신호 지원&lt;/sldiag&gt; 선택(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="InvalidInputVariableSizeSignalInRowMajor">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 연결된 신호는 가변 크기 신호입니다. 현재 이러한 신호는 행 우선 배열 레이아웃의 코드 생성에서 지원되지 않습니다.</entry>
    <entry key="NDDynamicArrayInputSignalInRowMajor">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 연결된 신호는 다차원 동적 배열 신호입니다. 현재 이러한 신호는 행 우선 배열 레이아웃의 코드 생성에서 지원되지 않습니다.</entry>
    <entry key="InvalidMemSecForSystem">Invalid memory section ''{0}'' for ''{1}'' specified in the Subsystem Parameters dialog of block ''{2}''. The memory section package ''{3}'' is loaded in Embedded Coder Dictionary. Please select memory section from ''{3}'' package</entry>
    <entry key="InvalidMemSecForSystemDefaults">Invalid memory section ''{0}'' for ''{1}'' specified in the Configuration Parameters dialog of block diagram ''{2}''. The memory section package is ''{3}''</entry>
    <entry key="InvalidModelArgument">''{0}''은(는) 유효한 인수가 아님</entry>
    <entry key="InvalidModelFlag">Simulink 모델 ''{0}''이(가) 유효하지 않은 플래그와 함께 호출됨</entry>
    <entry key="InvalidModelFlagOption">''{0}''은(는) 유효하지 않은 플래그 옵션임</entry>
    <entry key="InvalidModelOption">''{0}''은(는) 유효하지 않은 옵션임</entry>
    <entry key="InvalidNumDataStores">''{0}''에 대한 데이터저장소 개수는 음수일 수 없음</entry>
    <entry key="InvalidNumDworks">''{0}''에 대한 Dwork 개수는 음수일 수 없음</entry>
    <entry key="InvalidNumInputPorts">''{0}''에 대한 입력 포트 개수는 음수일 수 없음</entry>
    <entry key="InvalidNumModelArg">Simulink 모델 ''{0}''이(가) 잘못된 개수의 인수와 함께 호출됨</entry>
    <entry key="InvalidNumOutputPorts">''{0}''에 대한 출력 포트 개수는 음수일 수 없음</entry>
    <entry key="InvalidOutputVariableSizeSignal">The signal connected to the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of block ''{1}'' is a variable-size signal, which is currently disabled for code generation.
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;configset.internal.fixIt(''{1}'',''SupportVariableSizeSignals'',''on'')&lt;/cmd&gt;
            &lt;txt&gt;Select &lt;sldiag objui="configset" objparam="SupportVariableSizeSignals"&gt;Support variable-size signals&lt;/sldiag&gt; (might impact referenced or referencing models)&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="InvalidOutputVariableSizeSignalInRowMajor">블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호는 가변 크기 신호입니다. 현재 이러한 신호는 행 우선 배열 레이아웃의 코드 생성에서 지원되지 않습니다.</entry>
    <entry key="NDDynamicArrayOutputSignalInRowMajor">블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호는 다차원 동적 배열 신호입니다. 현재 이러한 신호는 행 우선 배열 레이아웃의 코드 생성에서 지원되지 않습니다.</entry>
    <entry key="InvalidPassThroughInputIdx">S-Function 블록 ''{1}''에 대한 ''ssSetInputDimsSameAsOutputDims''에 지정된 입력 포트 인덱스 {0,number,integer}이(가) 존재하지 않습니다.</entry>
    <entry key="InvalidPassThroughOutputIdx">S-Function 블록 ''{1}''에 대한 ''ssSetInputDimsSameAsOutputDims''에 지정된 출력 포트 인덱스 {0,number,integer}이(가) 존재하지 않습니다.</entry>
    <entry key="InvalidReturnErrorsOption">''{0}'' is an invalid option for CaptureErrors.</entry>
    <entry key="InvalidSkipParameterUpdateOption">''{0}'' is an invalid option for SkipParameterUpdate.</entry>
    <entry key="InvalidFastRestartOption">''{0}'' is an invalid option for FastRestart.</entry>
    <entry key="InvalidLiveTuningOption">''LiveTuning''에 유효하지 않은 옵션 ''{0}''이(가) 지정되었습니다.</entry>
    <entry key="SkipParameterUpdateNeedsFastRestart">SkipParameterUpdate parameter can be set only when the model is initialized in Fast Restart.</entry>
    <entry key="InvalidSCDBlockLinearizationSpecification">블록 파라미터 ''SCDBlockLinearizationSpecification''이 유효하지 않습니다. 이 파라미터는 MATLAB 구조체이거나 비어 있는 MATLAB 배열 []이어야 합니다. 구조체는 ''Name'', ''Specification'', ''Type'', ''ParameterNames'', ''ParameterValues'' 필드를 가지며 필드에는 문자형 벡터만 포함해야 합니다.</entry>
    <entry key="InvalidSampleTime">Invalid sample time format has been specified for ''{0}''. Sample time must be specified using a vector of the form [sample_time, offset_time]</entry>
    <entry key="InvalidSampleTimeForMSFcn">''{0}''에 대해 유효하지 않은 샘플 시간 형식이 지정되었습니다. 샘플 시간은 [sample_time, offset_time] 형식의 벡터를 사용하여 지정해야 합니다. Level-2 MATLAB S-Function에 대한 유효한 샘플 시간 쌍은 다음과 같습니다. 연속: [0, offset], 이산: [discrete_sample_time_period, offset], 상속: [-1, 0], 가변: [-2, 0]</entry>
    <entry key="InvalidPortSampleTimeForMSFcn">''{2}'' 포트 {3,number,integer}의 샘플 시간 [{0}, {1}]이(가) 유효하지 않습니다. 샘플 시간은 [sample_time, offset_time] 형식의 벡터를 사용하여 지정해야 합니다. Level-2 MATLAB S-Function에 대한 유효한 샘플 시간 쌍은 다음과 같습니다. 연속: [0, offset], 이산: [discrete_sample_time_period, offset], 상속: [-1, 0], 가변: [-2, 0]</entry>
    <entry key="InvalidScalarICTypeForOutportWithVirtualBus">The parameter ''Initial output'' of Outport block ''{0}'' must be of data type ''boolean'', ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', ''double'', or fixed-point data type, because the parameter is scalar and the Outport block is driven by a virtual bus signal with mixed data types.</entry>
    <entry key="InvalidScrollbarOffset">스크롤바 오프셋은 길이가 2인 양의 정수 벡터여야 함</entry>
    <entry key="InvalidSelfLoop" context="error">블록 ''{0}''을(를) 포함하는 비가상 서브시스템 ''{1}'' 주위의 자가 루프로 인해 블록 ''{0}''을(를) 포함하는 대수 루프의 해를 구할 수 없습니다.</entry>
    <entry key="InvalidSimViewingDevice">''{0}''은(는) 유효한 SimViewingDevice가 아닙니다. SimViewingDevices는 다음 요구 사항을 충족해야 합니다. \n \t - 싱글레이트여야 함 \n \t - 연속 상태가 없어야 함 \n \t - 출력이 없어야 함
</entry>
    <entry key="InvalidSolver">블록 다이어그램 ''{1}''에 연속 상태가 포함되어 있으므로 "{0}" 솔버를 사용하여 이 블록 다이어그램을 시뮬레이션할 수 없음</entry>
    <entry key="InvalidContStateInExpFcnMdl">Export-function model ''{0}'' does not support block ''{1}'' because the block has continuous states.</entry>
    <entry key="InvalidZeroCrossingInExpFcnMdl"> 영점교차 검출은 함수 내보내기 모델 "{0}"에서 지원되지 않습니다.</entry>
    <entry key="InvalidInputSignalComplexity">The signal connected to &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of block ''{1}'' is complex valued or contains complex valued bus element(s).
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="suggestion"&gt;
            &lt;txt&gt;Change the signal or bus element(s) to non-complex&lt;/txt&gt;
        &lt;/action&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;configset.internal.fixIt(''{1}'',''SupportComplex'',''on'')&lt;/cmd&gt;
            &lt;txt&gt;Select &lt;sldiag objui="configset" objparam="SupportComplex"&gt;Support complex numbers&lt;/sldiag&gt; (might impact referenced or referencing models)&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="InvalidInputSignalDataType">The signal connected to &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of block ''{1}'' is a floating point type or contains floating point type bus elements(s).
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="suggestion"&gt;
            &lt;txt&gt;Change the data type&lt;/txt&gt;
        &lt;/action&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;configset.internal.fixIt(''{1}'',''PurelyIntegerCode'',''off'')&lt;/cmd&gt;
            &lt;txt&gt;Select &lt;sldiag objui="configset" objparam="PurelyIntegerCode"&gt;Support floating-point numbers&lt;/sldiag&gt; (might impact referenced or referencing models)&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="InvalidOutputSignalComplexity">The signal connected to &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of block ''{1}'' is complex valued or contains complex valued bus element(s).
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="suggestion"&gt;
            &lt;txt&gt;Change the signal or bus element(s) to non-complex&lt;/txt&gt;
        &lt;/action&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;configset.internal.fixIt(''{1}'',''SupportComplex'',''on'')&lt;/cmd&gt;
            &lt;txt&gt;Select &lt;sldiag objui="configset" objparam="SupportComplex"&gt;Support complex numbers&lt;/sldiag&gt; (might impact referenced or referencing models)&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="InvalidOutputSignalDataType">블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호가 부동소수점 형식이거나 부동소수점 형식 버스 요소를 포함합니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;데이터형을 변경하십시오&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{1}'',''PurelyIntegerCode'',''off'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="PurelyIntegerCode"&gt;부동소수점 숫자 지원&lt;/sldiag&gt;을 선택하십시오(참조된 모델이나 참조 모델에 영향을 줄 수 있음)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="InvalidWorkComplexity">블록 ''{0}''의 작업 벡터가 복소수 값을 가집니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;데이터형 변경&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''SupportComplex'',''on'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="SupportComplex"&gt;복소수 지원&lt;/sldiag&gt; 선택(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="InvalidWorkDataType">블록 ''{0}''의 작업 벡터가 부동소수점 형식을 포함합니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;데이터형 변경&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''PurelyIntegerCode'',''off'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="PurelyIntegerCode"&gt;부동소수점 숫자 지원&lt;/sldiag&gt; 선택(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="InvalidRTParamComplexity">블록 ''{1}''의 파라미터 ''{0}''이(가) 복소수 값을 가집니다. 이 값을 복소수가 아닌 값으로 변경하거나 구성 파라미터 &gt; 코드 생성 &gt; 인터페이스 창에서 ''지원: 복소수'' 체크박스를 선택해 보십시오.</entry>
    <entry key="InvalidRTParamDataType">The parameter ''{0}'' of block ''{1}'' is a floating point type.
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="suggestion"&gt;
            &lt;txt&gt;Change the data type&lt;/txt&gt;
        &lt;/action&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;configset.internal.fixIt(''{1}'',''PurelyIntegerCode'',''off'')&lt;/cmd&gt;
            &lt;txt&gt;Select &lt;sldiag objui="configset" objparam="PurelyIntegerCode"&gt;Support floating-point numbers&lt;/sldiag&gt; (might impact referenced or referencing models)&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="InvalidWksParamComplexity">파라미터 ''{0}''이(가) 복소수 값을 가집니다. 이 값을 복소수가 아닌 값으로 변경하거나 구성 파라미터 &gt; 코드 생성 &gt; 인터페이스 창에서 ''지원: 복소수'' 체크박스를 선택해 보십시오.</entry>
    <entry key="InvalidWksParamDataType">The parameter ''{0}'' is a floating-point type. Consider changing the data type or selecting the ''Support: floating-point numbers'' check box on the Configuration Parameters &gt; Code Generation &gt; Interface pane</entry>
    <entry key="InvalidStructuredWksParamComplexity">Parameter ''{0}'' is complex valued. Consider changing it to non-complex or selecting the ''Support: complex numbers'' check box on the Configuration Parameters &gt; Code Generation &gt; Interface pane</entry>
    <entry key="InvalidStructuredWksParamDataType">Parameter ''{0}'' is a floating-point type. Consider changing the data type or selecting the ''Support: floating-point numbers'' check box on the Configuration Parameters &gt; Code Generation &gt; Interface pane</entry>
    <entry key="InvalidTypeForDWorkDimArg">''{0}''에 대해 지정된 데이터형이 유효하지 않습니다. 파생된 파라미터의 데이터형은 ''double''이어야 합니다.</entry>
    <entry key="InvalidVarDimsAssignForOutputPort">Invalid variable dimensions assignment for &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}''. Variable dimensions must be an array of nonnegative integers and each integer cannot exceed the maximum dimension</entry>
    <entry key="InvalidVirtualBusSignalTypeForOutportWithScalarIC">Invalid signal data type at &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of block ''{1}''. All signals in the virtual bus driving the Outport block ''{2}'' must be of type ''boolean'', ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', ''double'', or fixed-point data type, because the parameter ''Initial output'' of Outport block is scalar.</entry>
    <entry key="UnableToInitializeOutput">Unable to determine an initial output value for the outport block ''{0}''.</entry>
    <entry key="UnableToInitializeOutputCauseDueToInvalidICSrc">Outport 블록의 소스 블록 중 하나 이상이 유효한 초기 조건 소스가 아니기 때문에 초기 출력을 상속할 수 없습니다. 자세한 내용은 Simulink 도움말 문서에서 &lt;a href="matlab:helpview([docroot ''/toolbox/simulink/helptargets.map''], ''inherit_initial_output_values'')"&gt;''Inherit Initial Output Values from Input Signals''&lt;/a&gt;를 참조하십시오.
    </entry>
    <entry key="UnableToInitializeOutputCauseDueToUnsupportedDataType">그라운드 값을 디폴트 초기 출력으로 사용할 수 없습니다. 소스 블록 ''{1}''의 {0, number, integer}번 출력 포트의 데이터형에 대해 이러한 값을 확인할 수 없기 때문입니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;Simulink.internal.OpenBlockParamsDialog(''{2}'',''InitialOutput'')&lt;/cmd&gt; &lt;txt&gt;''{2}''에 대해 ''초기 출력''을 ''[]''이 아닌 값으로 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    
    </entry>
    <entry key="Invalid_Listner_TID_Format">''{0}''에 대해 유효하지 않은 이벤트 리스너 TID 형식이 지정되었습니다. 이벤트 리스너 TID는 [tid_1, tid_2, tid_3] 형식의 벡터를 사용하여 지정되어야 합니다.</entry>
    <entry key="JacobianAnalyticLinNotEnabled">AnalyticLinearization option is not enabled</entry>
    <entry key="LatchLinearizeErr">Cannot add linearization point at inport block ''{0}'' because such points are not supported for inports which have the option to latch subsystem inputs during execution turned on.</entry>
    <entry key="LatchLoopAssert">서브시스템 ''{1}''의 {0,number,integer}번 입력을 실행하는 동안 래치할 수 없습니다. 이 입력에 대한 메모리 버퍼는 시뮬레이션 과정 동안 유지되는 서브시스템의 다른 입력 중 하나에 대한 메모리 버퍼에 매핑됩니다. 정상적인 작업에서는 이 오류가 표시되지 않습니다. 이 오류는 이 모델에서 버퍼 재사용과 관련하여 발생할 수 있는 잠재적 문제를 나타냅니다. 이 문제를 버그로 보고하고 이 입력을 보내는 Outport 블록 앞에 Signal Conversion 블록을 명시적으로 추가하여 이 신호의 복사본을 만들고 문제를 해결하십시오.</entry>
    <entry key="LatchLoopError">Cannot latch all inputs of subsystem ''{0}'' over the duration of its execution. Since inport ''{1}'' directly reads the signal at the output of inport ''{2}'', it is not possible to latch both of these inputs independently before the execution of the subsystem. Consider inserting a Signal Conversion block before the outport block connected to the first inport to make an explicit copy of this signal.</entry>
    <entry key="LicenseError">Unable to check out the Simulink Coder license which is needed to generate code.</entry>
    <entry key="LineWithoutDst">''{0}''(출력 포트: {1,number,integer})에서 연결되지 않은 출력 라인이 발견됨</entry>
    <entry key="LineWithoutSrc">''{0}''(입력 포트: {1,number,integer})에서 연결되지 않은 입력 라인이 발견됨</entry>
    <entry key="LinearAnalysisForIterator">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 대한 선형 분석 특성을 Iterator 블록을 구동하도록 설정할 수 없음</entry>
    <entry key="LinearAnalysisNonDataPort">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 대한 선형 분석 특성을 데이터가 아닌 포트에 대해 설정할 수 없음</entry>
    <entry key="LinearAnalysisNotSupportedInMultiTasking">
        선형화는 멀티태스킹 모드에서 지원되지 않습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{0}'',''EnableMultiTasking'',''off'');&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="EnableMultiTasking"&gt;각 이산 레이트를 별개의 태스크로 처리&lt;/sldiag&gt;의 선택을 해제하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{0}'',''SolverType'',''Variable-step'');&lt;/cmd&gt; &lt;txt&gt;가변 스텝 솔버를 사용하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
        
    </entry>
    <entry key="LinearAnalysisTooManyElements">The model contains too many elements for linearization.  Please reduce the model size.</entry>
    <entry key="LinearAnalysisTooManyIOElements">Total size of input and output elements for linearization ({0} megabytes) must be less than 20% of the total available memory ({1} megabytes). To reduce the total size of the input and output elements, consider using fewer elements.</entry>
    <entry key="LinearizationWithSFuncDSMWrite">선형화는 Data Store Memory에 데이터를 쓰는 S-Function 블록에 대해 지원되지 않습니다. S-Function 블록 ''{0}'' 및 Data Store Memory ''{1}'' 사이의 연결은 선형 분석 동안 무시됩니다.</entry>
    <entry key="LinearizationWithSFuncDSMRead">선형화는 Data Store Memory에서 데이터를 읽는 S-Function 블록에 대해 지원되지 않습니다. S-Function 블록 ''{0}'' 및 Data Store Memory ''{1}'' 사이의 연결은 선형 분석 동안 무시됩니다.</entry>
    <entry key="InvalidPotentialLinearizationIO">The element {0,number,integer} in SCDPotentialLinearizationIOs structure is not referring to an existing block in the model.</entry>
    <entry key="InvalidLinearizationIOVariantSubsystem">Linearization IO points may not be placed at the top level of variant subsystems.</entry>
    <entry key="LinearlyImplicitActionSubsystemWithFixedStepImplicit">모델 ''{0}''은(는) ''{1}'' 솔버를 사용하고 ODE에 대한 선형 음함수 시스템을 지정하는 Action Subsystem을 포함하기 때문에 이 모델에 대한 코드를 생성할 수 없습니다. Action Subsystem에서 선형 음함수 방정식에 ''{1}''을(를) 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="LinearlyImplicitEnabledSubsystemWithFixedStepImplicit">모델 ''{0}''은(는) ''{1}'' 솔버를 사용하고 ODE에 대한 선형 음함수 시스템을 지정하는 Enabled Subsystem을 포함하기 때문에 이 모델에 대한 코드를 생성할 수 없습니다. Enabled Subsystem에서 선형 음함수 방정식에 ''{1}''을(를) 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="LinearlyImplicitSystemsUnsupportedTarget">모델 ''{0}''이(가) GRT, ERT, xPC 이외의 타깃 유형에 대해 ODE의 선형 음함수 시스템을 지정하기 때문에 이 모델에 대한 코드를 생성할 수 없습니다. GRT, ERT, xPC 타깃에 대해서만 ODE의 선형 음함수 시스템이 지원됩니다</entry>
    <entry key="LinearlyImplicitSystemsUnsupportedTargetOption">Unable to generate code for model ''{0}'' because ''C++ class'' as code interface packaging is not supported for model that specifies a linearly implicit system of ODEs. Set model configuration parameter &lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;Code interface packaging&lt;/sldiag&gt; to ''Nonreusable function'' or ''Reusable function''.</entry>
    <entry key="Listener_InvalidTid">''{0}''의 이벤트 리스너 TID는 0에서 {1,number,integer} 사이의 범위여야 함</entry>
    <entry key="MFileTsMustBeEmpty">Sample times (TS) matrix returned by MATLAB S-function ''{0}'' in ''{1}'' must be empty.</entry>
    <entry key="MSFcnAddDimsDependRuleCompStageMismatch">Simulink가 ''{0}''에서 Level-2 MATLAB S-Function에 대해 ''AddOutputDimsDependencyRule''의 사용이 올바르지 않음을 감지했습니다. 이 SimStruct 함수는 ''PostPropagationSetup'' 메서드에서만 사용할 수 있습니다.</entry>
    <entry key="MSFcnInvalidPassThroughInputIdx">Level-2 MATLAB S-Function 블록 ''{1}''에 대한 ''InputPortSameDimsAsOutputPort''에 지정된 입력 포트 인덱스 {0,number,integer}이(가) 존재하지 않습니다.</entry>
    <entry key="MSFcnInvalidPassThroughOutputIdx">Level-2 MATLAB S-Function 블록 ''{1}''에 대한 ''InputPortSameDimsAsOutputPort''에 지정된 출력 포트 인덱스 {0,number,integer}이(가) 존재하지 않습니다.</entry>
    <entry key="MSfcnMissingDefinedDimsDependRuleVarDims">''{1}''의 Level-2 MATLAB S-Function ''{0}''이(가) ''SignalSizesComputeType''을 ''FromInputSize''로 선언했습니다. 따라서 ''AddOutputDimsDependencyRules'' 메서드를 사용하여 &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{0}"&gt;{2,number,integer}번 출력 포트&lt;/sldiag&gt;의 차원 종속성 규칙을 등록해야 합니다.</entry>
    <entry key="MTCondExecDiagNotMatchModelAdvisor">샘플 시간 진단에서 ''멀티태스크 조건부 실행 서브시스템''의 진단이 ''{0}''입니다. 서브시스템 ''{1}''은(는) 복수의 태스크에서 실행됩니다. 이로 인해 실시간 시스템에서 데이터가 손상되거나 비결정적 동작이 발생할 수 있습니다. 모델 어드바이저는 실시간 시스템에 대한 코드를 생성할 때 이 진단에 대해 ''오류''를 권장합니다. 진단을 ''오류''로 변경해 보십시오.</entry>
    <entry key="MTCondExecSysHasAsync">조건부 실행 서브시스템 ''{0}''은(는) 비동기 서브시스템을 포함합니다. 이로 인해 실시간 시스템에서 데이터가 손상될 수 있습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;조건부 실행 서브시스템 외부로 비동기 서브시스템을 이동하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''MultiTaskCondExecSysMsg'',''none'')&lt;/cmd&gt; &lt;txt&gt;이 메시지를 표시하지 않으려면 &lt;sldiag objui="configset" objparam="MultiTaskCondExecSysMsg"&gt;멀티태스크 조건부 실행 서브시스템&lt;/sldiag&gt;을 ''안 함''으로 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="MTDSMDiagNotMatchModelAdvisor">구성 파라미터 대화 상자의 진단 페이지에 있는 ''멀티태스크 데이터 저장소'' 옵션이 ''{0}''입니다. 여러 다른 태스크에서 실행되는 Data Store Read 블록 및 Data Store Write 블록이 존재합니다. 이로 인해 실시간 시스템에서 데이터가 손상될 수 있습니다. 모델 어드바이저는 실시간 시스템에 대한 코드를 생성할 때 이 진단에 대해 ''오류''를 권장합니다. 진단을 ''오류''로 변경해 보십시오.</entry>
    <entry key="MaximumFwdTimesExceed">라이브러리 ''{0}''을(를) 불러오는 중에 재귀 제한이 초과되었습니다. 이 문제는 라이브러리 링크 전달 메커니즘이 무한 루프로 실행되기 때문에 발생할 수 있습니다.</entry>
    <entry key="MatrixTypeForDWorkLength">차원을 나타내는 인수 ''{0}''은(는) 스칼라여야 합니다.</entry>
    <entry key="MdlFileDeleted">블록 다이어그램을 불러왔지만 파일이 삭제됨</entry>
    <entry key="MdlFileLoaded">블록 다이어그램을 불러옴</entry>
    <entry key="MdlFileNotOnPath">블록 다이어그램 ''{0}''을(를) 포함하는 파일이 MATLAB 경로에 있지 않음: {1}</entry>
    <entry key="MdlFileShadowedByFile">The file containing block diagram ''{0}'' is shadowed by a file of the same name higher on the MATLAB path. This can cause unexpected behavior. For more information see &lt;a href="matlab:helpview([docroot ''/toolbox/simulink/helptargets.map''], ''shadowing'')"&gt;"Avoiding Problems with Shadowed Files"&lt;/a&gt; in the Simulink documentation.\n\nThe file containing the block diagram is: {1}.\nThe file higher on the MATLAB path is: {2}</entry>
    <entry key="MdlFileMissingAndShadowedByFile">블록 다이어그램 ''{0}''을(를) 포함하는 파일이 누락되었습니다. 이름이 동일한 다른 파일이 MATLAB 경로에 존재합니다. 이로 인해 예기치 않은 동작이 발생할 수 있습니다. 자세한 내용은 Simulink 도움말 문서에서 &lt;a href="matlab:helpview([docroot ''/toolbox/simulink/helptargets.map''], ''shadowing'')"&gt;"Avoiding Problems with Shadowed Files"&lt;/a&gt; 항목을 참조하십시오.\n\n누락된 파일은 {1}입니다.\nMATLAB 경로에 있는 파일은 {2}입니다</entry>
    <entry key="LoadShadowedFile">파일 ''{0}''은(는) MATLAB 경로에서 더 높은 수준에 있는 같은 이름의 다른 파일에 의해 가려져 있으므로 이 파일을 불러올 수 없습니다. 자세한 내용은 Simulink 도움말 문서에서 &lt;a href="matlab:helpview([docroot ''/toolbox/simulink/helptargets.map''], ''shadowing'')"&gt;"Avoiding Problems with Shadowed Files"&lt;/a&gt; 항목을 참조하십시오.\n\nMATLAB 경로에서 더 높은 수준에 있는 파일은 {1}입니다.</entry>
    <entry key="SlxFileShadowsMoreRecentMdlFile">파일 ''{0}.slx''가 동일한 폴더에서 더 최근에 저장된 MDL 파일 ''{1}.mdl''을 가립니다. 자세한 내용은 Simulink 도움말 문서에서 &lt;a href="matlab:helpview([docroot ''/toolbox/simulink/helptargets.map''], ''shadowing'')"&gt;"Avoiding Problems with Shadowed Files"&lt;/a&gt;를 참조하십시오.</entry>
    <entry key="MdlFileShadowedByVariable">블록 다이어그램 ''{0}''이(가) 동일한 이름의 변수에 의해 가려져 있습니다.</entry>
    <entry key="MdlFileShadowing">The model name ''{0}'' is shadowing another name in the MATLAB workspace or path. Type "which -all {1}" at the command line to find the other uses of this name. You should change the name of the model to avoid problems.</entry>
    <entry key="MdlRefExecTimeWithBlockRequestStateResetSizeVary">Block ''{0}'' contains states that require resetting whenever the input signal sizes vary. This block property is inconsistent with the ''Propagate sizes of variable-size signals'' setting ''During execution''.
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;configset.internal.fixIt(''{0}'',''PropagateVarSize'',''Only when enabling'')&lt;/cmd&gt;
            &lt;txt&gt;Change &lt;sldiag objui="configset" objparam="PropagateVarSize"&gt;Propagate sizes of variable-size signals&lt;/sldiag&gt; to ''Only when enabling''.&lt;/txt&gt;
        &lt;/action&gt;
        &lt;action type="suggestion"&gt;
            &lt;txt&gt;Place ''{1}'' inside an Enabled/Function-Call/Action/Resettable Subsystem and setting the parameter ''Propagate sizes of variable-size signals'' for the corresponding control port block to: ''Only when enabling'' for an Enabled or a Function-Call Subsystem; ''Only when execution is resumed'' for an Action Subsystem; or ''Only when resetting'' for a Resettable Subsystem.&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="MdlRefInitTimeWithblockSizeDependOnValue">블록 ''{0}''의 출력 신호 크기는 입력 신호 값에 종속됩니다. 그러나 &lt;sldiag objui="configset" objparam="PropagateVarSize"&gt;가변 크기 신호의 크기 전파&lt;/sldiag&gt;가 ''활성화할 때만''으로 설정되어 있습니다. 이 파라미터를 ''실행하는 동안''으로 변경해 보십시오.</entry>
    <entry key="MemoryAllocationError">메모리 할당 오류</entry>
    <entry key="MemorySectionsNotFound">Error loading memory section definitions.</entry>
    <entry key="MetadataMustBeStruct">The "Metadata" parameter of a block diagram must be a MATLAB structure</entry>
    <entry key="MissedNoncontSignal">서브시스템 블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;가 불연속이 있는 신호를 출력 중일 수 있으며, 연속 상태를 갖는 블록에 이 신호가 전달되고 있습니다. 이로 인해 솔버가 불연속 근처에서 부정확한 답을 생성할 수 있습니다.</entry>
    <entry key="MixedContextOnGenerator">"{0}'' 대상 포트가 서로 다른 실행 컨텍스트에 있음(예를 들어 한 포트는 루트 시스템에 있고 다른 한 포트는 조건부 실행 서브시스템에 있음)</entry>
    <entry key="MixedContextOnViewer">{0}'' is viewing signals that originate from different execution contexts (e.g. one signal in the root system and another signal in a conditionally executed subsystem)</entry>
    <entry key="ModelAlreadyCompiled">''{0}'' is already compiled</entry>
    <entry key="ModelCannotBeCompiledAgainWhileItIsBeingCompiled">Model is in the compile process and cannot be compiled again</entry>
    <entry key="CannotStartNewSimWhileSimOrCompileStarted">동일한 모델에 대해 다이어그램 업데이트 또는 시뮬레이션이 이미 시작된 경우에는 새 명령줄 시뮬레이션을 시작할 수 없음</entry>
    <entry key="ModelBlockNotConfiguredForMessagesMultiInstance">참조 모델 ''{0}''이(가) 메시지를 보내거나 받도록 설정되어 있지만 메시지 기반 통신에 대해 구성되어 있지 않습니다. 모델 구성 파라미터 ''최상위 모델당 허용되는 인스턴스의 총 개수''를 ''다중''으로 설정하십시오. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''ModelReferenceNumInstancesAllowed'',''Multi'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="ModelReferenceNumInstancesAllowed" objname="{0}"&gt;최상위 모델당 허용되는 인스턴스의 총 개수&lt;/sldiag&gt;를 ''다중''으로 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="ModelBlockNotConfiguredForFcnPortMultiInstance">참조 모델 ''{0}''이(가) 함수 포트를 사용하고 있는데 클라이언트/서버 통신에 대해 구성되지 않았습니다. 모델 구성 파라미터 ''최상위 모델당 허용되는 인스턴스의 총 개수''를 ''다중''으로 설정하십시오. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''ModelReferenceNumInstancesAllowed'',''Multi'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="ModelReferenceNumInstancesAllowed" objname="{0}"&gt;최상위 모델당 허용되는 인스턴스의 총 개수&lt;/sldiag&gt;를 ''다중''으로 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="ModelBlockCannotBeReusableForMultiInstanceCode">The referenced model ''{0}'' cannot generate reusable code. ''Total number of instances allowed per top model'' is set to ''One'' for the referenced model.
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;configset.internal.fixIt(''{0}'',''ModelReferenceNumInstancesAllowed'',''Multi'')&lt;/cmd&gt;
            &lt;txt&gt;Set &lt;sldiag objui="configset" objparam="ModelReferenceNumInstancesAllowed" objname="{0}"&gt;Total number of instances allowed per top model&lt;/sldiag&gt; to ''Multiple''.&lt;/txt&gt;
        &lt;/action&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;configset.internal.fixIt(''{1}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt;
            &lt;txt&gt;Set &lt;sldiag objui="configset" objparam="CodeInterfacePackaging" objname="{1}"&gt;Code interface packaging&lt;/sldiag&gt; to ''Nonreusable function'' for the top model ''{1}'' (might impact referenced or referencing models)&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="FunctionPortsRequireCpp">모델 ''{0}''은(는) 함수 서비스 포트를 포함하지만 C++ 클래스 코드를 생성하도록 구성되지 않았습니다. 모델 구성 파라미터 코드 인터페이스 패키징(''CodeInterfacePackaging'')을 ''C++ 클래스''로 설정하십시오. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''C++ class'')&lt;/cmd&gt; &lt;txt&gt;모델 ''{0}''에 대해 &lt;sldiag objui="configset" objparam="CodeInterfacePackaging" objname="{0}"&gt;코드 인터페이스 패키징&lt;/sldiag&gt;을 ''C++ 클래스''로 설정(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="MessagesDependsOnCppClassCode">참조 모델 ''{0}''이(가) 메시지를 보내거나 받도록 설정되어 있지만 메시지 기반 통신에 대해 구성되어 있지 않습니다. 모델 구성 파라미터 코드 인터페이스 패키징(''CodeInterfacePackaging'')을 ''C++ 클래스''로 설정하십시오. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''C++ class'')&lt;/cmd&gt; &lt;txt&gt;모델 ''{0}''에 대해 &lt;sldiag objui="configset" objparam="CodeInterfacePackaging" objname="{0}"&gt;코드 인터페이스 패키징&lt;/sldiag&gt;을 ''C++ 클래스''로 설정(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="GenerateAllocFcnDependsOnMultiInstanceCode">Cannot set model option GenerateAllocFcn when model option ''CodeInterfacePackaging'' is set to ''Nonreusable function''</entry>
    <entry key="ModelCompInProgress">''{0}'' 컴파일이 진행 중임</entry>
    <entry key="ModelDoesNotExist">
      ''{0}''이(가) MATLAB에 Simulink 모델을 식별하는 것으로 등록되어 있지 않으므로, 이를 컴파일할 수 없습니다. 동일한 이름을 갖는 MATLAB 클래스가 있을 수 있습니다. 이 경우 모델이나 클래스의 이름을 바꾸십시오
    </entry>
    <entry key="ModelNameTooLong">''{0}''은(는) 너무 길기 때문에 유효한 모델 이름이 아님</entry>
    <entry key="ModelTermInProgress">Termination of ''{0}'' is in progress</entry>
    <entry key="ModuleLibraryLoadError">다음 오류로 인해 ''{0}''을(를) 불러올 수 없습니다.\n''{1}''\n</entry>
    <entry key="MultSampleTime">''{0}''에 대해 샘플 시간을 하나만 지정할 수 있음</entry>
    <entry key="MultSysGenSameFcn">서브시스템 ''{0}'' 및 ''{1}''이(가) 동일한 함수 이름 ''{2}''을(를) 가집니다. 시스템이 서로의 동일한 복사본이 아닌 한 이는 적절하지 않습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;Simulink.internal.OpenBlockParamsDialog(''{0}'',''RTWFcnName'')&lt;/cmd&gt; &lt;txt&gt;''{0}''의 함수 이름을 수정하십시오&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;Simulink.internal.OpenBlockParamsDialog(''{1}'',''RTWFcnName'')&lt;/cmd&gt; &lt;txt&gt;''{1}''의 함수 이름을 수정하십시오&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''MaxIdLength'')&lt;/cmd&gt; &lt;txt&gt;''최대 식별자 길이''를 늘리십시오(참조된 모델이나 참조 모델에 영향을 줄 수 있음)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="RowMajorReusableFcnUnsupported">The ForEach subsystem ''{0}'' with function name ''{1}''is marked as reusable. This is currently not supported for row-major code generation.</entry>
    <entry key="MultiFcnCallInlined">Function-Call Subsystem ''{0}''에 여러 개의 호출자가 있기 때문에 코드 생성 함수 패키징 설정을 ''인라인''에서 ''함수''로 변경합니다</entry>
    <entry key="FcnCallSysWithMulTidsCalledFromSFSfcn">Function-Call Subsystem ''{0}''을(를) 자신의 부모에서 인라인 처리할 수 없기 때문에 코드 생성 함수 패키징 설정을 ''인라인''에서 ''함수''로 변경합니다</entry>
    <entry key="NonSLDomainFcnForceInline">''{0}''의 ''함수 패키징'' 설정을 ''{1}''에서 ''인라인''으로 변환하는 중입니다. 블록이 이벤트 기반 신호 입력을 가지고 있거나, 블록이 이벤트 기반 신호 입력을 갖는 Atomic Subsystem 또는 Function-Call Subsystem에 포함되어 있습니다.</entry>
    <entry key="ReusableTopModelWithInternalDefaultMapping">The model cannot generate reusable code with inputs and outputs passed as individual arguments. This is because the 'Internal Data' of the model is mapped to ''{0}'' which is a single-instance storage class that forces the system ''{1}'' to be generated as a non-reusable function.
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;configset.internal.fixIt(''{0}'',''RootIOFormat'',''Structure reference'')&lt;/cmd&gt;
            &lt;txt&gt;Set &lt;sldiag objui="configset" objparam="RootIOFormat"&gt;Pass root-level I/O as&lt;/sldiag&gt; to ''Structure reference''&lt;/txt&gt;
        &lt;/action&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt;
            &lt;txt&gt;Set &lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;Code interface packaging&lt;/sldiag&gt; to ''Nonreusable function'' (might impact referenced or referencing models)&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="MultiInstanceForcedNonInline">''{0}''은(는) 인라인이 아니어야 하므로 모델이 개별 인수로 전달되는 입력 및 출력을 갖는 재사용 가능한 코드를 생성할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''RootIOFormat'',''Structure reference'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="RootIOFormat"&gt;루트 레벨 I/O 전달 유형&lt;/sldiag&gt;을 ''구조체 참조''로 설정&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;코드 인터페이스 패키징&lt;/sldiag&gt;을 ''재사용 불가 함수''로 설정(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="MultiInstanceForcedNonInlineCPP">''{0}''은(는) 인라인이 아니어야 하므로 모델이 C++ 클래스 인터페이스를 생성할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''CodeInterfacePackaging'')&lt;/cmd&gt; &lt;txt&gt;''코드 인터페이스 패키징''을 ''C++ 클래스''가 아닌 값으로 설정(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="MultiInstanceNonReusableAsyncSFcn">''{0}''이(가) 코드 재사용을 지원하지 않는 비동기 S-Function이므로 모델이 재사용 가능한 코드를 생성할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;코드 인터페이스 패키징&lt;/sldiag&gt;을 ''재사용 불가 함수''로 설정(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="MultiInstanceNonReusableAsyncSFcn2">''{0}''이(가) 인라인이 아닌 비동기 S-Function이므로 모델이 재사용 가능한 코드를 생성할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;코드 인터페이스 패키징&lt;/sldiag&gt;을 ''재사용 불가 함수''로 설정(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="MultiInstanceNonReusableSFcn">''{0}''이(가) 코드 재사용을 지원하지 않으므로 모델이 개별 인수로 전달되는 입력 및 출력을 갖는 재사용 가능한 코드를 생성할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''RootIOFormat'',''Structure reference'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="RootIOFormat"&gt;루트 레벨 I/O 전달 유형&lt;/sldiag&gt;을 ''구조체 참조''로 설정&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;코드 인터페이스 패키징&lt;/sldiag&gt;을 ''재사용 불가 함수''로 설정(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="MultiInstanceNonReusableSFcn2">''{0}''이(가) 인라인이 아니므로 모델이 개별 인수로 전달되는 입력 및 출력을 갖는 재사용 가능한 코드를 생성할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''RootIOFormat'',''Structure reference'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="RootIOFormat"&gt;루트 레벨 I/O 전달 유형&lt;/sldiag&gt;을 ''구조체 참조''로 설정&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;코드 인터페이스 패키징&lt;/sldiag&gt;을 ''재사용 불가 함수''로 설정(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="MultiInstanceNonReusableSFcn2GRT">''{0}''이(가) 인라인이 아니므로 모델이 재사용 가능한 코드를 생성할 수 없습니다. ''grt_malloc.tlc'' 타깃 대신 ''grt.tlc'' 타깃을 사용해 보십시오.</entry>
    <entry key="MultiInstanceNonReusableSFcnCPP">The model cannot generate ''I/O arguments step method'' style C++ class interface because ''{0}'' does not support code reuse with I/O arguments.  Consider using the ''Void-void step method'' style C++ class interface using the ''Configure C++ Class Interface'' button from the Configuration Parameters &gt; Code Generation &gt; Interface pane.</entry>
    <entry key="MultiInstanceNonReusableSFcnGRT">''{0}''이(가) 코드 재사용을 지원하지 않으므로 모델이 재사용 가능한 코드를 생성할 수 없습니다. ''grt_malloc.tlc'' 타깃 대신 ''grt.tlc'' 타깃을 사용해 보십시오.</entry>
    <entry key="MultiInstanceSfcnNotInline">''{0}''이(가) 인라인이 아니므로 모델이 개별 인수로 전달되는 입력 및 출력을 갖는 재사용 가능한 코드를 생성할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''RootIOFormat'',''Structure reference'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="RootIOFormat"&gt;루트 레벨 I/O 전달 유형&lt;/sldiag&gt;을 ''구조체 참조''로 설정&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;코드 인터페이스 패키징&lt;/sldiag&gt;을 ''재사용 불가 함수''로 설정(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="MultiInstanceSfcnNotInlineCPP">''{0}''이(가) 인라인이 아니므로 모델이 C++ 클래스 인터페이스를 생성할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''CodeInterfacePackaging'')&lt;/cmd&gt; &lt;txt&gt;''코드 인터페이스 패키징''을 ''C++ 클래스''가 아닌 값으로 설정(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="MultiInstanceWideFcnCallTrig">The model cannot generate reusable code with inputs and outputs passed as individual arguments, because ''{0}'' is triggered by a wide function-call trigger.
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;configset.internal.fixIt(''{0}'',''RootIOFormat'',''Structure reference'')&lt;/cmd&gt;
            &lt;txt&gt;Set &lt;sldiag objui="configset" objparam="RootIOFormat"&gt;Pass root-level I/O as&lt;/sldiag&gt; to ''Structure reference''&lt;/txt&gt;
        &lt;/action&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt;
            &lt;txt&gt;Set &lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;Code interface packaging&lt;/sldiag&gt; to ''Nonreusable function'' (might impact referenced or referencing models)&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="MultiInstanceDefaultSharedLocalDSMMapping">''{0}''이(가) 재사용 가능한 서브시스템이고 공유된 로컬 데이터 저장소의 디폴트 스토리지 클래스가 Embedded Coder 사전에 정의되어 있지 않으므로 모델이 개별 인수로 전달되는 입력 및 출력을 갖는 재사용 가능한 코드를 생성할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''RootIOFormat'',''Structure reference'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="RootIOFormat"&gt;루트 레벨 I/O 전달 유형&lt;/sldiag&gt;을 ''구조체 참조''로 설정&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''CodeInterfacePackaging'',''Nonreusable function'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;코드 인터페이스 패키징&lt;/sldiag&gt;을 ''재사용 불가 함수''로 설정(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="MultiInstanceWideFcnCallTrigCPP">''{0}''이(가) 넓은 함수 호출 트리거로 트리거되기 때문에 모델이 C++ 클래스 인터페이스를 생성할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''CodeInterfacePackaging'')&lt;/cmd&gt; &lt;txt&gt;'' &lt;/actions&gt;코드 인터페이스 패키징''을 ''C++ 클래스''가 아닌 값으로 설정(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음)&lt;/txt&gt; &lt;/action&gt;
    </entry>
    <entry key="AutosarCSCMdlRefParam">서브모델 ''{0}''이(가) ''AUTOSAR.Parameter'' 객체 ''{1}''을(를) 참조할 수 없습니다. 이 객체의 사용자 지정 스토리지 클래스 ''{2}''이(가) 모델 계층 구조의 최상위 모델에 대해서만 지원되기 때문입니다. 파라미터를 서브모델에 모델 인수로 전달해 보십시오.</entry>
    <entry key="AutosarCSCMdlRefSig">Submodel ''{0}'' cannot reference ''AUTOSAR.Signal'' object ''{1}'' because
    the object's custom storage class ''{2}'' is supported only for the top model in a model hierarchy. </entry>
    <entry key="AutosarPIMCSCTopModel">모델 ''{0}''이(가) ''AUTOSAR.Signal'' 객체 ''{1}''을(를) 참조할 수 없습니다. 이 모델이 AUTOSAR 타깃을 사용하지 않기 때문입니다. </entry>
    <entry key="MultiplePriorityViolations">Detected {0,number,integer} priority violations in system ''{1}''. Note that these priority violations are not independent, i.e., changing the priorities on a subset of the blocks reported in the diagnostics above may address all the priority violations</entry>
    <entry key="MultirateEnable">Enabled Subsystem ''{0}''이(가) 복수의 태스크에서 실행됩니다. 이로 인해 실시간 시스템에서 데이터가 손상되거나 비결정적 동작이 발생할 수 있습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;싱글레이트 Enabled Subsystem을 사용하십시오&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''EnableMultiTasking'',''off'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="EnableMultiTasking"&gt;각 이산 레이트를 별개의 태스크로 처리&lt;/sldiag&gt;를 선택 해제하십시오&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''MultiTaskCondExecSysMsg'',''none'')&lt;/cmd&gt; &lt;txt&gt;이 메시지를 표시하지 않으려면 &lt;sldiag objui="configset" objparam="MultiTaskCondExecSysMsg"&gt;멀티태스크 조건부 실행 서브시스템&lt;/sldiag&gt;을 ''안 함''으로 설정하십시오&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="MultirateEnable_MC">Enabled Subsystem ''{0}''이(가) 복수의 동시 태스크에서 실행됩니다. 이로 인해 실시간 시스템에서 데이터가 손상되거나 비결정적 동작이 발생할 수 있습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;싱글레이트 Enabled Subsystem을 사용하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="MultirateRootEnable">This model has a root level Enable port ''{0}'' and executes in multiple tasks. This can cause corrupted data or non-deterministic behavior in a real-time system. Consider modifying your model to be single-rate or clear the 'Treat each discrete rate as a separate task' option in the Solver pane of the Configuration Parameters dialog box.</entry>
    <entry key="MultipleAutoInsertedBlocksAtPort">블록 ''{3}''의 {1} {2,number,integer}번 포트에 ''{0}'' 블록을 영구히 삽입/배치할 수 없습니다. 해당 포트에 이와 같이 자동 삽입된 블록이 여러 개 있기 때문입니다.</entry>
    <entry key="NoAutoInsertedBlocksAtPort">블록 ''{3}''의 {1} {2,number,integer}번 포트에 ''{0}'' 블록을 영구히 삽입/배치할 수 없습니다. 해당 포트에 이와 같이 자동 삽입된 블록이 없기 때문입니다.</entry>
    <entry key="NamedItemRename">이름이 이미 지정된 항목의 이름을 바꾸려 하고 있습니다.</entry>
    <entry key="NeverGotDisconnectResponse">타깃에서 연결 끊기 응답을 받지 못했습니다. 연결을 끊는 중...</entry>
    <entry key="NeverGotFinalLogBufferTerminator">타깃에서 최종 데이터 기록 버퍼와 기록 종단을 받지 못했습니다. 연결을 끊는 중...</entry>
    <entry key="NoActionSSInLoops">Action Subsystem으로 인해 입력 데이터 종속성 위반이 발생했습니다. Simulink 라이브러리에서 서브시스템 예를 참조하여 Action Subsystem의 유효한 예와 유효하지 않은 예를 확인하십시오</entry>
    <entry key="NoAutoUpdateStatusClock">모델 상태 표시줄과 블록 다이어그램 파라미터 ''SimulationTime''의 타깃 시간을 업데이트할 수 없습니다. 타깃 시간 업데이트를 활성화하려면 set_param(''{0}'',''ExtModeAutoUpdateStatusClock'',''on'')을 실행하십시오.</entry>
    <entry key="NoBlocksInModel">블록 다이어그램 ''{0}''에 블록이 포함되어 있지 않거나 모든 블록이 가상임</entry>
    <entry key="NoBehaviorsForArchitectureModel">아키텍처 모델 ''{0}''에 컴포넌트가 포함되어 있지 않거나 모든 컴포넌트가 가상입니다. 컴포넌트나 루트 입력 또는 출력에 동작을 추가하면 이 문제가 해결될 수 있습니다.</entry>
    <entry key="NoChangeWhileLogging">Cannot change data logging options while data logging is in progress</entry>
    <entry key="NoChangeWhileRunningInExtMode">외부 모드에서 시뮬레이션이 실행 중일 때는 ''{2}''의 파라미터 ''{0}({1})''을(를) 변경할 수 없음</entry>
    <entry key="NoChangeToDurationWhileConnectedInPackedMode">파라미터 ''ExtModeTrigDuration''을 변경할 수 없습니다. 모델이 타깃 애플리케이션과 연결되어 있으며 ''ExtModeSendContiguousSamples''가 ''on''입니다.</entry>
    <entry key="NoChecksumDetails">''{1}''에 대해 사용할 수 있는 ''{0}'' 세부 정보가 없음</entry>
    <entry key="NoChecksumDetailsCallGetCS">''{1}''에 대해 사용할 수 있는 ''{0}'' 세부 정보가 없습니다. 모델을 종료하고 컴파일되지 않은 상태의 모델을 사용하여 Simulink.{2}.getChecksum(''{3}'')을 호출해 보십시오.</entry>
    <entry key="NoDataTypeOverrideForPurelyIntegerCode">Cannot generate code for this model because support for floating-point numbers is disabled and the model is using double or single data types. This may be due to the 'data type override' setting on the model.
    &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;set_param(get_param(0,'CurrentSystem'), 'PurelyIntegerCode','off')&lt;/cmd&gt;
            &lt;txt&gt;To generate code, enable support for floating-point numbers.&lt;/txt&gt;
        &lt;/action&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;fxptui.setDTOValueOnModel(gcs,'Off')&lt;/cmd&gt;
            &lt;txt&gt;Remove data type override from the model.&lt;/txt&gt;
        &lt;/action&gt;
    &lt;/actions&gt;
    </entry>
    <entry key="NoDataUploadBlocks">No data has been selected for uploading.</entry>
    <entry key="NoDirectConnWhenDrivingIter">Invalid connection from Inport block ''{0}'' to the iterator block ''{1}''.  An Inport connected to an iterator cannot be directly connected to an Outport.  Consider inserting a Signal Conversion block on the signal line directly connecting the Inport block to the Outport block.</entry>
    <entry key="NoExtCmdsIfNotRunning">외부 모드에 있거나 타깃에 연결된 경우에만 외부 모드 명령을 실행할 수 있음</entry>
    <entry key="NoFcnCallOrActionSSInLoops">Function-Call Subsystem 또는 Action Subsystem으로 인해 입력 데이터 종속성 위반이 발생했습니다. 추가적인 정보는 &lt;a href=\"matlab:openExample('simulink_features/SimulinkSubsystemSemanticsExample'); open_system('sl_subsys_semantics/ Function-call subsystems');\"&gt;''sl_subsys_semantics''&lt;/a&gt;에서 Function-Call Subsystem의 유효한 예와 유효하지 않은 예를 참조하십시오.</entry>
    <entry key="NoHiliteForInvalidConn">일부 최적화로 인해 Simulink가 ''{0}''을(를) 포함하는 루프의 섹션을 강조 표시하지 못할 수 있습니다.</entry>
    <entry key="NoSimBlockDiagram">모델 ''{0}''은(는) ''{1}'' 블록 다이어그램이므로 이 모델의 시뮬레이션은 허용되지 않습니다.</entry>
    <entry key="NoDefaultBDSim">디폴트 블록 다이어그램의 시뮬레이션은 허용되지 않습니다.</entry>
    <entry key="NoMemSecPackageForSystem">Invalid memory section ''{0}'' specified in the Subsystem Parameters dialog of block ''{1}''. No memory section package selected in the Configuration Parameters dialog.</entry>
    <entry key="NoMemSecPackageForSystemDefaults">블록 다이어그램 ''{1}''의 구성 파라미터 대화 상자에 지정된 메모리 섹션 ''{0}''이(가) 유효하지 않습니다. 메모리 섹션 패키지가 선택되지 않았습니다.</entry>
    <entry key="NoModelForRTWNameOpen">Simulink Coder 블록 또는 시스템 이름에 open_system을 사용하려면 모델이 열려 있어야 합니다.</entry>
    <entry key="RTWNameIsEmpty">블록 ''{0}''에 비어 있는 코드 생성 이름이 있습니다.</entry>
    <entry key="RTWIdIsVoid">블록 ''{0}''에 코드 생성 식별자가 없습니다.</entry>
    <entry key="NoNonVirtualBlocksInModel">블록 다이어그램 ''{0}''의 모든 블록은 가상이거나 블록 축소 최적화에 의해 제거되었거나 비활성 Variant이므로 시뮬레이션할 항목이 없습니다. 참고로, 코드 생성 시 블록 축소 최적화는 코드 생성에 참여하지 않는 싱크 블록에서 종료되는 모든 다이어그램 분기를 제거합니다. 예를 들어, &lt;sldiag objui="configset" objparam="MatFileLogging"&gt;MAT 파일 기록&lt;/sldiag&gt;이 꺼져 있으면 To Workspace 블록 및 해당 소스가 제거됩니다.</entry>
    <entry key="NoNonvirtSubsysSelfLoops">비가상 서브시스템 ''{0}''과(와) 관련된 직접 피드백 연결은 허용되지 않습니다.</entry>
    <entry key="NoMultiTaskModelSelfLoops">In a multi-tasking model, direct feedback connections involving Model block ''{0}'' that have different rates are not allowed.
    &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="fixit"&gt;
        &lt;cmd&gt;set_param_action(''{1}'', ''EnableMultiTasking'', ''off'');&lt;/cmd&gt;
        &lt;txt&gt;Consider unselecting configuration option &lt;sldiag objui="configset" objparam="EnableMultiTasking"&gt;''Treat each discrete rate as a separate task''&lt;/sldiag&gt; to change the model to single tasking mode.&lt;/txt&gt;
        &lt;/action&gt;
    &lt;/actions&gt;
    </entry>
    <entry key="NoConstRateIOSelfLoop">한 포트에는 상수 샘플 시간이 있지만 다른 포트에는 없는 경우 블록 ''{0}''의 {1,number,integer}번 출력 포트 및 &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{0}"&gt;{2,number,integer}번 입력 포트&lt;/sldiag&gt; 사이의 직접 피드백 연결이 허용되지 않습니다.
    </entry>
    <entry key="NoOutputTimesWithFixedStep">"''OutputTimes'' are not supported by fixed step solvers (''{0}'').  The first and last elements of TIMESPAN are being used as the start and stop times.  All other elements are being ignored.  Type ''help sim'' for more information.</entry>
    <entry key="NoRTWCustomCode">The block ''{0}'' is a Simulink Coder Custom Code block; this type of block is not allowed for the {1}.</entry>
    <entry key="NoRefineWithFixedStep">''세분화''는 고정 스텝 솔버(''{0}'')에서 지원되지 않습니다. 지정된 세분화 인자 ''{1,number,integer}''이(가) 무시됩니다. 자세한 내용을 알아보려면 ''help sim''을 입력하십시오.</entry>
    <entry key="NoRefineWithPureDiscrete">&lt;sldiag objui="configset" objparam="Refine"&gt;세분화 인자&lt;/sldiag&gt; 구성 파라미터에 대해 지정된 값을 무시합니다. 이는 모델 ''{0}''이(가) 순수 이산 모델이기 때문입니다. 자세한 내용은 도움말 문서에서 ''Refine factor''(세분화 인자) 옵션을 참조하십시오.</entry>
    <entry key="NoSListForSystem">시스템 ''{0}''에 대한 정렬된 목록을 확인할 수 없습니다.</entry>
    <entry key="NoTrigSSInLoops">루프 내 Triggered Subsystem 또는 Model 블록 사용으로 인해 모호하게 정렬된 순서가 감지되었습니다. Simulink 라이브러리에서 서브시스템 예를 참조하여 Triggered Subsystem의 유효한 예와 유효하지 않은 예를 확인하십시오.</entry>
    <entry key="NoTsInhDueToPreSetDWorkSigObj">This model will not inherit a sample time because a sample time was explicitly set for the signal object ''{0}'' associated with DWork {1,number,integer} in block ''{2}''. \n \n If this model does not need to inherit a sample time, change the "Sample time constraint" to something other than "Ensure sample time independent" on the Solver tab of the Configuration Parameters dialog.</entry>
    <entry key="NoTsInhDueToPreSetOutputSigObj">샘플 시간이 블록 ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 signal 객체 ''{0}''에 대해 명시적으로 설정되었으므로 이 모델이 샘플 시간을 상속하지 않습니다.\n \n 이 모델이 샘플 시간을 상속할 필요가 없으면 구성 파라미터 대화 상자의 솔버 탭에서 "샘플 시간 제약 조건"을 "샘플 시간을 독립적으로 함"이 아닌 다른 옵션으로 변경하십시오.</entry>
    <entry key="MultipleRunTimeTasks">블록 ''{0}''에 복수의 런타임 레이트가 있습니다.</entry>
    <entry key="NonGraphicalDependencyCrossesFunctionSubsystem">블록 중 하나가 Function-Call Subsystem 내에 있기 때문에 블록 ''{1}'' 전에 블록 ''{0}''이(가) 실행되도록 할 수 없습니다.</entry>
    <entry key="NonGraphicalDependencyDifferentModels">블록이 서로 다른 모델에 있기 때문에 블록 ''{1}'' 전에 블록 ''{0}''이(가) 실행되도록 할 수 없습니다.</entry>
    <entry key="NonGraphicalDependencyLoop">종속성 루프가 발생하는 원인이 되므로 블록 ''{1}'' 전에 블록 ''{0}''이(가) 실행되도록 할 수 없습니다.</entry>
    <entry key="NonGraphicalDependencyMergeBlock">블록 중 하나가 Merge 블록이기 때문에 블록 ''{1}'' 전에 블록 ''{0}''이(가) 실행되도록 할 수 없습니다.</entry>
    <entry key="NonInhTsGlbDSMInhTsMod">Within the model ''{0}'', one or more blocks access the global data store ''{1}'', whose corresponding Simulink.Signal object has sample time {2}. However, that model specifies that it is sample time independent. The sample time of the object must be inherited (-1).</entry>
    <entry key="NonInlinedSFcnsNotSupported">블록 ''{0}''은(는) 인라인이 아닌 S-Function인데, 이는 현재 구성에서 지원되지 않습니다. &lt;sldiag objui="configset" objparam="SupportNonInlinedSFcns"&gt;인라인이 아닌 S-Function 지원&lt;/sldiag&gt;을 선택하십시오.</entry>
    <entry key="NonInlinedSFcnsNotSupportedForRowMajor">Block ''{0}'' is a non-inlined S-function which is not supported for the row-major code generation.</entry>
    <entry key="NonSourceBeingUsedAsSource">뷰어 및 생성기 관리자는 소스가 아닌 항목에 사용할 수 없습니다. ''{0}''은(는) 입력을 갖도록 구성되어 있으므로 소스가 아닙니다.</entry>
    <entry key="NoninlinedSfcnNotReused">S-Function ''{0}''에 옵션 SS_OPTION_WORKS_WITH_CODE_REUSE가 설정되어 있지만 ''{1}.tlc'' 파일이 없습니다. 이 함수가 있는 시스템은 재사용되지 않습니다.</entry>
    <entry key="RowMajorSfcnNotReusedInAcceleratedModes"> S-Function ''{0}''은(는) SS_ROW_MAJOR 옵션을 설정하므로 ''{0}''을(를) 포함하는 서브시스템은 액셀러레이터 및 고속 액셀러레이터 모드에서 코드 재사용에 참여할 수 없습니다.</entry>
    <entry key="NotEnoughMemoryOnTarget">타깃에 메모리가 부족하여 패킷을 처리할 수 없음: {0}</entry>
    <entry key="NotImplemented">내부 오류</entry>
    <entry key="NotMatchWithModelAdvisor">모델 어드바이저에서 권장하지 않는 설정입니다.</entry>
    <entry key="NotSupportSubsysFileInCPF">[구성 파라미터] 대화 상자의 [코드 생성] &gt; [코드 배치] 창에 있는 "파일 패키징 형식" 파라미터의 "콤팩트" 옵션이 서브시스템에 대한 별도의 소스 파일을 생성하지 않습니다. [서브시스템 파라미터] 대화 상자에서 서브시스템 ''{0}''에 대해 "코드 생성 파일 이름 옵션" 파라미터를 "자동"으로 지정하십시오. 또 다른 해결 방법으로, [구성 파라미터] 대화 상자의 [코드 생성] &gt; [코드 배치] 창에서 "파일 패키징 형식" 파라미터를 "모듈식"으로 지정할 수도 있습니다.</entry>
    <entry key="NotSupportedVarSizePropTypeAmbiguous">
    ''Propagate sizes of variable-size signals''
    of the model ''{0}'' is set to ''Infer from blocks
    in model''. The model contains a conditionally executed subsystem or a
    resettable subsystem ''{1}'' which has variable-size signals in the Model
    Reference target. However, Simulink did not detect any block in the model
    for which either of the following properties hold: 1) the block output
    signal sizes depend on the input signal values; 2) the block states require
    resetting if the input signal sizes vary and if the block is not inside an
    Enabled/Function-Call/Action/Resettable Subsystem. Consequently, Simulink
    cannot determine if the model should support the propagation of
    variable-size signals ''During execution'' or ''Only when enabling''.
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="suggestion"&gt;
            &lt;cmd&gt;configset.internal.open(''{0}'',''PropagateVarSize'')&lt;/cmd&gt;
            &lt;txt&gt;Change ''Propagate sizes of variable-size signals'' to ''During execution'' or ''Only when enabling''&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="NotSupportedVarSizePropTypeAmbiguousRootControlPort">
    ''Propagate sizes of variable-size signals''
    of the model ''{0}'' is set to ''Infer from
    blocks in model''. The model contains a control port at the root ''{1}'' and
    has variable-size signals in the Model Reference target. However, Simulink
    did not detect any block in the model for which either of the following
    properties hold: 1) the block output signal sizes depend on the input signal
    values; 2) the block states require resetting if the input signal sizes vary
    and if the block is not inside an Enabled/Function-Call/Action/Resettable
    Subsystem. Consequently, Simulink cannot determine if the model should
    support the propagation of variable-size signals ''During execution'' or
    ''Only when enabling''.
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="suggestion"&gt;
            &lt;cmd&gt;configset.internal.open(''{0}'',''PropagateVarSize'')&lt;/cmd&gt;
            &lt;txt&gt;Change ''Propagate sizes of variable-size signals'' to ''During execution'' or ''Only when enabling''&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="Not_FxpPoint">''{1}''의 ''{0}'' 메서드는 정수 및 고정소수점 데이터형에 대해서만 호출할 수 있음</entry>
    <entry key="NumDimsMismatchFromETVSSubsysIC">차원 수 불일치가 감지됨: ''{0}''의 초기 출력이 출력 차원 수가 {1,number,integer}임을 지정합니다. 하지만 입력 신호는 {2,number,integer}차원입니다.</entry>
    <entry key="NumDimsNotMatchMatlab">지정된 MATLAB 배열의 차원 수가 Simulink 내부 데이터의 차원 수와 일치하지 않음</entry>
    <entry key="Num_Var_Dims_Mismatch">Invalid variable dimensions assignment for &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}''. The number of variable dimensions is {2,number,integer}. However, the length of the MATLAB array is {3,number,integer}</entry>
    <entry key="OVERRIDE_IR_SUPPORT_FLAG">더미 메시지</entry>
    <entry key="ObsoleteExprDepthLimit">모델 파라미터 ''RTWExpressionDepthLimit''는 더 이상 사용되지 않습니다. ''ExpressionFolding'' 파라미터를 대신 사용하십시오.</entry>
    <entry key="ObsoleteSimPrmPage">모델 파라미터 ''SimParamPage''는 더 이상 사용되지 않습니다. 구성 파라미터 대화 상자를 사용하여 작업하려면 ''slCfgPrmDlg'' 명령을 사용하십시오.</entry>
    <entry key="OldStyleStateLabel">초기 상태 구조체에서 ''{0}''에 대한 상태 레이블은 {1}에서 {2}(으)로 업데이트되어야 함</entry>
    <entry key="OnlyTermWhenCompForChecksums">The model ''{0}'' has been compiled for checksums only. Termination is the only permissible model command for a model in this state</entry>
    <entry key="OuterOutportPassThruFcnCallInArgMustInheritIC">블록 ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에서 발생하는 신호에서 함수 호출 데이터 종속성 위반이 발생하지 않도록 하려면 Outport 블록 ''{0}''의 파라미터 ''초기 출력''을 []로 설정해야 합니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{0}'',''InitialOutput'',''[]'');&lt;/cmd&gt; &lt;txt&gt;''{0}''에 대해 ''초기 출력''을 ''[]''로 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="OutportBufferRequiredConstTS">Outport 블록이 상수 샘플 시간을 갖는 블록 ''{1}''의 {2,number,integer}번 출력 포트에 의해 구동되므로, 올바른 초기화를 보장하려면 Outport 블록 ''{0}''에 연결된 신호가 신호 복사여야 합니다. Signal Conversion 블록을 삽입하거나 모델을 수정하십시오.</entry>
    <entry key="OutportBufferRequiredExpFcnRootOutport">서브시스템 ''{1}''의 {2,number,integer}번 출력 포트가 함수 내보내기 모델에서 루트 Outport 블록을 구동하므로, Outport 블록 ''{0}''에 연결된 신호는 신호 복사여야 합니다. Signal Conversion 블록을 삽입하거나 모델을 수정하십시오.</entry>
    <entry key="OutportBufferRequiredMergeNesting">서브시스템 ''{1}''의 {2,number,integer}번 출력 포트가 Merge 블록에 연결되어 있고 Outport 블록이 중첩된 조건부 실행 서브시스템 ''{3}''의 {4,number,integer}번 출력 포트에 의해 구동되므로, Outport 블록 ''{0}''에 연결된 신호는 신호 복사여야 합니다. 결과가 병합되기 전에, 신호 복사는 중첩된 조건부 서브시스템에서 마지막으로 계산된 출력을 유지합니다. Signal Conversion 블록을 삽입하거나 모델을 수정하십시오.</entry>
    <entry key="OutportBufferRequiredMergeBranching">서브시스템 ''{1}''의 {2,number,integer}번 출력 포트가 Merge 블록에 연결되어 있으므로, Outport 블록 ''{0}''에 연결된 신호는 신호 복사여야 합니다. 소스 블록 ''{3}''의 {4,number,integer}번 출력 포트는 여러 대상으로 분기되므로, 직접 병합할 수 없습니다. Signal Conversion 블록을 삽입하거나 모델을 수정하십시오.</entry>
    <entry key="OutportBufferRequiredMergeNotReusable">서브시스템 ''{1}''의 {2,number,integer}번 출력 포트가 Merge 블록에 연결되어 있으므로, Outport 블록 ''{0}''에 연결된 신호는 신호 복사여야 합니다. 소스 블록 ''{3}''의 {4,number,integer}번 출력 포트에 대한 신호 버퍼는 재사용 불가로 표시되어 있으므로, 직접 병합할 수 없습니다. Signal Conversion 블록을 삽입하거나 모델을 수정하십시오.</entry>
    <entry key="OutportBufferRequiredMergeModelBlock">서브시스템 ''{1}''의 {2,number,integer}번 출력 포트가 Merge 블록에 연결되어 있으므로, Outport 블록 ''{0}''에 연결된 신호는 신호 복사여야 합니다. 참조된 모델에서 대응되는 루트 Outport 블록을 구동하는 신호가 Merge 블록 사용 규칙을 위반하므로, 소스 Model 블록 ''{3}''의 {4,number,integer}번 출력 포트를 직접 병합할 수 없습니다. Signal Conversion 블록을 삽입하거나 모델을 수정하십시오.</entry>
    <entry key="OutportBufferRequiredNesting1">Outport 블록이 별도의 초기 출력값을 갖는 중첩된 조건부 실행 서브시스템 블록 ''{1}''의 {2,number,integer}번 출력 포트에 의해 구동되므로, 올바른 초기화를 보장하려면 Outport 블록 ''{0}''에 연결된 신호가 신호 복사여야 합니다. Signal Conversion 블록을 삽입하거나 모델을 수정하십시오.</entry>
    <entry key="OutportBufferRequiredNesting2">Outport 블록이 Merge 블록 ''{1}''의 {2,number,integer}번 출력 포트를 통해 별도의 초기 출력값을 갖는 중첩된 조건부 실행 서브시스템에 의해 구동되므로, 올바른 초기화를 보장하려면 Outport 블록 ''{0}''에 연결된 신호가 신호 복사여야 합니다. Signal Conversion 블록을 삽입하거나 모델을 수정하십시오.</entry>
    <entry key="OutportBufferRequiredNotReusable">소스 블록 ''{1}''의 {2,number,integer}번 출력 포트에 대한 신호 버퍼가 재사용 불가로 표시되어 있으므로, 올바른 초기화를 보장하려면 Outport 블록 ''{0}''에 연결된 신호가 신호 복사여야 합니다. Signal Conversion 블록을 삽입하거나 모델을 수정하십시오.</entry>
    <entry key="OutportBufferRequiredBranching">소스 블록 ''{1}''의 {2,number,integer}번 출력 포트가 별도의 초기 출력값을 갖는 또 다른 Outport 블록 ''{3}''을(를) 구동하므로, 올바른 초기화를 보장하려면 Outport 블록 ''{0}''에 연결된 신호가 신호 복사여야 합니다. Signal Conversion 블록을 삽입하거나 모델을 수정하십시오.</entry>
    <entry key="OutportBufferRequiredBranchingSameOutport">소스 블록 ''{1}''의 {2,number,integer}번 출력 포트가 별도의 두 개 신호를 통해 이 Outport 블록을 구동하므로, 올바른 초기화를 보장하려면 Outport 블록 ''{0}''에 연결된 신호가 신호 복사여야 합니다. Signal Conversion 블록을 삽입하거나 모델을 수정하십시오.</entry>
    <entry key="OutportBufferRequiredStateflowReset">올바른 초기화를 보장하려면 Outport 블록 ''{0}''에 연결된 신호가 신호 복사여야 합니다. Stateflow 블록 ''{1}''의 {2,number,integer}번 출력 포트가 Outport 블록을 구동하고 부모 서브시스템 ''{3}''이(가) 활성화된 경우 상태를 재설정하도록 구성되었고 활성화된 경우 실행되도록 보장되지 않기 때문입니다. Signal Conversion 블록을 삽입하거나 모델을 수정하십시오.</entry>
    <entry key="OutportBufferRequiredVariantCondition">Outport 블록의 Variant 조건이 소스 블록의 Variant 조건과 다르므로, Outport 블록 ''{0}''에 연결된 신호는 신호 복사여야 합니다. Signal Conversion 블록을 삽입하거나 모델을 수정하십시오.</entry>
    <entry key="OutportBufferNotAllowedFcnCallInit">소스 블록 ''{0}''의 {1,number,integer}번 출력 포트의 신호가 함수 호출 신호이므로, Signal Conversion 블록을 Outport 블록 ''{2}'' 앞에 자동으로 삽입할 수 없습니다.</entry>
    <entry key="OutportBufferNotAllowedFcnCallInArg">Signal Conversion 블록을 Outport 블록 ''{2}'' 앞에 자동으로 삽입할 수 없습니다. 소스 블록 ''{0}''의 {1,number,integer}번 출력 포트의 신호가 Outport 블록을 통과해 함수 호출 대상 블록에 전달되며 삽입할 경우 함수 호출 데이터 종속성 위반이 발생하기 때문입니다. 함수 호출 데이터 종속성 위반에 대한 예는 예제 모델 &lt;a href="matlab:openExample(''simulink_features/SimulinkSubsystemSemanticsExample''); open_system('sl_subsys_semantics/ Function-call subsystems');"&gt; ''sl_subsys_semantics''&lt;/a&gt;를 참조하십시오.</entry>
    <entry key="OutportBufferNotAllowedSigObj">Signal Conversion 블록을 Outport 블록 ''{2}'' 앞에 자동으로 삽입할 수 없습니다. 소스 블록 ''{0}''의 {1,number,integer}번 출력 포트의 신호가 자동이 아닌 스토리지 클래스를 갖기 때문입니다.</entry>
    <entry key="OutportCannotBufferFcnCallSFcn">''{0}'' {1,number,integer}번 출력 포트에서 함수 호출 신호는 Outport 블록 ''{2}''에 의해 규칙적 신호로 처리합니다. Outport 블록이 함수 호출 신호를 인식하도록 하려면 서브시스템 ''{3}''의 {4,number,integer}번 출력 포트를 Function-Call Subsystem에 연결하십시오. Outport 블록의 ''초기 출력''을 []로 설정하십시오. 또는, S-Function 블록 ''{5}''의 소스 코드에 액세스 가능하고 {6,number,integer}번 출력 포트의 모든 요소가 함수 호출인 경우 mdlInitializeSizes에 ssSetOutputPortDataType(S, {7,number,integer}, SS_FCN_CALL)을 사용하여 이 출력 포트를 function-call 신호로 명시적으로 선언해 보십시오. Outport 블록의 ''초기 출력''을 []로 설정하십시오.</entry>
    <entry key="OutportCannotBufferFcnCall">''{0}'' {1,number,integer}번 출력 포트에서 함수 호출 신호는 Outport 블록 ''{2}''에 의해 규칙적 신호로 처리합니다. Outport 블록이 함수 호출 신호를 인식하도록 하려면 서브시스템 ''{3}''의 {4,number,integer}번 출력 포트를 Function-Call Subsystem에 연결하십시오. Outport 블록의 ''초기 출력''을 []로 설정하십시오.</entry>
    <entry key="OutportCannotHaveICForVirtualBus"> The parameter ''Initial output'' of Outport block ''{0}'' must be empty ([]) when the Outport block is driven by a virtual bus signal. It is possible to specify the initial output using a scalar or a structure value for this Outport block. However, you must enable simplified initialization mode by setting &lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;Underspecified initialization detection&lt;/sldiag&gt; to ''simplified''. Note that some modifications may be necessary to ensure the model conforms to certain modeling standards required by the new initialization mode. For more information, see documentation for the Model Advisor check ''Check consistency of initialization parameters for Outport and Merge blocks''.</entry>
    <entry key="OutportCannotLogNonBuiltInDataTypes">Using the structure or array format is not supported when logging outport ''{0}'' with the string data type or data types that are not built-in. Change the logging format to Dataset or disable Output Logging.
		
		&lt;actions exclusiveFixIts="yes"&gt;
			&lt;action type="fixit"&gt;
				&lt;cmd&gt;set_param(bdroot(''{0}''),''SaveFormat'',''Dataset'')&lt;/cmd&gt;
				&lt;txt&gt;Set data format of model to Dataset.&lt;/txt&gt;
			&lt;/action&gt;
			&lt;action type="fixit"&gt;
				&lt;cmd&gt;set_param(bdroot(''{0}''),''SaveOutput'',''off'')&lt;/cmd&gt;
				&lt;txt&gt;Disable Output Logging.&lt;/txt&gt;
			&lt;/action&gt;
	    &lt;/actions&gt;
		
	</entry>
    <entry key="OutportEmptyDialogIC">Outport 블록 ''{0}''의 파라미터 ''초기 출력:''에 대한 설정이 유효하지 않습니다. 초기 출력값을 완전히 지정해야 합니다.</entry>
    <entry key="OutportInvalidEmptyDialogIC">Outport 블록 ''{0}''의 파라미터 ''초기 출력:''에 대한 설정이 유효하지 않습니다. 초기 출력값을 완전히 지정해야 합니다. 또는, 디폴트 초기화를 사용하려면 ''초기 출력'' 파라미터의 값으로 빈 행렬('[]')을 사용하십시오.</entry>
    <entry key="OutportInvICSrcInternal">Cannot inherit initial output for Outport block ''{0}'' because Simulink inserted a block of type ''{1}'' on the input signal of this Outport block. To correct this problem, specify an initial output value.</entry>
    <entry key="OutportInvICSrcPort">블록 ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;가 유효한 초기 출력 소스가 아니기 때문에 Outport 블록 ''{0}''에 대한 초기 출력을 상속할 수 없습니다. Outport 블록은 Constant, Initial Condition, Merge(초기 출력 있음) 또는 조건부 실행 서브시스템 블록에서만 초기 출력을 상속할 수 있습니다. 이 문제를 해결하려면 Outport가 유효한 초기 출력 소스로 구동되는지 확인하거나 초기 출력값을 지정하십시오.</entry>
    <entry key="OutportInvICSrcRateTrans">Cannot inherit initial output for Outport block ''{0}'' because a Rate Transition block is inserted on the input signal of the Outport block. If you need a rate transition, specify an initial output value for the Outport block. Otherwise, deselect the option ''Automatically handle rate transition for data transfer'' in the Solver pane of the Configuration Parameters dialog</entry>
    <entry key="OutportInheritICStateflowMultiRateEnabledSubsys1">Outport block
    ''{0}'' is inheriting its initial output value from &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;output port
    {1,number,integer}&lt;/sldiag&gt; of Stateflow block ''{2}'' in the multi-rate enabled
    subsystem ''{3}''. Consider one of the following modifications:\n

    (1) Change ''States when enabling'' parameter of Enable Port block ''{4}'' to
    ''held''.\n

    (2) Make the enabled subsystem single-rate.\n

    (3) For the Outport block, ensure that the parameter ''Initial output'' is
    not empty ([]).\n

    (4) Insert a Signal Conversion block before the Outport block.</entry>
    <entry key="OutportInheritICStateflowMdlRefMultiRateEnabledSubsys1">Outport 블록 ''{0}''은(는) 멀티레이트 Enabled Subsystem ''{3}''에서 Model 블록 ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;를 통해 Stateflow 블록에서 해당 초기 출력값을 상속합니다. 다음 수정 작업 중 하나를 수행해 보십시오.\n (1) Enable Port 블록 ''{4}''의 ''활성화할 때의 상태'' 파라미터를 ''유지''로 변경합니다.\n (2) Enabled Subsystem을 싱글레이트로 설정합니다.\n (3) Outport 블록의 파라미터 ''초기 출력''이 빈 값([])이 아니도록 합니다.\n (4) Outport 블록 앞에 Signal Conversion 블록을 삽입합니다.</entry>
    <entry key="OutportInheritICStateflowMultiRateEnabledSubsys2">Outport 블록 ''{0}''은(는) Stateflow 블록 ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에서 해당 초기 출력값을 상속하지만, 부모 Function-Call Subsystem ''{3}''은(는) 멀티레이트 Enabled Subsystem ''{4}''(으)로 구동됩니다. 다음 수정 작업 중 하나를 수행해 보십시오.\n (1) Trigger Port 블록 ''{5}''의 ''활성화할 때의 상태'' 파라미터를 ''유지''로 변경합니다.\n (2) Enabled Subsystem을 싱글레이트로 설정합니다.\n (3) Outport 블록의 파라미터 ''초기 출력''이 빈 값([])이 아니도록 합니다.\n (4) Outport 블록 앞에 Signal Conversion 블록을 삽입합니다.</entry>
    <entry key="OutportInheritICStateflowMdlRefMultiRateEnabledSubsys2">Outport 블록 ''{0}''은(는) Model 블록 ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;를 통해 Stateflow 블록에서 해당 초기 출력값을 상속하지만, 부모 Function-Call Subsystem ''{3}''은(는) 멀티레이트 Enabled Subsystem ''{4}''(으)로 구동됩니다. 다음 수정 작업 중 하나를 수행해 보십시오.\n (1) Trigger Port 블록 ''{5}''의 ''활성화할 때의 상태'' 파라미터를 ''유지''로 변경합니다.\n (2) Enabled Subsystem을 싱글레이트로 설정합니다.\n (3) Outport 블록의 파라미터 ''초기 출력''이 빈 값([])이 아니도록 합니다.\n (4) Outport 블록 앞에 Signal Conversion 블록을 삽입합니다.</entry>
    <entry key="OutportInvalidArrayDataLoggingUsingLHSA_COMPLEXITY">루트 Outport에 연결된 신호가 다른 실수/복소수 여부를 갖기 때문에 sim 명령의 추가 출력 인수를 통해 출력을 저장할 수 없습니다. \n입력 인수 ''ReturnWorkspaceOutputs'' 및 ''on''을 사용하여 단일 출력 인수를 통해 출력을 저장하십시오.</entry>
    <entry key="OutportInvalidArrayDataLoggingUsingLHSA_DATATYPE">Cannot save outputs through extra output arguments of the sim command because signals connected to the root outports have different data types. \nSave outputs through single output argument by using input arguments '''ReturnWorkspaceOutputs'' and ''on''.</entry>
    <entry key="OutportInvalidArrayDataLoggingUsingLHSA_DIM">모델 ''{0}''의 루트 아웃포트에 연결된 신호가 스칼라 또는 1차원 배열이 아니므로 sim 명령의 추가 출력 인수를 통해 출력을 저장할 수 없습니다. \n입력 인수 ''ReturnWorkspaceOutputs'' 및 ''on''을 사용하여 단일 출력 인수를 통해 출력을 저장하십시오.</entry>
    <entry key="OutportInvalidArrayDataLogging_COMPLEXITY">Cannot save outputs in the ''Array'' format because the signals connected to the root outports are not of the same complexity. \nSet ''Configuration Parameters &gt; Data Import/Export &gt; Format'' to ''Dataset'', ''Structure with time'' or ''Structure''. The output format can also be specified via input argument ''SaveFormat'' of the sim command for command line simulation.</entry>
    <entry key="OutportInvalidArrayDataLogging_DATATYPE">루트 아웃포트에 연결된 신호가 다른 데이터형을 가지므로 출력을 ''배열'' 형식으로 저장할 수 없습니다. \n''구성 파라미터 &gt; 데이터 가져오기/내보내기 &gt; 형식''을 ''Dataset'', ''시간값을 갖는 구조체'' 또는 ''구조체''로 설정하십시오. 명령줄 시뮬레이션의 경우 sim 명령의 입력 인수 ''SaveFormat''을 통해 출력 형식을 지정할 수도 있습니다.</entry>
    <entry key="OutportInvalidArrayDataLogging_DIM">모델 ''{0}''의 루트 아웃포트에 연결된 신호가 스칼라 또는 1차원 배열이 아니므로 출력을 ''배열'' 형식으로 저장할 수 없습니다. ''구성 파라미터 &gt; 데이터 가져오기/내보내기 &gt; 형식''을 ''Dataset'', ''구조체'' 또는 ''시간값을 갖는 구조체''로 설정하십시오.</entry>
    <entry key="BEPInvalidDataLoggingFormat">Model ''{0}'' has root level bus element outport blocks and is configured to save outputs in either ''Array'', ''Structure'' or ''Structure with time'' formats. 
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="suggestion"&gt;
            &lt;cmd&gt;configset.internal.open(''{0}'',''SaveFormat'')&lt;/cmd&gt;
            &lt;txt&gt;Set ''Configuration Parameters &amp;gt; Data Import/Export &amp;gt; Format'' to ''Dataset'' to save outputs&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
</entry>
    <entry key="OutportMustHaveScalarICForBusSignal">The parameter ''Initial output'' of Outport block ''{0}'' must be a scalar or a structure when the Outport block is driven by a bus signal</entry>
    <entry key="OutportVarDimsVirtualBusWithNonVirtualSubbusSimplified">비가상 버스 요소를 포함하는 가상 버스는 Outport 블록 ''{0}''에 대한 입력으로 지원되지 않습니다. 이 버스 요소 중 적어도 하나가 가변 차원을 가지기 때문입니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;'To Virtual Bus' 블록을 ''{0}''의 입력에 삽입하여 버스 신호를 비가상 버스 요소를 갖지 않는 신호로 변환하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;또는, ''{0}''에 대한 입력에 가변 차원을 갖는 요소가 없도록 하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="OutportVarDimsVirtualBusWithNonVirtualSubbusClassic">A virtual bus containing non-virtual bus elements is not supported as an input to the Outport block ''{0}'' because at least one of the elements of the bus has variable dimensions. Carry out all the following steps to fix the issue.
  &lt;actions exclusiveFixIts="yes"&gt;
    &lt;action type="fixit"&gt;
      &lt;cmd&gt;configset.internal.fixIt(''{1}'',''UnderspecifiedInitializationDetection'',''Simplified'')&lt;/cmd&gt;
      &lt;txt&gt;Set &lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;Underspecified initialization detection&lt;/sldiag&gt; to Simplified.&lt;/txt&gt;
    &lt;/action&gt;
    &lt;action type="suggestion"&gt;
      &lt;txt&gt;Insert the 'To Virtual Bus' block at the input of ''{0}'' to convert the bus signal to one that has no non-virtual bus elements.&lt;/txt&gt;
    &lt;/action&gt;
  &lt;/actions&gt;
</entry>
    <entry key="OutportMustHaveScalarICForVarDimsVirtualBusClassic">모델 ''{1}''이(가) 가상 버스로 구동되는 ''{0}'' 같은 Outport 블록을 포함하고 버스가 가변 차원의 요소를 포함하는 경우 이 모델의 파라미터 &lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;과소 지정된 초기화 감지&lt;/sldiag&gt;를 ''고전 방식''으로 설정할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;Simulink.internal.OpenBlockParamsDialog(''{0}'',''InitialOutput'')&lt;/cmd&gt; &lt;txt&gt;''초기 출력'' 파라미터를 스칼라 값으로 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{1}'',''UnderspecifiedInitializationDetection'',''Simplified'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;과소 지정된 초기화 감지&lt;/sldiag&gt;를 [단순 방식]으로 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="OutportNeedsVirtualBusCopy">해당 서브시스템의 출력 신호가 올바로 초기화되도록 하려면 Outport 블록 ''{0}''을(를) 구동하는 버스 신호의 명시적 복사본이 필요합니다. ''출력'' 옵션이 ''신호 복사''로 설정된 Signal Conversion 블록을 이 Outport 블록 앞에 삽입하십시오. 다음과 같은 이유로 추가 신호 복사본이 필요할 수 있습니다. (1) Outport가 Ground, Constant 또는 Stateflow 블록과 같은 덮어쓸 수 없는 출력을 갖는 블록에 의해 구동됩니다. (2) Outport가 동일한 서브시스템 또는 현재 서브시스템 내에 중첩된 서브시스템의 다른 Outport와 동일한 신호 소스를 공유하되, 다른 초기 출력값을 가집니다. (3) Outport가 Merge 블록의 입력에 연결되어 있습니다. 또는 (4) 명시적 초기값을 갖는 Simulink.Signal 객체가 Outport의 입력 신호 중 하나에 지정됩니다.</entry>
    <entry key="OutportPassingThruFcnCallInitSigMustInheritIC">A function-call trigger signal from &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;output port {1,number,integer}&lt;/sldiag&gt; of block ''{2}'' is passing through the Outport block ''{0}''. Therefore, the parameter ''Initial output'' must be set to [].
    &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;set_param(''{0}'',''InitialOutput'',''[]'');&lt;/cmd&gt;
            &lt;txt&gt;Set ''Initial output'' to ''[]'' for ''{0}''.&lt;/txt&gt;
        &lt;/action&gt;
    &lt;/actions&gt;
    </entry>
    <entry key="OutputBufferInfNanDetectedError">{4} 시간 스텝 {5}에서 &lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;{3,number,integer}번 출력 포트&lt;/sldiag&gt;의 요소 {2,number,integer}에 대한 블록 ''{0}''의 출력 ''{1}''입니다. 이 블록은 값이 추가된 위치가 아닐 수 있습니다. 값이 시작된 블록을 찾으려면 액셀러레이터 모드 대신 표준 모드로 실행하십시오.</entry>
    <entry key="OutputNotConnected">블록 ''{1_SLObject}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1_SLObject}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;가 연결되어 있지 않습니다.</entry>
    <entry key="OutputPortMultiDDimsDisallowed">Cannot set dimensions of &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' to {2}. This block is not setup to handle signals of dimensions greater than 2 dimensions.</entry>
    <entry key="OutputPortTrailingUnityDimsDisallowed">Cannot initialize dimensions of &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' to {2}. When the number of dimensions of a matrix exceeds 2, the size of the trailing dimension must be greater than 1.</entry>
    <entry key="OverLicenseBlockLimit">블록 다이어그램 ''{0}'' 및 이에 의해 참조되는 모든 모델 내의 블록 개수가 비가상 블록의 라이선스 한도인 {1,number,integer}개를 초과합니다.</entry>
    <entry key="LicenseNoAcceleratorWarning">모델 ''{0}''은(는) 액셀러레이터 모드 또는 고속 액셀러레이터 모드를 사용합니다. 이 라이선스는 이러한 모드를 지원하지 않습니다. 시뮬레이션은 표준 모드로 실행됩니다.</entry>
    <entry key="ExplicitPartitionsNotSupportedInXIL">Model with explicit partitions is not supported by top-model SIL or PIL simulation mode. However, this model can be verified, equivalently, by referencing it as a model block with SIL or PIL simulation mode.</entry>
    <entry key="PLCCoder_LicenseError">코드를 생성하는 데 필요한 Simulink PLC Coder 라이선스를 체크아웃할 수 없음</entry>
    <entry key="ParamDataTypeNotSupportedInRTP">The block diagram ''{0}'' has a tunable parameter ''{1}'' with data type ''{2}''. This data type is not supported by rsimgetrtp or in rapid accelerator mode.</entry>
    <entry key="NotSupportRSIMWithMessages">모델 ''{0}''이(가) 시스템 타깃 파일 rsim.tlc로 구성되어 있으며, 메시지를 보내거나 받는 블록 ''{1}''을(를) 포함합니다. 시스템 타깃 파일 rsim.tlc는 해당 블록에 대한 메시지 전달을 지원하지 않습니다. 다른 시스템 타깃 파일을 선택하십시오.</entry>
    <entry key="NotSupportExtModeWithMessages">모델 ''{0}''이(가) 외부 모드를 사용하도록 구성되어 있으며, 메시지를 보내거나 받는 블록 ''{1}''을(를) 포함합니다. 외부 모드는 이 블록에 대한 메시지 전달을 지원하지 않습니다. 모델 구성 파라미터에서 외부 모드를 선택 해제하십시오. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''ExtMode'',''off'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="ExtMode"&gt;외부 모드&lt;/sldiag&gt;를 비활성화하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="NotSupportLogToMDFWithMessages">모델 ''{0}''이(가) 신호를 MDF 파일에 기록하도록 구성되어 있으며, 메시지를 보내거나 받는 블록 ''{1}''을(를) 포함합니다. MDF 파일 신호 기록은 이 블록에 대한 메시지 전달을 지원하지 않습니다. 모델 구성 파라미터 LogToMDFFile을 'off'로 설정하십시오. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="DisableMDF"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''LogToMDFFile'',''off'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="LogToMDFFile"&gt;MDF 파일에 신호 기록&lt;/sldiag&gt;을 비활성화하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="ModelParameterNotFoundInCAPI"> C-API에서 모델 파라미터 ''{0}''을(를) 찾을 수 없습니다. </entry>
    <entry key="BlockParameterNotFoundInCAPI"> C-API에서 블록 경로가 ''{1}''인 블록 파라미터 ''{0}''을(를) 찾을 수 없습니다. </entry>
    <entry key="RSimGetRtpGeneratedCodeDoesNotExist"> Could not find the host C-API library ''{0}''. </entry>
    <entry key="RSimGetRtpCannotUsePreCompiledModel">RSimGetRTP does not work with pre-compiled models.</entry>
    <entry key="RSimGetRtpChecksumMismatch">RSimGetRTP에 제공된 rtp의 체크섬이 생성 코드의 체크섬과 일치하지 않습니다.</entry>
    <entry key="ParameterDataNotReusableSCForCPP">파라미터 ''{0}''의 스토리지 클래스가 전역이므로 생성 코드가 C++ 클래스 인터페이스와 호환되지 않습니다. 스토리지 클래스 ''자동''을 사용하거나 옵션 ''코드 인터페이스 패키징''을 ''C++ 클래스''가 아닌 값으로 설정해 보십시오.</entry>
    <entry key="ParentInitTimeVariableSizeSubsystemExecTimeVariableSize">The subsystem ''{0}'' is set to ''Propagate sizes of variable-size signals during execution''. However, its parent subsystem is set to ''Propagate sizes of variable-size signals only when enabling, resetting, or when execution is resumed''. Consider changing the parameter ''Propagate sizes of variable-size signals'' for ''{1}'' to ''Only when enabling''.</entry>
    <entry key="ResetSSParentInitTimeVariableSizeSubsystemExecTimeVariableSize">The subsystem ''{0}'' is set to ''Propagate sizes of variable-size signals during execution''. However, its parent subsystem is set to ''Propagate sizes of variable-size signals only when enabling, resetting, or when execution is resumed''. Consider changing the parameter ''Propagate sizes of variable-size signals'' for ''{1}'' to ''Only when resetting''.</entry>
    <entry key="EmlParseCompilationError">코드 대체 라이브러리에 지정된 파생된 표현식 ''{0}''은(는) 코드 생성 시 지원되지 않습니다.</entry>
    <entry key="PartialCompileEarlyTerminate">요청에 따라 파라미터 평가 후 컴파일을 종료하는 중</entry>
    <entry key="PassThroughBusTypeMismatch">''{0}''의 데이터형이 유효하지 않습니다. 블록이 {1,number,integer}번 입력 포트와 {2,number,integer}번 출력 포트가 모델 실행 과정 전체에 걸쳐 동일한 버스 유형을 가져야 함을 나타내는 플래그(ssSetInputDimsSameAsOutputDims for S-functions)를 설정했습니다. Simulink에서는 입력 포트와 출력 포트의 버스 유형이 같아야 합니다.</entry>
    <entry key="PassThroughCompStageMismatch">Simulink detected an incorrect usage of ''ssSetInputPortDimsSameAsOutputPortDims'' for the S-function in ''{0}''. This SimStruct function can only be used in the ''mdlSetWorkWidths'' method.</entry>
    <entry key="PassThroughDimsMismatch">The maximum dimensions of the variable-size signals at the &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;input port {1,number,integer}&lt;/sldiag&gt; and the &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{0}"&gt;output port {2,number,integer}&lt;/sldiag&gt; of block ''{0}'' are ''{3}'' and ''{4}'' respectively. These values at the input and the output port of this block must match.</entry>
    <entry key="PassThroughDimsModeMismatch">''{0}''의 차원 모드 설정이 유효하지 않습니다. 블록이 {1,number,integer}번 입력 포트와 {2,number,integer}번 출력 포트의 차원이 모델 실행 과정 전체에 걸쳐 같아야 함을 나타내는 플래그(ssSetInputDimsSameAsOutputDims for S-functions)를 설정했습니다. Simulink에서는 입력 포트와 출력 포트의 차원 모드가 같아야 합니다.</entry>
    <entry key="PassThroughInvalidDirectFeedThroughSetting">''{0}'', which has variable-size mode, has an invalid direct feedthrough setting. The block has set a flag (ssSetInputDimsSameAsOutputDims for S-functions) which indicates that the dimensions of the input port {1,number,integer} and the output port {2,number,integer} must be the same throughout the model execution. Simulink requires that the direct feedthrough setting for the input port must be ''on''.</entry>
    <entry key="PathEmpty">빈 경로가 지정됨</entry>
    <entry key="PathInvalid">유효하지 않은 경로가 지정됨</entry>
    <entry key="PeriodicFCSSMustHaveScalarCall">Only one function-call initiator can execute function-call block ''{0}'' because it has a periodic sample time.</entry>
    <entry key="PerturbationMustBeScalar">블록 ''{0}'', {1,number,integer}번 포트의 포트 섭동 수준은 스칼라 변수여야 합니다.</entry>
    <entry key="PerturbationNotValidOnOutputPort">Port perturbation level not valid for a Simulink output port</entry>
    <entry key="PerturbationWithNonDoubleData">블록이 수치 섭동 메서드를 사용하여 선형화되었습니다. 입력 포트 중 하나 이상이 비double형이고 섭동되지 않았습니다.</entry>
    <entry key="PortBasedTsNeedsPorts">The block ''{0}'' cannot specify PORT_BASED_SAMPLE_TIMES because it has no ports.</entry>
    <entry key="PortDimsMismatch11">포트 너비 또는 차원에 오류가 있습니다. ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대해 유효하지 않은 차원이 지정되었습니다. 차원은 NULL일 수 없습니다.</entry>
    <entry key="PortDimsMismatch12">포트 너비 또는 차원에 오류가 있습니다. ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 대해 유효하지 않은 차원이 지정되었습니다. 차원은 NULL일 수 없습니다.</entry>
    <entry key="PortDimsMismatch21">포트 너비 또는 차원에 오류가 있습니다. ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대해 유효하지 않은 차원이 지정되었습니다.</entry>
    <entry key="PortDimsMismatch22">포트 너비 또는 차원에 오류가 있습니다. ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 대해 유효하지 않은 차원이 지정되었습니다.</entry>
    <entry key="PortDimsMismatch31">포트 너비 또는 차원에 오류가 있습니다. ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 {2,number,integer}개의 요소가 있습니다. 이 포트는 입력 신호로 지정된 차원(또는 방향)을 허용하지 않습니다.</entry>
    <entry key="PortDimsMismatch32">포트 너비 또는 차원에 오류가 있습니다. ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 {2,number,integer}개의 요소가 있습니다. 이 포트는 출력 신호로 지정된 차원(또는 방향)을 허용하지 않습니다.</entry>
    <entry key="PortDimsMismatch41">포트 너비 또는 차원에 오류가 있습니다. ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;가 {2,number,integer}개의 요소를 갖는 1차원 벡터입니다.</entry>
    <entry key="PortDimsMismatch42">포트 너비 또는 차원에 오류가 있습니다. ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;가 {2,number,integer}개의 요소를 갖는 1차원 벡터입니다.</entry>
    <entry key="BusSelectorAoBInputErr">Bus Selector 블록 ''{0}''에는 버스가 필요한데, 버스로 구성된 배열이 수신됩니다. 버스로 구성된 배열에서 요소를 선택하려면 Bus Selector 블록 대신 Selector 블록을 사용하십시오.</entry>
    <entry key="PortDimsMismatch51">포트 너비 또는 차원에 오류가 있습니다. ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;가 {2} 행렬입니다.</entry>
    <entry key="PortDimsMismatch52">포트 너비 또는 차원에 오류가 있습니다. ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;가 {2} 행렬입니다.</entry>
    <entry key="PortHandleNotAvailable">At least one of the port handles that correspond to linearization points is no longer available. Make sure that no block has been removed from block diagram, for example, in a model callback function or mask initialization code.</entry>
    <entry key="PortSampHitForNonPST">The ''IsSampleHit'' method of ''{0}'' cannot be called for a port that has no sample time</entry>
    <entry key="PortTypeDomainDifference">포트 유형 ''{0}''과(와) 포트 유형 ''{1}''은(는) 서로 다른 영역을 가지므로 연결할 수 없습니다.</entry>
    <entry key="PortVarDimsMismatch31">포트 너비 또는 차원에 오류가 있습니다. ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 최대 {2,number,integer}개의 요소가 있습니다. 이 포트는 입력 신호로 지정된 차원(또는 방향)을 허용하지 않습니다.</entry>
    <entry key="PortVarDimsMismatch32">포트 너비 또는 차원에 오류가 있습니다. ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 최대 {2,number,integer}개의 요소가 있습니다. 이 포트는 출력 신호로 지정된 차원(또는 방향)을 허용하지 않습니다.</entry>
    <entry key="PortVarDimsMismatch41">포트 너비 또는 차원에 오류가 있습니다. ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;가 최대 {2,number,integer}개의 요소를 갖는 1차원 벡터입니다.</entry>
    <entry key="PortVarDimsMismatch42">포트 너비 또는 차원에 오류가 있습니다. ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;가 최대 {2,number,integer}개의 요소를 갖는 1차원 벡터입니다.</entry>
    <entry key="PortVarDimsMismatch51">Error in port widths or dimensions. &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a matrix with a maximum size of {2}.</entry>
    <entry key="PortVarDimsMismatch52">포트 너비 또는 차원에 오류가 있습니다. ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;가 최대 크기 {2}의 행렬입니다.</entry>
    <entry key="PrintAlgLoopFound">다음을 포함하는 대수 루프가 발견됨: {0} </entry>
    <entry key="ProfileInitErrWithErrContext">Simulink 프로파일러에 대한 오류 컨텍스트를 초기화하는 중 오류가 발생함</entry>
    <entry key="ProfileInitErrWithMsgContext">Simulink 프로파일러에 대한 메시지 컨텍스트를 초기화하는 중 오류가 발생함</entry>
    <entry key="ProfileReportGenErr">모델 ''{0}''에 대한 프로파일 리포트를 생성하는 중 오류가 발생했습니다.</entry>
    <entry key="ProfilingNotSupportedForFixedAndDiscrete">상태가 없는 고정 스텝 솔버와 모델에는 솔버 프로파일링이 지원되지 않습니다.\n고정 스텝 ODE 솔버 또는 이산 솔버와 관련된 솔버 정보가 생성되지 않습니다.\n</entry>
    <entry key="ProjStateNotFinite">After imposing invariants at time {0}, state ''{1}'' of ''{2}'' is Inf or NaN.  Stopping simulation.</entry>
    <entry key="ProjectionsNotSupported">모델 ''{0}''에 필요한 상태 투영은 현재 지원되지 않기 때문에 이 모델에 대한 코드를 생성할 수 없음</entry>
    <entry key="RTI_ASSIGN_COMPLEX_MISMATCH">Invalid assignment in ''{0}'': attempt to assign ''complex'' to ''real''</entry>
    <entry key="RTI_ASSIGN_DATA_TYPE_MISMATCH">''{0}''의 할당이 유효하지 않음: ''{1}''을(를) ''{2}''에 할당하려고 함</entry>
    <entry key="RTI_ASSIGN_DIMS_MISMATCH">Invalid assignment in ''{0}'': attempt to assign a matrix of dimensions {1} to a matrix of dimensions {2}</entry>
    <entry key="RTI_ASSIGN_INVALID_DATA">''{0}''의 할당이 유효하지 않습니다. 데이터는 숫자형 배열 또는 논리형 배열이어야 합니다</entry>
    <entry key="RTI_ASSIGN_NUM_DIMS_MISMATCH">Invalid assignment in ''{0}'': attempt to assign a matrix to a vector</entry>
    <entry key="RTI_ASSIGN_VECT_WIDTH_MISMATCH">''{0}''의 할당이 유효하지 않음: 너비가 {1,number,integer}인 벡터를 너비가 {2,number,integer}인 벡터에 할당하려고 함</entry>
    <entry key="RTI_ContStatesInvalidComplexity">''{0}''의 연속 상태에 대해 지정된 데이터의 실수/복소수 여부가 유효하지 않습니다. 데이터의 실수/복소수 여부는 ''실수'' 또는 ''복소수''여야 합니다.</entry>
    <entry key="RTI_ContStatesInvalidDatatype">''{0}''의 연속 상태에 대해 지정된 데이터형이 유효하지 않습니다. ''double''의 경우 연속 상태의 데이터형 ID는 0이어야 합니다.</entry>
    <entry key="RTI_ContStatesInvalidDims">''{0}''의 연속 상태에 대해 지정된 차원이 유효하지 않습니다. 연속 상태의 차원은 양의 정수여야 합니다.</entry>
    <entry key="RTI_DataAsDouble_NonBuiltInNotSupported">''{0}''의 DataAsDouble 메서드는 내장되지 않은 데이터형에는 지원되지 않음</entry>
    <entry key="RTI_DataStoreCmplxReadOnly">''{1}''에서 데이터저장소 ''{0,number,integer}''의 읽기 전용 ''실수/복소수 여부'' 필드를 설정할 수 없음</entry>
    <entry key="RTI_DataStoreDimsReadOnly">''{1}''에서 데이터저장소 ''{0,number,integer}''의 읽기 전용 ''차원'' 필드를 설정할 수 없음</entry>
    <entry key="RTI_DataStoreDtypeReadOnly">''{1}''에서 데이터저장소 ''{0,number,integer}''의 읽기 전용 ''DataType'' 필드를 설정할 수 없음</entry>
    <entry key="RTI_Data_NonBuiltInNotSupported">''{0}''에서 내장되지 않은 데이터형을 갖는 데이터에는 액세스할 수 없음</entry>
    <entry key="RTI_DerivativesInvalidComplexity">''{0}''의 도함수에 대해 지정된 데이터의 실수/복소수 여부가 유효하지 않습니다. 데이터의 실수/복소수 여부는 ''실수'' 또는 ''복소수''여야 합니다.</entry>
    <entry key="RTI_DerivativesInvalidDatatype">''{0}''의 도함수에 대해 지정된 데이터형이 유효하지 않습니다. ''double''의 경우 도함수의 데이터형 ID는 0이어야 합니다.</entry>
    <entry key="RTI_DerivativesInvalidDims">''{0}''의 도함수에 대해 지정된 차원이 유효하지 않습니다. 연속 상태의 차원은 양의 정수여야 합니다.</entry>
    <entry key="RTI_DlgPrmInvalidComplexity">''{1}''의 대화 상자 파라미터 {0,number,integer}에 대해 지정된 데이터의 실수/복소수 여부가 유효하지 않습니다. 데이터의 실수/복소수 여부는 ''실수'' 또는 ''복소수''여야 합니다.</entry>
    <entry key="RTI_DlgPrmInvalidDatatype">''{1}''의 대화 상자 파라미터 {0,number,integer}에 대해 지정된 데이터형이 유효하지 않습니다. 데이터형 ID는 ''double''의 경우 0, ''single''의 경우 1, ''int8''의 경우 2, ''uint8''의 경우 3, ''int16''의 경우 4, ''uint16''의 경우 5, ''int32''의 경우 6, ''uint32''의 경우 7, ''boolean''의 경우 8이어야 합니다.</entry>
    <entry key="RTI_DlgPrmInvalidDims">''{1}''의 대화 상자 파라미터 {0,number,integer}에 대해 지정된 차원이 유효하지 않습니다. 차원은 양의 정수로 구성된 배열이어야 합니다.</entry>
    <entry key="RTI_DworkInvalidComplexity">''{1}''의 Dwork {0,number,integer}에 대해 지정된 데이터의 실수/복소수 여부가 유효하지 않습니다. 데이터의 실수/복소수 여부는 ''실수'' 또는 ''복소수''여야 합니다.</entry>
    <entry key="RTI_DworkInvalidDatatype">''{1}''의 Dwork {0,number,integer}에 대해 지정된 데이터형이 유효하지 않습니다. Dwork의 데이터형 ID는 ''double''의 경우 0, ''single''의 경우 1, ''int8''의 경우 2, ''uint8''의 경우 3, ''int16''의 경우 4, ''uint16''의 경우 5, ''int32''의 경우 6, ''uint32''의 경우 7, ''boolean'' 또는 고정소수점 데이터형의 경우 8이어야 합니다.</entry>
    <entry key="RTI_DworkInvalidDims">Invalid dimensions specified for Dwork {0,number,integer} of ''{1}''. Dwork must be a vector, and its width must be a positive integer</entry>
    <entry key="RTI_EmptyDataStoreName">''{1}''의 데이터저장소 {0,number,integer}의 이름은 빈 문자형 벡터일 수 없음</entry>
    <entry key="RTI_EmptyDworkName">''{1}''의 Dwork {0,number,integer}의 이름은 빈 문자형 벡터일 수 없음</entry>
    <entry key="RTI_FullDimInfoUnknown">''{1}''에서 Dwork {0,number,integer}의 차원 정보가 완전히 지정되지 않음</entry>
    <entry key="RTI_IdxForNoDataStore">''{0}''의 데이터저장소 인덱스가 유효하지 않습니다. 이 블록에는 등록된 데이터저장소가 없습니다.</entry>
    <entry key="RTI_IdxForNoDlgPrm">''{0}''의 대화 상자 파라미터 인덱스가 유효하지 않습니다. 이 블록에 대화 상자 파라미터가 없습니다</entry>
    <entry key="RTI_IdxForNoDwork">Invalid Dwork index for ''{0}''. This block has no registered Dwork</entry>
    <entry key="RTI_IdxForNoInputPort">''{0}''에 대해 지정된 입력 포트 인덱스가 유효하지 않습니다. 이 블록에 입력 포트가 없습니다</entry>
    <entry key="RTI_IdxForNoOutputPort">''{0}''에 대해 지정된 출력 포트 인덱스가 유효하지 않습니다. 이 블록에 출력 포트가 없습니다</entry>
    <entry key="RTI_IdxForNoRTP">Invalid run-time parameter index for ''{0}''. This block has no run-time parameters</entry>
    <entry key="RTI_InputPortInvalidComplexity">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대해 지정된 신호의 실수/복소수 여부가 유효하지 않습니다. 신호의 실수/복소수 여부는 ''실수'', ''복소수'' 또는 ''상속됨''이어야 합니다.</entry>
    <entry key="RTI_InputPortInvalidDatatype">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대해 지정된 데이터형이 유효하지 않습니다. 입력 포트의 데이터형 ID는 ''inherited''의 경우 -1, ''double''의 경우 0, ''single''의 경우 1, ''int8''의 경우 2, ''uint8''의 경우 3, ''int16''의 경우 4, ''uint16''의 경우 5, ''int32''의 경우 6, ''uint32''의 경우 7, ''boolean'' 또는 고정소수점 데이터형의 경우 8이어야 합니다.</entry>
    <entry key="RTI_InputPortInvalidDims">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대해 지정된 차원이 유효하지 않습니다. 차원은 양의 정수로 구성된 배열(또는 상속된 경우 -1)이어야 합니다.</entry>
    <entry key="RTI_InputPortInvalidDimsMode">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대해 지정된 차원 모드가 유효하지 않습니다. 차원 모드는 ''고정'', ''가변'' 또는 ''상속됨''이어야 합니다.</entry>
    <entry key="RTI_InputPortInvalidFrameness">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대해 지정된 샘플링 모드가 유효하지 않습니다. 샘플링 모드는 ''샘플'', ''프레임'' 또는 ''상속됨''이어야 합니다.</entry>
    <entry key="RTI_InputPortInvalidOverwriteDatatype">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;의 데이터형 ID를 {2,number,integer}에서 {3,number,integer}(으)로 변경할 수 없음</entry>
    <entry key="RTI_InputPortInvalidReuseSetting">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대해 지정된 재사용 가능성이 유효하지 않습니다. 입력 포트 재사용 가능성은 ''NotReusableAndGlobal'' 또는 ''ReusableAndLocal''이어야 합니다.</entry>
    <entry key="RTI_InputPortOverwriteComplexity">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;의 신호의 실수/복소수 여부를 ''{2}''에서 ''{3}''(으)로 변경할 수 없음</entry>
    <entry key="RTI_InputPortOverwriteDims">The dimensions of &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' cannot be changed from {2} to {3}</entry>
    <entry key="RTI_InputPortOverwriteDimsMode">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;의 차원 모드를 ''{2}''에서 ''{3}''(으)로 변경할 수 없음</entry>
    <entry key="RTI_InputPortOverwriteFrameness">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;의 샘플링 모드를 ''{2}''에서 ''{3}''(으)로 변경할 수 없음</entry>
    <entry key="RTI_InvalidDataStoreIdx">''{0}''의 데이터저장소 인덱스가 유효하지 않습니다. Dwork 인덱스는 1에서 {1,number,integer} 사이의 범위 내에 있어야 합니다.</entry>
    <entry key="RTI_InvalidDlgPrmIdx">''{0}''의 대화 상자 파라미터 인덱스가 유효하지 않습니다. 대화 상자 파라미터 인덱스는 1에서 {1,number,integer} 사이의 범위 내에 있어야 합니다</entry>
    <entry key="RTI_InvalidDworkIdx">Invalid Dwork index for ''{0}''. Dwork index must be in the range from 1 through {1,number,integer}</entry>
    <entry key="RTI_InvalidInputPortIdx">''{0}''에 대해 지정된 입력 포트 인덱스가 유효하지 않습니다. 입력 포트 인덱스는 1에서 {1,number,integer} 사이의 범위 내에 있어야 합니다</entry>
    <entry key="RTI_InvalidInputPortIdx2">Invalid input port index ({0,number,integer}) specified for block "''{1}''", which has {2,number,integer} input ports. Tip: port numbering goes 1,2,3...</entry>
    <entry key="RTI_InvalidOutputPortIdx">''{0}''의 출력 포트 인덱스가 유효하지 않습니다. 출력 포트 인덱스는 1에서 {1,number,integer} 사이의 범위 내에 있어야 합니다</entry>
    <entry key="RTI_InvalidRTPIdx">''{0}''의 런타임 파라미터 인덱스가 유효하지 않습니다. 런타임 파라미터 인덱스는 1에서 {1,number,integer} 사이의 범위 내에 있어야 합니다.</entry>
    <entry key="RTI_INVALID_INSTANTIATE_DIRECTLY">런타임 객체를 직접 인스턴스화할 수 없습니다. "get_param"을 사용하십시오.</entry>
    <entry key="RTI_INVALID_INSTANTIATE_BLOCK_DATA">Simulink.BlockData 객체를 직접 인스턴스화할 수 없습니다.</entry>
    <entry key="RTI_INVALID_COPY_BLOCK_DATA_VALUE">"BlockDataValues 데이터형에 대해 copy 메서드가 구현되지 않았습니다."</entry>
    <entry key="RTI_Listener_TIDs_ExecOnly">''{0}''의 이벤트 리스너 TID에는 시뮬레이션이 실행 중일 때만 액세스할 수 있음</entry>
    <entry key="RTI_Listener_Const_SampleTime">Simulink는 상수가 아닌 샘플 시간을 갖는 블록에만 실행 이벤트 리스너를 추가할 수 있습니다. 블록 ''{0}''은(는) 상수 샘플 시간을 갖습니다.</entry>
    <entry key="RTI_MATLAB_BLK_ONLY">속성 ''{0}''은(는) MATLAB S-Function 블록에 대해서만 설정할 수 있음</entry>
    <entry key="RTI_MATLAB_BLK_OR_EVENT_CALLBACK_ONLY">Property ''{0}'' can only be set for a MATLAB S-function block or from an event listener</entry>
    <entry key="RTI_NULL_DATA">''{0}''의 데이터에 액세스할 수 없습니다. 이 오류의 원인은 시뮬레이션이 실행 중일 때만 사용 가능한 데이터에 액세스했기 때문일 수 있습니다</entry>
    <entry key="RTI_OutputPortInvalidComplexity">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 대해 지정된 신호의 실수/복소수 여부가 유효하지 않습니다. 신호의 실수/복소수 여부는 ''실수'', ''복소수'' 또는 ''상속됨''이어야 합니다.</entry>
    <entry key="RTI_OutputPortInvalidDatatype">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 대해 지정된 데이터형이 유효하지 않습니다. 출력 포트의 데이터형 ID는 ''inherited''의 경우 -1, ''double''의 경우 0, ''single''의 경우 1, ''int8''의 경우 2, ''uint8''의 경우 3, ''int16''의 경우 4, ''uint16''의 경우 5, ''int32''의 경우 6, ''uint32''의 경우 7, ''boolean'' 또는 고정소수점 데이터형의 경우 8이어야 합니다.</entry>
    <entry key="RTI_OutputPortInvalidDims">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 대해 지정된 차원이 유효하지 않습니다. 차원은 양의 정수로 구성된 배열(또는 상속된 경우 -1)이어야 합니다.</entry>
    <entry key="RTI_OutputPortInvalidDimsMode">Invalid dimensions mode specified for &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}''. Sampling mode must be ''Fixed'', ''Variable'' or ''Inherited''</entry>
    <entry key="RTI_OutputPortInvalidFrameness">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 대해 지정된 샘플링 모드가 유효하지 않습니다. 샘플링 모드는 ''샘플'', ''프레임'' 또는 ''상속됨''이어야 합니다.</entry>
    <entry key="RTI_OutputPortInvalidOverwriteDatatype">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;의 데이터형 ID를 {2,number,integer}에서 {3,number,integer}(으)로 변경할 수 없음</entry>
    <entry key="RTI_OutputPortInvalidReuseSetting">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 대해 지정된 재사용 가능성이 유효하지 않습니다. 출력 포트 재사용 가능성은 ''NotReusableAndGlobal'' 또는 ''ReusableAndLocal''이어야 합니다.</entry>
    <entry key="RTI_OutputPortOverwriteComplexity">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;의 신호 실수/복소수 여부를 ''{2}''에서 ''{3}''(으)로 변경할 수 없음</entry>
    <entry key="RTI_OutputPortOverwriteDims">The dimensions of &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' cannot be changed from {2} to {3}</entry>
    <entry key="RTI_OutputPortOverwriteDimsMode">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;의 차원 모드를 ''{2}''에서 ''{3}''(으)로 변경할 수 없음</entry>
    <entry key="RTI_OutputPortOverwriteFrameness">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;의 샘플링 모드를 ''{2}''에서 ''{3}''(으)로 변경할 수 없음</entry>
    <entry key="RTI_PROPERTY_READONLY">속성 ''{0}''은(는) 읽기 전용이므로 설정할 수 없음</entry>
    <entry key="RTI_REDUCED_BLOCK">''{0}''에 대한 런타임 객체를 만들 수 없습니다. 이 블록은 블록 축소 최적화에 의해 제거되었습니다</entry>
    <entry key="RTI_RTPInvalidComplexity">''{1}''의 런타임 파라미터 {0,number,integer}에 대해 지정된 데이터의 실수/복소수 여부가 유효하지 않습니다. 데이터의 실수/복소수 여부는 ''실수'' 또는 ''복소수''여야 합니다.</entry>
    <entry key="RTI_RTPInvalidDatatype">''{1}''의 런타임 파라미터 {0,number,integer}에 대해 지정된 데이터형이 유효하지 않습니다. 데이터형 ID는 ''double''의 경우 0, ''single''의 경우 1, ''int8''의 경우 2, ''uint8''의 경우 3, ''int16''의 경우 4, ''uint16''의 경우 5, ''int32''의 경우 6, ''uint32''의 경우 7, ''boolean''의 경우 8이어야 합니다.</entry>
    <entry key="RTI_RTPInvalidDims">''{1}''의 런타임 파라미터 {0,number,integer}에 대해 지정된 차원이 유효하지 않습니다. 차원은 양의 정수로 구성된 배열이어야 합니다.</entry>
    <entry key="RTI_SetEvaledDlgParamsNotPerm">The data for dialog parameter {0,number,integer} in ''{1}'' is read-only and cannot be set</entry>
    <entry key="RTI_SetInputVarDimsNotPerm">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;의 가변 차원은 읽기 전용이므로 설정할 수 없음</entry>
    <entry key="RTI_SparseMatrixNotSupported">''{0}''에 사용된 블록 런타임 인터페이스는 MATLAB 희소 행렬을 지원하지 않음</entry>
    <entry key="RTI_WRITE_TO_BUS_NOT_SUPPORTED">''{0}''의 런타임 객체를 사용하여 데이터를 Bus 객체에 쓸 수 없음</entry>
    <entry key="RTWBoolsToBitsWithStructAlignment">Booleans may not be packed to bitfields when using a target that specifies an explicit structure alignment.  Turn off the option ''Pack Boolean data into bitfields'' in the Configuration Parameters dialog box.</entry>
    <entry key="RTWCSCStructureFieldIdConflict">A Custom Storage Class Structure Field ''{0}'' conflicts with a programming reserved identifier.</entry>
    <entry key="RTWCSCStructureMacroIdConflict">A Custom Storage Class Structure Field ''{0}'' conflicts with another Custom Storage Class Macro specification</entry>
    <entry key="RTWBusElementNameReservedIdConflictCSC">Unable to generate code using bus object ''{0}'' because it has an element named ''{1}'' which conflicts with a Parameter with Custom Storage Macro specification</entry>
    <entry key="RTWDataTypeNameReservedIdConflictCSC">사용자 정의 데이터형 ''{0}''이(가) 사용자 지정 저장공간 매크로 사양을 갖는 ''{1}'' 파라미터와 충돌하기 때문에 이 데이터형을 사용하여 코드를 생성할 수 없음</entry>
    <entry key="RTWCSCStructFieldIdConflictEnum">Unable to generate code using user-defined data type ''{0}'' because it has an element ''{1}'' that conflicts Custom Storage Structure specification</entry>
    <entry key="RTWBusElementNameReservedIdConflict">Unable to generate code using bus object ''{0}'' because it has an element named ''{1}'' which conflicts with a programming language reserved identifier.</entry>
    <entry key="RTWBusElementNameAliasConflict">별칭 유형의 이름과 충돌하는 ''{1}''(이)라는 이름의 요소가 Bus 객체 ''{0}''에 있기 때문에 이 객체를 사용하여 코드를 생성할 수 없습니다.</entry>
    <entry key="RTWCGAutosarEmptyConfigurationError">AUTOSAR 모델 ''{0}''이(가) AUTOSAR 소프트웨어 컴포넌트에 매핑되지 않았습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion" btn="open" id="launchWizard" retvalue="false"&gt; &lt;cmd&gt;autosar.ui.app.quickstart.WizardManager.wizard(''{0}'');&lt;/cmd&gt; &lt;txt&gt;"AUTOSAR Component Quick Start"를 사용하여 모델을 AUTOSAR 소프트웨어 컴포넌트에 매핑하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="RTWCGAutosarEmptySSConfigurationError">서브시스템 ''{0}''에 대한 코드를 생성할 때 AUTOSAR 타깃을 사용하려 하고 있습니다. 그러나 서브시스템에 적절한 AUTOSAR 인터페이스가 구성되어 있지 않습니다. 서브시스템에 대한 AUTOSAR 인터페이스를 지정하려면 서브시스템을 모델로 변환한 다음 모델을 구성하십시오.</entry>
    <entry key="RTWCGAutosarValidateError">Error during the validation of AUTOSAR configuration: {0}</entry>
    <entry key="RTWCGAutosarConditionalImplicitWrite">출력 포트 블록 ''{0}''의 현재 구성은 정의되지 않은 동작을 갖는 조건부 묵시적 쓰기를 야기합니다. 데이터 액세스 모드를 ExplicitSend로 변경하거나, 모델의 기본 샘플 시간과 일치하도록 샘플 시간을 변경하십시오.</entry>
    <entry key="RTWCGAutosarMergedIRVConditionalWrite">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;는 Merge 블록 ''{2}''에 조건부로 쓸 수 있습니다. 이 블록에는 러너블로 내보내지는 여러 개의 Function-Call Subsystem에 의해 쓰여집니다. 이 모델링 패턴은 일관된 동작을 보장하기 위해 &lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;과소 지정된 초기화 감지&lt;/sldiag&gt;가 '단순 방식'으로 설정되지 않는 한 AUTOSAR 타깃에서 지원되지 않습니다. 결과적으로, 생성 코드의 동작이 시뮬레이션과 일치하지 않을 수 있습니다. 크거나 복잡한 모델의 경우, 모델 어드바이저 검사 ''Outport 및 Merge 블록 초기화 파라미터의 일관성 검사''를 사용하면 이 태스크에 도움이 됩니다. 이 조건의 보고를 제어하려면 &lt;sldiag objui="configset" objparam="ModelReferenceIOMsg"&gt;유효하지 않은 루트 Inport/Outport 블록 연결&lt;/sldiag&gt;을 사용하십시오.</entry>
    <entry key="RTWCGAutosarInvalidIRVSSLoopback">서브시스템 ''{0}''의 포트 ''{1}''에서의 신호 출력은 AUTOSAR IRV입니다. IRV 신호를 다시 서브시스템 ''{0}''에 보내면 생성 코드에서 초기화되지 않은 변수에 액세스하게 될 수 있습니다.</entry>
    <entry key="RTWCGAutosarNvmRwInvReadBlockArgSpec">Function Caller 블록 ''{0}''이(가) ReadBlock 또는 RestoreBlockDefaults AUTOSAR 비휘발성 메모리 서비스 작업에 매핑되었습니다. 이러한 작업에는 입력 인수가 하나만 필요합니다. 출력을 Data Store Write 블록에 연결하고 이 데이터 저장소 메모리 포트를 입력 인수에 매핑하여 작업에 바로 전달하십시오.</entry>
    <entry key="RTWCGAutosarNvmRwInvWriteBlockArgSpec">Function Caller 블록 ''{0}''이(가) WriteBlock AUTOSAR 비휘발성 메모리 서비스 작업에 매핑되었습니다. 이 작업에는 입력 인수가 하나만 필요합니다. 입력을 Data Store Read 블록에 바로 연결하고 이 데이터 저장소 메모리 포트를 입력 인수에 매핑하여 작업에 바로 전달하십시오.</entry>
    <entry key="RTWCGAutosarNvmRwInvReadBlockInoutArg">Function Caller 블록 ''{0}''이(가) ReadBlock 또는 RestoreBlockDefaults AUTOSAR 비휘발성 메모리 서비스 작업에 매핑되었습니다. &lt;sldiag objui="outport" objparam="{1}" objname="{0}"&gt;출력 포트 {1}&lt;/sldiag&gt;은(는) 입력-출력 인수로 지정할 수 없습니다.</entry>
    <entry key="RTWCGAutosarNvmRwInvWriteBlockInoutArg">Function Caller 블록 ''{0}''이(가) WriteBlock AUTOSAR 비휘발성 메모리 서비스 작업에 매핑되었습니다. 데이터 저장소 메모리 입력 포트는 입력-출력 인수로 지정할 수 없습니다.</entry>
    <entry key="RTWCGAutosarNvmRwUnsupportedWriteBlockSrc">Function Caller block ''{0}'' is mapped to the WriteBlock AUTOSAR non-volatile memory service operation. Connect the input directly to a Data Store Read block to pass the data store memory directly to the operation. Configure the Data Store Read block to execute at the same time step and remove any element assignment specifications. Verify that the Function Caller block immediately follows the Data Store Read block in execution order.</entry>
    <entry key="RTWCGAutosarNvmRwUnsupportedReadBlockDst">Function Caller block ''{0}'' is mapped to the ReadBlock or RestoreBlockDefaults AUTOSAR non-volatile memory service operation. &lt;sldiag objui="outport" objparam="{1}" objname="{0}"&gt;Output port {1}&lt;/sldiag&gt; can only be connected to a Data Store Write block to pass the data store memory directly to the operation. Configure the Data Store Write block to execute at the same time step and remove any element assignment specifications. Verify that the Data Store Write block immediately follows the Function Caller block in execution order.</entry>
    <entry key="RTWCGAutosarNvmRwUnsupportedReadBlockTestpointSignal">Function Caller 블록 ''{0}''이(가) ReadBlock 또는 RestoreBlockDefaults AUTOSAR 비휘발성 메모리 서비스 작업에 매핑되었습니다. &lt;sldiag objui="outport" objparam="{1}" objname="{0}"&gt;출력 포트 {1}&lt;/sldiag&gt;에 연결된 신호는 생성 코드에서 테스트 지점으로 지정할 수 없습니다. 데이터 저장소 메모리가 AUTOSAR 타깃에 대한 생성 코드의 작업에 바로 전달되기 때문입니다.</entry>
    <entry key="RTWCGAutosarNvmRwUnsupportedReadBlockNonvirtualSignal">Function Caller 블록 ''{0}''이(가) ReadBlock 또는 RestoreBlockDefaults AUTOSAR 비휘발성 메모리 서비스 작업에 매핑되었습니다. &lt;sldiag objui="outport" objparam="{1}" objname="{0}"&gt;출력 포트 {1}&lt;/sldiag&gt;에 연결된 신호에 대해 신호 이름을 지정할 수 없습니다. 데이터 저장소 메모리가 AUTOSAR 타깃에 대한 생성 코드의 작업에 바로 전달되기 때문입니다.</entry>
    <entry key="RTWCGAutosarNvmRwValidationFailure">Function Caller 블록 ''{0}''이(가) WriteBlock, ReadBlock 또는 RestoreBlockDefaults AUTOSAR 비휘발성 메모리 서비스 작업에 매핑되었습니다. 코드 생성기가 데이터 저장소 메모리를 작업에 바로 전달할 수 없습니다.</entry>
    <entry key="RTWCGAutosarNvmRwUnaddressableDstore">Function Caller 블록 ''{0}''이(가) WriteBlock, ReadBlock 또는 RestoreBlockDefaults AUTOSAR 비휘발성 메모리 서비스 작업에 매핑되었습니다. 데이터 저장소 메모리 신호를 작업에 바로 전달하려면 해당 신호의 주소화가 가능해야 합니다. 예를 들어, AUTOSAR.Signal 객체를 생성하여 데이터 저장소 메모리를 지정할 수 있습니다.</entry>
    <entry key="RTWCGCPPClassGenStr">C++ 클래스 인터페이스</entry>
    <entry key="RTWCGCPPClassGenValidateError">모델 ''{0}''에 대한 C++ 클래스 인터페이스 사양의 유효성을 검사하는 중 오류가 발생함: {1}</entry>
    <entry key="RTWCGCPPClassMdlRefContStates">모델 ''{0}''에 연속시간을 사용하는 블록이 포함되어 있으므로 이 모델에 대해 코드 인터페이스 패키징 옵션 ''C++ 클래스''를 선택할 수 없습니다. 이러한 선택은 모델 참조 타깃에 대한 코드를 생성할 때 지원되지 않습니다</entry>
    <entry key="RTWCGCPPClassMdlRefVoidStyleNotSupported">참조된 모델로 사용되는 모델 ''{0}''에는 ''I/O 인수 스텝 메서드'' 스타일의 C++ 클래스 인터페이스만 지원됩니다.</entry>
    <entry key="RTWCGCPPClassSetNotAllowed">비ERT 기반 타깃에는 C++ 클래스 인터페이스 사용자 지정이 허용되지 않음</entry>
    <entry key="RTWCGCPPClassIOMessagePort">모델 ''{0}''이(가) 메시지를 보내거나 받도록 구성된 경우 ''I/O 인수 스텝 메서드'' 유형의 ''함수 사양''은 지원되지 않습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion" btn="apply"&gt; &lt;cmd&gt;set_param(''{0}'', ''RTWCPPFcnClass'', RTW.ModelCPPDefaultClass); get_param(''{0}'',''RTWCPPFcnClass'').setStepMethodName(''Step''); get_param(''{0}'',''RTWCPPFcnClass'').setClassName(''{0}ModelClass'');&lt;/cmd&gt; &lt;txt&gt;''함수 사양''의 설정을 ''디폴트 스텝 메서드''로 변경하십시오(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음).&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="RTWCGCPPMdlRefInstanceVariables">C++ 클래스 생성의 I/O 인수 스텝 메서드에 대해 모델 참조 인스턴스 변수를 읽어오는 중 오류가 발생함</entry>
    <entry key="RTWCGEmptyCPPEncapConfigurationError">Model ''{0}'' has code interface packaging set to ''C++ class'', but a C++ class interface configuration is not specified for the model.
    
             &lt;actions exclusiveFixIts="yes"&gt;
             &lt;action type="suggestion"&gt;
             &lt;cmd&gt;simulinkcoder.internal.slfpc.FunctionControlDialogManager.openEntryFcnDialog(''{0}'')&lt;/cmd&gt;
             &lt;txt&gt;Specify a C++ class interface&lt;/txt&gt;
             &lt;/action&gt;
             &lt;/actions&gt;
    </entry>
    <entry key="RTWCGFcnProtoCtlMdlRefOutUpdCombined">Model function prototype control cannot be used for ''{0}'' because it does not combine its output and update functions when generating code for model reference targets
      
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="suggestion" id="FPCMdlRefOutUpdCombined"&gt;
            &lt;cmd&gt;simulinkcoder.internal.slfpc.FunctionControlDialogManager.openEntryFcnDialog(''{0}'')&lt;/cmd&gt;
            &lt;txt&gt;Fix preceding errors or clear checkbox for ''Configure arguments for Step function prototype''&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="RTWCGFcnProtoCtlMdlRefVirtualBusRootIO">Model function prototype
    control cannot be used for ''{0}'' because it is a referenced model
    with a virtual bus at root I/O port ''{1}''.
      
        &lt;actions exclusiveFixIts="yes"&gt;
            &lt;action type="suggestion" id="FPCMdlRefVirtualBusRootIO"&gt;
                &lt;cmd&gt;simulinkcoder.internal.slfpc.FunctionControlDialogManager.openEntryFcnDialog(''{0}'')&lt;/cmd&gt;
                &lt;txt&gt;Fix preceding errors or clear checkbox for ''Configure arguments for Step function prototype''&lt;/txt&gt;
            &lt;/action&gt;
            &lt;action type="suggestion"&gt;
                &lt;cmd&gt;Simulink.internal.OpenBlockParamsDialog(''{1}'',''BusOutputAsStruct'')&lt;/cmd&gt;
                &lt;txt&gt;Select ''Output as nonvirtual bus''&lt;/txt&gt;
            &lt;/action&gt;
      &lt;/actions&gt;
   </entry>
    <entry key="RTWCGFcnProtoCtlIOMessagePort">Model function prototype
    control cannot be used for ''{0}'' because it has
    a root I/O port that sends or receives messages.
    
             &lt;actions exclusiveFixIts="yes"&gt;
             &lt;action type="fixit" id="MessageIOFPC" retvalue="false"&gt;
             &lt;cmd&gt;simulinkcoder.internal.slfpc.FunctionControlDialogManager.openEntryFcnDialog(''{0}'', Simulink.CodeMapping.get(''{0}'', ''CoderDictionary'').OutputFunctionMappings(1), ''OutputFunctionMappings'')&lt;/cmd&gt;
             &lt;txt&gt;Fix preceding errors or clear checkbox for ''Configure arguments for Step function prototype''&lt;/txt&gt;
             &lt;/action&gt;
             &lt;/actions&gt;
    </entry>
    <entry key="RTWCGFcnProtoCtlMdlRefVirtualBusRootIOBEP">Model function prototype
    control cannot be used for ''{0}'' because it is a referenced model
    with a virtual bus at root I/O port ''{1}''.
      
        &lt;actions exclusiveFixIts="yes"&gt;
            &lt;action type="suggestion" id="FPCMdlRefVirtualBusRootIOBEP"&gt;
                &lt;cmd&gt;simulinkcoder.internal.slfpc.FunctionControlDialogManager.openEntryFcnDialog(''{0}'')&lt;/cmd&gt;
                &lt;txt&gt;Fix preceding errors or clear checkbox for ''Configure arguments for Step function prototype''&lt;/txt&gt;
            &lt;/action&gt;
      &lt;/actions&gt;
   </entry>
    <entry key="RTWCGCPPClassMdlRefVirtualBusRootIO">Configuration of referenced
    model ''{0}'' does not support using a virtual bus at root I/O port ''{1}''.
    &lt;actions exclusiveFixIts="yes"&gt;
    &lt;action type="suggestion"&gt;
    &lt;cmd&gt;Simulink.internal.OpenBlockParamsDialog(''{1}'',''BusOutputAsStruct'')&lt;/cmd&gt;
    &lt;txt&gt;Select ''Output as nonvirtual bus''&lt;/txt&gt;
    &lt;/action&gt;
    &lt;action type="suggestion"&gt;
    &lt;cmd&gt;configset.internal.open(''{0}'',''CodeInterfacePackaging'')&lt;/cmd&gt;
    &lt;txt&gt;Change the setting of ''Code interface packaging'' (might impact referenced or referencing models)&lt;/txt&gt;
    &lt;/action&gt;
    &lt;action type="suggestion"&gt;
    &lt;cmd&gt;simulinkcoder.internal.slfpc.FunctionControlDialogManager.openEntryFcnDialog(''{0}'')&lt;/cmd&gt;
    &lt;txt&gt;Change the setting of ''Function specification'' to ''Default step method''.&lt;/txt&gt;
    &lt;/action&gt;
    &lt;/actions&gt;
    
    </entry>
    <entry key="RTWCGFcnProtoCtlValidateError">''{0}''에 대한 모델 함수 프로토타입의 유효성을 검사하는 중 오류가 발생함: {1} &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion" id="FPCValidateError"&gt; &lt;cmd&gt;simulinkcoder.internal.slfpc.FunctionControlDialogManager.openEntryFcnDialog(''{0}'')&lt;/cmd&gt; &lt;txt&gt;이전 오류를 수정하거나 ''Configure arguments for Step function prototype'' 체크박스의 선택을 해제하십시오&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="RTWCGArchSpecValidateError">모델 ''{0}''에 대해 {2}을(를) 확인하는 중 오류가 발생했습니다. 참조된 모델 ''{1}''은(는) C-API 인터페이스를 생성했으며 이 모델의 루트 인포트에 연결하는 신호 중 하나가 테스트 지점 특성을 설정했습니다. 그러나 이 구성 조합은 해당 기능에 대해 지원되지 않습니다. 이러한 조합을 사용하지 않는 방법으로 오류를 해결하거나, 테스트 지점 신호를 야기한 참조된 모델의 루트 인포트에 Signal Conversion을 삽입해 보십시오.</entry>
    <entry key="RTWCGInternalError">Error during code generation: {0}</entry>
    <entry key="RTWCGInvalidDTReasonUnknownInternal">코드 생성 시 블록 ''{0}''에는 데이터형 ''{1}''이(가) 지원되지 않습니다.</entry>
    <entry key="RTWCGInvalidDTSize">Code cannot be generated for this model because block ''{0}'' is using the data type ''{1}'' which requires {2,number,integer} bits, but the maximum supported by the block for code generation is {3,number,integer}</entry>
    <entry key="RTWCGInvalidDTSize2Internal">이 모델에 대한 코드를 생성할 수 없습니다. 블록 ''{0}''에서 {2,number,integer}비트가 필요한 데이터형 ''{1}''을(를) 사용하지만 코드 생성에 지원되는 최댓값이 {3,number,integer}이기 때문입니다. 입력 신호, 출력 신호, 런타임 파라미터 및 dwork 상태에 지원되지 않는 데이터형을 사용할 경우 대개 코드 생성 프로세스 초기에 오류가 발생합니다. 이 오류는 후반 단계에서 발생했습니다. 따라서 지원되지 않는 데이터형이 블록 내부의 지역 변수에 사용되었을 가능성이 높습니다. 지역 변수에는 중간 계산 결과가 들어 있을 수 있습니다. 중간 계산을 보관하기 위해 선택되는 데이터형과 스케일링은 모델의 테스트 하드웨어에 따라 다를 수 있습니다. 테스트 하드웨어가 long 데이터형 비트 수를 32보다 크도록 지정할 수 있습니다. 테스트 하드웨어를 구성하려면 구성 파라미터 대화 상자에서 ''테스트 하드웨어''를 검색하십시오.</entry>
    <entry key="RTWCGInvalidTargetLongSize">코드를 생성할 수 없습니다. ''테스트 하드웨어의 long 데이터형 비트 수''({0,number,integer})가 32보다 크거나 같아야 합니다.</entry>
    <entry key="RTWCGModelReferenceStackSizeConflict">''{2}''에서 참조하는 모델 ''{1}''에 대해 추정된 필수 스택 크기 {0,number,integer}바이트가 ''{4}''의 구성 파라미터 대화 상자에서 "최대 스택 크기" 파라미터로 지정된 최대 스택 크기 {3,number,integer}바이트를 초과합니다. 이 충돌을 해결하려면 최대 스택 크기를 {6,number,integer}바이트보다 크거나 같은 값으로 높여 ''{5}''의 "최대 스택 크기" 파라미터를 수정하거나 ''{7}''을(를) 선택하십시오. 모델 ''{9}''의 구성 파라미터 대화 상자에서 "최대 스택 크기" 파라미터를 {8,number,integer}바이트(또는 그 이하)로 지정하여 해결할 수도 있습니다.</entry>
    <entry key="RTWCGTargetStackSizeConflict">모델 ''{0}''에는 ''최대 스택 크기(바이트)''가 {1,number,integer}바이트로 지정되어 있습니다. 그러나 현재 시스템 타깃에는 최대 스택 크기가 {2,number,integer}바이트 이하여야 합니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''MaxStackSize'')&lt;/cmd&gt; &lt;txt&gt;''최대 스택 크기(바이트)''를 {3,number,integer}(또는 그 이하) 또는 문자열 ''{4}''(으)로 변경&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;현재 시스템 타깃의 최대 스택 크기 값 증가(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음)&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="SLCGStackSizeAndGlobalDataAccessConflict">'최대 스택 크기'가 '0'으로 설정되어 있으므로 '전역 데이터 액세스 최적화'를 '전역 데이터 액세스 최소화로' 설정할 수 없습니다.</entry>
    <entry key="RTWCGMissingCSCRegistration">Embedded Coder 사전에 스토리지 클래스 ''{0}''이(가) 정의되지 않았습니다. 해당 사전에 스토리지 클래스를 정의하거나, 해당 사전에 사용되는 패키지에서 코드 정의를 변경한 경우 명령 refreshPackage(coder.dictionary.open(''{1}''))을(를) 사용하여 패키지를 다시 불러오십시오.</entry>
    <entry key="RTWCGReusableCSCMultipleEndpoints">The Reusable CSC ''{0}'' at the &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{1}"&gt;outport port {2,number,integer}&lt;/sldiag&gt; of ''{1}'' is not a unique endpoint.  An endpoint is a usage of a Reusable CSC with no other downstream.  The runtime environment should not read this variable because its value is not well defined.</entry>
    <entry key="RTWCGReusableCSCNotRenamable">재사용 가능한 버퍼 지정 문제: ''{0}''의 출력 포트는 재사용 및 이름 변경이 가능하지 않습니다.</entry>
    <entry key="RTWCGReusableCSCNotInTheSameNonVirtualSS">Reusable buffer specification problem: the reusable CSC at the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is not in the same non-virtual subsystem as the other reusable CSC.</entry>
    <entry key="RTWCGReusableCSCNotOnAContinuousPath">Reusable buffer specification problem: the reusable CSC at the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is not on a continuous path with the other reusable CSC; or the compilation of the model introduced new blocks that make the Reusable CSC specification discontinuous.</entry>
    <entry key="RTWCGReusableCSCMultipleOutputs">동일한 재사용 가능 CSC ''{0}''이(가) 블록 ''{3}''의 {1,number,integer}번과 {2,number,integer}번 출력 포트에 지정되었습니다. 동일한 블록의 둘 이상 출력에 재사용 가능 CSC를 동일하게 지정할 수 없습니다.</entry>
    <entry key="RTWCGReusableCSCMultipleInputs">동일한 재사용 가능 CSC ''{0}''이(가) 블록 ''{3}''의 {1,number,integer}번과 {2,number,integer}번 입력 포트에 지정되었습니다. 동일한 블록의 둘 이상 입력에 재사용 가능 CSC를 동일하게 지정할 수 없습니다.</entry>
    <entry key="RTWCGReusableCSCHasNoBuffer">The Reusable CSC specified on the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is invalid because there is no corresponding variable for this signal in the generated code. This could be because the subsystem's Output Port block is not connected.</entry>
    <entry key="RTWCGReusableCSCOutputCannotOverwriteInput">재사용 가능 버퍼 지정 문제: ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;는 ''{3}''의 &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 출력 포트&lt;/sldiag&gt;를 덮어쓸 수 없습니다.</entry>
    <entry key="RTWCGReusableCSCDataTypesMismatch">Reusable buffer specification problem: the data type/shape of the signal connected to the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' does not match with the data type/shape of the signal connected to the &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;output port {2,number,integer}&lt;/sldiag&gt; of ''{3}''.</entry>
    <entry key="RTWCGReusableCSCMappingsCodePropertiesMismatch">''{4}''의 재사용 가능 버퍼 지정 문제: ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호에 대한 코드 퍼스펙티브의 코드 생성 속성이 ''{3}''의 &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호와 일치하지 않습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;신호에 대해 동일한 속성 ''DataScope'', ''HeaderFile'', ''DefinitionFile'' 및 ''Owner''를 지정하십시오&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;이 메시지를 표시하지 않으려면 &lt;sldiag objui="configset" objparam="RCSCRenamedMsg"&gt;재사용되지 않은 사용자 지정 스토리지 클래스 감지&lt;/sldiag&gt;를 ''안 함''으로 설정하십시오&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="RTWCGReusableFPCDataTypesMismatch">Function prototype control problem: the data type/shape of the non-virtual signal connected to the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' does not match with the data type/shape of the non-virtual signal connected to the &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;input port {2,number,integer}&lt;/sldiag&gt; of ''{3}''.</entry>
    <entry key="RTWCGReusableCSCRootMustBeSameSize">The reusable custom storage class ''{0}'' is on a signal line that connect to the root Inport block ''{1}'' and the root Outport block that connects to ''{2}'' port ''{3,number,integer}''. The root ports have different sizes.</entry>
    <entry key="RTWCGReusableCSCVariantMismatch">All signals with the same reusable storage class specification must have the same variant condition.  The signal connected to the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' does not have the same variant condition as the signal connected to the &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;output port {2,number,integer}&lt;/sldiag&gt; of ''{3}''.</entry>
    <entry key="RTWCGReusableModelReferenceTarget">재사용 가능 CSC 지정 문제: Model 블록 내에는 재사용 가능 CSC를 지정할 수 없습니다. 이러한 한 가지 경우가 {1}의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에서 발견되었습니다.</entry>
    <entry key="RTWCGReusableModelReferenceInputNotOutput">Reusable CSC specification is specified on &lt;sldiag objui="inport" objparam="{0}" objname="{1}"&gt;inport {0}&lt;/sldiag&gt; and internally on block ''{1}''.  This is not allowed for model reference unless the specification is also on an outport as well.</entry>
    <entry key="RTWCGReusableCSCDifferentSampleTimesInMultiTaskingMode">Reusable buffer specification problem: the signal connected to the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' and the signal connected to the &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;output port {2,number,integer}&lt;/sldiag&gt; of ''{3}'' have different rates in the multi-tasking solver mode. This is not supported.</entry>
    <entry key="RTWCGReusableFPCDifferentSampleTimesInMultiTaskingMode">함수 프로토타입 제어 문제: ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호와 ''{3}''의 &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호의 레이트가 멀티태스킹 솔버 모드에서 서로 다릅니다. 이는 지원되지 않습니다.</entry>
    <entry key="RTWCGReusableCSCDifferentSampleTimes">Reusable buffer specification problem: the signal connected to the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' and the signal connected to the &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;output port {2,number,integer}&lt;/sldiag&gt; of ''{3}'' have different rates. This is not supported.</entry>
    <entry key="RTWCGReusableFPCDifferentSampleTimes">Function prototype control problem: the signal connected to the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' and the signal connected to the &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;output port {2,number,integer}&lt;/sldiag&gt; of ''{3}'' have different rates. This is not supported.</entry>
    <entry key="RTWCGReusableCSCRootIOCannotReuseState">Reusable CSC specification problem: the state in the unit delay block ''{0}'' cannot reuse the root IO.</entry>
    <entry key="RTWCGReusableCSCStateProblem">블록 ''{0}''의 상태는 현재 모델 설정을 갖는 재사용 가능한 사용자 지정 스토리지 클래스로 지정할 수 없습니다.</entry>
    <entry key="RTWCGReusableCSCStateWithPackedBool">데이터형이 부울이고 &lt;sldiag objui="configset" objparam="BooleansAsBitfields"&gt;부울 데이터를 비트 필드로 패킹&lt;/sldiag&gt;이 [켜기[로 설정된 경우 블록 ''{0}''의 상태를 재사용 가능한 사용자 지정 스토리지 클래스로 지정할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''BooleansAsBitfields'',''off'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="BooleansAsBitfields"&gt;부울 데이터를 비트 필드로 패킹&lt;/sldiag&gt;을 [끄기]로 설정&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;''{0}''에서 재사용 가능 CSC 지정 제거&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="RTWCGReusableCSCStateWithStateRW">블록 ''{0}''의 상태가 State Read 블록 또는 State Write 블록과 호환되지 않는 재사용 가능한 사용자 지정 스토리지 클래스를 사용합니다.</entry>
    <entry key="RTWCGReusableCSCStateNotERT">블록 ''{0}''의 상태가 모델의 시스템 타깃 파일을 ert.tlc로 설정해야 하는 재사용 가능한 사용자 지정 스토리지 클래스를 사용합니다.</entry>
    <entry key="RTWCGReusableCSCStateNeedLocalReuse">블록 ''{0}''의 상태가 &lt;sldiag objui="configset" objparam="LocalBlockOutputs"&gt;로컬 블록 출력&lt;/sldiag&gt; 파라미터와 &lt;sldiag objui="configset" objparam="BufferReuse"&gt;로컬 블록 출력 재사용&lt;/sldiag&gt; 파라미터를 [켜기]로 설정해야 하는 사용자 지정 스토리지 클래스 지정을 사용합니다.</entry>
    <entry key="RTWCGReusableCSCStateWithSLCI">&lt;sldiag objui="configset" objparam="AdvancedOptControl"&gt;AdvancedOptControl&lt;/sldiag&gt; 파라미터가 활성화된 경우 블록 ''{0}''의 상태가 재사용 가능한 사용자 지정 스토리지 클래스를 사용할 수 없습니다. 그러한 상태에 지정된 재사용 가능한 스토리지 클래스가 Simulink Code Inspector와 호환되지 않기 때문입니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''AdvancedOptControl'','''')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="AdvancedOptControl"&gt;AdvancedOptControl&lt;/sldiag&gt;을 [끄기]로 설정&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="RTWCGReusableCSCStateMustUseItsIO">Reusable CSC specification problem: the state in the unit delay block ''{0}'' is supported to merge with only its IO buffers.</entry>
    <entry key="RTWCGReusableCSCPairsCannotReuseStates">재사용 가능 CSC 지정 문제: ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;가 모델 경계에서 다른 신호를 재사용하며 Unit Delay 블록 ''{2}''의 상태를 재사용할 수 없습니다.</entry>
    <entry key="RTWCGReusableCSCStateCannotUseBackPropedSig">재사용 가능 CSC 지정 문제: Unit Delay 블록 ''{0}''의 상태가 모델에서 전파된 재사용 가능 CSC를 사용할 수 없습니다.</entry>
    <entry key="RTWCGReusableCSCAtMultipleInputs">The same reusable custom storage class specification is at multiple root inports: ''{0}'' and ''{1}''. This is not allowed.</entry>
    <entry key="RTWCGReusableCSCAtMultipleOutputs">The same reusable custom storage class specification is at multiple root outports:  the root outport connected to port {0,number,integer} of ''{1}'' and the root outport connected to port {2,number,integer} of ''{3}''. This is not allowed.</entry>
    <entry key="RTWCGReusableCSCAtMultipleOutputsOfABlock">Reusable CSC specification problem: the same specification is found at multiple outputs: the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' and the &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;output port {2,number,integer}&lt;/sldiag&gt; of ''{3}''. This is not allowed.</entry>
    <entry key="RTWCGReusableCSCAtMultipleInputsOfABlock">Reusable CSC specification problem: the same specification is found at multiple inputs: the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' and the &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;output port {2,number,integer}&lt;/sldiag&gt; of ''{3}''. This is not allowed.</entry>
    <entry key="RTWCGReusableCSCSignalsNotAtModelBoundary">Reusable CSC specification problem: the duplicate specification is supported only for root IO signals or at block boundary; if one reusable CSC is at root IO ports, the other one must also be at root IO ports. In this case, either of the signal connected to the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' or the signal connected to the &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;output port {2,number,integer}&lt;/sldiag&gt; of ''{3}'' or both do not satisfy the specification.</entry>
    <entry key="RTWCGReusableCSCSignalsCannotBeInClassicMode">재사용 가능 CSC 지정 문제: 중복 지정은 단순 방식 초기화 모드에 있는 모델 IO 신호에 대해서만 지원됩니다. 이 경우 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호 또는 ''{3}''의 &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호 중 하나 또는 두 개 모두가 모델 IO 포트에 있습니다.</entry>
    <entry key="RTWCGReusableFPCMdlRefCannotRequireGlobalAccess">FPC IO 재사용 지정 문제: IO 포트 ''{0}''은(는) 모델 참조 빌드의 전역 액세스를 요구할 수 없습니다.</entry>
    <entry key="RTWCGReusableCSCSignalsLiferangeOverlapped">Reusable CSC specification problem: the signal connected to the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' and the signal connected to the &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;output port {2,number,integer}&lt;/sldiag&gt; of ''{3}'' are not reusable, because their life ranges could be overlapped.</entry>
    <entry key="RTWCGReusableCSCBlockORenamed">The &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of block ''{1}'' can not reuse with some other usages of the Reusable CSC ''{2}''.  In most cases this will result in an additional buffer in the generated code.</entry>
    <entry key="RTWCGReusableCSCDworkRenamed">''{0}''의 상태는 다른 재사용 가능 CSC ''{1}''을(를) 사용하면서 함께 재사용할 수 없습니다. 대부분의 경우, 재사용하면 생성 코드에서 추가 버퍼가 발생합니다.</entry>
    <entry key="RTWCGReusableCSCSignalsMustBeAtTheSameModel">재사용 가능 CSC 지정 문제: 중복 지정은 동일한 모델의 모델 IO 신호에 대해서만 지원됩니다. 이 경우 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호가 다른 모델에 정의되어 있습니다.</entry>
    <entry key="RTWCGReusableCSCSignalsInTwoModels">Identical Reusable custom storage class signal ''{0}'' is specified on root ports of the Model blocks ''{1}'' and ''{2}''.  This is not supported unless &lt;sldiag objui="configset" objparam="RCSCRenamedMsg"&gt;RCSCRenamedMsg&lt;/sldiag&gt; is set to ''error''.
    &lt;actions exclusiveFixIts="no"&gt;
    &lt;action type="suggestion"&gt;
    &lt;txt&gt;Set &lt;sldiag objui="configset" objparam="RCSCRenamedMsg"&gt;RCSCRenamedMsg&lt;/sldiag&gt; to ''error''&lt;/txt&gt;
    &lt;/action&gt;
    &lt;action type="suggestion"&gt;
    &lt;txt&gt;To avoid build failures, change the RCSCRenamedMsg parameter for all child models to ''error'', or use &lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''], ''configuration_reference_dialog'')"&gt;Configuration References&lt;/a&gt;.&lt;/txt&gt;
    &lt;/action&gt;
    &lt;/actions&gt;
    </entry>
    <entry key="RTWCGReusableCSCSignalsInModelAndBlock">Identical Reusable custom storage class signal ''{0}'' is specified on a root port of the Model block ''{1}'' and also on the &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;output port {2,number,integer}&lt;/sldiag&gt; of block ''{3}''.  This is not supported unless &lt;sldiag objui="configset" objparam="RCSCRenamedMsg"&gt;RCSCRenamedMsg&lt;/sldiag&gt; is set to ''error''.
    &lt;actions exclusiveFixIts="no"&gt;
    &lt;action type="suggestion"&gt;
    &lt;txt&gt;Set &lt;sldiag objui="configset" objparam="RCSCRenamedMsg"&gt;RCSCRenamedMsg&lt;/sldiag&gt; to ''error''&lt;/txt&gt;
    &lt;/action&gt;
    &lt;action type="suggestion"&gt;
    &lt;txt&gt;To avoid build failures, change the RCSCRenamedMsg parameter for all child models to ''error'', or use &lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''], ''configuration_reference_dialog'')"&gt;Configuration References&lt;/a&gt;.&lt;/txt&gt;
    &lt;/action&gt;
    &lt;/actions&gt;
    </entry>
    <entry key="RTWCGReusableCSCSignalAtModelBoundMustHaveSingleUse">재사용 가능 CSC 지정 문제: ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호를 여러 개의 블록에 연결할 수 없습니다.</entry>
    <entry key="RTWCGReusableCSCSignalsCannotBeInsideModelBlock">재사용 가능 CSC 지정 문제: 참조된 모델 내에 재사용 가능 CSC를 사용할 수 없습니다. 이 경우 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호 또는 ''{3}''의 &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호 중 하나 또는 두 개 모두가 참조된 모델에 있습니다.</entry>
    <entry key="RTWCGReusableCSCCannotBeUsedByMultipleStates">Reusable CSC specification problem: multiple unit delay states cannot use the same reusable CSC. In this case, both ''{0}'' and ''{1}'' use the same reusable CSC.</entry>
    <entry key="RTWCGReusableCSCInterceptingOutputHiddenBuffer1">재사용 가능 CSC 지정 문제: ''{1}'' 의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 내부 버퍼가 있습니다.</entry>
    <entry key="RTWCGReusableCSCInterceptingOutputHiddenBuffer">재사용 가능 CSC 지정 문제: 중복 지정은 모델 또는 루트 IO 신호에 대해서만 지원됩니다. 이 경우 입력 포트 ''{0}''에 연결된 신호 또는 ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호 중 하나 또는 두 개 모두가 모델 또는 루트 IO 포트에 없습니다. 이유: ''{4}''의 &lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;{3,number,integer}번 출력 포트&lt;/sldiag&gt;에 내부 버퍼가 있습니다.</entry>
    <entry key="RTWCGReusableCSCInterceptingInputHiddenBuffer">재사용 가능 CSC 지정 문제: 중복 지정은 모델 또는 루트 IO 신호에 대해서만 지원됩니다. 이 경우 입력 포트 ''{0}''에 연결된 신호 또는 ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호 중 하나 또는 두 개 모두가 모델 또는 루트 IO 포트에 없습니다. 이유: 입력 포트 ''{3}''에 내부 버퍼가 있습니다.</entry>
    <entry key="RTWCGReusableCSCInputMustBeDirectFeedThrough">재사용 가능 CSC 지정 문제: ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;가 직접 피드스루여야 합니다.</entry>
    <entry key="RTWCGReusableCSCOutputCannotBeInDifferentRate">Reusable buffer specification problem: the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is running at a sample rate slower than the model's base rate, which might leave the outport conditionally assigned. Consider not to reuse the outport.</entry>
    <entry key="RTWCGReusableCSCOutputCannotBeConditional">Reusable buffer specification problem: the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' cannot be conditional.</entry>
    <entry key="RTWCGReusableCSCMultipleSource">Reusable buffer specification problem: the output port ''{0}'' is not driven by a single data source.</entry>
    <entry key="RTWCGReusableCSCInterceptingHiddenBufferAtModelBound">재사용 가능 CSC 지정 문제: 중복 지정은 루트 IO 신호에 대해 또는 블록 경계에서만 지원됩니다. 이유: ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt; 또는 ''{3}''의 &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 출력 포트&lt;/sldiag&gt;에 내부 버퍼가 있습니다.</entry>
    <entry key="RTWCGReusableCSCEmbeddedSigObj">Multiple signals that have a reusable custom storage class and the same signal name must all resolve to a Simulink signal object.  The &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of {1} does not resolve to a Simulink signal object.</entry>
    <entry key="RTWCGReusableCSCSimulinkFcnUnsupported">Reusable CSC specification is not allowed inside a Simulink Function block. Found one such instance in the port {0,number,integer} of {1}.</entry>
    <entry key="RTWCGReusableCSCDimVarUnsupportedAtBO">Reusable CSC specification is not allowed at blocks with dimension variants. Found one such instance in the port {0,number,integer} of {1}.</entry>
    <entry key="RTWCGReusableCSCDimVarUnsupportedAtDW">Reusable CSC specification is not allowed at blocks with dimension variants. Found one such instance in the state of {0}.</entry>
    <entry key="RTWCGReusableCSCVarDimsUnsupported">{0}의 재사용 가능 CSC 지정 문제: 모델의 어디든 가변 차원 유형의 신호가 있는 경우 재사용 가능 CSC 지정을 적용할 수 없습니다.</entry>
    <entry key="RTWCGReusableCSCExportFcnUnsupported">Reusable CSC specification problem in {0}: Reusable CSC specification cannot be honored in models having export functions.</entry>
    <entry key="RTWCGReusableCSCInportOverwrittenExportFcn">{0}에 재사용 가능 CSC를 지정하면 루트 인포트를 덮어쓰게 되며, 따라서 내보낸 함수를 모델에서 비동기식으로 실행 시 잘못된 결과가 생성될 수 있습니다</entry>
    <entry key="RTWCGReusableCSCInDifferentTasksInExportFcn">{0}의 재사용 가능 버퍼 지정 문제: ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호와 ''{4}''의 &lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;{3,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호가 여러 다른 태스크에서 실행됩니다. 이는 내보내기 함수를 갖는 모델에서는 지원되지 않습니다</entry>
    <entry key="RTWCGReusableCSCNotAtRootIOInExportFcn">{0}의 재사용 가능 버퍼 지정 문제: ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호에 대해서는 재사용 가능 CSC 지정을 적용할 수 없습니다. 내보내기 함수를 갖는 모델의 경우 재사용 가능 CSC 지정은 루트 인포트와, 루트 아웃포트를 구동하는 신호에서만 지원됩니다</entry>
    <entry key="RTWCGReusableCSCAtModelBlockIOInExportFcn">{0}의 재사용 가능 버퍼 지정 문제: ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호에 대해서는 재사용 가능 CSC 지정을 적용할 수 없습니다. 내보내기 함수를 갖는 모델의 경우 재사용 가능 CSC 지정은 Model 블록의 루트 포트의 신호에 대해 지원되지 않습니다</entry>
    <entry key="RTWCGReusableCSCNotAtTopLevelInExportFcn">{0}의 재사용 가능 버퍼 지정 문제: ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호에 대해서는 재사용 가능 CSC 지정을 적용할 수 없습니다. 해당 신호가 비가상 서브시스템 내부에 있기 때문입니다. 내보내기 함수를 갖는 모델의 경우 재사용 가능 CSC 지정은 최상위 수준의 신호에 대해서만 지원됩니다</entry>
    <entry key="RTWCGReusableCSCFcnProtoControlUnsupported">{0}의 재사용 가능 CSC 지정 문제: 함수 프로토타이핑 제어가 활성화된 경우 재사용 가능 CSC 지정을 적용할 수 없습니다.</entry>
    <entry key="RTWCGReusableCSCEncapCPPIOUnsupported">{0}의 재사용 가능 CSC 지정 문제: C++ 클래스 인터페이스를 생성할 때는 재사용 가능 CSC 지정을 적용할 수 없습니다.</entry>
    <entry key="RTWCGReusableCSCMoreThanOnePair">{0}의 재사용 가능 CSC 지정 문제: 재사용 가능 CSC 지정은 한 쌍의 입/출력 신호만 허용합니다.</entry>
    <entry key="RTWCGReusableCSCRootIORenameWithVC">동일한 재사용 가능 스토리지 클래스를 가지는 모든 루트 IO는 Variant 조건을 갖는 경우 재사용해야 합니다. ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 루트 입력 신호와 ''{3}''의 &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 루트 출력 신호가 Variant 조건을 갖지만 사용되지 않았습니다.</entry>
    <entry key="RTWCGReusableCSCRootIOAtIRT">''{1}''의 &lt;sldiag objui="outport" objparam="{0, number, integer}" objname="{1}"&gt;{0, number, integer}번 출력 포트&lt;/sldiag&gt;와 ''{3}''의 &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 출력 포트&lt;/sldiag&gt;에는 재사용 가능 CSC를 지정할 수 없습니다. ''{1}'' 또는 ''{3}'', 혹은 두 개 모두가 Initialize, Reinitialize, Reset 또는 Terminate Subsystem에 연결된 루트 IO 신호이기 때문입니다.</entry>
    <entry key="RTWCGReusableFPCSwitchedNonreusedToReused">서브시스템이 FPC를 통해 재사용 가능한 IO 인수에 액세스하기 때문에 서브시스템 ''{0}''의 ''재사용 불가 함수'' 패키징 설정을 ''재사용 가능 함수''로 변환하는 중</entry>
    <entry key="RTWCGReusableFPCCannotSwitchNonreusedToReusedO">Function prototyping control IO reuse problem: the setting to subsystems that access the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' cannot be ''Nonreusable function''</entry>
    <entry key="RTWCGReusableFPCCannotSwitchNonreusedToReusedI">Function prototyping control IO reuse problem: the setting to subsystems that access the &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' cannot be ''Nonreusable function''</entry>
    <entry key="RTWCGReusableFPCCannotSpecifyPointerBusOnInport">함수 프로토타이핑 제어 IO 재사용이 포인터 버스로 전달되므로 Inport 블록 ''{0}''에 이 IO 재사용을 적용할 수 없습니다.</entry>
    <entry key="RTWCGReusableMatlabIOCannotReusePartialI">MATLAB Function 블록의 인 플레이스 최적화(In-place Optimization) 문제: ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 전체 메모리 영역을 갖는 버퍼가 없습니다.</entry>
    <entry key="RTWCGReusableMatlabIOCannotReuseNoBufferI">MATLAB Function 블록의 인 플레이스 최적화(In-place Optimization) 문제: ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 버퍼가 없습니다.</entry>
    <entry key="RTWCGReusableMatlabIOCannotReuseNoBufferO">MATLAB Function 블록의 인 플레이스 최적화(In-place Optimization) 문제: ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 버퍼가 없습니다.</entry>
    <entry key="RTWCGConcurrentAccessOnlyDSM">신호 {0}의 특성이 유효하지 않습니다. Concurrent Access 특성은 Data Store Memory에 있는 신호에만 유효합니다.</entry>
    <entry key="RTWDataTypeNameReservedIdConflict">Unable to generate code using user-defined data type ''{0}'' because it conflicts with a {1} language reserved identifier</entry>
    <entry key="RTWEmptyNamingRule">The naming rule ''{0}'' specified for the ''{1}'', results in an empty string. Specify a different naming rule or ensure that the naming rule contains $M or $N. </entry>
    <entry key="RTWExternNameClash">식별자 ''{0}''의 사용에 잠재적 충돌이 있을 수 있음: {1}</entry>
    <entry key="RTWExternNameClash2">Potential usage conflicts for identifier ''{0}''.  This might occur when multiple referenced models have similar model names and similar naming rules.  You can resolve this conflict by: increase the maximum identifier length parameter on the Identifiers pane of the Configuration Parameter dialog, add different literal character vectors in identifier naming rules for each referenced model, or use dis-similar names for each referenced model</entry>
    <entry key="RTWExternNameClashWithNamespace">Potential conflicting usages of type ''{0}''; this name is already in use as a namespace. Please change the type name or namespace name.</entry>
    <entry key="RTWExternNameClashWithTypeName">Potential conflicting usages of identifier: ''{0}'' is a field name and a field type name in a C++ class or struct.</entry>
    <entry key="RTWIDInMakingSynthesizedExternNameClash">Potential conflicting usages of identifier ''{0}'': {1}.\n\nThe identifier ''{0}'' for ''{2}'' was generated because it is individually mapped to a non-Auto storage class and the Identifier field is empty.</entry>
    <entry key="RTWIDInMemSynthesizedExternNameClash">Potential conflicting usages of identifier ''{0}'': {1}.\n\nThe identifier ''{0}'' for ''{2}'' was generated because it is individually mapped to a non-Auto storage class and the Identifier field is empty.</entry>
    <entry key="RTWBothIDsSynthesizedExternNameClash">Potential conflicting usages of identifier ''{0}'': {1}.\n\nThe identifier ''{0}'' was generated for both ''{2}'' and ''{3}'' because both blocks are individually mapped to a non-Auto storage class and the Identifier field for each block is empty.</entry>
    <entry key="RTWIDSynthesizedIDIsEmpty">블록 ''{0}''에 대한 식별자가 생성되었습니다. 이 블록이 자동이 아닌 스토리지 클래스에 개별적으로 매핑되고 블록에 대한 식별자 필드가 비어 있기 때문입니다. 그러나 유효한 식별자에 대한 모든 규칙을 적용한 후에 생성된 식별자가 비어 있습니다. 블록의 이름을 하나 이상의 유효한 ANSI-C 문자로 바꾸십시오.</entry>
    <entry key="RTWIDSynthesizedIDForIOBufferIsEmpty">포트 ''{1}''에서 블록 ''{0}''과(와) 연결된 신호에 대한 식별자가 생성되었습니다. 이 블록이 자동이 아닌 스토리지 클래스에 개별적으로 매핑되고 신호에 대한 식별자 필드가 비어 있기 때문입니다. 그러나 유효한 식별자에 대한 모든 규칙을 적용한 후에 생성된 식별자가 비어 있습니다. 블록의 이름을 하나 이상의 유효한 ANSI-C 문자로 바꾸십시오.</entry>
    <entry key="RTWIDSynthesizedStateIDIsEmpty">블록 ''{0}''이(가) 소유한 상태에 대한 식별자가 생성되었습니다. 블록이 자동이 아닌 스토리지 클래스에 개별적으로 매핑되고 상태에 대한 식별자 필드가 비어 있기 때문입니다. 그러나 유효한 식별자에 대한 모든 규칙을 적용한 후에 생성된 식별자가 비어 있습니다. 상태를 소유하는 블록 ''{0}''의 이름을 하나 이상의 유효한 ANSI-C 문자로 바꾸십시오.</entry>
    <entry key="RTWRelaxNameForVariantsNotPossibleForCSC"> 스토리지 클래스를 내장 스토리지 클래스 중 하나로 변경해 보십시오.</entry>
    <entry key="RTWReusedFcnNameClashIntraModel"> ''{0}'' and ''{1}'' have the same function name but different checksums, therefore the same function name ''{2}'' cannot be specified for the two subsystems.\n Try the following in order to eliminate this error:\n\n1. In Library Subsystem &gt; Block Parameter &gt; Code Generation, specify the 'Function Name Options' as 'Auto' to find out differences in the two function signatures. Then, refer to &lt;a href="matlab:helpview([docroot '/ecoder/ug/determine-why-subsystem-code-is-not-reused.html'])"&gt;"Determine Why Subsystem Code Is Not Reused"&lt;/a&gt;  on tips to resolve checksum differences.\n\n2. Consider renaming the function name from ''{2}'' to ''{2}$C'' in Library Subsystem &gt; Block Parameter &gt; Code Generation &gt; Function Name to the append subsystem checksum to the function name and make it unique. Note that this will turn the code reuse optimization off by generating separate functions for the conflicting instances</entry>
    <entry key="RTWGenBadParamValue">rtwgen 파라미터 ''{0}''에 지정된 값이 유효하지 않음</entry>
    <entry key="RTWGenBuildAdvisorWarning">Code generation advisor detects potential issues with model ''{0}''.
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="suggestion"&gt;
          &lt;cmd&gt;coder.advisor.internal.open&lt;/cmd&gt;
          &lt;txt&gt;Address issues in advisor window.&lt;/txt&gt;
        &lt;/action&gt;
        &lt;action type="suggestion"&gt;
          &lt;txt&gt;Turn off the advisor by selecting "Off" for &lt;sldiag objui="configset" objparam="CheckMdlBeforeBuild"&gt;Check model before generating code&lt;/sldiag&gt; on the Code Generation pane of the Configuration Parameters dialog.&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="RTWGenDupParam">rtwgen 파라미터 ''{0}''이(가) 중복 지정됨</entry>
    <entry key="RTWGenExportedIdClash1">두 개의 다른 함수 호출을 동일한 이름 ''{0}''을(를) 사용하여 내보내려고 함</entry>
    <entry key="RTWGenExportedIdClash2">내보낸 함수 이름 ''{0}''이(가) 함수 호출이 내보내진 시스템 이름과 충돌함</entry>
    <entry key="RTWGenExportedIdClash3">내보낸 함수 이름 ''{0}''이(가) 서브시스템 ''{1}''의 함수 이름과 충돌함</entry>
    <entry key="RTWGenNoInliningSubsysOfSeparateData">The exported function name ''{0}'' clashes with the Function Name for subsystem ''{1}''. To avoid this name conflict, either uncheck ''Function with separate data'' on the subsystem parameters dialog or rename one of the functions.</entry>
    <entry key="RTWGenNoInliningSubsysOfReusableFunction">The exported function name ''{0}'' clashes with the Function Name for subsystem ''{1}''. To avoid this name conflict, either select ''Function'' for ''Function packaging'' on the subsystem parameters dialog or rename one of the functions.</entry>
    <entry key="RTWGenMdlInputDataSpec">모델 ''{0}''의 루트 인포트에 외부 입력 데이터가 지정되어 있습니다. 이 데이터는 생성 코드에 자동으로 포함되지 않습니다. 0이 아닌 신호를 루트 인포트에 입력하려면 생성 코드를 위한 특정 런타임 인터페이스를 타깃이 생성해야 합니다.</entry>
    <entry key="RTWGenSyntaxErr">사용법: rtwgen(''BlockDiagram'')</entry>
    <entry key="RTWGenModelNameTooLong">모델 ''{0}''의 이름이 {1,number,integer}자를 초과하므로, 이 모델에 대한 코드를 생성할 수 없습니다</entry>
    <entry key="RTWGenUnknownParam">Unknown rtwgen parameter ''{0}'' specified</entry>
    <entry key="RTWIllegalUseOfReservedId">Cannot use identifier ''{0}'' as a "{1}" because it is a programming language reserved identifier</entry>
    <entry key="RTWReservedIdentifier">The identifier ''{0}'' has already been reserved</entry>
    <entry key="RTWIdentifierServiceCodeGenNotStarted">Cannot request Identifier as Code Generation Context is not available</entry>
    <entry key="RTWIdentifierServiceCodeGenStarted">Cannot reserve Identifier as Code Generation has started. Use requestIdentifier to request for an identifier during Code Generation</entry>
    <entry key="RTWInvalidExportFunctionsCall">The TLC option ''ExportFunctionsMode'' is not supported for generating code from a model. The option applies only to generating code from a subsystem</entry>
    <entry key="RTWNameUnableToLocateRootBlock">Unable to locate ''{0}'' in root window of model {1}</entry>
    <entry key="RTWNameUnableToLocateSubsystemBlock">Unable to locate ''{0}'' in subsystem ''{1}'' (S{2,number,integer}) of model {3}</entry>
    <entry key="RTWNonReuseWideGroundCanInputGrnd">Subsystem 블록 ''{0}''에 대한 함수를 생성할 수 없습니다. 이 서브시스템은 비 스칼라 출력 신호를 갖는 Ground 블록 ''{1}''을(를) 통해 입력되었습니다. Ground 블록을 모든 값이 0인 Constant 블록으로 교체하거나, 아니면 Subsystem 블록의 ''함수 패키징'' 설정을 인라인으로 설정하거나 ''함수 인터페이스''가 ''void_void''로 설정된 재사용 불가 함수로 수정하십시오</entry>
    <entry key="RTWNonReuseWideGroundCanInputGrndCPP">C++ 클래스 인터페이스를 생성할 때 필요한 Subsystem 블록 ''{0}''에 대한 함수를 생성할 수 없습니다. 이 서브시스템은 비 스칼라 출력 신호를 갖는 Ground 블록 ''{1}''을(를) 통해 입력되었습니다. Ground 블록을 모든 값이 0인 Constant 블록으로 교체하거나 &lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;코드 인터페이스 패키징&lt;/sldiag&gt;을 ''C++ 클래스''가 아닌 다른 값으로 설정하십시오.</entry>
    <entry key="RTWNonReuseWideGroundCanInputUnconn">Subsystem 블록 ''{0}''에 대한 재사용 가능 함수를 생성할 수 없습니다. 이 Subsystem 블록의 일부 입력 포트 요소가 직접적으로든 간접적으로든 실제(비가상) 신호에 연결되지 않았습니다. Subsystem 블록의 연결되지 않은 입력을 값이 0인 Constant 블록에 연결하거나 Subsystem 블록의 ''함수 패키징'' 설정을 [인라인] 또는 [함수]로 수정하십시오</entry>
    <entry key="RTWNonReuseWideGroundCanInputUnconnCPP">C++ 클래스 인터페이스를 생성할 때 필요한 Subsystem 블록 ''{0}''에 대한 재사용 가능 함수를 생성할 수 없습니다. 이 Subsystem 블록의 일부 입력 포트 요소가 직접적으로든 간접적으로든 실제(비가상) 신호에 연결되지 않았습니다. Subsystem 블록의 연결되지 않은 입력을 값이 0인 Constant 블록에 연결하거나 &lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;코드 인터페이스 패키징&lt;/sldiag&gt;을 ''C++ 클래스''가 아닌 다른 값으로 설정하십시오.</entry>
    <entry key="RTWNotConfigForExtMode">Current code generation target for model ''{0}'' is either not configured for or does not support external mode.  Select &lt;sldiag objui="configset" objparam="ExtMode"&gt;External mode&lt;/sldiag&gt; to enable external mode for targets that support it</entry>
    <entry key="RTWSFcnComplexTunableParameterNotSupported">S-Function 파라미터 ''{0}''은(는) 값이 복소수이기 때문에 조정 가능형으로 설정할 수 없음</entry>
    <entry key="RTWSFcnNonBuiltInTunableParameterNotSupported">S-Function 파라미터 ''{0}''은(는) 데이터형이 내장형이 아니기 때문에 조정 가능형으로 설정할 수 없음</entry>
    <entry key="RTWSFcnTransformedTunableParameterNotSupported">S-Function 파라미터 ''{0}''은(는) 값 또는 데이터형이 해당 외부 파라미터를 기준으로 변형되었기 때문에 조정 가능형으로 설정할 수 없음</entry>
    <entry key="RTWSimRunning">모델이 현재 시뮬레이션되는 중이므로 ''{0}''에 대한 코드를 생성할 수 없습니다.</entry>
    <entry key="RTWStateFlowBitSetsWithStructAlignment">Bitsets may not be used when using a target that specifies an explicit structure alignment.  Turn off the options ''Use bitsets for storing state configuration'' and ''Use bitsets for storing Boolean data'' in the Configuration Parameters dialog box.</entry>
    <entry key="RTWDataTypeElementNameReservedIdConflict">Unable to generate code using user-defined data type ''{0}'' because it has an element named ''{1}'' which conflicts with a programming language reserved identifier</entry>
    <entry key="RTWAnonStructElementNameReservedIdConflict">"Unable to generate code for ''{0}'' because it is used in a tunable expression and contains name ''{1}'' in struct that is a programming language reserved identifier."</entry>
    <entry key="RateTransBlkNotAllowedAtMergeBlk">Merge 블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에는 Rate Transition 블록이 허용되지 않습니다. Rate Transition 블록을 삽입하기 전에 Merge 블록의 입력 포트에 Signal Conversion을 배치해 보십시오.</entry>
    <entry key="RateTransBlkDoesntSupportMoreThanTwoTasks" context="error">Rate Transition block ''{0}'' with ''Ensure data integrity'' set to ''on'' does not support multiple read and write transitions involving Union rate.
    
             &lt;actions exclusiveFixIts="yes"&gt;
             &lt;action type="fixit" id="DisableDataTransferProtection" retvalue="false"&gt;
             &lt;cmd&gt;set_param(''{0}'', ''Integrity'', ''off'');&lt;/cmd&gt;
             &lt;txt&gt;Disable the ''Ensure data integrity'' setting for Rate Transition block ''{0}''.&lt;/txt&gt;
             &lt;/action&gt;
             &lt;/actions&gt;
    
    </entry>
    <entry key="VirtualBusRootOutportWithUnionTsUnsupported" context="error">가상 버스 입력을 가진 루트 Outport 블록 ''{0}''은(는) 유니언 샘플 시간을 지원하지 않습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion" id="ReplaceOutportBlockWithBEP"&gt; &lt;txt&gt;루트 Outport 블록 ''{0}''을(를) Out Bus Element 블록으로 바꾸십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    
    </entry>
    <entry key="SuggestForMultiWordCSC">
      
               &lt;actions&gt; &lt;action type="suggestion" id="rtw_suggestion" retvalue="false"&gt; &lt;txt&gt; 대신 Embedded Coder 사전에 정의된 사용자 지정 스토리지 클래스를 사용해 볼 수 있습니다.&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit" id="rtw_fixit" retvalue="false"&gt; &lt;cmd&gt;set_param(''{0}'',''ProdLongLongMode'',''on'')&lt;/cmd&gt; &lt;txt&gt;이 메시지를 표시하지 않으려면 &lt;sldiag objui="configset" objparam="ProdLongLongMode"&gt;long long 데이터형 지원&lt;/sldiag&gt;을 ''켜기''로 설정하십시오. 모델 계층 구조의 모든 모델에 대해 이와 같이 변경해야 합니다.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
      
    </entry>
    <entry key="RTWCGInvalidCSCDataTypeForOutput">Output port {0,number,integer} of ''{1}'' has a legacy custom storage class as well as a data type having {2,number,integer} bits. This data type is multi-word because the largest integer type supported on the target has only {3,number,integer} bits. Custom storage classes are not supported in conjunction with multi-word data types.
    
      &lt;actions exclusiveFixIts="yes"&gt;
      &lt;action_catalog id="Simulink:Engine:SuggestForMultiWordCSC" enabled="true" ids="{5}"&gt;
          &lt;arg&gt;{4}&lt;/arg&gt;
      &lt;/action_catalog&gt;
      &lt;/actions&gt;
        
    </entry>
    <entry key="RTWCGInvalidCSCDataTypeForState">''{0}''의 상태가 레거시 사용자 지정 스토리지 클래스뿐 아니라 {1,number,integer}비트를 갖는 멀티워드 데이터형도 가집니다. 타깃에서 지원되는 가장 큰 정수형이 {2,number,integer}비트만 가지므로 이 데이터형은 멀티워드입니다. 사용자 지정 스토리지 클래스는 멀티워드 데이터형과 함께 사용할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action_catalog id="Simulink:Engine:SuggestForMultiWordCSC" enabled="true" ids="{4}"&gt; &lt;arg&gt;{3}&lt;/arg&gt; &lt;/action_catalog&gt; &lt;/actions&gt;
    
    </entry>
    <entry key="RTWCGInvalidCSCDataTypeForParam">''{0}''의 파라미터가 레거시 사용자 지정 스토리지 클래스뿐 아니라 {1,number,integer}비트를 갖는 멀티워드 데이터형도 가집니다. 타깃에서 지원되는 가장 큰 정수형이 {2,number,integer}비트만 가지므로 이 데이터형은 멀티워드입니다. 사용자 지정 스토리지 클래스는 멀티워드 데이터형과 함께 사용할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action_catalog id="Simulink:Engine:SuggestForMultiWordCSC" enabled="true" ids="{4}"&gt; &lt;arg&gt;{3}&lt;/arg&gt; &lt;/action_catalog&gt; &lt;/actions&gt;
    
    </entry>
    <entry key="RTWCGInvalidCSCDataTypeForWSParam">The workspace parameter ''{0}'' has a legacy custom storage class as well as a multi-word data type having {1,number,integer} bits. This data type is multi-word because the largest integer type supported on the target has only {2,number,integer} bits. Custom storage classes are not supported in conjunction with multi-word data types.
    
      &lt;actions exclusiveFixIts="yes"&gt;
      &lt;action_catalog id="Simulink:Engine:SuggestForMultiWordCSC" enabled="true" ids="{4}"&gt;
          &lt;arg&gt;{3}&lt;/arg&gt;
      &lt;/action_catalog&gt;
      &lt;/actions&gt;
    
    </entry>
    <entry key="RTWCGInvalidCSCDataTypeForRootOutport">루트 아웃포트 ''{0}''이(가) 레거시 사용자 지정 스토리지 클래스뿐 아니라 {1,number,integer}비트의 멀티워드 데이터형도 가집니다. 타깃에서 지원되는 가장 큰 정수형이 {2,number,integer}비트만 가지므로 이 데이터형은 멀티워드입니다. 사용자 지정 스토리지 클래스는 멀티워드 데이터형과 함께 사용할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action_catalog id="Simulink:Engine:SuggestForMultiWordCSC" enabled="true" ids="{4}"&gt; &lt;arg&gt;{3}&lt;/arg&gt; &lt;/action_catalog&gt; &lt;/actions&gt;
    
    </entry>
    <entry key="RTWFuncScopeGlobal">''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에 있는 신호 ''{0}''은(는) 자동으로 범위가 설정되도록 지정되었지만, 국소화될 수 없습니다.{3}</entry>
    <entry key="RTWAutoScopeDuplicatedGlobal">Multiple signals with the same name ''{0}'' have a Localizable storage class or Data Scope of Auto, but one of them is forced to be a global variable.  These can be found on the &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;output port {1,number,integer}&lt;/sldiag&gt; of ''{2}'' and the &lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;output port {3,number,integer}&lt;/sldiag&gt; of ''{4}.''</entry>
    <entry key="RTWAutoScopeDuplicatedRoot">Multiple signals with the same name ''{0}'' have a Localizable storage class or Data Scope of Auto, and are outside of a reusable subsystem.  These can be found on the &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;output port {1,number,integer}&lt;/sldiag&gt; of ''{2}'' and the &lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;output port {3,number,integer}&lt;/sldiag&gt; of ''{4}''.</entry>
    <entry key="RTWAutoScopeDuplicatedSubsys">동일한 ID ''{0}''을(를) 갖는 다중 신호가 Localizable 스토리지 클래스를 갖거나 데이터 범위가 자동으로 설정되었으며, 동일한 재사용 가능 서브시스템 ''{1}'' 내에 있습니다. 이러한 신호는 ''{3}''의 &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 출력 포트&lt;/sldiag&gt;와 ''{5}''의 &lt;sldiag objui="outport" objparam="{4,number,integer}" objname="{5}"&gt;{4,number,integer}번 출력 포트&lt;/sldiag&gt;에서 찾을 수 있습니다.</entry>
    <entry key="RTWAutoScopeDuplicatedNonAutoScope">동일한 신호 이름 ''{0}''이(가) 다중 신호에 사용되었습니다. 이 중 한 신호만 Localizable 스토리지 클래스를 갖거나 데이터 범위가 자동으로 설정되었습니다. 이러한 신호는 ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;와 ''{4}''의 &lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;{3,number,integer}번 출력 포트&lt;/sldiag&gt;에서 찾을 수 있습니다.</entry>
    <entry key="RapidAcceleratorCantUploadDataNoDWork">업로드 가능한 dwork가 없기 때문에 고속 액셀러레이터 모드가 ''{0}''을(를) 업데이트할 수 없음</entry>
    <entry key="RapidAcceleratorCantUploadDataNoInputPorts">입력 포트가 없기 때문에 고속 액셀러레이터 모드가 ''{0}''을(를) 업데이트할 수 없음</entry>
    <entry key="RapidAcceleratorCantUploadDataNoConnectedSignals">연결된 신호가 없기 때문에 고속 액셀러레이터 모드가 ''{0}''을(를) 업데이트할 수 없음</entry>
    <entry key="RapidAcceleratorCantUploadDataPortBasedSampleTime">블록이나 그 소스 블록들 중 하나가 포트 기반 샘플 시간을 갖기 때문에 고속 액셀러레이터 모드가 ''{0}''을(를) 업데이트할 수 없음</entry>
    <entry key="RapidAcceleratorCantUploadDataConstantSampleTime">블록이나 그 소스 블록들 중 하나가 상수 샘플 시간을 갖기 때문에 고속 액셀러레이터 모드가 ''{0}''을(를) 업데이트할 수 없음</entry>
    <entry key="RapidAcceleratorCantUploadDataMultipleRates">싱글레이트가 아니기 때문에 고속 액셀러레이터 모드가 ''{0}''을(를) 업데이트할 수 없음</entry>
    <entry key="RapidAcceleratorCantUploadDataRootInport">구동 중인 블록 중 하나가 최상위 인포트이기 때문에 고속 액셀러레이터 모드가 ''{0}''을(를) 업데이트할 수 없음</entry>
    <entry key="RapidAcceleratorCantUploadDataCSC">소스 신호 중 하나가 사용자 지정 스토리지 클래스를 사용하기 때문에 고속 액셀러레이터 모드가 ''{0}''을(를) 업데이트할 수 없음</entry>
    <entry key="RapidAcceleratorCantUploadDataNoConvertFunc">소스 신호 중 하나가 고속 액셀러레이터 모드에서 지원하지 않는 데이터형을 사용하기 때문에 고속 액셀러레이터 모드가 ''{0}''을(를) 업데이트할 수 없음</entry>
    <entry key="RapidAcceleratorCantUploadDataVarDims">소스 신호 중 하나가 가변 크기이기 때문에 고속 액셀러레이터 모드가 ''{0}''을(를) 업데이트할 수 없음</entry>
    <entry key="RapidAcceleratorUnableToOpenModelParameterInfoFile">모델 파라미터 정보 mat 파일 ''{0}''을(를) 열 수 없습니다.</entry>
    <entry key="RateTransBlkNotAllowedInTrigSubsys">Rate Transition 블록 ''{0}''은(는) 그 입력 또는 출력 포트 샘플 시간이 비동기 샘플 시간이 아닌 한, {1} 서브시스템 ''{2}'' 내부에서 허용되지 않습니다. Rate Transition 블록을 {3} 서브시스템 외부에 배치해 보십시오.</entry>
    <entry key="RateTransBlkNotAllowedToHaveTrigRateWithConstSrc">{2} 서브시스템 ''{3}''의 {1} 포트가 연결이 끊겼거나 접지되었기 때문에 Rate Transition 블록 ''{0}''이(가) 소스 없이 샘플 시간을 트리거했습니다. {2} 서브시스템 ''{3}''의 {1} 포트를 접지를 제외한 유효한 소스에 연결하십시오.</entry>
    <entry key="RemoveNonRemovableItem">Item ''{0}'' is not removable.</entry>
    <entry key="RemovedSysDoesNotHaveThis">서브시스템 ''{0}''은(는) SimViewingDevice이고 코드를 생성하지 않기 때문에 ''{1}''을(를) 갖지 않음</entry>
    <entry key="ResetSignalMustBeScalar">Cannot set dimensions of the reset input port of ''{0}''. Reset signal must be a scalar signal.</entry>
    <entry key="ResettableSubsystemMustBeSingleRate">재설정 포트 ''{1}''을(를) 포함하여 서브시스템 ''{0}'' 내의 모든 블록은 동일한 샘플 시간을 가져야 합니다.</entry>
    <entry key="ReturnWkspOutputOptNotSupported">ReturnWorkspaceOutputs 옵션을 ''off''로 설정하는 것은 모호합니다. 이 오류를 방지하려면 다음 중 하나를 수행하십시오:\n\t1) sim 명령을 호출할 때 반환 인수를 하나만 사용합니다.\n\t2) 모델에 대해 파라미터 ReturnWorkspaceOutputs를 &lt;a href="matlab:set_param(bdroot,'ReturnWorkspaceOutputs','off');"&gt;끄고&lt;/a&gt; sim 명령을 호출할 때 옵션 ReturnWorkspaceOutputs를 지정하지 않습니다.</entry>
    <entry key="RightClickBuildFailInsertRateTransBlkInput">오른쪽 버튼을 클릭하여 서브시스템을 만들 때 블록({1})의 {0,number,integer}번 입력 포트에 Rate Transition 블록을 삽입하지 못했습니다. 원래 모델에서 다음 사항을 확인하여 이 문제를 조사하십시오. \n - 원래 모델에 고정 스텝 솔버가 사용됨 \n - 서브시스템에서 Inport 블록과 Outport 블록의 샘플 시간 파라미터가 모두 -1로 설정됨 \n - 서브시스템 입력 신호에 상수 샘플 시간이 없음</entry>
    <entry key="RightClickBuildFailInsertRateTransBlkOutput">오른쪽 버튼을 클릭하여 서브시스템을 만들 때 블록({1})의 {0,number,integer}번 출력 포트에 Rate Transition 블록을 삽입하지 못했습니다. 원래 모델에서 다음 사항을 확인하여 이 문제를 조사하십시오. \n - 원래 모델에 고정 스텝 솔버가 사용됨 \n - 서브시스템에서 Inport 블록과 Outport 블록의 샘플 시간 파라미터가 모두 -1로 설정됨 \n - 서브시스템 입력 신호에 상수 샘플 시간이 없음</entry>
    <entry key="InsertRTBWithEnumTypeNotPermitted">
      열거형 데이터형의 신호에는 Rate Transition 블록을 자동으로 삽입할 수 없습니다.\n블록 ''{2}''의 {0} {1,number,integer}번 포트에 수동으로 Rate Transition 블록을 삽입한 다음,\n''초기 조건''을 유효한 열거형 값으로 설정하십시오.
    </entry>
    <entry key="InsertRTBNotPermittedOnInputPortVariantSubsystem">
      Automatic insertion of a Rate Transition block on input port {0,number,integer} of Variant block ''{1}'' is not supported.\nManually insert a Rate Transition block at the input port {0,number,integer} of subsystem ''{2}''.
    </entry>
    <entry key="InsertRTBNotPermittedOnOutputPortVariantSubsystem">
      Automatic insertion of a Rate Transition block on output port {0,number,integer} of Variant block ''{1}'' is not supported.\nManually insert a Rate Transition block at the output port {0,number,integer} of subsystem ''{2}''.
    </entry>
    <entry key="InsertRTBWithAliasEnumTypeNotPermitted">
      열거형 데이터형의 별칭을 가진 신호에는 Rate Transition 블록을 자동으로 삽입할 수 없습니다. \n블록 ''{2}''의 {0} {1,number,integer}번 포트에 수동으로 Rate Transition 블록을 삽입한 다음,\n''초기 조건''을 유효한 열거형 값으로 설정하십시오.
    </entry>
    <entry key="InsertBlkAtVirtualBlkInputError">Simulink는 가상 블록의 Rate Transition 블록 다운스트림을 자동으로 삽입할 수 없습니다.\n가상 블록 업스트림의 입력 포트에서 수동으로 Rate Transition 블록을 ''{0}''에 삽입하십시오.</entry>
    <entry key="RootInportCannotCodeGenForVarDims">The root-level input port ''{0}'' is carrying a variable-size signal with finite upper bound.  This is supported only for the following targets:\n\t
    - Model reference\n\t
    - Accelerator\n\t
    - GRT (except GRT malloc)\n\t
    - ERT\n\t
    - S-function\n
    However, even for the above targets, variable-size signals with finite upper bounds are not supported when:\n\t
    - 'Code interface packaging' is set to either 'C++ class' or 'Reusable function' on the Interface pane of the Configuration Parameters dialog box\n</entry>
    <entry key="RunTimeChangeDimsFixedDimsMode">Simulink cannot modify the dimensions of &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' because this port has a fixed-size signal.</entry>
    <entry key="RunTimeChangeDimsFixedDimsNVBus">Simulink cannot modify the dimensions of &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' because this port has a nonvirtual bus with only fixed-size elements.</entry>
    <entry key="RunTimeChangeDimsPassThruOutput">Simulink는 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;의 차원을 수정할 수 없습니다. 이 블록은 출력 포트의 차원이 한 입력 포트의 차원과 일치해야 하기 때문에 차원 수정은 허용되지 않습니다. (S-Function의 경우 ''ssSetInputDimsSameAsOutputDims''가 사용되었습니다.)</entry>
    <entry key="RunTimeChangeNumRowsFrameOutputSignal">Simulink는 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;의 첫 번째 차원을 수정할 수 없습니다. 이 포트의 샘플링 모드가 프레임 기반이기 때문입니다. 이 포트의 샘플링 모드를 샘플 기반으로 변경해 보십시오.</entry>
    <entry key="RunTimeInvalidDims">Simulink cannot set the current dimensions for &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}''. The specified dimension ({2,number,integer}) must be in the range of 0 to {3,number,integer}.</entry>
    <entry key="RunTimeInvalidDimsNVBus">Simulink cannot set the current dimensions for &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}''. The specified dimension ({2,number,integer}) for bus element ''{3}'' must be in the range of 0 to {4,number,integer}.</entry>
    <entry key="RunTimeExceedNumDims">Simulink cannot set the current dimensions for &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}''. The specified dimensions index ({2,number,integer}) must be in the range of 0 to {3,number,integer} because the number of dimensions of the output port is {4,number,integer}.</entry>
    <entry key="RunTimeExceedNumDimsNVBus">Simulink cannot set the current dimensions for &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}''. The specified dimensions index ({2,number,integer}) must be in the range of 0 to {3,number,integer} because the total number of dimensions of the variable-size elements at the output port is {4,number,integer}.</entry>
    <entry key="RuntimeMethodCalledInUnallowedPhase">시뮬레이션이 실행 중일 때만 ''{1}''의 ''{0}'' 메서드를 호출할 수 있음</entry>
    <entry key="SFSfcnFunctionToReusableFunctionCPP">Stateflow 차트 ''{0}'' 에 서브함수가 포함되어 있고 이 서브함수에서는 C++ 클래스 인터페이스를 생성할 때 ''재사용 가능 함수''를 차트의 ''함수 패키징'' 설정으로 사용해서 코드를 생성해야 하므로 ''함수 패키징'' 설정을 ''재사용 불가 함수''에서 ''재사용 가능 함수''로 변환합니다.</entry>
    <entry key="SFSfcnInlinedToFunction">Stateflow 차트 ''{0}''에 서브함수가 포함되어 있고 차트를 완전히 인라인으로 표시할 수 없으므로 ''함수 패키징'' 설정을 ''인라인''에서 ''{1}''(으)로 변환합니다</entry>
    <entry key="SFSfcnReusableToFunction">내보낸 그래픽 함수가 Stateflow 차트 ''{0}''에 포함되어 있고 이 차트를 재사용 가능 함수로 생성할 수 없으므로, 해당 차트의 ''함수 패키징'' 설정을 ''재사용 가능 함수''에서 ''재사용 불가 함수''로 변환합니다</entry>
    <entry key="SFcnAPICannotChangeTXUDuringSim">시뮬레이션 중에 모델을 프로그래밍 방식으로 호출하는 경우 시뮬레이션 시간, 상태 및 모델 입력을 변경할 수 없음</entry>
    <entry key="SFcnAPIInvalidExtInputs">Model ''{0}'' contains non-double or complex signals. Cannot set non-double or complex external inputs. Use Data Type Conversions</entry>
    <entry key="SFcnAPIInvalidExtInputs1">지정된 모델 입력 개수({0,number,integer})가 실제 입력 개수({1,number,integer})와 일치하지 않음</entry>
    <entry key="SFcnAPIInvalidInputs">시뮬레이션 입력은 double형 벡터로 지정되어야 함</entry>
    <entry key="SFcnAPIInvalidExtOutputs">Model ''{0}'' contains non-double or complex signals. Cannot save external outputs. Use Data Type Conversions</entry>
    <entry key="ModelCommandSingleTaskingModeOnly">메서드 ''{0}''은(는) 싱글태스킹 실행 모드의 모델에 대해서만 지원됩니다.</entry>
    <entry key="SFcnAPIInvalidSyntax">모델 ''{0}''에 프로그래밍 방식으로 액세스할 때의 구문이 유효하지 않음</entry>
    <entry key="SFcnAPIInvalidTime1">시뮬레이션 시간은 double형 실수 스칼라 값이어야 함</entry>
    <entry key="SFcnAPIInvalidTime2">시뮬레이션 시간의 지정된 값({0})이 유효하지 않음. 시뮬레이션 시작 시간({1})과 중지 시간({2}) 사이의 double형 스칼라여야 함</entry>
    <entry key="SFcnAPIInvalidStates">시뮬레이션의 상태는 double형 실수로 구성된 벡터 또는 구조체로 지정되어야 함</entry>
    <entry key="SFcnAPIInvalidTs">샘플 시간 값은 비어 있거나 음이 아닌 double형 스칼라여야 함</entry>
    <entry key="SFcnAPITerminationDeferred">Termination of ''{0}'' deferred</entry>
    <entry key="SFcnCannotChangeSampleTime">S-Function ''{0}'' 메서드 {1}은(는) 한 번 설정된 포트 샘플 시간을 변경할 수 없습니다.</entry>
    <entry key="SFcnDidNotSetSampleTime">S-function should set the sample time of {0} port {1,number,integer} of ''{2}'' to the value specified by the sample and offset time arguments of method {3}.</entry>
    <entry key="SFcnDidnotSetPortFrameData">S-function should set the frame data of {0} port {1,number,integer} of ''{2}'' to the frame data specified by the input argument of method {3}</entry>
    <entry key="SFcnDoesNotExist">S-Function ''{0}''에 오류가 있음: S-Function ''{1}''이(가) 존재하지 않음</entry>
    <entry key="SFcnInvConstantTs">''{1}''의 S-Function {0}에 할당된 샘플 시간이 유효하지 않습니다. 상수 (inf) 샘플 시간을 사용하려면 옵션 SS_OPTION_ALLOW_CONSTANT_PORT_SAMPLE_TIME을 지정해야 합니다.</entry>
    <entry key="SFcnInvInputPortTsAssigned">''{2}''에 있는 S-Function {1}의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 할당된 샘플 시간이 유효하지 않습니다. 포트에 할당되는 샘플 시간은 등록된 샘플 시간 중 하나여야 합니다.</entry>
    <entry key="SFcnInvName">S-Function ''{0}''에 오류가 있음: ''{1}''은(는) 유효하지 않은 모델 이름 지정임</entry>
    <entry key="SFcnInvNumSampleTimes">''{1}''에 있는 S-Function ''{0}''에 의해 반환된 샘플 시간 개수가 유효하지 않습니다.</entry>
    <entry key="SFcnInvOutputPortTsAssigned">''{2}''에 있는 S-Function {1}의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 할당된 샘플 시간이 유효하지 않습니다. 포트에 할당되는 샘플 시간은 등록된 샘플 시간 중 하나여야 합니다.</entry>
    <entry key="SFcnMissingSetInputFrameData">''{1}''의 S-Function ''{0}''에 mdlSetInputPortFrameData 루틴이 없습니다. 여러 개의 출력 포트가 있는 S-Function에서 포트 중 하나라도 동적 프레임 데이터(SamplingMode 상속)가 설정된 경우 mdlSetInputPortFrameData 루틴을 정의해야 합니다.</entry>
    <entry key="SFcnMissingSetInputPortSampleTime">''{1}''에 있는 S-Function ''{0}''은(는) PORT_BASED_SAMPLE_TIMES를 사용하지만, mdlSetInputPortSampleTime 루틴을 갖지 않습니다.</entry>
    <entry key="SFcnMissingSetOutputPortSampleTime">''{1}''에 있는 S-Function ''{0}''은(는) PORT_BASED_SAMPLE_TIMES를 사용하지만, mdlSetOutputPortSampleTime 루틴을 갖지 않습니다.</entry>
    <entry key="SFcnNeedsContTs">''{1}''에 있는 S-Function {0}은(는) 연속 상태이기 때문에 연속 샘플 시간을 가져야 합니다.</entry>
    <entry key="SFcnNoUnorientedFrameData">S-function ''{0}'' in ''{1}'' sets number of dimensions to be one for its {2} port {3,number,integer} even though that port is frame-based. Note that if a port is frame-based, then the number of dimensions should be at least 2</entry>
    <entry key="SFcnUnableToAcqFcnHdl">S-Function ''{0}''에 오류가 있음: MATLAB 함수 ''{1}''에 대한 핸들을 가져올 수 없음</entry>
    <entry key="SFcnUseDisallowConstTs">''{0}''이(가) 불변 상태가 되었습니다(즉, 시뮬레이션 시작 시 한 번만 실행됨). 그러나 상태를 갖고 있습니다. mdlInitializeSizes 메서드에서 ssSetOptions(S, SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME)을 사용하여 불변 상태가 되는 것을 방지해 보십시오.</entry>
    <entry key="SIDCannotAllowCopiedSID">하이 워터마크가 0이 아니기 때문에 복사된 객체의 Simulink ID가 동일할 수 없습니다.</entry>
    <entry key="SIDCannotSetHighWatermark">Cannot change high-watermark. New high-watermark must be greater than current high-watermark.</entry>
    <entry key="SIDNoSIDSpace">Simulink ID 공간이 존재하지 않습니다.</entry>
    <entry key="SLDV_PrecisionLost"> ''{0}''에서 값을 신호 유형으로 변환할 때 정밀도가 손실됨</entry>
    <entry key="SLDV_PrecisionLostErr">''{0}''에서 신호 유형과 파라미터 값 유형 간의 유형 불일치로 인해 정밀도가 손실됨</entry>
    <entry key="SLDV_ProofViolation">Proof property violated in ''{0}'' at time {1}</entry>
    <entry key="SLDV_SigObjWithICIgnored">''{0}''의 초기 출력값은 signal 객체에서 상속되었기 때문에 무시됩니다. 이 블록의 대화 상자 파라미터를 사용하여 필요한 초기값을 지정하십시오.</entry>
    <entry key="SLDV_UnknownBlockType"> ''{0}''은(는) 알 수 없는 Simulink Design Verifier 블록 유형임</entry>
    <entry key="SLType_MI_NoPublicCtor">''{0}'' 클래스의 퍼블릭 생성자가 없음</entry>
    <entry key="SLType_MI_OneIndexed">인덱스 값은 1보다 크거나 같아야 함</entry>
    <entry key="SLType_ModifyLockedType">잠긴 유형 객체를 수정할 수 없음</entry>
    <entry key="SampHitInvalidTid">The sample time index passed into the method ''{0}'' of ''{1}'' must be in the range from 0 to {2,number,integer}</entry>
    <entry key="SampHitInvalidTidForSingleRate">이 모델의 샘플 시간이 단 한 개이므로 ''{1}''의 메서드 ''{0}''에 전달된 샘플 시간 인덱스는 0이어야 함</entry>
    <entry key="SaveWithDisabledLinks_Error">블록 다이어그램 ''{0}''이(가) 비활성화된 라이브러리 링크를 포함하므로 저장되지 않습니다. 이 제한을 비활성화하려면 set_param(''{1}'',''SaveWithDisabledLinksMsg'',''none'')을 입력한 후 다시 저장하십시오. 비활성화된 링크를 찾으려면 모델 어드바이저를 사용하십시오.</entry>
    <entry key="SaveWithParameterizedLinks_Error">Block diagram ''{0}'' contains a parameterized library link and will not be saved. To disable this restriction, type set_param(''{1}'',''SaveWithParameterizedLinksMsg'',''none'') and save again.  To find the parameterized link use the Model Advisor.</entry>
    <entry key="SetCurrentOutputDimsRunTime">블록 다이어그램 실행 중일 경우 Simulink는 {1}에 있는 S-Function ''{0}''에 대해 메서드 ''ssSetCurrentOutputPortDimensions''만 호출할 수 있습니다.</entry>
    <entry key="SetDirty_MdlFileChangedOnDisk">현재 블록 다이어그램 ''{0}''을(를) 편집하는 중이지만, 블록 다이어그램을 불러온 후 파일이 디스크에서 변경되었습니다. 블록 다이어그램을 닫고 다시 불러와야 합니다.</entry>
    <entry key="SetDstateNotPerm">이산 상태 수가 읽기 전용입니다. ''UsedAsDiscState'' 플래그를 통해 해당 Dwork를 상태로 표시하여 이산 상태를 등록할 수 있습니다.</entry>
    <entry key="SetNumCStatesEvalOrPostPropTaskOnly">The number of continuous states can be set only in the Initialize and PostPropagationSetup methods of ''{0}''</entry>
    <entry key="SetNumDataStoresEvalOnly">DataStores 개수는 ''{0}''의 CheckPrms 메서드에서만 설정할 수 있음</entry>
    <entry key="SetNumDworksPostPropOnly">The number of Dworks can be set only in the PostPropagationSetup method of ''{0}''</entry>
    <entry key="SetNumInputPortsInitOnly">입력 포트의 개수는 ''{0}''의 Initialize 메서드에서만 설정할 수 있음</entry>
    <entry key="SetNumOutputPortsInitOnly">출력 포트의 개수는 ''{0}''의 Initialize 메서드에서만 설정할 수 있음</entry>
    <entry key="SetSampleTimeEvalOnly">샘플 시간은 ''{0}''의 Initialize 메서드에서만 설정할 수 있음</entry>
    <entry key="SettingAliasedThroughDatatypeIdNotPermitted">''{0}''의 aliasedthrough 데이터형 ID는 읽기 전용이므로 설정할 수 없음</entry>
    <entry key="SettingAliasedThroughDatatypeNameNotPermitted">''{0}''의 aliasedthrough 데이터형 이름은 읽기 전용이므로 설정할 수 없음</entry>
    <entry key="SettingBlockHandleNotPermitted">''{0}''의 블록 핸들은 읽기 전용이므로 설정할 수 없음</entry>
    <entry key="SettingBlockPortNameNotPermitted">블록 ''{0}''의 포트 이름은 읽기 전용이므로 설정할 수 없음</entry>
    <entry key="SettingDatatypeNameNotPermitted">''{0}''의 데이터형 이름은 읽기 전용이므로 설정할 수 없음</entry>
    <entry key="SettingNotPermitted">속성 ''{0}''은(는) 읽기 전용이므로 설정할 수 없음</entry>
    <entry key="SettingNumDlgPrmsNotPermitted">''{0}''의 대화 상자 파라미터 개수는 읽기 전용이므로 설정할 수 없음</entry>
    <entry key="SettingNumRuntimePrmsNotPermitted">''{0}''의 런타임 파라미터 개수는 읽기 전용이므로 설정할 수 없음</entry>
    <entry key="SettingObjectTypeEnumNotPermitted">''{0}''의 열거형 객체 유형은 읽기 전용이므로 설정할 수 없음</entry>
    <entry key="NoDStateNumInfoForModelRef">Discrete states linearization not supported for Model block ''{0}'' because it references a protected model from R2020b or earlier. </entry>
    <entry key="CannotLinearizeModelRefInAccelMode">Model 블록 ''{0}''에는 이산 상태 선형화가 지원되지 않습니다. 블록이 액셀러레이터 모드이기 때문입니다. </entry>
    <entry key="SfcnCannotUseDefaultDimsMethods_s">S-Function ''{0}''에 mdlSetInputPortDimensionInfo (mdlSetInputPortWidth) 및 mdlSetOutputPortDimensionInfo (mdlSetOutputPortWidth) 메서드가 없습니다. 이 S-Function은 디폴트 규칙을 따르지 않으므로 Simulink 디폴트 메서드를 사용하여 포트 너비 또는 차원을 설정할 수 없습니다. 위 메서드를 추가하여 S-Function을 업데이트하십시오. 이러한 메서드에 대한 자세한 내용은 ''Writing S-functions'' 문서에서 확인할 수 있습니다.</entry>
    <entry key="SfcnHasBothReuseAndssWriteRTW">S-Function ''{0}''에 옵션 SS_OPTION_WORKS_WITH_CODE_REUSE가 설정되어 있습니다. 그러나 이 S-Function은 자체 mdlRTW 함수에 ssWriteRTWParameters를 사용하고 있거나, ssSetSFcnParamTunable을 사용하여 명시적으로 파라미터 조정 가능 여부를 설정하지 않았습니다. 코드 재사용 기능과 호환되도록 하려면 S-Function에서 런타임 파라미터를 등록해야 합니다. 등록 방법에 대한 자세한 내용은 S-Function 문서를 참조하십시오.</entry>
    <entry key="SfcnInvalidOutputAsMatrix">S-Function ''{0}''의 mdlRTW에 오류가 있습니다. 더 이상 사용되지 않는 매크로를 사용하여 파라미터를 2차원 형식으로 .rtw 파일에 작성하고 있습니다. 2차원으로 파라미터를 작성하려면 S-Function을 업그레이드하여 런타임 파라미터를 등록해야 합니다. 이에 대한 예는 ''sfundemo''를 입력하여 나오는 런타임 파라미터 데모를 참조하십시오.</entry>
    <entry key="SfcnJacobianConfigButNoMethod">S-Function ''{0}''이(가) mdlSetWorkWidths 함수에 야코비 행렬 차원을 구성했지만, mdlJacobian 메서드를 구현하지 못했습니다.</entry>
    <entry key="SfcnJacobianMethodButNoConfig">S-Function ''{0}''이(가) mdlJacobian 메서드를 구현했지만 mdlSetWorkWidths 함수에 해당 야코비 행렬 차원을 구성하지 못했습니다.</entry>
    <entry key="SfcnJacobianMethodButNoIrJc">S-Function ''{0}''이(가) mdlJacobian 메서드를 구현했지만 mdlStart 함수에서 해당 야코비 행렬 구조체 (Ir, Jc)를 초기화하지 못했습니다.</entry>
    <entry key="SfcnMissingDefinedDimsDependRuleVarDims">''{1}''의 S-Function ''{0}''이(가) ''ssSetSignalSizesComputeType''을 SS_VARIABLE_SIZE_FROM_INPUT_SIZE로 선언했습니다. 따라서 ''ssAddOutputDimsDependencyRule'' 메서드를 사용하여 &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{0}"&gt;{2,number,integer}번 출력 포트&lt;/sldiag&gt;의 차원 종속성 규칙을 등록해야 합니다.</entry>
    <entry key="SfcnMissingReqTLCforSetVarDims">The S-function ''{0}'' in ''{1}'' does not have a TLC file. A TLC file is required for this S-function because the S-function has registered output dimension dependency rules for the support of variable-size signals.</entry>
    <entry key="SfcnMustHaveMdlDimsFcn_ss">S-Function ''{0}''에는 {1} 함수가 있어야 합니다.</entry>
    <entry key="SfcnRedundantDimsDepRule">The S-function ''{0}'' in ''{1}'' has registered a redundant output dimension dependency rule for &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{0}"&gt;output port {2,number,integer}&lt;/sldiag&gt;. The input index registered in rule {3,number,integer} is a subset or superset of an existing rule. For example, a rule that contains input index "0, 1" is redundant if another rule already contains the input index "0", "1" or "0, 1".</entry>
    <entry key="SfcnTsNotMatchGlbDSMTs">블록 ''{0}''은 샘플 시간 {1}을(를) 가집니다. 하지만 데이터 저장소 메모리 ''{2}''에 액세스하는데, 이 메모리의 Simulink.Signal 객체는 이와 충돌하는 샘플 시간 {3}을(를) 갖습니다.</entry>
    <entry key="SfsDomainMustBeFirst">{0} 기호 형식 문자열에 오류가 있습니다. 기호 형식 문자열에 영역 매크로 ''$D''가 지정된 경우 매크로는 기호 형식 문자열의 시작 부분에 와야 합니다.</entry>
    <entry key="SfsInvalid1stChar">Error in {0} Symbol Format String.  The first character specified must be a macro, alphabetic, or an underscore.</entry>
    <entry key="SfsInvalidChar">Error in {0} Symbol Format String.  ''{1}'' is not recognized as a valid macro or C-language identifier.</entry>
    <entry key="SfsInvalidMacro">Error in {0} Symbol Format String.  ''${1}'' is not recognized as a valid macro.</entry>
    <entry key="SfsMangleMacroCount">Error in {0} Symbol Format String.  There must be at least one and only one mangle macro ($M).</entry>
    <entry key="SfsMangleRequired">Error computing symbol names in model ''{0}''. The maximum identifier length ''{1,number,integer}'' does not provide sufficient space to make symbol names unique using the symbol format string ''{2}''. Consider increasing the maximum identifier length.</entry>
    <entry key="SfsMangleOrChange">Error computing symbol names in model ''{0}''. The following symbol ''{1}'' needs to be changed or mangled to make symbol names unique using the symbol format string ''{2}''. Consider changing one of the symbols or adding $M to the symbol format string.</entry>
    <entry key="SfsMangleOrChangeWithBlockPath">모델 ''{0}''에서 기호 이름을 계산하는 중 오류가 발생했습니다. 블록 ''{2}''에서 발생하는 다음 기호 ''{1}''을(를) 고유한 기호 이름을 갖도록 기호 형식 문자열 ''{3}''을(를) 사용하여 변경하거나 변형해야 합니다. 기호 중 하나를 변경하거나 기호 형식 문자열에 $M을 추가해 보십시오.</entry>
    <entry key="SfsNoMethod">Error in {0} Symbol Format String. Macro for method name ''$F'' is not supported in this symbol format string.</entry>
    <entry key="SfsNoRoot">{0} 기호 형식 문자열에 오류가 있습니다. 이 기호 형식 문자열에는 모델 이름 ''$R''에 대한 매크로가 지원되지 않습니다.</entry>
    <entry key="SfsNoSysId">Error in {0} Symbol Format String. Macro for system hierarchy number ''$H'' is not supported in this symbol format string.</entry>
    <entry key="SfsNoType">Error in {0} Symbol Format String. Macro for data type ''$A'' is not supported in this symbol format string.</entry>
    <entry key="SfsTooLong">{0} 기호 형식 문자열, 최대 식별자 길이, 최소 변형 길이 간의 설정이 호환되지 않습니다. 최대 식별자 길이는 예약된 길이(즉, {1,number,integer})와 최소 변형 길이, {2} 기호 형식 문자열의 리터럴 문자형 길이를 모두 합한 값보다 커야 합니다.</entry>
    <entry key="NamingRuleParsingError">기호 형식 문자열 ''{0}''을(를) 구문 분석할 수 없습니다. 명명 규칙의 부분문자열 ''{2}''에서 {1}이(가) 감지되었습니다.{3}</entry>
    <entry key="NamingRuleParsingEmptyRule">명명 규칙이 비어 있음</entry>
    <entry key="NamingRuleParsingInvalidToken">유효하지 않은 토큰임</entry>
    <entry key="NamingRuleParsingInvalidDecorator">유효하지 않은 데코레이터임</entry>
    <entry key="NamingRuleParsingUnclosedDecorator">데코레이터에 ']'가 누락됨</entry>
    <entry key="NamingRuleParsingUnexpectedOpenBracket">데코레이터에 예기치 않은 '['가 있음</entry>
    <entry key="NamingRuleParsingUnexpectedCloseBracket">데코레이터에 예기치 않은 ']'가 있음</entry>
    <entry key="NamingRuleParsingInvalidLiteral">유효하지 않은 기호임</entry>
    <entry key="ExtendedDecoratorNotAllowedOnUnsupportedToken">정규 표현식 기반 문자열 대체를 지원하는 데코레이터에서는 $N, $G 또는 $R만 사용할 수 있습니다.</entry>
    <entry key="DecoratorParsingError">토큰 데코레이터 ''{0}''을(를) 구문 분석할 수 없습니다.{1}</entry>
    <entry key="DecoratorParsingNoBackSlash">'/' 구분 기호가 발견되지 않았습니다.</entry>
    <entry key="DecoratorParsingTooManyBackSlashes">'/' 구분 기호가 3개 이상 발견되었습니다.</entry>
    <entry key="DecoratorParsingWrongPrefix">문자열은 'r' 또는 'r/'로 시작해야 합니다.</entry>
    <entry key="DecoratorParsingEmptySpecId">사양 ID가 비어 있습니다.</entry>
    <entry key="DecoratorParsingInvalidIdentifierCharacter">식별자에는 ''{0}''을(를) 사용할 수 없습니다.</entry>
    <entry key="DecoratorParsingIdentifierStartsWithNumber">식별자가 숫자 ''{0}''(으)로 시작합니다.</entry>
    <entry key="RegexprepDecoratorOptionsParsingError">토큰 데코레이터 옵션 문자열 ''{0}''을(를) 구문 분석할 수 없습니다.{1}</entry>
    <entry key="RegexprepDecoratorOptionNotApplicable">옵션 ''{0}''을(를) 적용할 수 없습니다.{1}</entry>
    <entry key="RegexprepDecoratorOptionUnknownOption">알 수 없는 옵션입니다.</entry>
    <entry key="RegexprepDecoratorOptionConflictingOption">''{0}''은(는) 이전 옵션 ''{1}''과(와) 호환되지 않습니다.</entry>
    <entry key="SfsMangleTooLong">변형 길이는 15자를 초과할 수 없습니다.</entry>
    <entry key="SfsChecksumTooLong">Shared Checksum Length cannot exceed 15 characters.</entry>
    <entry key="SignalBasedLinearizationBusNotSupported">신호 기반 선형화를 수행할 경우 버스 신호에 배치되는 IO 점에 대해 모델 파라미터 ''InjectionData''의 ''BusSignalName'' 필드가 비어 있어서는 안 됩니다.</entry>
    <entry key="SignalBasedLinearizationInvalidInjectionData">The model parameter ''InjectionData'' is invalid. It is required that the model parameter ''InjectionData'' is either empty, a double array of port handles or a MATLAB structure with fields ''PortHandle'', ''InputWKSVariable'', ''OutputWKSVariable'' and ''SignalInjectionData''. ''SignalInjectionData'' field is required to be another structure with fields ''IOType'', ''DataType'', ''Dimensions'', ''PortDataSize'', ''SampleTime'', ''BusSignalName'', ''SignalIndex''.</entry>
    <entry key="IdentifierLengthDiagnosticTableHeaderIdentifier">식별자</entry>
    <entry key="IdentifierLengthDiagnosticTableHeaderType">유형</entry>
    <entry key="IdentifierLengthDiagnosticTableHeaderFormat">형식</entry>
    <entry key="IdentifierLengthDiagnosticSuggestedActionGRT">
      최대 식별자 길이 설정을 충족하기 위해 모델 ''{0}''의 식별자가 잘렸습니다. 식별자 길이는 {1}자를 초과할 수 없습니다. {2} &lt;actions exclusiveFixIts="no"&gt; &lt;action type="fixit" id="EliminateMessage"&gt; &lt;cmd&gt;Simulink.ModelReference.internal.ModelRefFixes(''DisableIdentifierLengthMessage'',''{0}'',''none'')&lt;/cmd&gt; &lt;txt&gt;이 메시지를 다시 표시하지 않습니다.&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" id="HelpMaxIdentifierLength"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''MaxIdLength'')&lt;/cmd&gt; &lt;txt&gt;최대 식별자 길이를 늘리십시오(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음).&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="IdentifierLengthDiagnosticSuggestedActionERT">
      최대 식별자 길이 설정을 충족하기 위해 모델 ''{0}''의 식별자가 잘렸습니다. 식별자 길이는 {1}자를 초과할 수 없습니다. {2} &lt;actions exclusiveFixIts="no"&gt; &lt;action type="fixit" id="EliminateMessage"&gt; &lt;cmd&gt;Simulink.ModelReference.internal.ModelRefFixes(''DisableIdentifierLengthMessage'',''{0}'',''none'')&lt;/cmd&gt; &lt;txt&gt;이 메시지를 다시 표시하지 않습니다.&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" id="HelpMaxIdentifierLength"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''MaxIdLength'')&lt;/cmd&gt; &lt;txt&gt;최대 식별자 길이를 늘리십시오(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음).&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" id="HelpStringFormat"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''CustomSymbolStrGlobalVar'')&lt;/cmd&gt; &lt;txt&gt;식별자 형식을 변경하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="IdentifierLengthDiagnosticSuggestedActionGRTError">
      최대 식별자 길이 설정을 충족하기 위해 모델 ''{0}''의 식별자를 잘라야 합니다. 식별자 길이는 {1}자를 초과할 수 없습니다. {2} &lt;actions exclusiveFixIts="no"&gt; &lt;action type="fixit" id="EliminateMessage"&gt; &lt;cmd&gt;Simulink.ModelReference.internal.ModelRefFixes(''DisableIdentifierLengthMessage'',''{0}'',''none'')&lt;/cmd&gt; &lt;txt&gt;이 메시지를 다시 표시하지 않습니다.&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" id="HelpMaxIdentifierLength"&gt; &lt;cmd&gt;configset.internal.open(''{0}'',''MaxIdLength'')&lt;/cmd&gt; &lt;txt&gt;최대 식별자 길이를 늘리십시오(참조된 모델 또는 참조하는 모델에 영향을 줄 수 있음).&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="IdentifierLengthDiagnosticSuggestedActionERTError">
      Identifiers for model ''{0}'' must be truncated to satisfy maximum identifier length setting. 
      Identifier length must not exceed {1} characters. {2} 
      
      &lt;actions exclusiveFixIts="no"&gt;
          &lt;action type="fixit" id="EliminateMessage"&gt;
            &lt;cmd&gt;Simulink.ModelReference.internal.ModelRefFixes(''DisableIdentifierLengthMessage'',''{0}'',''none'')&lt;/cmd&gt;
            &lt;txt&gt;Do not show this message again.&lt;/txt&gt;
          &lt;/action&gt;
          &lt;action type="suggestion" id="HelpMaxIdentifierLength"&gt;
            &lt;cmd&gt;configset.internal.open(''{0}'',''MaxIdLength'')&lt;/cmd&gt;
            &lt;txt&gt;Increase maximum identifier length which might impact referenced or referencing models.&lt;/txt&gt;
          &lt;/action&gt;
          &lt;action type="suggestion" id="HelpStringFormat"&gt;
            &lt;cmd&gt;configset.internal.open(''{0}'',''CustomSymbolStrGlobalVar'')&lt;/cmd&gt;
            &lt;txt&gt;Change identifier format.&lt;/txt&gt;
          &lt;/action&gt;
        &lt;/actions&gt;
    </entry>
    <entry key="IdentifierLengthDiagnosticMessageReportAction">명령 set_param(''{0}'',''ModelReferenceSymbolNameMessage'',''none'')이 실행되었습니다.</entry>
    <entry key="SignalDataNotReusableSC">The storage class of the signal connected to &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is global, thus the generated code is not reusable.  Consider using storage class ''Auto'', setting &lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;Code interface packaging&lt;/sldiag&gt; to ''Nonreusable function'', or setting &lt;sldiag objui="configset" objparam="MultiInstanceErrorCode"&gt;Multi-instance code error diagnostic&lt;/sldiag&gt; to ''None'' or ''Warning''</entry>
    <entry key="SignalDimNotReusableSC">모델은 재사용 가능한 코드를 생성할 수 없습니다. ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 신호의 스토리지 클래스가 전역 클래스이고 가변 크기 차원을 갖습니다. 신호의 스토리지 클래스 ''Auto''를 사용하거나, 모델의 &lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;코드 인터페이스 패키징&lt;/sldiag&gt;을 ''재사용 불가 함수''로 설정해 보십시오.</entry>
    <entry key="RootOutportSignalDataNotReusableSC">루트 아웃포트 ''{0}''의 스토리지 클래스가 전역 클래스이기 때문에 생성된 코드를 재사용할 수 없습니다. 스토리지 클래스 ''자동''을 사용하거나, 옵션 ''코드 인터페이스 패키징''을 ''재사용 불가 함수''로 설정하거나, 구성 파라미터 &gt; 코드 생성 &gt; 인터페이스 창에서 옵션 ''다중 인스턴스 코드 진단''을 ''안 함'' 또는 ''경고''로 설정해 보십시오.</entry>
    <entry key="InvalidSettingInLinearAnalysisIOBusElement">Cannot find the bus element for the given bus element in the linearization IO specification. </entry>
    <entry key="ArrayOfBusesLinearAnalysisIOBusElement">배열 내 버스의 요소에 선형화 분석점을 설정할 수 없습니다.</entry>
    <entry key="LinearAnalysisIOBusElementOnNonBusSignal">Cannot set linearization analysis point using bus elements on a non-bus signal.</entry>
    <entry key="DuplicatedLinearAnalysisIOOnInport">Cannot set multiple linearization I/O points on the duplicated ports of ''{0}''.</entry>
    <entry key="LinearAnalysisIOOnDuplicateInportWarning">''{0}'' 또는 이에 대한 중복 포트에 선형화 I/O 점이 지정되어 있습니다. 이 선형화 I/O 점은 중복 포트와 마스터 포트의 모든 경로를 고려하게 됩니다.</entry>
    <entry key="SignalBasedLinearizationIOOnABus">신호 기반 선형화에서는 버스 신호를 I/O 점으로 사용할 수 없습니다.</entry>
    <entry key="SignalDimsLargerThan32">The number of dimensions specified in ''{0}'' exceeds the maximum (32).</entry>
    <entry key="SignalWidthLargerThanProductLongIntSize">The size of &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' exceeds the embedded hardware long int size (''{2,number,integer}'' bits) or the test hardware long int size (''{3,number,integer}'' bits). This can cause overflows during execution.</entry>
    <entry key="SigobjConsistencyDWork">Signal attribute inconsistency found on the state of block ''{0}'', where the state attribute does not match the signal object ''{1}'' referenced by the state:\n   State attribute ({2}): {3}\n   Object setting ({4}): {5}</entry>
    <entry key="SigobjConsistencyDWork2">Signal attribute inconsistency found on the state of block ''{0}'', where the block attribute does not match the signal object ''{1}'' referenced by the state:\n   Block attribute ({2}): {3}\n   Object setting ({4}): {5}</entry>
    <entry key="SigobjConsistencyPort">블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에서 신호 특성 불일치가 발견되었습니다. 포트 설정이 블록 ''{4}''의 &lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;{3,number,integer}번 출력 포트&lt;/sldiag&gt;에 있는 signal 객체 ''{2}''과(와) 일치하지 않습니다.\n 포트 설정({5}): {6}\n 객체 설정({7}): {8}</entry>
    <entry key="SimCantChangeBDPropDuringExtModeSim">Cannot change the ''{0}'' parameter while the model ''{1}'' is running in External Mode</entry>
    <entry key="SimCantChangeBDPropDuringSim">모델 ''{1}''이(가) 실행 중인 동안에는 ''{0}'' 파라미터를 변경할 수 없음</entry>
    <entry key="SimCantChangeBDPropInFastRestart">모델 ''{1}''이(가) [빠른 재시작]에서 초기화된 경우에는 ''{0}'' 파라미터를 변경할 수 없음</entry>
    <entry key="SimCantChangeInputGlobalAttrDuringSim">시뮬레이션이 실행 중일 때는 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;의 전역 특성을 변경할 수 없음</entry>
    <entry key="SimCantChangeInputReusableAttrDuringSim">시뮬레이션이 실행 중일 때는 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;의 재사용 가능한 특성을 변경할 수 없음</entry>
    <entry key="SimCantChangeOutputReusableAttrDuringSim">시뮬레이션이 실행 중일 때는 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;의 재사용 가능한 특성을 변경할 수 없음</entry>
    <entry key="SimCantChangeOutputTestPointAttrDuringSim">시뮬레이션이 실행 중일 때는 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;의 테스트 지점 특성을 변경할 수 없음</entry>
    <entry key="SimCantChangeOverWritableAttrDuringSim">시뮬레이션이 실행 중일 때는 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;의 덮어쓰기 가능한 특성을 변경할 수 없음</entry>
    <entry key="SimOptInitStepTooLarge">초기 스텝 크기({0})가 최대 스텝 크기({1})보다 큼</entry>
    <entry key="SimOptInitStepTooSmall">초기 스텝 크기({0})가 최소 스텝 크기({1})보다 작음</entry>
    <entry key="SimOptMinEqualToMax">최대 스텝 크기({0})가 최소 스텝 크기({1})와 같습니다. 고정 스텝 크기 문제의 경우 고정 스텝 솔버를 사용하십시오</entry>
    <entry key="SimOptMinLargerThanMax">최대 스텝 크기({0})는 최소 스텝 크기({1})보다 커야 함</entry>
    <entry key="SimOptMinLargerThanSample">최소 스텝 크기({0})가 이산 샘플링 주기({1})보다 큼</entry>
    <entry key="SimOptMinLargerThanTotalTime">최소 스텝 크기({0})가 전체 시간 구간({1})보다 큽니다. 최소 스텝 크기를 줄이십시오</entry>
    <entry key="SimOptMinStepIgnoredInVarStepDisc">모델에서 가변 스텝 이산 솔버를 사용 중이기 때문에 최소 스텝 크기({0})가 무시됨</entry>
    <entry key="SimOptRelTolTooSmall">상대 허용오차 값 {0}은(는) 너무 작습니다. 상대 허용오차가 {1}(으)로 설정됩니다.</entry>
    <entry key="SimStatusBuilding">빌드 중</entry>
    <entry key="SimStatusBuildingAsModelRef">참조된 모델로 빌드 중</entry>
    <entry key="SimStatusExternal">외부</entry>
    <entry key="SimStatusExternalAsModelRef">참조된 모델로 외부</entry>
    <entry key="SimStatusExternalAsNormalModelRef">외부 시뮬레이션에 연결되지 않은 참조된 모델</entry>
    <entry key="SimStatusInitializing">초기화 중</entry>
    <entry key="SimStatusRestarting">다시 시작하는 중</entry>
    <entry key="SimStatusInitializingAsModelRef">참조된 모델로 초기화하는 중</entry>
    <entry key="SimStatusRestartingAsModelRef">참조된 모델로 다시 시작하는 중</entry>
    <entry key="SimStatusPaused">일시 중지됨</entry>
    <entry key="SimStatusPausedAsModelRef">참조된 모델로 일시 중지됨</entry>
    <entry key="SimStatusPausedInDebugger">디버거에서 일시 중지됨</entry>
    <entry key="SimStatusPausedInDebuggerAsModelRef">디버거에서 참조된 모델로 일시 중지됨</entry>
    <entry key="SimStatusCompiled">컴파일됨</entry>
    <entry key="SimStatusCompiledAsModelRef">참조된 모델로 컴파일됨</entry>
    <entry key="SimStatusRunning">실행 중</entry>
    <entry key="SimStatusRunningAsModelRef">참조된 모델로 실행하는 중</entry>
    <entry key="SimStatusPacingUtilization">: {0,number,integer} 사용률</entry>
    <entry key="SimStatusPacingOverrun">: 속도 조절할 수 없음</entry>
    <entry key="SimStatusPacingPollMode">속도 조절 중(폴링){0}</entry>
    <entry key="SimStatusPacingPollModeAsModelRef">참조된 모델로 속도를 조절하는 중(폴링){0}</entry>
    <entry key="SimStatusPacingSleepMode">속도 조절 중(절전){0}</entry>
    <entry key="SimStatusPacingSleepModeAsModelRef">참조된 모델로 속도를 조절하는 중(절전){0}</entry>
    <entry key="SimStatusStopped">중지됨</entry>
    <entry key="SimStatusStoppedAsModelRef">참조된 모델로 중지됨</entry>
    <entry key="SimStatusTerminating">종단 중</entry>
    <entry key="SimStatusTerminatingAsModelRef">참조된 모델로 종단하는 중</entry>
    <entry key="SimStatusUpdating">업데이트 중</entry>
    <entry key="SimStatusUpdatingAsModelRef">참조된 모델로 업데이트하는 중</entry>
    <entry key="SimStatusCanceling">취소 중</entry>
    <entry key="SimStatusCancel">취소</entry>
    <entry key="SimIsStoppedDuringConditionalStopRequest">비활성 시뮬레이션을 조건부로 중지할 수 없음</entry>
    <entry key="PortTypePropagationStatusPausing">일시 중지 중</entry>
    <entry key="PortTypePropagationPause">일시 중지</entry>
    <entry key="PortTypePropagationPauseTooltip">복소수 포트 도메인 유형 전파를 일시 중지합니다</entry>
    <entry key="PortTypePropagationStatusMsgInProgress">포트 도메인 유형 전파: 진행 중</entry>
    <entry key="PortTypePropagationStatusMsgPaused">포트 도메인 유형 전파: 복소수 연결을 위해 일시 중지됨</entry>
    <entry key="PortTypePropagationStatusResuming">재개 중</entry>
    <entry key="PortTypePropagationResume">재개</entry>
    <entry key="PortTypePropagationResumeTooltip">복소수 포트 도메인 유형 전파를 재개합니다</entry>
    <entry key="PortTypePropagation">포트 도메인 유형 전파</entry>
    <entry key="PortTypePropagationPaused">일시 중지됨</entry>
    <entry key="StopRequestedBy">{0}에 의해 중지가 요청되었습니다.</entry>
    <entry key="StopCommandIssued">stop 명령을 통해 시뮬레이션이 중지됨</entry>
    <entry key="ReachedStopTime">중지 시간 {0}에 도달함</entry>
    <entry key="SimulationTimedOut">시뮬레이션이 시간 초과됨</entry>
    <entry key="StartTimeGreaterThanStop">시작 시간이 중지 시간보다 큼</entry>
    <entry key="SimTypeMismatch">모델 ''{0}''은(는) 현재 시뮬레이션 유형 ''{1}''에 대해 컴파일되었습니다. 모델을 지정된 시뮬레이션 유형 ''{2}''에 대해 컴파일하려면 현재 컴파일 작업을 종료해야 합니다.</entry>
    <entry key="SimViewingDeviceNotAtomic">''{0}'' is specified as a ''SimViewingDevice'' but it is not atomic. Subsystems that are ''SimViewingDevices'' must be atomic</entry>
    <entry key="SimulationCommandInNoDisplay">Issuing simulation commands using the set_param function is not supported for MATLAB sessions that do not have a display, such as MATLAB sessions started using the -nodisplay option.</entry>
    <entry key="SimCommandInModelAPI">'SimulationCommand' action using set_param function is not supported for models compiled using the model function.</entry>
    <entry key="SingularJacobian" context="error">연립 미분대수 방정식의 지수가 1이 아니거나 대수 방정식의 제약 조건이 지나치게 적거나 많기 때문에 블록 ''{0}''을(를) 포함하는 대수 루프에 대해 시간 {1}에서 특이 야코비 행렬이 계산되었습니다. ''고정 스텝 크기(기본 샘플 시간)'' 또는 ''상대 허용오차'' 파라미터 값을 줄여 솔버가 취하는 스텝 크기를 줄여 보십시오.</entry>
    <entry key="SlType_IndexOutOfRange">인덱스 값이 범위를 벗어남</entry>
    <entry key="SlType_InvalidElementName">요소 이름이 유효하지 않음</entry>
    <entry key="NeedsToUseDAEOrAutoSolver"> 모델 "{0}"이(가) 동적 방정식과 대수 방정식을 모두 포함합니다. 이러한 방정식을 생성하는 Descriptor State-Space 블록이 포함되어 있을 수 있습니다. 솔버를 DAE 솔버(예: ode15s, ode23t, ode14x, ode1be 또는 자동 솔버)로 전환하십시오.</entry>
    <entry key="ODENNeedsImplicitIntegrationMethod"> 모델 "{0}"이(가) 동적 방정식과 대수 방정식을 모두 포함합니다. 이러한 방정식을 생성하는 Descriptor State-Space 블록이 포함되어 있을 수 있습니다. 이 모델을 시뮬레이션하려면 ODEN이 ode14x 또는 ode1be와 같은 음함수 적분 방법을 사용해야 합니다.</entry>
    <entry key="SaveWithDisabledLinks_Warning">Block diagram ''{0}'' contains disabled library links.  
    Use Model Advisor to find the disabled links in non-library models.  The diagram has been saved but may not contain what you intended.
    
    &lt;actions exclusiveFixIts="yes"&gt;
    &lt;action type="suggestion"&gt;
      &lt;cmd&gt;editedlinkstool('Create',''{0}'',0);&lt;/cmd&gt;
      &lt;txt&gt;You can restore or push the disabled links in the model using the Library Link Tool.&lt;/txt&gt;
      &lt;/action&gt;
    &lt;/actions&gt;
    
    </entry>
    <entry key="SaveWithParameterizedLinks_Warning">
      블록 다이어그램 ''{0}''이(가) 하나 이상의 파라미터화된 라이브러리 링크를 포함합니다. 파라미터화된 링크를 찾으려면 모델 어드바이저를 사용하십시오. 다이어그램이 저장되었지만 의도한 대로 동작하지 않을 수 있습니다. 파라미터화된 링크에 대한 지원은 향후 릴리스에서 제거될 예정입니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;editedlinkstool('Create',''{0}'',1);&lt;/cmd&gt; &lt;txt&gt;라이브러리 링크 도구를 사용하여 모델에서 파라미터화된 링크를 복원하거나 밀어넣을 수 있습니다.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
      
    </entry>
    <entry key="SlvrJacobianMethodCorrected">The ''Solver Jacobian method''
        specified is ''{0}'', however Simulink has chosen the ''{1}'' method because {3}
        
          &lt;actions exclusiveFixIts="yes"&gt;
          &lt;action type="fixit"&gt;
              &lt;cmd&gt;set_param(''{2}'',''SolverJacobianMethodControl'',''{1}'');&lt;/cmd&gt;
              &lt;txt&gt;You can disable this diagnostic by explicitly setting the 
                   &lt;sldiag objui="configset" objparam="SolverJacobianMethodControl"&gt;Solver 
                   Jacobian method&lt;/sldiag&gt; to ''{1}''.&lt;/txt&gt;
          &lt;/action&gt;
          &lt;action type="suggestion" btn="apply"&gt;
          &lt;cmd&gt;set_param(''{2}'',''SolverPrmCheckMsg'',''none'');&lt;/cmd&gt;
          &lt;txt&gt;Set &lt;sldiag objui="configset" objparam="SolverPrmCheckMsg"&gt;Automatic
               solver parameter selection&lt;/sldiag&gt; diagnostic to ''none''.&lt;/txt&gt;
          &lt;/action&gt;
      &lt;/actions&gt;
        </entry>
    <entry key="SlvrJacobianPatternNotSupported">slvrJacobian 패턴 정보를 가져오려면 모델 ''{0}''의 솔버가 음함수 솔버여야 하고 희소 형식의 야코비 방법을 사용해야 합니다.</entry>
    <entry key="SlvrAnalyticJacobianPatternNotSupported">해석적 선형화를 사용하여 모델 "{0}"에 대한 솔버 야코비 행렬 패턴을 가져올 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="SlvrAnalyticJacobianPatternNotSupportedFix" retvalue="false"&gt; &lt;cmd&gt;set_param(''{0}'',''AnalyticLinearization'',''off'');&lt;/cmd&gt; &lt;txt&gt;모델 "{0}"에 대해 해석적 선형화를 비활성화하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    
    </entry>
    <entry key="SlvrAnalyticJacobianValueNotSupported">해석적 선형화를 사용하여 모델 "{0}"에 대한 솔버 야코비 행렬 값을 가져올 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="SlvrAnalyticJacobianValueNotSupportedFix" retvalue="false"&gt; &lt;cmd&gt;set_param(''{0}'',''AnalyticLinearization'',''off'');&lt;/cmd&gt; &lt;txt&gt;모델 "{0}"에 대해 해석적 선형화를 비활성화하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    
    </entry>
    <entry key="SlvrJacobianValueNotSupported">slvrJacobian 값 정보를 가져오려면 모델 ''{0}''의 솔버가 음함수 솔버여야 합니다. 값 A B C D를 가져오려면 해석적 야코비 방법을 사용해야 합니다.</entry>
    <entry key="MassMatrixNotSupported">There is no mass matrix for model ''{0}''.</entry>
    <entry key="SolverConsecutiveZCNum">At time {0}, simulation hits
      ({1,number,integer}) consecutive zero crossings. Consecutive zero
      crossings will slow down the simulation or cause the simulation to
      hang.
      &lt;actions exclusiveFixIts="no"&gt;
          &lt;action type="fixit"&gt;
          &lt;cmd&gt;set_param(''{3}'',''ZeroCrossAlgorithm'',''Adaptive'');&lt;/cmd&gt;
          &lt;txt&gt;Try changing &lt;sldiag objui="configset" objparam="ZeroCrossAlgorithm"&gt;zero-
               crossing detection algorithm&lt;/sldiag&gt; to ''Adaptive''. When using the 
               adaptive algorithm, you can turn off this message by setting the 
               &lt;sldiag objui="configset" objparam="MaxConsecutiveZCsMsg"&gt;Consecutive 
               zero-crossings violation&lt;/sldiag&gt; diagnostic to ''none''.&lt;/txt&gt;
      &lt;/action&gt;
      &lt;action type="suggestion"&gt;
      &lt;txt&gt;Disable the zero crossing of the blocks shown in the following table. \n
      {2}&lt;/txt&gt;
      &lt;/action&gt;
      &lt;action type="suggestion" btn="apply"&gt;
      &lt;cmd&gt;set_param(''{3}'',''MaxConsecutiveZCsMsg'',''none'');&lt;/cmd&gt;
      &lt;txt&gt;To disable this diagnostic, set &lt;sldiag objui="configset" objparam=
           "MaxConsecutiveZCsMsg"&gt;Consecutive zero-crossings violation&lt;/sldiag&gt; diagnostic 
           to ''none''&lt;/txt&gt;
      &lt;/action&gt;
      &lt;/actions&gt;
      </entry>
    <entry key="SolverDerivConsistencyCheckFailure">Simulation of ''{0}'' causes derivative consistency check failure at time {1}</entry>
    <entry key="SolverIgnoredZCBracketing"> The simulation has ignored searching
      for zero-crossing events at time {0} for ({1,number,integer}) zero crossing
      signals. These signals are being ignored either because their values are
      smaller than the zero crossing tolerance, or because they caused multiple
      consecutive zero crossings. This indicates your system has strong chattering. \n
      {2}
      &lt;actions exclusiveFixIts="yes"&gt;
      &lt;action type="suggestion" btn="apply"&gt;
      &lt;cmd&gt;set_param(''{3}'',''IgnoredZcDiagnostic'',''none'');&lt;/cmd&gt;
      &lt;txt&gt;To disable this diagnostic, set &lt;sldiag objui="configset" objparam=
           "IgnoredZcDiagnostic"&gt;Ignored zero crossings&lt;/sldiag&gt; diagnostics to ''none''&lt;/txt&gt;
      &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="SolverMaskedZC">시간 {0}에 시뮬레이션에서 ({1,number,integer})개의 마스크 처리된 영점교차(즉, 짝수의 영점교차 이벤트를 갖는 신호)를 발견했습니다. 이 시간 스텝에 다른 영점교차가 있기 때문에 검색 알고리즘에 이러한 영점교차만 감지되었습니다. 마스크 처리된 영점교차는 현재 시간 스텝에 짝수의 영점교차를 갖는 하나 이상의 영점교차 신호에 의해 발생합니다. 마스크 처리된 영점교차는 경우에 따라 감지되지 않을 수 있습니다. \n {3} &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;configset.internal.open(''{4}'',''Refine'')&lt;/cmd&gt; &lt;txt&gt;''세분화 인자''를 ({2,number,integer})에서 더 큰 값으로 높이기&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" btn="apply"&gt; &lt;cmd&gt;set_param(''{4}'',''MaskedZcDiagnostic'',''none'');&lt;/cmd&gt; &lt;txt&gt;이 진단을 비활성화하려면 &lt;sldiag objui="configset" objparam= "MaskedZcDiagnostic"&gt;마스크 처리된 영점 교차&lt;/sldiag&gt;를 ''안 함''으로 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="SolverMaxConsecutiveMinStepsViolated">시간 {2}에서 연속된 {1,number,integer}개의 시간 값 동안 최소 스텝 크기 {0}를 위반하지 않고 스텝 크기를 줄일 수 없습니다. 시뮬레이션이 중지되었습니다. 대개 이 현상은 시스템의 높은 경직성으로 인해 발생할 수 있습니다. 모델 ''{3}''을(를) 확인하거나 &lt;sldiag objui="configset" objparam="MaxConsecutiveMinStep"&gt;연속된 최소 스텝 수&lt;/sldiag&gt;를 늘리십시오.</entry>
    <entry key="SolverMaxConsecutiveMinStepsViolatedForDAE">시간 {2}에서 연속된 {1,number,integer}개의 시간 값 동안 최소 스텝 크기 {0}를 위반하지 않고 스텝 크기를 줄일 수 없습니다. 시뮬레이션이 중지되었습니다. 대개 이 현상은 연립미분대수방정식의 대수 제약 조건을 위반하거나 시스템의 높은 경직성으로 인해 발생할 수 있습니다. 오차 허용오차 및/또는 모순 없는 조건 계산을 위한 허용오차를 좁혀 보십시오. 문제가 지속되는 경우 모델 ''{3}''을(를) 확인하거나 &lt;sldiag objui="configset" objparam="MaxConsecutiveMinStep"&gt;연속된 최소 스텝 수&lt;/sldiag&gt;를 늘리십시오.</entry>
    <entry key="SolverMinStepErr">Unable to reduce the step size without violating a minimum step size of {0} at time {1} for model ''{2}''</entry>
    <entry key="SolverMinStepNonlinearIterWarnForDAE">
     시간 {2}에서 연속된 {1,number,integer}개의 시간 값 동안 최소 스텝 크기 {0}를 위반하지 않고 스텝 크기를 줄일 수 없습니다. 대개 이 현상은 연립미분대수방정식의 대수 제약 조건을 위반하거나 시스템의 높은 경직성으로 인해 발생할 수 있습니다. 오차 허용오차 및/또는 모순 없는 조건 계산을 위한 허용오차를 좁혀 보십시오. 문제가 지속되는 경우 모델 ''{3}''을(를) 확인하거나 &lt;sldiag objui="configset" objparam="MaxConsecutiveMinStep"&gt;연속된 최소 스텝 수&lt;/sldiag&gt;를 늘리십시오. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;solverprofiler.launchSolverProfiler&lt;/cmd&gt; &lt;txt&gt;솔버 프로파일러를 열어 이러한 문제를 확인하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="SolverMinStepSizeCausedByShapePreserveErr">시간 {1}에서 최소 스텝 크기 {0}를 위반하지 않고는 상태 형태 보존 제약 조건을 충족하도록 스텝 크기를 줄일 수 없습니다.</entry>
    <entry key="SolverMinStepSizeCausedByShapePreserveWarn">시간 {1}에서 최소 스텝 크기 {0}를 위반하지 않고는 상태 형태 보존 제약 조건을 충족하도록 스텝 크기를 줄일 수 없습니다. 상태 형태 보존 제약 조건을 충족하도록 스텝 크기를 {2}(으)로 제한한 상태에서 시뮬레이션이 계속되고 1차 오일러 적분 방법이 사용됩니다.</entry>
    <entry key="SolverMinStepSizeWarn">Unable to reduce the step size without violating minimum step size of {0} for {1,number,integer} consecutive times at time {2}.  Continuing simulation with the step size restricted to {3} and using an effective relative error tolerance of {4}, which is greater than the specified relative error tolerance of {5}. This usually may be caused by the high stiffness of the system. Please check the model ''{6}'' or increase &lt;sldiag objui="configset" objparam="MaxConsecutiveMinStep"&gt;Number of consecutive min steps&lt;/sldiag&gt;</entry>
    <entry key="SolverMinStepSizeWarnForDAE">
     Unable to reduce the step size without violating minimum step size of {0} for {1,number,integer} consecutive times at time {2}.  Continuing simulation with the step size restricted to {3} and using an effective relative error tolerance of {4}, which is greater than the specified relative error tolerance of {5}. This usually may be caused by violating algebraic constraints in the differential-algebraic system or by the high stiffness of the system. Try tightening the error tolerances, and/or the tolerances for computing consistent conditions. If the problem persists, please check the model ''{6}'' or increase &lt;sldiag objui="configset" objparam="MaxConsecutiveMinStep"&gt;Number of consecutive min steps&lt;/sldiag&gt;.
     &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="suggestion"&gt;
            &lt;cmd&gt;solverprofiler.launchSolverProfiler&lt;/cmd&gt;
            &lt;txt&gt;Open Solver Profiler to explore such issues&lt;/txt&gt;
        &lt;/action&gt;
     &lt;/actions&gt;
    </entry>
    <entry key="SolverNonlIterMinStepErr">
     Nonlinear iteration is not converging with step size reduced to hmin ({0}) at time {1}.  Try reducing the minimum step size and/or relax the relative error tolerance
     &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="suggestion"&gt;
            &lt;cmd&gt;solverprofiler.launchSolverProfiler&lt;/cmd&gt;
            &lt;txt&gt;Open Solver Profiler to explore such issues&lt;/txt&gt;
        &lt;/action&gt;
     &lt;/actions&gt;
    </entry>
    <entry key="SolverOutputAssertConsoleErrMsg">''{3}''의 {2,number,integer}번 포트의 출력 요소 {1,number,integer}에 대한 출력 일관성 검사가 시간 {0}에서 실패함\n</entry>
    <entry key="SolverOutputAssertDlgErrMsg">Simulation of ''{0}'' terminated due to output inconsistencies</entry>
    <entry key="SolverOutputAssertForDblsConsoleErrMsg">''{3}''의 {2,number,integer}번 포트의 출력 요소 {1,number,integer}에 대한 출력 일관성 검사가 시간 {0}에서 실패함\n 예상 값: {4}\n 실제 값: {5}\n</entry>
    <entry key="SolverStateConsistencyCheckFailure">''{0}'' 시뮬레이션으로 인해 시간 {1}에서 상태 일관성 검사가 실패했습니다.</entry>
    <entry key="SolverZCConsistencyCheckFailure">
     Simulation of ''{0}'' causes zero crossing consistency check failure at time {1}
     &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="suggestion"&gt;
            &lt;cmd&gt;solverprofiler.launchSolverProfiler&lt;/cmd&gt;
            &lt;txt&gt;Open Solver Profiler to explore such issues&lt;/txt&gt;
        &lt;/action&gt;
     &lt;/actions&gt;
    </entry>
    <entry key="SortAlgLoopThruIntegrator" context="warning">Integrator 블록의 재설정 또는 초기 조건 포트가 하나 이상의 대수 루프 경로의 일부이므로 예기치 않거나 직관적이지 않은 시뮬레이션 결과가 발생할 수 있습니다. Integrator 블록 사용 시 대수 루프를 방지하려면 상태 포트를 사용하십시오.</entry>
    <entry key="SortDiscontinuityInAlgLoop" context="warning">하나 이상의 대수 루프에서 불연속이 감지되었습니다. 대수 루프 솔버가 루프의 해를 구하지 못할 수 있습니다.</entry>
    <entry key="SortICInAlgLoop" context="warning">IC 블록 ''{0}''이(가) ''{1}'' ''{2}''에 의해 구동되므로 대수 루프의 일부인 IC 블록 ''{0}''을(를) 무시합니다.</entry>
    <entry key="SourceLoopError">신호 차원을 확인할 수 없습니다. 신호 차원이 순환 관계로 정의되어 확인이 불가능한 ''{0}''(으)로 구성된 루프가 있습니다. Inport, Mux, Selector, Demux에 신호 차원을 지정하면 루프의 신호 차원을 확인하는 데 도움이 됩니다. Signal Specification을 사용하여 신호 차원을 정의할 수도 있습니다.</entry>
    <entry key="SrcsCannotHaveDynamicDimensionsMode">Source ''{0}'' cannot have inherited dimension mode setting for its output port {1,number,integer}. All output ports of all sources should be set explicitly to fixed-size mode or variable-size mode.</entry>
    <entry key="SrcsCannotHaveDynamicFrameData">소스 ''{0}''의 {1,number,integer}번 출력 포트에 동적 프레임 데이터(SamplingMode 상속)를 설정할 수 없습니다. 모든 소스는 자신의 모든 출력 포트를 FRAME_YES(프레임) 또는 FRAME_NO(샘플)로 명시적으로 설정해야 합니다.</entry>
    <entry key="StandaloneNoCStates">서브시스템 ''{0}''이(가) 별도의 데이터와 초기화를 갖는 함수로 구성되었습니다. 이 구성을 사용하는 서브시스템에는 연속 상태가 포함되지 않을 수 있습니다. 서브시스템 블록에서 ''별도의 데이터 및 초기화'' 옵션을 선택 취소하십시오.</entry>
    <entry key="StandaloneNoContTime">서브시스템 ''{0}''이(가) 별도의 데이터와 초기화를 갖는 함수로 구성되었고, 연속 샘플 시간을 갖는 블록을 포함하고 있습니다. 이 구성을 사용하는 서브시스템은 이산 샘플 시간만 가져야 합니다.</entry>
    <entry key="StandaloneNoMdlRef">The model ''{0}'' contains the subsystem ''{1}'' which is configured as a Function with separate data and initialization. Subsystems using this configuration are not supported for the model reference code generation target</entry>
    <entry key="StandaloneNoMultiInstanceERT">The model ''{0}'' contains the subsystem ''{1}'' which is configured as a Function with separate data and initialization. Subsystems using this configuration are not supported when &lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;Code interface packaging&lt;/sldiag&gt; is set to either ''C++ class'' or ''Reusable function''.
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="suggestion"&gt;
            &lt;cmd&gt;Simulink.internal.OpenBlockParamsDialog(''{1}'',''FunctionWithSeparateData'')&lt;/cmd&gt;
            &lt;txt&gt;Clear Function with separate data&lt;/txt&gt;
        &lt;/action&gt;
        &lt;action type="suggestion"&gt;
            &lt;cmd&gt;configset.internal.open(''{0}'',''CodeInterfacePackaging'')&lt;/cmd&gt;
            &lt;txt&gt;Set ''Code interface packaging'' to ''Nonreusable function'' (might impact referenced or referencing models)&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="StandaloneNoMultiRate">The subsystem ''{0}'' is configured as a Function with separate data and initialization and has multiple sample times.  Subsystems using this configuration must be single rate</entry>
    <entry key="StandaloneNoNoninlinedSfcns">서브시스템 ''{0}''은(는) 별도의 데이터와 초기화를 갖는 함수로 구성되었고, TLC 파일이 없는 S-Function ''{1}''을(를) 포함하고 있습니다. 이 구성을 사용하는 서브시스템은 인라인 S-Function만 지원합니다.</entry>
    <entry key="StandaloneOutFedByProbeBlock">Probe 블록 ''{0}''이(가) 별도의 데이터와 초기화를 갖는 함수로 구성된 서브시스템 ''{1}''의 아웃포트를 구동하는 중입니다. Probe 블록은 전역 데이터를 지원하지 않으므로, Probe 블록과 서브시스템 아웃포트 사이에 Signal Conversion 블록을 배치해 주십시오.</entry>
    <entry key="StandaloneOutFedByWidthBlock">Width 블록 ''{0}''이(가) 별도의 데이터와 초기화를 갖는 함수로 구성된 서브시스템 ''{1}''의 아웃포트를 구동하는 중입니다. Width 블록은 전역 데이터를 지원하지 않으므로, Width 블록과 서브시스템 아웃포트 사이에 Signal Conversion 블록을 배치해 주십시오.</entry>
    <entry key="StandaloneOutputFcnCall">서브시스템 ''{0}''이(가) 별도의 데이터와 초기화를 갖는 함수로 구성되었습니다. 이 구성을 사용하는 서브시스템은 함수 호출 신호를 출력할 수 없습니다. 서브시스템 블록에서 ''별도의 데이터 및 초기화'' 옵션을 선택 취소하십시오.</entry>
    <entry key="StartTimeCorrected">  The specified simulation start time ({0}) is
        not an integer multiple of the fixed step size ({1}). Changing the start time to
        ({2}).
        &lt;actions exclusiveFixIts="yes"&gt;
          &lt;action type="fixit" retvalue="false"&gt;
              &lt;cmd&gt;set_param(''{3}'',''StartTime'',''__startTime__'');&lt;/cmd&gt;
            &lt;cargs&gt;
                &lt;carg name="__startTime__" type="text"&gt;
                    &lt;txt_prompt&gt;Enter start time:&lt;/txt_prompt&gt;
                &lt;/carg&gt;
            &lt;/cargs&gt;
            &lt;txt&gt;Specify an integer multiple of the fixed step size for the start time of 
                 the simulation.&lt;/txt&gt;
          &lt;/action&gt;
          &lt;action type="suggestion" btn="apply"&gt;
              &lt;cmd&gt;set_param(''{3}'', ''SolverPrmCheckMsg'',''none'');&lt;/cmd&gt;
              &lt;txt&gt;Set &lt;sldiag objui="configset" objparam="SolverPrmCheckMsg"&gt;Automatic 
                   solver parameter selection&lt;/sldiag&gt; diagnostic to ''none''.&lt;/txt&gt;
          &lt;/action&gt;
         &lt;/actions&gt;
      </entry>
    <entry key="StateEnableSignalMustBeScalar">Cannot set dimensions of the enable input port of ''{0}''. The enable signal must be a scalar signal.</entry>
    <entry key="StateEnabledOrTriggeredSubsystemMustBeSingleRate1">서브시스템 ''{0}''에 인에이블 포트 또는 트리거 포트가 포함되어 있고 동기식 모드를 사용하므로 이 서브시스템 내의 모든 블록은 샘플 시간이 동일해야 합니다.</entry>
    <entry key="StateEnabledOrTriggeredSubsystemMustBeSingleRate2">서브시스템 ''{0}''에 인에이블 포트 또는 트리거 포트가 포함되어 있고 동기식 모드를 사용하므로 이 서브시스템에 들어가는 모든 신호는 서브시스템과 동일한 샘플 시간을 가져야 합니다.</entry>
    <entry key="StateEnabledOrTriggeredSubsystemMustHaveDiscreteOrTrigTs">서브시스템 ''{0}''에 인에이블 포트 또는 트리거 포트가 포함되어 있으므로 이산 샘플 시간 또는 트리거된 샘플 시간을 가져야 합니다.</entry>
    <entry key="BlockWithStatesModifiedInOutputUpdateInAlgLoop">출력을 계산하는 동안 영속 변수 또는 상태 변수를 업데이트하는 블록을 포함하고 있는 ''{0}'' 또는 이를 참조하는 모델은 대수 루프에서 지원되지 않습니다. 이러한 모델이 다음 블록과 함께 이 대수 루프에 있습니다.</entry>
    <entry key="BlocksInSubsystemWithStatesModifiedInOutputUpdateInAlgLoop">출력을 계산하는 동안 영속 변수 또는 상태 변수를 업데이트하는 블록을 포함하고 있는 ''{0}'' 또는 이를 참조하는 모델은 대수 루프에서 지원되지 않습니다. 부모 서브시스템 ''{1}''이(가) 다음 블록과 함께 이 대수 루프에 있습니다.</entry>
    <entry key="StatePerturbationMustBeScalar">블록 ''{0}''의 상태 섭동 수준은 스칼라 변수여야 합니다.</entry>
    <entry key="StatePortCannotFeedOutport">State port cannot feed into outports of nonvirtual subsystems.  Offending connection involves outport ''{0}''</entry>
    <entry key="StateResetForFCSSWithNonExplicitInit">The "States when enabling" parameter of block ''{0}'' may not be set to "reset"; it may only be set to "inherit" or "held" since its function call initiator ''{1}'' is not configured to explicitly enable and disable its destinations</entry>
    <entry key="StopAndCloseRunningModel">''{0}''이(가) 실행 중입니다. 실행을 중지하고 모델을 닫으시겠습니까?</entry>
    <entry key="StopAndCloseRunningModelInFastRestart">빠른 재시작으로 ''{0}''이(가) 실행 중입니다. 빠른 재시작을 종료하고 모델을 닫으시겠습니까?</entry>
    <entry key="StopAndCloseModelInitializedInFastRestart">빠른 재시작으로 ''{0}''이(가) 초기화되었습니다. 빠른 재시작을 종료하고 모델을 닫으시겠습니까?</entry>
    <entry key="StopAndCloseRunningModelInExternalMode">''{0}''이(가) 외부 모드 상태로 타깃에 연결되었습니다. 연결을 끊고 모델을 닫으시겠습니까?</entry>
    <entry key="CannotChangeFastRestartWhenStepping">시뮬레이션 중에는 [빠른 재시작]을 활성화하거나 비활성화할 수 없음</entry>
    <entry key="FastRestartNotSupportedInThisMode">[빠른 재시작]은 표준 모드와 액셀러레이터 모드에 대해서만 지원됩니다. ''set_param(''{0}'', ''FastRestart'', ''off'')''를 사용하여 [빠른 재시작]을 비활성화할 수 있습니다.</entry>
    <entry key="FastRestartArgNotSupportedInThisMode">[빠른 재시작]은 표준 모드와 액셀러레이터 모드에 대해서만 지원됩니다.</entry>
    <entry key="FastRestartSingleSimulationOutput">여러 출력 인수를 반환하는 sim 함수 구문은 일반적으로 권장되지 않으며 모델 ''{0}''에 빠른 재시작이 활성화된 경우 지원되지 않습니다. 시뮬레이션 결과를 단일 출력 인수로 반환하는 문서화된 구문을 사용하십시오.</entry>
    <entry key="LiveTuningArgNotSupportedInThisMode">옵션 ''LiveTuning''은 표준 모드와 액셀러레이터 모드에만 유효합니다.</entry>
    <entry key="StopTimeCorrected">  지정된 시뮬레이션 중지 시간({0})이 고정 스텝 크기({1})의 정수 배수가 아닙니다. 중지 시간을 ({2})(으)로 변경합니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" retvalue="false"&gt; &lt;cmd&gt;set_param(''{3}'',''StopTime'',''__stopTime__'');&lt;/cmd&gt; &lt;cargs&gt; &lt;carg name="__stopTime__" type="text"&gt; &lt;txt_prompt&gt;중지 시간 입력:&lt;/txt_prompt&gt; &lt;/carg&gt; &lt;/cargs&gt; &lt;txt&gt;시뮬레이션의 중지 시간에 대해 고정 스텝 크기의 정수 배수를 지정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" btn="apply"&gt; &lt;cmd&gt;set_param(''{3}'', ''SolverPrmCheckMsg'',''none'');&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="SolverPrmCheckMsg"&gt;솔버 파라미터 자동 선택&lt;/sldiag&gt; 진단을 ''안 함''으로 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    
    </entry>
    <entry key="StructFormatNotCompatible">지정된 MATLAB 배열의 구조체 데이터가 Simulink 비가상 버스 데이터와 호환되지 않음</entry>
    <entry key="SubsystemCannotBeReusableForMultiInstanceCode">The model cannot generate reusable code with inputs and outputs passed as individual arguments, because ''{0}'' can not generate a reusable function. Consider changing  &lt;sldiag objui="configset" objparam="RootIOFormat"&gt;Pass root-level I/O&lt;/sldiag&gt; to ''Structure reference''. Alternatively, consider setting &lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;Code interface packaging&lt;/sldiag&gt; to ''Nonreusable function''.</entry>
    <entry key="SubsystemCannotBeReusableForMultiInstanceCodeCPP">''{0}''은(는) C++ 클래스 인터페이스를 생성할 때 필요한 재사용 가능 함수를 생성할 수 없습니다. &lt;sldiag objui="configset" objparam="CodeInterfacePackaging"&gt;코드 인터페이스 패키징&lt;/sldiag&gt;을 ''C++ 클래스'' 외의 다른 값으로 설정해 보십시오.</entry>
    <entry key="SubsystemChangedToBeReusableNotSupportedInInplace">Inplace specification not supported when the implementation of ''{0}'' needs to be changed to a Reusable function. Please set the function packaging on this block to Reusable.</entry>
    <entry key="SubsystemChangedToBeReusableForMultiInstanceCode">Attempting to change the implementation of ''{0}'' to a reusable function, so that the generated code may be reusable</entry>
    <entry key="SubsystemChangedToBeReusableInsideServer">서버 블록 ''{1}'' 내에 있기 때문에 ''{0}''의 구현이 재사용 가능 함수로 변경됨</entry>
    <entry key="StandaloneNoServer">The model ''{0}'' contains the subsystem ''{1}'' which is configured as a Function with separate data and initialization. Subsystems using this configuration are not supported inside of server blocks, and that subsystem is inside the server block ''{2}''</entry>
    <entry key="SubsystemNonReusableInReusableSubsysCPP">''{0}''은(는) Simulink Function이거나 코드 생성 함수 패키징 파라미터 값으로 ''재사용 불가 함수''를 사용하는 서브시스템인데, ''재사용 가능 함수'' 옵션을 사용하는 선조 서브시스템 ''{1}''이(가) 있습니다. 이는 C++ 클래스 인터페이스를 생성하는 경우에는 허용되지 않습니다. 전자에 해당하는 서브시스템의 옵션을 ''재사용 가능 함수''로 변경하거나 후자에 해당하는 서브시스템의 옵션을 ''재사용 불가 함수''로 변경해 보십시오.</entry>
    <entry key="SuppressErrStNotSupportNonInlinedSF">Block ''{0}'' is a non-inlined sfunction block, which is not supported when &lt;sldiag objui="configset" objparam="SuppressErrorStatus"&gt;Remove error status field in real-time model data structure&lt;/sldiag&gt; is checked. Consider unselecting the option or removing the block</entry>
    <entry key="SuppressErrorStatusNotSupportCTime">Model ''{0}'' has both &lt;sldiag objui="configset" objparam="SupportContinuousTime"&gt;Support: continuous time&lt;/sldiag&gt; and &lt;sldiag objui="configset" objparam="SuppressErrorStatus"&gt;Remove error status field in real-time model data structure&lt;/sldiag&gt; checked, which is not a supported configuration. One of these options must be unselected in order to build this model.</entry>
    <entry key="SwitchedReusedToNonreused">서브시스템 ''{0}''의 ''재사용 가능 함수'' 설정을 ''재사용 불가 함수''으로 변환하는 중입니다. 하위 시스템이 재사용되지 않는 것으로 명시적으로 표시되었거나 재사용되지 않아야 하는 구성에 사용되었기 때문입니다. 코드 생성 중에 HTML 보고서를 생성하여 "Subsystems" 섹션에서 자세한 내용을 참조하십시오.</entry>
    <entry key="ConnToModelRefFcnCallInitiator">Subsystem 블록 ''{0}''에 Model Reference 블록의 함수 호출 포트에 연결된 출력 함수 호출이 있습니다. 따라서 ''{0}'' 서브시스템을 재사용할 수 없습니다. 이 경고가 발생하지 않도록 하려면 ''{0}''의 함수 패키징 파라미터를 ''인라인''으로 변경하십시오.</entry>
    <entry key="CompositeRateSubsysToRootOutport">Subsystem 블록 ''{0}''이(가) 함수 내보내기 모델 내에 있습니다. Subsystem 블록은 유니언 레이트를 가지며 루트 Outport에 연결되어 있습니다. 따라서 ''{0}'' 서브시스템을 재사용할 수 없습니다. 이 경고가 발생하지 않도록 하려면 ''{0}''의 함수 패키징 파라미터를 ''인라인''으로 변경하십시오.</entry>
    <entry key="SysGenSameFcnAsMdl">Subsystem ''{0}'' function name setting ({1}) is the same name as the model ''{2}''.  Please change the function name setting for this subsystem</entry>
    <entry key="SysGenSameFileAsMdl">The subsystem ''{0}'' is trying to generate code to a reserved file ({1}) for the model ''{2}''.  Please change the file name setting for this subsystem</entry>
    <entry key="SysIllegalFileName">서브시스템 ''{0}''이(가) 이름이 ''rt_sys''로 시작하는 파일({1})에 코드를 생성하려고 합니다. 이는 Simulink Coder의 예약된 식별자입니다. 이 서브시스템의 파일 이름 설정을 변경하십시오.</entry>
    <entry key="TagEmpty">태그는 비어 있지 않아야 함</entry>
    <entry key="Target_BadTFLSource">코드 대체 라이브러리 ''{0}''이(가) 누락되었거나 유효한 테이블을 포함하지 않습니다.</entry>
    <entry key="Target_FailedToGetHostWordLengths">호스트 워드 길이를 얻으려는 시도가 오류가 발생하며 실패했습니다.</entry>
    <entry key="TipAlert_AutoConnectionDescription">블록을 빠르게 연결하려면 소스 블록을 선택한 다음 Ctrl 키를 누른 상태에서 대상 블록을 마우스 왼쪽 버튼으로 클릭하십시오.</entry>
    <entry key="TipAlert_AutoConnectionTitle">자동 블록 연결 팁</entry>
    <entry key="TnextMustBeScalar">flag={2,number,integer} 호출 동안 ''{1}''에 있는 S-Function ''{0}''에 의해 반환된 다음 적중 시간은 실수여야 합니다.</entry>
    <entry key="TrigSSDataInputPortsInLoop">''{1}''의 입력 포트 {0}이(가) 루프에 연결되어 있습니다. Triggered Subsystem 및/또는 Model 블록과 관련된 루프를 제거하려면, 해당 인포트에 ''외부 신호를 지연시켜 입력 래치''를 지정하십시오.</entry>
    <entry key="TrigSSEnabPortInLoop">The enable input port of enabled and triggered subsystem or Model block ''{0}'' is involved in a loop. This causes the enable signal at time t to be dependent on the output of the subsystem or Model block at time t, resulting in an ambiguous execution. You can use a Memory block to break the loop.</entry>
    <entry key="TrigSSTrigPortInLoop">Triggered Subsystem 또는 Model 블록 ''{0}''의 트리거 입력 포트가 루프에 연결되어 있습니다. 이로 인해 시간 t에서의 트리거 신호가 시간 t에서의 Triggered Subsystem 또는 Model 블록의 출력에 따라 달라지므로 실행 순서가 모호해집니다. Memory를 사용하여 루프를 끊을 수 있습니다.</entry>
    <entry key="TrigSigMustBeRealDouble">외부 모드 트리거 신호는 복소수가 아니어야 하고, 정수만 있는 타깃에 대해서는 ''int32''형, 그 외 모든 타깃에 대해서는 ''double''형이어야 합니다.</entry>
    <entry key="TrigStateflowDataInputPortsInLoop">트리거된 Stateflow 차트 ''{1}''의 입력 포트 {0}이(가) 루프에 연결되어 있습니다. Memory 블록을 사용하여, 트리거된 Stateflow 차트와 연결된 루프를 제거할 수 있습니다.</entry>
    <entry key="TriggerECPotentialPreStartOutputDiff">''{1}''이(가) t = 0에서 트리거되지 않은 경우 ''{0}''의 출력은 이전 Simulink 릴리스와 다른 결과를 생성할 수 있습니다. ''{2}'' 블록은 영(0) 입력에 대해 0이 아닌 출력을 생성할 수 있으며 ''{3}'' 실행 컨텍스트에 의해 상속되었습니다. 이전 릴리스에서 ''{4}''은(는) 실행 컨텍스트에 의해 상속되지 않았으며 조건부 서브시스템 시작 전에 0이 아닌 출력을 생성했을 수 있습니다. 컨텍스트의 상속을 방지하려면 ''{5}''의 샘플 시간을 신호를 다시 계산하고자 하는 레이트로 명시적으로 설정하십시오. 이 경고 메시지를 끄려면 &lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;실행 컨텍스트의 사전 활성화 출력 확인&lt;/sldiag&gt;을 선택 취소하십시오.</entry>
    <entry key="TriggerECPotentialPreStartOutputDiffConsistentOutportInit">''{1}''이(가) t = 0에서 트리거되지 않은 경우 ''{0}''의 출력은 이전 Simulink 릴리스와 다른 결과를 생성할 수 있습니다. ''{2}'' 블록은 영(0) 입력에 대해 0이 아닌 출력을 생성할 수 있으며 ''{3}'' 실행 컨텍스트에 의해 상속되었습니다. 이전 릴리스에서 ''{4}''은(는) 실행 컨텍스트에 의해 상속되지 않았으며 조건부 서브시스템 시작 전에 0이 아닌 출력을 생성했을 수 있습니다. 컨텍스트의 상속을 방지하려면 ''{5}''의 샘플 시간을 신호를 다시 계산하고자 하는 레이트로 명시적으로 설정하십시오. 이 경고 메시지를 끄려면 &lt;sldiag objui="configset" objparam="CheckExecutionContextPreStartOutputMsg"&gt;실행 컨텍스트의 사전 활성화 출력 확인&lt;/sldiag&gt;을 선택 취소하십시오.</entry>
    <entry key="TriggeredFcnCallCannotBeITVS">The Function-Call Port block ''{0}'' has an invalid setting specified for its ''Sample time type'' parameter. When ''Propagate sizes of variable-size signals'' is set to ''Only when enabling'', the ''Sample time type'' option must be set to ''periodic''.</entry>
    <entry key="InitTrigStateCannotBeNegative">Parameter ''Initial trigger signal state'' for Trigger Port block ''{0}'' cannot be ''negative'' because the data type ''{1}'' of the corresponding parent subsystem trigger port is unsigned.</entry>
    <entry key="UnableRepresentDataInFi">Unable to construct the fi object for the fixed-point data type ''{0}'' associated with block ''{1}''.</entry>
    <entry key="UnableRepresentModelDataInFi">고정소수점 데이터형 ''{0}''에 대한 fi 객체를 생성할 수 없습니다.</entry>
    <entry key="UnableRepresentDataInMatlab">Simulink 내부 데이터를 저장하기에 적합한 MATLAB 데이터형을 찾을 수 없음</entry>
    <entry key="UnableRepresentDataInMatlabErr">''{1}''에 대한 ''{0}'' 유형의 Simulink 내부 데이터를 저장하기에 적합한 MATLAB 데이터형을 찾을 수 없음</entry>
    <entry key="UnableToHonorPriority">Unable to honor user-specified block priorities. ''{0}'' with a block priority {1} has to execute before ''{2}'' that has a higher block priority {3} to satisfy data dependencies.</entry>
    <entry key="UnableToHonorPriorityInTask">샘플 시간 {5}을(를) 갖는 블록 실행을 스케줄링할 때 {4,number,integer}번 태스크에 사용자 지정 블록 우선 순위를 적용할 수 없습니다. 데이터 종속성을 충족하려면 블록 우선 순위 {1}을(를) 갖는 ''{0}''이(가) 더 높은 블록 우선 순위 {3}을(를) 갖는 ''{2}''보다 먼저 실행되어야 합니다.</entry>
    <entry key="UnableToHonorPriorityInTask0">이산 또는 연속 샘플 시간을 갖는 블록 실행을 스케줄링할 때 {4,number,integer}번 태스크에 사용자 지정 블록 우선 순위를 적용할 수 없습니다. 데이터 종속성을 충족하려면 블록 우선 순위 {1}을(를) 갖는 ''{0}''이(가) 더 높은 블록 우선 순위 {3}을(를) 갖는 ''{2}''보다 먼저 실행되어야 합니다.</entry>
    <entry key="UnableToHonorPriorityInConstTask">상수 샘플 시간을 갖는 블록에 사용자 지정 블록 우선 순위를 적용할 수 없습니다. 데이터 종속성을 충족하려면 블록 우선 순위 {1}을(를) 갖는 ''{0}''이(가) 더 높은 블록 우선 순위 {3}을(를) 갖는 ''{2}''보다 먼저 실행되어야 합니다.</entry>
    <entry key="UnableToLoadBd">블록 다이어그램 ''{0}''을(를) 불러올 수 없음</entry>
    <entry key="PossibleSimulationResultsMismatchForCodeGen">루트 인포트 ''{0}''과(와) 루트 아웃포트 ''{1}''이(가) 재사용되었기 때문에, .mat 파일에서 가져오는 결과가 다른 시뮬레이션 모드의 결과와 일치한다고 보장할 수 없습니다.</entry>
    <entry key="UnableToLocateRTWNameInBd">Unable to locate Simulink Coder block or system name ''{0}'' in model ''{1}''</entry>
    <entry key="UnableToSolveAlgLoop">블록 ''{0}''을(를) 포함하는 대수 루프의 해를 구할 수 없습니다. 대수 변수를 대입할 수 없는 하나 이상의 블록이 루프에 포함되어 있기 때문입니다(예: Stateflow 차트, 비가상 서브시스템, 복소수 출력 신호를 갖는 블록, 이산 샘플 시간을 갖거나 데이터형이 double형이 아닌 출력을 갖는 블록). &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;루프 내 신호가 이산 샘플 시간을 갖는 경우 루프에 블록(예: Delay 블록 또는 Memory 블록)을 추가하여 루프를 끊으십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;루프 내 신호가 연속 샘플 시간을 갖는 경우 연속 블록(예: 시스템 동역학에 영향을 미치지 않을 정도로 작은 시정수를 갖는 1계 시스템을 구현하는 Transfer Function 블록)을 추가하여 루프를 끊으십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;루프에 대한 자세한 내용을 보려면 Simulink.BlockDiagram.getAlgebraicLoops 함수를 사용하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;</entry>
    <entry key="UnableToUpdateDisplayInRapidAccelMode">고속 액셀러레이터 모드는 ''{0}'' 같은 일부 시각화 블록을 업데이트하지 않습니다. 시각화 블록을 최대한 활용하려면 표준 모드 또는 액셀러레이터 모드에서 모델을 실행하십시오.</entry>
    <entry key="UnconnLine">''{0}''에서 연결되지 않은 선이 발견됨(왼쪽에서 {1,number,integer}%번째부터 및 상단에서 {2,number,integer}%번째부터)</entry>
    <entry key="UnconnLineOutsideWindow">Unconnected line found in ''{0}'' (outside of current view)</entry>
    <entry key="UnnamedRegsitryItem">이름 없는 항목은 레지스트리에 추가할 수 없습니다.</entry>
    <entry key="UnresolvedPassThroughLoop">Simulink가 ''{0}''에서 가변 크기를 갖는 블록이 포함된 유효하지 않은 루프를 발견했습니다. 루프는 블록과 블록의 포트로 구성됩니다. 이러한 모든 블록에 따르면 출력 포트의 차원과 각각의 입력 포트의 차원이 일치해야 합니다. (S-Function의 경우 ''ssSetInputDimsSameAsOutputDims''가 사용되었습니다.) 그 결과, 루프의 어떠한 블록도 사실상 지정된 시간 스텝으로 포트 차원을 설정하지 못합니다. 블록과 이 루프의 외부 입력 포트에 해당하는 포트 인덱스는 {1}입니다.</entry>
    <entry key="UnsupportedBlockJacobian">이 블록의 야코비 행렬은 지원되지 않습니다.</entry>
    <entry key="VerySmallMaxStepSize">모델의 고주파수 소스 블록으로 인해 모델 ''{0}''의 자동 스텝 크기가 {1}(으)로 선택되었습니다. 시뮬레이션을 완료하려면 최소 {2}개의 시뮬레이션 스텝이 필요합니다. 시뮬레이션 스텝 수를 줄이려면 중지 시간을 줄이거나 더 큰 최대 스텝 크기를 선택하십시오.</entry>
    <entry key="VerySmallFixedStepSize">모델의 고주파수 소스 블록으로 인해 모델 ''{0}''의 자동 스텝 크기가 {1}(으)로 선택되었습니다. 시뮬레이션을 완료하려면 {2}개의 시뮬레이션 스텝이 필요합니다. 시뮬레이션 스텝 수를 줄이려면 중지 시간을 줄이거나 더 큰 고정 스텝 크기를 선택하십시오.</entry>
    <entry key="UsingDefaultMaxStepSize">모델 ''{0}''은(는) 최대 스텝 크기에 디폴트 값 {1}을(를) 사용합니다. &lt;sldiag objui="configset" objparam="SolverPrmCheckMsg"&gt;솔버 파라미터 자동 선택&lt;/sldiag&gt;을 ''안 함''으로 설정하여 이 진단을 비활성화할 수 있습니다</entry>
    <entry key="UsingDiscreteSolver">모델 ''{0}''이(가) 연속 상태를 갖지 않으므로, Simulink가 솔버 ''{2}'' 대신 솔버 ''{1}''을(를) 사용합니다. &lt;sldiag objui="configset" objparam="Solver"&gt;솔버&lt;/sldiag&gt;에 이산 솔버를 명시적으로 지정하거나 &lt;sldiag objui="configset" objparam="SolverPrmCheckMsg"&gt;솔버 파라미터 자동 선택&lt;/sldiag&gt;을 ''안 함''으로 설정하여 이 진단을 비활성화할 수 있습니다</entry>
    <entry key="AutoSolverHighNx">연속 상태 ''{0}''의 수가 임계값 ''{1}''보다 크기 때문에 이 모델에는 자동 솔버의 경직성 검사가 지원되지 않습니다. 임계값을 변경하려면 MATLAB 명령줄에서 ''NumStatesForStiffnessChecking'' 모델 파라미터를 설정하십시오.</entry>
    <entry key="EnableRuntimeSolverSwitching">블록 다이어그램 ''{0}''에 발견법을 설정하려면 먼저 런타임 솔버 전환을 활성화해야 합니다.</entry>
    <entry key="RuntimeSolverSwitchingInvalidSolver">Run time solver switching is only supported for VariableStepAuto solver. Please change the solver for block diagram ''{0}''.</entry>
    <entry key="AutoSolverRuntimeInvalidParamNames">블록 다이어그램 ''{0}''에 지정된 EnableRuntimeSolverSwitching의 입력이 유효하지 않습니다. 파라미터 이름 ''{1}''이(가) 유효하지 않습니다.</entry>
    <entry key="AutoSolverRuntimeInvalidParamValues">Invalid input for EnableRuntimeSolverSwitching for block diagram ''{0}''. The values of the following parameters are invalid: ''{1}''.</entry>
    <entry key="AutoSolverRuntimeInvalidParamNamesAndValues">블록 다이어그램 ''{0}''의 EnableRuntimeSolverSwitching에 대한 입력이 유효하지 않습니다. 파라미터 이름 ''{1}''이(가) 유효하지 않습니다. 파라미터 ''{2}''의 값이 유효하지 않습니다.</entry>
    <entry key="ValueLabelSignalReuseClashPart1">이 모델에는 신호 저장공간 재사용이 설정되어 있습니다. 따라서 블록의 출력 포트 표시가 올바르지 않을 수 있습니다.</entry>
    <entry key="ValueLabelSignalReuseClashPart2">그럼에도 포트 표시를 설정하려면 [확인]을 선택하고, 현재 설정을 유지하려면 [취소]를 선택하십시오.</entry>
    <entry key="VarDimRulesExceedMaxNumber">The number of propagated dimension dependency rules ({0,number,integer}) of ''{1}'' has exceeded the maximum number of rules ({2,number,integer}) allowed in the model. You can use ''set_param(modelname, ''MaxNumVariableDimRules'', N)'' to change this setting, but this might result in longer block-diagram updates.</entry>
    <entry key="VarDimsBlockExecTimeWithBlockRequestStateResetSizeVary">Block ''{0}'' contains states that require resetting whenever the input signal sizes vary. This block property is inconsistent with a block property of ''{1}''; the output signal sizes of block ''{2}'' depend on its input signal values. Consider placing ''{3}'' in an Enabled/Function-Call/Action/Resettable Subsystem and setting the parameter ''Propagate sizes of variable-size signals'' on the corresponding control port block to: ''Only when enabling'' for an Enabled or a Function-Call Subsystem; ''Only when execution is resumed'' for an Action Subsystem; or ''Only when resetting'' for a Resettable Subsystem.</entry>
    <entry key="VarDimsBlockRequestStateResetNonModelRef">블록 ''{0}''에 입력 신호 크기가 변할 때마다 재설정해야 하는 상태가 포함되어 있습니다. 그러나 Simulink는 이 블록이 활성화된 경우에만 신호 크기를 설정할 수 있습니다. Enabled/Function-Call/Action/Resettable Subsystem 내에 ''{1}''을(를) 두십시오. 그런 다음 해당 제어 포트 블록의 파라미터 ''가변 크기 신호의 크기 전파''를 Enabled Subsystem 또는 Function-Call Subsystem에는 ''활성화할 때만''으로, Action Subsystem에는 ''실행을 재개할 때만''으로, Resettable Subsystem에는 ''재설정할 때만''으로 설정하십시오.</entry>
    <entry key="VarDimsBusElementNotAllowed">{0} does not support nonvirtual buses which contain variable-size elements.</entry>
    <entry key="VarDimsContextNotResetBlockRequestStateResetSizeVary1">블록 ''{0}''에 입력 신호 크기가 변하면 재설정해야 하는 상태가 포함되어 있습니다. ''{1}''의 ''활성화할 때의 상태'' 파라미터를 ''재설정''으로 변경해 보십시오.</entry>
    <entry key="VarDimsContextNotResetBlockRequestStateResetSizeVary2">블록 ''{0}''에 입력 신호 크기가 변하면 재설정해야 하는 상태가 포함되어 있습니다. ''{1}''의 ''실행을 재개할 때의 상태'' 파라미터를 ''재설정''으로 변경해 보십시오.</entry>
    <entry key="VarDimsExecTimeContextModelBlockInitTime">The subsystem ''{0}'' contains the control port block ''{1}'' and the model block ''{2}''. For the control port block ''{3}'', the parameter ''Propagate sizes of variable-size signals'' is set to ''During execution''. In addition, the model block  has one of the following properties: 1) the model block contains states that require resetting when the input signal sizes vary. 2) the ''Configuration Parameters &gt; Model Referencing &gt; Propagate sizes of variable-size signals'' parameter of the referenced model ''{4}'' is set to ''Only when enabling''. Consider changing the parameter ''Propagate sizes of variable-size signals'' for ''{5}'' to ''Only when enabling''.</entry>
    <entry key="VarDimsExecTimeContextModelBlockInitTimeAction">서브시스템 ''{0}''에는 제어 포트 블록 ''{1}''과(와) Model 블록 ''{2}''이(가) 포함되어 있습니다. 제어 포트 블록 ''{3}''은(는) 파라미터 ''가변 크기 신호의 크기 전파''가 ''실행하는 동안''으로 설정되었습니다. 또한 Model 블록은 다음 속성 중 하나를 갖습니다. 1) Model 블록에 입력 신호 크기가 변하면 재설정해야 하는 상태가 있습니다. 2) 참조된 모델 ''{4}''의 ''구성 파라미터 &gt; 모델 참조 &gt; 가변 크기 신호의 크기 전파'' 파라미터가 ''활성화할 때만''으로 설정됩니다. ''{5}''의 파라미터 ''가변 크기 신호의 크기 전파''를 ''실행을 재개할 때만''로 변경해 보십시오.</entry>
    <entry key="VarDimsExecTimeContextModelBlockInitTimeReset">The subsystem ''{0}'' contains the control port block ''{1}'' and the model block ''{2}''. For the control port block ''{3}'', the parameter ''Propagate sizes of variable-size signals'' is set to ''During execution''. In addition, the model block  has one of the following properties: 1) the model block contains states that require resetting when the input signal sizes vary. 2) the ''Configuration Parameters &gt; Model Referencing &gt; Propagate sizes of variable-size signals'' parameter of the referenced model ''{4}'' is set to ''Only when enabling''. Consider changing the parameter ''Propagate sizes of variable-size signals'' for ''{5}'' to ''Only when resetting''.</entry>
    <entry key="VarDimsExecTimeContextRequestStateResetSizeVary">Block ''{0}'' contains states that require resetting when input signal sizes vary. However, the subsystem that contains this block is set to ''Propagate sizes for variable-size signals during execution''. The resetting of states for ''{1}'' can occur only when the subsystem is being enabled. Consider changing the parameter ''Propagate sizes of variable-size signals'' for ''{2}'' to ''Only when enabling''.</entry>
    <entry key="VarDimsExecTimeContextRequestStateResetSizeVaryAction">Block ''{0}'' contains states that require resetting when input signal sizes vary. However, the subsystem that contains this block is set to ''Propagate sizes for variable-size signals during execution''. The resetting of states for ''{1}'' can occur only when the subsystem execution is resumed. Consider changing the parameter ''Propagate sizes of variable-size signals'' for ''{2}'' to ''Only when execution is resumed''.</entry>
    <entry key="VarDimsExecTimeContextRequestStateResetSizeVaryReset">Block ''{0}'' contains states that require resetting when input signal sizes vary. However, the subsystem that contains this block is set to ''Propagate sizes for variable-size signals during execution''. The resetting of states for ''{1}'' can occur only when the subsystem is reset. Consider changing the parameter ''Propagate sizes of variable-size signals'' for ''{2}'' to ''Only when resetting''.</entry>
    <entry key="VarDimsInitTimeContextModelBlockExecTime">The subsystem ''{0}'' contains the control port block ''{1}'' and the model block ''{2}''. For the control port block ''{3}'', the parameter ''Propagate sizes of variable-size signals'' is set to ''Only when enabling''. In addition, the model block  has one of the following properties: 1) the model block contains a block for which the output signal sizes depend on the input signal values; 2) the ''Configuration Parameters &gt; Model Referencing &gt; Propagate sizes of variable-size signals'' parameter of the referenced model ''{4}'' is set to ''During execution''. Consider changing the parameter ''Propagate sizes of variable-size signals'' for ''{5}'' to ''During execution''.</entry>
    <entry key="VarDimsInitTimeContextSizeDependOnValue">블록 ''{0}''의 출력 신호 크기는 입력 신호 값에 종속됩니다. 그러나 이 블록이 포함된 서브시스템이 ''가변 크기 신호의 크기 전파: 활성화할 때만''으로 설정되어 있습니다. 이 파라미터 설정을 사용하거나 ''{1}''에 대한 파라미터 ''가변 크기 신호의 크기 전파''를 ''실행하는 동안''으로 변경하여 이 블록을 서브시스템 외부에 배치해 보십시오.</entry>
    <entry key="ResetSSVarDimsInitTimeContextSizeDependOnValue">The output signal sizes of block ''{0}'' depend on the input signal values. However, the subsystem that contains this block is set to ''Propagate sizes of variable-size signals only when resetting''. Consider changing the parameter ''Propagate sizes of variable-size signals'' for ''{1}'' to ''During execution''.</entry>
    <entry key="VarDimsInputEmpty">The signal at &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' cannot have an empty size.</entry>
    <entry key="VarDimsInputRequireDiscreteST">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 있는 신호가 비이산 샘플 시간을 갖는 가변 크기 신호입니다. 가변 크기 신호의 샘플 시간은 이산시간이어야 합니다.</entry>
    <entry key="VarDimsBusInputRequireDiscreteST">The signal at &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a bus with a variable-size element and has a nondiscrete sample time. The sample time for any variable-size signal must be discrete.</entry>
    <entry key="VarDimsInvalidDrivingSS">Outport ''{0}'' is driven directly by &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;output port {1,number,integer}&lt;/sldiag&gt; of subsystem ''{2}''. Since ''{3}'' has a variable-size input and it is inside a subsystem that propagates sizes of variable-size signals during execution, it cannot be driven directly by a subsystem that propagates sizes of variable-size signals only when enabling, resetting, or when execution is resumed. To fix this, you can either insert a Signal Conversion block with its ''Output'' parameter set to ''Signal copy'' and ''Override optimizations and always copy signal'' parameter checked between two Outport blocks; or you can enable simplified initialization mode by setting &lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;Underspecified initialization detection&lt;/sldiag&gt; to ''simplified''. Note that some modifications may be necessary to ensure the model conforms to certain modeling standards required by the new initialization mode. For more information, see documentation for the Model Advisor check ''Check consistency of initialization parameters for Outport and Merge blocks''.</entry>
    <entry key="VarDimsInvalidDrivingMdlRef">Outport ''{0}'' is driven directly by &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;output port {1,number,integer}&lt;/sldiag&gt; of Model block ''{2}''. Since ''{3}'' has a variable-size input and it is inside a subsystem that propagates sizes of variable-size signals during execution, it cannot be driven directly by a subsystem inside the referenced model that propagates sizes of variable-size signals only when enabling, resetting, or when execution is resumed. To fix this, you can either insert a Signal Conversion block with its ''Output'' parameter set to ''Signal copy'' and ''Override optimizations and always copy signal'' parameter checked between two Outport blocks; or you can enable simplified initialization mode by setting &lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;Underspecified initialization detection&lt;/sldiag&gt; to ''simplified''. Note that some modifications may be necessary to ensure the model conforms to certain modeling standards required by the new initialization mode. For more information, see documentation for the Model Advisor check ''Check consistency of initialization parameters for Outport and Merge blocks''.</entry>
    <entry key="VarDimsInvalidInputIndexDimsDependencyRule">''{0}''에 지정된 차원 종속성 규칙이 유효하지 않습니다. 입력 포트 인덱스가 0~{1,number,integer} 내에 있어야 합니다(여기서 {2,number,integer}은(는) 입력 포트 수에서 1을 뺀 값임).</entry>
    <entry key="VarDimsInvalidInputModeDimsDependencyRule">''{0}''에 지정된 차원 종속성 규칙이 유효하지 않습니다. {1,number,integer}번 입력 포트는 고정 크기 모드일 수 없습니다.</entry>
    <entry key="VarDimsMultiModeLoopInputError">Simulink에서 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;과(와) 연결된 루프의 차원 종속성 규칙을 확인할 수 없습니다. 차원 종속성 규칙이 순환 관계로 정의되었기 때문에 이 규칙을 확인할 수 없습니다.</entry>
    <entry key="VarDimsMultiModeLoopOutputError">Simulink is not able to determine the dimension dependency rules for the loop involving the &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}''. Simulink cannot resolve the dimension dependency rules because they are defined by a cyclic relationship.</entry>
    <entry key="VarDimsOutportInitOutConflict">&lt;sldiag objui="outport" objparam="{0}" objname="{1}"&gt;Outport {0}&lt;/sldiag&gt; and ''{1}'' which are driven by the same signal specify conflicting values for the "Initial output" parameter. Initial outputs should be the same.</entry>
    <entry key="VarDimsSfChartOutportInitOutConflict">Stateflow Chart ''{0}''과(와) Outport 블록 ''{1}''이(가) 서로 충돌하는 초기 출력값을 지정했습니다. 초기 출력은 같아야 합니다.</entry>
    <entry key="VarDimsOutputRequireDiscreteST">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 있는 신호가 비이산 샘플 시간을 갖는 가변 크기 신호입니다. 가변 크기 신호의 샘플 시간은 이산시간이어야 합니다.</entry>
    <entry key="VarDimsBusOutputRequireDiscreteST">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 있는 신호는 가변 크기 요소를 갖는 버스인데 비이산 샘플 시간을 갖습니다. 가변 크기 신호의 샘플 시간은 이산시간이어야 합니다.</entry>
    <entry key="VarDimsOutputRequireNonCustomStorageClass">The signal at &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is a variable-size signal with a custom storage class. However, variable-size signals do not support any custom storage class. Consider, in the ''Signal Properties...'' dialog, selecting a noncustom storage class from the list. (Open the ''Signal Properties...'' dialog by right-clicking the signal line).</entry>
    <entry key="UnboundedDimsOutputRequireBuiltInStorageClass">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 있는 신호에는 지원되지 않는 스토리지 클래스를 가진 비유계 가변 크기 신호가 포함되어 있습니다. 스토리지 클래스는 'Auto', 'Exported Global', 'Imported Extern' 또는 'Imported Extern Pointer'여야 합니다.</entry>
    <entry key="UnboundedDimsInputRequireBuiltInStorageClass">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 있는 신호에는 지원되지 않는 스토리지 클래스를 가진 비유계 차원 신호가 포함되어 있습니다. 스토리지 클래스는 'Auto', 'Exported Global', 'Imported Extern' 또는 'Imported Extern Pointer'여야 합니다.</entry>
    <entry key="VarDimsRequireContiguousInput">The &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is set to accept variable-size signals, but the port is using discontiguous memory. If you are using an S-function, consider setting ''ssSetInputPortRequiredContiguous'' to on. Otherwise, consider inserting a Signal Conversion block upstream of this input port.</entry>
    <entry key="VarDimsSSExecTimeWithBlockRequestStateResetSizeVary">블록 ''{0}''에 입력 신호 크기가 변할 때마다 재설정해야 하는 상태가 포함되어 있습니다. 이 블록 속성은 서브시스템 ''{2}''에 있는 블록 ''{1}''의 블록 파라미터 설정과 맞지 않습니다. 특히 파라미터 ''가변 크기 신호의 크기 전파''가 ''실행하는 동안''으로 설정되어 있습니다. Enabled/Function-Call/Action/Resettable Subsystem 내에 ''{3}''을(를) 두십시오. 그런 다음 해당 제어 포트 블록의 파라미터 ''가변 크기 신호의 크기 전파''를 Enabled Subsystem 또는 Function-Call Subsystem에는 ''활성화할 때만''으로, Action Subsystem에는 ''실행을 재개할 때만''으로, Resettable Subsystem에는 ''재설정할 때만''으로 설정하십시오. 또는 ''{4}''의 ''가변 크기 신호의 크기 전파'' 파라미터 설정을 ''활성화할 때만''으로 변경하십시오.</entry>
    <entry key="VarDimsSSExecTimeWithBlockRequestStateResetSizeVaryAction">블록 ''{0}''에 입력 신호 크기가 변할 때마다 재설정해야 하는 상태가 포함되어 있습니다. 이 블록 속성은 서브시스템 ''{2}''에 있는 블록 ''{1}''의 블록 파라미터 설정과 맞지 않습니다. 특히 파라미터 ''가변 크기 신호의 크기 전파''가 ''실행하는 동안''으로 설정되어 있습니다. Enabled/Function-Call/Action/Resettable Subsystem 내에 ''{3}''을(를) 두십시오. 그런 다음 해당 제어 포트 블록의 파라미터 ''가변 크기 신호의 크기 전파''를 Enabled Subsystem 또는 Function-Call Subsystem에는 ''활성화할 때만''으로, Action Subsystem에는 ''실행을 재개할 때만''으로, Resettable Subsystem에는 ''재설정할 때만''으로 설정하십시오. 또는 ''{4}''의 ''가변 크기 신호의 크기 전파'' 파라미터 설정을 ''실행을 재개할 때만''으로 변경하십시오.</entry>
    <entry key="VarDimsSSExecTimeWithBlockRequestStateResetSizeVaryReset">Block ''{0}'' contains states that require resetting whenever the input signal sizes vary. This block property is inconsistent with the block parameter setting for block ''{1}'' in subsystem ''{2}''. Specifically, the parameter ''Propagate sizes of variable-size signals'' is set to ''During execution''. Consider placing ''{3}'' inside an Enabled/Function-Call/Action/Resettable subsystem and setting the parameter ''Propagate sizes of variable-size signals'' for the corresponding control port block to: ''Only when enabling'' for an Enabled or a Function-Call Subsystem; ''Only when execution is resumed'' for an Action Subsystem; or ''Only when resetting'' for a Resettable Subsystem. Alternatively, change the ''Propagate sizes of variable-size signals'' parameter setting for ''{4}'' to ''Only when resetting''.</entry>
    <entry key="VarDimsSfcnRequireContiguous">The &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of S-Function block ''{1}'' is set to accept variable-size signals. The S-function ''{2}'' must call the method ''ssSetInputPortRequiredContiguous(S,port,true)''.</entry>
    <entry key="VarDimsMultiRateEnableNotSupported"> Simulink does not support the multirate enabled subsystem ''{0}'' as configured for a variable-size input. Since the subsystem ''{1}'' is multirate and the parameter ''Propagate sizes of variable-size signals'' of the control port ''{2}'' is set to ''Only when enabling'', this subsystem cannot accept any variable-size signals as input. Consider using a single-rate enabled subsystem instead.</entry>
    <entry key="VarDimsTrivialRTBNotAllowed">Rate Transition Block ''{0}'' cannot be used with a variable-size signal when the block parameter ''Ensure data integrity during data transfer'' is disabled. To eliminate this message, enable that parameter.</entry>
    <entry key="VarDimsDeferredRTBNotAllowed">지연 모드에서는 Rate Transition 블록 ''{0}''에 가변 크기 신호를 사용할 수 없습니다.</entry>
    <entry key="VarSTInpPortIsFrameBased">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;가 가변 샘플 시간을 갖는데도 프레임 기반으로 설정되었습니다. 프레임 기반 신호는 이산 샘플 시간을 가져야 합니다.</entry>
    <entry key="VectToMatrixConversionByBlock">1차원 배열과 2차원 벡터(행렬) 신호가 함께 ''{0}''을(를) 구동합니다. 이로 인해 1차원 신호가 2차원 벡터 신호로 자동으로 변환되었습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;Reshape 사용&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''VectorMatrixConversionMsg'',''none'')&lt;/cmd&gt; &lt;txt&gt;이 메시지를 표시하지 않으려면 &lt;sldiag objui="configset" objparam="VectorMatrixConversionMsg"&gt;벡터/행렬 블록 입력 변환&lt;/sldiag&gt;을 ''안 함''으로 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="VirtSubsysDoesNotHaveThis">''{1}''은(는) 비활성 Variant나 주석 처리된 블록 계층 구조 또는 가상 서브시스템의 일부일 수 있기 때문에 서브시스템 ''{0}''에 없습니다</entry>
    <entry key="ModelIsNotYetLinked">모델이 초기화되지 않은 경우 이 명령을 사용할 수 없습니다. 먼저 feval(bdroot, ''Init'')를 실행하십시오.</entry>
    <entry key="VirtSubsysHasNoSList">Virtual subsystem ''{0}'' does not have a sorted list.</entry>
    <entry key="WaitingForDisconnectResponse">연결 해제 메시지가 {0,number,integer}초 전에 타깃에 전송되었습니다. 응답을 기다리는 중입니다.</entry>
    <entry key="WaitingForFinalLogBufferTerminator">{0,number,integer}초 전에 타깃으로부터 종료 메시지가 수신되었습니다. 최종 데이터 기록 버퍼와 기록 종단을 기다리는 중입니다.</entry>
    <entry key="WarnAlgLoopsFound" context="warning">모델 ''{0}''에 대수 루프가 {1,number,integer}개 포함되어 있습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;Simulink.BlockDiagram.getAlgebraicLoops(''{0}'');&lt;/cmd&gt; &lt;txt&gt;Simulink.BlockDiagram.getAlgebraicLoops 함수를 사용하여 모델에 포함된 대수 루프에 대한 정보를 강조 표시하고 확인하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{0}'','AlgebraicLoopMsg', 'none');&lt;/cmd&gt; &lt;txt&gt;이 진단을 표시하지 않으려면 '대수 루프' 진단 파라미터를 '안 함'으로 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="WarnAlgLoopsFoundInDebugger" context="warning">모델 ''{0}''에 대수 루프가 {1,number,integer}개 포함되어 있습니다. 모델 내 루프에 대한 정보를 가져오려면 sldebug 함수를 사용하여 Simulink 프로그래밍 디버그 인터페이스를 시작한 후 ashow 함수를 사용하십시오.</entry>
    <entry key="WarnArtAlgLoopMdlPortDF" context="warning">모델 ''{1}''에 입력 포트''{0}''에서 하나 이상의 루트 수준 출력 포트로의 직접 피드스루 경로가 포함되어 있어 소프트웨어가 모델 ''{1}''에 대한 참조를 포함하는 인위적 대수 루프를 제거할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;소프트웨어가 인위적 대수 루프를 제거할 수 있도록 하여 이 경고를 해결하려면 입력 포트 ''{0}''에 루트 수준 출력 포트로의 직접 피드스루가 없도록 모델 ''{1}''의 내용을 수정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;모델의 내용을 수정하지 않고 이 경고를 제거하려면 모델 ''{1}''에 대한 ''인위적 대수 루프 발생 최소화'' 구성 파라미터의 선택을 해제하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;</entry>
    <entry key="WarnArtAlgLoopSysPortDF">Subsystem ''{1}'' contains a direct feedthrough path from input port ''{0}'' to one or more subsystem output ports that prevents the software from removing artificial algebraic loops that involve subsystem ''{1}''.
	&lt;actions exclusiveFixIts="yes"&gt;
    &lt;action type="suggestion"&gt;
    &lt;txt&gt;To resolve this warning by enabling the software to remove the artificial algebraic loop, modify the contents of subsystem ''{1}'' such that input port ''{0}'' does not have direct feedthrough to any output ports of subsystem ''{1}''.&lt;/txt&gt;
    &lt;/action&gt;
	&lt;action type="suggestion"&gt;
    &lt;txt&gt;To eliminate this warning without modifying the contents of the subsystem, clear the ''Minimize artificial algebraic loop occurrences'' parameter of subsystem ''{1}''.&lt;/txt&gt;
    &lt;/action&gt;
    &lt;/actions&gt;</entry>
    <entry key="WarnArtAlgLoopLoggingDF">Atomic Subsystem 또는 참조된 모델 ''{0}''이(가) 인위적 대수 루프의 일부인 경우, 직접 피드스루 경로에 있는 하나 이상의 신호가 신호 기록 또는 데이터를 기록하는 블록을 사용하여 기록되었기 때문에 소프트웨어가 루프를 제거할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;소프트웨어가 인위적 대수 루프를 제거할 수 있도록 하여 이 경고를 해결하려면, ''{0}'' 내의 직접 피드스루 경로에 있는 신호(예: 블록 ''{1}''의 출력)를 기록하지 마십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;인위적 대수 루프를 제거하지 않고 이 경고를 제거하려면, Atomic Subsystem 또는 참조된 모델 ''{0}''에 대한 ''인위적 대수 루프 발생 최소화'' 파라미터의 선택을 해제하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="WarnForFrameUpgrade">Block ''{0}'' uses the frame status of the signal. Update your model to move control of sample-based and frame-based processing from the frame status of the signal to the block dialog parameters. For help in resolving this and other upgrade issues, run the 'Check model for block upgrade issues requiring compile time information' check in &lt;a href="matlab:{1}"&gt;the Simulink Upgrade Advisor&lt;/a&gt;.\n\nTo identify user-created library blocks with frame upgrade issues, run the 'Check model for custom library blocks that rely on frame status of the signal' check in the Upgrade Advisor.\n\nFor general information about the changes to frame-based processing, see your product-specific Release Notes.</entry>
    <entry key="WarnForFrameObjUpgrade">모델에 'SamplingMode' 설정이 '프레임 기반'으로 설정된 Simulink.Signal 객체가 하나 이상 있습니다. 설정을 직접 'auto'로 변경하십시오.</entry>
    <entry key="WebBlockCallbackEvalErr">''{1}''의 ''{0}'' 콜백을 실행하는 중 오류가 발생했습니다. \n콜백 문자열은 ''{2}''입니다</entry>
    <entry key="WebBlockInPanelCallbackEvalErr">패널 ''{2}''에서 ''{1}''의 ''{0}'' 콜백을 실행하는 중 오류가 발생했습니다. \n콜백 문자열은 ''{3}''입니다</entry>
    <entry key="WidthNotMatchMatlab">지정된 MATLAB 배열의 너비가 Simulink 내부 데이터의 너비와 일치하지 않음</entry>
    <entry key="kthDimensionsNotMatchMatlab">지정된 MATLAB 배열의 {0,number,integer}번째 차원이 Simulink 내부 데이터의 차원과 일치하지 않음</entry>
    <entry key="SimStepperWrongStage"> 현재 단계에서는 메서드를 호출할 수 없습니다. </entry>
    <entry key="SimStepperWrongMode">현재 시뮬레이션 모드에서는 SimStepper를 사용할 수 없습니다. 현재로서는 표준 모드에서만 모델에 SimStepper를 사용할 수 있습니다.</entry>
    <entry key="SimStepperModelExistsWhileInit">모델 ''{0}''이(가) 이미 실행 중입니다.</entry>
    <entry key="SimStepperOnlySingleTasking">SimStepper에서는 '구성 파라미터' &gt; '솔버' &gt; '각 이산 레이트를 별개의 태스크로 처리' 옵션을 선택할 수 없습니다.</entry>
    <entry key="StringNumberConsecutiveZc">연속 영점교차 개수</entry>
    <entry key="StringZcSignalName">영점교차 신호 이름</entry>
    <entry key="StringZcSignalIndex">영점교차 신호 인덱스</entry>
    <entry key="StringBlockType">블록 유형</entry>
    <entry key="StringBlockPath">블록 경로</entry>
    <entry key="StringTime">시간</entry>
    <entry key="StringReason">이유</entry>
    <entry key="StringSuggestion">제안</entry>
    <entry key="SparseMethodMayCauseProblem">모델 ''{0}''에 대해 솔버 야코비 방법 파라미터가 희소 방법으로 설정되었습니다. 모델 크기가 큰 경우 이 설정으로 인해 시뮬레이션 시간이 느려지거나 메모리 할당 오류가 발생할 수 있습니다. 이러한 문제가 발생하면 이 파라미터에 비희소 섭동 방법을 선택하십시오.</entry>
    <entry key="AnalyticalJacobianNotSupportPlugin">모델 ''{0}''에 대한 ''솔버 야코비 행렬 방법'' 파라미터 값은 ''비희소 섭동'' 또는 ''희소 섭동'이어야 합니다.</entry>
    <entry key="NoAnalyticalSlvrJacobian">이유는 다음과 같습니다.\n{0}\n </entry>
    <entry key="NoAnalyticalJacobian">블록에 해석적 야코비 행렬이 없음</entry>
    <entry key="AnalyticalJacobianIsNotExact">해석적 야코비 행렬이 정확하지 않음</entry>
    <entry key="AnalyticalJacobianIsNotExactSuggestion">'블록 파라미터' 대화 상자에서 '선형화할 때 이득으로 처리'를 끄십시오.</entry>
    <entry key="HasDataStoreForSlvrJacobian">모델에 Data Read 블록 또는 Data Write 블록이 있습니다. </entry>
    <entry key="TooMuchMemoryForSlvrJacobian">원래 메서드를 선택하려면 너무나 많은 메모리가 필요합니다. </entry>
    <entry key="UseFullPerturbationToAvoidMemoryError">메모리가 부족하여 솔버 야코비 행렬의 패턴을 계산할 수 없습니다. 이 오류를 해결하려면 구성 파라미터 대화 상자의 솔버 창에서 ''솔버 야코비 방법''을 ''비희소 섭동''으로 설정하십시오.</entry>
    <entry key="EmptySlvrJacobian">솔버 야코비 행렬이 빈 행렬입니다. </entry>
    <entry key="ContainsLocalSolversForSolverJacobian">모델에 로컬 솔버를 사용하도록 구성된 참조된 모델이 하나 이상 포함되어 있습니다. </entry>
    <entry key="InvalidArraySize">Simulink는 최대 {0,number,integer}개 바이트의 신호 크기를 지원합니다. 신호 크기는 데이터형 크기, 요소 개수 및 신호 유형(실수/복소수)을 기반으로 계산됩니다. 블록 ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에서 시작된 신호가 {0,number,integer}보다 큰 신호 크기를 갖습니다. 모델을 컴파일하거나 시뮬레이션하기 전에 신호 크기를 줄여 보십시오.</entry>
    <entry key="InvalidBlockIOSize">Simulink supports total block I/O buffer size up to {0,number,integer} number of bytes. The total block I/O size is calculated based on data type size, number of elements, and signal type (real/complex) of all signals in the model. Consider reducing signal sizes before compiling or simulating the model.</entry>
    <entry key="InvalidParameterSize">Simulink supports parameter size up to {0,number,integer} number of bytes. This size is calculated based on data type size, number of elements, and signal type (real/complex). Parameter ''{1}'' of block ''{2}'' has a size greater than {0,number,integer}. Consider reducing the parameter size before compiling or simulating the model.</entry>
    <entry key="InputPortStrLC">입력 포트</entry>
    <entry key="OutputPortStrLC">출력 포트</entry>
    <entry key="InvSignalDimensionSize">Simulink supports signal dimension size up to {0,number,integer}, which is the maximum allowable 32-bit signed integer value. The dimension size specified on or computed for {1} {2,number,integer} of ''{3}'' exceeds this limit. Consider reducing the signal size before compiling or simulating the model.</entry>
    <entry key="InvDimensionSize">Simulink supports signal and parameter dimension size up to {0,number,integer}, which is the maximum allowable 32-bit signed integer value. Consider reducing the signal or parameter size before compiling or simulating the model.</entry>
    <entry key="CannotMixDynAndInfInDimensionSpec">Dimension specification cannot contain a combination of inherited (-1) and unbounded (inf) values.</entry>
    <entry key="InfDimensionSpecRequiresNumDimensions">Dimension specification containing an unbounded (inf) value must provide number of dimensions.</entry>
    <entry key="InvalidDWorkOffsetSize">Simulink supports discrete states/dwork size  up to {0,number,integer} number of bytes. It uses the size of each discrete state to calculate the offset needed for internal memory alignment.  The size of the offset is calculated based on data type size, number of elements, and type (real/complex). The computed offset of discrete state or dwork of the block ''{1}''  is greater than {2,number,integer}. Consider reducing the discrete state/dwork or the signal width before compiling or simulating the model.</entry>
    <entry key="InvalidModelRefAccelDWorkSize">Simulink supports discrete states/dwork size, for Model Reference in Accelerator mode, up to {0,number,integer} number of bytes. The size of discrete states or dwork of the Model block ''{1}''  is greater than {2,number,integer}. Consider reducing the discrete states/dwork or the signal width before compiling or simulating the model.</entry>
    <entry key="InvalidVarDimsRootInportForEnabledModel">루트 인포트 ''{0}''에 가변 크기 신호인 출력이 있습니다. 모델에 루트 수준 인에이블 포트 ''{1}''이(가) 있으므로 이것은 허용되지 않습니다.</entry>
    <entry key="InvalidVarDimsRootOutportForEnabledModel">루트 아웃포트 ''{0}''에 가변 크기 신호인 입력이 있습니다. 모델에 루트 수준 인에이블 포트 ''{1}''이(가) 있으므로 이것은 허용되지 않습니다.</entry>
    <entry key="ParamNotAllowed">Failed to set the parameter ''{0}'' for the model ''{1}''. Parameter ''{0}'' applies only to libraries.</entry>
    <entry key="ParamNotAllowedGeneric">Cannot set parameter ''{0}'' because it is not allowed ({1}: ''{2}'')</entry>
    <entry key="Model">모델</entry>
    <entry key="Library">라이브러리</entry>
    <entry key="Subsystem">서브시스템</entry>
    <entry key="STFNotSupported">The selected system target file ''{0}'' is not currently supported for concurrent execution.</entry>
    <entry key="SILPILNotSupportedForConcurrency">현재 SIL 모드와 PIL 모드는 동시 실행을 지원하지 않습니다.</entry>
    <entry key="IDsLessThanDynamic">dynamic보다 작은 ID를 가질 수 없습니다.</entry>
    <entry key="DynamicMixError">[항상 필요]와 [동적으로 필요]를 함께 사용할 수 없음</entry>
    <entry key="ConditionalMixError">입력 포트와 출력 포트의 조건부 ID가 동일할 수 없음</entry>
    <entry key="NoCompiledModel">종료할 컴파일된 모델이 없음</entry>
    <entry key="UseTopModel">참조된 모델 ''{0}''에서 이 API를 호출할 수 없습니다. 대신, 컴파일된 계층 구조의 최상위 모델(''{1}'')을 사용하십시오.</entry>
    <entry key="InvalidBlockDiagram">Invalid block diagram</entry>
    <entry key="UninitializedModel">모델이 초기화되지 않음</entry>
    <entry key="ModelNotCompiledForQuery">Model is not compiled for this query</entry>
    <entry key="UnknownModel">알 수 없는 모델</entry>
    <entry key="FixUseDblUsage">더 이상 사용하지 않는 방식으로 전역 변수 'FixUseDbl'이 사용되었습니다. 데이터형 재정의 상태를 설정하려면 모델 또는 서브시스템 수준에서 'DataTypeOverride'의 파라미터를 설정하십시오.</entry>
    <entry key="FixLogPrefUsage">더 이상 사용하지 않는 방식으로 전역 변수 'FixLogPref'가 사용되었습니다. 최소/최대/오버플로 기록 상태를 설정하려면 모델 또는 서브시스템 수준에서 'MinMaxOverflowLogging'의 파라미터를 설정하십시오.</entry>
    <entry key="InvalidRTWIndex">내부 오류: ''{0}''에 유효하지 않은 RTWIndex가 있음</entry>
    <entry key="NotCurrentNetList">내부 오류: ''{0}''이(가) 현재 net-list의 일부가 아닙니다.</entry>
    <entry key="CompRTWCGDiffRTWIndex">내부 오류: ''{0}''에 첫 번째 인스턴스 ''{3}''과(와) 다른 RTWIndex {1,number,integer} != {2,number,integer}이(가) 있습니다.</entry>
    <entry key="CompRTWCGDiffInputType">내부 오류: ''{0}''에 첫 번째 인스턴스 ''{3}''과(와) 다른 입력 유형 {1,number,integer} != {2,number,integer}이(가) 있습니다.</entry>
    <entry key="CompRTWCGDiffOutputType">내부 오류: ''{0}''에 첫 번째 인스턴스 ''{3}''과(와) 다른 출력 유형 {1,number,integer} != {2,number,integer}이(가) 있습니다.</entry>
    <entry key="SubsystemHiddenParameterImproperlyAccessed">Using a testing get_param that is valid only if you do model([],[],[],'compileForRTW') first.</entry>
    <entry key="VirtualSubsystemHiddenParameterImproperlyAccessed">비가상 서브시스템에만 유효한 테스트 get_param이 사용되었습니다.</entry>
    <entry key="RealizingTransformedBlocksIsDebugOnly">Realizing blocks from the transformed graph into the visible graph is a feature to be used only in internal debugging and testing.</entry>
    <entry key="ShadowedModelName">가려진 모델 이름</entry>
    <entry key="CannotInitMLSysForCodeGen">Model ''{0}'' contains one or more MATLAB System blocks and is configured to load initial states. This capability is only supported for Normal mode.
    </entry>
    <entry key="ConflictingEnumerationAlreadyPresentInModelReference">
      참조 모델 {1} 내에서 상태 활동을 출력하는 데 사용되는 열거형 ''{0}''이(가) 참조 모델 {2} 내에서 상태 활동을 출력하는 데 사용되는 열거형과 충돌됩니다.
    </entry>
    <entry key="DisableVolatileCSCForCPPClass">The usage of custom storage class ''{0}'' with C++ class code generation is not supported, because the custom storage class uses a ''Volatile'' specification.</entry>
    <entry key="DisableOtherTypeCSCForCPPClass">The usage of C++ class code generation with custom storage class ''{0}'' is not supported, because the custom storage class'' CSCType is ''Other''.</entry>
    <entry key="DisableVolatileMemSecForCPPClass">The usage of memory section ''{0}'' for parameter ''{1}'' with C++ class code generation is not supported, because the memory section uses a ''Volatile'' specification.</entry>
    <entry key="StateOwnerRequirementsForStateReader">Block ''{0}'' has attributes or configurations that are not supported by State Reader block ''{1}''.</entry>
    <entry key="StateOwnerRequirementsForStateWriter">Block ''{0}'' has attributes or configurations that are not supported by State Writer block ''{1}''.</entry>
    <entry key="StateOwnerRequirementsForStateAccessInChart">블록 ''{0}''에 차트 ''{1}''에서 텍스트 상태 액세스로 지원하지 않는 특성 또는 구성이 있습니다.</entry>
    <entry key="StateOwnerFrameInput">블록 ''{0}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;에 프레임 기반 신호가 있습니다.</entry>
    <entry key="StateOwnerFrameOutput">블록 ''{0}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에 프레임 기반 신호가 있습니다.</entry>
    <entry key="StateOwnerVarDimsInput">블록 ''{0}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;에 가변 크기 신호가 있습니다.</entry>
    <entry key="StateOwnerVarDimsOutput">블록 ''{0}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에 가변 크기 신호가 있습니다.</entry>
    <entry key="StateOwnerVirtualBusInput">블록 ''{0}''의 {1,number,integer}번 입력 포트에 가상 버스 신호가 있습니다. 블록 ''{2}''이(가) 비가상 버스를 지원하는지 문서에서 확인하십시오.</entry>
    <entry key="StateOwnerVirtualBusOutput">블록 ''{0}''의 {1,number,integer}번 출력 포트에 가상 버스 신호가 있습니다. 블록 ''{2}''이(가) 비가상 버스를 지원하는지 문서에서 확인하십시오.</entry>
    <entry key="StateOwnerStatePort">블록 ''{0}''에 상태 포트가 있습니다.</entry>
    <entry key="StateOwnerResetPort">블록 ''{0}''에 재설정 포트가 있습니다.</entry>
    <entry key="StateOwnerInitCondPort">블록 ''{0}''에 초기 조건 포트가 있습니다.</entry>
    <entry key="StateOwnerInInitSS">Block ''{0}'' is inside an Initialize Function block.</entry>
    <entry key="StateOwnerInSubsystemResettingStates">블록 ''{0}''은(는) 상태를 재설정할 수 있는 서브시스템 내에 있습니다. 상태를 재설정할 수 있는 서브시스템의 예로는 Resettable Subsystem 또는 Enable Port 블록의 파라미터 ''활성화할 때의 상태''를 "재설정''으로 지정해 둔 Enabled Subsystem을 들 수 있습니다.</entry>
    <entry key="StateOwnerFrameBasedProcessing">블록 ''{0}''에서 파라미터 ''입력 처리''가 ''열을 채널로(프레임 기반)''로 설정되어 있습니다. 파라미터를 ''요소를 채널로(샘플 기반)''로 설정해 보십시오.</entry>
    <entry key="StateOwnerCircularBuffer">블록 ''{0}''에서 파라미터 ''상태에 원형 버퍼 사용''의 선택을 취소해야 합니다.</entry>
    <entry key="StateOwnerZeroDelay">블록 ''{0}''에서 파라미터 ''지연 길이''가 0으로 설정되어 있습니다.</entry>
    <entry key="StateOwnerDiscIntegratorInTrigSS">Discrete-Time Integrator block ''{0}'' cannot be within a triggered subsystem with the parameter 'Integrator method' set to 'Integration:'. Switch the integrator method to be of type 'Accumulation:'.</entry>
    <entry key="StateOwnerDiscIntegratorICMode">Discrete-Time Integrator 블록 ''{0}''의 파라미터 ''초기 조건 설정''을 '자동'으로 설정해야 합니다.</entry>
    <entry key="StateOwnerDiscIntegratorLimitOutput">Discrete-Time Integrator 블록 ''{0}''에서 파라미터 ''출력 제한''의 선택을 취소해야 합니다.</entry>
    <entry key="StateAccessForOutportResetWhenDisabled">Outport 블록 ''{0}''의 파라미터 ''비활성인 경우 출력''을 ''유지''로 설정해야 합니다.</entry>
    <entry key="StateAccessForOutportInheritIC">Outport 블록 ''{0}''이(가) 자신의 소스로부터 초기 출력값을 상속하고 있습니다. 이 문제를 해결하려면 ''초기 출력'' 파라미터가 빈 행렬([])이 아닌 다른 값으로 설정되어 있는지 확인하십시오.</entry>
    <entry key="StateAccessForMessageOutport">Outport 블록 ''{0}''이(가) 메시지를 출력하는 중입니다.</entry>
    <entry key="StateAccessSrcDataTypeMismatch">Outport 블록 ''{0}''의 입력 데이터형은 ''{1}''입니다. 그러나 소스 블록 ''{2}''의 출력 데이터형은 ''{3}''입니다. outport 블록이 상태 소유자인 경우 이 두 유형은 일치해야 합니다. </entry>
    <entry key="StateAccessForMergedOutport">Outport 블록 ''{0}''에 대응하는 서브시스템 출력이 Merge 블록 ''{1}''에 연결되어 있습니다.</entry>
    <entry key="StateAccessForSignedTriggerPort">Trigger Port 블록 ''{0}''에서 해당 부모 서브시스템의 트리거 포트가 부호 있는 데이터형 ''{1}''입니다. ''boolean'' 또는 ''uint32'' 같은 부호 없는 데이터형을 사용해 보십시오.</entry>
    <entry key="StateAccessForEitherRisingOrFallingTriggerPort">파라미터 ''트리거 유형''이 ''양쪽 모두 가능''으로 설정된 경우 State Reader 블록 또는 State Writer 블록을 지원하려면 Trigger Port 블록 ''{0}''의 파라미터 ''초기 트리거 신호 상태''가 ''0'' 또는 ''양수''로 설정되어야 합니다.</entry>
    <entry key="StateOwnerFcnCall">블록 ''{0}''의 상태가 함수 호출 데이터형으로 설정되어 있습니다. State Reader 블록과 State Writer 블록은 함수 호출을 지원하지 않습니다.</entry>
    <entry key="StateOwnerEmptyStates">블록 ''{0}''의 상태가 비어 있습니다.</entry>
    <entry key="StateAccessContStateMultiState">블록 ''{0}''의 상태가 여러 개입니다. 외부에서 상태에 액세스하려면 한 개의 상태만 지원됩니다.</entry>
    <entry key="StateAccessContStateInvalidName">''{1}''의 파라미터 ''{0}''에 대한 식별자가 액세스에 유효한 상태 이름이 아닙니다. 외부에서 상태에 액세스할 때 유효한 상태 이름은 따옴표 사이에 있고, 영문자 또는 ''_'' 문자로 시작한 다음 영숫자 또는 ''_'' 문자가 오는 식별자입니다.</entry>
    <entry key="TextualAccessStateInvalidName">''{1}''의 상태에 할당된 이름 ''{0}''은(는) 유효한 식별자가 아닙니다. 텍스트 상태에 액세스할 때 유효한 식별자는 영문자 또는 ''_'' 문자로 시작한 다음 영숫자 또는 ''_'' 문자가 오는 식별자입니다.</entry>
    <entry key="State">상태</entry>
    <entry key="Parameter">파라미터</entry>
    <entry key="InconsistentReaderDims">블록 ''{2}''에 의해 계산된 {0} 차원 {1}이(가) {0} Reader 블록 ''{4}''에 의해 계산된 출력 신호 차원 {3}과(와) 일치하지 않습니다.</entry>
    <entry key="InconsistentWriterDims">The {0} dimensions {1} computed by block ''{2}'' is inconsistent with input signal dimensions {3} computed by the {0} Writer block ''{4}''.</entry>
    <entry key="InconsistentParameterWriterDims">Parameter Writer 블록 ''{4}''의 입력 신호 차원은 {3}인데 반해, 블록 ''{2}''이(가) 소유한 파라미터 ''{0}''의 차원은 ''{1}''입니다. Parameter Writer 블록에 제공된 차원이 해당 파라미터 차원과 동일한지 확인하십시오.</entry>
    <entry key="InconsistentDefaultReaderDims">과소 지정으로 인해 Simulink에서 블록 ''{0}''의 신호 차원을 확인하는 데 발견법(Heuristics)을 사용했습니다. 그런데 이 블록에서 계산된 결과 차원 {1}이(가) Reader 블록 ''{3}''에서 계산된 출력 신호 차원 {2}과(와) 일치하지 않습니다. 이 문제가 발생하지 않도록 하려면 블록 ''{4}''의 모든 입력 신호와 출력 신호에 차원을 완전히 지정해 보십시오.</entry>
    <entry key="InconsistentDefaultWriterDims">Simulink used heuristics to determine signal dimensions for block ''{0}'' due to underspecification. However, the resulting state dimensions {1} computed by this block is inconsistent with input signal dimensions {2} computed by the Writer block ''{3}''. Consider specifying dimensions for all input and output signals of block ''{4}'' fully to avoid this problem.</entry>
    <entry key="InconsistentReaderDataType">블록 ''{2}''에서 계산된 {0} 데이터형 ''{1}''이(가) {0} Reader 블록 ''{4}''에서 계산된 출력 신호 데이터형 ''{3}''과(와) 일치하지 않습니다.</entry>
    <entry key="InconsistentWriterDataType">The {0} data type ''{1}'' computed by block ''{2}'' is inconsistent with the input signal data type ''{3}'' computed by {0} Writer block ''{4}''.</entry>
    <entry key="InconsistentParameterWriterDataType">Parameter Writer 블록 ''{4}''의 입력 신호 데이터형은 {3}인데 반해, 블록 ''{2}''이(가) 소유한 파라미터 ''{0}''의 데이터형은 ''{1}''입니다. Parameter Writer 블록의 입력 데이터형이 해당 파라미터의 데이터형과 동일한지 확인하십시오.</entry>
    <entry key="InconsistentParameterWriterToWSVarDims">Parameter Writer 블록 ''{3}''의 입력 신호 차원은 {2}인데 반해, 현재 모델 작업 공간의 파라미터 ''{0}''의 차원은 ''{1}''입니다. Parameter Writer 블록에 제공된 차원이 해당 파라미터 차원과 동일한지 확인하십시오.</entry>
    <entry key="InconsistentChartAndOwnerDataType">블록 ''{1}''에서 계산된 상태 데이터형 ''{0}''이(가) 차트 ''{3}''에서 계산된 데이터형 ''{2}''과(와) 일치하지 않습니다.</entry>
    <entry key="InconsistentDefaultReaderDataType">과소 지정으로 인해 Simulink에서 블록 ''{0}''의 신호 데이터형을 확인하는 데 발견법(Heuristics)을 사용했습니다. 그런데 이 블록에서 계산된 결과 데이터형 ''{1}''이(가) Reader 블록 ''{3}''에서 계산된 출력 신호 데이터형 ''{2}''과(와) 일치하지 않습니다. 이 문제가 발생하지 않도록 하려면 블록 ''{4}''의 모든 입력 신호와 출력 신호에 데이터형을 완전히 지정해 보십시오.</entry>
    <entry key="InconsistentDefaultWriterDataType">과소 지정으로 인해 Simulink에서 블록 ''{0}''의 신호 데이터형을 확인하는 데 발견법(Heuristics)을 사용했습니다. 그런데 이 블록에서 계산된 결과 데이터형 ''{1}''이(가) Writer 블록 ''{3}''에서 계산된 입력 신호 데이터형 ''{2}''과(와) 일치하지 않습니다. 이 문제가 발생하지 않도록 하려면 블록 ''{4}''의 모든 입력 신호와 출력 신호에 데이터형을 완전히 지정해 보십시오.</entry>
    <entry key="InconsistentReaderComplexSignal1">블록 ''{1}''에서 계산된 {0} 신호 유형 ''실수''가 {0} Reader 블록 ''{2}''에서 계산된 출력 신호 유형 ''복소수''와 일치하지 않습니다.</entry>
    <entry key="InconsistentReaderComplexSignal2">블록 ''{1}''에서 계산된 {0} 신호 유형 ''복소수''가 {0} Reader 블록 ''{2}''에서 계산된 출력 신호 유형 ''실수''와 일치하지 않습니다.</entry>
    <entry key="InconsistentWriterComplexSignal1">블록 ''{1}''에서 계산된 {0} 신호 유형 ''실수''가 {0} Writer 블록 ''{2}''에서 계산된 입력 신호 유형 ''복소수''와 일치하지 않습니다.</entry>
    <entry key="InconsistentWriterComplexSignal2">블록 ''{1}''에서 계산된 {0} 신호 유형 ''복소수''가 {0} Writer 블록 ''{2}''에서 계산된 입력 신호 유형 ''실수''와 일치하지 않습니다.</entry>
    <entry key="InconsistentParameterWriterComplexSignal1">블록 ''{1}''이(가) 소유한 파라미터 ''{0}''의 신호 유형 ''실수''가 Parameter Writer 블록 ''{2}''에서 계산된 입력 신호 유형 ''복소수''와 일치하지 않습니다.</entry>
    <entry key="InconsistentParameterWriterComplexSignal2">블록 ''{1}''이(가) 소유한 파라미터 ''{0}''의 신호 유형 ''복소수''가 Parameter Writer 블록 ''{2}''에서 계산된 입력 신호 유형 ''실수''와 일치하지 않습니다.</entry>
    <entry key="InconsistentDefaultReaderComplexSignal1">과소 지정으로 인해 Simulink에서 블록 ''{0}''의 신호 유형을 확인하는 데 발견법(Heuristics)을 사용했습니다. 그런데 이 블록에서 계산된 결과 신호 유형 ''실수''가 Reader 블록 ''{1}''에서 계산된 출력 신호 유형 ''복소수''와 일치하지 않습니다. 이 문제가 발생하지 않도록 하려면 블록 ''{2}''의 모든 입력 신호와 출력 신호에 신호 유형을 완전히 지정해 보십시오.</entry>
    <entry key="InconsistentDefaultReaderComplexSignal2">과소 지정으로 인해 Simulink에서 블록 ''{0}''의 신호 유형을 확인하는 데 발견법(Heuristics)을 사용했습니다. 그런데 이 블록에서 계산된 결과 신호 유형 ''복소수''가 Reader 블록 ''{1}''에서 계산된 출력 신호 유형 ''실수''와 일치하지 않습니다. 이 문제가 발생하지 않도록 하려면 블록 ''{2}''의 모든 입력 신호와 출력 신호에 신호 유형을 완전히 지정해 보십시오.</entry>
    <entry key="InconsistentDefaultWriterComplexSignal1">과소 지정으로 인해 Simulink에서 블록 ''{0}''의 신호 유형을 확인하는 데 발견법(Heuristics)을 사용했습니다. 그런데 이 블록에서 계산된 결과 신호 유형 ''실수''가 Writer 블록 ''{1}''에서 계산된 입력 신호 유형 ''복소수''와 일치하지 않습니다. 이 문제가 발생하지 않도록 하려면 블록 ''{2}''의 모든 입력 신호와 출력 신호에 신호 유형을 완전히 지정해 보십시오.</entry>
    <entry key="InconsistentDefaultWriterComplexSignal2">과소 지정으로 인해 Simulink에서 블록 ''{0}''의 신호 유형을 확인하는 데 발견법(Heuristics)을 사용했습니다. 그런데 이 블록에서 계산된 결과 신호 유형 ''복소수''가 Writer 블록 ''{1}''에서 계산된 입력 신호 유형 ''실수''와 일치하지 않습니다. 이 문제가 발생하지 않도록 하려면 블록 ''{2}''의 모든 입력 신호와 출력 신호에 신호 유형을 완전히 지정해 보십시오.</entry>
    <entry key="SFcnStateWidthChangeInMdlSetWorkWidths">S-Function 블록 ''{1}''의 작업 벡터 ''{0}''의 너비가 mdlInitializeSizes의 {2,number,integer}에서 mdlSetWorkWidths의 {3,number,integer}(으)로 변경되었습니다. mdlSetWorkWidths에서 ssSetDWorkWidth 호출을 제거하거나, ssSetDWorkWidth를 통해 이 작업 벡터의 너비가 mdlInitializeSizes에 DYNAMICALLY_SIZED로 설정되었는지 확인해 보십시오.</entry>
    <entry key="SFcnStateDataTypeChangeInMdlSetWorkWidths">S-Function 블록 ''{1}''의 작업 벡터 ''{0}''의 데이터형이 mdlInitializeSizes의 ''{2}''에서 mdlSetWorkWidths의 ''{3}''(으)로 변경되었습니다. mdlSetWorkWidths에서 ssSetDWorkDataType 호출을 제거하거나, ssSetDWorkDataType을 통해 이 작업 벡터의 데이터형이 mdlInitializeSizes에 DYNAMICALLY_TYPED로 설정되었는지 확인해 보십시오.</entry>
    <entry key="SFcnStateComplexSignalChangeInMdlSetWorkWidths1">S-Function 블록 ''{1}''의 작업 벡터 ''{0}''의 신호 유형이 mdlInitializeSizes의 ''실수''에서 mdlSetWorkWidths의 ''복소수''로 변경되었습니다. mdlSetWorkWidths에서 ssSetDWorkComplexSignal 호출을 제거하거나, ssSetDWorkComplexSignal을 통해 이 작업 벡터의 신호 유형이 mdlInitializeSizes에 DYNAMICALLY_TYPED로 설정되었는지 확인해 보십시오.</entry>
    <entry key="SFcnStateComplexSignalChangeInMdlSetWorkWidths2">S-Function 블록 ''{1}''의 작업 벡터 ''{0}''의 신호 유형이 mdlInitializeSizes의 ''복소수''에서 mdlSetWorkWidths의 ''실수''로 변경되었습니다. mdlSetWorkWidths에서 ssSetDWorkComplexSignal 호출을 제거하거나, ssSetDWorkComplexSignal을 통해 이 작업 벡터의 신호 유형이 mdlInitializeSizes에 DYNAMICALLY_TYPED로 설정되었는지 확인해 보십시오.</entry>
    <entry key="InconsistentStateReaderDimsSFcn">S-Function 블록 ''{2}''의 작업 벡터 ''{1}'' 의 차원 {0}이(가) State Reader 블록 ''{4}''의 출력 신호 차원 {3}과(와) 일치하지 않습니다. 이 작업 벡터에 대한 ssSetDWorkWidth 호출을 mdlSetWorkWidths에서 mdlInitializeSizes로 옮겨 보십시오. 또는 Signal Specification 블록을 사용하는 방법 등으로 State Reader 블록의 출력 포트가 일치하는 차원을 갖는지 확인하십시오.</entry>
    <entry key="InconsistentStateReaderDimsSFcnDefault">Simulink에서 S-Function 블록 ''{2}''의 작업 벡터 ''{1}''의 차원 {0}을(를) 확인하는 데 발견법(Heuristics)을 사용했습니다. 그런데 결과가 State Reader 블록 ''{4}''의 출력 신호 차원 {3}과(와) 일치하지 않습니다. mdlInitializeSizes 또는 mdlSetWorkWidths에 ssSetDWorkWidth를 사용하여 이 작업 벡터의 차원을 지정해 보십시오.</entry>
    <entry key="InconsistentStateWriterDimsSFcnDefault">Simulink에서 S-Function 블록 ''{2}''의 작업 벡터 ''{1}''의 차원 {0}을(를) 확인하는 데 발견법(Heuristics)을 사용했습니다. 그런데 결과가 State Writer 블록 ''{4}''의 입력 신호 차원 {3}과(와) 일치하지 않습니다. mdlInitializeSizes 또는 mdlSetWorkWidths에 ssSetDWorkWidth를 사용하여 이 작업 벡터의 차원을 지정해 보십시오.</entry>
    <entry key="InconsistentStateReaderDataTypeSFcn">S-Function 블록 ''{2}''의 작업 벡터 ''{1}'' 의 데이터형 ''{0}''이(가) State Reader 블록 ''{4}''의 출력 신호 데이터형 ''{3}''과(와) 일치하지 않습니다. 이 작업 벡터에 대한 ssSetDWorkDataType 호출을 mdlSetWorkWidths에서 mdlInitializeSizes로 옮겨 보십시오. 또는 Signal Specification 블록을 사용하는 방법 등으로 State Reader 블록의 출력 포트가 일치하는 데이터형을 갖는지 확인하십시오.</entry>
    <entry key="InconsistentStateWriterDataTypeSFcn">S-Function 블록 ''{2}''의 작업 벡터 ''{1}'' 의 데이터형 ''{0}''이(가) State Writer 블록 ''{4}''의 입력 신호 데이터형 ''{3}''과(와) 일치하지 않습니다. 이 작업 벡터에 대한 ssSetDWorkDataType 호출을 mdlSetWorkWidths에서 mdlInitializeSizes로 옮겨 보십시오. 또는 Signal Specification 블록을 사용하는 방법 등으로 State Writer 블록의 입력 포트가 일치하는 데이터형을 갖는지 확인하십시오.</entry>
    <entry key="InconsistentStateReaderDataTypeSFcnDefault">Simulink에서 S-Function 블록 ''{2}''의 작업 벡터 ''{1}''의 데이터형 ''{0}''을(를) 확인하는 데 발견법(Heuristics)을 사용했습니다. 그런데 결과가 State Reader 블록 ''{4}''의 출력 신호 데이터형 ''{3}''과(와) 일치하지 않습니다. mdlInitializeSizes 또는 mdlSetWorkWidths에 ssSetDWorkDataType을 사용하여 이 작업 벡터의 데이터형을 지정하십시오.</entry>
    <entry key="InconsistentStateWriterDataTypeSFcnDefault">Simulink에서 S-Function 블록 ''{2}''의 작업 벡터 ''{1}''의 데이터형 ''{0}''을(를) 확인하는 데 발견법(Heuristics)을 사용했습니다. 그런데 결과가 State Writer 블록 ''{4}''의 입력 신호 데이터형 ''{3}''과(와) 일치하지 않습니다. mdlInitializeSizes 또는 mdlSetWorkWidths에 ssSetDWorkDataType을 사용하여 이 작업 벡터의 데이터형을 지정하십시오.</entry>
    <entry key="InconsistentStateReaderComplexSignalSFcn1">S-Function 블록 ''{1}''의 작업 벡터 ''{0}''의 신호 유형 ''실수''가 State Reader 블록 ''{2}''의 출력 신호 유형 ''복소수''와 일치하지 않습니다. 이 작업 벡터에 대한 ssSetDWorkComplexSignal 호출을 mdlSetWorkWidths에서 mdlInitializeSizes로 옮겨 보십시오. 또는 Signal Specification 블록을 사용하는 방법 등으로 State Reader 블록의 출력 포트가 일치하는 신호 유형을 갖는지 확인하십시오.</entry>
    <entry key="InconsistentStateReaderComplexSignalSFcn2">S-Function 블록 ''{1}''의 작업 벡터 ''{0}''의 신호 유형 ''복소수''가 State Reader 블록 ''{2}''의 출력 신호 유형 ''실수''와 일치하지 않습니다. 이 작업 벡터에 대한 ssSetDWorkComplexSignal 호출을 mdlSetWorkWidths에서 mdlInitializeSizes로 옮겨 보십시오. 또는 Signal Specification 블록을 사용하는 방법 등으로 State Reader 블록의 출력 포트가 일치하는 신호 유형을 갖는지 확인하십시오.</entry>
    <entry key="InconsistentStateWriterComplexSignalSFcn1">S-Function 블록 ''{1}''의 작업 벡터 ''{0}''의 신호 유형 ''실수''가 State Writer 블록 ''{2}''의 입력 신호 유형 ''복소수''와 일치하지 않습니다. 이 작업 벡터에 대한 ssSetDWorkComplexSignal 호출을 mdlSetWorkWidths에서 mdlInitializeSizes로 옮겨 보십시오. 또는 Signal Specification 블록을 사용하는 방법 등으로 State Writer 블록의 입력 포트가 일치하는 신호 유형을 갖는지 확인하십시오.</entry>
    <entry key="InconsistentStateWriterComplexSignalSFcn2">S-Function 블록 ''{1}''의 작업 벡터 ''{0}''의 신호 유형 ''복소수''가 State Writer 블록 ''{2}''의 입력 신호 유형 ''실수''와 일치하지 않습니다. 이 작업 벡터에 대한 ssSetDWorkComplexSignal 호출을 mdlSetWorkWidths에서 mdlInitializeSizes로 옮겨 보십시오. 또는 Signal Specification 블록을 사용하는 방법 등으로 State Writer 블록의 입력 포트가 일치하는 신호 유형을 갖는지 확인하십시오.</entry>
    <entry key="InconsistentStateReaderComplexSignalSFcnDefault1">Simulink에서 S-Function 블록 ''{1}''의 작업 벡터 ''{0}''의 신호 유형 ''실수''를 확인하는 데 발견법(Heuristics)을 사용했습니다. 그런데 결과가 State Reader 블록 ''{2}''의 출력 신호 유형 ''복소수''와 일치하지 않습니다. mdlInitializeSizes 또는 mdlSetWorkWidths에 ssSetDWorkComplexSignal을 사용하여 이 작업 벡터의 신호 유형을 지정하십시오.</entry>
    <entry key="InconsistentStateReaderComplexSignalSFcnDefault2">Simulink에서 S-Function 블록 ''{1}''의 작업 벡터 ''{0}''의 신호 유형 ''복소수''를 확인하는 데 발견법(Heuristics)을 사용했습니다. 그런데 결과가 State Reader 블록 ''{2}''의 출력 신호 유형 ''실수''와 일치하지 않습니다. mdlInitializeSizes 또는 mdlSetWorkWidths에 ssSetDWorkComplexSignal을 사용하여 이 작업 벡터의 신호 유형을 지정하십시오.</entry>
    <entry key="InconsistentStateWriterComplexSignalSFcnDefault1">Simulink에서 S-Function 블록 ''{1}''의 작업 벡터 ''{0}''의 신호 유형 ''실수''를 확인하는 데 발견법(Heuristics)을 사용했습니다. 그런데 결과가 State Writer 블록 ''{2}''의 입력 신호 유형 ''복소수''와 일치하지 않습니다. mdlInitializeSizes 또는 mdlSetWorkWidths에 ssSetDWorkComplexSignal을 사용하여 이 작업 벡터의 신호 유형을 지정하십시오.</entry>
    <entry key="InconsistentStateWriterComplexSignalSFcnDefault2">Simulink에서 S-Function 블록 ''{1}''의 작업 벡터 ''{0}''의 신호 유형 ''복소수''를 확인하는 데 발견법(Heuristics)을 사용했습니다. 그런데 결과가 State Writer 블록 ''{2}''의 입력 신호 유형 ''실수''와 일치하지 않습니다. mdlInitializeSizes 또는 mdlSetWorkWidths에 ssSetDWorkComplexSignal을 사용하여 이 작업 벡터의 신호 유형을 지정하십시오.</entry>
    <entry key="SubsysFcnOptionNotSupported">The subsystem ''{0}'' contains a State/Parameter Reader/Writer block but does not contain the corresponding state/parameter owner block, and is inside a For Each subsystem ''{1}''. Also, its parameter ''Code generation function packaging'' is set to ''Reusable function''. Simulink does not support this scenario. Consider changing the parameter ''Code generation function packaging'' of subsystem ''{2}'' to ''Inline'' or ''Auto''.</entry>
    <entry key="InvMcosObjectForInitState">Loading initial states for model ''{0}'' from the MATLAB object specified in &lt;sldiag objui="configset" objparam="InitialState"&gt;Initial state&lt;/sldiag&gt; is not supported. To specify the initial state, use a non-empty scalar object of type Simulink.op.ModelOperatingPoint or Simulink.SimulationData.Dataset.</entry>
    <entry key="SimModeAuto">자동</entry>
    <entry key="SimModeNormal">표준</entry>
    <entry key="SimModeAccelerated">액셀러레이터</entry>
    <entry key="SimModeRapidAccel">고속 액셀러레이터</entry>
    <entry key="SimModeSIL">SIL(Software-in-the-Loop)</entry>
    <entry key="SimModePIL">PIL(Processor-in-the-Loop)</entry>
    <entry key="SimModeExternal">외부</entry>
    <entry key="NormalModeOptimizationAuto">자동</entry>
    <entry key="NormalModeOptimizationInitialization">초기화</entry>
    <entry key="NormalModeOptimizationExecution">실행</entry>
    <entry key="AutoOnOffAuto">자동</entry>
    <entry key="AutoOnOffOn">켜기</entry>
    <entry key="AutoOnOffOff">끄기</entry>
    <entry key="ClearAccelCacheNone">안 함</entry>
    <entry key="ClearAccelCacheMemory">메모리</entry>
    <entry key="ClearAccelCacheAll">모두</entry>
    <entry key="SimRollbackUninitialized">초기화되지 않음</entry>
    <entry key="SimRollbackCompliant">준수</entry>
    <entry key="SimRollbackNonCompliantNeutral">비준수-중립적</entry>
    <entry key="SimRollbackNonCompliantFatal">비준수-치명적</entry>
    <entry key="RapidAccelSimStatusInactive">비활성</entry>
    <entry key="RapidAccelSimStatusDormant">유휴</entry>
    <entry key="RapidAccelSimStatusStarting">시작 중</entry>
    <entry key="RapidAccelSimStatusEditing">편집 중</entry>
    <entry key="RapidAccelSimStatusInitializing">초기화 중</entry>
    <entry key="RapidAccelSimStatusBuilding">빌드 중</entry>
    <entry key="RapidAccelSimStatusUpdating">업데이트 중</entry>
    <entry key="RapidAccelSimStatusConnecting">연결 중</entry>
    <entry key="RapidAccelSimStatusRunning">실행 중</entry>
    <entry key="RapidAccelSimStatusTerminating">종료 중</entry>
    <entry key="RapidAccelMenuSimStatusUnused">미사용</entry>
    <entry key="RapidAccelMenuSimStatusReady">준비</entry>
    <entry key="RapidAccelMenuSimStatusActive">활성</entry>
    <entry key="RapidAccelMenuSimStatusPassed">통과</entry>
    <entry key="RapidAccelMenuSimStatusFailed">실패</entry>
    <entry key="IncompleteVarUsageInfo">Variable usage information may be incomplete. Model must be initialized in FastRestart to get complete list of nontunable variables</entry>
    <entry key="NonTunableVarChangedInFastRestart">변수 ''{0}''이(가) 변경되었지만 ''{1}''의 조정 불가형 파라미터에 사용됩니다. 모델이 [빠른 재시작]으로 초기화되었기 때문에 새 값이 사용되지 않습니다. 새 값을 사용하려면 [빠른 재시작]을 끄십시오. </entry>
    <entry key="NonTunableVarChanged">Variable ''{0}'' was changed but it is used in a nontunable parameter in ''{1}''. The new value will not be used in the current simulation. Restart the simulation if you would like to use the new value. </entry>
    <entry key="NonTunableVarChangedMaxWarnings">조정 불가형 파라미터에 사용된 추가 변수가 변경되었지만 경고 메시지 수를 제한하는 것으로 보고되지 않음</entry>
    <entry key="WarnModelClose">컴파일 또는 시뮬레이션 중에 모델 {0}이(가) 닫혔습니다.</entry>
    <entry key="SlFcnFpcUnsupportedVoidPtr">Simulink Function 블록 ''{1}''의 인수 ''{0}''은(는) ''void*'' 유형으로 구성되었습니다. AUTOSAR 코드 생성 시 Function Caller 블록에만 이 유형을 사용할 수 있습니다. AUTOSAR 타깃의 경우 특정 NvM(비휘발성 메모리) 작업에 매핑된 Function Caller 블록은 ''void*'' 인수 유형으로 자동으로 구성됩니다. 그 경우 해당 Simulink Function 블록만 시뮬레이션에 정의할 수 있습니다.</entry>
    <entry key="SlFcnFpcUnsupportedCaller"> 코드 생성 시 Simulink Function 블록 ''{0}''의 호출자는 지원되지 않습니다. Simulink Function 블록을 호출하려면 한 개 이상의 Function Caller 블록을 사용하십시오.</entry>
    <entry key="RTWDataTypeHeaderFileIdConflict">Unable to generate code using the type ''{0}'' because the header file specified for the type ''{1}'' conflicts with a file generated by the model.</entry>
    <entry key="ExpFcnRootOutportDrivenByStatePort">함수 내보내기 모델에서 블록 ''{1}''의 상태 포트로 루트 Outport 블록 ''{0}''을(를) 구동할 수 없습니다.</entry>
    <entry key="VirtualBusDrivingVirtualRootOutport">루트 Outport 블록 ''{0}''은(는) 가상 블록이어야 하므로 가상 버스 신호를 받을 수 없습니다.</entry>
    <entry key="DiscontigVirtualRootOutport">루트 Outport 블록 ''{0}''은(는) 가상 블록이어야 합니다. 소스 출력 포트에서 Outport 블록까지 요소가 재정렬되거나 선택되지 않고 직선으로 포트가 연결되는지 확인하십시오.</entry>
    <entry key="NoBranchingToSameVirtualRootOutport">블록 ''{0}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에서 가상 루트 Outport 블록 ''{2}''(으)로의 연결이 유효하지 않습니다. 출력 신호는 분기된 이후에 동일한 가상 루트 Outport 블록을 구동하기 위해 다시 결합될 수 없습니다.</entry>
    <entry key="NoBranchingToTwoVirtualRootOutports">블록 ''{0}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에서 루트 Outport 블록 ''{2}'', ''{3}''(으)로의 연결이 유효하지 않습니다. 출력 신호를 여러 개의 가상 루트 Outport 블록으로 분기할 수 없습니다.</entry>
    <entry key="BufferRequiredOnInitResetTermOutport">Outport 블록 ''{0}''은(는) 가상 블록이어야 합니다. 소스 신호가 Initialize Function, Terminate Function, Reinitialize Function 또는 Reset Function 블록에서 비롯되었기 때문입니다. 그런데 이 연결 경로상의 일부 지점에서 신호 버퍼가 필요한 것으로 확인되었습니다. 소스 출력 포트에서 Outport 블록까지 요소가 재정렬되거나 선택되지 않고 직선으로 포트가 연결되는지 확인하십시오.</entry>
    <entry key="BufferRequiredOnVirtualOutport">Outport 블록 ''{0}''은(는) 가상 블록이어야 합니다. 그런데 소스 출력 포트로부터의 경로상에 있는 일부 지점에서 신호 버퍼가 필요한 것으로 확인되었습니다. 소스 출력 포트에서 Outport 블록까지 요소가 재정렬되거나 선택되지 않고 직선으로 포트가 연결되는지 확인하십시오.</entry>
    <entry key="NonEmptyICOnInitResetTermParentOutport">Outport 블록 ''{0}''은(는) 초기 출력값을 가질 수 없습니다. 소스 신호가 Initialize Function, Terminate Function, Reinitialize Function 또는 Reset Function 블록에서 비롯되었기 때문입니다. 이 문제를 해결하려면 Outport 블록의 파라미터 ''{1}''을(를) ''on''으로 설정하십시오. 또는 Outport 블록의 파라미터 ''초기 출력''을 빈 행렬([])로 설정하십시오.</entry>
    <entry key="VirtualOutportCodeGenErrorDueToDataConnector">Outport 블록 ''{0}''에 파라미터 ''{1}''이(가) 설정되었습니다. 그러나 다음 이유로 인해 생성 코드에서 아웃포트가 가상 포트가 된다는 보장은 없습니다. 이 문제를 해결하는 방법 중 하나는 파라미터 ''{1}''을(를) ''off''로 설정하는 것입니다. </entry>
    <entry key="InitTermResetCodeGenErrorDueToDataConnector">Outport 블록 ''{0}''은(는) Initialize Function, Reinitialize Function, Reset Function 또는 Terminate Function 블록에 의해 구동되기 때문에 생성 코드에서 가상 블록이어야 합니다. 그러나 다음 이유로 인해 이 조건을 적용할 수 없습니다.</entry>
    <entry key="OutportNeedsToBeVirtualForUnionRate">The Outport block ''{0}'' needs to be virtual in generated code because it is driven by a Simulink function call subsystem under union of rates. However, Simulink is unable to honor this condition due to the following reasons.</entry>
    <entry key="ReusableSSDrivingRootOutportWithEnsureVirtualSpec">Outport 블록 ''{0}''은(는) 재사용 가능 함수를 생성하도록 구성된 서브시스템 ''{1}''에 의해 구동됩니다. 이 문제를 해결하려면 서브시스템의 파라미터 ''함수 패키징''을 ''인라인'' 또는 ''재사용 불가 함수''로 설정하십시오.</entry>
    <entry key="NoDataConnectorRootOutportWithEnsureVirtualSpec">루트 Outport 블록''{0}''이(가) 생성 코드에서 가상 블록이 된다고 보장할 수 없습니다. 이 문제를 해결하려면 Outport 블록의 파라미터 ''{1}''을(를) ''off''로 설정하십시오.</entry>
    <entry key="DifferentWidthsRootOutportWithEnsureVirtualSpec">루트 Outport 블록 ''{0}''과(와) 소스 블록 ''{1}''의 너비가 서로 다릅니다. 이 문제를 해결하려면 Outport 블록 ''{0}''과(와) 소스가 모두 동일한 너비가 되도록 하십시오.
    </entry>
    <entry key="VarDimsRootOutportEnsureVirtualSpec">루트 Outport 블록 ''{0}''의 입력이 가변 차원이거나 가변 차원으로 이루어진 요소를 포함하고 있습니다.
    </entry>
    <entry key="SourceWithConstSampleTimeRootOutportWithEnsureVirtualSpec">Since the source block ''{1}'' of the root Outport block ''{0}'' has a constant sample-time, Simulink cannot ensure the root Outport block is virtual. To correct this problem, ensure that the source block ''{1}'' uses a sample-time that is not constant.
    </entry>
    <entry key="VirtualOutportDueToSpecification">Outport 블록 ''{0}''은(는) 가상 블록이어야 합니다. 파라미터 ''{1}''이(가) ''켜기''로 설정되었기 때문입니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{0}'',''EnsureOutportIsVirtual'',''off'')&lt;/cmd&gt; &lt;txt&gt;''copy'' 의미 체계로 전환하고 가능한 경우 다른 답을 얻으려면 블록 ''{0}''의 파라미터 ''{1}''을(를) ''끄기''로 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
</entry>
    <entry key="VirtualOutportDueToIRT">The Outport block ''{0}'' must be virtual because its source signal originates from an Initialize, Terminate, Reinitialize or Reset Function block.</entry>
    <entry key="VirtualOutportDueToExpFcn">함수 내보내기 모델의 루트 Outport 블록 ''{0}''은(는) 다음 중 한 가지 이유로 인해 가상 블록이어야 합니다.\n (1) 블록이 Merge 블록에 의해 구동됩니다.\n (2) 블록이 Mux 블록에 의해 구동됩니다.\n (3) 블록이 파라미터 ''{1}''이(가) ''켜기''로 설정된 Outport 블록에 의해 구동됩니다.\n (4) 블록이 또 다른 함수 내보내기 모델을 참조하는 Model 블록의 출력 포트에 의해 구동되며, 참조된 모델의 해당 루트 아웃포트는 위의 이유 중 하나로 인해 가상 포트여야 할 수 있습니다.</entry>
    <entry key="NoDataConnectorVirtualRootOutport">루트 Outport 블록 ''{0}''은(는) 가상 블록이어야 합니다. 그런데 이 조건을 생성 코드에서 보장할 수 없습니다. 이 오류 메시지와 관련하여 도움이 필요하면 MathWorks에 문의하십시오.</entry>
    <entry key="InitResetTermNeedSimplifiedInitMode">The Initialize, Reinitialize, Reset, or Terminate Function block ''{0}'' requires simplified initialization mode for model ''{1}''. For more information, see &lt;a href="matlab:helpview([docroot '/simulink/ug/simplified-initialization-mode.html'])"&gt;Simplified initialization mode&lt;/a&gt;.
    &lt;actions exclusiveFixIts="yes"&gt;
    &lt;action type="fixit"&gt;
    &lt;cmd&gt;configset.internal.fixIt(''{1}'',''UnderspecifiedInitializationDetection'',''Simplified'')&lt;/cmd&gt;
    &lt;txt&gt;Set the parameter &lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;"Underspecified initialization detection"&lt;/sldiag&gt; in the Diagnostics page of the Configuration Parameters dialog to ''Simplified''.&lt;/txt&gt;
    &lt;/action&gt;
    &lt;/actions&gt;
    </entry>
    <entry key="SimulinkStateNeedSimplifiedInitMode">The Simulink state ''{0}'' requires simplified initialization mode for model ''{1}''. For more information, see &lt;a href="matlab:helpview([docroot '/simulink/ug/simplified-initialization-mode.html'])"&gt;Simplified initialization mode&lt;/a&gt;.
    &lt;actions exclusiveFixIts="yes"&gt;
      &lt;action type="fixit"&gt;
        &lt;cmd&gt;configset.internal.fixIt(''{1}'',''UnderspecifiedInitializationDetection'',''Simplified'')&lt;/cmd&gt;
        &lt;txt&gt;Set the parameter &lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;"Underspecified initialization detection"&lt;/sldiag&gt; in the Diagnostics page of the Configuration Parameters dialog to ''Simplified''.&lt;/txt&gt;
      &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="OutportStateAccessNeedSimplifiedInitMode">Outport 블록 ''{1}''에 대한 읽기/쓰기를 지원하려면 모델 ''{0}''에 단순 방식 초기화 모드를 사용해야 합니다. 자세한 내용은 &lt;a href="matlab:helpview([docroot '/simulink/ug/simplified-initialization-mode.html'])"&gt;단순 방식 초기화 모드&lt;/a&gt;를 참조하십시오. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''UnderspecifiedInitializationDetection'',''Simplified'')&lt;/cmd&gt; &lt;txt&gt;[구성 파라미터] 대화 상자의 [진단] 페이지에서 파라미터 &lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;"과소 지정된 초기화 감지"&lt;/sldiag&gt;를 ''단순 방식''으로 설정.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="InvalidVariableSizeSignalForRootOutport"> Outport block ''{0}'' has a signal object with non-auto storage class. But it is driven by a variable size signal. Currently a variable size signal is not allowed in such a case. </entry>
    <entry key="UnableToUpdateModel"> 모델 ''{0}''을(를) 업데이트할 수 없습니다. </entry>
    <entry key="AlgConstBlockMultipleConfigs">동일한 대수 루프 내에 있는 {0,number,integer}개의 Algebraic Constraint 블록 중 일부의 솔버 및 허용오차 값이 일치하지 않습니다.</entry>
    <entry key="FMUModeDisallowedSS">''{0}'' is an FMU block with {1} mode. An FMU block with {1} mode is not allowed inside the {2} subsystem ''{3}''.</entry>
    <entry key="FMUModeDisallowedSSState">''{0}'' is an FMU block with {1} mode. An FMU block with {1} mode is not allowed inside the {2} subsystem ''{3}'' with states ''{4}''.</entry>
    <entry key="FMUModeIsNotRecognized">FMU 모드 ''{0}''은(는) ''{1}'' 블록에서 인식할 수 없습니다.</entry>
    <entry key="SameNamedModelSourceAndDataFile">모델에서 소스 파일 ''{0}''과(와) 데이터 파일 ''{0}''을(를) 동일한 이름으로 생성하려 하고 있습니다. 소스 파일 이름/데이터 파일 이름 설정을 변경하거나 파일 패키징 형식을 "콤팩트"로 변경하십시오.</entry>
    <entry key="BlockMultiThreadCoSimThreadSafeWarning">''{0}'' 블록과 연결된 S-Function이 런타임 스레드 안전으로 선언되지 않았음에도 런타임 스레드 안전으로 강제로 실행됩니다. 이 경고가 표시되지 않도록 하려면 ''ssSetRuntimeThreadSafetyCompliance(S, RUNTIME_THREAD_SAFETY_COMPLIANCE_TRUE)''를 사용하여 S-Function을 런타임 스레드 안전으로 선언하십시오.</entry>
    <entry key="BlockMultiThreadCoSimThreadSafeError">''{0}'' 블록과 연결된 S-Function은 런타임 스레드 안전으로 선언되지 않았기 때문에 런타임 스레드 안전으로 강제로 실행되지 않습니다. S-Function을 런타임 스레드 안전으로 설정하려면 ''ssSetRuntimeThreadSafetyCompliance(S, RUNTIME_THREAD_SAFETY_COMPLIANCE_TRUE)''를 사용하십시오.</entry>
    <entry key="MTCSGlobalErrorStatus">하나 이상의 멀티스레드 블록에서 "ssSetErrorStatus"를 사용합니다. 이로 인해 오류가 부정확하게 보고될 수 있습니다. 오류 보고의 정확성을 높이려면 "ssSetLocalErrorStatus"를 대신 사용하십시오.</entry>
    <entry key="MTCSBlocker_Accel">멀티스레딩은 액셀러레이터 모드에서 Model 블록에 대해 지원됩니다. Model 블록을 액셀러레이터 모드로 설정하십시오.</entry>
    <entry key="MTCSBlocker_BlkSetting">블록 속성 ''MultithreadedSim''이 off입니다. 블록 설정을 활성화하려면 set_param(blockName, ''MultithreadedSim'', ''auto'')를 사용하십시오.</entry>
    <entry key="MTCSBlocker_CompChk">S-Function 분석기가 켜져 있으면 멀티스레딩이 활성화되지 않습니다. 표준 모드에서 멀티스레딩을 사용해 보십시오.</entry>
    <entry key="MTCSBlocker_ConstBlock">멀티스레딩은 상수 샘플 시간을 가진 블록에 대해 활성화되지 않습니다.</entry>
    <entry key="MTCSBlocker_ContStChk">S-Function에 연속 상태가 있고 솔버가 고정 스텝이라는 조건이 합쳐져 연속 상태 일관성 검사를 트리거할 때는 멀티스레딩이 활성화되지 않습니다. 연속 상태 일관성 검사를 비활성화하려면 ''ssSetSkipContStatesConsistencyCheck'' 함수를 사용하십시오.</entry>
    <entry key="MTCSBlocker_ContTS">S-Function이 연속 샘플 시간을 갖는 경우에는 멀티스레딩이 활성화되지 않습니다. 다른 &lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''],''specifying_sample_time'')"&gt;"샘플 시간 설정"&lt;/a&gt;을 사용해 보십시오.</entry>
    <entry key="MTCSBlocker_Coverage">커버리지(내부용).</entry>
    <entry key="MTCSBlocker_Debugger">Simulink 디버거가 켜져 있으면 멀티스레딩이 활성화되지 않습니다. Simulink 디버거를 끄십시오.</entry>
    <entry key="MTCSBlocker_MRToFile">모델에 To File 블록이 포함된 경우 멀티스레딩이 활성화되지 않습니다. 다른 방법을 사용하여 &lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''],''data_logging_summary'')"&gt;"시뮬레이션 데이터 내보내기"&lt;/a&gt;를 수행해 보십시오.</entry>
    <entry key="MTCSBlocker_MRFromFile">모델에 From File 블록이 포함된 경우 멀티스레딩이 활성화되지 않습니다. 최상위 모델에서 인포트를 통해 참조된 모델에 데이터를 전달해 보십시오.</entry>
    <entry key="MTCSBlocker_MRDSM">모델이 전역 데이터 저장소를 사용하는 경우 멀티스레딩이 활성화되지 않습니다.</entry>
    <entry key="MTCSBlocker_MRConstant">모델에 상수 샘플 시간이 있는 경우 멀티스레딩이 활성화되지 않습니다.</entry>
    <entry key="MTCSBlocker_MRRuntimeDiag">참조된 모델에 런타임 진단을 실행하는 블록이 포함된 경우 멀티스레딩이 활성화되지 않습니다.</entry>
    <entry key="MTCSBlocker_MRCoverage">커버리지(내부용).</entry>
    <entry key="MTCSBlocker_MRSLFunc">모델에 Simulink Function 블록이 포함된 경우 멀티스레딩이 활성화되지 않습니다.</entry>
    <entry key="MTCSBlocker_DebugLog">FMU 블록 디버그 기록이 활성화된 경우 멀티스레딩이 활성화되지 않습니다. FMU 블록 디버그 기록을 비활성화하려면 set_param(blockName, ''FMUDebugLogging'', ''off'')를 사용하십시오.</entry>
    <entry key="MTCSBlocker_CrossplatformSim">FMU 블록이 크로스 플랫폼 시뮬레이션을 실행 중인 경우 멀티스레딩이 활성화되지 않습니다.</entry>
    <entry key="MTCSBlocker_DynProf">계산 비용에 비해 멀티스레딩 {0} 메서드의 오버헤드 비용이 지나치게 커서 경제적이지 않습니다. &lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''],''comp_based_model_guidelines'')"&gt;"guidelines for component-based modeling"&lt;/a&gt;을 참조하십시오.</entry>
    <entry key="MTCSBlocker_DynProfNotFinished">시뮬레이션에 {0} 메서드의 동적 성능을 측정하기 위한 스텝 수가 충분하지 않았습니다. 시뮬레이션을 더 오래 실행해 보십시오.</entry>
    <entry key="MTCSBlocker_EventPort">Model 블록에 이벤트 포트가 있는 경우 멀티스레딩이 활성화되지 않습니다.</entry>
    <entry key="MTCSBlocker_ExcFree">멀티스레딩에서는 S-Function에서 예외 없음(exception-free)을 나타내는 옵션을 선언해야 합니다. 자세한 내용은 &lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''],''guidelines_for_threadsafe_sfunctions'')"&gt;"Guidelines for Writing Thread-Safe S-Functions"&lt;/a&gt;를 참조하십시오.</entry>
    <entry key="MTCSBlocker_FMUME">멀티스레딩은 연동 시뮬레이션 모드에 대해서만 활성화됩니다. Co-Simulation FMU 대신 Model Exchange FMU를 사용해 보십시오.</entry>
    <entry key="MTCSBlocker_ForEachSS">Model 블록이 For Each Subsystem에 있는 경우 멀티스레딩이 활성화되지 않습니다. Model 블록을 For Each Subsystem 밖으로 옮겨 보십시오.</entry>
    <entry key="MTCSBlocker_Graph">이 블록은 멀티스레딩이 불가능한 또 다른 블록에 의존합니다. 예를 들어 Unit Delay 블록을 사용해 종속성을 해제해 보십시오.</entry>
    <entry key="MTCSBlocker_TOPO_Source_Node_RTTS_YES_BUT_DF">시작 블록은 직접 피드스루 입력을 가질 수 없습니다.</entry>
    <entry key="MTCSBlocker_MdlSetting">멀티스레딩에 대한 모델 설정이 꺼져 있습니다. 모델에 대한 멀티스레딩을 활성화하려면 set_param(modelName, ''MultithreadedSim'', ''auto'')를 사용하십시오.</entry>
    <entry key="MTCSBlocker_Multirate">멀티스레딩은 싱글레이트 블록에서 지원됩니다. 멀티스레딩을 활성화하려면 멀티레이트 블록을 싱글레이트 블록으로 변환하십시오.</entry>
    <entry key="MTCSBlocker_NoBlock">멀티스레딩에 적합한 블록이 없습니다. 기존 블록에 대한 멀티스레딩 조건을 충족하거나 새 블록을 추가해 보십시오.</entry>
    <entry key="MTCSBlocker_NoOutput">멀티스레딩은 출력 메서드와 업데이트 메서드를 동시에 실행합니다. 이 블록에는 출력 메서드가 없습니다.</entry>
    <entry key="MTCSBlocker_NotDefault">디폴트 블록 케이스가 아님(내부용).</entry>
    <entry key="MTCSBlocker_NoUpdate">멀티스레딩은 출력 메서드와 업데이트 메서드를 동시에 실행합니다. 이 블록에는 업데이트 메서드가 없습니다.</entry>
    <entry key="MTCSBlocker_OOP">FMU가 별도 프로세스(out-of-process)를 실행하는 경우 멀티스레딩이 지원되지 않습니다. 이 설정을 비활성화하려면 set_param(blockName, ''DebugExecutionForFMUViaOutOfProcess'', ''off'')를 사용하십시오.</entry>
    <entry key="MTCSBlocker_RTAPI">S-Function 런타임 모델 API 지원 끄기(내부용).</entry>
    <entry key="MTCSBlocker_RTThrSafe">멀티스레딩에서는 S-Function이 런타임 스레드 안전 준수 옵션을 true로 설정해야 합니다. 자세한 내용은 &lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''],''guidelines_for_threadsafe_sfunctions'')"&gt;"Guidelines for Writing Thread-Safe S-Functions"&lt;/a&gt;를 참조하십시오.</entry>
    <entry key="MTCSBlocker_RTThrSafeFCGen">Function-Call Generator 블록에 대해 멀티스레드가 활성화되어 있지 않습니다.</entry>
    <entry key="MTCSBlocker_SimMode">멀티스레딩은 표준 시뮬레이션 모드에 대해서만 지원됩니다.</entry>
    <entry key="MTCSBlocker_VarTS">멀티스레딩에서는 가변 샘플 시간이 지원되지 않습니다. &lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''],''specifying_sample_time'')"&gt;"샘플 시간 설정"&lt;/a&gt;을 참조하십시오.</entry>
    <entry key="MTCSBlockerBlockOutputIn">참여 중인 병렬 출력 메서드 실행</entry>
    <entry key="MTCSBlockerBlockUpdateIn">참여 중인 병렬 업데이트 메서드 실행</entry>
    <entry key="MTCSBlockerBlockOut">참여 중인 병렬 실행이 아님</entry>
    <entry key="MTCSBlockerBlockName">MTCS 블록: ''{0}''</entry>
    <entry key="MTCSBlockerBlockType">블록 유형: {0}</entry>
    <entry key="MTCSBlockerBlockUnknown">알 수 없는 블로커</entry>
    <entry key="MTCSBlockerBlockCommon">공통 블로커</entry>
    <entry key="MTCSBlockerBlockOutput">출력 메서드별 블로커</entry>
    <entry key="MTCSBlockerBlockUpdate">업데이트 메서드별 블로커</entry>
    <entry key="MTCSBlockerModelName">모델: ''{0}''</entry>
    <entry key="MTCSBlockerModelIn">참여 중인 병렬 실행</entry>
    <entry key="MTCSBlockerModelOut">참여 중인 병렬 실행이 아님</entry>
    <entry key="MTCSBlockerModelUnknown">알 수 없는 블로커</entry>
    <entry key="MTCSBlockerModelAll">블로커</entry>
    <entry key="MTCSBlockerHeader">멀티스레드 시뮬레이션 블로커 시작</entry>
    <entry key="MTCSBlockerFooter">멀티스레드 시뮬레이션 블로커 종료</entry>
    <entry key="TruncateWrittenStringParam"> 모든 문자와 끝에 있는 null 종결자를 저장하려면 블록 ''{1}''의 파라미터 ''{0}''의 버퍼 크기가 ''{2, number, integer}''바이트여야 합니다. 필요한 이 버퍼 크기가 구성 파라미터 "동적 크기 문자열의 버퍼 크기"에 의해 지정된 동적 문자열의 버퍼 크기를 초과합니다. 생성 코드에서는 블록이 ''{3, number, integer}''바이트 버퍼에 맞도록 파라미터 값을 자릅니다. 자르는 동작을 방지하려면 문자열 버퍼 크기를 늘려 보십시오.</entry>
    <entry key="TruncateWrittenStringOutput"> 모든 문자와 끝에 있는 null 종결자를 저장하려면 블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0, number, integer}" objname="{1}"&gt;{0, number, integer}번 출력 버퍼&lt;/sldiag&gt;의 초기값 버퍼 크기가 ''{2, number, integer}''바이트여야 합니다. 필요한 이 버퍼 크기가 구성 파라미터 "동적 크기 문자열의 버퍼 크기"에 의해 지정된 동적 문자열의 버퍼 크기를 초과합니다. 생성 코드에서는 블록이 ''{3, number, integer}''바이트 버퍼에 맞도록 초기값을 자릅니다. 자르는 동작을 방지하려면 문자열 버퍼 크기를 늘려 보십시오.</entry>
    <entry key="CrossModelModification">It is incorrect to modify the model ''{0}'' from the InitFcn callback of a different model.</entry>
    <entry key="ErrCreateBlockDiagramThroughMCOS">MCOS를 통해 직접 블록 다이어그램을 만드는 것은 올바르지 않습니다.</entry>
    <entry key="SolverProfileLevelInvalidName">''{0}''은(는) 솔버 프로파일러 기록 수준 설정에 유효하지 않은 필드 이름입니다.</entry>
    <entry key="SolverProfileLevelMustBeStruct">파라미터 SolverProfileInfoLevel은 MATLAB 구조체여야 합니다.</entry>
    <entry key="ErrCallDeleteOnObject">이 객체는 삭제 작업을 지원하지 않습니다.</entry>
    <entry key="ErrGetUDIWithFeatureON">UDDToMCOS 기능이 ON인 경우 get_udi를 호출해서는 안 됩니다.</entry>
    <entry key="ArchitectureExportToPreviousNotSupported">Exporting Architecture models to Simulink version R2019a or earlier is not supported.</entry>
    <entry key="NotAcyclicGraph">이 기본 그래프는 비순환 그래프가 아닙니다.</entry>
    <entry key="InvalidSubsysDiffPross">Invalid subsystem diff process. Exactly two subsystems should be marked for checksum diff.</entry>
    <entry key="BusElementEmptySLValueType">Bus 객체 ''{1}''의 버스 요소 ''{0}''이(가) 빈 ValueType을 지정합니다. </entry>
    <entry key="BusElementCannotFindSLValueType">Bus 객체 ''{2}''의 버스 요소 ''{1}''에 대해 지정된 'ValueType' ''{0}''을(를) 찾을 수 없습니다. </entry>
    <entry key="BlockCannotFindSLValueType">블록 ''{1}''에 대해 지정된 'Simulink.ValueType' ''{0}''을(를) 찾을 수 없습니다. </entry>
    <entry key="SimulinkTypeCannotBeEmpty">블록 ''{1}''에 대해 지정된 Simulink.ValueType ''{0}''은(는) 속성의 값을 제공해야 합니다. </entry>
    <entry key="SlDataObjectEmptySLValueType">Simulink 데이터 객체 ''{0}''이(가) 빈 값 유형을 지정합니다. </entry>
    <entry key="SlDataObjectCannotFindSLValueType">Simulink 데이터 객체 ''{1}''에 대해 지정된 값 유형 ''{0}''을(를) 찾을 수 없습니다. </entry>
    <entry key="SlParameterValueMismatchValueTypeDataType">값 유형 ''{0}''이(가) bus 객체를 지정하지만 Simulink.Parameter 객체 ''{1}''에 대한 ''Value''의 숫자형 값은 구조체가 아닙니다. 데이터형이 일치해야 합니다.</entry>
    <entry key="SlParameterValueMismatchValueTypeDataTypeEnum">Simulink.Parameter 객체 ''{0}''의 ''Value'' 속성은 열거형 데이터형 ''{1}''을(를) 갖는 값을 지정하지만, ''DataType'' 속성은 데이터형 ''{3}''을(를) 갖는 Simulink.ValueType 객체 ''{2}''을(를) 지정합니다. 데이터형이 일치해야 합니다.</entry>
    <entry key="SlParameterValueMismatchValueTypeDimensions">Simulink.Parameter 객체 ''{1}''에 대한 값 유형 ''{0}''과(와) ''Value''의 숫자형 값 간의 차원이 일치해야 합니다.</entry>
    <entry key="SlParameterValueMismatchValueTypeComplexity">Simulink.Parameter 객체 ''{1}''에 대한 값 유형 ''{0}''과(와) ''Value''의 숫자형 값 간의 실수/복소수 여부가 일치해야 합니다.</entry>
    <entry key="ModelNotLoaded">No model loaded.</entry>
    <entry key="SymbolicDimsWithVariableDimsUnsupportedCause">블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;</entry>
    <entry key="SymbolicDimsWithVariableDimsUnsupported">고정 크기 신호에는 기호 차원만 지원됩니다. 기호 차원 또는 가변 크기 신호를 사용하되, 둘 모두는 사용하지 않도록 다음 블록 포트를 업데이트하십시오:</entry>
    <entry key="InvalidBlockIOBufferSizeCause">블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;</entry>
    <entry key="InvalidBlockIOBufferSize">Simulink는 최대 {0,number,integer}바이트의 개별적인 블록 I/O 신호 크기를 지원합니다. 신호 크기는 데이터형 크기, 요소 개수 및 신호 유형(실수/복소수)을 기반으로 계산됩니다. 이 제한을 초과하는 블록 포트는 다음과 같습니다:</entry>
    <entry key="HeaderGuardPrefixInvalidStr">유효하지 않은 사용자 지정 헤더 가드 접두사입니다. 공백이 없는 문자열 리터럴만 허용됩니다.</entry>
    <entry key="HalideFolderInvalidAccess">폴더에 대한 액세스 권한이 없습니다.</entry>
    <entry key="PromptForChange">변경</entry>
    <entry key="PromptForIgnore">무시</entry>
    <entry key="PromptForAlwaysIgnore">항상 무시</entry>
    <entry key="PointerBusNameNotFound">포인터 버스 이름 ''{0}''은(는) Bus 객체를 지정하지만, 이러한 Bus 객체를 작업 공간이나 데이터 사전에서 찾을 수 없습니다.</entry>
    <entry key="EditTimeDashBoardOpenTip">모델링 지침을 봅니다</entry>
    <entry key="EditTimeDashBoardNoIssuesTip">모델에서 문제가 발견되지 않았습니다</entry>
    <entry key="EditTimeDashBoardIssuesFoundTip">모델링 문제가 감지되었습니다. 클릭하여 표시합니다.</entry>
    <entry key="OpaqueEnumFeatureConflict">RangeAnalysisForEnums, ShrinkCfgSwitchPruning 또는 PreserveEnumsWithDuplicateValues 특징 중 하나라도 디폴트 값에서 변경하려면 조정 가능한 열거형 특징을 비활성화해야 합니다. MathWorks 기술 지원팀에 문의하십시오</entry>
    <entry key="OpaqueEnumFeatureConflict2">향후 릴리스에서는 RangeAnalysisForEnums, ShrinkCfgSwitchPruning 또는 PreserveEnumsWithDuplicateValues 특징이 제거될 예정입니다. 조정 가능한 열거형을 대신 사용하십시오.</entry>
    <entry key="BlockNotAvailable">블록 ''{0}''이(가) 시뮬레이션에서 제거되었으므로 이 블록의 출력에 표시된 선형화 점은 더 이상 사용할 수 없습니다.</entry>
    <entry key="LinearizationWithSFuncArrayOfBus">Linearization points cannot be placed on signals that are arrays of buses.</entry>
    <entry key="SLFcnNameClashWithMdlCppConstructor"> Simulink function name ''{0}'' clashes with the C++ class constructor name of the model ''{1}''. Consider changing the function name or changing the 'Code interface packaging' parameter to a setting other than 'C++ class'</entry>
    <entry key="FallBackToNonVm"/>
    <entry key="BlkInAlgLoopWarnInfo"> ''{0}''{1}{2}\n</entry>
    <entry key="Comp_CompileDone"/>
    <entry key="Comp_Model_Terminated"> </entry>
    <entry key="DomainDynamicPortTypeInternalError">Internal error: Error encountered while setting up port type ''{0}'' in domain ''{1}''.  However, unable to remove port type due to subsequent errors.  See attached cause for original error encountered while setting up the port type.</entry>
    <entry key="TipAlert_AutoConnectionPrefsKey">SimulinkTipAlertAutoConnectTip</entry>
    <entry key="MxArrayIsNotSparse">
      The matrix is not sparse.
    </entry>
    <entry key="PrArrayIsNULL">
      Its Pr array is NULL.
    </entry>
    <entry key="PiArrayIsNULL">
      Its Pi array is NULL.
    </entry>
    <entry key="IrArrayIsNULL">
      Its Ir array is NULL.
    </entry>
    <entry key="JcArrayIsNULL">
      Its Jc array is NULL.
    </entry>
    <entry key="PrArrayIsNotZero">
      Its Pr array is Pr = '{'{0}'}' now. However, it should be Pr = '{'0'}'.
    </entry>
    <entry key="PiArrayIsNotZero">
      Its Pi array is Pi = '{'{0}'}' now. However, it should be Pi = '{'0'}'.
    </entry>
    <entry key="IrArrayIsNotZero">
      Its Ir array is Ir = '{'{0}'}' now. However, it should be Ir = '{'0'}'.
    </entry>
    <entry key="JcArrayNotOneZero">
      Its Jc array is Jc = '{'{0}'}' now. However, it should be Jc = '{'0'}'.
    </entry>
    <entry key="JcArrayTailWrong">
      The last element of Jc array does not equal to nzmax. nCols == {0}, Jc[nCols] == {1}, nzmax == {2}.
    </entry>
    <entry key="AllZeroButNzmax">
      Its Ir and Jc arrays'' elements are all zero, but nzmax is {0}.
    </entry>
    <entry key="PassFormatCheck">
      Pass the check.
    </entry>
    <entry key="IrArrayWrongOrder">
      The order of element in Ir array's is wrong at row {0} (the first row's index is 0).
    </entry>
    <entry key="JcArrayWrongOrder">
      Jc[{0}] is larger than Jc[{1}].
    </entry>
    <entry key="JcArrayNotAllZero">
      Its Jc array has Jc[{0}] == {1}. However, Jc should be a all zero array.
    </entry>
    <entry key="JcArrayHeadWrong">
      Its nzmax &gt; 0, the Jc array has Jc[0] = {0} now. However, there should always be Jc[0] = 0.
    </entry>
    <entry key="NzmaxNotMatch">
      Its Jc[nCols] == 0, nzmax == {0}. However, there should be Jc[nCols] == nzmax or Jc[nCols] == 0, nzmax == 1.
    </entry>
    <entry key="RapidAccelCmdlSim">cmdlsim</entry>
    <entry key="RapidAccelMenuSim">menusim</entry>
    <entry key="RapidAccelCmdlBuildOnly">buildonly</entry>
    <entry key="AlgConstBlockInAlgLoopInfo"> ''{0}'' ({1,number,integer})</entry>
  </message>
</rsccat>
