<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ko_KR" product="Simulink" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="CustomCodeParsingFailed">사용자 지정 코드를 구문 분석하지 못했습니다. 사용자 지정 코드가 C++ 언어 구문을 사용하는 경우 "언어"가 "C++"로 설정되어 있는지 확인하십시오. 구문 분석기 오류 메시지: {0}</entry>
    <entry key="NonwritableFolder">Unable to write to current working directory ''{0}''.  Change your current working directory to a directory that is not write-protected.</entry>
    <entry key="CustomCodeInstrumBuildFailed">사용자 지정 코드를 빌드하지 못했습니다. 지정된 사용자 지정 코드가 커버리지와 호환되지 않습니다.</entry>
    <entry key="CustomCodeParsingError">모델 ''{0}''에 대한 사용자 지정 코드를 구문 분석하는 중 오류가 발생했습니다. 사용자 지정 코드에서 오류를 수정하거나, 사용자 지정 코드에 비호환성 문제가 있는 경우 ''{1}''을(를) 비활성화하십시오. 사용자 지정 코드가 C++ 언어 구문을 사용하는 경우 모델 구성 파라미터 &gt; 시뮬레이션 타깃에서 ''언어''가 ''C++''로 설정되어 있는지 확인하십시오.</entry>
    <entry key="CustomCodeParsingDiagnostic">{0}{1}에서,\n{2}:\n{3}</entry>
    <entry key="CustomCodeSnippet">사용자 지정 코드</entry>
    <entry key="CustomCodeParsingUnknownException">알 수 없는 예외입니다.</entry>
    <entry key="BlockCustomCodeParsingError">블록 ''{0}''에 대한 사용자 지정 코드를 구문 분석하는 중 오류가 발생했습니다. 사용자 지정 코드의 오류를 수정하십시오. 사용자 지정 코드가 C++ 언어 구문을 사용하는 경우 모델 구성 파라미터 &gt; 시뮬레이션 타깃에서 ''언어''가 ''C++''로 설정되어 있는지 확인하십시오.</entry>
    <entry key="CallTheFunction">함수 {0}을(를) 호출하십시오.</entry>
    <entry key="CustomCodeLibBuildError">모델 ''{0}''에 대해 사용자 지정 코드 시뮬레이션 타깃을 빌드하는 중 오류가 발생했습니다. 사용자 지정 코드에서 오류를 수정하거나, 사용자 지정 코드에 비호환성 문제가 있는 경우 ''{1}''을(를) 비활성화하십시오.</entry>
    <entry key="CustomCodeLibLoadFailed">Failed to load custom code simulation library:{0}</entry>
    <entry key="CustomCudeParseSuccessful">모델 ''{0}''에서 사용자 지정 코드를 구문 분석하는 데 성공했습니다.</entry>
    <entry key="CustomCodeBuildSuccessful">모델 ''{0}''에 대한 사용자 지정 코드를 성공적으로 빌드했습니다.</entry>
    <entry key="CustomCudeParseSuccessfulWithImport">모델 ''{0}''에서 사용자 지정 코드를 구문 분석하는 데 성공했습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion" btn="apply"&gt; &lt;cmd&gt;Simulink.importExternalCTypes(''{0}'',''Names'',{3});&lt;/cmd&gt; &lt;txt&gt;함수 ''{1}''의 인터페이스에 다음과 같은 사용자 지정 데이터형이 있습니다: \n\n{2}\n이러한 유형을 기본 작업 공간에 Simulink.AliasType, Simulink.Bus 또는 Simulink 열거형 클래스 객체로 수동으로 가져오려면 다음 명령을 사용하십시오:\n&lt;a href="matlab:doc('Simulink.importExternalCTypes')"&gt;Simulink.importExternalCTypes&lt;/a&gt;(''{0}'',''Names'',{3});\n자동으로 가져오려면 [적용]을 클릭하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
        
    </entry>
    <entry key="CustomCodeUndefinedFcnMsg">다음 함수는 지정된 사용자 지정 코드 소스 파일 또는 라이브러리 파일에 정의되어 있지 않습니다.\n{0}</entry>
    <entry key="CustomCodeUndefinedVarMsg">다음 변수는 지정된 사용자 지정 코드 소스 파일 또는 라이브러리 파일에 정의되어 있지 않습니다.\n{0}</entry>
    <entry key="CustomCodeUndefinedFcnFilteredOut">The specified function ''{1}'' in C Caller block ''{0}'' is filtered out because it is undefined in custom code source files or library files.</entry>
    <entry key="UnsupportedCustomCodeVarAccess">
    사용자 지정 코드 변수 ''{0}''에 액세스할 수 없습니다. 다음과 같은 경우에서는 사용자 지정 코드 변수 액세스가 지원되지 않습니다: &lt;ul&gt; &lt;li&gt; 사용자 지정 코드 소스 또는 라이브러리 파일이 변수를 정의하지 않습니다. ''정의되지 않은 함수 처리'' 파라미터를 조정하여 Simulink가 정의되지 않은 함수 및 변수를 처리하는 방법을 지정하십시오&lt;/li&gt; &lt;li&gt; 변수 데이터형이 지원되지 않습니다. 값 유형으로 참조 유형, 공용체 유형(union type), 익명 구조체 또는 열거형, 클래스 유형은 지원되지 않습니다&lt;/li&gt; &lt;/ul&gt;</entry>
    <entry key="AmbiguousCustomType">Simulink type ''{0}'' must be imported into the Architectural Data section of the Simulink Data Dictionary with the ''C++ Namespace'' parameter value set explicitly because Simulink type ''{0}'' matches names of multiple types in the custom code associated with model ''{1}''. Otherwise, the generated code may be incorrect because of unintentional use of namespace.</entry>
    <entry key="SLCCBlockDoesNotSupportMultiExecInstances">서브시스템 내에 있는 블록 ''{0}''은(는) 지원되지 않는 ''{1}''입니다. 해당 서브시스템에 For Each 블록 ''{2}''이(가) 포함되어 있고 이 블록에서 호출하는 사용자 지정 코드가 결정적 출력을 갖지 않을 수 있기 때문입니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{3}'');configset.highlightParameter(''{3}'','DefaultCustomCodeDeterministicFunctions');&lt;/cmd&gt; &lt;txt&gt;출력이 상태가 없고 결정적이라는 가정을 갖도록 선택하여 사용자 지정 코드에서 복수의 실행 인스턴스가 지원되도록 하십시오. ''{3}'' \n블록이 블록 사용자 지정 코드에 의존하는 C Function 블록인 경우 ''CustomCodeIsMultiInstantiable''을 ''on''으로 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
         </entry>
    <entry key="NoAvailableFunctionsInFilterOutMode">C Caller 블록 ''{0}''에서 사용할 수 있는 함수가 없습니다. 정의되지 않은 함수는 기본적으로 필터링됩니다. 자세한 내용은 ''{1}''을(를) 참조하십시오. </entry>
    <entry key="CustCodeSrcFiles">사용자 지정 소스 파일 문자열</entry>
    <entry key="CustCodeLibFiles">사용자 지정 라이브러리 파일 문자열</entry>
    <entry key="CustCodeIncludeDirs">사용자 지정 include 디렉터리 경로 문자열</entry>
    <entry key="TokenizeError">사용자 지정 코드를 확인하는 중 오류가 발생했습니다.</entry>
    <entry key="MismatchedDollars">$ 문자가 일치하지 않습니다. {0}에서 대입을 진행하지 못했습니다.</entry>
    <entry key="CustCodeFileNotFoundInSRootDir">{1}에 지정된 ''{0}''이(가) 모델 디렉터리 {2}에 대한 상대적인 위치에 존재하지 않습니다.</entry>
    <entry key="InvalidDollarString">'$'로 캡슐화된 토큰 ''{0}''이(가) 표현식 ''{1}''에 대입할 수 있는 기본 작업 공간의 문자열로 평가되지 않습니다.</entry>
    <entry key="CustCodeFileNotFoundInSearchDirs">{1}에 지정된 {0}이(가) 다음 검색 디렉터리에 존재하지 않습니다.\n{2}</entry>
    <entry key="ErrorInDollarString">{1}에 대입할 수 있도록 기본 작업 공간의 ''$'' 캡슐화된 토큰 ''{0}''을(를) 평가할 수 없습니다.</entry>
    <entry key="SizeFcnInInputArgDims">인수 ''{0}''에 대한 차원을 확인할 수 없습니다. size() 표현식은 출력 인수 차원 지정에만 사용할 수 있습니다.</entry>
    <entry key="SizeFcnIncorrectInputs">인수 ''{0}''에 대한 차원을 확인할 수 없습니다. size() 표현식은 한 개 또는 두 개의 인수만 받을 수 있습니다.</entry>
    <entry key="SizeFcnInvalidSymbolName">인수 ''{0}''에 대한 차원을 확인할 수 없습니다. size() 표현식의 첫 번째 인수는 입력을 참조해야 합니다.</entry>
    <entry key="SizeFcnOnlyInputInOutputOrParameter">''{0}''을(를) 사용하여 ''{1}''의 차원을 지정하지 못했습니다. 파라미터 값 또는 출력의 차원을 지정하십시오.</entry>
    <entry key="DataMustBeInSizeFcn">인수 ''{0}''에 대한 차원을 확인할 수 없습니다. ''{1}''이(가) size() 표현식 내에서 사용되어야 합니다.</entry>
    <entry key="SizeFcnInvalidDimension">인수 ''{0}''에 대한 차원을 확인할 수 없습니다. size() 표현식의 두 번째 입력은 차원이어야 합니다.</entry>
    <entry key="SizeComputationFailedGeneric">차원을 계산하지 못했습니다. "size()" 표현식을 사용한 차원 지정에 구문 오류가 있는지 확인하십시오.</entry>
    <entry key="SizeComputationFailed">차원을 계산하지 못했습니다. ''{0}''의 차원 지정에 구문 오류가 있는지 확인하십시오.</entry>
    <entry key="SizeComputationFailedInCBlock">''{0}''에 대한 포트 차원을 확인할 수 없습니다. 차원 지정에 구문 오류가 있는지 확인하십시오. Input 및 InputOutput 포트는 상속된 크기만 지원합니다. Output 포트는 size() 표현식을 지원합니다. </entry>
    <entry key="SizeComputationFailedInPyBlock">''{0}''에 대한 포트 차원을 확인할 수 없습니다. 차원 지정에 구문 오류가 있는지 확인하십시오. 입력 포트는 상속된 크기만 지원합니다. Output 포트는 size() 표현식을 지원합니다. </entry>
    <entry key="SizeComputationInvalidDimensionShapeOrValue">인수 ''{0}''에 대한 차원을 계산하지 못했습니다. 차원 사양은 스칼라로 평가될 수 있거나 정수 값으로 구성된 벡터로 평가될 수 있어야 합니다. 각 차원의 길이는 1과 {1, number, integer} 사이여야 합니다.</entry>
    <entry key="SizeExpressionMustBeBuiltInNumeric"> size() 표현식은 내장 숫자형이어야 합니다. 지정된 유형 ''{0}''을(를) 확인할 수 없습니다.</entry>
    <entry key="TypeImporterModelHeaderFieldEmpty">모델 ''{0}''에 지정된 사용자 지정 코드를 확인할 수 없습니다.</entry>
    <entry key="TypeImporterParamValueOutputDirInvalid">지정된 출력 디렉터리 ''{0}''을(를) 찾을 수 없습니다.</entry>
    <entry key="TypeImporterModelHasNoConfigurationParameters">모델 ''{0}''에 유효하지 않은 구성 파라미터가 있습니다.</entry>
    <entry key="TypeImporterArgumentShadowed">속성 ''{0}''은(는) 모델의 구성 파라미터에 의해 가려져 있으므로 설정할 수 없습니다.</entry>
    <entry key="TypeImporterParamValueIsNotString">''{0}'' value must be a nonempty string or character vector.</entry>
    <entry key="TypeImporterParamValueIsNotStringOrStringArray">''{0}'' 값은 비어 있지 않은 string형 또는 string형 배열이어야 합니다.</entry>
    <entry key="TypeImporterParamValueIsNotHardwareImplementation">''{0}'' value must be an instance of "coder.HardwareImplementation" or "Simulink.ConfigSet".</entry>
    <entry key="TypeImporterParamNotSupportSimultaneously">속성 ''{0}''과(와) ''{1}''을(를) 동시에 사용할 수 없습니다.</entry>
    <entry key="TypeImporterParamDataDictionaryAndEnumClassConflict">"DataDictionary"를 사용하는 중에는 속성 "EnumClass"를 "MATLAB 파일"로 설정할 수 없습니다.</entry>
    <entry key="TypeImporterBusTypeImported">파일 ''{1}''에서 ''{0}''을(를) Simulink.Bus 객체로 가져옵니다.</entry>
    <entry key="TypeImporterEnumTypeImported">파일 ''{1}''에서 ''{0}''을(를) 열거형 클래스로 가져옵니다.</entry>
    <entry key="TypeImporterAliasTypeImported">파일 ''{1}''에서 ''{0}''을(를) Simulink.AliasType 객체로 가져옵니다.</entry>
    <entry key="TypeImporterExistingBusType">파일 ''{1}''에서 ''{0}''을(를) 다시 가져올 수 없습니다. 일치하는 Simulink.Bus 객체가 동일한 이름으로 존재합니다.</entry>
    <entry key="TypeImporterExistingEnumType">파일 ''{1}''에서 ''{0}''을(를) 다시 가져올 수 없습니다. 일치하는 열거형 클래스가 동일한 이름으로 존재합니다.</entry>
    <entry key="TypeImporterExistingAliasType">파일 ''{1}''에서 ''{0}''을(를) 다시 가져올 수 없습니다. 일치하는 Simulink.AliasType 객체가 동일한 이름으로 존재합니다.</entry>
    <entry key="TypeImporterInconsistentBusType">파일 ''{1}''에서 ''{0}''을(를) 다시 가져올 수 없습니다. 기존 Simulink.Bus object 객체와 일치하지 않습니다.</entry>
    <entry key="TypeImporterInconsistentAliasType">파일 ''{1}''에서 ''{0}''을(를) 다시 가져올 수 없습니다. 기존 Simulink.AliasType 객체와 일치하지 않습니다.</entry>
    <entry key="TypeImporterInconsistentEnumTypeEnumNames">파일 ''{1}''에서 ''{0}''을(를) 가져올 수 없습니다. 열거형 이름이 기존 열거형 클래스와 일치하지 않습니다.</entry>
    <entry key="TypeImporterInconsistentEnumTypeEnumValues">파일 ''{1}''에서 ''{0}''을(를) 가져오지 못했습니다. 열거형 값이 기존 열거형 클래스와 일치하지 않습니다.</entry>
    <entry key="TypeImporterInconsistentNotValidBusType">파일 ''{1}''에서 ''{0}''을(를) 가져올 수 없습니다. 동일한 변수 이름을 가진 유효하지 않은 Simulink.Bus 객체가 존재합니다.</entry>
    <entry key="TypeImporterInconsistentNotValidAliasType">파일 ''{1}''에서 ''{0}''을(를) 가져올 수 없습니다. 동일한 변수 이름을 가진 유효하지 않은 Simulink.AliasType 객체가 존재합니다.</entry>
    <entry key="TypeImporterInconsistentBusTypeElementField">{0}.Elements({2, number, integer}).{3}에서 파일 ''{1}''의 ''{0}''이(가) 기존 Simulink.Bus 객체와 일치하지 않습니다.</entry>
    <entry key="TypeImporterInconsistentBusTypeNewElement">기존 Simulink.Bus 객체와 비교하여 파일 ''{1}''의 ''{0}''에 새로운 Elements({2, number, integer})이(가) 있습니다.</entry>
    <entry key="TypeImporterNonImportableBusType">파일 ''{1}''에서 ''{0}''을(를) 가져올 수 없습니다. 비어 있거나, Simulink에서 지원되지 않는 유형의 필드가 있습니다.</entry>
    <entry key="TypeImporterInvalidVariableName">파일 ''{1}''에서 ''{0}''을(를) 가져올 수 없습니다. 유효한 MATLAB 변수 이름이 아닙니다.</entry>
    <entry key="TypeImporterInvalidFieldName">필드 이름이 유효하지 않으므로 파일 ''{1}''에서 ''{0}''을(를) 가져올 수 없습니다.</entry>
    <entry key="TypeImporterAmbiguousType">서로 다른 네임스페이스에 여러 유형의 동일한 이름이 있기 때문에 파일 ''{1}''에서 ''{0}''을(를) 가져올 수 없습니다. "Names" 옵션을 네임스페이스 정규화 유형 이름과 함께 사용하여 한 가지 유형만 지정하십시오.</entry>
    <entry key="TypeImporterEnumStorageType64Bits">열거형 스토리지 유형이 64비트이기 때문에 파일 ''{1}''에서 ''{0}''을(를) 가져올 수 없습니다.</entry>
    <entry key="TypeImporterFailToCreateEnumTypeFile">Unable to open enum file for enum type ''{0}''. \n{1}</entry>
    <entry key="TypeImporterDataDictionaryNeededForDataDictioanrySection">A valid value of ''DataDictionary'' option is required when specifying a value for ''DataDictionarySection'' option.</entry>
    <entry key="TypeImporterInconsistentTypeNamespace">파일 ''{1}''에서 ''{0}''을(를) 다시 가져올 수 없습니다. ''{0}'' 유형이 Simulink 데이터 사전에 존재하며, 해당 C++ 네임스페이스가 기존 유형의 코드 생성 C++ 네임스페이스와 다릅니다.</entry>
    <entry key="TypeImporterInconsistentTargetDataSection">파일 ''{1}''에서 ''{0}''을(를) 다시 가져올 수 없습니다. ''{0}'' 유형이 Simulink 데이터 사전에 존재하며, 지정된 ''DataDictionarySection''이 기존 유형의 데이터 섹션과 다릅니다.</entry>
    <entry key="TypeImporterFailToCreateEnumTypeBecauseOfConflict">Failed to create enumeration type ''{0}'' because an enumeration with the same name already exists in the path or has been loaded in another data dictionary.</entry>
    <entry key="CFcnCallerBlkFcnNotExist">C Caller 블록 ''{0}''에서 함수 ''{1}''을(를) 호출할 수 없습니다. 함수가 사용자 지정 코드에 정의되지 않았거나 C Caller 블록에서 지원되지 않는 유형입니다.</entry>
    <entry key="CFcnCallerSyncToolTip">사용자 지정 코드를 새로 고칩니다.</entry>
    <entry key="CFcnCallerGotoFcnDefNoFcnDlgErrTitle">사용자 지정 코드 오류</entry>
    <entry key="CustomCodeGenericError">사용자 지정 코드 오류</entry>
    <entry key="CFcnCallerGotoFcnDefNoFcn">선택한 함수 ''{0}''을(를) 찾을 수 없습니다. [새로 고침] 버튼을 클릭하십시오.</entry>
    <entry key="CFcnCallerGotoFcnDefToolTip">함수로 이동합니다.</entry>
    <entry key="CFcnCallerConfigSetToolTip">사용자 지정 코드 설정을 구성합니다.</entry>
    <entry key="InvalidTypeForInport">''{0}''을(를) ''{2}''의 &lt;sldiag objui="inport" objparam="{1, number, integer}" objname="{2}"&gt;{1, number, integer}번 입력 포트&lt;/sldiag&gt;에 대한 유효한 유형으로 확인할 수 없습니다.</entry>
    <entry key="InvalidTypeForOutport">''{0}''을(를) ''{2}''의 &lt;sldiag objui="outport" objparam="{1, number, integer}" objname="{2}"&gt;{1, number, integer}번 출력 포트&lt;/sldiag&gt;에 대한 유효한 유형으로 확인할 수 없습니다.</entry>
    <entry key="InvalidTypeForParam">Unable to resolve ''{0}'' to a valid type for block parameter or constant ''{1}'' of ''{2}''.</entry>
    <entry key="ParsingTypeFailed">인수 ''{1}''에 대해 유형 문자열 ''{0}''을(를) 구문 분석하지 못했습니다.</entry>
    <entry key="CCallerParameterRegisterError">C Caller 블록 ''{0}''에 대한 파라미터를 등록할 수 없습니다.</entry>
    <entry key="ParameterCFcnDimensionMismatch">Parameter data size mismatch. Block parameter ''{0}'' of specified dimension ''{1}'' does not match size of evaluated parameter ''{2}''.</entry>
    <entry key="ParameterValueCannotBeEmptyMatrix">The value of block parameter ''{0}'' is set to be an empty matrix. Parameter value that is an input to a C Function cannot be an empty matrix.</entry>
    <entry key="PortSpec_Prompt">포트 사양:</entry>
    <entry key="CFunctionPortSpec_Prompt">포트 및 파라미터</entry>
    <entry key="PortSpec_ArgName">이름</entry>
    <entry key="PortSpec_Scope">범위</entry>
    <entry key="PortSpec_Index">포트</entry>
    <entry key="PortSpec_Label">레이블</entry>
    <entry key="PortSpec_Type">유형</entry>
    <entry key="PortSpec_Size">차원</entry>
    <entry key="CSPortSpec_Size">차원</entry>
    <entry key="NameColumnForClassTooltip">이름을 사용하여 클래스의 객체를 인스턴스화합니다. 예를 들어, "obj" 또는 "obj()"와 같습니다.\n클래스 생성자에 인수를 전달하기 위해 상수뿐만 아니라 \n이 테이블에 정의된 상수와 파라미터 기호를 갖는 표현식도 사용할 수 있습니다.\n예를 들어, "obj(10)" 또는 "obj(aParam[0])"과 같습니다.</entry>
    <entry key="NameColumnTooltip">포트 또는 파라미터 변수 이름</entry>
    <entry key="LabelColumnTooltipInputOutput">포트 레이블 문자열</entry>
    <entry key="LabelColumnTooltipParam">파라미터 대화 상자 프롬프트</entry>
    <entry key="LabelColumnTooltipConstant">상수 기호의 값으로 평가되는 표현식</entry>
    <entry key="FailToRegisterCustomType">Failed to register custom type ''{0}''.</entry>
    <entry key="CustomTypeNameCollision">Failed to register custom type with name ''{0}'' as another type with the same name has been registered already.</entry>
    <entry key="ContinuousSampleTimeNotAllowed">C Caller 블록 "{0}"은(는) 비결정적 출력을 가질 수 있는 사용자 지정 코드를 호출하므로 연속 샘플 시간을 지원하지 않습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{1}'');configset.highlightParameter(''{1}'','DefaultCustomCodeDeterministicFunctions');&lt;/cmd&gt; &lt;txt&gt;결정적 함수를 지정하여 사용자 지정 코드에 대해 연속 샘플 시간 지원을 활성화하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
 </entry>
    <entry key="ContinuousTimeNotAllowedForNonDeterministic">C Function 블록 ''{0}''은(는) 비결정적 출력을 가질 수 있는 사용자 지정 코드를 사용하므로 연속 샘플 시간을 지원하지 않습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{1}'');configset.highlightParameter(''{1}'','DefaultCustomCodeDeterministicFunctions');&lt;/cmd&gt; &lt;txt&gt;결정적 함수를 지정하여 사용자 지정 코드에 대해 연속 샘플 시간 지원을 활성화하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
 </entry>
    <entry key="EmptyCustomCodeSetting">C Caller 블록 ''{0}''을(를) 사용하려면 모델에 가져올 수 있는 사용자 지정 코드가 연결되어 있어야 합니다. 지정된 사용자 지정 코드가 없거나 ''{1}''이(가) 비활성화되었습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{2}'');configset.highlightParameter(''{2}'','SimCustomHeaderCode');&lt;/cmd&gt; &lt;txt&gt;모델 ''{2}''에 사용자 지정 코드 종속성을 추가할 수 있습니다&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{2}'');configset.highlightParameter(''{2}'',''SimParseCustomCode'');&lt;/cmd&gt; &lt;txt&gt;모델 ''{2}''에 대해 ''{1}''을(를) 활성화하십시오&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
        
    </entry>
    <entry key="CFcnCallerBlockFcnOutputArgSizeNotSpecified">Specify size of output argument ''{0}'' for C Caller block ''{1}'' or select "Simulate custom code in a separate process" in Configuration Parameters &gt; Simulation Target pane.</entry>
    <entry key="CCallerParseTypeError">C Caller 블록 ''{0}''에 대한 인수 유형을 구문 분석할 수 없습니다.</entry>
    <entry key="UnexpectedExtension">사용자 지정 코드 소스/헤더 파일에 대한 예기치 않은 확장자임: ''{0}''</entry>
    <entry key="NonConstCPointerInputNotGoodAsInputOrParameter">C Caller 블록 ''{0}''에서 함수 인수 ''{1}''이(가) ''const'' 한정자 없이 포인터로 전달되었습니다. 그러나 이 인수는 읽기 전용 인수를 위한 포트 사양 테이블에 블록 ''{2}''(으)로 지정되었습니다. 함수 ''{3}''이(가) 포인터를 통해 인수 ''{1}''에 쓰지 않는지 확인하십시오.</entry>
    <entry key="AddDeleteGIOErrorWithAutoInfer"> Error using ''addGlobalArg'' or ''deleteGlobalArg'' function with ''Automatically infer global variables as function interfaces'' parameter selected. To use those functions, in the model Configuration Parameters dialog box, deselect 'Simulation Target &gt; Import settings &gt; Automatically infer global variables as function interfaces'.</entry>
    <entry key="CCallerName">C Caller 블록</entry>
    <entry key="CCallerPort">인수</entry>
    <entry key="CFunctionName">C Function 블록</entry>
    <entry key="CFunctionPort">기호</entry>
    <entry key="SimulinkTypeIncompatibleWithCustomCodeType">Simulink data type specified for argument ''{0}'' for C Caller block ''{1}'' is incompatible with the argument's type in the custom code. Ensure that a compatible Simulink data type is specified for argument ''{0}''.</entry>
    <entry key="BusTypeNameMismatch">{4} ''{1}''의 {3} ''{0}''에 대해 지정된 버스 유형이 사용자 지정 코드의 {3}의 유형과 일치하지 않습니다. [구성 파라미터] &gt; [시뮬레이션 타깃] 창에서 {2}에 대한 구조체 정의를 확인하십시오.</entry>
    <entry key="BusTypeFieldNameMismatch">{4} ''{1}''의 {3} ''{0}''에 대해 지정된 버스 유형 필드 이름이 사용자 지정 코드의 {3}의 유형과 일치하지 않습니다. [구성 파라미터] &gt; [시뮬레이션 타깃] 창에서 {2}에 대한 구조체 정의를 확인하십시오.</entry>
    <entry key="BusTypeFieldTypeMismatch">{4} ''{1}''의 {3} ''{0}''에 대한 버스에 지정된 필드 유형이 사용자 지정 코드의 {3}의 유형과 일치하지 않습니다. 구성 파라미터 &gt; 시뮬레이션 타깃 창에서 {2}에 대한 구조체 정의를 확인하십시오.</entry>
    <entry key="BusTypeElementEnumNameMismatch">{4} ''{1}''의 {3} ''{0}''의 버스 필드 유형에 대해 지정된 열거형 이름이 사용자 지정 코드의 {3}의 유형과 일치하지 않습니다. [구성 파라미터] &gt; [시뮬레이션 타깃] 창에서 {2}에 대한 열거형 정의를 확인하십시오.</entry>
    <entry key="BusTypeElementEnumFieldValueMismatch">{4} ''{1}''의 {3} ''{0}''의 버스 필드 유형에 대해 지정된 열거형 요소의 값이 사용자 지정 코드의 {3}의 유형과 일치하지 않습니다. [구성 파라미터] &gt; [시뮬레이션 타깃] 창에서 {2}에 대한 열거형 정의를 확인하십시오.</entry>
    <entry key="BusTypeFieldNumMismatch">{4} ''{1}''의 {3} ''{0}''에 대한 버스 유형에 지정된 필드 개수가 사용자 지정 코드의 {3}의 유형과 일치하지 않습니다. 구성 파라미터 &gt; 시뮬레이션 타깃 창에서 {2}에 대한 구조체 정의를 확인하십시오.</entry>
    <entry key="BusTypeElementEnumFieldNumMismatch">{4} ''{1}''의 {3} ''{0}''의 버스 필드 유형에 대해 지정된 열거형 요소의 개수가 사용자 지정 코드의 {3}의 유형과 일치하지 않습니다. [구성 파라미터] &gt; [시뮬레이션 타깃] 창에서 {2}에 대한 열거형 정의를 확인하십시오.</entry>
    <entry key="BusTypeElementCPPEnumStorageTypeMismatch">{4} ''{1}''의 {3} ''{0}''의 버스 필드 유형에 대해 지정된 Simulink 열거형 스토리지 유형이 사용자 지정 코드의 C++ 열거형 {2}의 기본 유형과 일치하지 않습니다.</entry>
    <entry key="EnumTypeNameMismatch">{4} ''{1}''의 {3} ''{0}''에 대해 지정된 열거형 유형이 사용자 지정 코드의 {3}의 유형과 일치하지 않습니다. [구성 파라미터] &gt; [시뮬레이션 타깃] 창에서 {2}에 대한 열거형 정의를 확인하십시오.</entry>
    <entry key="EnumTypeFieldNumMismatch">{4} ''{1}''의 {3} ''{0}''에 대해 지정된 열거형 요소의 개수가 사용자 지정 코드의 {3}의 유형과 일치하지 않습니다. [구성 파라미터] &gt; [시뮬레이션 타깃] 창에서 {2}에 대한 열거형 정의를 확인하십시오.</entry>
    <entry key="EnumTypeFieldValueMismatch">{4} ''{1}''의 {3} ''{0}''에 대해 지정된 열거형 요소의 값이 사용자 지정 코드의 {3}의 유형과 일치하지 않습니다. 구성 파라미터 &gt; 시뮬레이션 타깃 창에서 {2}에 대한 열거형 정의를 확인하십시오.</entry>
    <entry key="CPPEnumStorageTypeMismatch">{4} ''{1}''의 {3} ''{0}''에 대해 지정된 Simulink 열거형 스토리지 유형이 사용자 지정 코드의 C++ 열거형 {2}의 기본 유형과 일치하지 않습니다.</entry>
    <entry key="MultiWordFixptNotSupported">Simulink data type specified for argument ''{0}'' for C Caller block ''{1}'' is a multiword fixed-point type on the current target. Using multiword fixed-point types is not supported for C Caller block. Only fixed-point types with maximum word length of {2,number,integer} can be used on the current target.</entry>
    <entry key="PortSpecConsistencyError"> {0} of argument ''{1}'' for function ''{2}'' is specified as ''{4}'' in C Caller block {3} and ''{5}'' in C Caller block {6}. C Caller blocks that call the same function must specify the same argument {0}. </entry>
    <entry key="PortSpecInconsistencyTopError">동일한 사용자 지정 코드 함수를 호출하는 두 개의 C Caller 블록 간에 일치하지 않는 포트 사양이 발견되었습니다.</entry>
    <entry key="CCallerInvalidArgumentType">인수 ''{1}''에 대한 유형 ''{0}''이(가) 유효하지 않습니다.</entry>
    <entry key="UnableToCallFunctionWithNDArrayCPP">함수 인수 중 하나가 다차원 배열이고 시뮬레이션 타깃 또는 코드 생성 언어가 ''C++''로 설정되어 있기 때문에 블록 ''{1}''의 사용자 지정 코드 함수 ''{0}''을(를) 호출할 수 없습니다.</entry>
    <entry key="UnableToCallFunctionWithNDArrayCPP_SF">함수 인수 중 하나가 다차원 배열이고 시뮬레이션 타깃 또는 코드 생성 언어가 ''C++''로 설정되어 있기 때문에 사용자 지정 코드 함수 ''{0}''을(를) 호출할 수 없습니다.</entry>
    <entry key="InputArgumentSizeMismatchWarning">블록 ''{2}''의 인수 ''{0}''에 대해 사용자 지정 코드 함수 ''{1}''에 전달된 입력 파라미터 크기가 사용자 지정 코드 함수에 필요한 크기와 일치하지 않습니다.</entry>
    <entry key="GIOWriteOnlyAsInputWarning">블록 ''{2}''의 전역 인수 ''{0}''에 대한 범위 설정이 유효하지 않습니다. 인수는 블록에 ''Input'' 범위로 설정되어 있으나, 해당 전역 변수는 사용자 지정 코드 함수 ''{1}''에 ''Output''을 나타내는 것으로만 작성되어 있습니다.</entry>
    <entry key="InputArgumentSizeMismatchWarningCFunctionBlk">블록 ''{2}''의 인수 [{0, number, integer}]에 대해 사용자 지정 코드 함수 ''{1}''에 전달된 입력 파라미터 크기가 사용자 지정 코드 함수에 필요한 크기와 일치하지 않습니다.</entry>
    <entry key="CCallerRowMajorFunctionWithStructInColumnMajorCodegen">C Caller 블록 ''{0}''이(가) 입력 또는 출력으로 비 스칼라 필드를 갖는 구조체가 포함된 행 우선 사용자 지정 코드 함수 ''{1}''을(를) 호출합니다. 이는 열 우선 코드 생성에서 지원되지 않습니다.</entry>
    <entry key="DynamicSLStringAsOutput">인수 ''{0}''에 지정된 Simulink 문자열 유형은 C Caller 블록 ''{1}''의 최대 문자열 길이를 지정해야 합니다. "stringtype"을 사용하여 Output 및 InputOutput 포트에 대한 최대 문자열 길이를 지정하십시오.</entry>
    <entry key="StdStringToNonConstFcnArg">모델이 입력값 ''{2}''에 대해 ''std::string''을 생성하도록 구성되어 있으므로 사용자 지정 코드 함수 ''{1}''을(를) 호출하는 C Caller 블록 ''{0}''에 대해 C++ 코드를 생성할 수 없습니다. const 한정 형식이 아닌 함수 인수 ''{2}''은(는) std::string을 지원하지 않습니다. 함수 인수 ''{2}''에 const 한정자를 추가해 보십시오.</entry>
    <entry key="ParameterScopeNotSupportedForSLString">파라미터 범위가 인수 ''{0}''에 대한 Simulink 문자열을 지원하지 않습니다.</entry>
    <entry key="GlobalSLStringVar">C Caller 블록 ''{1}''은(는) 전역 변수 ''{0}''에 대해 Simulink 문자열을 지원하지 않습니다.</entry>
    <entry key="CFunctionBlockParsingFailed">C Function 블록 ''{2}''에서 ''{0}'' 코드의 구문 분석에 실패했으며 메시지는 다음과 같습니다:\n{1}</entry>
    <entry key="CFunctionBlockParsingFailedAddOn">코드 생성 탭에서 &lt;a href="matlab:doc('c function')"&gt;''현재 코드 그대로 생성''&lt;/a&gt;을 설정해 보십시오.</entry>
    <entry key="CFunctionBlockParsingFailedWithImportCustomCodeOff">C Function 블록 ''{3}''의 구문 분석에 실패했습니다. C Function 블록이 외부 코드를 사용하는 경우 ''{0}''이(가) 활성화되어야 합니다. {1} 구문 분석에 실패했으며 메시지는 다음과 같습니다:\n{2}</entry>
    <entry key="SymbolTableBlockParameterCannotBeEmpty">블록 파라미터 ''{0}''의 값이 빈 행렬로 설정되어 있습니다. {2} ''{1}''에서 입력값에 해당하는 파라미터 값은 빈 행렬일 수 없습니다.</entry>
    <entry key="SymbolTableBlockParameterDimensionMismatch">{3} ''{2}''에서 파라미터 데이터 크기가 일치하지 않습니다. 지정된 차원 ''{1}''의 블록 파라미터 ''{0}''이(가) 평가된 파라미터 ''{0}''의 크기와 일치하지 않습니다.</entry>
    <entry key="SymbolTableBlockInvalidTypeForInputPort">''{0}''을(를) ''{2}''의 &lt;sldiag objui="inport" objparam="{1, number, integer}" objname="{2}"&gt;{1, number, integer}번 입력 포트&lt;/sldiag&gt;에 대한 유효한 유형으로 확인할 수 없습니다.</entry>
    <entry key="SymbolTableBlockInvalidTypeForOutputPort">''{0}''을(를) ''{2}''의 &lt;sldiag objui="outport" objparam="{1, number, integer}" objname="{2}"&gt;{1, number, integer}번 출력 포트&lt;/sldiag&gt;에 대한 유효한 유형으로 확인할 수 없습니다.</entry>
    <entry key="CFunctionFunctionPointerError">C Function 블록 ''{1}''에서 함수 포인터 ''{0}''은(는) 지원되지 않습니다.</entry>
    <entry key="StaticDeclaration"> C Function 블록 ''{1}''에서 정적 변수 {0}을(를) 선언하는 것은 허용되지 않습니다. 블록에서 포트 사양의 이 변수를 '영속' 범위로 선언하십시오.</entry>
    <entry key="DuplicateDeclaration"> 변수 {0}이(가) 여러 곳에서 선언되었습니다. C Function 블록 ''{1}'' 또는 C 코드에서 이 변수를 삭제하거나 이름을 변경하십시오.</entry>
    <entry key="WritingToInputVar"> C Function 블록 ''{1}''에서 읽기 전용 입력 또는 파라미터 기호 ''{0}''에 쓰는 중입니다.</entry>
    <entry key="ArgumentNameConflict"> Another symbol with name ''{0}'' already exists in the {2} ''{1}''. Select a different name for your new symbol. </entry>
    <entry key="CFunctionInvalidAccessToArraySymbol"> C Function 블록 ''{1}''에서 배열 유형의 기호 ''{0}''에 대한 액세스가 유효하지 않습니다. </entry>
    <entry key="CFunctionReadOnlyAddressEscaping"> C Function 블록 ''{1}''에서 "const"가 아닌 정규화된 포인터 타깃 유형에 읽기 전용 입력 또는 파라미터 기호 ''{0}'' 주소를 할당하는 것은 권장되지 않으며 이로 인해 코드 생성 시 빌드 실패가 발생할 수 있습니다.</entry>
    <entry key="CFunctionProhibitedConstantAddress"> C Function 블록 ''{1}''에서 상수 기호 ''{0}''의 주소에 쓰거나 그 주소를 가져오는 것은 허용되지 않습니다. </entry>
    <entry key="SymbolTableBlockInvalidArgumentName"> 블록 ''{1}''에 있는 기호 ''{0}''이(가) 유효하지 않은 변수 이름입니다. </entry>
    <entry key="CFunctionBlockModelColumnMajorityMismatch"> C Function 블록 ''{0}''은(는) 행 우선 구성을 포함하며 열 우선 코드 생성을 지원하지 않습니다. </entry>
    <entry key="CFunctionBlockModelRowMajorityMismatch"> C Function 블록 ''{0}''은(는) 열 우선 구성을 포함하며 행 우선 코드 생성을 지원하지 않습니다. </entry>
    <entry key="CFunctionBlockInvalidArgumentType"> 데이터형 ''{0}''은(는) 유효하지 않습니다. </entry>
    <entry key="SymbolTableBlockOutputArgSizeNotSpecified"> 출력 기호에는 상속된 크기 "-1"이 지원되지 않습니다. {2} ''{1}''에 대해 출력 기호 ''{0}''의 크기를 정확하게 지정하십시오 </entry>
    <entry key="SymbolTableBlockCodeParsingTypeFailed">{3} ''{2}''에서 기호 ''{1}''에 대한 string형 ''{0}''을(를) 구문 분석하지 못했습니다.</entry>
    <entry key="CFunctionIntrinsicMismatchedInputs">C Function 블록 ''{1}''에서 ''{0}''에 대한 입력이 일치하지 않습니다. 함수 ''{0}''은(는) [{2, number, integer}]개의 입력을 받는데 현재 [{3, number, integer}]개가 발견되었습니다.</entry>
    <entry key="CFunctionUnsupportedLibraryFunctionCall">Error with unsupported call to function ''{0}'' in C Function block ''{1}''. Calling C library functions directly in C Function block is not supported. To see a list of supported Simulink library functions in C Function block, view the &lt;a href="matlab:doc('c function')"&gt;documentation&lt;/a&gt;.</entry>
    <entry key="CFunctionFunctionNotFound">C Function 블록 ''{1}''에 선언되지 않은 함수 ''{0}''이(가) 지정되었습니다. 함수 ''{0}''은(는) 사용자 지정 코드 소스 파일 또는 라이브러리 파일에 정의되어 있지 않기 때문에 필터링되어 버릴 수 있습니다.</entry>
    <entry key="CFunctionVariableNotFound">C Function 블록 ''{1}''에 선언되지 않은 변수 ''{0}''이(가) 지정되었습니다. 변수 ''{0}''은(는) 사용자 지정 코드 소스 파일 또는 라이브러리 파일에 정의되어 있지 않기 때문에 필터링되어 버릴 수 있습니다.</entry>
    <entry key="CFunctionBlockPassByRefOutputDirectPass">C Function 블록 ''{1}''의 함수 ''{0}''을(를) 호출할 수 없습니다. 함수의 출력값을 참조로 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="CFunctionBlockUnsupportedFcnCalled">C Function 블록 ''{1}''에서 함수 ''{0}''을(를) 호출할 수 없습니다. 함수가 C Function 블록에서 지원되지 않는 유형이기 때문입니다. </entry>
    <entry key="CFunctionBlockOverloadedFcnCalled">C Function 블록 ''{1}''에서 오버로드된 함수 ''{0}''을(를) 호출할 수 없습니다. </entry>
    <entry key="CFunctionIntrinsicTypeVariantUnsupported">C Function 블록 ''{2}''에 지정된 ''{0}''을(를) 호출하는 것은 지원되지 않습니다. 대신 ''{1}''을(를) 사용하십시오.</entry>
    <entry key="CFunctionInvalidAdditionalType">Unable to resolve ''{0}'' to a valid type for ''{1}'' in the C Function block ''{2}''.</entry>
    <entry key="SymbolTableBlockInvalidDimensionInInputDims">{2} ''{1}''에서 기호 ''{0}''에 대한 크기를 확인하는 중 오류가 발생했습니다. 입력 또는 출력 기호 차원은 상속된 크기 "-1" 또는 정확한 크기로 지정해야 합니다.</entry>
    <entry key="SymbolTableBlockInvalidDimensionInOutputDims">{2} ''{1}''에서 기호 ''{0}''에 대한 크기를 확인하는 중 오류가 발생했습니다. 출력 기호 차원은 정확한 크기 또는 size() 표현식으로 지정해야 합니다.</entry>
    <entry key="SymbolTableBlockInvalidDimensionInParameterDims">{2} ''{1}''에서 기호 ''{0}''에 대한 크기를 확인하는 중 오류가 발생했습니다. 파라미터 기호 차원은 상속된 크기 "-1" 또는 정확한 크기로 지정해야 합니다.</entry>
    <entry key="SymbolTableBlockInvalidDimensionInPersistentDims">{2} ''{1}''에서 기호 ''{0}''에 대한 크기를 확인하는 중 오류가 발생했습니다. 영속 기호 차원은 양의 정수로 지정해야 합니다.</entry>
    <entry key="SymbolTableBlockEmptySizeFcnInArgDims">{2} ''{1}''에서 기호 ''{0}''의 크기를 지정해야 합니다.</entry>
    <entry key="CFunctionBlockMatrixSymbol">Symbol ''{0}'' in C Function block ''{1}'' cannot be a matrix or contain matrices. Only scalar and vector symbols are supported with a C Function block.</entry>
    <entry key="CFunctionBlockMatrixVar">C Function 블록 ''{1}''의 지역 변수 ''{0}''은(는) 행렬이거나 행렬을 포함할 수 없습니다. C Function 블록에는 벡터 변수만 지원됩니다.</entry>
    <entry key="CFunctionMemcpyNDUnsupported">C Function 블록 ''{0}''에서는 행렬 또는 다차원 배열을 memcpy 또는 memset에 전달하는 것이 지원되지 않습니다.</entry>
    <entry key="CFunctionAliasTypeMismatch">Symbols 테이블에 지정된 기호 ''{0}''에 대한 별칭 유형이 C Function 블록 ''{1}''의 구문 분석된 별칭 typedef와 일치하지 않습니다. 구성 파라미터 &gt; 시뮬레이션 타깃 창에서 ''{2}''에 대한 유형 정의를 확인하십시오.</entry>
    <entry key="CFunctionBlockMatrixCustomCodeVar">Custom code variable ''{0}'' used in the C Function block ''{1}'' cannot be a matrix or contain matrices. Only vector custom code variables are supported with a C Function block.</entry>
    <entry key="SymbolTableBlockMatrixPersistent">{2} ''{1}''에서 기호 ''{0}''은(는) 행렬일 수 없습니다. {2}의 '영속' 범위에는 스칼라 또는 벡터만 지원됩니다.</entry>
    <entry key="SymbolTableBlockOpaquePtrMustBeScalar">{3} ''{1}''에서 기호 ''{0}''은(는) 크기가 '1'이어야 합니다. 유형 ''{2}''의 '영속' 범위 기호에는 스칼라만 지원됩니다.</entry>
    <entry key="SymbolTableBlockOpaquePtrNotAllowed">{3} ''{1}''에서 기호 ''{0}''은(는) 유형 ''{2}''일 수 없습니다. '영속' 범위의 기호만 유형 ''{2}''일 수 있습니다.</entry>
    <entry key="SymbolTableBlockStringTypeNotAllowed">{2} ''{1}''에서 기호 ''{0}''은(는) Simulink 문자열 유형일 수 없습니다. 'Parameter' 범위가 Simulink 문자열을 지원하지 않습니다.</entry>
    <entry key="CFunctionBlockMatrixIndexOutOfRange">C Function 블록 ''{4}''에서 첨자 [{0, number, integer}]이(가) 행렬 ''{1}''의 범위를 벗어났습니다. 유효한 첨자 범위는 {2, number, integer}...{3, number, integer}입니다.</entry>
    <entry key="CFunctionBlockMatrixElementAddressEscape">C Function 블록 ''{0}''에서는 행렬 요소의 주소를 취할 수 없습니다. 행렬 요소의 주소를 취하지 않도록 블록 코드를 수정하십시오.</entry>
    <entry key="CFunctionBlockMatrixElementAddressEscapeToCustomCodeCall">C Function 블록 ''{0}''에서는 행렬의 요소 중 첫 번째가 아닌 요소의 주소를 외부 함수에 전달할 수 없습니다. 행렬의 첫 번째 요소의 주소만 외부 함수에 전달하도록 블록 코드를 수정하십시오.</entry>
    <entry key="CFunctionBlockMatrixPartialAccess">C Function 블록 ''{0}''에서는 행렬에 대한 부분적 액세스가 허용되지 않습니다. C Function 블록에서는 행렬의 요소에만 액세스할 수 있습니다.</entry>
    <entry key="CFunctionBlockUnionFieldAccess">C Function 블록 ''{0}''에서 공용체 필드에 액세스하는 것은 허용되지 않습니다.</entry>
    <entry key="CFunctionBlockFunctionMajorityNotSpecifiedInRowMajorCodegen">C Function 블록 ''{0}''이(가) 함수 배열 레이아웃이 '지정되지 않음'으로 설정된 사용자 지정 코드 함수 ''{1}''을(를) 호출합니다. 구성 파라미터 &gt; 시뮬레이션 타깃 창에서 ''{1}''에 대해 함수 배열 레이아웃을 지정하십시오.</entry>
    <entry key="CFunctionBlockRowMajorFunctionWithStructInColumnMajorCodegen">C Function 블록 ''{0}''이(가) 행 우선 사용자 지정 코드 함수 ''{1}''을(를) 호출합니다. 이 코드 함수에는 입력 또는 출력으로 비 스칼라 필드를 갖는 구조체가 있습니다. 열 우선 코드 생성에서는 비 스칼라 필드 입력 또는 출력을 갖는 구조체가 있는 행 우선 사용자 지정 코드 함수를 호출할 수 없습니다.</entry>
    <entry key="CFunctionBlockUninitializedlocalVarUsage">지역 변수 ''{0}''이(가) 초기화되기 전에 C Function 블록 ''{1}''에서 사용되었습니다. </entry>
    <entry key="FixedPointNumBitMismatch">C Function 블록 ''{2}''의 함수 ''{1}''에 전달된 인수 ''{0, number, integer}''에서 고정소수점 데이터형이 일치하지 않습니다.</entry>
    <entry key="CFunctionBlockDiagSourceLocation">다음 라인에서 발생함:\n\t{0}</entry>
    <entry key="CFunctionIncompatiblePointerArgument">호환되지 않는 포인터 유형에서 C Function 블록 ''{2}''에 있는 외부 C 함수 ''{1}''의 {0, number, integer}번째 인수를 전달하고 있습니다. 포인터 인수가 외부 C 함수의 파라미터 유형과 호환되는지 확인하십시오.</entry>
    <entry key="CFunctionBlockPointerConversionNotSupported">C Function 블록 ''{0}''에서는 포인터 유형과 포인터가 아닌 유형 간의 변환이 지원되지 않습니다. 포인터 유형과 포인터가 아닌 유형 간에 묵시적 또는 명시적 변환이 발생하지 않도록 블록 코드를 수정하십시오.</entry>
    <entry key="CFunctionVariadicFunctionNotSupported">C Function 블록 ''{1}''의 외부 함수 ''{0}''이(가) 가변 인자 함수(variadic function)입니다. C Function 블록에서는 가변 인자 함수를 호출할 수 없습니다.</entry>
    <entry key="SymbolTableBlockScaledDoubleNotSupported">{2} ''{1}''에서 기호 ''{0}''에 대해 지정된 유형이 유효하지 않습니다. {2}에는 스케일링된 double형이 지원되지 않습니다.</entry>
    <entry key="IncludeFoundInScript"> C Function 블록 ''{0}''에서 '#include' 지시문이 발견되었습니다. include 지시문은 구성 파라미터에서만 추가할 수 있습니다. \n{1} </entry>
    <entry key="InputVarUsedInMethod"> C Function 블록 ''{1}''에서 시작 코드, InitializeConditions 코드 또는 종료 코드에 Input 기호 또는 InputOutput 기호 ''{0}''을(를) 사용하는 중 오류가 발생했습니다. Input 기호 및 InputOutput 기호는 ''출력 코드'' 내에서만 액세스할 수 있습니다. </entry>
    <entry key="CFunctionBlockUnsupportedVarTypes">C Function 블록 ''{1}''에서는 지역 변수 또는 전역 변수 ''{0}''의 데이터형이 지원되지 않습니다.</entry>
    <entry key="CFunctionBlockLocalVarOfStructWithNDTypeNotSupported">지역 변수 ''{0}''이(가) 행렬 필드 유형이 포함된 구조체를 갖습니다. 변수 유형이 사용자 지정 코드 내부에 정의된 경우 행렬 유형을 갖는 구조체의 지역 변수는 C Function 블록 ''{1}''에서 지원되지 않습니다.</entry>
    <entry key="ClassDefinitionInScript">C Function 블록 ''{1}'' 내에서 클래스 유형 ''{0}''을(를) 정의하는 것은 지원되지 않습니다.</entry>
    <entry key="SymbolTableBlockUnsupportedParameterComplex">{2} ''{1}''의 파라미터 기호 ''{0}''이(가) 복소수로 평가되었습니다. 복소수 값은 {2}에서 지원되지 않습니다.</entry>
    <entry key="SymbolTableBlockMultiWordNotSupported">{3} ''{1}''의 기호 ''{0}''은(는) 현재 타깃에서 멀티워드 유형입니다. 최대 워드 길이가 {2,number,integer}인 정수형만 {3}의 현재 타깃에서 사용할 수 있습니다.</entry>
    <entry key="ConstantEvalFailed">''{2}''의 기호 ''{1}''에 대한 '상수' 표현식 ''{0}''을(를) 평가하는 중 오류가 발생했습니다. ''{0}''의 '상수' 지정에 구문 오류나 정의되지 않은 변수 이름이 있는지 확인하십시오. '상수' 표현식은 내장 숫자형 스칼라로 평가되어야 합니다.</entry>
    <entry key="SizeComputationConstantNotScalar">표현식 ''{1}''에서 기호 ''{0}''을(를) 평가하는 중 오류가 발생했습니다. 크기 표현식을 가진 상수 범위 값은 평가하면 내장된 숫자형 스칼라가 되어야 합니다.</entry>
    <entry key="SizeComputationConstantOutOfRange">표현식 ''{1}''에서 기호 ''{0}''을(를) 평가하는 중 오류가 발생했습니다. 크기 표현식을 가진 상수 범위 값은 {2, number, integer}에서 {3, number, integer} 사이의 정수여야 합니다.</entry>
    <entry key="SizeComputationConstantEvalFailedInBlock">''{0}''에서 '상수' 값을 평가하는 중 오류가 발생했습니다. '상수' 표현식에 구문 오류가 있는지 확인하십시오. 크기 표현식의 경우 입력값의 크기만 허용됩니다. </entry>
    <entry key="SizeComputationConstantEvalFailed">'상수' 표현식 실행에 실패했습니다. ''{0}''의 '상수' 지정에 구문 오류가 있는지 확인하십시오.</entry>
    <entry key="SizeComputationConstantEvalFailedGeneric">'상수' 표현식 실행에 실패했습니다. '상수' 지정에 구문 오류 또는 유형 불일치가 있는지 확인하십시오.</entry>
    <entry key="ConstantSizeFcnIncorrectInputs">인수 ''{0}''에 대한 '상수' 값을 평가하는 중 오류가 발생했습니다. size() 표현식은 한 개 또는 두 개의 인수만 받을 수 있습니다.</entry>
    <entry key="ConstantSizeFcnInvalidSymbolName">인수 ''{0}''에 대한 '상수' 값을 평가하는 중 오류가 발생했습니다. size() 표현식의 첫 번째 인수는 입력을 참조해야 합니다.</entry>
    <entry key="ConstantSizeFcnOnlyInputInOutputOrParameter">''{0}''은(는) ''{1}''의 '상수' 값을 지정하는 데 사용할 수 없습니다. 파라미터의 값 또는 입력의 크기 표현식을 지정하십시오. 상수 범위 값은 평가하면 내장된 숫자형 스칼라가 되어야 합니다.</entry>
    <entry key="DataMustBeInConstantSizeFcn">인수 ''{0}''에 대한 '상수' 값을 평가하는 중 오류가 발생했습니다. ''{1}''이(가) size() 표현식에 사용되어야 합니다.</entry>
    <entry key="ConstantSizeFcnInvalidExpression">인수 ''{0}''에 대한 '상수' 값을 평가하는 중 오류가 발생했습니다. size() 표현식의 두 번째 입력은 차원이어야 합니다.</entry>
    <entry key="CFunctionUseCustomCodeFunctionWithImportCustomCodeOff">C Function 블록 ''{0}''이(가) 사용자 지정 코드 함수를 호출합니다. 이 작업을 위해서는 ''{1}''을(를) 활성화해야 합니다.</entry>
    <entry key="ContinuousSampleTimeNotAllowedSymbolTable">연속 샘플 시간에 영속 변수가 있어 이 샘플 시간은 {1} "{0}"에서 지원되지 않습니다. '샘플 시간' 블록 파라미터를 이산 값 또는 보조 스텝에서 고정됨 값으로 설정하십시오.</entry>
    <entry key="CFunctionBlockCodeParsingWarnings">C Function 블록 ''{1}''의 {0}을(를) 구문 분석하는 중 다음 경고 메시지가 생성되었습니다.\n</entry>
    <entry key="CFunctionBlockUnsupportBusOfSymbolicDimsInitCodegen">C Function 블록 ''{0}''의 영속 기호 또는 출력 기호 ''{1}''에 기호 차원을 갖는 요소를 포함하는 버스 유형이 있습니다. 이는 Embedded Real-Time 타깃을 사용하는 코드 생성 시 C Function 블록에서 지원되지 않습니다. 기호 차원을 비활성화하려면 구성 파라미터 대화 상자에서 ''기호 차원 지정 허용''을 검색하고 체크박스 선택을 해제하십시오.</entry>
    <entry key="InCompatiableSimulinkAndCustomCodeTypes"> C Function 블록 ''{2}''에 있는 기호 ''{1}''의 Simulink 데이터형 ''{0}''이(가) 사용자 지정 코드 유형 ''{3}''과(와) 일치하지 않습니다. 사용자 지정 코드 데이터형은 상응하는 Simulink 데이터형과 일치해야 합니다.</entry>
    <entry key="PortVarAddressEscaping">C Function 블록 ''{1}''에서는 구조체형 기호 ''{0}''의 주소를 가져오는 것이 허용되지 않습니다.</entry>
    <entry key="AddressEscapeForTypeContainingND">다차원 배열의 주소를 변수에 할당하는 것은 C Function 블록 ''{0}'' 내에서 지원되지 않습니다.</entry>
    <entry key="CFcnBlkBusWithSLString">C Function 블록 ''{1}''의 기호 ''{0}''에는 Simulink 문자열을 포함하는 버스가 지원되지 않습니다.</entry>
    <entry key="NonExtendedASCIIString">문자열에 지원되지 않는 문자가 포함되어 있습니다. 확장 ASCII 문자(ISO-8859-1)만 지원됩니다.</entry>
    <entry key="ClassTypeNotSupported">C Function 블록 ''{2}''의 기호 테이블에서 기호 ''{1}''에 유효하지 않은 유형 ''{0}''이(가) 지정되었습니다. C Function 블록은 C++ 클래스 유형을 지원하지 않습니다.</entry>
    <entry key="ClassTypeNotFound">C Function 블록 ''{2}''의 기호 테이블에서 기호 ''{1}''에 선언되지 않은 클래스 유형 ''{0}''이(가) 지정되었거나 클래스 유형이 지원되지 않습니다. 구성 파라미터 &gt; 시뮬레이션 타깃 창에 포함된 사용자 지정 코드를 확인하십시오.</entry>
    <entry key="ClassTypeNotInPersistentScope">C Function 블록 ''{2}''의 기호 테이블에서 기호 ''{1}''에 유효하지 않은 클래스 유형 ''{0}''이(가) 지정되었습니다. 영속 기호만 클래스 유형을 가질 수 있습니다.</entry>
    <entry key="AccessingNonPublicClassData">C Function 블록 ''{2}''에서 ''{1}'' 클래스의 필드 ''{0}''에 액세스하는 중 오류가 발생했습니다. 퍼블릭 클래스 멤버만 액세스할 수 있습니다.</entry>
    <entry key="AccessingClassDataOfPrivateType">C Function 블록 ''{2}''에서 ''{1}'' 클래스의 필드 ''{0}''에 액세스하는 중 오류가 발생했습니다. 프라이빗 유형 또는 보호 유형의 클래스 멤버에 액세스할 수 없습니다.</entry>
    <entry key="OpOverloadDisallowed">C Function 블록 ''{1}'' 내에서 오버로드된 연산자 ''{0}''을(를) 호출하는 것은 지원되지 않습니다.</entry>
    <entry key="ExplicitDestructorCallError"> C Function 블록 ''{1}''에서 ''{0}'' 클래스의 소멸자를 명시적으로 호출하는 것은 지원되지 않습니다. </entry>
    <entry key="CFunctionBlockClassPassedByValueOrReturnByRef"> C Function 블록 ''{0}''은(는) 값으로 클래스를 받거나 값 또는 참조로 클래스를 반환하는 사용자 지정 코드 메서드 ''{1}''을(를) 호출합니다. C Function 블록에서는 값으로 클래스 인스턴스를 전달하거나 값 또는 참조로 클래스 인스턴스를 반환하는 것이 지원되지 않습니다.</entry>
    <entry key="CFunctionBlockFcnReturnsPtr2ND"> C Function 블록 ''{0}''이(가) 다차원 배열에 대한 포인터를 반환하는 사용자 지정 코드 함수 ''{1}''을(를) 호출합니다. C Function 블록에서는 다차원 배열에 대한 포인터의 반환이 지원되지 않습니다.</entry>
    <entry key="CFunctionBlockUnsupportedArg"> C Function 블록 ''{0}''이(가) 지원되지 않는 인수를 받는 사용자 지정 코드 메서드 ''{1}''을(를) 호출합니다. </entry>
    <entry key="NoMatchingConstructor">C Function 블록 ''{3}''에서 ''클래스: {1}'' 유형의 기호 ''{0}''에 대해 입력 인수 ''{2}''의 일치하는 퍼블릭 생성자를 찾을 수 없음</entry>
    <entry key="ConstructorResolutionMessage">생성자를 확인하지 못했습니다. 메시지:\n {0}</entry>
    <entry key="AbstractClassError">C Function 블록 ''{2}''에 사용된 추상 클래스 유형 ''{1}''의 기호 ''{0}''을(를) 인스턴스화할 수 없습니다. </entry>
    <entry key="StaticMemberAccessUnsupported">C Function 블록 ''{1}''에서 정적 클래스 데이터 멤버 ''{0}''에 대한 액세스가 유효하지 않습니다. 정적 클래스 데이터 멤버에는 액세스할 수 없습니다.</entry>
    <entry key="CFunctionUnsupportedClassAccess">C Function 블록 ''{1}''에서 액세스된 ''{0}'' 클래스는 지원되지 않습니다.</entry>
    <entry key="TemplateClassSymbolError">C Function 블록 ''{2}''에 사용된 템플릿 파라미터 ''{1}''이(가) 있는 클래스 유형의 기호 ''{0}''을(를) 인스턴스화할 수 없습니다. </entry>
    <entry key="PrivateConstructorError">클래스 유형 ''{2}''에 유효한 퍼블릭 생성자가 없기 때문에 C Function 블록 ''{1}''에 사용된 기호 ''{0}''을(를) 인스턴스화할 수 없습니다.</entry>
    <entry key="PrivateDestructorError"> 클래스 유형 ''{2}''에 유효한 퍼블릭 소멸자가 없기 때문에 C Function 블록 ''{1}''에 사용된 기호 ''{0}''을(를) 제거할 수 없습니다. </entry>
    <entry key="InvalidVariableInConstructorArgs">C Function 블록 ''{2}''의 기호 ''{1}''에 대한 클래스 생성자 인수에 유효하지 않은 변수 ''{0}''이(가) 지정되었습니다. 클래스 생성자 인수는 파라미터 범위 또는 상수 범위를 가져야 합니다.</entry>
    <entry key="FcnCalledInConstructorArgs">C Function 블록 ''{2}''의 기호 ''{1}''에 대한 클래스 생성자 인수에 유효하지 않은 함수 호출 ''{0}''이(가) 지정되었습니다. 생성자 인수는 다른 함수를 호출할 수 없습니다.</entry>
    <entry key="IllegalConstructorArgument">C Function 블록 ''{2}''의 기호 ''{1}''에 대한 클래스 생성자 인수에 유효하지 않은 표현식 ''{0}''이(가) 지정되었습니다.</entry>
    <entry key="CFunctionBlockIncorrectRTWLangForCPP">코드가 C++를 사용하여 구문 분석되므로, C Function 블록 ''{0}''에 지정된 사용자 지정 코드를 사용한 코드 생성 설정이 유효하지 않습니다. 모델 구성 파라미터에서 ''코드 생성 &gt; 언어''를 ''C++''로 설정하십시오. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{1}'');configset.highlightParameter(''{1}'','TargetLang');&lt;/cmd&gt; &lt;txt&gt;코드 생성 언어 설정을 ''C++''로 변경하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="CFunctionBlockIncorrectSimLangForCPP">코드가 C++를 사용하여 구문 분석되므로, C Function 블록 ''{0}''에 지정된 사용자 지정 코드를 사용한 시뮬레이션 설정이 유효하지 않습니다. 모델 구성 파라미터에서 ''시뮬레이션 타깃 &gt; 언어''를 ''C++''로 설정하십시오. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;load_system(''{1}'');configset.highlightParameter(''{1}'','SimTargetLang');&lt;/cmd&gt; &lt;txt&gt;시뮬레이션 타깃 언어 설정을 ''C++''로 변경하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="CFcnLocalVarOfClassType">C Function 블록 ''{1}''에서는 클래스 유형의 지역 변수 ''{0}''이(가) 지원되지 않습니다.</entry>
    <entry key="CopyAssignmentDisallowed">C Function 블록 ''{0}''에서는 클래스 기호에 값을 대입할 수 없습니다.</entry>
    <entry key="NDDataMemberAccessDisallowed">C Function 블록 ''{2}''에서 ''{1}'' 클래스의 필드 ''{0}''에 액세스하는 중 오류가 발생했습니다. 행렬 클래스 멤버에 액세스하는 것은 지원되지 않습니다.</entry>
    <entry key="DisallowPointerToClassArrayDataMemberAccess">C Function 블록 ''{2}''에서 ''{1}'' 클래스의 필드 ''{0}''에 액세스할 수 없습니다. 클래스 배열에 대한 포인터 유형의 데이터 멤버에 액세스하는 것은 지원되지 않습니다.</entry>
    <entry key="DisallowDirectClassArrayDataMemberAccess">C Function 블록 ''{2}''에서 직접 ''{1}'' 클래스의 필드 ''{0}''에 액세스할 수 없습니다. 인덱싱 없이 클래스 배열 유형의 데이터 멤버에 액세스하는 것은 지원되지 않습니다.</entry>
    <entry key="CFunctionBlockGlobalClassTypeUnsupported">C Function 블록 ''{1}''에서는 C++ 클래스 유형의 사용자 지정 코드 전역 변수 {0}에 액세스할 수 없습니다.</entry>
    <entry key="CFunctionBlockInvalidInitialization">C Function 블록 ''{1}''에서 기호 "{0}"을(를) 초기화할 수 없습니다. 기호 테이블의 초기화는 C++ 클래스 유형의 영속 기호에 대해서만 지원됩니다.</entry>
    <entry key="ColMajorMethodConst">''{0}''에 대한 함수 배열 레이아웃 설정이 유효하지 않습니다. 클래스 메서드 및 생성자에 대한 함수 배열 레이아웃 설정은 '행 우선' 또는 '임의'여야 합니다.</entry>
    <entry key="ClassArgumentToColMajorFcn">클래스 객체는 열 우선 함수 ''{0}''(으)로 전달할 수 없습니다.</entry>
    <entry key="MatchingMethodNotFoundInCustomCode">C Function 블록 ''{0}''에서 내부 오류가 발생함: 함수 호출 ''{1}''에 대해 사용자 지정 코드에서 일치하는 오버로드된 함수를 찾지 못했습니다. MathWorks 기술 지원팀에 이 버그를 보고하십시오.</entry>
    <entry key="CFunctionBlockUnsupportedLocalNestedClassType">C Function 블록 ''{1}'' 내에서는 중첩된 클래스 유형 ''{0}''을(를) 사용할 수 없습니다.</entry>
    <entry key="CFunctionBlockSlError">C Function 블록 ''{2}''에서 시뮬레이션 ''{1}'' 코드의 {0, number, integer}번 라인에서 오류가 발생했습니다:\n{3}\n\n''{4}''</entry>
    <entry key="CFunctionBlockSlWarning">C Function 블록 ''{2}''에서 시뮬레이션 ''{1}'' 코드의 {0, number, integer}번 라인에서 경고가 발생했습니다:\n{3}\n\n''{4}''</entry>
    <entry key="OOPUnsupportedClassDataMemberAccess">''{1}'' 클래스의 데이터 멤버 ''{0}''에는 액세스할 수 없습니다. 별도의 프로세스에서 사용자 지정 코드를 시뮬레이션하는 경우 클래스 유형 및 클래스 벡터 유형이 아닌 데이터 멤버에 액세스하는 것은 지원되지 않습니다. </entry>
    <entry key="OOPUnsupportedClassMemberFunctionAccess">
    ''{1}'' 클래스의 멤버 함수 ''{0}''을(를) 호출할 수 없습니다. 별도의 프로세스에서 사용자 지정 코드를 시뮬레이션하는 경우 다음 반환값 유형 및 함수 인수 유형을 갖는 멤버 함수에 액세스하는 것은 지원되지 않습니다: &lt;ul&gt; &lt;li&gt; 반환값 유형: 클래스가 아닌 포인터 및 클래스에 대한 다중 포인터&lt;/li&gt; &lt;li&gt; 함수 인수 유형: void 포인터 유형, 포인터로 구성된 배열, 클래스 유형에 대한 다중 포인터, 복소수형 및 공용체 유형&lt;/li&gt; &lt;/ul&gt;</entry>
    <entry key="CFunctionBlockUINoSelectionForRemove">테이블에서 기호를 제거할 행을 선택하십시오.</entry>
    <entry key="CFunctionBlockDialogText">사용자 지정 C/C++ 알고리즘을 통합하기 위한 코드 입력</entry>
    <entry key="CFunctionBlockDialogStatementDesc"> 실행할 {0}을(를) 입력합니다. </entry>
    <entry key="CFunctionBlockDialogSimTabTitle">시뮬레이션</entry>
    <entry key="CFunctionBlockUseSameCodeAsSimPrompt">시뮬레이션과 동일한 코드 사용</entry>
    <entry key="CFunctionBlockDialogWidgetCodegenCodeChkBoxToolTip">시뮬레이션에서와 동일한 코드 및 사용자 지정 코드 설정을 사용할지 여부를 지정합니다</entry>
    <entry key="CFunctionBlockGenCodeAsIsPrompt">현재 코드 그대로 생성</entry>
    <entry key="CFunctionBlockArrayLayout">배열 레이아웃:</entry>
    <entry key="CFunctionBlockLanguageLevel">언어 지원 수준:</entry>
    <entry key="CFunctionLanguageLevelManaged">C/C++의 서브셋(분석 활성화됨)</entry>
    <entry key="CFunctionLanguageLevelFull">전체(현재 코드 그대로 사용)</entry>
    <entry key="CFunctionBlockDialogWidgetGenCodeAsIsChkBox">현재 코드 그대로 생성(최적화 끄기)</entry>
    <entry key="CFunctionBlockDialogWidgetGenCodeAsIsToolTip">매크로 확장과 같은 구문 분석기 기반의 최적화 없이 현재 코드 그대로 인라인 처리할지 여부를 지정합니다.</entry>
    <entry key="CFunctionBlockDialogCodegenCodeTabTitle">코드 생성</entry>
    <entry key="CFunctionBlockDialogcScriptName">출력</entry>
    <entry key="CFunctionBlockDialogstartScriptName">시작</entry>
    <entry key="CFunctionBlockDialogtermScriptName">종료</entry>
    <entry key="CFunctionBlockDialogAddButtonName">추가</entry>
    <entry key="CFunctionBlockDialogDeleteButtonName">삭제</entry>
    <entry key="CFunctionBlockDialoginitScriptName">상태 초기화</entry>
    <entry key="SimulinkInterfaceDialogOutputCodeDesc">시뮬레이션 중 각 시간 스텝에서 실행할 C 코드를 입력합니다.\n예: "y = classObject.process(u);"\ny, classObject 및 u는 기호 테이블에 정의되어 있습니다.</entry>
    <entry key="SimulinkInterfaceDialogInitCodeDesc">시뮬레이션 시작 시 실행할 C 코드를 입력합니다.\n예: "classObject.initialize(param);"\nclassObject 및 param은 기호 테이블에 정의되어 있습니다.</entry>
    <entry key="SimulinkInterfaceDialogTermCodeDesc">시뮬레이션 종료 시 실행할 C 코드를 입력합니다.\n예: "classObject.cleanup();"\nclassObject는 기호 테이블에 정의되어 있습니다.</entry>
    <entry key="DeterministicFunctionsDlgDescriptionTitle">설명</entry>
    <entry key="DeterministicFunctionsDlgDescription">[추가] 또는 [제거] 버튼을 사용하여 결정적 사용자 지정 코드 함수를 지정합니다.</entry>
    <entry key="DeterministicFunctionsDlgTitle">결정적 사용자 지정 코드 함수 목록</entry>
    <entry key="DeterministicFunctionsDlgSSFcnNameColHeader">함수 이름</entry>
    <entry key="DeterministicFunctionsDlgAddButtonTooltip">결정적 사용자 지정 코드 함수를 추가합니다.</entry>
    <entry key="DeterministicFunctionsDlgDeleteButtonTooltip">결정적 사용자 지정 코드 함수 목록에서 선택한 함수를 제거합니다.</entry>
    <entry key="DeterministicFunctionsInvalidCharacterNames">함수 이름 ''{0}''에 유효하지 않은 문자가 있습니다. 함수 이름은 유효한 C 식별자여야 합니다.</entry>
    <entry key="SymbolTableBlockAPIIncorrectPortIndex"> {4} ''{3}''에서 기호 ''{0}''의 포트 수는 ''{1}''과(와) ''{2}'' 사이의 정수 값이어야 합니다. </entry>
    <entry key="SymbolTableBlockAPIMethodInputIsNotString"> {2} ''{1}''에서 메서드 ''{0}''의 입력은 문자형 배열/string형이어야 합니다. </entry>
    <entry key="SymbolTableBlockAPIMethodUnexpectedInputArgument"> ''{0}'' 메서드에는 입력이 필요하지 않습니다. </entry>
    <entry key="SymbolTableBlockAPIMethodUnexpectedOutputArgument"> ''{0}'' 메서드에는 출력이 필요하지 않습니다. </entry>
    <entry key="SymbolTableBlockAPIMethodLessThanTwoInputOnly"> ''{0}'' 메서드에는 입력으로 최대 한 개의 기호 이름을 사용할 수 있습니다. </entry>
    <entry key="SymbolTableBlockAPIMethodInputNotFound"> {2} ''{1}''에 기호 ''{0}''이(가) 존재하지 않습니다. </entry>
    <entry key="SymbolTableBlockAPIMethodInputNumInvalid"> ''{0}'' 메서드에는 입력으로 한 개의 기호 이름만 필요합니다. </entry>
    <entry key="LockedSymbolTableBlock">{1} ''{0}''을(를) 포함하는 라이브러리가 잠겨 있기 때문에 SymbolSpec 객체를 수정할 수 없습니다. 블록을 변경하려면 라이브러리의 잠금을 해제하십시오.</entry>
    <entry key="LinkedSymbolTableBlock">현재 {1} ''{0}''이(가) 라이브러리에 연결되어 있기 때문에 SymbolSpec 객체를 수정할 수 없습니다. 이 블록을 수정하려면 라이브러리에서 블록을 수정하거나 링크를 끊으십시오.</entry>
    <entry key="ModelIsExecutingSymbolTableBlock">모델이 실행 중일 때에는 {1} ''{0}''의 SymbolSpec 객체를 수정할 수 없습니다.</entry>
    <entry key="DeletedSymbolTableBlock">블록이 삭제되었기 때문에 SymbolSpec 객체를 가져올 수 없습니다.</entry>
    <entry key="CFunctionBlockIndexReadOnly">The Port Number of the 'Persistent' and 'Constant' scopes in the C Function block ''{0}'' are read-only.</entry>
    <entry key="PythonFunctionBlockIndexReadOnly">Python Code 블록 ''{0}''에서 'Persistent' 범위의 포트 번호가 읽기 전용입니다.</entry>
    <entry key="CFunctionBlockAPIArrayLayoutReadOnly">C Function 블록 ''{1}''의 'LanguageLevel'이 'subset'인 경우 블록 파라미터 ''{0}''의 값을 수정할 수 없습니다.</entry>
    <entry key="CFunctionBlockAPILangLevelReadOnly">C Function 블록 ''{1}''의 'CustomCodeSettingsLocation'이 '모델 구성 파라미터'인 경우 블록 파라미터 ''{0}''의 값을 수정할 수 없습니다.</entry>
    <entry key="CFunctionBlockAPISizeReadOnly">The Size of the 'Constant' symbol and the 'Persistent' VoidPointer symbol in the C Function block ''{0}'' are read-only.</entry>
    <entry key="PythonFunctionBlockAPISizeReadOnly">Python Function 블록 ''{0}''에서 '영속' PythonObject 기호의 크기가 읽기 전용입니다.</entry>
    <entry key="CFunctionBlockAPIGenCodeAsIsReadOnly">Cannot modify the value for block parameter ''{0}'' when 'Use same code as Simulation' is off for C Function block ''{1}''.</entry>
    <entry key="CFunctionBlockAPICodegenCodeReadOnly">Cannot modify the value for block parameter ''{0}'' when 'Use same code as Simulation' is on for C Function block ''{1}''.</entry>
    <entry key="MajorityDlgDescriptionTitle">설명</entry>
    <entry key="MajorityDlgDescription">[추가] 또는 [제거] 버튼을 사용하여 사용자 지정 코드 함수에 대한 배열 레이아웃 예외를 지정합니다.</entry>
    <entry key="MajorityDlgTitle">사용자 지정 코드 함수에 대한 배열 레이아웃</entry>
    <entry key="MajorityDlgSSFcnNameColHeader">함수 이름</entry>
    <entry key="MajorityDlgSSSettingColHeader">배열 레이아웃</entry>
    <entry key="MajorityDlgAddButtonTooltip">함수 배열 레이아웃 예외가 있는 사용자 지정 코드 함수를 추가합니다.</entry>
    <entry key="MajorityDlgDeleteButtonTooltip">선택한 함수 배열 레이아웃 설정을 제거합니다.</entry>
    <entry key="FunctionArrayLayoutWrongFormat">
      Invalid data type. Parameter 'CustomCodeFunctionArrayLayout' must be a 1-by-n structure with 'FunctionName' and 'ArrayLayout' fields.
    </entry>
    <entry key="FunctionArrayLayoutEmptyNames">Invalid function names. Function names must be nonempty.</entry>
    <entry key="FunctionArrayLayoutNamesWithWhitespace">Invalid function names {0}. Function names must not contain whitespace characters.</entry>
    <entry key="FunctionArrayLayoutDuplicateNames">Invalid function names {0}. Duplicate function names not supported.</entry>
    <entry key="FunctionArrayLayoutInvalidSetting">
      Invalid function array layout setting. Function array layout setting must be 'Column-major', 'Row-major' or 'Any'.
    </entry>
    <entry key="FunctionMajorityNotSpecifiedInRowMajorCodegen">C Caller block ''{0}'' calls custom code function ''{1}'' that has 'Not specified' as the function array layout. Specify a function array layout for ''{1}'' on Configuration Parameters &gt; Simulation Target pane.</entry>
    <entry key="FunctionArrayLayoutIgnored">사용자 지정 코드 함수 ''{0}''의 입력/출력 인수가 모두 스칼라입니다. 사용자 지정 코드 함수 ''{0}''에 대한 배열 레이아웃 설정이 무시됩니다. 이 경고 메시지를 제거하려면 "구성 파라미터 &gt; 시뮬레이션 타깃 &gt; 함수별 예외..."에서 ''{0}''에 대한 배열 레이아웃 설정을 삭제하십시오.</entry>
    <entry key="FunctionArrayLayoutOverrideForSNDF">행렬 필드를 입력/출력 인수로 갖는 구조체를 포함하는 사용자 지정 코드 함수 ''{0}''은(는) '행 우선' 배열 레이아웃을 가져야 합니다. 사용자 지정 코드 함수 ''{0}''에 대한 ''{1}'' 배열 레이아웃 설정이 무시됩니다. 이 경고 메시지를 제거하려면 "구성 파라미터 &gt; 시뮬레이션 타깃 &gt; 함수별 예외..."에서 ''{0}''에 대해 '행 우선'으로 배열 레이아웃 설정을 지정하십시오.</entry>
    <entry key="FunctionArrayLayoutOverrideForPtrToArr">입력 인수로 행렬에 대한 포인터를 포함하는 사용자 지정 코드 함수 ''{0}''은(는) '행 우선' 배열 레이아웃을 가져야 합니다. 사용자 지정 코드 함수 ''{0}''에 대한 ''{1}'' 배열 레이아웃 설정이 무시됩니다. 이 경고 메시지를 제거하려면 "구성 파라미터 &gt; 시뮬레이션 타깃 &gt; 함수별 예외..."에서 ''{0}''에 대해 '행 우선'으로 배열 레이아웃 설정을 지정하십시오.</entry>
    <entry key="BlockUsedInModelReferenceSimTargetCustomCodeUnchecked">{3} ''{0}''이(가) 참조된 모델에 사용되었습니다. 이 참조된 모델은 ''{1}''이(가) 비활성화되어 있어 액셀러레이터 모드로 시뮬레이션할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt;open_system(''{2}'');configset.highlightParameter(''{2}'','SupportModelReferenceSimTargetCustomCode');&lt;/cmd&gt; &lt;txt&gt;모델 ''{2}''에서 ''{1}''을(를) 활성화하고 모델을 다시 저장할 수 있습니다.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
        
    </entry>
    <entry key="UnrecognizedFileFormat">.slx 파일 형식의 config 세트만 SLXConfigSetAdapter를 통해 읽을 수 있음</entry>
    <entry key="FileNotFound">제공된 위치에서 파일을 찾을 수 없습니다.</entry>
    <entry key="NoWriteForFunctions">config 세트의 함수에 대해서는 쓰기 작업이 허용되지 않습니다.</entry>
    <entry key="SegVOccurredInOOP">ID가 ''{0}''인 별도의 프로세스에서 사용자 지정 코드를 시뮬레이션하는 동안 세그멘테이션 오류가 발생했습니다.</entry>
    <entry key="ErrorCauseSegVInOOP">\n세그멘테이션 오류가 발생했습니다. 이 오류는 프로그램이 자신에 할당된 메모리 외부에서 읽기 또는 쓰기를 시도하거나, 읽기만 가능한 메모리에 쓰기를 시도하는 경우에 발생할 수 있습니다.</entry>
    <entry key="ErrorCauseAbortInOOP">\n중단이 발생했습니다. 이는 프로그램이 중단을 호출하는 경우에 발생할 수 있습니다.</entry>
    <entry key="ErrorCauseIllegalInstructionInOOP">\n부적절한 명령이 감지되었습니다. 이는 프로그램이 가비지 또는 권한이 필요한 명령을 실행하려고 시도하는 경우에 발생할 수 있습니다.</entry>
    <entry key="ErrorCauseArithmeticErrorInOOP">\n치명적인 산술 오류가 발생했습니다. 일반적인 산술 오류에는 0으로 나누기 및 오버플로가 포함됩니다.</entry>
    <entry key="ProcessCrashedInOOP">Process with ID ''{0}'' crashed during simulating custom code in a separate process. {1}</entry>
    <entry key="SegVStackTraceInfo">ID가 ''{0}''인 프로세스가 비정상적으로 종료되었습니다. 비정상 종료 시점의 스택 추적 정보:\n{1}</entry>
    <entry key="ComplexParamNotSupportedInOOP">C Caller 블록 ''{1}''의 파라미터 ''{0}''이(가) 복소수가 됩니다. C Caller 블록에 대한 별도 프로세스(out-of-process) 실행은 실수 파라미터만 지원합니다.</entry>
    <entry key="CustomTypeUnsupportedInOOP">사용자 지정 함수 ''{0}''에 사용자 지정 데이터형을 가진 인수가 포함되어 있습니다. 별도의 프로세스에서 사용자 지정 코드를 시뮬레이션할 때는 사용자 지정 데이터형이 지원되지 않습니다.</entry>
    <entry key="ComplexTypeUnsupportedInOOP">사용자 지정 함수 ''{0}''에 복소수 인수가 포함되어 있습니다. 별도의 프로세스에서 사용자 지정 코드를 시뮬레이션할 때는 복소수 인수가 지원되지 않습니다.</entry>
    <entry key="OOPExeBuildFailure">모델 ''{0}''과(와) 연결된 사용자 지정 코드에 대해 별도의 실행 파일을 생성하는 동안 오류가 발생했습니다.</entry>
    <entry key="FcnNotFoundInCustomCode">''{0}'' is not found in custom code executable ''{1}''.</entry>
    <entry key="LoadLibFailure">라이브러리 ''{0}''을(를) 불러오지 못했습니다.</entry>
    <entry key="MemoryInconsistentBetweenSimulinkAndOOP">ID가 ''{1}''인 프로세스에서 사용자 지정 함수 ''{0}''을(를) 호출할 때 일관되지 않은 데이터가 감지되었습니다. 사용자 지정 코드에서 인덱싱이 범위를 벗어났기 때문일 수 있습니다.</entry>
    <entry key="UnKnownResponseFromSeparateProcess">별도의 프로세스에서 사용자 지정 코드를 시뮬레이션하는 동안 프로세스에서 알 수 없는 응답을 받았습니다.</entry>
    <entry key="LibNotRegisteredWithOOPForModel">모델 ''{0}''과(와) 연결된 사용자 지정 코드 라이브러리가 별도의 프로세스에서 진행되는 사용자 지정 코드 시뮬레이션에 등록되어 있지 않습니다.</entry>
    <entry key="LibNotRegisteredWithOOPForBlock">블록 ''{0}''과(와) 연결된 사용자 지정 코드 라이브러리가 별도의 프로세스에서 진행되는 사용자 지정 코드 시뮬레이션에 등록되어 있지 않습니다.</entry>
    <entry key="LibNotRegisteredWithOOP">ID가 ''{0}''인 사용자 지정 코드 라이브러리가 별도의 프로세스에서 진행되는 사용자 지정 코드 시뮬레이션에 등록되어 있지 않습니다.</entry>
    <entry key="ProcessNotRunning">ID가 ''{0}''인 프로세스가 실행되고 있지 않습니다.</entry>
    <entry key="CrashOccurredInOOP">별도의 프로세스에서 사용자 지정 코드를 시뮬레이션하는 동안 ID가 ''{0}''인 프로세스가 비정상적으로 종료되었습니다.</entry>
    <entry key="IncompatibleEnumTypeInOOP">별도의 프로세스에서 사용자 지정 코드를 시뮬레이션할 때는 열거형 ''{0}''이(가) 지원되지 않습니다. 이 시뮬레이션에서는 모든 열거형이 정밀도 손실 없이 ''int32''로 변환 가능해야 합니다.</entry>
    <entry key="UnsupportedDataTypeError">별도의 프로세스에서 사용자 지정 코드를 시뮬레이션할 때는 데이터형 ''{0}''이(가) 지원되지 않습니다.</entry>
    <entry key="BlockRunningInOOPModeMsg">ID가 ''{1}''인 별도의 프로세스를 사용하여 블록 ''{0}''이(가) 디버그 모드로 실행 중입니다.</entry>
    <entry key="InitTermCodeNotSupportedInOOP">The custom code setting associated with model ''{0}'' contains initialize and/or terminate functions. Out-of-process execution does not support this scenario.</entry>
    <entry key="LibMustBeLoaded">The library ''{0}'' must be loaded to import custom code in model ''{1}''. </entry>
    <entry key="AtLeastOneLibraryMustBeLinked">모델 ''{0}''은(는) 가져온 사용자 지정 코드가 포함된 한 개 이상의 Simulink 라이브러리에 연결되어야 합니다.</entry>
    <entry key="MultipleLibrariesAreLinked">가져온 사용자 지정 코드를 위한 여러 개의 Simulink 라이브러리 ''{1}''에 모델 ''{0}''이(가) 연결되어 있습니다. 이는 허용되지 않습니다.</entry>
    <entry key="EditDisabledProperty">The property ''{0}'' of argument ''{1}'' cannot be edited. </entry>
    <entry key="IncorrectScopeForArgument">''{0}'' is not a valid scope value for argument ''{1}''.</entry>
    <entry key="InvalidFunctionName">''{0}''은(는) 인식할 수 없는 함수입니다. C Caller 블록을 매핑할 수 있는 유효한 함수 이름 목록을 표시하려면 get_param(gcb,''AvailableFunctions'')를 사용하십시오.</entry>
    <entry key="LockedCCaller">The FunctionPortSpecification object cannot be modified because the library containing the C Caller block is locked. Unlock the library to make changes to the block.</entry>
    <entry key="LinkedCCaller">The FunctionPortSpecification object cannot be modified because the C Caller block is currently linked to a library. Modify the block from the library or break the link to modify this block.</entry>
    <entry key="ModelIsExecuting">The FunctionPortSpecification object cannot be modified while the model is executing.</entry>
    <entry key="IndexExceedsDimsLinear">인덱스가 배열 요소 개수를 초과합니다.</entry>
    <entry key="LinkedCCallerFcnName">Function Name cannot be modified because the C Caller block is currently linked to a library. Modify the block from the library or break the link to modify this block.</entry>
    <entry key="NonexistentGlobalArgument">''{0}'' is not a valid global argument.</entry>
    <entry key="AddNonexistentGlobalArgument">''{0}'' is not a valid global argument to add.</entry>
    <entry key="RemoveNonexistentGlobalArgument">''{0}'' is not a valid global argument to remove.</entry>
    <entry key="InvalidNumberOfInputsForAPIMethod"> ''{0}'' 메서드에는 입력으로 하나의 전역 인수 이름이 필요합니다. </entry>
    <entry key="CCallerGlobalIOAPIMethodInvalidInput"> 메서드 ''{0}''의 입력은 문자형 벡터 또는 string형 스칼라여야 합니다. </entry>
    <entry key="AddDuplicateGlobalArgument"> Global argument ''{0}'' already exists. </entry>
    <entry key="GlobalIOParsingError"> Error(s) encountered while performing global variable analysis for model ''{0}''. Fix the errors in your custom code or disable ''{1}'' if global variables are not used as function interface. </entry>
    <entry key="GlobalInputTooltip"> 입력으로 사용되는 전역 변수 </entry>
    <entry key="GlobalOutputTooltip"> 출력으로 사용되는 전역 변수 </entry>
    <entry key="GlobalInputOutputTooltip"> 입력 및 출력으로 사용되는 전역 변수 </entry>
    <entry key="GlobalNonInterfaceTooltip"> 전역 변수는 블록 인터페이스가 아닙니다.</entry>
    <entry key="GlobalVariableUsageWarning"> 전역 변수 {0}이(가) {1}에서 읽혀지고 {2}에 쓰여집니다. 실행 순서가 제대로 정의되지 않은 경우 {0}의 변경 내용으로 인해 다른 블록에서 예상치 않은 결과가 발생할 수 있습니다.</entry>
    <entry key="InvalidOrDeletedObject">Invalid or deleted 'FunctionPortSpecification' object.</entry>
    <entry key="GlobalArgsTotalCountMismatchError">The total number of global arguments for function ''{0}'' is {1} in C Caller block ''{2}'' and {3} in C Caller block ''{4}''. These C Caller blocks that call the same function don't have the same number of global arguments. </entry>
    <entry key="GlobalArgNotFoundError">Global argument ''{0}'' for function ''{1}'' is in C Caller block ''{2}'' but is not in C Caller block ''{3}''. These C Caller blocks that call the same function don't use the same arguments.</entry>
    <entry key="IncompatibleArgument">Passing incompatible type for argument {0, number, integer} of external C function ''{1}'' with coder.ceval.</entry>
    <entry key="IncompatiblePointerArgument">coder.ceval을 통해, 외부 C 함수 ''{1}''의 {0, number, integer}번째 인수에 대해 호환되지 않는 포인터 유형을 전달하고 있습니다.</entry>
    <entry key="MatrixArgumentDifferentElements">coder.ceval을 통해, 외부 C 함수 ''{1}''의 {0, number, integer}번째 인수에 대해 요소 개수가 다른 행렬을 전달하고 있습니다.</entry>
    <entry key="CustomCodeUndefinedCevalFcn">coder.ceval을 통한 외부 C 함수 ''{0}''은(는) 사용자 지정 코드 소스 파일 또는 라이브러리 파일에 정의되어 있지 않으므로 필터링됩니다.</entry>
    <entry key="CppReferenceNotSupportedCeval">coder.ceval은 사용자 지정 코드 인수 또는 반환 값으로 C++ 참조를 지원하지 않습니다. 포인터를 받거나 반환하려면 사용자 지정 코드를 수정하십시오.</entry>
    <entry key="GlobalVarPointerTypeUnsupportedForOOP">사용자 지정 코드의 전역 변수 ''{0}''이(가) 포인터 유형입니다. 별도의 프로세스에서 사용자 지정 코드를 시뮬레이션할 때는 포인터 유형 전역 변수가 지원되지 않습니다.</entry>
    <entry key="GlobalVarUnsupportedTypeForOOP">사용자 지정 코드의 전역 변수 ''{0}''의 유형이 지원되지 않습니다. 별도의 프로세스에서 사용자 지정 코드를 시뮬레이션할 때는 C/C++ 유형인 void 포인터, 포인터로 구성된 배열, 복소수형 및 공용체 유형(union type)이 지원되지 않습니다.</entry>
    <entry key="CustomCodeFcnCallParamTypeUnsupportedForOOP">사용자 지정 함수 ''{0}''에서 인수 ''{1}''의 유형이 지원되지 않습니다. 별도의 프로세스에서 사용자 지정 코드를 시뮬레이션할 때는 C/C++ 유형인 void 포인터 유형, 포인터로 구성된 배열, 복소수형 및 공용체 유형(union type)이 지원되지 않습니다.</entry>
    <entry key="GlobalVarAddressEscapeOOP">별도의 프로세스에서 사용자 지정 코드를 시뮬레이션하는 경우 C Function 블록에서 전역 변수 ''{0}''의 주소를 const가 아닌 포인터에 할당하는 것은 지원되지 않습니다.</entry>
    <entry key="CustomCodeFcnCallUnsupportedForOOP">사용자 지정 코드 함수 ''{0}''을(를) 호출할 수 없습니다. 별도의 프로세스에서 사용자 지정 코드를 시뮬레이션하는 경우 다음 반환값 유형 및 함수 인수 유형을 갖는 함수에 액세스하는 것은 지원되지 않습니다: &lt;ul&gt; &lt;li&gt; 반환값 유형: 포인터 유형, 복소수형, 클래스 유형 및 공용체 유형(union type)&lt;/li&gt; &lt;li&gt; 함수 인수 유형: void 포인터 유형, 포인터로 구성된 배열, 다중 포인터, 클래스 유형, 복소수형 및 공용체 유형&lt;/li&gt; &lt;/ul&gt;</entry>
    <entry key="CustomCodeFcnCallPassingNullptrForOOP">별도의 프로세스에서 사용자 지정 코드를 시뮬레이션할 때는 사용자 지정 함수 ''{0}''에서 인수 ''{1}''에 대한 빈 배열이나 빈 행렬을 전달하는 기능이 지원되지 않습니다.</entry>
    <entry key="CustomCodeVariadicFcnUnsupportedForOOP">별도의 프로세스에서 사용자 지정 코드를 시뮬레이션할 때는 가변 인자 함수 ''{0}''이(가) 지원되지 않습니다.</entry>
    <entry key="CustomCodeDebugExecutionError">별도의 프로세스에서 사용자 지정 코드를 시뮬레이션하는 동안 ''{0}''에서 오류가 발생했습니다.</entry>
    <entry key="CustomCodeDebugExecutionErrorWithDebugger">별도의 프로세스에서 사용자 지정 코드를 시뮬레이션하는 동안 ''{0}''에 오류가 발생했습니다.
        
            &lt;actions exclusiveFixIts="yes"&gt;
                &lt;action type="suggestion" id="launchDebuggerFromDV" retvalue="false"&gt;
                    &lt;cmd&gt;SLCC.OOP.LaunchDebuggerForOOP(''{0}'');&lt;/cmd&gt;
                    &lt;txt&gt;외부 사용자 지정 코드를 디버그하려면 외부 디버거를 실행하십시오.&lt;/txt&gt;
                &lt;/action&gt;
            &lt;/actions&gt;
        
    </entry>
    <entry key="CustomCodeDebugExecutionErrorInInit">모델 ''{0}''에 대한 별도의 프로세스에서 사용자 지정 코드를 시뮬레이션하는 중 초기화 함수에서 오류가 발생했습니다.</entry>
    <entry key="CustomCodeDebugExecutionErrorInTerm">모델 ''{0}''에 대한 별도의 프로세스에서 사용자 지정 코드를 시뮬레이션하는 중 종료 함수에서 오류가 발생했습니다.</entry>
    <entry key="CustomCodeDebugExecutionDebuggerLaunchingStatusTip">외부 디버거를 실행하는 중입니다. 대개 이 과정은 최대 1분이 걸립니다. ''열기'' 버튼을 두 번 이상 클릭하지 마십시오.</entry>
    <entry key="OOPExeDebuggingFailure">모델 ''{0}''에 연결된 사용자 지정 코드를 디버그하는 중 오류가 발생했습니다.</entry>
    <entry key="MatrixElementAddressEscapeToCustomCodeFcnCallForOOP">별도의 프로세스에서 사용자 지정 코드를 시뮬레이션할 때는 행렬의 요소 중 첫 번째가 아닌 요소의 주소를 외부 사용자 지정 함수 ''{0}''에 전달하는 기능이 지원되지 않습니다.</entry>
    <entry key="OOPExeDebuggerLaunchFailure">모델 ''{0}''에 연결된 사용자 지정 코드를 대상으로 디버거를 실행하지 못했습니다. 디버그 정보를 찾을 수 없습니다.</entry>
    <entry key="OOPExeDebuggerLaunchMissingExecutable">''{0}''을(를) 찾지 못했습니다.</entry>
    <entry key="MacroFunctionUnsupportedForOOP">별도의 프로세스에서 사용자 지정 코드를 시뮬레이션할 때는 함수 호출로 확장되는 C 매크로 ''{0}''이(가) 지원되지 않습니다.</entry>
    <entry key="OOPExeLaunchFailure">''{0}''에서 실행 파일을 실행하지 못했습니다.</entry>
    <entry key="OOPExeDebuggerNoCustomCodeWithModel">모델 ''{0}''에 디버그할 사용자 지정 코드가 없습니다.</entry>
    <entry key="OOPExeDebuggerNonExistSrcFile">사용자 지정 함수 ''{1}''에 대한 소스 파일 ''{0}''이(가) 존재하지 않습니다.</entry>
    <entry key="ExternalDebuggerLaunchFailure">Error occurred when launching external debugger.</entry>
    <entry key="ExternalDebuggerUnsupported">외부 코드에 대해 선택된 현재 컴파일러는 ''{0}''이며, 이는 외부 코드 디버그에 대해 지원되지 않습니다. ''mex -setup''을 사용하여 호환되는 컴파일러를 선택하십시오.</entry>
    <entry key="ExternalDebuggerUnsupportedOnMacWithOOP">Mac OS 플랫폼에서는 별도의 프로세스에서 사용자 지정 코드를 디버그할 수 없습니다.</entry>
    <entry key="ExternalDebuggerVSCodeNotSupportedInProcess">별도의 프로세스에서 시뮬레이션하는 경우에만 사용자 지정 코드에 대해 VSCode로 디버그할 수 있습니다.</entry>
    <entry key="ExternalDebuggerVSCodeNotSupportedInProcess_FixIt">모델 또는 라이브러리 ''{0}''에 대해 사용자 지정 코드를 별도의 프로세스에서 시뮬레이션하도록 활성화합니다.</entry>
    <entry key="ExternalDebuggerNoCustomCode">외부 디버거를 실행할 수 없습니다. 모델 ''{0}''에 대해 디버그 가능한 사용자 지정 코드가 없습니다. 모델 ''{0}''이(가) 디버그할 사용자 지정 코드를 지정하고 ''{1}'' 옵션이 모델 구성 파라미터에서 활성화되어 있는지 확인하십시오.</entry>
    <entry key="ExternalDebuggerNotLaunchForOOP">사용자 지정 코드 함수가 ''{0}''과(와) 호환되지 않는 경우 필터링되지 않았을 수 있습니다.</entry>
    <entry key="ExternalDebuggerLaunchedMSVC">외부 디버거가 준비되었습니다. 디버그 세션을 시작하려면 외부 디버거에서 중단점을 설정하고 모델을 시뮬레이션하십시오.</entry>
    <entry key="ExternalDebuggerLaunchedUnix">외부 디버거가 준비되었습니다. 모든 사용자 지정 코드 함수 진입점의 중단점은 외부 디버거에 설정되어 있습니다. 디버그 세션을 시작하려면 모델을 시뮬레이션하십시오. 디버그 세션을 종료하려면 외부 디버거를 닫기 전에 프로세스를 분리하십시오.</entry>
    <entry key="ExternalDebuggerAlreadyLaunched">외부 디버거가 이미 실행되었습니다. 외부 디버거 창이 최소화되었거나 다른 애플리케이션 창 뒤에 있을 수 있습니다.</entry>
    <entry key="ExternalDebuggerStatusBarInfo">사용자 지정 코드 디버그: 호출하는 함수 ''{0}''</entry>
    <entry key="ExternalDebuggerMSVCDLLLimit">현재 Visual Studio 디버거에서 불러올 수 있는 최대 모듈 수는 ''{0}''입니다. 이 제한으로 인해 불러오지 못하는 사용자 지정 코드 모듈 때문에 중단점에서 멈추지 않을 수 있습니다. Simulink 내에서 사용자 지정 코드를 디버그하려면 불러올 수 있는 최대 모듈 수를 4096개 이상으로 설정하는 것이 좋습니다. 관련 문서</entry>
    <entry key="ExternalDebuggerSessionEnd">사용자 지정 코드 디버그 세션이 종료되었습니다. 새 디버그 세션을 시작하려면 Simulink 툴스트립에서 디버거를 실행하십시오.</entry>
    <entry key="ExternalDebuggerLaunchingStatusTip">외부 디버거를 실행하는 중입니다</entry>
    <entry key="ExternalDebuggerLaunchingWarnDlgMsgUnix">\\bf 주의: \\rm 외부 디버거에서 ''kill'' 명령을 실행하지 마십시오. 그럴 경우 알림 없이 MATLAB이 종료됩니다. 디버그 세션을 종료하려면 ''detach'' 명령을 사용하십시오.</entry>
    <entry key="ExternalDebuggerDebuggingWithMinGW">사용자 지정 코드 디버그에 MinGW를 사용하려면 {0} 지원 패키지를 설치하십시오.</entry>
    <entry key="MexDebuggingWithVSCodeError">MEX 디버그에는 VS 코드 디버그가 지원되지 않습니다. </entry>
    <entry key="PrebuildFailed">모델 ''{0}''에 대한 사용자 지정 코드 시뮬레이션 실행 파일을 빌드하지 못했습니다.</entry>
    <entry key="PrebuildInterfaceHeaderUnsuccessful">지정된 사용자 지정 코드에서 인터페이스 헤더를 생성하지 못했습니다.</entry>
    <entry key="InferringHeadersFailed">헤더 정보를 자동으로 채우지 못했습니다.</entry>
    <entry key="InferredHeadersEmpty">헤더 정보가 비어 있습니다. 소스 파일과 include 디렉터리 사양을 확인하거나, 헤더 파일을 명시적으로 지정하십시오.</entry>
    <entry key="EmptyCustomCodeHeader">모델 ''{0}''에 대해 헤더 파일이 지정되지 않았습니다. 구문 분석하기 전에 &lt;sldiag objui="configset" objparam="SimCustomHeaderCode"&gt;헤더 파일&lt;/sldiag&gt;을 지정하십시오.</entry>
    <entry key="EmptyCustomCodeSource">모델 ''{0}''에 대해 소스 파일이 지정되지 않았습니다. 구문 분석하기 전에 &lt;sldiag objui="configset" objparam="SimUserSources"&gt;소스 파일&lt;/sldiag&gt;을 지정하십시오.</entry>
    <entry key="ValidateCustomCode">모델에 대한 사용자 지정 코드의 유효성을 검사하는 중: {0}</entry>
    <entry key="InferHdrConfirmationDlgTitle">헤더 파일 자동 채우기</entry>
    <entry key="InferHdrConfirmationDlgMsg">''{0}''의 이전 값을 자동으로 채워진 헤더로 바꾸시겠습니까?</entry>
    <entry key="InferHdrConfirmationDlgYesLabel">예</entry>
    <entry key="InferHdrConfirmationDlgNoLabel">아니요</entry>
    <entry key="InferHdrUnappliedChanges">헤더 파일을 자동으로 채우려면 모델 ''{0}''의 구성 파라미터 대화 상자에 적용되지 않은 변경 내용이 없어야 합니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion" id="apply" btn="apply"&gt; &lt;cmd&gt;configset.internal.util.applyChanges(''{0}'');&lt;/cmd&gt; &lt;txt&gt;변경 내용 적용&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="ValidateCCUnappliedChanges">사용자 지정 코드의 유효성을 검사하려면 모델 ''{0}''의 구성 파라미터 대화 상자에 적용되지 않은 변경 내용이 없어야 합니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion" id="apply" btn="apply"&gt; &lt;cmd&gt;configset.internal.util.applyChanges(''{0}'');&lt;/cmd&gt; &lt;txt&gt;변경 내용 적용&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="PythonBlockInferenceFail">Python 함수 입력 및 출력 유형 ''{0}''을(를) 유추하지 못했습니다</entry>
    <entry key="UnsupportedPythonTypeToMATLABTypeConversionError">''{1}''에서 ''{0}''(으)로 변환하는 것은 지원되지 않습니다.</entry>
    <entry key="OutputDictionaryKeysDoNotContainBusField">출력 사전 키에서 ''{0}''을(를) 찾을 수 없습니다. 출력 사전 키는 출력 Simulink.Bus 객체의 모든 필드를 포함해야 합니다.</entry>
    <entry key="UnsupportedPythonTypeToSimulinkTypeConversion">Python 함수 출력 유형에서 지정된 Simulink 유형으로 변환할 수 없습니다.</entry>
    <entry key="PythonRuntimeError">Python 오류:\n{0}</entry>
    <entry key="PythonBufferWrongNDims">python에서 반환된 배열 또는 행렬의 차원 수는 Simulink에 지정된 차원 수와 일치해야 합니다.</entry>
    <entry key="PythonBufferWrongType">python에서 반환된 배열 또는 행렬의 유형은 Simulink에 필요한 유형과 일치해야 합니다.</entry>
    <entry key="PythonBufferWrongShape">Python에서 반환된 배열 또는 행렬의 차원은 Simulink에 지정된 차원과 일치해야 합니다.</entry>
    <entry key="PythonBusElementNameNotDictKey">버스 요소 ''{0}''의 이름이 python에서 반환된 딕셔너리에 string형 키 형태로 존재하지 않습니다.</entry>
    <entry key="PythonDictBusMismatch">python에서 반환된 딕셔너리의 요소 개수가 버스의 요소 개수보다 크거나 같아야 합니다</entry>
    <entry key="PythonAccessNonTupleAsTuple">python에서 반환된 객체는 튜플이어야 합니다.</entry>
    <entry key="PythonBoolMarshaling">Python에서 반환된 객체는 부울이어야 합니다.</entry>
    <entry key="PythonIdxOutOfRange">인덱스가 시퀀스 요소 개수를 초과합니다.</entry>
    <entry key="PythonListToNdArray">Python 리스트에서 다차원 Simulink 배열로의 변환은 지원되지 않습니다.</entry>
    <entry key="PythonUnsupportedTypeEnum">열거형은 코드 생성에 기반한 실행 시에 Python과 호환되지 않습니다. 열거형 이름: ''{0}'' </entry>
    <entry key="PythonUnsupportedTypeComplex">복소수형은 코드 생성에 기반한 실행 시에 Python과 호환되지 않습니다.</entry>
    <entry key="PythonFloatToIntMayLosePrecision">Python 부동소수점을 Simulink 정수로 변환하면 정밀도가 떨어질 수 있습니다.</entry>
    <entry key="PythonOOPExecutionMLSB">Code generation based execution of Python is not supported for ''{0}'' when the Python environment in MATLAB is set to Out-of-Process. Change the MATLAB Python environment to In-Process or change the block simulation mode to interpreted execution.</entry>
    <entry key="PythonOOPExecutionPyCode">Code generation based execution of Python is not supported for ''{0}'' when the Python environment in MATLAB is set to Out-of-Process. Change the MATLAB Python environment to In-Process.</entry>
    <entry key="PythonNotConfigured">Python Function 블록을 사용하려면 Python을 사용하도록 MATLAB을 구성해야 합니다.</entry>
    <entry key="PythonCodeBlockInDataflow">Python Code 블록 ''{0}''은(는) Dataflow Subsystem 내에 있을 수 없습니다. </entry>
    <entry key="PythonCodeBlockArrayOfBusInput">Python 코드의 코드 생성에 기반한 실행을 사용하는 블록은 버스 유형을 포함하는 입력 배열을 지원하지 않습니다.</entry>
    <entry key="PythonCodeBlockArrayOfBusOutput">Python 코드의 코드 생성에 기반한 실행을 사용하는 블록은 버스 유형을 포함하는 출력 배열을 지원하지 않습니다.</entry>
    <entry key="PythonStringCppCodegen">Simulink 문자열 데이터형을 사용하는 경우 Python Code 블록 ''{0}''이(가) C++ 코드를 생성할 수 없습니다</entry>
    <entry key="PythonRapidAccelForEach">For Each Subsystem 내에서는 Python Code 블록 ''{0}''을(를) 고속 액셀러레이터를 사용하여 실행할 수 없습니다</entry>
    <entry key="PythonHeaderNotFound">Python.h 헤더 파일을 찾을 수 없습니다. Python 개발 헤더가 MATLAB에 사용된 Python 버전과 함께 설치되었는지 확인하십시오.</entry>
    <entry key="PythonFunctionMaskDialogText">사용자 지정 Python 알고리즘을 통합하기 위한 Python 코드 입력</entry>
    <entry key="PythonFunctionName">Python Code 블록</entry>
    <entry key="MultiWordBusFieldRequiresLongLong">사용자 지정 코드에서 가져온 Bus 객체 ''{0}''에 멀티워드 필드가 포함되어 있습니다. 하드웨어 구현 창에서 'long long 데이터형 지원' 옵션을 활성화하십시오. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="rtw_fixit" retvalue="false"&gt; &lt;cmd&gt;set_param(''{1}'',''ProdLongLongMode'',''on'');&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="ProdLongLongMode"&gt;long long 데이터형 지원&lt;/sldiag&gt;을 ''on''으로 설정하십시오&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
	</entry>
    <entry key="StructWithNDInGRTCodegen">사용자 지정 코드에서 가져온 Bus 객체 ''{0}''에 행렬 유형의 요소가 있으므로 블록 다이어그램 ''{1}''에 대한 코드 생성 타깃이 지원되지 않습니다. 모델이 행렬 필드를 포함하는 Bus 객체를 가져온 경우 ERT 기반 타깃만 지원됩니다.</entry>
    <entry key="NdIndexingMismatchCustomCodeExpectsUnflattenedType">블록 다이어그램 ''{1}''이(가) 사용자 지정 코드의 행렬 필드를 포함하는 버스를 가져왔습니다. 이 경우 요소 차원 유지를 활성화해야 합니다. 블록 다이어그램 ''{1}''에 대해 ''{0}''의 PreserveElementDimensions 속성을 변경하십시오.</entry>
    <entry key="NdIndexingMismatchCustomCodeExpectsFlattenedType">블록 다이어그램 ''{1}''이(가) 사용자 지정 코드의 벡터 필드를 포함하는 버스를 가져왔습니다. 이 경우 버스 요소 차원 유지를 비활성화해야 합니다. 블록 다이어그램 ''{1}''에 대해 ''{0}''의 PreserveElementDimensions 속성을 변경하십시오.</entry>
    <entry key="IncorrectUseOfMajorityFunction">행/열 우선성(majority) 지정 함수 ''{0}''이(가) 잘못 사용되었습니다. 정규화된 사용자 지정 코드 함수 이름이 행/열 우선성 지정 함수에 string형 입력값으로 전달되어야 합니다.</entry>
    <entry key="CannotFindMajorityFunction">행/열 우선성(majority) 지정 함수 ''{1}''에 지정된 사용자 지정 코드 함수 ''{0}''을(를) 찾을 수 없습니다. 다음 함수에 대해 행/열 우선성을 설정할 수 있습니다: ''{2}''.</entry>
    <entry key="NoFcnInCCCanTakeMajority">{0} 사용자 지정 코드 사양의 어떤 함수도 행/열 우선성(majority)을 가질 수 없습니다. 이 경고 메시지를 제거하려면 블록 코드에서 행/열 우선성 지정 함수 호출을 삭제하십시오.</entry>
    <entry key="FunctionArrayLayoutOverrideForSNDF_BlockCC">행렬 필드를 입력/출력 인수로 갖는 구조체를 포함하는 사용자 지정 코드 함수 ''{0}''은(는) '행 우선' 배열 레이아웃을 가져야 합니다. 사용자 지정 코드 함수 ''{0}''에 대한 ''{1}'' 배열 레이아웃 설정이 무시됩니다. 이 경고 메시지를 제거하려면 블록 코드에서 ''slSetRowMajor'' 함수를 사용하여 ''{0}''에 대해 배열 레이아웃 설정을 '행 우선'으로 지정하십시오.</entry>
    <entry key="FunctionArrayLayoutOverrideForPtrToArr_BlockCC">입력 인수로 행렬에 대한 포인터를 포함하는 사용자 지정 코드 함수 ''{0}''은(는) '행 우선' 배열 레이아웃을 가져야 합니다. 사용자 지정 코드 함수 ''{0}''에 대한 ''{1}'' 배열 레이아웃 설정이 무시됩니다. 이 경고 메시지를 제거하려면 블록 코드에서 ''slSetRowMajor'' 함수를 사용하여 ''{0}''에 대해 배열 레이아웃 설정을 '행 우선'으로 지정하십시오.</entry>
    <entry key="CFunctionBlockLibMultiInstanceError">Generating code from the model, simulating the model in rapid accelerator mode, or simulating the model using model reference in accelerator mode is not supported since multiple instances of library block ''{0}'' are used and ''CustomCodeIsMultiInstantiable'' is set to ''off''.</entry>
    <entry key="CFunctionBlockMultiInstanceError">블록 ''{0}'' 및 ''{1}''에 동일한 블록 사용자 지정 코드가 있고 ''CustomCodeIsMultiInstantiable''이 ''off''로 설정되어 있으므로, 모델에서 코드를 생성하거나 고속 액셀러레이터 모드에서 모델을 시뮬레이션하거나 액셀러레이터 모드에서 모델 참조를 사용하여 모델을 시뮬레이션할 수 없습니다.</entry>
    <entry key="ContinuousSampleTimeNotAllowForNonDeterministicBlockCC">C Function 블록 ''{0}''은(는) 비결정적 출력을 가질 수 있는 사용자 지정 코드를 사용하므로 연속 샘플 시간을 지원하지 않습니다. 이 블록에 대한 연속 샘플 시간 지원을 활성화하려면 포함된 사용자 지정 코드 동작이 결정적인 경우 ''CustomCodeIsMultiInstantiable''을 ''on''으로 설정하십시오.</entry>
    <entry key="CFcnHeaderFiles">헤더</entry>
    <entry key="CFcnSourceFiles">소스</entry>
    <entry key="CFcnSearchDirs">검색 디렉터리</entry>
    <entry key="CFcnLibraries">라이브러리</entry>
    <entry key="CFcnDefines">정의</entry>
    <entry key="CFcnCompilerFlags">컴파일러 플래그</entry>
    <entry key="CFcnLinkerFlags">링커 플래그</entry>
    <entry key="CFcnAdvancedSettings">고급</entry>
    <entry key="CFcnMultiInstance">블록 지정 사용자 지정 코드가 다수의 인스턴스를 지원</entry>
    <entry key="CFcnLocalCustomCode">블록 사용자 지정 코드 사용</entry>
    <entry key="CFcnConfigSetCustomCode">구성 파라미터 사용자 지정 코드 사용</entry>
    <entry key="CFcnSimulationCC">시뮬레이션 사용자 지정 코드 </entry>
    <entry key="CFcnCodeGenCC">코드 생성 사용자 지정 코드</entry>
    <entry key="CFcnDependencyPromp">블록 사용자 지정 코드 종속성 지정</entry>
    <entry key="CFunctionBlockLocalCCInDataflow">C Function 블록 ''{0}''은(는) 로컬 사용자 지정 코드를 사용하므로 Dataflow Subsystem 내에 있을 수 없습니다. </entry>
    <entry key="OOPExeBuildFailureBlockCC">블록 ''{0}''과(와) 연결된 사용자 지정 코드를 빌드할 때 오류가 발생했습니다.</entry>
    <entry key="ExportingTargetCodegenToPrvsRelease">C Function 블록 ''{0}''은(는) 새로 추가된 코드 생성 섹션을 사용하여 시뮬레이션과 코드 생성에 각기 다른 코드를 지정합니다. 이 기능은 R2024a에서 추가되었기 때문에 코드 생성 코드는 내보내기 중에 제거됩니다.</entry>
    <entry key="ExportingLocalCCToPrvsRelease">C Function 블록 ''{0}''에서 사용자 지정 코드 설정이 블록에 지정되어 있습니다. 이 기능은 R2024a 이상의 릴리스에 추가되었으며 이전 릴리스와는 호환되지 않습니다. 블록은 내보내기 중에 제거됩니다.</entry>
    <entry key="ExportingFullLangToPrvsRelease">C Function 블록 ''{0}''의 'LanguageLevel'이 'full'로 설정되었습니다. 이 기능은 R2025b 이상의 릴리스에 추가되었으며 이전 릴리스와는 호환되지 않습니다.</entry>
    <entry key="CustomCodeLibBuildErrorCause">{0}</entry>
    <entry key="CFcnCallerDefaultFunctionName">&lt;FunctionName&gt;</entry>
    <entry key="ParsingTypeFailedDetail">{0}</entry>
    <entry key="DeterministicFunctionsDlgSSFcnNameEditHint">functionName</entry>
    <entry key="MajorityDlgSSFcnNameEditHint">functionName</entry>
    <entry key="GlobalIOParsingErrorCause">{0}</entry>
  </message>
</rsccat>
