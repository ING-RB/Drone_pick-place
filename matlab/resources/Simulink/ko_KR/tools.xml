<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ko_KR" product="Simulink" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="ModelingStandards">모델링 표준</entry>
    <entry key="modelassistantObsolete">'modelassistant' is obsolete, please use 'modeladvisor' instead.</entry>
    <entry key="MALicenseCheckoutFail">License checkout failed. Cannot find a license for {0}. </entry>
    <entry key="MAMissVnVLicenseForCustomCheck">사용자 지정 검사를 실행하려면 유효한 Simulink Check 라이선스가 필요합니다.</entry>
    <entry key="MAMissVnVLicenseForMACE">모델 어드바이저 구성 편집기를 시작하려면 유효한 Simulink Check 라이선스가 필요합니다.</entry>
    <entry key="MALoadConfigMissCorrespondCheck">Unable to locate check "{0}" specified by "{1}" when loading configuration {2}. This might be due to a missing sl_customization.m file or toolboxes that are not installed.</entry>
    <entry key="MAMissCorrespondCheck">검사 {0}을(를) 찾을 수 없습니다. sl_customization.m 파일이 누락되었거나 툴박스가 설치되지 않았기 때문일 수 있습니다.</entry>
    <entry key="MASlcustomizeInsideMlroot">Do not place a sl_customization.m ({0}) file that customizes the Model Advisor in your root MATLAB folder, or any of its sub-folders, with the exception of the matlabroot/work folder.</entry>
    <entry key="MACENoDuplicateName">"{0}"이(가) 이미 존재합니다. 동일한 폴더 내 항목은 이름이 서로 달라야 합니다.</entry>
    <entry key="MAErrorChangeWorkConfiguration">The Model Advisor is currently open using the following configuration: {0}. To use a new configuration, in the Model Advisor select File &gt; Load configuration.</entry>
    <entry key="MACENotRenameFolder">이 폴더의 이름을 바꿀 수 없습니다.</entry>
    <entry key="MACEEmptyDisplayName">이름 필드가 비어 있습니다. 이름을 입력하십시오.</entry>
    <entry key="MAUnableStartMAWhenMACEOpen">모델 어드바이저 구성 편집기가 열려 있습니다. 모델 어드바이저를 시작하려면 먼저 구성 편집기를 닫으십시오.</entry>
    <entry key="MACEReservedName">"{0}"은(는) 예약된 이름이므로 폴더 이름으로 지정할 수 없습니다. 이 폴더에 다른 이름을 선택하십시오.</entry>
    <entry key="MAFactoryGrpUnderGrp">ModelAdvisor.FactoryGroup object {0} can be only placed under By Task group.</entry>
    <entry key="MAUnableLocateRestorePointName">Unable to locate specified restore point: {0}.</entry>
    <entry key="MASystemRenamed">시스템의 이름이 {0}에서 {1}(으)로 변경되었습니다. {2}을(를) 검사하려면 모델을 다시 불러와야 합니다.</entry>
    <entry key="FPASystemRenamed">시스템의 이름이 {0}에서 {1}(으)로 변경되었습니다. {2}을(를) 검사하려면 모델을 다시 불러와야 합니다.</entry>
    <entry key="MACBTitle">모델 어드바이저 검사 브라우저</entry>
    <entry key="MADisplayName">표시 이름</entry>
    <entry key="MACheckTitle">검사 제목</entry>
    <entry key="MACheckID">검사 ID</entry>
    <entry key="MAToolTip">툴팁</entry>
    <entry key="MAProductAssociation">제품 연결</entry>
    <entry key="MATools">툴</entry>
    <entry key="MANew">새로 만들기</entry>
    <entry key="MAUndo">실행 취소</entry>
    <entry key="MARedo">다시 실행</entry>
    <entry key="MAOpen">열기</entry>
    <entry key="MACopy">복사</entry>
    <entry key="MAPaste">붙여넣기</entry>
    <entry key="MACut">잘라내기</entry>
    <entry key="MAMoveup">위로 이동</entry>
    <entry key="MAMovedown">아래로 이동</entry>
    <entry key="MANewfolder">새 폴더</entry>
    <entry key="MAYes">예</entry>
    <entry key="MAInstructions">지침</entry>
    <entry key="MANo">아니요</entry>
    <entry key="MAEnable">사용</entry>
    <entry key="MADisable">사용 안 함</entry>
    <entry key="MAWorkflow">워크플로</entry>
    <entry key="MACreate">만들기</entry>
    <entry key="MAConfigure">구성</entry>
    <entry key="MACheck">검사</entry>
    <entry key="MAManage">관리</entry>
    <entry key="MAFind">찾기</entry>
    <entry key="MANameandDescription">이름 및 설명</entry>
    <entry key="MASearchNameDescription">이름 및 설명 검색</entry>
    <entry key="MAFindNext">다음 찾기</entry>
    <entry key="MAFindPrevious">이전 찾기</entry>
    <entry key="MACloseToolbar">도구 모음 닫기</entry>
    <entry key="MAPhraseNotFound">찾을 수 없음</entry>
    <entry key="MANumberOccurrences">{0,number,integer}/{1,number,integer}</entry>
    <entry key="MAPhraseFoundInCheckName">검사 이름에서 검색됨.</entry>
    <entry key="MAPhraseFoundInFolderName">폴더 이름에서 검색됨.</entry>
    <entry key="MAPhraseFoundInDescription">분석 설명에서 검색됨.</entry>
    <entry key="MASelectMatFile">MAT 파일 선택</entry>
    <entry key="MASelectMATLABFile">MATLAB 파일 선택</entry>
    <entry key="MACETitle">모델 어드바이저 구성 편집기</entry>
    <entry key="MACETreeTitle">현재 구성: {0}</entry>
    <entry key="MACERootMsg0">모델 어드바이저 구성 편집기를 사용하면 모델 어드바이저 구성을 빠르게 사용자 지정하고 배포할 수 있습니다. 작업은 일반적으로 다음과 같이 진행합니다.</entry>
    <entry key="MACERootMsg1">사용자 지정 검사를 작성합니다.</entry>
    <entry key="MACERootMsg2">검사를 구성하고 사용자 지정 구성을 생성합니다.</entry>
    <entry key="MACERootMsg3">사용자 지정 구성을 배포합니다.</entry>
    <entry key="MACERootMsg4">모델이 모델링 지침을 준수하는지 확인합니다.</entry>
    <entry key="MARootMsg0">모델이 모델링 지침을 준수하는지 확인합니다.</entry>
    <entry key="MACELibRootNodeMsgLine1">검사 브라우저에서 구성 편집기로 검사를 끌어서 놓습니다.</entry>
    <entry key="MACENewMsg">새 편집 세션 시작</entry>
    <entry key="MACELoadMsg">구성 불러오기</entry>
    <entry key="MACEDeleteMsg">선택한 검사나 폴더 삭제</entry>
    <entry key="MACEEnableMsg">선택한 검사나 폴더 활성화</entry>
    <entry key="MACEDisableMsg">선택한 검사나 폴더 비활성화</entry>
    <entry key="MACESaveMsg">현재 구성 저장</entry>
    <entry key="MACECopyMsg">선택한 검사나 폴더 복사</entry>
    <entry key="MACEPasteMsg">현재 폴더에 붙여 넣기</entry>
    <entry key="MACECutMsg">선택한 검사나 폴더 잘라내기</entry>
    <entry key="MACEMoveUpMsg">선택한 검사나 폴더를 위로 이동</entry>
    <entry key="MACEMoveDownMsg">선택한 검사나 폴더를 아래로 이동</entry>
    <entry key="MACEFolderNewMsg">현재 폴더에 새 폴더 만들기</entry>
    <entry key="MACECheckBrowserMsg">검사 브라우저 실행</entry>
    <entry key="MALoadedConfigurationFromDisk">{0}에서 구성을 불러옴</entry>
    <entry key="MALoadConfiguration">구성 불러오기...</entry>
    <entry key="MAOpenConfigurationEditor">구성 편집기 열기</entry>
    <entry key="MASetDefaultConfiguration">현재 구성을 디폴트 값으로 설정</entry>
    <entry key="MARestoreDefaultConfiguration">디폴트 구성 복원</entry>
    <entry key="MALoadingConfiguration">구성 {0}을(를) 불러오는 중...</entry>
    <entry key="MASavingConfiguration">구성 {0}을(를) 저장하는 중...</entry>
    <entry key="MAUnableLoadPrefConfiguration">Unable to load configuration {0}.</entry>
    <entry key="MACEUnableSaveEmptyConfig">비어 있는 구성을 저장할 수 없습니다.</entry>
    <entry key="MAWarnLoadConfigUI">새 구성을 불러오면 이전의 모델 어드바이저 결과와 리포트가 제거됩니다.</entry>
    <entry key="MAWarnLoadConfigUIWhenDirty">현재 구성에 저장되지 않은 변경 사항이 있습니다. 새 구성을 열면 현재 구성을 덮어쓰게 됩니다.</entry>
    <entry key="MASetDefaultConfig">{0}이(가) 디폴트 구성으로 설정되었습니다.</entry>
    <entry key="MAResetDefaultConfig">디폴트 구성이 재설정되었습니다. </entry>
    <entry key="MAWarnResetDefaultConfig">디폴트 구성을 복원하고 모델 어드바이저를 재시작하시겠습니까? 그러면 기존 리포트가 제거됩니다.</entry>
    <entry key="MAInvalidConfigFile">{0}은(는) 유효한 구성 파일이 아닙니다.</entry>
    <entry key="MADouWantSaveConfigChange">현재 구성의 변경 사항을 저장하시겠습니까?</entry>
    <entry key="MAGetConfigObjInvalidSource">The input value is invalid. Valid values are either ''ConfigUICellArray'' or ''CheckLibrary''.</entry>
    <entry key="MAGetConfigObjArrayNotPopulated">ConfigUICellArray is empty. You must populate ConfigUICellArray before calling {0}.</entry>
    <entry key="MARptName">리포트 이름</entry>
    <entry key="SLVersion">Simulink 버전</entry>
    <entry key="MdlVersion">모델 버전</entry>
    <entry key="MASystem">시스템</entry>
    <entry key="MACurrentrun">현재 실행</entry>
    <entry key="MARunSummary">실행 요약</entry>
    <entry key="MASystemSelector">시스템 선택기</entry>
    <entry key="MAMdlNewerThanRpt">{0} 모델이 모델 어드바이저 리포트보다 최신입니다. 최신 리포트를 생성하려면 업데이트된 모델에서 모델 어드바이저 검사를 다시 실행하십시오. </entry>
    <entry key="MAExplorerAdviceMsg"> 모델 어드바이저는 모델을 분석하여 시뮬레이션 및 코드 생성에 Simulink를 최대한 효과적으로 활용할 수 있도록 합니다. 개별 검사를 선택하고 세부 정보가 포함된 리포트를 생성할 수 있습니다. 이는 설계의 초기 단계에 특히 유용합니다. </entry>
    <entry key="MAExplorerStartMsg"> 모델 어드바이저 시작... </entry>
    <entry key="MASystemHierarchy">시스템 계층 구조</entry>
    <entry key="MASystemSelectorDescription">시작할 시스템을 선택합니다.</entry>
    <entry key="MASelectSystemDialogTitle">계층 구조에서 시스템 선택:</entry>
    <entry key="MACurrentSystem">현재 시스템</entry>
    <entry key="MACurrentSystemAndBelow">현재 시스템 및 그 아래 시스템</entry>
    <entry key="MAFor">For</entry>
    <entry key="MAShow">표시</entry>
    <entry key="MASelectSubsystem">서브시스템 선택...</entry>
    <entry key="MAOk">확인</entry>
    <entry key="MAName">이름</entry>
    <entry key="MALoad">불러오기</entry>
    <entry key="MASave">저장</entry>
    <entry key="MASaveAs">다른 이름으로 저장...</entry>
    <entry key="MADelete">삭제</entry>
    <entry key="MAInvalidType">The specified type {0} is invalid.</entry>
    <entry key="MAMASaveRestorepointDialogTitle">모델 어드바이저: 모델 및 데이터 복원 지점 저장</entry>
    <entry key="MAMALoadRestorepointDialogTitle">모델 어드바이저: 모델 및 데이터 복원 지점 불러오기</entry>
    <entry key="MASaveRestorepointInstruct">복원 지점에 대한 이름 및 설명(선택 사항)을 입력합니다.</entry>
    <entry key="MALoadRestorepointInstruct">불러올 복원 지점을 선택합니다.</entry>
    <entry key="MANoRestorepointSaved">저장된 복원 지점이 없습니다.</entry>
    <entry key="MALoadRestorePoint">복원 지점 불러오기...</entry>
    <entry key="MASaveRestorePoint">복원 지점 저장</entry>
    <entry key="MASaveAsRestorePoint">다른 이름으로 복원 지점 저장...</entry>
    <entry key="MASavingRestorePoint">복원 지점 {0}을(를) 저장하는 중...</entry>
    <entry key="MAWarnLoadRestorePoint">복원 지점 {0}을(를) 불러오면 현재 모델과 작업 공간을 덮어쓰게 됩니다.</entry>
    <entry key="MAWarnOverwriteRestorePoint">복원 지점 {0}이(가) 이미 존재합니다. 바꾸시겠습니까?</entry>
    <entry key="MAPass">통과</entry>
    <entry key="MAFail">실패</entry>
    <entry key="MAWarning">경고</entry>
    <entry key="MACancel">취소</entry>
    <entry key="MATotal">총계</entry>
    <entry key="MAWhatsThis">설명</entry>
    <entry key="MAAboutSimulink">Simulink 정보</entry>
    <entry key="MAUnsupportDataType">지원되지 않는 데이터형입니다.</entry>
    <entry key="MAUnknownEventReceived">Unknown event received.</entry>
    <entry key="MASpecifySystemName">Specify the name of system.</entry>
    <entry key="MAInvalidBtnClick">Unexpected button clicked. Please re-start the tool.</entry>
    <entry key="MAUnsupportedInputParamType">Unsupported input parameters type.</entry>
    <entry key="MAUnrecognizedSolver">인식할 수 없는 솔버: {0}</entry>
    <entry key="MAInvalidNumArgs">인수의 개수가 올바르지 않습니다.</entry>
    <entry key="MAUnexpectedAction">Unexpected action</entry>
    <entry key="MAUnableLocateMAObj">Can not locate model advisor object for {0}.</entry>
    <entry key="MAUnknownMethod">Unknown method: {0} specified.</entry>
    <entry key="MAUnknownAction">알 수 없는 동작임</entry>
    <entry key="MAReportNotExist">리포트가 존재하지 않습니다. 새 리포트를 생성하십시오.</entry>
    <entry key="MATriggerUpdateDiagram">다이어그램 업데이트를 트리거함</entry>
    <entry key="MAAbnormalExit">비정상적인 종료:</entry>
    <entry key="MAInvalidParam">Invalid parameter specified. Parameter must be {0}.</entry>
    <entry key="MAIncorrectAPIUsage">Incorrect usage of {0} method.</entry>
    <entry key="MADuplicatedArgName">{0} 이름은 고유해야 합니다.</entry>
    <entry key="MANoGroupAllowedUnderProcedure">No ModelAdvisor.Group object is allowed inside ModelAdvisor.Procedure object.</entry>
    <entry key="MAUnableLocateActiveSys">Unable to locate Model Advisor active system. Please restart Model Advisor tool.</entry>
    <entry key="MANoItemToDispaly">표시할 항목이 없습니다.</entry>
    <entry key="MACanNotPublishTaskNode">It''s not allowed to publish a ModelAdvisor.Task object.</entry>
    <entry key="MADupProcessCallback">More than one Model Advisor process callback function found. Only the one with the highest precedence is used.</entry>
    <entry key="MAErrorMACallbackFunc">Error occurred with Model Advisor callback function: {0}.</entry>
    <entry key="MAPropertyNolongerSupport">속성 {0}은(는) 더 이상 지원되지 않습니다.</entry>
    <entry key="MAMissEntriesForEnum">Input parameter defined inside {0} misses entries for type enum. </entry>
    <entry key="MAMissProductNameWhenPublishObj">A valid product name is required to publish {0}.</entry>
    <entry key="MACheckIDDuplicate">검사 ID {0}이(가) 중복되었습니다.</entry>
    <entry key="MACheckTitleDuplicate">검사 제목 {0}이(가) 중복되었습니다.</entry>
    <entry key="MATaskIDDuplicate">태스크 어드바이저 ID {0}이(가) 중복되었습니다.</entry>
    <entry key="MAUnableFindCheckSpecified">Unable to find the Model Advisor check {0} specified by {1}. Incorrect spelling or a missing required license might be the cause.</entry>
    <entry key="MAMultipleParentFound">{0} has more than one parent nodes.</entry>
    <entry key="MARun">실행</entry>
    <entry key="MAValueisReserved">{0} is reserved.</entry>
    <entry key="MARunToFailure">모두 실행</entry>
    <entry key="MARunAll">모두 실행</entry>
    <entry key="MAContinue">계속</entry>
    <entry key="MAInProgress">{0}이(가) 진행 중입니다.</entry>
    <entry key="MAGroupLegendNote">그룹 폴더 - 임의 순서로 실행</entry>
    <entry key="MAProcedureLegendNote">절차 폴더 - 순차적으로 실행</entry>
    <entry key="MANothingtoContinue">Nothing to continue from.</entry>
    <entry key="MAModelNotRdyForGenReport">모델이 리포트를 생성할 준비가 되지 않았습니다.</entry>
    <entry key="MAMissLicense">필요한 라이선스 {1}이(가) 누락되었기 때문에 태스크 {0}을(를) 불러올 수 없습니다.</entry>
    <entry key="MANotAllowAddObject">It''s not allowed to add {0} into {1} object.</entry>
    <entry key="MAOneCheckNotSyncRpt">타임스탬프가 {0}과(와) 다른 항목이 1개 있음</entry>
    <entry key="MAMoreCheckNotSyncRpt">타임스탬프가 {1}과(와) 다른 항목이 {0}개 있음</entry>
    <entry key="MACurrent">현재</entry>
    <entry key="MAReset">재설정</entry>
    <entry key="PassedMsg">통과</entry>
    <entry key="FailedMsg">실패</entry>
    <entry key="WarningMsg">경고</entry>
    <entry key="RecAction">권장 조치</entry>
    <entry key="LinkToBlocks">다음 링크를 사용하여 블록 또는 대화 상자로 이동:</entry>
    <entry key="SeeAlso">참고 항목</entry>
    <entry key="FormatTemplateConstructorError">FormatTemplate constructor requires one of the following inputs: ''ListTemplate'' or ''TableTemplate''</entry>
    <entry key="NoColumnTitles">Column titles must be set before adding rows.</entry>
    <entry key="RowColumnMismatch">The number of columns in the row does not match the number of columns in the table. Number of columns in table: {0}</entry>
    <entry key="RefLinksCells">Input to setRefLink must be a cell array of cell arrays.</entry>
    <entry key="RefLinksMatlabKeyword">The first input argument to setRefLink must be the keyword ''matlab'' when the length of the cell is 4.</entry>
    <entry key="RefLinksCellLength">The length of the input cell of setRefLink is incorrect.</entry>
    <entry key="setCheckTextInputLength">Input to setCheckText must be a character vector.</entry>
    <entry key="setCheckTextInput">setCheckText에 전달된 인수 개수가 올바르지 않습니다.</entry>
    <entry key="ColTitlesListTemplate">Column title cannot be set for a ListTemplate object.</entry>
    <entry key="setColTitlesInputString">Input to setColTitles must be a cell array of character vectors.</entry>
    <entry key="setColTitlesInput">setColTitles에 전달된 인수 개수가 올바르지 않습니다.</entry>
    <entry key="setFormatTypeInput">setFormatType에 전달된 입력 인수 개수가 올바르지 않습니다.</entry>
    <entry key="setInformationInputString">Input to setInformation must be a character vector.</entry>
    <entry key="setInformationInput">setInformation에 전달된 인수 개수가 올바르지 않음</entry>
    <entry key="ListObjTableTemplate">List objects cannot be set for a TableTemplate object.</entry>
    <entry key="setListObjInput">setListObj에 전달된 인수 개수가 올바르지 않음</entry>
    <entry key="setRecActionInputString">Input to setRecAction must be a character vector or a cell array of character vectors.</entry>
    <entry key="setRecActionInput">setRecAction에 전달된 인수 개수가 올바르지 않음</entry>
    <entry key="setRefLinkInput">setRefLink에 전달된 인수 개수가 올바르지 않음</entry>
    <entry key="setSubBarInputLength">Input to setSubBar must be a Boolean.</entry>
    <entry key="setSubBarInput">setSubBar에 전달된 인수 개수가 올바르지 않음</entry>
    <entry key="setSubResultStatusInputLength">Input to setSubResultStatus must be a character vector.</entry>
    <entry key="setSubResultStatusInput">setSubResultStatus에 전달된 인수 개수가 올바르지 않음</entry>
    <entry key="setSubResultStatusTextInputLength">Input to setSubResultStatusText must be a character vector.</entry>
    <entry key="setSubResultStatusTextInput">setSubResultStatusText에 전달된 인수 개수가 올바르지 않음</entry>
    <entry key="setSubTitleInputLength">Input to setSubTitle must be a character vector.</entry>
    <entry key="setSubTitleInput">setSubTitle에 전달된 인수 개수가 올바르지 않음</entry>
    <entry key="TableInfoListTemplate">Cannot add table data for a ListTemplate object.</entry>
    <entry key="setTableInfoInput1">Column titles for the table must be set before adding data to the table.</entry>
    <entry key="setTableInfoInput2">Size of input to setTableInfo must match the number of columns. Number of columns: {0}</entry>
    <entry key="setTableInfoInput3">Input to setTableInfo must be a cell or an array of cells.</entry>
    <entry key="setTableInfoInput4">setTableInfo에 전달된 인수 개수가 올바르지 않음</entry>
    <entry key="setTableTitleInputLength">Input to setTableTitle must be a character vector.</entry>
    <entry key="setTableTitleInput">setTableTitle에 전달된 인수 개수가 올바르지 않음</entry>
    <entry key="TableTitleListTemplate">Cannot set table title for a ListTemplate object.</entry>
    <entry key="GetMdlRefVariantInfoWrongBlockType">The first argument of ''Simulink.{0}'' must be the handle of a Simulink Model block.</entry>
    <entry key="GetOutportInfoWrongBlockType">The first argument of ''Simulink.{0}'' must be the handle of a Simulink Outport block.</entry>
    <entry key="GetMdlRefVariantInfoNonPositiveVariantIndex">''Simulink.{0}''의 두 번째 인수는 Variant의 양수(1부터 시작) 인덱스여야 합니다.</entry>
    <entry key="GetMdlRefVariantInfoTooLargeVariantIndex">블록 ''{0}''에는 Variant가 {1,number,integer}개만 있기 때문에 ''Simulink.{2}''의 두 번째 인수는 1에서 {3,number,integer} 사이여야 합니다.</entry>
    <entry key="FPCAHelp">고정소수점 변환 태스크 도움말</entry>
    <entry key="FPCARootMsg1">고정소수점 어드바이저를 사용하면 시스템 또는 서브시스템을 부동소수점 데이터형에서 고정소수점 데이터형으로 손쉽게 변환할 수 있습니다.</entry>
    <entry key="FPCAContainerMsg1">고정소수점 어드바이저를 사용하면 부동소수점 모델 또는 서브시스템을 고정소수점 표현으로 손쉽게 변환할 수 있습니다.</entry>
    <entry key="FPCAContainerMsg2">다음 태스크를 수행합니다.</entry>
    <entry key="FPCAContainerMsg3">고정소수점 어드바이저는 태스크의 결과에 대한 피드백을 제공합니다. 태스크가 실패하면 고정소수점 어드바이저가 태스크를 완료하기 위해 모델을 수정하는 방법에 대한 정보를 제공합니다. 자세한 내용을 보려면 [도움말]을 클릭하십시오.</entry>
    <entry key="FPCAContainerMsg4">모델을 변환할 준비를 합니다.</entry>
    <entry key="FPCAContainerMsg5">모델 전체에 적용되는 구성 옵션을 평가합니다.</entry>
    <entry key="FPCAContainerMsg6">부동소수점 기준선 데이터 세트를 만듭니다.</entry>
    <entry key="FPCAContainerMsg7">데이터형 지정 및 스케일링을 준비합니다. </entry>
    <entry key="FPCAContainerMsg8">블록 관련 구성을 평가합니다.</entry>
    <entry key="FPCAContainerMsg9">설계 최솟값 및 최댓값 정보를 모델에 추가합니다.</entry>
    <entry key="FPCAContainerMsg10">고정소수점 툴로 돌아가서 데이터형 지정 및 스케일링을 수행합니다.</entry>
    <entry key="FPCAContainerMsg15">다음의 용도를 위해 실행할 수 있습니다.</entry>
    <entry key="FPCAContainerMsg16">용도 1: 현재 데이터형에 대한 요약을 봅니다.</entry>
    <entry key="FPCAContainerMsg17">용도 2: 시뮬레이션 수치 오차에 대한 요약을 봅니다.</entry>
    <entry key="FPCAContainerMsg18">용도 3: 현재 시뮬레이션 데이터와 참조 데이터 사이의 차이점에 대한 요약을 봅니다.</entry>
    <entry key="FPCAContainerMsg19">태스크에 대한 도움말을 보려면</entry>
    <entry key="FPCAContainerMsg20">태스크를 마우스 오른쪽 버튼으로 클릭하십시오.</entry>
    <entry key="FPCAContainerMsg21">팝업 메뉴에서 "설명"을 선택합니다.</entry>
    <entry key="MAUnsupportedObject">Unsupported object specified. Item must be {0} objects.</entry>
    <entry key="MAUnsupportedItem">지원되지 않는 항목이 addItem 메서드를 사용하여 지정되었습니다. 항목은 ModelAdvisor.Element 객체이거나 문자형 벡터여야 합니다.</entry>
    <entry key="MAContentMustBeString">객체에 지정된 내용이 문자형 벡터가 아닙니다. 내용에는 문자형 벡터만 포함시키십시오.</entry>
    <entry key="MAInvalidaTableConstructor">잘못 사용되었습니다. 테이블을 초기화하려면 Table(rowSize, columnSize)를 사용하십시오.</entry>
    <entry key="MAInvalidaImageSourceMustBeString">이미지에 지정된 소스가 문자형 벡터가 아닙니다. 이미지 소스에는 문자형 벡터만 포함시키십시오.</entry>
    <entry key="MATableBorderNeedInteger">테이블 테두리 크기에 지정된 값이 정수가 아닙니다. 음수가 아닌 정수 값을 지정하십시오.</entry>
    <entry key="MAInvalidDataType">지정된 데이터형이 유효하지 않습니다. 데이터형은 ModelAdvisor.Element 객체이거나 문자형 벡터일 수 있습니다.</entry>
    <entry key="MAParamExceedTableSize">지정된 행 또는 열 크기가 테이블 크기를 초과합니다. 지정된 테이블 크기 범위 내에 있는 값으로 크기를 지정하십시오.</entry>
    <entry key="MAParamTableSizeNotMatch">입력 셀형 배열의 크기가 테이블 크기와 일치하지 않습니다. 테이블({0})과 크기가 동일한 셀형 배열을 지정하십시오.</entry>
    <entry key="MAInvalidAlignType">지정된 정렬이 유효하지 않습니다. 정렬은 왼쪽, 오른쪽 또는 가운데일 수 있습니다.</entry>
    <entry key="MAInvalidSLCallbackStyle">Invalid callback style. Use callback style hilite_system or open_system.</entry>
    <entry key="MAModelAdvisor">모델 어드바이저</entry>
    <entry key="MAErrorChangeWorkSystem">Inadvertently tried to change Model Advisor work system before ending previous session. To change the work system, use Simulink.ModelAdvisor.getModelAdvisor(system, ''new'').</entry>
    <entry key="MAAnalysis">분석</entry>
    <entry key="MADescription">설명</entry>
    <entry key="MAInputParameters">입력 파라미터</entry>
    <entry key="MAResult">결과</entry>
    <entry key="MAExit">종료</entry>
    <entry key="MAFile">파일</entry>
    <entry key="MAEdit">편집</entry>
    <entry key="MANotApplicable">해당 없음</entry>
    <entry key="MASourceTab">소스 탭</entry>
    <entry key="MAView">보기</entry>
    <entry key="MAHelp">도움말</entry>
    <entry key="MAModelAdvisorHelp">모델 어드바이저 도움말</entry>
    <entry key="MAReport">리포트</entry>
    <entry key="MALastReport">마지막 리포트</entry>
    <entry key="MAFromNode">노드:</entry>
    <entry key="MASummary">요약</entry>
    <entry key="MATaskHierarchy">작업 계층 구조</entry>
    <entry key="MADateTime">날짜/시간</entry>
    <entry key="MADisplay">표시</entry>
    <entry key="MAAction">조치</entry>
    <entry key="MASpreadsheet">스프레드시트</entry>
    <entry key="MAExploreSelection">선택 항목 탐색...</entry>
    <entry key="MAFormat">형식</entry>
    <entry key="MAModelAdvisorTaskManager">모델 어드바이저 태스크 관리자</entry>
    <entry key="MAExploreResult">결과 탐색</entry>
    <entry key="MARootNodeMsgLine1">폴더 내 검사를 보려면 폴더를 여십시오.</entry>
    <entry key="MARootNodeMsgLine2">검사를 활성화하거나 비활성화하려면 검사 이름 옆에 있는 체크박스를 선택하거나 선택을 해제하십시오.</entry>
    <entry key="MARootNodeMsgLine3">폴더 내 모든 검사를 활성화하거나 비활성화하려면 폴더를 마우스 오른쪽 버튼으로 클릭한 후 "모두 선택" 또는 "모두 선택 취소"를 클릭하십시오. </entry>
    <entry key="MARootNodeMsgLine4">자세한 내용을 보려면 "도움말"을 클릭하십시오. </entry>
    <entry key="MARootNodeMsgLine5">가능한 모든 조치 목록을 보려면 왼쪽 창에서 객체를 마우스 오른쪽 버튼으로 클릭하십시오.</entry>
    <entry key="MARootNodeMsgLine6">검사를 실행하려면 왼쪽 창에서 폴더나 검사를 선택하십시오.</entry>
    <entry key="MALegend">범례</entry>
    <entry key="MASource">소스</entry>
    <entry key="MATitle">제목</entry>
    <entry key="MATaskName">태스크 이름</entry>
    <entry key="MAProcessCallbackFuncName">프로세스 콜백 함수 이름</entry>
    <entry key="MASelectedCheck">선택한 검사</entry>
    <entry key="MAPSelectedCheck">선택한 검사(영구)</entry>
    <entry key="MADeselectedCheck">선택 취소한 검사</entry>
    <entry key="MAPassedCheck">통과한 검사</entry>
    <entry key="MAFailedCheck">실패한 검사</entry>
    <entry key="MAInitializing">초기화 중...</entry>
    <entry key="MAPleaseWait">기다려 주십시오...</entry>
    <entry key="MARunToSelectedTask">선택한 태스크까지 실행</entry>
    <entry key="MAResetThisTask">이 태스크 재설정</entry>
    <entry key="MACETitleInRpt">모델 어드바이저 구성</entry>
    <entry key="MAProcessing">처리 중</entry>
    <entry key="MAProcessCallbacks">콜백 처리 중</entry>
    <entry key="MAProcessCallback">콜백 처리 중</entry>
    <entry key="MACompilingModel">모델을 컴파일하는 중...</entry>
    <entry key="MACompilingModelForCodegen">코드 생성을 위해 모델을 컴파일하는 중...</entry>
    <entry key="MAWarnReportFromDifferentNode">경고 - 마지막 리포트가 현재 노드가 아닌 다른 모델 어드바이저 노드에서 생성되었습니다.</entry>
    <entry key="MAPressRunThisCheck">&lt;b&gt;이 검사 실행&lt;/b&gt;을 클릭합니다.</entry>
    <entry key="MAPressRunThisTask">&lt;b&gt;이 태스크 실행&lt;/b&gt;을 클릭합니다.</entry>
    <entry key="MARightClickThenPressRunThisCheck">작업 계층 구조에서 이 검사를 마우스 오른쪽 버튼으로 클릭하여 선택한 후 &lt;b&gt;이 검사 실행&lt;/b&gt;을 누릅니다.</entry>
    <entry key="MASelectThenPressRunThisCheck">이 검사를 실행하려면 검사를 선택한 후 &lt;b&gt;이 검사 실행&lt;/b&gt;을 클릭하십시오.</entry>
    <entry key="MASelectThenPressRunThisTask">이 태스크를 실행하려면 이전의 모든 태스크 결과가 [통과] 또는 [경고]여야 합니다.</entry>
    <entry key="MAShowRptAfterRun">실행 후 리포트 표시</entry>
    <entry key="MAAdviceOnContainerNode1">이 폴더에서 활성화된 모든 항목을 처리하고 새 리포트를 생성하려면 {0}을(를) 클릭하십시오.</entry>
    <entry key="MAAdviceOnContainerNode2">{0}을(를) 클릭하면 실패할 때까지 활성화된 절차 폴더가 실행됩니다.</entry>
    <entry key="MAAdviceOnContainerNode3">마우스 오른쪽 버튼을 클릭하고 이 폴더의 모든 항목을 선택하거나 선택 취소합니다. </entry>
    <entry key="MAAdviceOnContainerNode4">처리 후 리포트가 자동으로 표시되도록 하려면 {0}을(를) 선택하십시오. </entry>
    <entry key="MAAdviceOnContainerNode5">마지막으로 생성된 리포트를 표시하려면 "리포트" 경로 링크를 클릭하십시오.</entry>
    <entry key="MAAdviceOnContainerNode6">가능한 모든 조치 목록을 보려면 작업 계층 구조에서 항목을 마우스 오른쪽 버튼으로 클릭하십시오. </entry>
    <entry key="MAAdviceOnprocedure1">태스크가 실패할 때까지 태스크 폴더 내 모든 태스크가 자동으로 실행되도록 하려면 폴더를 선택하고 {0}을(를) 클릭하십시오.</entry>
    <entry key="MAAdviceOnprocedure1HDLWA">태스크 폴더 내 모든 태스크가 자동으로 실행되도록 하려면 폴더를 선택하고 {0}을(를) 클릭하십시오.</entry>
    <entry key="MAAdviceOnprocedure2">태스크를 직접 실행하려면 태스크를 선택하고 {0}을(를) 클릭하십시오. 태스크를 순서대로 실행해야 합니다. 따라서 이전 태스크를 실행하지 않은 경우에는 {1}을(를) 사용할 수 없습니다. </entry>
    <entry key="MAAdviceOnprocedure3">태스크를 처리한 후 리포트가 자동으로 표시되도록 하려면 {0}을(를) 선택하십시오.</entry>
    <entry key="MAAdviceOnprocedure5">자세한 내용을 보려면 태스크를 마우스 오른쪽 버튼으로 클릭하고 {0}을(를) 선택하십시오.</entry>
    <entry key="MAStatus">상태</entry>
    <entry key="MANotRunMsg">실행되지 않음</entry>
    <entry key="MAWaivedMsg">실패 - 예외적으로 통과 처리됨</entry>
    <entry key="MAFailedMsg">실패</entry>
    <entry key="MASeverity">심각도</entry>
    <entry key="MAAdvisory">권고</entry>
    <entry key="MARequired">필요</entry>
    <entry key="MASelected">선택됨</entry>
    <entry key="MAPermSelected">영구 선택됨</entry>
    <entry key="MADeselected">선택 취소됨</entry>
    <entry key="MAPermDeselected">영구 선택 취소됨</entry>
    <entry key="MARunSelectedChecks">선택한 검사 실행</entry>
    <entry key="MASaveReport">다른 이름으로 저장...</entry>
    <entry key="MARunThisCheck">이 검사 실행</entry>
    <entry key="MARunThisTask">이 태스크 실행</entry>
    <entry key="MANoteNotCreateReport">참고: 리포트가 생성되지 않음</entry>
    <entry key="MASelectAll2">모두 선택</entry>
    <entry key="MADeselectAll">모두 선택 취소</entry>
    <entry key="MASelect">선택</entry>
    <entry key="MADeselect">선택 취소</entry>
    <entry key="MANeedWrittableWorkDir">''{0}''에서 작업 디렉터리를 생성하는 중 오류가 발생했습니다. 쓰기 권한이 있는 디렉터리로 이동하고 모델 어드바이저를 다시 실행하십시오. </entry>
    <entry key="MAInvalidParamsetActionStyle">Invalid action callback style {0} is used on setActionStyle method.</entry>
    <entry key="MACanOnlyCallWhileExecuteCheckCallback">검사 콜백을 실행하는 동안에는 {0} 메서드만 호출할 수 있습니다.</entry>
    <entry key="MACanOnlyCallWhileExecuteActionCallback">{0} method can only be called while executing action callback.</entry>
    <entry key="MAInvalidCallsetActionResultStatus">setActionResultStatus 메서드는 조치 콜백을 실행하는 중에만 호출할 수 있습니다.</entry>
    <entry key="MARunAdvisor">어드바이저 실행</entry>
    <entry key="MAByProduct">제품별</entry>
    <entry key="MAByTask">작업별</entry>
    <entry key="MAReportEmpty">표시할 결과가 없습니다. 왼쪽 창에서 하나 이상의 항목을 선택한 후 &lt;b&gt;{0}&lt;/b&gt;을(를) 누르십시오.</entry>
    <entry key="NoActionCallBack">검사 {0}에 대한 모델 어드바이저 조치 콜백 함수가 없습니다. </entry>
    <entry key="MAErrorActionCallback">검사 {0}에 대한 모델 어드바이저 조치 콜백 함수를 호출하는 동안 오류가 발생했습니다. </entry>
    <entry key="MAWarnEmptyActionButtonName">Model Advisor ignored check {0} because it contains ActionCallbackHandle but lacks ActionButtonName.</entry>
    <entry key="MAWarnCheckboxActionButtonTogether">ActionCallbackStyle이 "PerGroup"이 아닌 경우 모델 어드바이저가 검사 {0}에 대해 ActionShowCheckBox 설정을 무시합니다.</entry>
    <entry key="MAWarnVVLicense">Simulink V&amp;V 라이선스를 사용할 수 없습니다. {0} 내부에서 모델 어드바이저 콜백을 무시합니다.</entry>
    <entry key="MAInvalidCheckID">Invalid check TitleID.</entry>
    <entry key="MAErrorInActionCallback">검사 {0}에 대한 모델 어드바이저 조치 콜백 함수를 호출하는 동안 오류가 발생했습니다. </entry>
    <entry key="MAMaxIdLengthLargerThan31">&lt;p /&gt;{0}을(를) {1}(으)로 설정했습니다. C에 대한 산업 표준(예: ISO&amp;#174; 및 MISRA&amp;#174;)에 따라 식별자는 처음 31자 내에서 고유해야 합니다. 표준을 준수하려면 최대 식별자 길이를 31자로 설정해야 합니다.</entry>
    <entry key="MACheckSolverVariableStep">모델이 {0}({1})을(를) 지정합니다. Embedded Coder를 사용하여 이 모델에서 코드를 생성하려면 먼저 &lt;b&gt;솔버&lt;/b&gt; 구성 파라미터 설정을 변경하여 고정 스텝 이산 솔버를 지정해야 합니다.&lt;p&gt;참고로, 모델의 서브시스템에서 코드를 생성해야 할 때는 솔버 설정을 변경할 필요가 없습니다. 서브시스템의 상황별 메뉴에서 &lt;b&gt;C/C++ 코드 &amp;gt; 이 서브시스템 빌드&lt;/b&gt; 또는 &lt;b&gt;C/C++ 코드 &amp;gt; S-Function 생성&lt;/b&gt;을 선택하면 Embedded Coder가 설정을 고정 스텝 솔버로 변경하기 때문입니다.&lt;/p&gt;</entry>
    <entry key="MATitletipIdentQuestFixptOper">이 연산으로 인해 최적이 아닌 결과가 생성될 수 있습니다.</entry>
    <entry key="MATitleIdentQuestFixptOper">문제가 될 수 있는 고정소수점 연산 식별</entry>
    <entry key="MATitleEnableLongLong">'long long' 데이터형 사용 검사</entry>
    <entry key="MATitleTipEnableLongLong">비용이 많이 드는 멀티워드 유형이 감지되면 'long long' 데이터형이 사용되었는지 검사합니다</entry>
    <entry key="MATitleTipIdentBlocksQuestFixptOper">이러한 블록으로 인해 최적이 아닌 고정소수점 코드가 생성될 수 있습니다.</entry>
    <entry key="MATitleIdentBlocksQuestFixptOper">비용이 많이 드는 고정소수점 및 포화 코드를 생성하는 블록 식별</entry>
    <entry key="MATitleIdentQuestSubsysSetting_tip">일부 서브시스템 설정으로 인해 최적이 아닌 결과가 생성될 수 있습니다.</entry>
    <entry key="MATitleIdentQuestSubsysSetting_pass"> 설정이 잘못된 서브시스템을 찾을 수 없습니다.</entry>
    <entry key="MATitleIdentQuestSubsysSetting_rec_action">Subsystem 블록은 [함수 패키징 옵션]을 [재사용 불가 함수]로 지정해서는 안 됩니다.</entry>
    <entry key="MATitleIdentQuestSubsysSetting">문제가 될 수 있는 서브시스템 설정 식별</entry>
    <entry key="MATitleCodeGenSanityCheck">모델 구성 설정이 코드 생성 목표에 맞는지 검사</entry>
    <entry key="MATitleTipCodeGenSanityCheck">모델 구성 설정이 코드 생성 목표에 맞는지 검사합니다. 한 옵션에 대한 변경 사항이 다른 옵션에 영향을 미칠 수 있기 때문에 이 검사가 성공적으로 통과하는 데 여러 번의 반복이 수행될 수 있습니다.</entry>
    <entry key="MATitleDataStoreExecutionOrder">Data Store Read 블록 및 Data Store Write 블록에 대한 상대적인 실행 순서 검사</entry>
    <entry key="MATitleTipDataStoreExecutionOrder">Data Store Read 블록 및 Data Store Write 블록에 대한 레거시 및 태스크 기반 정렬 사이에서 상대적인 실행 순서가 변경되었는지 검사합니다.</entry>
    <entry key="MADataStoreExecutionOrderAction">원래 실행 순서를 복원하도록 블록 우선 순위 수정</entry>
    <entry key="MADataStoreExecutionOrderModify">수정</entry>
    <entry key="MADataStoreExecutionOrderPassDesc">실행 순서가 변경되는 Data Store 블록을 식별합니다.</entry>
    <entry key="MADataStoreExecutionOrderPassMsg">Data Store Read 블록 또는 Data Store Write 블록이 없거나 모든 Data Store 블록의 실행 순서가 일치합니다.</entry>
    <entry key="MADataStoreExecutionOrderFailDesc">실행 순서가 변경되는 Data Store 블록을 식별합니다.</entry>
    <entry key="MADataStoreExecutionOrderFailMsg">실행 순서가 변경된 블록:</entry>
    <entry key="MADataStoreExecutionOrderFailAction">실행 순서를 명시적으로 지정하십시오.</entry>
    <entry key="MATitleDataStoreRTWExecutionOrder">Data Store Read 블록 및 Data Store Write 블록에 대한 상대적인 실행 순서가 변경되었는지 검사</entry>
    <entry key="MATitleTipDataStoreRTWExecutionOrder">생성 코드에서 Data Store Read 블록 및 Data Store Write 블록의 상대적인 실행 순서가 표준 모드 시뮬레이션에서와 비교했을 때 변경되었는지 여부를 검사합니다.</entry>
    <entry key="MADataStoreRTWExecutionOrderAction">표준 모드 시뮬레이션의 블록 우선 순위를 수정하여 상대적 실행 순서를 생성 코드와 동일하게 만들려면 아래 버튼을 누르십시오.</entry>
    <entry key="MADataStoreRTWExecutionOrderModify">블록 우선 순위 수정</entry>
    <entry key="MADataStoreRTWExecutionOrderPassDesc">실행 순서가 변경되는 Data Store 블록을 식별합니다.</entry>
    <entry key="MADataStoreRTWExecutionOrderPassMsg">Data Store Read 블록 또는 Data Store Write 블록이 없거나 모든 Data Store 블록의 실행 순서가 일치합니다.</entry>
    <entry key="MADataStoreRTWExecutionOrderFailDesc">실행 순서가 변경되는 Data Store 블록을 식별합니다.</entry>
    <entry key="MADataStoreRTWExecutionOrderFailMsg">실행 순서가 변경된 블록:</entry>
    <entry key="MADataStoreRTWExecutionOrderFailAction">실행 순서를 명시적으로 지정하십시오.</entry>
    <entry key="MAforCodeGenAdvisorCheckEnableMemcpyFixButton">값 수정</entry>
    <entry key="MAforCodeGenAdvisorCheckEnableMemcpyFixButtonDesc">구성 파라미터 ''벡터 할당에 memcpy 사용''의 값을 수정합니다.</entry>
    <entry key="MARawTitleCodeGenSanityCheck">모델 구성 설정이 코드 생성 목표에 맞는지 검사</entry>
    <entry key="MATCodeGenSanityCheckPassMsg">통과</entry>
    <entry key="MATCodeGenSanityCheckPassMsg2">권장 값을 사용하여 파라미터를 검사하고 확인했습니다.</entry>
    <entry key="MATCodeGenSanityCheckNoObjective">지정된 목표 없음</entry>
    <entry key="MATCodeGenSanityCheckNoObjectiveLinkMsg">구성 세트에서 목표 지정...</entry>
    <entry key="MATCodeGenSanityCheckNoObjectiveMsg">코드 생성 어드바이저 루트 노드에서 목표를 지정합니다.</entry>
    <entry key="MATCodeGenSanityCheckResultTableTitle">다음 파라미터 값은 선택한 목표에 대해 최적화되지 않았습니다.&lt;br&gt;&lt;br&gt;경고를 자동으로 수정하려면 ''파라미터 수정'' 버튼을 클릭한 후 검사를 다시 실행하십시오. 경고를 직접 수정하려면 파라미터 하이퍼링크를 클릭하여 [구성 파라미터] 대화 상자를 열고 권장 값을 직접 적용하십시오.</entry>
    <entry key="MATCodeGenSanityCheckResultTableColName1">파라미터</entry>
    <entry key="MATCodeGenSanityCheckResultTableColName2">현재 값</entry>
    <entry key="MATCodeGenSanityCheckResultTableColName2a">이전 값</entry>
    <entry key="MATCodeGenSanityCheckResultTableColName3">권장 값</entry>
    <entry key="MATCodeGenSanityCheckResultTableColName4">값</entry>
    <entry key="MATCodeGenSanityCheckObjectives">목표</entry>
    <entry key="CodeGenObjectiveCheckGroupName">코드 생성 목표</entry>
    <entry key="CodeGenObjectiveCheckGroupDescr">코드 생성 목표</entry>
    <entry key="MACodeGenSanityCheckFixButtonTitle">파라미터 수정</entry>
    <entry key="MATitleCodeGenSanityCheckFixButtonDescr">현재 값을 권장 값으로 변경합니다. 일부 파라미터는 직접 변경해야 할 수 있습니다.</entry>
    <entry key="MATCodeGenSanityCheckFixNoChange">어떠한 파라미터도 변경되지 않았습니다.</entry>
    <entry key="MATCodeGenSanityCheckFixPartlySingular">1개의 파라미터가 권장 값으로 자동 설정되었습니다(아래 표 참조).</entry>
    <entry key="MATCodeGenSanityCheckFixPartly">{0,number,integer}개의 파라미터가 권장 값으로 자동 설정되었습니다(아래 표 참조).</entry>
    <entry key="MATCodeGenSanityCheckFixManualSingular">직접 변경해야 하는 파라미터가 1개 있습니다. 직접 변경해야 하는 파라미터와 해당 변경의 영향을 받는 파라미터 설정을 보려면 "이 검사 실행"을 클릭하십시오.\n\n</entry>
    <entry key="MATCodeGenSanityCheckFixManual">직접 변경해야 하는 파라미터가 {0,number,integer}개 있습니다. 직접 변경해야 하는 파라미터의 목록과 해당 변경의 영향을 받는 파라미터 설정을 보려면 "이 검사 실행"을 클릭하십시오.\n\n</entry>
    <entry key="MATCodeGenSanityCheckFixAll">모든 파라미터가 권장 사항대로 설정되었습니다.</entry>
    <entry key="MATitleChecktipDiscreteIntegBlockwInitialCondition">상태 포트 및 초기 조건 포트를 가진 Discrete-Time Integrator 블록에서 이들 포트가 IC 또는 상수 블록으로부터 입력을 받지 않는 경우 블록이 제대로 초기화되지 않을 수 있습니다.</entry>
    <entry key="MATitleCheckDiscreteIntegBlockwInitialCondition">초기 조건 불확실성을 갖는 Discrete-Time Integrator 블록이 있는지 검사</entry>
    <entry key="MATitletipCheckBusTreatedAsVector">벡터로 처리되는 버스 신호를 식별합니다.</entry>
    <entry key="MATitleCheckBusTreatedAsVector">벡터로 처리되는 버스 신호 검사</entry>
    <entry key="MATitleCheckVirtualBusUsageUpgrade">블록에 대한 가상 버스 입력 검사</entry>
    <entry key="MATitletipCheckVirtualBusUsageUpgrade">가상 버스를 지원하지 않는 블록으로 입력되는 가상 버스 신호를 식별합니다.</entry>
    <entry key="MATitletipCheckForProperMergeBlockUsage">Merge 블록의 동일한 트리를 직접 구동하는 블록들은 각 시간 스텝마다 상호 배타적으로 실행되어야 합니다. 이 조건을 보장하지 못할 경우 의도치 않은 모델 동작이 발생할 수 있습니다.</entry>
    <entry key="MATitleCheckForProperMergeBlockUsage">Merge 블록 사용 검사</entry>
    <entry key="MATitletipDataStoreCheck">멀티태스킹 데이터 무결성, 강한 데이터형 지정, 상위 범위의 데이터 저장소가 가려지는 문제 등 Data Store Memory 블록과 관련된 모델링 문제가 있는지 검사합니다.</entry>
    <entry key="MATitleDataStoreCheck">Data Store Memory 블록에 멀티태스킹, 강한 데이터형 지정, 가리는 문제가 있는지 검사</entry>
    <entry key="MATitletipCheckForProperDataStoreBlockUsage">쓰기 전 읽기, 읽기 후 쓰기 또는 쓰기 후 쓰기 문제가 있는 시나리오를 감지하는 등 Data Store Memory 블록과 관련된 모델링 문제가 있는지 검사합니다.</entry>
    <entry key="MATitleCheckForProperDataStoreBlockUsage">데이터 저장소 액세스와 관련된 잠재적인 순서 지정 문제가 있는지 검사 </entry>
    <entry key="MADataStoreAnalysisForDetailsSee">Data Store 블록의 액세스 순서 지정을 설정하는 방법에 대한 자세한 내용은 {0} 항목을 참조하십시오.</entry>
    <entry key="MADataStoreOrderingDataStoreAccess">데이터 저장소 액세스 순서 지정</entry>
    <entry key="MADataStoreRBWTitle">잠재적인 쓰기 전 읽기 문제가 식별됨</entry>
    <entry key="MADataStoreReadBeforeWriteError">모델이 현재 시간 스텝에서 Data Store 블록에 데이터를 쓰지 않은 채 그 블록으로부터 데이터 읽기를 시도할 수 있습니다. 해당하는 블록은 다음과 같습니다.</entry>
    <entry key="MADataStoreRBWAction">Data Store Read 블록이 항상 Data Store Write 블록 전에 실행되도록 모델을 재구성해 보십시오.</entry>
    <entry key="MADataStoreMETitle">잠재적인 쓰기 후 쓰기 문제가 식별됨</entry>
    <entry key="MADataStoreMutualExclusiveness">모델이 현재 시간 스텝에서 Data Store 블록에 연속으로 두 번 데이터 쓰기를 시도할 수 있습니다. 해당하는 블록은 다음과 같습니다.</entry>
    <entry key="MADataStoreMEAction">하나의 Data Store Write 블록만 하나의 시간 스텝에서 실행될 수 있도록 모델을 재구성해 보십시오.</entry>
    <entry key="MADataStoreWARTitle"> 잠재적인 읽기 후 쓰기 문제가 식별됨</entry>
    <entry key="MADataStoreWriteAfterReadError">모델이 현재 시간 스텝에서 먼저 Data Store 블록에서 데이터를 읽은 후에 이 블록으로 데이터 쓰기를 시도할 수 있습니다.</entry>
    <entry key="MADataStoreWARAction">Data Store Writer 블록이 Data Store Reader 블록 다음에 실행되는 경우가 없도록 모델을 재구성해 보십시오.</entry>
    <entry key="MATitleMigrateToSimplifiedMode">단순 방식 초기화 모드로 마이그레이션</entry>
    <entry key="MATitletipMigrateToSimplifiedMode">예기치 않은 초기화 동작을 초래할 수 있는 파라미터 설정을 식별하고 단순 방식 초기화 모드로의 마이그레이션을 활성화합니다.</entry>
    <entry key="MATitleCheckOptimalBusVirtual_tip">생성된 코드의 효율성을 향상시키기 위해 비가상으로 만들 수 있는 가상 버스가 있는지 검사합니다.</entry>
    <entry key="MATitleCheckOptimalBusVirtual">최적의 버스 가상성 검사</entry>
    <entry key="MATitleCheckOptimalBusVirtual_warn">다음 블록은 모델 경계를 넘는 가상 버스를 지정합니다.</entry>
    <entry key="MATitleCheckOptimalBusVirtual_pass">가상 버스를 찾을 수 없습니다.</entry>
    <entry key="MATitleCheckOptimalBusVirtual_rec_action">이 모델에서 생성된 코드의 효율성을 높이려면 비가상 버스를 지정할 수 있도록 블록을 변경해 보십시오:</entry>
    <entry key="MATitletipCheckImplicitSignalRes">묵시적 신호 연결 맺기로 구성된, 즉 명명된 모든 신호와 상태를 Simulink.Signal 객체와 연결 맺기를 시도하도록 구성된 모델이 있는지 검사합니다. 이러한 구성은 비효율적이며 증분 코드 생성 및 모델 참조의 속도를 늦춥니다.</entry>
    <entry key="MATitleCheckImplicitSignalRes">묵시적 신호 연결 맺기가 있는지 검사</entry>
    <entry key="MATitleCheckDTAndScale">slDataTypeAndScale() 호출이 있는지 검사</entry>
    <entry key="MATitletipCheckDTAndScale">slDataTypeAndScale()을 사용하여 지정된 데이터형 파라미터를 갖는 블록을 검색합니다.</entry>
    <entry key="MACheckDTAndScaleSub0">대체가 필요한 경우</entry>
    <entry key="MACheckDTAndScaleSub0Info">더 이상 지원되지 않으므로 대체되어야 하는 slDataTypeAndScale() 호출을 식별합니다. 이러한 호출은 언제든지 자동으로 대체될 수 있습니다.</entry>
    <entry key="MADTAndScaleSub0Case">다음과 같은 slDataTypeAndScale() 호출은 더 이상 지원되지 않으므로 대체되어야 합니다.</entry>
    <entry key="MADTAndScaleSub0NoCase">대체가 필요한 slDataTypeAndScale() 호출이 없습니다.</entry>
    <entry key="MACheckDTAndScaleSub0RecAction">오류를 자동으로 수정하려면 "{0}" 버튼을 클릭한 후 검사를 다시 실행하십시오. 오류를 직접 수정하려면 블록 하이퍼링크를 클릭하여 블록을 식별하십시오. 블록을 더블 클릭하여 블록 파라미터 대화 상자를 엽니다. 블록 파라미터 대화 상자에서 권장 값을 직접 적용합니다.</entry>
    <entry key="MACheckDTAndScaleSub1">대체가 권장되는 경우</entry>
    <entry key="MACheckDTAndScaleSub1Info">모델 어드바이저가 자동으로 대체할 수 있는 불필요한 slDataTypeAndScale() 호출을 식별합니다.</entry>
    <entry key="MACheckDTAndScaleSub01Link">slRemoveDataTypeAndScale()이 자동으로 대체되는 경우</entry>
    <entry key="MADTAndScaleSub1Case">다음과 같은 slDataTypeAndScale() 호출은 불필요하므로 자동으로 대체될 수 있습니다.</entry>
    <entry key="MADTAndScaleSub1NoCase">자동으로 대체될 수 있는 slDataTypeAndScale() 호출이 없습니다.</entry>
    <entry key="MACheckDTAndScaleSub1RecAction">경고를 자동으로 수정하려면 "{0}" 버튼을 클릭한 후 검사를 다시 실행하십시오. 경고를 직접 수정하려면 블록 하이퍼링크를 클릭하여 블록을 식별하십시오. 블록을 더블 클릭하여 블록 파라미터 대화 상자를 엽니다. 블록 파라미터 대화 상자에서 권장 값을 직접 적용합니다.</entry>
    <entry key="MACheckDTAndScaleSub2">직접 검사하는 경우</entry>
    <entry key="MACheckDTAndScaleSub2Info">불필요할 수 있는 slDataTypeAndScale() 호출을 식별합니다.</entry>
    <entry key="MACheckDTAndScaleSub2Link">slRemoveDataTypeAndScale()을 직접 검사하는 경우</entry>
    <entry key="MADTAndScaleSub2Case">다음과 같은 slDataTypeAndScale() 호출을 검토하여 불필요한지 여부를 판단합니다.</entry>
    <entry key="MADTAndScaleSub2NoCase">직접 검사해야 하는 slDataTypeAndScale() 호출이 없습니다.</entry>
    <entry key="MACheckDTAndScaleSub2RecAction">경고를 직접 수정하려면 블록 하이퍼링크를 클릭하여 블록을 식별하십시오. 블록을 더블 클릭하여 블록 파라미터 대화 상자를 연 후 호출을 검사하고 불필요한 경우 값을 직접 변경합니다.</entry>
    <entry key="MADTAndScaleRemove">수정</entry>
    <entry key="MADTAndScaleRemoveDscp">자동으로 대체되는 경우에 해당하는 불필요한 slDataTypeAndScale() 호출을 대체합니다.</entry>
    <entry key="MADTAndScaleRemoveDscp_new">대체가 필요한 경우/대체가 권장되는 경우에 해당하는 지원되지 않거나 불필요한 slDataTypeAndScale() 호출을 대체합니다.</entry>
    <entry key="MADTAndScaleRemoveCase">다음과 같은 slDataTypeAndScale() 호출이 대체되었습니다.</entry>
    <entry key="MADTAndScaleAllBlocks">모든 경우</entry>
    <entry key="MADTAndScaleBlockName">블록</entry>
    <entry key="MADTAndScaleParamName">파라미터</entry>
    <entry key="MADTAndScaleNewStr">권장 값</entry>
    <entry key="MADTAndScaleOldStr">이전 값</entry>
    <entry key="MADTAndScaleCurStr">현재 값</entry>
    <entry key="MATitletipCheckParamTunableIgnore">[모델 파라미터 구성] 대화 상자에서 파라미터 조정 가능성 정보를 지정하는 모델이 있는지 검사합니다. Simulink는 참조된 모델에 대해 이 방법으로 지정된 조정 가능성 정보를 무시합니다.</entry>
    <entry key="MATitleCheckParamTunableIgnore">참조된 모델에 대해 무시된 파라미터 조정 가능성 정보가 있는지 검사</entry>
    <entry key="MATitletipCheckBlockConstraintTunableParam">Lookup 블록 및 Lookup2D 블록은 조정 가능한 경우 엄격한 제약 조건이 있습니다.</entry>
    <entry key="MATitleCheckBlockConstraintTunableParam">조정 가능형 파라미터에 대한 제약 조건이 있는 블록이 있는지 검사</entry>
    <entry key="MATitletipCheckSampleTime">잘못된 태스킹 모드로 인해 비효율적인 코드 실행이 발생할 수 있습니다.</entry>
    <entry key="MATitleCheckSampleTime">샘플 시간 및 태스킹 모드 검사</entry>
    <entry key="MATitletipIdentQuestCodeInstr">생성된 코드의 계측으로 인해 최적이 아닌 결과가 생성될 수 있습니다.</entry>
    <entry key="MATitleIdentQuestCodeInstr">문제가 될 수 있는 코드 계측(데이터 I/O) 식별</entry>
    <entry key="MATitletipIdentQuestSoftSpec">일부 소프트웨어 환경 설정에 대한 지원으로 인해 최적이 아닌 결과가 생성될 수 있습니다.</entry>
    <entry key="MATitleIdentQuestSoftSpec">문제가 될 수 있는 소프트웨어 환경 사양 식별</entry>
    <entry key="MATitletipCheckOptimSetting">선택되지 않은 최적화가 있는 경우 최적이 아닌 결과가 생성될 수 있습니다.</entry>
    <entry key="MATitleCheckOptimSetting">최적화 설정 검사</entry>
    <entry key="MATitletipCheckHardImple">하드웨어 특성의 불일치 또는 과소 지정으로 인해 최적이 아닌 결과가 생성될 수 있습니다.</entry>
    <entry key="MATitleCheckHardImple">하드웨어 구현 상태 검사</entry>
    <entry key="MATitletipCheckModelrefMismatch">최상위 모델과 구성 설정이 일치하지 않는 Model 블록을 식별합니다.</entry>
    <entry key="MATitleCheckModelrefMismatch">모델 참조 구성이 불일치하는지 검사</entry>
    <entry key="MATitletipCheckModelRefSIMConfigCompliance">액셀러레이터 시뮬레이션에서 지원되지 않는 모델 참조 진단을 식별합니다.</entry>
    <entry key="MATitletipCheckModelRefRTWConfigCompliance">코드 생성 시 지원되지 않는 모델 참조 식별자 형식 설정을 식별합니다.</entry>
    <entry key="MAModelRefSIMConfigCheckInfo">액셀러레이터 모드에서 실행되는 참조된 모델에는 다음의 현재 진단 설정이 지원되지 않습니다. 이 모델 참조 계층의 최상위 모델은 ''{0}''입니다.</entry>
    <entry key="MAModelRefRTWConfigCheckInfo">최상위 모델 ''{0}''을(를) 갖는 모델 참조 계층의 코드 생성 시 다음의 현재 식별자 형식 설정이 지원되지 않습니다.</entry>
    <entry key="MAModelRefConfigCheckDSMHeader">액셀러레이터 모드에서 실행되는 참조된 모델에 포함된 다음의 로컬 Data Store Memory 블록에는 쓰기 전 읽기 감지, 읽기 후 쓰기 감지, 쓰기 후 쓰기 감지 진단 설정이 지원되지 않습니다.</entry>
    <entry key="MAModelRefConfigCheckPassText">구성 파라미터 설정이 검사를 통과했습니다.</entry>
    <entry key="MAModelRefConfigCheckTableCol1">파라미터</entry>
    <entry key="MAModelRefConfigCheckTableCol2">현재 값</entry>
    <entry key="MAModelRefConfigCheckRecActionSIM">이러한 진단을 활용하려면 모델이 &lt;a href="matlab:helpview([docroot,''/toolbox/simulink/ug/simulink_ug.map''], ''mamodelref_sim_modes'');"&gt;표준 모드에서 실행되는 참조된 모델&lt;/a&gt;이어야 합니다. 자세한 내용은 &lt;a href="matlab:helpview([docroot,''/toolbox/simulink/ug/simulink_ug.map''],''model_ref_limitations_ma_checksimulation'');"&gt;관련 문서&lt;/a&gt;를 참조하십시오.</entry>
    <entry key="MAModelRefConfigCheckRecActionRTW">코드 생성 시 모델 이름을 나타내는 $R 토큰이 추가되었습니다. 자세한 내용은 &lt;a href="matlab:helpview([docroot,''/toolbox/rtw/helptargets.map''],''model_ref_limitations_ma_checkcodegen'');"&gt;관련 문서&lt;/a&gt;를 참조하십시오.</entry>
    <entry key="MAModelRefConfigCheckModelHeader">참조된 모델: </entry>
    <entry key="MATitleCheckModelRefSIMConfigCompliance">가속화된 모드에서 모델 참조를 시뮬레이션하는 동안 무시된 진단 설정이 있는지 검사</entry>
    <entry key="MATitleCheckModelRefRTWConfigCompliance">모델 참조에 사용된 코드 생성 식별자 형식 검사</entry>
    <entry key="MATitletipIdentQuestBlocks">코드 생성에서 지원되지 않거나 배포에 권장되지 않은 블록을 식별합니다.</entry>
    <entry key="MATitleIdentQuestBlocks">지정된 시스템 내에서 문제가 될 수 있는 블록 식별</entry>
    <entry key="MATitletipCheckSolver">설정이 잘못된 경우 코드가 생성되지 못할 수 있습니다. 샘플 시간을 과소 지정하면 원하지 않는 결과가 생성될 수 있습니다.</entry>
    <entry key="MATitleCheckSolver">코드 생성을 위한 솔버 검사</entry>
    <entry key="MATitletipIdentExpensiveBlocks">이러한 설정으로 인해 최적이 아닌 결과가 생성될 수 있습니다.</entry>
    <entry key="MATitleIdentExpensiveBlocks">비용이 많이 드는 반올림 코드를 생성하는 블록 식별</entry>
    <entry key="MATitletipIdentLUTRangeCheckCode">입력이 항상 Lookup Table 블록, Prelookup 블록, Interpolation 블록을 포함한 Lookup Table의 유효한 절점 범위 내에 속한다면 이러한 설정은 비효율적인 코드 생성을 야기할 수 있습니다.</entry>
    <entry key="MATitleIdentLUTRangeCheckCode">범위를 벗어나는 값을 검사하는 고비용의 코드를 생성하는 Lookup Table 블록 식별</entry>
    <entry key="MALookupTableRemoveRangeCheckingCodeInfo">다음 Lookup Table 블록은 범위를 벗어나는 값을 검사하는 코드를 생성합니다. 입력이 항상 유효한 절점 값 범위 내에 속한다면 블록별 임베디드 코드 생성에서 범위 검사 코드를 제거할 수 있습니다.</entry>
    <entry key="MALUTRemoveRangeCheckCodeDscp">입력이 항상 유효한 절점 값 범위 내에 속한다면 코드 생성의 효율성을 높이기 위해 범위 검사 코드를 제거할 수 있습니다.</entry>
    <entry key="MALUTRemoveRangeCheckCodePass">Lookup Table 블록에 대한 코드 생성이 범위 검사 코드를 포함하지 않도록 구성되었습니다.</entry>
    <entry key="MALookupTableBlockName">블록</entry>
    <entry key="MALookupTableParamName">파라미터</entry>
    <entry key="MALookupTableNewSetting">권장 설정</entry>
    <entry key="MALookupTableRangeRemoveAction">나열된 모든 블록에 대해 경고를 자동으로 수정하려면 "{0}" 버튼을 클릭한 후 검사를 다시 실행하십시오. 경고를 직접 수정하려면 블록 하이퍼링크를 클릭하여 블록을 식별하십시오. 블록을 더블 클릭하여 블록 파라미터 대화 상자를 엽니다. 블록 파라미터 대화 상자에서 권장 값을 직접 적용합니다. 또한 시뮬레이션 중에 범위를 벗어난 입력을 감지하도록 블록 파라미터 대화 상자에서 'DiagnosticForOutOfRangeInput'을 '경고' 또는 '오류'로 설정하는 것이 좋습니다.</entry>
    <entry key="MALookupTableRangeRemoveActionResult">나열된 모든 블록이 범위 검사 코드를 생성하지 않도록 설정되었습니다. 또한 현재 설정이 '안 함'인 경우 이러한 블록에 대한 'DiagnosticForOutOfRangeInput'이 '경고'로 설정되었습니다. 따라서 시뮬레이션 중에 범위를 벗어난 입력이 감지될 수 있습니다.</entry>
    <entry key="MALookupTableRangeRemove">수정</entry>
    <entry key="MATitletipCheckRootInport">특성을 완전히 정의하지 않는 루트 모델의 Inport 블록으로 인해 원하지 않는 결과가 생성될 수 있습니다.</entry>
    <entry key="MATitleCheckRootInport">루트 모델의 Inport 블록 사양 검사</entry>
    <entry key="MATitletipIdentUnconnectLine">연결되지 않은 객체는 모델에 문제가 있음을 나타낼 수 있습니다.</entry>
    <entry key="MATitleIdentUnconnectLine">연결되지 않은 선, 입력 포트 및 출력 포트 식별</entry>
    <entry key="MATitlePartialBusParameters">버스 신호에 부분 구조체 파라미터를 사용하는지 검사</entry>
    <entry key="MATitleTipPartialBusParameters">연결된 버스 신호와 형태가 일치하지 않는 구조체 파라미터를 참조하는 블록을 식별합니다.</entry>
    <entry key="MATitleCheckModelReferenceIOMsg">유효하지 않은 루트 Inport/Outport 블록 연결이 있는지 검사</entry>
    <entry key="MATitletipCheckModelReferenceIOMsg">이 모델을 다른 모델에서 참조하는 경우 유효하지 않은 루트 Inport 블록 및 Outport 블록 연결을 감지합니다</entry>
    <entry key="MACheckModelReferenceIOMsgStatus">다음에서 유효하지 않은 연결이 발견됨:</entry>
    <entry key="MACheckModelReferenceIOMsgRecAction">이 경고를 방지하려면 Signal Conversion 블록을 ''{0}'' 앞에 삽입하십시오.</entry>
    <entry key="MAPassResultStatusPartialBusParameters">버스 신호에 부분 구조체 파라미터를 사용하는 블록이 없습니다.</entry>
    <entry key="MARecActionPartialBusParameters">나열된 블록에 대해 Simulink.Bus.createMATLABStruct를 사용하여 부분 구조체 파라미터 값을 전체 구조체 파라미터 값으로 변환해 보십시오.</entry>
    <entry key="MAUnableOpenModel">모델을 열 수 없습니다. 모델을 연 후 모델 어드바이저 툴을 다시 시작하십시오.</entry>
    <entry key="MAErrorOccurredCompile">모델 컴파일 중 오류가 발생했습니다.</entry>
    <entry key="MARequiresCompile">이 검사를 실행하면 다이어그램 업데이트가 트리거되어 처리 시간이 늘어납니다.</entry>
    <entry key="MARequiresCompileShort">이 검사를 실행하면 다이어그램 업데이트가 트리거됩니다.</entry>
    <entry key="MASelectItemFromList">다음 목록에서 제품 범주 또는 항목 선택:</entry>
    <entry key="MASelectTaskFromList">다음 목록에서 태스크 선택:</entry>
    <entry key="MASelectAll">모두 선택 또는 선택 취소</entry>
    <entry key="MARegenerateReport">경고: 링크가 최신 상태가 아닙니다. 최신 정보를 보려면 리포트를 다시 생성하십시오.</entry>
    <entry key="MANotWorkOnLibrary">모델 어드바이저는 Simulink 라이브러리를 지원하지 않습니다.</entry>
    <entry key="MARequiresJava">이 툴을 실행하려면 Java가 필요합니다.</entry>
    <entry key="FunctionRequiresJava">Function ''{0}'' requires java support</entry>
    <entry key="MARemoveExistReport">모델 어드바이저가 기존 리포트를 제거하는 중입니다.</entry>
    <entry key="MAUnableCreateFilesInDirectory">현재 작업 디렉터리에 모델 어드바이저의 파일을 만들 수 없습니다: ''{0}''. 현재 디렉터리를 쓰기 가능하도록 변경하십시오.</entry>
    <entry key="MAPassedMsg">통과</entry>
    <entry key="MAAnalysisThrewError">모델 분석 중에 문제가 발생했습니다. 이 문제를 해결하면 분석이 완료될 수 있음: {0}</entry>
    <entry key="MAMustBeBlockDiagram">업데이트 분석은 모델 수준에서만 지원됩니다. 이 분석을 실행하려면 모델의 서브시스템 수준 대신 최상위 수준에서 모델 어드바이저를 열고 분석을 다시 시작하십시오.</entry>
    <entry key="MAUpdateDiagnosticSummary">모델 어드바이저가 이 버전의 Simulink에서 모델을 사용할 때 이 모델의 블록, 설정 및 참조에 문제가 있는지 검사했습니다. 아래에 설명된 문제를 해결하는 첫 번째 단계로 문제가 보고된 모델 및 라이브러리에서 Simulink 업그레이드 어드바이저를 실행해야 합니다. 참고로, 여기에 식별된 문제 이외에 더 많은 문제가 있을 수 있습니다. 자세한 내용은 {0} 항목을 참조하십시오.</entry>
    <entry key="MAUnableFindTaskSpecified">{1}에 의해 지정된 모델 어드바이저 노드 {0}을(를) 찾을 수 없습니다. 철자가 잘못되었거나 필수 라이선스가 없기 때문일 수 있습니다.</entry>
    <entry key="MAIncompleteTreeStructure">The Model Advisor tree structure is incorrect. The structure of the following folder is not specified correctly: {0}.</entry>
    <entry key="MAMdlFilesMsgDiagnostic">참조된 모델 업데이트 상태:</entry>
    <entry key="MAMdlFilesMsgNone">(이 파일에서 참조된 모델 중 업데이트가 필요한 모델이 없음)</entry>
    <entry key="MALibFilesMsgDiagnostic">라이브러리 업데이트 상태(참조된 블록만 검사됨):</entry>
    <entry key="MALibFilesMsgNone">(이 블록 다이어그램에는 MathWorks 라이브러리가 아닌 라이브러리가 연결되지 않음)</entry>
    <entry key="MAFileMsgNeedsUpdate">(업데이트 권장)</entry>
    <entry key="MAFileMayNeedUpdate">(업데이트가 필요할 수 있음)</entry>
    <entry key="MAFileMsgCheck">(검사 권장)</entry>
    <entry key="MABlocksMsgDiagnostic">업데이트가 권장되는 블록(업데이트 이유를 기준으로 그룹화):</entry>
    <entry key="MAReasonStr">&lt;b&gt;업데이트 이유&lt;/b&gt; &amp;#8212; {0}:</entry>
    <entry key="modelBadStateForCheck">Upgrade Advisor is unable to run the requested check(s) on model {0} in its current compile state</entry>
    <entry key="MACompileCheckUpdatesTitle">모델, 로컬 라이브러리 및 참조된 모델에 컴파일 시간 정보가 필요한 알려진 업그레이드 문제가 있는지 검사</entry>
    <entry key="MACompileCheckUpdatesTitleTips">컴파일 시간 정보가 필요한 자주 발생하는 업그레이드 문제가 있는지 검사합니다.</entry>
    <entry key="MAMdlRefTaskTitle">모델 참조</entry>
    <entry key="MAMdlRefTaskTitleTips">모델 참조 관련 검사를 수행합니다.</entry>
    <entry key="MADataTransferTaskTitle">데이터 전송 효율성</entry>
    <entry key="MADataTransferTaskTitleTips">데이터 전송 효율성 관련 검사를 수행합니다.</entry>
    <entry key="MAUpgradeTaskTitle">현재 Simulink 버전으로 업그레이드</entry>
    <entry key="MAUpgradeTaskTitleTips">권장된 버전 업그레이드 검사를 수행합니다.</entry>
    <entry key="MATitleCheckSfunctions">S-Function 런타임 진단</entry>
    <entry key="MATitletipCheckSfunctions">배열 경계 및 솔버 일관성을 검사하여 S-Function이 존재하는지 여부를 확인합니다.</entry>
    <entry key="MAMsgCheckSfunctions">이 모델에 포함된 C-MEX S-Function:</entry>
    <entry key="MASetSolverDataInconsistencyToWarning">Simulink에서 내장 블록에 적용하는 ODE 솔버 일관성 규칙을 S-Function이 따르는지 여부를 검증하려면 &lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'',''{0}'',''ConsistencyChecking'');"&gt;솔버 데이터 일관성 문제&lt;/a&gt; &lt;a href="matlab:helpview(strcat(docroot, ''/toolbox/simulink/helptargets.map''), ''cpd_diags_solverdatainconsistency'',''CSHelpWindow'');"&gt;[?]&lt;/a&gt;를 &lt;code&gt;오류&lt;/code&gt; 또는 &lt;code&gt;경고&lt;/code&gt;로 설정해 보십시오(현재 &lt;code&gt;안 함&lt;/code&gt;으로 설정되어 있음).</entry>
    <entry key="MASetArrayBoundsCheckingToWarning">S-Function이 배열 경계 외부에 쓰는지 여부를 검사하려면 &lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'',''{0}'',''ArrayBoundsChecking'');"&gt;배열 경계를 초과함&lt;/a&gt; &lt;a href="matlab:helpview(strcat(docroot, ''/toolbox/simulink/helptargets.map''), ''cpd_diags_arrayboundsexceeded'',''CSHelpWindow'');"&gt;[?]&lt;/a&gt;을 &lt;code&gt;오류&lt;/code&gt; 또는 &lt;code&gt;경고&lt;/code&gt;로 설정해 보십시오(현재 &lt;code&gt;안 함&lt;/code&gt;으로 설정되어 있음).</entry>
    <entry key="MAMsgMultiTaskDataStore">&lt;b&gt;멀티태스크 데이터 저장소&lt;/b&gt; 검사가 ''오류''로 설정되지 않았습니다. 실시간 멀티태스킹 환경에 배포되는 경우 여러 다른 태스크에서 쓰거나 읽어오는 데이터 저장소의 값 무결성이 손상될 위험이 있습니다. &lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'',''{0}'',''MultiTaskDSMMsg'')"&gt;멀티태스크 데이터 저장소&lt;/a&gt; 설정을 ''오류''로 변경해 보십시오.</entry>
    <entry key="MAMsgDuplicateDataStore">&lt;b&gt;중복된 데이터 저장소 이름&lt;/b&gt; 검사가 ''오류''로 설정되지 않았습니다. 데이터 저장소 이름이 중복 사용될 경우 이로 인해 더 상위 모델 범위의 데이터 저장소가 의도치 않게 가려질 수 있습니다. &lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'',''{0}'',''UniqueDataStoreMsg'')"&gt;중복된 데이터 저장소 이름&lt;/a&gt; 설정을 ''오류''로 변경해 보십시오.</entry>
    <entry key="MAMsgDataStoreReadWrite">데이터 저장소를 읽거나 쓰는 순서와 관련된 런타임 진단이 여러 개 있음:</entry>
    <entry key="MATitleDataStoreRWOrder">읽기/쓰기 진단이 Data Store 블록에 대해 활성화되었는지 검사</entry>
    <entry key="MATitletipDataStoreRWOrder">Data Store 블록이 있는 경우 읽기/쓰기 순서 진단 검사가 설정되었는지 확인합니다.</entry>
    <entry key="MAMsgGlobalDataStoreRWOrder">&lt;b&gt;{0} 감지&lt;/b&gt; 검사가 전역적으로 비활성화되어 있습니다. &lt;b&gt;구성 파라미터&lt;/b&gt; 대화 상자의 &lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'',''{1}'',''{2}'')"&gt;데이터 유효성&lt;/a&gt; 페이지에서 이 검사를 활성화해 보십시오.</entry>
    <entry key="MAMsgLocalDataStoreRWOrder">&lt;b&gt;{0} 감지&lt;/b&gt;가 다음 Data Store Memory 블록에 대해 활성화되어 있지 않습니다. &lt;b&gt;구성 파라미터&lt;/b&gt; 대화 상자의 &lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'',''{1}'',''{2}'')"&gt;데이터 유효성&lt;/a&gt; 페이지에서 이 검사를 전역적으로 활성화하거나 다음 블록 모두에 대해 이 검사를 활성화해 보십시오.</entry>
    <entry key="MATitleNonDiscSigDataStore">Data Store 블록 샘플 시간에 모델링 오류가 있는지 검사</entry>
    <entry key="MATitletipNonDiscSigDataStore">Data Store 블록이 연속 샘플 시간 또는 보조 스텝에서 고정됨 샘플 시간을 갖지 않는지 검사합니다.</entry>
    <entry key="MAMsgNonDiscSigDataStore">&lt;p /&gt; 다음의 Data Store Memory, Data Store Read, Data Store Write 블록은 연속 샘플 시간 또는 보조 스텝에서 고정됨 샘플 시간을 갖습니다.</entry>
    <entry key="MAMsgNonDiscSigDataStoreSuggest">&lt;p /&gt;원래 연속 샘플 시간을 갖도록 의도한 것이 아니라면 이러한 블록을 이산 블록으로 만들거나 Memory 블록 또는 Goto 블록과 From 블록으로 바꿔 보십시오.</entry>
    <entry key="MANonContDSMPass"> 모든 Data Store 블록이 이산 샘플 시간을 갖습니다. &lt;font color="#008000"&gt; 통과 &lt;/font&gt;</entry>
    <entry key="MAMultiTaskCheck">&lt;p /&gt; &lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'',''{0}'',''MultiTaskDSMMsg'');"&gt;멀티태스킹 Data Store 블록 감지&lt;/a&gt; &lt;a href="matlab:helpview(strcat(docroot, ''/toolbox/simulink/helptargets.map''), ''cpd_diags_multitaskdatastore'', ''CSHelpWindow'');"&gt;[?]&lt;/a&gt;에 대한 컴파일 시간 진단이 현재 비활성화되어 있습니다. 멀티태스킹 Data Store 블록이 사용되면 대개 Data Store 블록을 사용한 모델링 문제가 있을 수 있음을 의미합니다. &lt;b&gt;구성 파라미터 대화 상자&lt;/b&gt;의 &lt;b&gt;데이터 유효성&lt;/b&gt; 페이지를 사용하여 멀티태스킹 Data Store 블록에 대한 검사를 설정해 보십시오.</entry>
    <entry key="MATitleNonContSigDerivPort">미분 포트를 구동하는 불연속 신호가 있는지 검사</entry>
    <entry key="MATitletipNonContSigDerivPort">미분 포트를 구동하는 불연속 신호를 모델링 문제로 표시하여, 이로 인해 상당한 수의 솔버 재설정이 발생할 수 있음을 나타냅니다.</entry>
    <entry key="MAMsgNonContSigDerivPort">&lt;p /&gt; 정확한 시뮬레이션 결과를 보장하기 위해 솔버는 미분 포트를 구동하는 불연속 신호값의 각 변경 사항에 대한 응답으로 재설정됩니다. 미분 포트를 구동하는 불연속 신호의 인스턴스 중 하나 이상을 제거하면 시뮬레이션 성능이 향상될 수 있습니다. </entry>
    <entry key="MAMsgContSrcLocationHeader"> &lt;tr&gt;&lt;td&gt;&lt;b&gt;블록&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;포트&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;시작 인덱스&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;너비&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;</entry>
    <entry key="MAMsgNonContSigDerivPortSuggest"> &lt;p /&gt; 미분 포트를 구동하는 불연속 신호에 대해 다음 변경 작업을 수행해 보십시오: &lt;ul&gt;&lt;li&gt;신호를 연속으로 만듭니다.&lt;/li&gt; &lt;li&gt;신호를 수신하는 연속 블록을 이산 블록으로 바꿉니다.&lt;/li&gt;&lt;/ul&gt;</entry>
    <entry key="MASimPnATaskTitle">시뮬레이션 정확도</entry>
    <entry key="MASimPnATaskTitleTip">시뮬레이션 정확도 향상을 위한 검사</entry>
    <entry key="MASimRuntimeAccuracyTaskTitle">시뮬레이션 런타임 정확도 진단</entry>
    <entry key="MASimRuntimeAccuracyTaskTitleTip">문제를 찾는 데 도움이 되지만 Simulink 속도를 저하시킬 수 있는 정확도 진단입니다.</entry>
    <entry key="MADataStoreBlocksTaskTitle">Data Store Memory 블록 관리</entry>
    <entry key="MADataStoreBlocksTaskTitleTip">Data Store 블록 사용 향상을 위한 검사로, 문제를 찾는 데 도움이 될 수 있습니다.</entry>
    <entry key="MADiagHasPerformanceHit">&lt;p /&gt; &lt;b&gt;참고&lt;/b&gt;: 이러한 런타임 진단은 시뮬레이션 속도를 상당히 늦출 수 있습니다. 시뮬레이션 중에 이 런타임 진단으로부터 경고나 오류가 발생하지 않는 것을 확인했으면 이 진단을 &lt;code&gt;{0}&lt;/code&gt;(으)로 다시 설정해야 합니다. </entry>
    <entry key="CheckPassed">&lt;b&gt;{0} 감지&lt;/b&gt; &lt;font color="#008000"&gt;통과&lt;/font&gt;</entry>
    <entry key="CheckEnabled">&lt;b&gt;{0} 감지&lt;/b&gt;가 &lt;font color="#008000"&gt;활성화됨&lt;/font&gt;</entry>
    <entry key="MAMsgCouldNotCompileModel">&lt;p /&gt; 모델 &lt;b&gt;{0}&lt;/b&gt;을(를) 컴파일할 수 없습니다.</entry>
    <entry key="ContinuousBlocks">연속 블록</entry>
    <entry key="ZOHBlocks">Zero Order Hold 블록</entry>
    <entry key="MAErrorStackDump">{0} {1,number,integer}번 라인</entry>
    <entry key="CommonMAMuxUsedCheckMsg">잘못 사용된 Mux 블록을 바꾼 후에는 검사를 수행하여 모델에 벡터로 처리된 버스 신호가 포함되어 있지 않은지 확인해야 합니다. </entry>
    <entry key="CommonMAMuxUsedFixMsg">이렇게 하려면 구성 파라미터 창에서 ''버스 신호를 생성하는 데 사용되는 Mux 블록'' 진단을 오류로 설정하고 이 검사를 다시 실행하십시오.</entry>
    <entry key="CommonMAMuxUsedConfigLink">버스 - 버스 신호를 생성하는 데 사용되는 Mux 블록</entry>
    <entry key="CommonMAMuxUsedConfigLink1">버스 - 버스 신호가 벡터로 처리됨</entry>
    <entry key="CommonMAUnableToRunCheckForProperBusOnSubsystem">''버스 사용'' 검사는 최상위 모델에만 사용 가능합니다. 이 검사를 수행하려면 최상위 모델에서 어드바이저를 실행하십시오.</entry>
    <entry key="CommonMAResultCheckBusSignalsFromMux">모델에서 Simulink가 벡터로 처리하는 버스 신호를 식별할 수 있도록 진단 - ''버스 신호를 생성하는 데 사용되는 Mux 블록''을 오류로 설정하는 것이 좋습니다.</entry>
    <entry key="CommonMAResultCheckBusSignalsFromMuxLink">버스: 버스 신호를 생성하는 데 사용되는 Mux 블록</entry>
    <entry key="CommonMAMuxUsedasBusErrorMsg2">Bus Creator 블록을 제공하는 라이브러리:</entry>
    <entry key="CommonMAMuxUsedasBusErrorMsg3">다음 목록에는 버스 지원 블록에 의해 버스 신호로 처리되는 출력을 가진 Mux 블록이 포함되어 있습니다. 이 목록의 각 Mux 블록은 그 뒤에 해당 Mux 블록의 출력을 버스로 처리하는 버스 지원 블록이 옵니다.</entry>
    <entry key="CommonMAMuxUsedasBusErrorMsg4">다음 Mux 블록이 서로 다른 차원의 신호를 포함하는 버스 신호를 출력함:</entry>
    <entry key="CommonMAMuxUsedasBusErrorMsg5">다음 Mux 블록이 서로 다른 데이터형의 신호를 포함하는 버스 신호를 출력함:</entry>
    <entry key="CommonMAMuxUsedasBusErrorMsg6">다음 Mux 블록이 서로 다른 유형(실수/복소수)의 신호를 포함하는 버스 신호를 출력함:</entry>
    <entry key="CommonMAMuxUsedasBusErrorMsg7">다음 Mux 블록이 서로 다른 샘플링 모드(샘플 기반/프레임 기반)의 신호를 포함하는 버스 신호를 출력함:</entry>
    <entry key="CommonMAMuxUsedasBusErrorMsg8">다음 Mux 블록이 서로 다른 스토리지 클래스의 신호를 포함하는 버스 신호를 출력함:</entry>
    <entry key="CommonMAMuxUsedasBusErrorMsg9">모델이 버스를 올바르게 사용하고 있습니다. 하지만, 모델이 잘못된 버스 사용을 초래할 수 있는 향후 변경을 감지하도록 구성되지 않았기 때문에 이 검사가 실패했습니다. 이러한 변경을 감지하도록 하려면 구성 파라미터에서 ''버스 신호가 벡터로 처리됨'' 진단을 오류로 설정하고 검사를 다시 실행하십시오. </entry>
    <entry key="CommonMABusToVectorErrorMsg1">Simulink가 묵시적으로 벡터로 변환하는 버스 신호가 모델에 포함되어 있습니다. Simulink에서 향후 기능을 활용하려면 모델이 이러한 신호를 벡터로 명시적으로 변환해야 합니다. 이렇게 하려면 ''Bus to Vector'' 변환 블록을 버스 신호와 버스 신호가 전달되는 블록 입력 포트 사이에 삽입하거나 다음 명령을 사용하십시오. </entry>
    <entry key="CommonMABusToVectorErrorMsg2">''Bus to Vector'' 변환 블록을 제공하는 라이브러리:  </entry>
    <entry key="CommonMABusToVectorErrorMsg3">식별된 버스 신호를 벡터로 변환한 후 잘못된 버스 사용을 초래할 수 있는 향후 변경을 감지하도록 하려면 구성 파라미터를 열고 ''버스 신호가 벡터로 처리됨'' 진단을 오류로 설정한 후 검사를 다시 실행하십시오. </entry>
    <entry key="CommonMABusToVectorErrorMsg4">다음 버스 신호는 벡터로 처리됨:</entry>
    <entry key="CommonMABusToVectorMsg"> 입력 포트에 전달하는 버스 신호   </entry>
    <entry key="MAErrorSimulationNotStopped">Simulink가 모델 ''{0}''을(를) 시뮬레이션하는 중입니다. 시뮬레이션을 중지하고 다시 시도하십시오.</entry>
    <entry key="MAErrorModelFileNotWritable">모델 {0}은(는) 쓸 수 없습니다. 모델을 쓸 수 있도록 파일 권한을 변경하십시오.</entry>
    <entry key="MAConfirmYes">예</entry>
    <entry key="MAConfirmNo">아니요</entry>
    <entry key="rapidAccelSimStart">다음 모델에 대한 고속 액셀러레이터 시뮬레이션을 시작하는 중: {0}</entry>
    <entry key="rapidAccelCheckingIfUpToDate">구조적 체크섬을 계산하는 중</entry>
    <entry key="rapidAccelBuildStart">다음 모델에 대한 고속 액셀러레이터 타깃을 빌드하는 중: {0}</entry>
    <entry key="rapidAccelTargetIsUpToDate">고속 액셀러레이터 타깃이 최신 상태임</entry>
    <entry key="rapidAccelTargetIsOutOfDate">고속 액셀러레이터 타깃이 최신 상태가 아님</entry>
    <entry key="rapidAccelBuildFinish">### 다음 모델에 대한 고속 액셀러레이터 타깃을 성공적으로 빌드함: {0}</entry>
    <entry key="rapidAccelBuildFailed">고속 액셀러레이터 모드에서 모델 ''{0}''을(를) 시뮬레이션하는 독립형 실행 파일을 빌드할 수 없습니다.</entry>
    <entry key="rapidAccelBuildFailedCSFunctionSourceNotFound">Unable to build a standalone executable to simulate the model ''{0}'' in rapid accelerator mode: could not find the C S-function source file ''{1}''. Rapid Accelerator simulations require source files for certain S-functions (e.g. level 1 S-functions) to be in the same folder as the S-functions' MEX files. Note that additional S-function source files can be specified through the S-function block's ''S-function modules'' field and through the use of a rtwmakecfg.m file. For more information, please consult the S-function documentation.</entry>
    <entry key="rapidAccelBuildFailedMaybeCPP">	빌드 실패는 ''{0}''에 사용자 지정 C++ 코드가 사용되었기 때문에 발생한 것일 수 있습니다. 고속 액셀러레이터는 현재 C 코드 생성만 지원합니다.</entry>
    <entry key="rapidAccelDoesNotSupportImages">모델 ''{0}''이(가) 이미지 데이터형을 사용하기 때문에, 고속 액셀러레이터 모드에서 이 모델을 시뮬레이션할 수 없습니다.</entry>
    <entry key="rapidAccelExeError">모델 ''{0}''을(를) 시뮬레이션하는 중에 고속 액셀러레이터 프로세스가 비정상적으로 종료되었습니다. \n{1}</entry>
    <entry key="rapidAccelAssertion"> 시간 {1}에 ''{0}''에서 어설션이 감지됨</entry>
    <entry key="rapidAccelGccVersion"> gcc 버전 ''{0}''을(를) 사용하고 있습니다. 이 버전의 gcc는 고속 액셀러레이터에서 지원되지 않습니다. 현재 고속 액셀러레이터에서 지원되는 버전은 ''{1}'' 이상입니다.</entry>
    <entry key="rapidAccelUnableToLoadExtInputsWrongNumber"> An error occurred while evaluating the external inputs for the model ''{0}'': ''{0}'' has {2} root inport blocks, but {1} external inputs were specified in the Data Import/Export page of the Configuration Parameters dialog for ''{0}''. The number of external inputs specified in the Data Import/Export page must equal 1 or must equal the number of root inport blocks in the model. </entry>
    <entry key="rapidAccelUnableToLoadExtInputsBadFormat"> 모델 ''{0}''에 대한 외부 입력을 평가하는 중 오류가 발생함: 고속 액셀러레이터 모드에서 외부 입력은 double형 배열 또는 리프가 MATLAB timeseries인 구조체여야 합니다. </entry>
    <entry key="rapidAccelDatasetExtInputInvalidNumberOfExtInputs">The first external input data for model ''{0}'' is of type Simulink.SimulationData.Dataset. Rapid Accelerator supports external input of this type only if there is exactly one external input specified.</entry>
    <entry key="rapidAccelDatasetExtInputNonScalarDataset">The external input data for model ''{0}'' is of type Simulink.SimulationData.Dataset. The dimension of the input is not scalar. Rapid Accelerator supports external input of this type only if the Simulink.SimulationData.Dataset object is scalar.</entry>
    <entry key="rapidAccelDatasetExtInputInvalidNumberOfElements">The external input data for model ''{0}'' is of type Simulink.SimulationData.Dataset. Rapid Accelerator supports external input of this type only if there is exactly the same number of elements in the Simulink.SimulationData.Dataset instance as the number of root inport blocks in the model. Root inport blocks include Enable blocks and Trigger blocks with 'Trigger type' set to rising, falling, or either.</entry>
    <entry key="rapidAccelDatasetExtInputInvalidNumberOfSamples">모델 ''{0}''에 대한 외부 입력 데이터의 유형이 Simulink.SimulationData.Dataset입니다. 고속 액셀러레이터는 데이터셋에 포함된 각 timeseries에 0이 아닌 개수의 데이터 점이 포함된 경우에만 이 유형의 외부 입력을 지원합니다.</entry>
    <entry key="rapidAccelMCOSObjExtInputsNotSupported">The external input data for model ''{0}'' has signal values of type ''{1}'' that are MATLAB objects. Rapid accelerator does not support external inputs of such data types</entry>
    <entry key="rapidAccelInportBoundsNotHonoured"> One or more root inports in the model ''{0}'' has a nonempty OutMin or OutMax parameter. However, bounds on root inport data are not enforced in rapid accelerator; the data may exceed the bounds during a simulation, without warning or error. </entry>
    <entry key="rapidAccelCppNotSupported">고속 액셀러레이터는 C 코드만 지원합니다. 구성 세트에 설정되어 있기 때문에 C++에서는 모델 ''{0}''을(를) 빌드하지 않습니다. 따라서 빌드하지 못할 수 있습니다</entry>
    <entry key="rapidAccelSimOptNotSupported">Simulation option ''{0}'' is not supported in rapid accelerator mode</entry>
    <entry key="rapidAccelSimOptInvVal">The sim command option ''{0}'' should be either of character vector type or of numeric type for rapid accelerator.</entry>
    <entry key="rapidAccelInvCmdlSimParam">The sim command parameter ''{0}'' and its value is not a valid parameter, value pair. Setting the parameter produces the following error: {1} : {2} </entry>
    <entry key="rapidAccelSimOptNotSupportedWithoutUpdate">Simulation option ''{0}'' is not supported in rapid accelerator mode with up-to-date check off.</entry>
    <entry key="rapidAccelInlineParametersOff">모델 ''{0}''에 대해 파라미터는 기본적으로 조정 가능형입니다. ''구성 파라미터 &gt; 코드 생성 &gt; 최적화 &gt; 디폴트 파라미터 동작''을 ''인라인''으로 설정하고 조정 가능형 파라미터도 지정하는 것이 좋습니다.</entry>
    <entry key="rapidAccelUnableToStartExecutable">Unable to start rapid accelerator executable for model ''{0}'', expected to find PID ''{1}''</entry>
    <entry key="rapidAccelUnableToFindPort">Unable to find an unused TCP/IP port to connect to the rapid accelerator target for model ''{0}''</entry>
    <entry key="rapidAccelCannotGetPID">Unable to determine if rapid accelerator target for ''{0}'' started successfully</entry>
    <entry key="rapidAccelUnableToConnect">외부 모드를 통해 ''{0}''에 대한 고속 액셀러레이터 타깃에 연결할 수 없음: {1}</entry>
    <entry key="rapidAccelExtModeConnectFailed">Rapid accelerator target connection failed</entry>
    <entry key="rapidAccelTgtConnConnectFailed">Due to an internal connection problem, these simulation features are not available in Rapid Accelerator mode:\n  -tuning structured parameters during simulation\n  -streaming data to Simulation Data Inspector\n  -streaming data to Simulink Dashboard blocks</entry>
    <entry key="rapidAccelExeModeStartFailed">모델 ''{0}''에 대한 고속 액셀러레이터 타깃을 시작하지 못했습니다.</entry>
    <entry key="rapidAccelExeInterrupted">Simulation interrupted</entry>
    <entry key="rapidAccelSettingUp">고속 액셀러레이터 모드에서 시뮬레이션하도록 설정하는 중</entry>
    <entry key="rapidAccelBuilding">고속 액셀러레이터 타깃을 빌드하는 중</entry>
    <entry key="rapidAccelLaunching">고속 액셀러레이터 타깃을 실행하는 중</entry>
    <entry key="rapidAccelConnecting">고속 액셀러레이터 타깃에 연결하는 중</entry>
    <entry key="rapidAccelRunning">고속 액셀러레이터 모드에서 실행하는 중</entry>
    <entry key="rapidAccelRunningInMultithreading">{0,number,integer}개의 워커 스레드를 사용하여 고속 액셀러레이터 모드에서 실행하는 중</entry>
    <entry key="rapidAccelSecondSim">모델 {0}의 고속 액셀러레이터 시뮬레이션 또는 빌드가 이미 실행 중입니다. 두 번째 빌드 또는 시뮬레이션을 시작할 수 없습니다.</entry>
    <entry key="rapidAccelIncorrectOutputs">Incorrect number of outputs specified for model {0} in the Configuration Parameters dialog box on the Data Import/Export page. When specifying that root-level outports are to be returned individually, the number of fields in the comma separated list must be equal to the number of root-level outports and the fields must be valid MATLAB variable names .</entry>
    <entry key="rapidAccelInvalidOutputsVar">모델 {0}에 지정된 출력 변수가 유효하지 않습니다.</entry>
    <entry key="rapidAccelToFileBlksNotSupportedWithoutUpdate">모델 {0}에 ToFile 블록이 포함되어 있습니다. ToFile 블록은 최신 검사가 해제된 상태로 시뮬레이션하는 경우 지원되지 않습니다.</entry>
    <entry key="rapidAccelExeNotFound">모델 ''{0}''에 실행 가능한 고속 액셀러레이터를 찾을 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="BuildRapidAcceleratorTargetFix"&gt; &lt;cmd&gt;Simulink.BlockDiagram.buildRapidAcceleratorTarget(''{0}'')&lt;/cmd&gt; &lt;txt&gt;모델 ''{0}''에 대한 고속 액셀러레이터 타깃을 빌드하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;

</entry>
    <entry key="rapidAccelBadBlockDiagramParameterNonexistent"> Error while evaluating the block diagram parameter ''{2}'' for the model ''{0}'': the value of ''{2}'' was specified as ''{1}'' but there is no variable named ''{1}'' in the base workspace or in the model workspace of ''{0}''. Please provide a valid literal value or a valid variable name for the value of ''{2}''. </entry>
    <entry key="rapidAccelBadBlockDiagramParameterExpectingNumeric"> Error while evaluating the block diagram parameter ''{2}'' for the model ''{0}'': the value of ''{2}'', which must be numeric, was specified as ''{1}'', but ''{1}'' evaluated to a non-numeric value. Please specify a numeric value for ''{2}''. </entry>
    <entry key="rapidAccelAutoSolverError">Rapid accelerator with up to date check off is not compatible with auto solver. Please turn on the up to date check or use a non auto solver.</entry>
    <entry key="rapidAccelExtModeTestingError">Error while setting the ExtModeTesting parameter for the model, {0},: {1}, {2}.</entry>
    <entry key="rapidAccelOutportInvalidArrayDataLogging">The ''Array'' format for saving outputs to the workspace requires all signals connected to the root outports to be scalar or 1-D arrays. Specify ''Configuration Parameters &gt; Data Import/Export &gt; Format'' to either ''Structure'' or ''StructureWithTime''.</entry>
    <entry key="NoRapidAccelSimModeForRootFcnCall">Rapid Accelerator simulation
    mode is not supported for model ''{0}'' because the model contains a
    root-level inport (''{1}'') that is generating a function-call.</entry>
    <entry key="rapidAccelSFunctionNeedsToBeRegenerated">A bus used as
    an input or output to S-Function block ''{0}'' had padding added to it by
    Simulink. Before using this S-function in a top model in a Rapid Accelerator
    simulation, regenerate the S-function with the tool originally used to
    create it. The &lt;a href="matlab:sl(''upgradeadvisor'', ''{1}'')"&gt;Upgrade
    Advisor&lt;/a&gt; check ''Check model for known block upgrade issues requiring
    compile time information'' can assist in identifying and automatically
    updating all such blocks.</entry>
    <entry key="rapidAccelSFunctionBuilderNeedsToBeRegenerated">A bus
    used as an input or output to S-Function Builder block ''{0}'' had padding
    added to it by Simulink. Before using this S-function in a top model in a
    Rapid Accelerator simulation, regenerate the S-function with the S-Function
    Builder. The &lt;a href="matlab:sl(''upgradeadvisor'', ''{1}'')"&gt;Upgrade
    Advisor&lt;/a&gt; check ''Check model for known block upgrade issues requiring
    compile time information'' can assist in identifying and automatically
    updating all such blocks.</entry>
    <entry key="rapidAccelSimHardwareAccelRapidAccelUpToDateCheck">모델이 파라미터 'SimHardwareAccelerarion'이 'native'로 설정된 상태에서 다른 CPU로 컴파일되었기 때문에 'RapidAcceleratorUpToDateCheck'가 'Off'로 설정된 상태로는 시뮬레이션할 수 없습니다. 모델을 현재 CPU에 대해 다시 컴파일하려면 'RapidAcceleratorUpToDateCheck'를 'On'으로 설정한 상태에서 모델을 시뮬레이션하십시오.</entry>
    <entry key="rapidAcceleratorExternalModeConnectStage">고속 액셀러레이터 프로세스에 연결하고 시뮬레이션</entry>
    <entry key="rapidAcceleratorExeErrorBeforeConnect"> An error occurred while attempting to connect to the Rapid Accelerator target for the model ''{0}'': ''{1}'' </entry>
    <entry key="rapidAcceleratorConnectTakingTooLong"> 모델 ''{0}''의 고속 액셀러레이터 시뮬레이션이 시작하는 데 평소보다 시간이 더 걸립니다. </entry>
    <entry key="rapidAccelSFcnDataTypeAccess"> The s-function ''{0}'' attempted to make a call to the simstruct method ''{1}''. The method ''{1}'' is not allowed in s-functions used in Rapid Accelerator mode. The call to ''{1}'' may have been made indirectly through simstruct methods such as ssGetDataTypeProperties or ssGetNumBusElements.</entry>
    <entry key="rapidAccelSFcnRegDataType"> S-Function ''{0}''이(가) simstruct 메서드 ''{1}''을(를) 호출하려고 시도했습니다. 메서드 ''{1}''은(는) 고속 액셀러레이터 모드에서 사용되는 S-Function에 사용할 수 없습니다.</entry>
    <entry key="rapidAccelSFcnMex"> The s-function ''{0}'' attempted to make a call to the mex API function ''{1}''. Calls to ''{1}'' are not allowed in s-functions used in Rapid Accelerator mode.</entry>
    <entry key="rapidAccelSFcnMexFileNotFoundDuringUTDCOffSim"> The mex file for the s-function ''{0}'' could not be found. The Rapid Accelerator simulation for the model ''{1}'' was aborted. Please place the mex file for ''{0}'' on the MATLAB path. </entry>
    <entry key="rapidAccelSFcnsWithoutSourceNotSupportedMinGW"> 소스 코드가 S-Function의 MEX 파일과 동일한 디렉터리에 있지 않으면서 인라인이 아닌 C S-Function이 모델 ''{0}''에 포함되어 있습니다. MinGW를 사용할 때는 고속 액셀러레이터 모드에서 S-Function을 이런 방식으로 사용할 수 없습니다. 고속 액셀러레이터 모드에서 ''{0}''을(를) 실행하려면 컴파일러를 변경하거나 ''{0}''에 포함된 각 S-Function의 소스 코드가 S-Function의 MEX 파일과 동일한 디렉터리에 있도록 하십시오. </entry>
    <entry key="rapidAccelSFcnSourceExistsButUsingMexFileAnyways"> The source code for the s-function ''{0}'' exists on the MATLAB path but is not in the same directory as the s-function's MEX file. The current Rapid Accelerator simulation will dynamically load the s-function's MEX file - the source code for ''{0}'' will not be compiled into the Rapid Accelerator target. </entry>
    <entry key="rapidAccelSFcnErrorDuringrtwmakecfg"> An error occurred while calling rtwmakecfg for the s-function ''{0}'': the 'sourcePath' field of the structure returned by rtwmakecfg must be a cell array of strings. </entry>
    <entry key="rapidAccelSFcnLoaderBlockError"> 고속 액셀러레이터 모드에서 S-Function ''{0}''에 대해 MEX 파일을 동적으로 불러오는 중에 내부 오류가 발생함: ''{1}''. ''{0}''의 소스 코드를 제공하거나 표준 모드나 액셀러레이터 모드에서 모델을 시뮬레이션해 보십시오. </entry>
    <entry key="rapidAccelSFcnLoaderSFcnInfoFileNameNull"> 고속 액셀러레이터 모드를 초기화하는 중에 내부 오류가 발생함: MEX S-Function 정보 파일 이름이 고속 액셀러레이터 타깃으로 제공되지 않았습니다. 시뮬레이션을 다시 시작하십시오. </entry>
    <entry key="rapidAccelSFcnLoaderSFcnInfoFileError"> 고속 액셀러레이터 모드에서 MEX S-Function을 동적으로 불러오려고 준비하는 중에 내부 오류가 발생함: ''{0}'' </entry>
    <entry key="rapidAccelSFcnLoaderMexFileError"> 고속 액셀러레이터 모드에서 S-Function MEX 파일 ''{0}''을(를) 처리하는 중에 내부 오류가 발생함: ''{1}''. 해당 S-Function의 소스 코드를 제공하거나 표준 모드 또는 액셀러레이터 모드에서 모델을 시뮬레이션해 보십시오. </entry>
    <entry key="rapidAccelInitialStateError"> 모델 ''{0}''의 초기 상태를 가져오는 중에 오류가 발생했습니다. </entry>
    <entry key="rapidAccelCollapsedParameterComplexityMismatch"> The value of ''{0}'' is ''{1}'' but was ''{2}'' when the Rapid Accelerator target for ''{3}'' was built. The complexity of the value of the expression ''{0}'' cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelCollapsedParameterLengthMismatch"> The value of the expression '{0}'' has ''{1}'' elements but had ''{2}'' elements when the Rapid Accelerator target for ''{3}'' was built. The number of elements in the value of the expression ''{0}''  cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelCollapsedParameterUnableToCast"> The value of the expression ''{0}'' has type ''{1}'' but had type ''{2}'' when the Rapid Accelerator target for ''{3}'' was built. The type of the value of the expression ''{0}''  cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelMaskParameterEvaluationError"> An error occurred while computing the value of the expression ''{0}'' for the block ''{1}''.</entry>
    <entry key="rapidAccelMaskParameterComplexityMismatch"> An error occurred while computing the value of the expression ''{0}'' for the block ''{1}'': the value of ''{0}'' is ''{2}'' but was ''{3}'' when the Rapid Accelerator target for ''{4}'' was built.  The complexity of the value of the expression ''{0}'' cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelMaskParameterLengthMismatch"> An error occurred while computing the value of the expression ''{0}'' for the block ''{1}'': the value of ''{0}'' has ''{2}'' elements but had ''{3}'' elements when the Rapid Accelerator target for ''{4}'' was built. The number of elements in the value of the expression ''{0}'' cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelMaskParameterUnableToCast"> An error occurred while computing the value of the expression ''{0}'' for the block ''{1}'': the value of ''{0}'' has type ''{2}'' but had type ''{3}'' when the Rapid Accelerator target for ''{4}'' was built. The type of the value of the expression ''{0}''  cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelSparseParameterLengthMismatch"> The parameter ''{0}'' of the block ''{1}'' has ''{2}'' non zero elements but had ''{3}'' at build time. The number of non zero elements in the value of ''{0}''  cannot increase. </entry>
    <entry key="rapidAccelSparseParameterShapeMismatch"> The shape of the sparse expression / variable ''{0}'' has ''{1}'' columns but had ''{2}'' columns when the Rapid Accelerator target for ''{3}'' was built. The number of columns in the value of the sparse expression / variable ''{0}''  cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelSparseParameterComplexityMismatch"> The value of ''{0}'' is ''{1}'' but was ''{2}'' when the Rapid Accelerator target for ''{3}'' was built. The complexity of the value of the sparse expression / variable ''{0}'' cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelSparseParameterUnableToCast"> The value of the sparse expression / variable ''{0}'' has type ''{1}'' but had type ''{2}'' when the Rapid Accelerator target for ''{3}'' was built. The type of the value of the sparse expression / variable ''{0}''  cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelSparseParameterInvalidType"> 희소 표현식/변수 ''{0}''의 유형이 ''{1}''입니다. 이 유형은 숫자형 런타임 파라미터에는 허용되지 않습니다. 이 파라미터에 대해 숫자형 값/표현식을 제공하십시오.</entry>
    <entry key="rapidAccelSparseParameterPatternMismatch"> The sparsity pattern of parameter ''{0}'' of the block ''{1}'' is not allowed to change.</entry>
    <entry key="rapidAccelTransformedParameterArgComplexityMismatch"> The value of the expression ''{0}'' is ''{1}'' but was ''{2}'' when the Rapid Accelerator target for ''{3}'' was built. The complexity of the value of the expression ''{0}'' cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelTransformedParameterArgSizeMismatch"> The value of the expression ''{0}'' has ''{1}'' dimension but had ''{2}'' dimension when the Rapid Accelerator target for ''{3}'' was built. The dimension of the expression ''{0}'' cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelTransformedParameterArgTypeMismatch"> The value of the expression ''{0}'' has type ''{1}'' but had type ''{2}'' when the Rapid Accelerator target for ''{3}'' was built. The type of the value of the expression ''{0}'' cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelTransformedParameterLengthMismatch"> The transformed parameter has ''{0}'' elements but had ''{1}'' elements when the Rapid Accelerator target for ''{2}'' was built. The number of elements of the transformed parameter cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelTransformedParameterComplexityMismatch"> The transformed parameter is ''{0}'' but was ''{1}'' when the Rapid Accelerator target for ''{2}'' was built. The complexity of the transformed parameter cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelTransformedParameterTypeMismatch"> The transformed parameter has type ''{0}'' but had type ''{1}'' when the Rapid Accelerator target for ''{2}'' was built. The type of the transformed parameter cannot change when running up-to-date-check-off simulations. </entry>
    <entry key="rapidAccelBusParameterStructVariableMismatch">블록 ''{1}''의 파라미터 ''{0}''은(는) Simulink Compiler 시뮬레이션에서 또는 RapidAcceleratorUpToDateCheckOff가 'off'인 경우 조정할 수 없음: 파라미터 값을 제공하는 구조체가 파라미터의 버스 유형과 일치하지 않습니다.</entry>
    <entry key="TopModelPilERT">Unable to run "{0}" in SIL or PIL simulation mode. Embedded Coder is not installed or licensed. To resolve this, ensure that Embedded Coder is installed and licensed.</entry>
    <entry key="TopModelPilSLC">SIL 또는 PIL 시뮬레이션 모드에서 "{0}"을(를) 실행할 수 없습니다. Simulink Coder가 설치되어 있지 않거나 라이선스가 부여되지 않았습니다. 이 문제를 해결하려면 Simulink Coder를 설치하고 라이선스를 부여받으십시오.</entry>
    <entry key="pilRunning">{0} 모드에서 실행 중(중단하려면 명령 창에 CTRL+C 누르기)</entry>
    <entry key="MAMergeAnalysisError">Merge 분석을 완료할 수 없음:</entry>
    <entry key="MADataStoreAnalysisRBWError">Data Store 쓰기 전 읽기 분석을 완료할 수 없음</entry>
    <entry key="MAMergeAnalysisInvalidMaxAnalysisTime">최대 분석 시간은 양의 스칼라 값이어야 합니다.</entry>
    <entry key="MAMergeAnalysisSummaryHeading">요약</entry>
    <entry key="MAMergeAnalysisDetailHeading">세부 정보</entry>
    <entry key="MAMergeAnalysisDescOverall">Merge 블록을 상호 연결하여 트리 구조를 생성할 수 있습니다. 아래 리포트는 동일한 트리에 있는 Merge 블록이 하나의 그룹으로 분석된 결과를 보여줍니다.</entry>
    <entry key="MAMergeAnalysisDescPassed">이 Merge 블록 트리는 올바르게 사용되고 있습니다.</entry>
    <entry key="MAMergeAnalysisDescUnknown">Merge 분석 절차가 주어진 시간 내에 분석을 완료하지 못했습니다.</entry>
    <entry key="MAMergeAnalysisTotalMergeTrees">병합 트리의 총 개수</entry>
    <entry key="MAMergeAnalysisStatus">상태</entry>
    <entry key="MAMergeAnalysisMergeTree">병합 트리</entry>
    <entry key="MAMergeAnalysisDescription">설명</entry>
    <entry key="MAMergeAnalysisHeadingFailed">실패</entry>
    <entry key="MAMergeAnalysisHeadingPassed">통과</entry>
    <entry key="MAMergeAnalysisHeadingWarning">경고</entry>
    <entry key="MAMergeAnalysisHeadingUnknown">알 수 없음</entry>
    <entry key="MAMergeAnalysisProblemForcedRun">블록 {0} 및 {1}은(는) 동일한 Merge 블록 트리를 구동하므로 동일한 시간 스텝에서 실행할 수 있습니다.</entry>
    <entry key="MAMergeAnalysisForDetailsSee">Merge 블록 사용에 대한 자세한 내용은 다음을 참조하십시오.</entry>
    <entry key="MAMergeAnalysisMerge">병합</entry>
    <entry key="MAMsgAnd">및</entry>
    <entry key="MAMsgBlock">블록</entry>
    <entry key="MAMsgBlocks">블록</entry>
    <entry key="MAUnableToRunCheckOnSubsystem">이 검사는 최상위 모델에만 사용 가능합니다. 따라서 이 검사를 수행하려면 최상위 모델에서 모델 어드바이저를 실행하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckError">Outport 및 Merge 초기화 파라미터에 대한 검사를 완료할 수 없습니다.</entry>
    <entry key="MAOutportCondSubsysCheckLibraryBlock">라이브러리 블록</entry>
    <entry key="MAOutportCondSubsysCheckInstance">인스턴스</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOverall">Outport 블록 사용 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOverall">이 검사는 단순 방식 초기화 모드로 마이그레이션 시 Outport 블록과 조건부 서브시스템에 발생하는 문제를 찾아 보고합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOverall">이 모델이 단순 방식 초기화 모드를 사용하고 있지 않습니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOverallHasError">아래에 표시된 실패한 하위 검사가 모두 해결되도록 모델을 수정한 후 이 검사를 다시 실행하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOverallNoErrorButHasWarning">아래에 표시된 하위 검사에서 보고된 모든 경고가 해결되었는지 확인하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOverallNoErrorNoWarning">Outport 블록 또는 조건부 서브시스템과 관련된 메시지가 발견되지 않았습니다. 이 모델은 구성 파라미터를 사용하여 단순 방식 초기화 모드로 마이그레이션할 수 있습니다.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingBlockDiagramErrorNeedStrictBusMode">버스 진단 설정 확인</entry>
    <entry key="MAOutportCondSubsysCheckDescBlockDiagramErrorNeedStrictBusMode">구성 파라미터 대화 상자의 연결성 진단 창에서 ''버스 신호를 생성하는 데 사용되는 Mux 블록'' 옵션이 ''오류''로 설정되었는지 확인하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckStatusBlockDiagramErrorNeedStrictBusMode">이 모델에 대해 잘못된 버스 진단 설정이 감지되었습니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionBlockDiagramErrorNeedStrictBusMode">''버스 신호를 생성하는 데 사용되는 Mux 블록'' 옵션을 ''오류''로 설정한 후 오류 없이 모델이 업데이트되는지 확인하십시오.</entry>
    <entry key="MAMergeBlockCheckLibraryBlock">라이브러리 블록</entry>
    <entry key="MAMergeBlockCheckInstance">인스턴스</entry>
    <entry key="MAMergeBlockCheckHeadingLibraryBlockErrorMigration">마이그레이션할 수 없는 인스턴스가 있는 라이브러리 블록이 있는지 검사</entry>
    <entry key="MAMergeBlockCheckDescLibraryBlockErrorMigration">모델에서 라이브러리와 연결된 블록의 모든 인스턴스를 단순 방식 초기화 모드로 안전하게 마이그레이션할 수 있는지 확인합니다.</entry>
    <entry key="MAMergeBlockCheckStatusLibraryBlockErrorMigration">다음 라이브러리 블록에는 단순 방식 초기화 모드로 마이그레이션할 수 없는 인스턴스가 한 개 이상 있거나 서로 다른 마이그레이션 경로를 갖는 인스턴스가 두 개 이상 있습니다.</entry>
    <entry key="MAMergeBlockCheckRecActionLibraryBlockErrorMigration">이러한 각 블록에 대해 해당 인스턴스의 하위 검사 결과를 검토하고 적합한 정정 조치를 정하십시오.</entry>
    <entry key="MAMergeBlockCheckHeadingLibraryBlockWarningMigration">경고가 발생한 인스턴스가 있는 라이브러리 블록이 있는지 검사</entry>
    <entry key="MAMergeBlockCheckDescLibraryBlockWarningMigration">경고가 발생한 인스턴스가 있는 라이브러리 블록을 식별합니다.</entry>
    <entry key="MAMergeBlockCheckStatusLibraryBlockWarningMigration">다음 각 라이브러리 블록에는 하위 검사 경고가 발생한 인스턴스가 하나 이상 있습니다.</entry>
    <entry key="MAMergeBlockCheckRecActionLibraryBlockWarningMigration">경고가 모두 허용 가능한 것인지 확인하십시오. 허용할 수 없는 경고인 경우 단순 방식 초기화 모드로 마이그레이션하기 전에 경고에 따라 모델을 수정하십시오.</entry>
    <entry key="MAMergeBlockCheckHeadingOverall">Merge 블록 사용 검사</entry>
    <entry key="MAMergeBlockCheckDescOverall">이 검사는 단순 방식 초기화 모드로 마이그레이션 시 Merge 블록과 관련된 문제를 찾아 보고합니다. </entry>
    <entry key="MAMergeBlockCheckStatusOverall">이 모델이 단순 방식 초기화 모드를 사용하고 있지 않습니다.</entry>
    <entry key="MAMergeBlockCheckRecActionOverallHasError">아래에 표시된 실패한 하위 검사가 모두 해결되도록 모델을 수정한 후 이 검사를 다시 실행하십시오.</entry>
    <entry key="MAMergeBlockCheckRecActionOverallNoErrorButHasWarning">아래에 표시된 하위 검사에서 보고된 경고를 검토하고 주의가 필요한 항목을 해결하십시오.</entry>
    <entry key="MAMergeBlockCheckRecActionOverallNoErrorNoWarning">Merge 블록과 관련된 메시지가 발견되지 않았습니다. 이 모델은 구성 파라미터를 사용하여 단순 방식 초기화 모드로 마이그레이션할 수 있습니다.</entry>
    <entry key="MAMergeBlockCheckHeadingBlockDiagramErrorNeedMergeDiagnostics">Merge 블록의 런타임 진단 설정 검사</entry>
    <entry key="MAMergeBlockCheckDescBlockDiagramErrorNeedMergeDiagnostics">구성 파라미터 대화 상자에서 Merge 블록의 ''동일한 시간 스텝에서 실행되는 여러 개의 구동 블록 감지'' 옵션이 ''오류''로 설정되었는지 확인하십시오.</entry>
    <entry key="MAMergeBlockCheckStatusBlockDiagramErrorNeedMergeDiagnostics">이 모델에 대한 Merge 블록에 대해 잘못된 런타임 진단 설정이 감지되었습니다.</entry>
    <entry key="MAMergeBlockCheckRecActionBlockDiagramErrorNeedMergeDiagnostics">''동일한 시간 스텝에서 실행되는 여러 개의 구동 블록 감지'' 옵션을 ''오류''로 설정한 후 오류 없이 모델이 시뮬레이션되는지 확인하십시오.</entry>
    <entry key="MAModelLevelMessagesCheckHeadingOverall">모델 수준의 메시지가 있는지 검사</entry>
    <entry key="MAModelLevelMessagesCheckDescOverall">이 검사는 단순 방식 초기화 모드로 마이그레이션 시 모델 수준의 메시지를 찾아 보고합니다.</entry>
    <entry key="MAModelLevelMessagesCheckStatusOverall">이 모델이 해결해야 하는 몇몇 모델 수준의 메시지를 보고했습니다.</entry>
    <entry key="MAModelLevelMessagesCheckRecActionOverallHasError">아래에 표시된 실패한 하위 검사가 모두 해결되도록 모델을 수정한 후 이 검사를 다시 실행하십시오.</entry>
    <entry key="MAModelLevelMessagesCheckRecActionOverallNoErrorButHasWarning">아래에 표시된 하위 검사에서 보고된 경고를 검토하고 주의가 필요한 항목을 해결하십시오.</entry>
    <entry key="MAModelLevelMessagesCheckRecActionOverallHasErrorOtherChecksFail">또한, 아래에 표시된 실패한 하위 검사를 모두 해결하도록 모델을 수정한 후 이 검사를 다시 실행하십시오.</entry>
    <entry key="MAModelLevelMessagesCheckRecActionOverallNoErrorButHasWarningOtherChecksFail">또한, 아래에 표시된 하위 검사에서 보고된 경고를 검토하고 주의가 필요한 항목을 해결하십시오.</entry>
    <entry key="MAModelLevelMessagesCheckRecActionOtherChecks">다음 검사를 실행하고 보고된 문제를 해결해야 함:</entry>
    <entry key="MAModelLevelMessagesCheckHeadingBlockDiagramWarningClassicMode">단순 방식 초기화 모드 설정 확인</entry>
    <entry key="MAModelLevelMessagesCheckDescBlockDiagramWarningClassicMode">구성 파라미터 대화 상자에서 ''과소 지정된 초기화 감지'' 파라미터가 ''단순 방식''으로 설정되었는지 확인합니다.</entry>
    <entry key="MAModelLevelMessagesCheckStatusBlockDiagramWarningClassicMode">이 모델이 단순 방식 초기화 모드를 사용하고 있지 않습니다.</entry>
    <entry key="MAModelLevelMessagesCheckRecActionBlockDiagramWarningClassicMode">이 모델의 &lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;과소 지정된 초기화 감지&lt;/sldiag&gt; 설정을 단순 방식으로 변경하십시오.</entry>
    <entry key="MAModelLevelMessagesCheckHeadingModelReferenceErrorModelRefNeedConsistentOutportInit">Model 블록이 단순 방식 초기화 모드를 사용하고 있는지 확인</entry>
    <entry key="MAModelLevelMessagesCheckDescModelReferenceErrorModelRefNeedConsistentOutportInit">모든 참조된 모델이 단순 방식 초기화 모드를 사용하고 있는지 확인합니다.</entry>
    <entry key="MAModelLevelMessagesCheckStatusModelReferenceErrorModelRefNeedConsistentOutportInit">다음 Model 블록에서 참조하는 모델이 단순 방식 초기화 모드로 마이그레이션되지 않았습니다.</entry>
    <entry key="MAModelLevelMessagesCheckRecActionModelReferenceErrorModelRefNeedConsistentOutportInit">아래에 표시된 하위 검사에서 보고된 경고를 검토하고 주의가 필요한 항목을 해결하십시오. 보고된 오류가 없으면 [과소 지정된 초기화 감지] 모드를 [단순 방식]으로 변경할 수 있습니다.</entry>
    <entry key="MAMergeBlockCheckHeadingMergeErrorSingleInput">단일 입력 Merge 블록이 있는지 검사</entry>
    <entry key="MAMergeBlockCheckDescMergeErrorSingleInput">입력 포트가 한 개만 있는 Merge 블록이 없는지 확인합니다.</entry>
    <entry key="MAMergeBlockCheckStatusMergeErrorSingleInput">다음 Merge 블록에는 입력 포트가 한 개만 있습니다. 단일 입력 Merge 블록은 단순 방식 초기화 모드에서 지원되지 않습니다.</entry>
    <entry key="MAMergeBlockCheckRecActionMergeErrorSingleInput">Mux 블록과 단일 입력 Merge 블록의 조합을 상응하는 다중 입력 Merge 블록으로 바꾸십시오.</entry>
    <entry key="MAMergeBlockCheckHeadingMergeErrorEmptyIC">''초기 출력''이 지정되지 않은 루트 Merge 블록이 있는지 검사</entry>
    <entry key="MAMergeBlockCheckDescMergeErrorEmptyIC">모든 루트 Merge 블록에 대해 ''초기 출력'' 파라미터가 명시적으로 지정되어 있는지 확인합니다.</entry>
    <entry key="MAMergeBlockCheckStatusMergeErrorEmptyIC">다음 루트 Merge 블록에 대해 ''초기 출력'' 파라미터가 명시적으로 지정되어 있지 않습니다.</entry>
    <entry key="MAMergeBlockCheckRecActionMergeErrorEmptyIC">위에 나열된 Merge 블록의 ''초기 출력'' 파라미터를 []이 아닌 값으로 설정하십시오.</entry>
    <entry key="MAMergeBlockCheckHeadingMergeWarningUseDefaultIC">''초기 출력''이 지정되지 않은 루트 Merge 블록이 있는지 검사</entry>
    <entry key="MAMergeBlockCheckDescMergeWarningUseDefaultIC">명시적 ''초기 출력'' 값을 지정하지 않는 Merge 블록의 새 동작에 대한 경고를 표시합니다.</entry>
    <entry key="MAMergeBlockCheckStatusMergeWarningUseDefaultIC">다음 Merge 블록에 대해 ''초기 출력'' 파라미터가 명시적으로 지정되어 있지 않습니다. 이 경우, Merge 블록은 디폴트 그라운드 값을 ''초기 출력'' 값으로 사용합니다.</entry>
    <entry key="MAMergeBlockCheckRecActionMergeWarningUseDefaultIC">Merge 블록의 새 동작이 허용되는지 확인합니다. 허용되지 않는 경우 단순 방식 초기화 모드로 마이그레이션하기 전에 새 동작이 처리되도록 모델을 수정하십시오.</entry>
    <entry key="MAMergeBlockCheckHeadingMergeErrorInputOffsets">0이 아닌 입력 포트 오프셋을 갖는 Merge 블록이 있는지 검사</entry>
    <entry key="MAMergeBlockCheckDescMergeErrorInputOffsets">모든 Merge 블록에 대해 ''서로 다른 포트 너비 허용'' 파라미터가 ''끄기''로 설정되어 있는지 확인합니다.</entry>
    <entry key="MAMergeBlockCheckStatusMergeErrorInputOffsets">다음 Merge 블록에 대해 ''서로 다른 포트 너비 허용'' 파라미터가 ''켜기''로 설정되었습니다.</entry>
    <entry key="MAMergeBlockCheckRecActionMergeErrorInputOffsets">위에 나열된 Merge 블록에 대해 ''서로 다른 포트 너비 허용'' 파라미터를 ''끄기''로 설정하십시오. 진정으로 병합이 필요한 신호 요소에 대해서만 Merge 블록을 사용해야 합니다. 다른 요소는 Concatenate 블록을 사용하여 병합된 요소와 연속적으로 결합될 수 있습니다.</entry>
    <entry key="MAMergeBlockCheckHeadingMergeErrorNonCondSubsysSrc">연결되지 않은 입력을 갖거나 조건부 실행이 아닌 서브시스템으로부터의 입력을 갖는 Merge 블록이 있는지 검사</entry>
    <entry key="MAMergeBlockCheckDescMergeErrorNonCondSubsysSrc">연결되지 않은 입력을 갖는 Merge 블록, Iterator Subsystem에 의해 직접 구동되는 입력을 갖는 Merge 블록, 또는 조건부 실행 서브시스템이 아닌 블록에 의해 직접 구동되는 입력을 갖는 Merge 블록이 없는지 확인합니다.</entry>
    <entry key="MAMergeBlockCheckStatusMergeErrorNonCondSubsysSrc">다음 Merge 블록에 대해 유효하지 않는 입력 연결이 감지되었습니다.</entry>
    <entry key="MAMergeBlockCheckRecActionMergeErrorNonCondSubsysSrc">위에 나열된 Merge 블록의 입력 연결을 위에 명시된 요구 사항에 따라 수정하십시오.</entry>
    <entry key="MAMergeBlockCheckHeadingMergeErrorDiscontigCondSubsysSrc">조건부 실행 서브시스템 외부에서 결합되었거나 재정렬된 입력을 갖는 Merge 블록이 있는지 검사</entry>
    <entry key="MAMergeBlockCheckDescMergeErrorDiscontigCondSubsysSrc">Mux, Bus Creator 또는 Selector 블록을 사용하여 조건부 실행 서브시스템 외부에서 결합되었거나 재정렬된 입력 신호를 갖는 Merge 블록이 없는지 확인합니다.</entry>
    <entry key="MAMergeBlockCheckStatusMergeErrorDiscontigCondSubsysSrc">다음 Merge 블록에 대해 유효하지 않는 입력 연결이 감지되었습니다.</entry>
    <entry key="MAMergeBlockCheckRecActionMergeErrorDiscontigCondSubsysSrc">위에 나열된 Merge 블록의 입력 연결을 위 요구 사항에 따라 수정하십시오.</entry>
    <entry key="MAMergeBlockCheckHeadingMergeErrorMultSrcTs">입력 샘플 시간이 일치하지 않는 Merge 블록이 있는지 검사</entry>
    <entry key="MAMergeBlockCheckDescMergeErrorMultSrcTs">지정된 Merge 블록에 대한 모든 입력 신호의 샘플 시간이 동일한지 확인합니다.</entry>
    <entry key="MAMergeBlockCheckStatusMergeErrorMultSrcTs">다음 Merge 블록에 대한 입력 신호의 샘플 시간이 서로 다릅니다.</entry>
    <entry key="MAMergeBlockCheckRecActionMergeErrorMultSrcTs">위에 나열된 Merge 블록에 대한 입력 신호의 샘플 시간을 위의 요구 사항에 따라 수정하십시오.</entry>
    <entry key="MAMergeBlockCheckHeadingMergeErrorMultInputsDrivenBySameSrc">단일 소스에 의해 구동되는 여러 개의 입력 포트를 갖는 Merge 블록이 있는지 검사</entry>
    <entry key="MAMergeBlockCheckDescMergeErrorMultInputsDrivenBySameSrc">동일한 조건부 실행 서브시스템 또는 조건부 실행 Model 블록에 의해 구동된 입력 신호를 갖는 Merge 블록이 없는지 확인합니다.</entry>
    <entry key="MAMergeBlockCheckStatusMergeErrorMultInputsDrivenBySameSrc">다음 Merge 블록에 대해 유효하지 않는 입력 연결이 감지되었습니다.</entry>
    <entry key="MAMergeBlockCheckRecActionMergeErrorMultInputsDrivenBySameSrc">위에 나열된 Merge 블록의 입력 연결을 위의 요구 사항에 따라 수정하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorBufferConflictFcnCall">신호 버퍼 요구 사항이 충돌하는 Outport 블록이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorBufferConflictFcnCall">함수 호출 신호와 충돌하는 버퍼가 없는지 확인합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorBufferConflictFcnCall">다음 각 Outport 블록에는 표준 데이터 신호와 함께 이를 통과하는 함수 호출 트리거 또는 함수 호출 데이터 종속성 신호가 있습니다. 올바로 초기화되도록 하려면 일부 표준 데이터 신호에 명시적 신호 버퍼가 있어야 합니다. 그러나 함수 호출 관련 신호를 버퍼링하면 함수 호출 데이터 종속성 위반이 발생하기 때문에 이러한 버퍼링은 적용할 수 없습니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorBufferConflictFcnCall">함수 호출 관련 신호를 연결하는 Outport 블록과 별개인 Outport 블록을 표준 데이터 신호에 사용하도록 모델을 수정하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorBufferConflictSigObj">자동이 아닌 스토리지 클래스를 갖는 Signal 객체로 인해 신호 버퍼 요구 사항이 충돌하는 Outport 블록이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorBufferConflictSigObj">자동이 아닌 스토리지 클래스를 갖는 Signal 객체와 충돌하는 버퍼가 없는지 확인합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorBufferConflictSigObj">다음 각 Outport 블록의 들어오는 신호 선에 자동이 아닌 스토리지 클래스를 갖는 Signal 객체가 있습니다. 단순 방식 초기화 모드에서 올바로 초기화되도록 하려면 각각의 경우에 대해 명시적 신호 버퍼를 삽입해야 합니다. 그러나 버퍼를 삽입하면 Simulink가 이러한 자동이 아닌 스토리지 클래스를 해당 서브시스템 출력과 연결할 수 없으므로 버퍼를 삽입할 수 없습니다. 다음과 같은 이유 중 하나 이상으로 인해 버퍼가 필요합니다. &lt;br&gt;(1) Outport가 Ground, Constant 또는 Stateflow 블록과 같은 덮어쓸 수 없는 출력을 갖는 블록에 의해 구동됩니다. &lt;br&gt;(2) Outport가 Merge 블록의 입력에 연결되어 있습니다. &lt;br&gt;(3) Outport가 현재 서브시스템 내에 중첩되어 있지만 명시적 초기 출력값을 자체적으로 가지는 또 다른 Outport와 동일한 신호 소스를 공유하고 있습니다. 또는 &lt;br&gt;(4) Outport가 동일한 서브시스템에 있으면서 명시적 초기 출력값을 자체적으로 가지는 또 다른 Outport와 동일한 신호 소스를 공유하고 있습니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorBufferConflictSigObj">위에 표시된 이유 중 하나라도 해당하는 경우 Outport 블록 앞에 Signal Conversion 블록을 삽입하고 스토리지 클래스 지정을 이 삽입한 블록의 출력으로 이동해 보십시오. 또는 (4)번 이유에 해당하는 경우에는 자동이 아닌 스토리지 클래스를 갖는 신호가 별도의 Outport를 통과하도록 모델을 수정해 보십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorNeedVirtualBusCopy">명시적 버스 복사본이 필요한 Outport 블록이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorNeedVirtualBusCopy">모든 Outport 블록의 입력 버스 신호가 필요할 때 복사되는지 확인합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorNeedVirtualBusCopy">올바로 초기화되도록 하려면 다음 Outport 블록에 입력 버스 신호의 명시적 복사본이 필요합니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorNeedVirtualBusCopy">각 Outport 블록 앞에 Signal Conversion 블록을 삽입하고 해당 ''출력'' 파라미터를 ''신호 복사''로 설정하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorScalarICForBusSignal">버스 신호에 의해 구동되고 ''초기 출력''이 스칼라 값이 아닌 Outport 블록이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorScalarICForBusSignal">버스 신호에 의해 구동되는 모든 Outport 블록의 ''초기 출력''이 스칼라 값인지 확인합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorScalarICForBusSignal">다음 Outport 블록에는 스칼라 초기 출력값이 필요합니다. 그렇지 않으면 단순 방식 초기화 모드로 마이그레이션한 후 모델이 업데이트에 실패하게 됩니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorScalarICForBusSignal">각 Outport 블록의 ''초기 출력'' 파라미터에 스칼라 값을 입력하십시오. 모든 요소의 초기값이 동일하지 않을 경우 단순 방식 초기화 모드로 마이그레이션한 후 IC(초기 조건) 구조체를 사용하여 ''초기 출력''을 설정하십시오. 초기 조건 구조체에 대한 자세한 내용은 문서를 참조하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorMergedButInheritingFromResetWhenDisabledOutport">비활성화되는 경우 재설정되도록 구성된 Outport 블록에서 초기 출력값을 상속하는 병합된 Outport 블록이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorMergedButInheritingFromResetWhenDisabledOutport">Merge 블록을 구동하는 모든 Outport 블록이 부모 서브시스템이 비활성화된 경우 자신의 출력값을 유지하는지 확인합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorMergedButInheritingFromResetWhenDisabledOutport">다음 Outport 블록은 Merge 블록을 구동하지만 비활성화된 경우 재설정되도록 구성된 Outport 블록에서 초기 출력값을 상속합니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorMergedButInheritingFromResetWhenDisabledOutport">각 Outport 블록에 대해 ''비활성인 경우 출력'' 파라미터가 ''유지''로 설정되어 있는지 확인하십시오. ''초기 출력'' 파라미터에 명시적인 값이 지정되어 있어야 합니다. 또는 문제가 있는 소스 Outport 블록으로 이동하고 ''비활성인 경우 출력'' 파라미터를 ''유지''로 변경하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorMergedButResetWhenDisabled">비활성화된 경우 재설정되는 병합된 Outport 블록이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorMergedButResetWhenDisabled">Merge 블록을 구동하는 모든 Outport 블록이 부모 서브시스템이 비활성화된 경우 자신의 출력값을 유지하는지 확인합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorMergedButResetWhenDisabled">다음 Outport 블록은 Merge 블록을 구동하지만 비활성화된 경우 재설정되도록 구성되었습니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorMergedButResetWhenDisabled">각 Outport 블록에 대해 ''비활성인 경우 출력'' 파라미터를 ''유지''로 설정하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorEmptyIC">정의되지 않은 ''초기 출력'' 값을 갖는 Outport 블록이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorEmptyIC">모든 Outport 블록이 제대로 정의된 ''초기 출력'' 값을 갖는지 확인합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorEmptyIC">다음 Outport 블록 각각에 대한 ''초기 출력'' 파라미터의 설정이 유효하지 않은 것으로 감지되었습니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorEmptyIC">각 Outport 블록에 대해 ''초기 출력'' 파라미터를 []이 아닌 값으로 변경하십시오. 또는 파라미터 값을 []로 그대로 유지하되, 모든 아웃포트 소스가 ''초기 출력'' 값의 유효한 소스, 즉 Constant, Initial Condition, Merge(초기 출력 있음) 또는 조건부 실행 서브시스템 블록인지 확인하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportWarningUseDefaultIC">정의되지 않은 ''초기 출력'' 값을 가지며 초기 조건 소스가 유효하지 않은 Outport 블록이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportWarningUseDefaultIC">빈 행렬([])을 사용하여 디폴트 ''초기 출력'' 값을 지정하는 Outport 블록의 새 동작에 대한 경고를 표시합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportWarningUseDefaultIC">아웃포트가 정의되지 않은 ''초기 출력'' 값을 갖고 아웃포트의 소스 중 하나 이상이 초기값을 상속하기에 유효한 소스가 아니기 때문에 아웃포트가 디폴트 그라운드 값을 초기 출력으로 사용합니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportWarningUseDefaultIC">Outport 블록의 새 동작이 허용되는지 확인합니다. 허용되지 않는 경우 단순 방식 초기화 모드로 마이그레이션하기 전에 새 동작이 처리되도록 모델을 수정하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorEmptyICRateTrans">자동 레이트 변경을 갖는 Outport 블록 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorEmptyICRateTrans">자동 레이트 변경을 갖는 모든 Outport 블록에 대해 ''초기 출력'' 파라미터가 지정되어 있는지 확인합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorEmptyICRateTrans">Simulink가 다음 Outport 블록의 입력에 Rate Transition 블록을 삽입했습니다. 해당 ''초기 출력'' 파라미터를 지정해야 합니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorEmptyICRateTrans">초기 출력값을 지정하십시오. 그렇지 않으면 구성 파라미터 대화 상자의 솔버 창에서 옵션 ''데이터 전송을 위한 레이트 변경 자동 처리''의 선택을 취소하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorEmptyICInternal">특별한 신호 저장공간 요구 사항이 있는 Outport 블록 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorEmptyICInternal">특별한 신호 저장공간 요구 사항이 있는 모든 Outport 블록에 대해 ''초기 출력'' 파라미터가 지정되어 있는지 확인합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorEmptyICInternal">Simulink 내부 신호 저장공간 처리 시스템의 요구 사항을 따르려면 다음 Outport 블록에 대해 ''초기 출력''을 명시적으로 지정해야 합니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorEmptyICInternal">각 Outport 블록에 대해 ''초기 출력'' 파라미터를 []이 아닌 값으로 변경하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportWarningUseDefaultICInternal">특별한 신호 저장공간 요구 사항과 정의되지 않은 ''초기 출력'' 값을 갖는 Outport 블록 검사.</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportWarningUseDefaultICInternal">빈 행렬([])을 사용하여 디폴트 ''초기 출력'' 값을 지정하는 Outport 블록의 새 동작에 대한 경고를 표시합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportWarningUseDefaultICInternal">Simulink 내부 신호 저장공간 처리 시스템의 요구 사항을 따르기 위해 아웃포트가 디폴트 그라운드 값을 초기 출력으로 사용합니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportWarningUseDefaultICInternal">Outport 블록의 새 동작이 허용되는지 확인합니다. 허용되지 않는 경우 단순 방식 초기화 모드로 마이그레이션하기 전에 새 동작이 처리되도록 모델을 수정하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorResetButEmptyIC">비활성화된 경우 재설정되는 Outport 블록의 ''초기 출력'' 설정 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorResetButEmptyIC">비활성화된 경우 재설정되는 모든 Outport 블록에 대해 ''초기 출력'' 파라미터가 지정되어 있는지 확인합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorResetButEmptyIC">다음 Outport 블록은 비활성화된 경우 재설정되도록 구성되었기 때문에 이 블록에 대해 ''초기 출력'' 파라미터를 명시적으로 지정해야 합니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorResetButEmptyIC">각 Outport 블록에 대해 ''초기 출력'' 파라미터를 []이 아닌 값으로 변경하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportErrorNeedEmptyICForFcnCallInArgPassThru">함수 호출 데이터 종속성 신호를 통과시키는 Outport 블록에 대한 ''초기 출력'' 설정 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportErrorNeedEmptyICForFcnCallInArgPassThru">함수 호출 데이터 종속성 신호를 통과시키는 모든 Outport 블록에 대해 ''초기 출력'' 파라미터가 []로 설정되어 있는지 확인합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportErrorNeedEmptyICForFcnCallInArgPassThru">함수 호출 데이터 종속성 신호가 다음 Outport 블록을 통과하기 때문에 이 포트에 대해 ''초기 출력'' 파라미터를 []로 설정해야 합니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportErrorNeedEmptyICForFcnCallInArgPassThru">각 Outport 블록에 대해 ''초기 출력'' 파라미터를 []로 설정하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportWarningSignalObjectSpecifyingICParam">Signal 객체를 사용하여 ''초기 출력'' 값을 지정하는 Outport 블록이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportWarningSignalObjectSpecifyingICParam">Signal 객체를 사용하여 ''초기 출력'' 값을 지정하는 Outport 블록의 새 동작에 대한 경고를 표시합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportWarningSignalObjectSpecifyingICParam">단순 방식 초기화 모드에서는 더 이상 Signal 객체를 사용하여 다음 Outport 블록의 ''초기 출력'' 파라미터를 지정할 수 없습니다. Signal 객체를 사용하여 이러한 Outport 블록의 입력 신호 또는 출력 신호를 초기화할 수는 있지만, 그 초기화 결과를 Outport 블록의 초기화 결과가 덮어쓸 수 있습니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportWarningSignalObjectSpecifyingICParam">Outport 블록의 새 동작이 허용되는지 확인합니다. 허용되지 않는 경우 단순 방식 초기화 모드로 마이그레이션하기 전에 새 동작이 처리되도록 모델을 수정하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportWarningMergedFromGroundSrc">Ground 블록에 연결되지 않았거나 연결된 병합된 Outport 블록이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportWarningMergedFromGroundSrc">Outport 블록이 Merge 블록을 구동하지만 연결되지 않은 입력 또는 Ground 블록에 연결된 입력을 갖는 경우, Outport 블록의 새 동작에 대한 경고를 표시합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportWarningMergedFromGroundSrc">고전 방식 초기화 모드에서는 연결되지 않았거나 접지된 Outport 블록이 조건부로 실행되는 부모 서브시스템이 실행 중인 경우에도 병합 신호를 업데이트하지 않습니다. 하지만 단순 방식 초기화 모드에서는 다음 Outport 블록이 조건부로 실행되는 부모 서브시스템이 실행 중인 경우 병합 신호를 0 값으로 업데이트합니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportWarningMergedFromGroundSrc">Outport 블록의 새 동작이 허용되는지 확인합니다. 허용되지 않는 경우 단순 방식 초기화 모드로 마이그레이션하기 전에 새 동작이 처리되도록 모델을 수정하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportWarningMergedFromNestedCondSubsysSrc">중첩된 조건부 실행 서브시스템에 의해 구동되는 병합된 Outport 블록이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportWarningMergedFromNestedCondSubsysSrc">Merge 블록을 구동하지만 결과적으로는 조건부로 실행되는 부모 서브시스템 내에 중첩된 조건부 실행 서브시스템에 의해 구동되는 Outport 블록의 새 동작에 대한 경고를 표시합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportWarningMergedFromNestedCondSubsysSrc">고전 방식 초기화 모드에서는 중첩된 조건부 실행 서브시스템에 의해 구동되는 Outport 블록이 조건부로 실행되는 부모 서브시스템이 실행 중인 경우에도 병합 신호를 업데이트하지 않을 수도 있습니다. 그러나 단순 방식 초기화 모드에서는 다음 Outport 블록이 조건부로 실행되는 부모 서브시스템이 실행 중인 경우 블록을 구동하는 중첩된 조건부 실행 서브시스템의 마지막 출력값으로 병합 신호를 항상 업데이트합니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportWarningMergedFromNestedCondSubsysSrc">Outport 블록의 새 동작이 허용되는지 확인합니다. 허용되지 않는 경우 단순 방식 초기화 모드로 마이그레이션하기 전에 새 동작이 처리되도록 모델을 수정하십시오.</entry>
    <entry key="MAMergeBlockCheckHeadingMergeWarningSignalObjectSpecifyingICParam">Signal 객체를 사용하여 ''초기 출력'' 값을 지정하는 Merge 블록이 있는지 검사</entry>
    <entry key="MAMergeBlockCheckDescMergeWarningSignalObjectSpecifyingICParam">Signal 객체를 사용하여 ''초기 출력'' 값을 지정하는 Merge 블록의 새 동작에 대한 경고를 표시합니다.</entry>
    <entry key="MAMergeBlockCheckStatusMergeWarningSignalObjectSpecifyingICParam">단순 방식 초기화 모드에서는 더 이상 Signal 객체를 사용하여 다음 Merge 블록의 ''초기 출력'' 파라미터를 지정할 수 없습니다. Signal 객체를 사용하여 이러한 Merge 블록의 출력 신호를 초기화할 수는 있지만, 그 초기화 결과를 Merge 블록의 초기화 결과가 덮어쓸 수 있습니다.</entry>
    <entry key="MAMergeBlockCheckRecActionMergeWarningSignalObjectSpecifyingICParam">새 동작이 허용되는지 확인합니다. 허용되지 않는 경우 단순 방식 초기화 모드로 마이그레이션하기 전에 새 동작이 처리되도록 모델을 수정하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportWarningUseICFromInputSignal">마이그레이션될 때 입력 신호에서 ''초기 출력'' 값을 가져오는 Outport 블록이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportWarningUseICFromInputSignal">입력 신호에서 ''초기 출력'' 값을 가져올 수 있는 Outport 블록의 새 동작에 대한 경고를 표시합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportWarningUseICFromInputSignal">다음 Outport 블록의 ''초기 출력'' 파라미터가 지정되지 않았습니다([]으로 설정됨). 단순 방식 초기화 모드에서는 Simulink가 각 Outport 블록의 ''초기 출력'' 값이 입력 신호에서 파생된 것으로 가정합니다. 그 결과, 초기화 동작이 고전 방식 초기화 모드와는 다를 수 있습니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportWarningUseICFromInputSignal">새 동작이 허용되는지 확인합니다. 허용되지 않는 경우 단순 방식 초기화 모드로 마이그레이션하기 전에 새 동작이 처리되도록 모델을 수정하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportWarningUseScalarZeroAsIC">가장 안쪽에 있는 Outport 블록 중 가변 크기 입력과 지정되지 않은 ''초기 출력''을 갖는 블록이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportWarningUseScalarZeroAsIC">가변 크기 입력을 갖는 가장 안쪽에 있는 Outport 블록의 ''초기 출력'' 설정 변경에 대한 경고를 표시합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportWarningUseScalarZeroAsIC">다음 각 Outport 블록은 가장 안쪽에 있는 Outport 블록이며 부모 서브시스템이 다시 활성화될 때만 신호 크기가 달라지는 가변 크기 입력을 가집니다. 따라서 Simulink가 ''초기 출력'' 파라미터가 지정되지 않은 경우([])에도 0인 것으로 묵시적으로 가정합니다. 단순 방식 초기화 모드에서는 이 파라미터가 명시적으로 0으로 설정됩니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportWarningUseScalarZeroAsIC">''초기 출력''을 []이 아닌 값으로 명시적으로 설정하거나, 단순 방식 초기화 모드로 마이그레이션하기 전에 0으로 설정하는 것이 허용되는지 확인하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportWarningConvertToEmptyHeldIC">바깥쪽 Outport 블록 중 명시적 ''초기 출력''을 갖는 블록이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportWarningConvertToEmptyHeldIC">명시적 ''초기 출력''을 갖는 바깥쪽 Outport 블록의 새 설정에 대한 경고를 표시합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportWarningConvertToEmptyHeldIC">고전 방식 초기화 모드에서 다음 각 Outport 블록은 해당 소스 Outport 블록과 동일한 ''초기 출력'' 파라미터 및 ''비활성인 경우 출력'' 파라미터를 가집니다. 따라서 단순 방식 초기화 모드에서는 ''초기 출력'' 파라미터가 ''[]''로 설정되고 ''비활성인 경우 출력'' 파라미터는 ''유지''로 설정됩니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportWarningConvertToEmptyHeldIC">단순 방식 초기화 모드로 마이그레이션하기 전에 새 설정이 허용되는지 확인하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportWarningUseICFromDialog">바깥쪽 Outport 블록 중 명시적 ''초기 출력''을 갖는 블록이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportWarningUseICFromDialog">명시적 ''초기 출력''을 갖는 바깥쪽 Outport 블록의 새 설정에 대한 경고를 표시합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportWarningUseICFromDialog">고전 방식 초기화 모드에서 다음 각 Outport 블록은 해당 소스 Outport 블록과 동일한 ''초기 출력'' 파라미터 및 ''비활성인 경우 출력'' 파라미터를 가집니다. 따라서 단순 방식 초기화 모드에서는 ''초기 출력'' 파라미터가 ''[]''로 설정되고 ''비활성인 경우 출력'' 파라미터는 ''유지''로 설정됩니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportWarningUseICFromDialog">단순 방식 초기화 모드로 마이그레이션하기 전에 새 설정이 허용되는지 확인하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportDispositionUseICFromDialog">대화 상자에 지정된 ''초기 출력'' 값이나 디폴트 값 0을 사용하는 Outport 블록에 마이그레이션 충돌이 있는지 확인합니다</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportDispositionUseICFromDialog">라이브러리와 연결되고 대화 상자에 지정된 ''초기 출력'' 값이나 디폴트 값 0을 사용하는 Outport 블록에 대해 균일한 마이그레이션 경로가 존재하는지 확인합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportDispositionUseICFromDialog">단순 방식 초기화 모드에서 다음 각 Outport 블록은 대화 상자에 지정된 ''초기 출력'' 값이나 디폴트 값 0을 사용합니다. 동일한 라이브러리 링크를 사용하는 Outport 블록의 다른 인스턴스는 오류가 발생하거나, 각기 다르게 마이그레이션됩니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportDispositionUseICFromDialog">각 Outport 블록의 다른 인스턴스에 대한 각기 다른 마이그레이션 경로를 알아보려면 하위 검사 &lt;a href="#Simulink:tools:MAOutportCondSubsysCheckHeadingLibraryBlockErrorMigration"&gt;마이그레이션할 수 없는 인스턴스가 있는 라이브러리 블록이 있는지 검사&lt;/a&gt;의 결과를 검토하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportDispositionUseICFromInputSignal">입력 신호로부터 초기 출력값을 가져오는 Outport 블록에 마이그레이션 충돌이 있는지 확인합니다</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportDispositionUseICFromInputSignal">라이브러리와 연결되고 입력 신호에서 초기 출력값을 가져오는 Outport 블록의 마이그레이션 경로가 균일한지 확인합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportDispositionUseICFromInputSignal">다음의 각 Outport 블록은 입력 신호로부터 초기 출력값을 가져옵니다. 동일한 라이브러리 링크를 사용하는 Outport 블록의 다른 인스턴스는 오류가 발생하거나, 각기 다르게 마이그레이션됩니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportDispositionUseICFromInputSignal">각 Outport 블록의 다른 인스턴스에 대한 각기 다른 마이그레이션 경로를 알아보려면 하위 검사 &lt;a href="#Simulink:tools:MAOutportCondSubsysCheckHeadingLibraryBlockErrorMigration"&gt;마이그레이션할 수 없는 인스턴스가 있는 라이브러리 블록이 있는지 검사&lt;/a&gt;의 결과를 검토하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportDispositionUseDefaultIC">디폴트 그라운드 값을 ''초기 출력'' 값으로 사용하는 Outport 블록에 마이그레이션 충돌이 있는지 검사.</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportDispositionUseDefaultIC">라이브러리와 연결되고 ''초기 출력'' 값으로 디폴트 그라운드 값을 사용하는 Outport 블록의 마이그레이션 경로가 균일한지 확인합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportDispositionUseDefaultIC">파라미터 ''초기 출력''이 현재 []로 설정되어 있고 아웃포트의 소스가 유효하지 않은 초기 조건 소스이기 때문에 단순 방식 초기화 모드에서 이 아웃포트는 디폴트 그라운드 값을 초기 출력으로 사용합니다. 동일한 라이브러리 링크를 사용하는 Outport 블록의 다른 인스턴스는 오류가 발생하거나, 각기 다르게 마이그레이션됩니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportDispositionUseDefaultIC">각 Outport 블록의 다른 인스턴스에 대한 각기 다른 마이그레이션 경로를 알아보려면 하위 검사 &lt;a href="#Simulink:tools:MAOutportCondSubsysCheckHeadingLibraryBlockErrorMigration"&gt;마이그레이션할 수 없는 인스턴스가 있는 라이브러리 블록이 있는지 검사&lt;/a&gt;의 결과를 검토하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportDispositionUseEmptyICForMerge">''초기 출력''이 명시적으로 지정되지 않은 상태로 병합된 Outport 블록에 마이그레이션 충돌이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportDispositionUseEmptyICForMerge">라이브러리와 연결되고 ''초기 출력''이 명시적으로 지정되지 않은 상태로 병합된 Outport 블록의 마이그레이션 경로가 균일한지 확인합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportDispositionUseEmptyICForMerge">다음 각 Outport 블록의 경우, Merge 블록을 구동하기 때문에 ''초기 출력'' 및 ''비활성인 경우 출력'' 파라미터가 단순 방식 초기화 모드에서도 각각 ''[]''과 ''유지''로 그대로 유지됩니다. 동일한 라이브러리 링크를 사용하는 Outport 블록의 다른 인스턴스는 오류가 발생하거나, 각기 다르게 마이그레이션됩니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportDispositionUseEmptyICForMerge">각 Outport 블록의 다른 인스턴스에 대한 각기 다른 마이그레이션 경로를 알아보려면 하위 검사 &lt;a href="#Simulink:tools:MAOutportCondSubsysCheckHeadingLibraryBlockErrorMigration"&gt;마이그레이션할 수 없는 인스턴스가 있는 라이브러리 블록이 있는지 검사&lt;/a&gt;의 결과를 검토하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportDispositionUseEmptyIC">''초기 출력''이 명시적으로 지정되지 않은 Outport 블록에 마이그레이션 충돌이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportDispositionUseEmptyIC">라이브러리와 연결되고 ''초기 출력''이 명시적으로 지정되지 않은 Outport 블록의 마이그레이션 경로가 균일한지 확인합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportDispositionUseEmptyIC">다음 각 Outport 블록의 경우, ''초기 출력'' 및 ''비활성인 경우 출력'' 파라미터가 단순 방식 초기화 모드에서도 각각 ''[]''과 ''유지''로 그대로 유지됩니다. 동일한 라이브러리 링크를 사용하는 Outport 블록의 다른 인스턴스는 오류가 발생하거나, 각기 다르게 마이그레이션됩니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportDispositionUseEmptyIC">각 Outport 블록의 다른 인스턴스에 대한 각기 다른 마이그레이션 경로를 알아보려면 하위 검사 &lt;a href="#Simulink:tools:MAOutportCondSubsysCheckHeadingLibraryBlockErrorMigration"&gt;마이그레이션할 수 없는 인스턴스가 있는 라이브러리 블록이 있는지 검사&lt;/a&gt;의 결과를 검토하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportDispositionUseScalarZeroAsIC">가변 크기 입력을 가지며 ''초기 출력''이 지정되지 않은 가장 안쪽에 있는 Outport 블록에 마이그레이션 충돌이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportDispositionUseScalarZeroAsIC">라이브러리와 연결된 가장 안쪽 Outport 블록 중 가변 크기 입력을 가지며 ''초기 출력''이 지정되지 않은 블록의 마이그레이션 경로가 균일한지 확인합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportDispositionUseScalarZeroAsIC">다음 각 Outport 블록은 가장 안쪽에 있는 Outport 블록이며 부모 서브시스템이 다시 활성화된 경우만 신호 크기가 달라지는 가변 크기 입력을 가집니다. 따라서 Simulink가 ''초기 출력'' 파라미터가 지정되지 않은 경우([])에도 0인 것으로 묵시적으로 가정합니다. 단순 방식 초기화 모드에서는 이 파라미터가 0으로 명시적으로 설정됩니다. 동일한 라이브러리 링크를 사용하는 Outport 블록의 다른 인스턴스는 오류가 발생하거나, 각기 다르게 마이그레이션됩니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportDispositionUseScalarZeroAsIC">각 Outport 블록의 다른 인스턴스에 대한 각기 다른 마이그레이션 경로를 알아보려면 하위 검사 &lt;a href="#Simulink:tools:MAOutportCondSubsysCheckHeadingLibraryBlockErrorMigration"&gt;마이그레이션할 수 없는 인스턴스가 있는 라이브러리 블록이 있는지 검사&lt;/a&gt;의 결과를 검토하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingOutportDispositionUseEmptyICForSimEvents">SimEvents 의미 체계를 사용하는 Outport 블록에 마이그레이션 충돌이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescOutportDispositionUseEmptyICForSimEvents">라이브러리와 연결되고 SimEvents의 초기화 의미 체계를 사용하는 Outport 블록의 마이그레이션 경로가 균일한지 확인합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusOutportDispositionUseEmptyICForSimEvents">다음 각 Outport 블록의 경우, 조건부로 실행되는 부모 서브시스템이 SimEvents 블록에 연결되어 있기 때문에 ''초기 출력'' 및 ''비활성인 경우 출력'' 파라미터가 단순 방식 초기화 모드에서도 각각 ''[]''과 ''유지''로 그대로 유지됩니다. 동일한 라이브러리 링크를 사용하는 Outport 블록의 다른 인스턴스는 오류가 발생하거나, 각기 다르게 마이그레이션됩니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionOutportDispositionUseEmptyICForSimEvents">각 Outport 블록의 다른 인스턴스에 대한 각기 다른 마이그레이션 경로를 알아보려면 하위 검사 &lt;a href="#Simulink:tools:MAOutportCondSubsysCheckHeadingLibraryBlockErrorMigration"&gt;마이그레이션할 수 없는 인스턴스가 있는 라이브러리 블록이 있는지 검사&lt;/a&gt;의 결과를 검토하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingSubSystemWarningCondSubsysMovingBlocksIntoContextFromOutputSide">출력 경계에서 실행 컨텍스트를 전파하는 조건부 실행 서브시스템이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescSubSystemWarningCondSubsysMovingBlocksIntoContextFromOutputSide">실행 컨텍스트 전파와 관련하여 서브시스템의 새 동작에 대한 경고를 표시합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusSubSystemWarningCondSubsysMovingBlocksIntoContextFromOutputSide">다음 서브시스템에 대해 옵션 ''서브시스템 경계에서 실행 컨텍스트 전파''가 선택되었습니다. 하지만 단순 방식 초기화 모드에서는 올바른 초기화를 보장하기 위해 서브시스템의 실행 컨텍스트 전파가 출력 측에서 비활성화됩니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionSubSystemWarningCondSubsysMovingBlocksIntoContextFromOutputSide">단순 방식 초기화 모드로 마이그레이션하기 전에 새 서브시스템 동작이 허용되는지 확인하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckPropCECAcrossSSBoundary">서브시스템 경계에서 실행 컨텍스트 전파</entry>
    <entry key="MADiscreteIntegratorCheckHeadingOverall">Discrete-Time Integrator 블록 사용 상태 검사</entry>
    <entry key="MADiscreteIntegratorCheckDescOverall">이 검사는 단순 방식 초기화 모드로 마이그레이션 시 Discrete-Time Integrator 블록과 관련된 문제를 찾아 보고합니다.</entry>
    <entry key="MADiscreteIntegratorCheckStatusOverall">이 모델이 단순 방식 초기화 모드를 사용하고 있지 않습니다.</entry>
    <entry key="MADiscreteIntegratorCheckRecActionOverallHasError">아래에 표시된 실패한 하위 검사가 모두 해결되도록 모델을 수정한 후 이 검사를 다시 실행하십시오.</entry>
    <entry key="MADiscreteIntegratorCheckRecActionOverallNoErrorButHasWarning">아래에 표시된 하위 검사에서 보고된 경고를 검토하고 주의가 필요한 항목을 해결하십시오.</entry>
    <entry key="MADiscreteIntegratorCheckRecActionOverallNoErrorNoWarning">Discrete-Time Integrator 블록과 관련된 문제가 발견되지 않았습니다. 따라서 이 모델은 구성 파라미터를 사용하여 단순 방식 초기화 모드로 마이그레이션할 수 있습니다.</entry>
    <entry key="MADiscreteIntegratorCheckHeadingDiscreteIntegratorWarningOutputICMode">'초기 조건 설정' 파라미터가 '출력'으로 설정된 Discrete-Time Integrator 블록이 있는지 검사</entry>
    <entry key="MADiscreteIntegratorCheckDescDiscreteIntegratorWarningOutputICMode">Discrete-Time Integrator 블록을 찾아 단순 방식 초기화 모드의 변경 사항에 대한 경고를 표시합니다.</entry>
    <entry key="MADiscreteIntegratorCheckStatusDiscreteIntegratorWarningOutputICMode">다음 블록은 단순 방식 초기화 모드에서 다른 결과를 생성할 수 있습니다.</entry>
    <entry key="MADiscreteIntegratorCheckRecActionDiscreteIntegratorWarningOutputICMode">Discrete-Time Integrator가 단순 방식 초기화 모드에서 수행하는 새로운 초기화 동작에 대한 자세한 내용은 관련 문서를 참조하십시오.</entry>
    <entry key="MADiscreteIntegratorCheckHeadingDiscreteIntegratorDispositionUseStateICMode">''초기 조건 설정'' 파라미터가 '자동'으로 설정되는 Discrete-Time Integrator 블록에 마이그레이션 충돌이 있는지 검사</entry>
    <entry key="MADiscreteIntegratorCheckDescDiscreteIntegratorDispositionUseStateICMode">라이브러리와 연결되고 ''초기 조건 설정'' 파라미터에 '자동' 옵션을 사용하는 Discrete-Time Integrator 블록의 마이그레이션 경로가 균일한지 확인합니다.</entry>
    <entry key="MADiscreteIntegratorCheckStatusDiscreteIntegratorDispositionUseStateICMode">다음의 각 Discrete-Time Integrator 블록은 단순 방식 초기화 모드에서 파라미터 ''초기 조건 설정''이 그대로 ''자동''으로 설정됩니다. 동일한 라이브러리 링크를 사용하는 Discrete-Time Integrator 블록의 다른 항목은 오류가 있거나, 다른 방식으로 마이그레이션되는 중입니다.</entry>
    <entry key="MADiscreteIntegratorCheckRecActionDiscreteIntegratorDispositionUseStateICMode">각 Discrete-Time Integrator 블록의 다른 인스턴스에 대한 각기 다른 마이그레이션 경로를 알아보려면 하위 검사 &lt;a href="#Simulink:tools:MAOutportCondSubsysCheckHeadingLibraryBlockErrorMigration"&gt;마이그레이션할 수 없는 인스턴스가 있는 라이브러리 블록이 있는지 검사&lt;/a&gt;의 결과를 검토하십시오.</entry>
    <entry key="MADiscreteIntegratorCheckLibraryBlock">라이브러리 블록</entry>
    <entry key="MAOutportCondSubsysCheckHeadingAnyBlockWarningCannotReadInputFromNonVirtualSubsysInStart">초기화하는 동안 비가상 서브시스템에서 입력값을 읽어오는 블록이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescAnyBlockWarningCannotReadInputFromNonVirtualSubsysInStart">초기화하는 동안 비가상 서브시스템에서 입력값을 읽어오는 블록의 새 동작에 대해 경고를 표시합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusAnyBlockWarningCannotReadInputFromNonVirtualSubsysInStart">다음 블록은 현재 최적화의 형태로 초기화 중에 비가상 시스템에서 입력값을 읽어옵니다. 이 최적화는 잘못된 시뮬레이션 결과로 이어질 수 있기 때문에 단순 방식 초기화 모드에서는 꺼집니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionAnyBlockWarningCannotReadInputFromNonVirtualSubsysInStart">단순 방식 초기화 모드로 마이그레이션하기 전에 새 동작이 허용되는지 확인하십시오.</entry>
    <entry key="MADiscreteIntegratorCheckHeadingAnyBlockErrorUseElapsedTimeInIterSubsys">경과 시간이 필요한 블록이 Iterator Subsystem 내에 있는지 검사</entry>
    <entry key="MADiscreteIntegratorCheckDescAnyBlockErrorUseElapsedTimeInIterSubsys">경과 시간이 필요한 블록이 Iterator Subsystem 내에 사용되지 않았음을 확인합니다.</entry>
    <entry key="MADiscreteIntegratorCheckStatusAnyBlockErrorUseElapsedTimeInIterSubsys">단순 방식 초기화 모드에서는 다음 블록을 Iterator Subsystem 계층 구조 내에 둘 수 없습니다. 이러한 블록에는 2회 연속 실행 사이에 경과된 시간을 관리하는 서비스가 필요하기 때문입니다.</entry>
    <entry key="MADiscreteIntegratorCheckRecActionAnyBlockErrorUseElapsedTimeInIterSubsys">예기치 않은 동작을 방지하려면 Iterator Subsystem 내에 그러한 블록을 사용하지 마십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingLibraryBlockErrorMigration">마이그레이션할 수 없는 인스턴스가 있는 라이브러리 블록이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescLibraryBlockErrorMigration">모델에서 라이브러리와 연결된 블록의 모든 인스턴스를 단순 방식 초기화 모드로 안전하게 마이그레이션할 수 있는지 확인합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusLibraryBlockErrorMigration">다음 라이브러리 블록에는 단순 방식 초기화 모드로 마이그레이션할 수 없는 인스턴스가 한 개 이상 있거나 서로 다른 마이그레이션 경로를 갖는 인스턴스가 두 개 이상 있습니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionLibraryBlockErrorMigration">이러한 각 블록에 대해 해당 인스턴스의 하위 검사 결과를 검토하고 적합한 정정 조치를 정하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckHeadingLibraryBlockWarningMigration">경고가 발생한 인스턴스가 있는 라이브러리 블록이 있는지 검사</entry>
    <entry key="MAOutportCondSubsysCheckDescLibraryBlockWarningMigration">경고가 발생한 인스턴스가 있는 라이브러리 블록을 식별합니다.</entry>
    <entry key="MAOutportCondSubsysCheckStatusLibraryBlockWarningMigration">다음 각 라이브러리 블록에는 하위 검사 경고가 발생한 인스턴스가 하나 이상 있습니다.</entry>
    <entry key="MAOutportCondSubsysCheckRecActionLibraryBlockWarningMigration">경고가 모두 허용 가능한 것인지 확인하십시오. 허용할 수 없는 경고인 경우 단순 방식 초기화 모드로 마이그레이션하기 전에 경고에 따라 모델을 수정하십시오.</entry>
    <entry key="MAOutportCondSubsysCheckActionButtonName">설정 수정</entry>
    <entry key="MAOutportCondSubsysCheckActionDescription">단순 방식 초기화 모드와의 호환성을 위해 모든 Outport 블록과 조건부 서브시스템 블록의 설정을 마이그레이션합니다.</entry>
    <entry key="MADiscreteIntegratorCheckActionButtonName">설정 수정</entry>
    <entry key="MADiscreteIntegratorCheckActionDescription">단순 방식 초기화 모드와의 호환성을 위해 Discrete-Time Integrator 블록 설정을 수정합니다.</entry>
    <entry key="MASimplifiedModeCheckActionButtonName">설정 수정</entry>
    <entry key="MASimplifiedModeCheckActionDescription">모든 모델 설정을 단순 방식 초기화 모드로 마이그레이션합니다. 그 결과 [구성 파라미터] 대화 상자에서 ''과소 지정된 초기화 감지'' 옵션이 ''단순 방식''으로 설정됩니다. 진행하기 전에 모델을 포함해 관련된 모든 라이브러리 파일이 쓰기 가능한 형태이며 저장되지 않은 변경 내용이 없는지 확인하십시오.</entry>
    <entry key="MATitleReplaceZOHDelayByRTB">레이트 변경을 수행하기 위한 Delay, Unit Delay 및 Zero-Order Hold 블록 확인</entry>
    <entry key="MATitletipReplaceZOHDelayByRTB">모델에서 레이트 변경을 수행하는 Delay, Unit Delay 및 Zero-Order Hold 블록을 식별합니다. 그러한 블록을 Rate Transition 블록으로 바꿉니다.</entry>
    <entry key="MAMsgReplaceZOHDelayByRTBWarn">&lt;p /&gt; 다음 Delay, Unit Delay 및/또는 Zero-Order Hold 블록은 입력 신호와 출력 신호 간의 레이트 변경 역할을 합니다. 이러한 블록은 숨겨진 Rate Transition 블록으로 대체되었습니다. </entry>
    <entry key="MAMsgReplaceZOHDelayByRTBSuggest">&lt;p /&gt; 강력한 성능을 위해 이러한 블록을 실제 Rate Transition 블록으로 바꾸십시오. [모델 업그레이드]를 클릭한 다음 모델을 저장하십시오. </entry>
    <entry key="MANonReplaceZOHDelayByRTBPass"> 모델에 레이트 변경을 수행하는 Delay, Unit Delay 또는 Zero-Order Hold 블록이 없습니다.</entry>
    <entry key="MAReplaceZOHDelayByRTBActionButtonName">모델 업그레이드</entry>
    <entry key="MAReplaceZOHDelayByRTBActionDescription">이러한 Delay, Unit Delay 및 Zero-Order Hold 블록을 Rate Transition 블록으로 바꾸려면 여기를 클릭하십시오. 그러면 모델이 다시 컴파일됩니다. 변경 사항을 영구적으로 적용하려면 컴파일이 끝난 후 모델을 저장하십시오.</entry>
    <entry key="MAReplaceZOHDelayByRTBActionResults">다음 블록은 Rate Transition 블록으로 대체되었습니다. 변경 내용을 유지하려면 모델을 저장하십시오.</entry>
    <entry key="MAReplaceZOHDelayByRTBUnexpectedError">블록 대체 중에 예기치 않은 오류가 발생함: {0}</entry>
    <entry key="OutportMigrateTitle">아웃포트 설정 마이그레이션</entry>
    <entry key="OutportMigrateConfirmQuestion">변경 내용을 실행 취소하기가 어렵기 때문에 진행하기 전에 모델과 라이브러리의 백업 복사본을 저장하십시오. 모델 ''{0}''을(를) 단순 방식 초기화 모드로 마이그레이션하시겠습니까?</entry>
    <entry key="OutportMigrateUnexpectedError">모델 마이그레이션 중에 예기치 않은 오류가 발생함: {0}</entry>
    <entry key="OutportMigrateRunning">단순 방식 초기화 모드와 호환되도록 하기 위해 모델 어드바이저가 모델 ''{0}'' 내에 있는 블록의 설정을 마이그레이션하고 있습니다.</entry>
    <entry key="SimplifiedModeMigrateRunning">단순 방식 초기화 모드와 호환되도록 하기 위해 모델 어드바이저가 모델 ''{0}'' 내에 있는 블록의 설정을 마이그레이션하고 있습니다.</entry>
    <entry key="OutportMigrateCompleted">블록 마이그레이션이 완료되었습니다.</entry>
    <entry key="SimplifiedModeMigrateCompleted">블록 마이그레이션이 완료되었습니다.</entry>
    <entry key="OutportMigrateCancelled">모델을 단순 방식 초기화 모드로 마이그레이션하는 작업이 사용자에 의해 취소되었거나 실패했습니다.</entry>
    <entry key="OutportMigrateNotNeeded">모델 ''{0}''이(가) 이미 마이그레이션되었기 때문에 블록 마이그레이션은 필요하지 않습니다.</entry>
    <entry key="MADataStoreCheckActionButtonName">계속</entry>
    <entry key="MADataStoreCheckActionDescription">데이터 저장소 메모리가 권장 모범 사례를 준수하는지 확인하십시오. 위에 보고된 모든 경고를 파악하거나 해결한 다음에 계속 진행하십시오.</entry>
    <entry key="slDebuguiRequiresJava">The Simulink debugger requires Java support</entry>
    <entry key="viewLinkDataRequiresJava">The link data dialog requires java support. Please use set_param/get_param of ''LinkData'' property instead.</entry>
    <entry key="slDebuguiInUse">다음에 Simulink Debugger가 사용 중임: ''{0}''.\n''{1}''을(를) 디버그하려면 현재 디버거를 종료하십시오.</entry>
    <entry key="slDebugCurrentBlockIsEmpty">모델 ''{0}''에서 선택된 블록이 없습니다.</entry>
    <entry key="slDebugCurrentBlockNotInModel">디버그 중인 모델 ''{1}''에 블록 ''{0}''이(가) 없기 때문에 이 블록에 중단점을 설정할 수 없습니다.</entry>
    <entry key="slDebugBreakpointSetOnVirtualBlock">선택한 블록 ''{0}''은(는) 가상 블록입니다. 중단점을 설정하려면 비가상 블록을 선택해야 합니다. 모델 ''{1}''의 비가상 블록 목록은 디버거의 [정렬된 목록] 창 또는 SLIST 명령의 출력을 확인하십시오.</entry>
    <entry key="NoSLDebugWithTLCDebug">The Simulink Debugger has been disabled while the TLC debugger is running</entry>
    <entry key="NoTLCDebugWithSLDebug">The TLC Debugger has been disabled while the Simulink debugger is open</entry>
    <entry key="LUTEditorNoUndefinedExpressions">Error evaluating parameter ''{0}'' in block ''{1}''.\n If this parameter specifies a variable name, make sure that you define the variable in a workspace.\n Otherwise, make sure that this parameter specifies data that is dimensioned consistently with its corresponding breakpoint vectors.</entry>
    <entry key="PosRealCheck">양의 실수이거나 z = 0에 가까운 극점을 갖는 하이브리드 시스템의 선형화는 dlinmod에서 지원되지 않습니다. Simulink Control Design의 명령 linearize에서는 지원됩니다.</entry>
    <entry key="ImplicitSignalResolutionAlreadyDisabled">Implicit signal object resolution is already disabled for model ''{0}''.</entry>
    <entry key="TurnOnResolutionForSignals">다음 신호 레이블과 Signal 객체 사이에 강제로 연결이 맺어집니다.</entry>
    <entry key="TurnOnResolutionForStates">다음 상태와 Signal 객체 사이에 강제로 연결이 맺어짐:</entry>
    <entry key="CannotDisableImplicitSignalResolution">Cannot change SignalResolutionControl to ''UseLocalSettings'' because this model is using a configuration reference. To disable implicit signal object resolution, manually modify this parameter on the source configuration set ''{0}''.</entry>
    <entry key="RenameStateflowOutputSignal">Changing signal label from ''{0}'' to ''{1}'' for output of Stateflow chart ''{2}''.</entry>
    <entry key="ExpectedOneStateflowOutputWithSignalName">신호와 이름이 같은 Outport 블록을 한 개 찾아야 합니다.</entry>
    <entry key="dlinmodUseZeroTs">Forcing sample time to zero in LINMOD mode.</entry>
    <entry key="dlinmodReturningTransferFunction">전달 함수 모델 반환</entry>
    <entry key="dlinmodUnrecognizedOption">인식할 수 없는 옵션입니다. 자세한 내용은 HELP DLINMOD를 입력하여 참조하십시오.</entry>
    <entry key="dlinmodNoV5Sparse">Sparse matrices are not supported with ''v5'' option.</entry>
    <entry key="dlinmodNoV5AnalysisPorts">Analysis ports are not supported with ''v5'' option.</entry>
    <entry key="dlinmodMultiTaskingSolver">The model must be using a single-tasking fixed step or a variable step solver when linearizing a model.</entry>
    <entry key="dlinmodWrongInputVectorSize">Expecting an input vector of length {0,number,integer}</entry>
    <entry key="dlinmodExtraStatesZero">Extra states are being set to zero.</entry>
    <entry key="dlinmodIgnoreDiscreteStates">Ignoring discrete states (use DLINMOD for proper handling)</entry>
    <entry key="dlinmodNoSampleTimeFoundUseFixedStepSize">No sample time found in the model. Defaulting to fixed step size.</entry>
    <entry key="dlinmodNoSampleTimeFound">No sample time found in the model. Defaulting to 1.</entry>
    <entry key="dlinmodv5RequireStateStruct">Models with Model blocks must use the state structure to initialize a linearization.</entry>
    <entry key="dlinmodv5StateStructXPert">When using the structure format for the model states the variable XPERT must be specified as a structure.</entry>
    <entry key="linmodNotSupportedMultipleModelReference">The model {0} is being used as a normal mode model reference and an accelerated model reference. This is not currently supported by the linear analysis tools. Please only use a single instance of a normal mode reference.</entry>
    <entry key="trimModelMustHaveOneState">트리밍하려면 시스템에 하나 이상의 상태가 있어야 합니다.</entry>
    <entry key="trimNotSupportedModelReference">Model 블록이 있는 모델은 명령 trim에서 지원되지 않습니다.</entry>
    <entry key="trimSupportContinuousDerivatives">명령 [X,U,Y,DX]=TRIM(''SYS'',X0,U0,Y0,IX,IU,IY,DX0,IDX)에서 DX0의 길이는 Simulink 모델의 연속 상태 수와 같아야 합니다.</entry>
    <entry key="slbusInvalidNumInputs">입력값 개수가 올바르지 않습니다.</entry>
    <entry key="slbusInvalidScope">Invalid scope argument. Valid values for
    scope are a Simulink.data.BaseWorkspace or Simulink.data.DataDictionary
    object.</entry>
    <entry key="slbusObjectToCellInvalidInput">입력값은 버스 이름을 포함한 셀형 배열이어야 합니다.</entry>
    <entry key="slbusNotPreserveAdditionalProps">Additional properties are not preserved for subclass of ''{0}''.</entry>
    <entry key="slbusSaveInvalidFirstArg">유효하지 않은 입력 인수입니다. 첫 번째 입력 인수와 두 번째 입력 인수는 문자형 벡터여야 합니다.</entry>
    <entry key="slbusSaveInvalidExt">유효하지 않은 파일 이름입니다. 파일 이름은 ''.m'' 확장자를 갖거나 확장자가 없어야 합니다.</entry>
    <entry key="slbusSaveFileAlreadyExists">파일 ''{0}''이(가) 존재합니다. 새 파일 이름을 지정하거나 파일 ''{1}''을(를) 삭제한 후 명령을 다시 실행하십시오.</entry>
    <entry key="slbusSaveDirDoesNotExist">지정된 디렉터리가 존재하지 않습니다.</entry>
    <entry key="slbusSaveInvalidSecondArg">두 번째 입력값은 ''cell'' 또는 ''object''여야 합니다.</entry>
    <entry key="slbusSaveInvalidThirdArg">세 번째 입력값은 버스 이름을 포함한 셀이어야 합니다.</entry>
    <entry key="slconnectionBusSaveInvalidSecondArg">두 번째 입력값은 연결 버스 이름으로 구성된 셀형 배열이어야 합니다.</entry>
    <entry key="slbusSaveFileOpenError">파일 ''{0}''을(를) 열어서 Bus 객체를 저장할 수 없습니다. 실제 오류는 ''{1}''입니다.</entry>
    <entry key="slbusCreateObjectInvalidModelName">유효하지 않은 모델 이름입니다.</entry>
    <entry key="slbusCreateObjectBadSimulationStatus">Simulation status of model ''{0}'' is ''{1}''. This indicates that the model is being run. \n Please stop the simulation, and rerun Simulink.Bus.createObject.</entry>
    <entry key="slbusCreateObjectGeneric">입력 구조체에서 필드 ''{0}''을(를) 처리하는 동안 Simulink.Bus.createObject가 다음 오류를 보고했습니다: \n''{1}''</entry>
    <entry key="slbusCreateObjectNonNumericStructField">구조체 필드 ''{0}''에 숫자형, 논리형 또는 MATLAB timeseries 값이 없습니다.</entry>
    <entry key="slbusCreateObjectNonVectorStringStructField">Structure field ''{0}'' does not have a string scalar or a one dimensional character array.</entry>
    <entry key="slbusCreateObjectOrderMismatch">The number of fields or their ordering is inconsistent at the following locations in the input structure: ''{0}'' and ''{1}''. Simulink.Bus.createObject requires all elements of a substructure array to be consistent with each other.</entry>
    <entry key="slbusCreateObjectStructNonStructMismatch">''{0}'' is a structure field, while ''{1}'' is not. Simulink.Bus.createObject requires all elements of a substructure array to be consistent with each other.</entry>
    <entry key="slbusCreateObjectDimsMismatch">입력 구조체의 위치 ''{0}'' 및 ''{1}''에서 필드 차원이 일치하지 않습니다. Simulink.Bus.createObject에서 하위 구조체형 배열의 모든 요소는 서로 일치해야 합니다.</entry>
    <entry key="slbusCreateObjectDataTypeMismatch">The data type of the fields is inconsistent at the following locations in the input structure: ''{0}'' and ''{1}''. Simulink.Bus.createObject requires all elements of a substructure array to be consistent with each other.</entry>
    <entry key="slbusCreateObjectComplexityMismatch">The complexity of the fields is inconsistent at the following locations in the input structure: ''{0}'' and ''{1}''. Simulink.Bus.createObject requires all elements of a substructure array to be consistent with each other.</entry>
    <entry key="slbusCreateObjectMultiColumnTimetable">Timetable형 객체는 하나의 변수만 가져야 합니다.</entry>
    <entry key="slbusCreateObjectMultiChannelDatastore">두 개 이상의 채널을 불러오도록 matlab.io.datastore.MDFDatastore 객체를 구성할 수 없습니다.</entry>
    <entry key="slbusCreateObjectInvalidPortElement">포트 ''{1}''의 요소 ''{0}''에 대한 Simulink.Bus를 생성할 수 없습니다.</entry>
    <entry key="slcreateMATLABStructInvalidFirstArgument">첫 번째 입력값은 유효한 Bus 객체 이름이거나 블록 포트에 대한 하나 이상의 유효한 핸들이어야 합니다(즉, 핸들이 둘 이상인 경우에는 배열이어야 함).</entry>
    <entry key="slcreateMATLABStructInvalidDimension">첫 번째 인수가 Bus 객체의 이름인 경우 유효한 차원 D=[d_1, ..., d_n]을 세 번째 입력 파라미터로 제공할 수 있습니다. 차원 값에 따라 결과 구조체의 차원이 결정됩니다. 두 번째 입력 파라미터에 부분 구조체를 사용하는 경우 부분 구조체의 차원 P=[p_1, ..., p_m]은 D와 호환되어야 합니다(즉, m &lt;= n이어야 하며 1&lt;=i&lt;=m일 때 p_i &lt;= d_i). 첫 번째 인수가 Bus 객체 이름으로 구성된 셀형 배열인 경우 유효한 차원의 셀형 배열을 제공할 수도 있습니다. 첫 번째 인수가 Bus 객체의 이름이 아닌 경우 차원을 제공할 수 없습니다.</entry>
    <entry key="slcreateMATLABStructInvalidPartialStruct">첫 번째 인수가 Bus 객체 이름이거나 블록 포트에 대한 유효한 핸들인 경우 두 번째 입력 인수는 MATLAB 구조체이거나 비어 있어야([]) 합니다. 이 구조체의 필드에 지정된 값에 따라, 결과로 생성된 전체 MATLAB 구조체의 해당 필드가 채워집니다. 첫 번째 인수가 블록 포트에 대한 핸들로 구성된 배열이거나 Bus 객체 이름으로 구성된 셀형 배열인 경우 두 번째 인수는 MATLAB 구조체로 구성된 셀형 배열이어야 합니다.</entry>
    <entry key="slcreateMATLABStructInvalidNumSecondArguments">port 핸들의 수는 지정된 부분 구조체의 수와 같아야 합니다.</entry>
    <entry key="slcreateMATLABStructStrictBusRequired">This utility function requires that the ''Mux blocks used to create bus signals'' diagnostic in the Connectivity panel of the Configuration Parameters dialog be set to ''error''</entry>
    <entry key="slcreateMATLABStructBadFieldInPartialStructure">The partial structure has an inconsistent shape and differs from the generated structure at ''{0}''</entry>
    <entry key="slcreateMATLABStructInconsistentDimensionInPartialStructure">The partial structure has an inconsistent dimension with the dimension of bus object node at ''{0}''.</entry>
    <entry key="slcreateMATLABStructBadFieldAttributeDimensions">''{0}''에 있는 부분 구조체에 지정된 값의 차원이 ''{1}''인 반면, 생성된 구조체에 있는 해당 값의 차원은 ''{2}''입니다</entry>
    <entry key="slcreateMATLABStructBadFieldAttributeDataType">부분 구조체의 필드 ''{0}''에 지정된 값의 데이터형은 ''{1}''이지만, Simulink.Bus.createMATLABStruct는 이 필드에 ''{2}'' 데이터형의 값이 필요합니다. 이 필드에 지정된 값을 ''{2}''(으)로 형변환하는 것은 정밀도 손실을 야기할 수 있으며 지원되지 않습니다.</entry>
    <entry key="slcreateMATLABStructBadFieldAttributeDataTypeConversion">부분 구조체의 필드 ''{0}''에 지정된 값의 데이터형은 ''{1}''이지만, Simulink.Bus.createMATLABStruct는 이 필드에 ''{2}'' 데이터형의 값이 필요합니다. 이 필드에 지정된 값이 ''{2}''(으)로 형변환되었습니다.</entry>
    <entry key="slcreateMATLABStructBadFieldAttributeComplexity">The value provided for the partial structure at ''{0}'' is ''{1}'', while the corresponding value in the generated structure is ''{2}''</entry>
    <entry key="slcreateMATLABStructFromBusObject">Simulink.Bus.createMATLABStruct는 임시 모델 ''TmpModelForCreatingMATLABStruct''를 사용하여 MATLAB 구조체를 만듭니다. 구조체를 만드는 동안 오류가 발생했습니다. 다음 원인을 참조하십시오:</entry>
    <entry key="MATitletipCheckForProperFcnCallRetVals">Simulink의 묵시적 Signal Conversion 블록 삽입으로 인해 잠재적 지연이 발생할 수 있는 함수 호출 블록 반환 값을 식별합니다.</entry>
    <entry key="MATitleCheckForProperFcnCallRetVals">잠재적 지연이 발생할 수 있는 함수 호출 블록 반환 값이 있는지 검사</entry>
    <entry key="MABlkPortPairListItem">블록의 입력 포트({0}):</entry>
    <entry key="MAMsgHiddenBufCausingLoop">해당 신호가 메모리 내에서 연속적이 되도록 하기 위해 Simulink가 다음 함수 호출 개시자 블록의 입력 포트 앞에 묵시적 Signal Conversion 블록을 삽입했습니다. 이로 인해 그러한 신호를 자신이 호출하는 Function-Call Subsystem에서 오는 반환 값으로 관찰 중일 가능성이 있는 함수 호출 개시자 블록에 한 개의 스텝 지연이 발생할 수 있습니다. 지연을 방지하려면 나열된 입력 포트의 신호가 호출 중인 Function-Call Subsystem 내의 신호 블록에서 발생한 것인지 확인하십시오. 지연을 허용할 수 있는 경우 해당 입력 포트 앞에 Unit Delay 블록을 삽입하십시오.</entry>
    <entry key="MATitleIdentSigsWithContTsAndNonFloatDataType">연속 샘플 시간과 비부동소수점 데이터형을 가진 블록 출력 신호 식별</entry>
    <entry key="MAUnableToRunCheckForProperBusOnSubsystem">''버스 사용'' 검사는 최상위 모델에만 사용 가능합니다. 이 검사를 수행하려면 최상위 모델에서 어드바이저를 실행하십시오.</entry>
    <entry key="MATitleCheckDisabledLinks">비활성화된 라이브러리 링크 식별</entry>
    <entry key="MATitletipCheckDisabledLinks">모델에서 비활성화된 라이브러리 링크를 검색합니다. 의도치 않게 비활성화된 라이브러리 링크는 예기치 않은 시뮬레이션 결과를 야기할 수 있습니다. 일반적으로 라이브러리 링크를 비활성화한 상태로 모델을 저장해서는 안 됩니다. 이 검사 결과는 알려진 업그레이드 문제에 대한 검사 결과와 겹칠 수 있습니다.</entry>
    <entry key="MAResultCheckDisabledLinks">아래에 나열된 블록은 비활성화된 라이브러리 링크입니다. 링크에 연결을 맺으려면 Simulink 다이어그램에서 블록을 마우스 오른쪽 버튼으로 클릭한 다음, ''{1}'' 메뉴에서 ''{0}''을(를) 선택하십시오.</entry>
    <entry key="MATitleCheckParameterizedLinks">파라미터화된 라이브러리 링크 식별</entry>
    <entry key="MATitletipCheckParameterizedLinks">모델에서 파라미터화된 라이브러리 링크를 검색합니다. 의도치 않게 파라미터화된 라이브러리 링크는 예기치 않은 시뮬레이션 결과를 야기할 수 있습니다.</entry>
    <entry key="MAResultCheckParameterizedLinks">다음 블록은 파라미터화된 라이브러리 링크입니다. Simulink 다이어그램에서 블록을 마우스 오른쪽 버튼으로 클릭한 다음 "라이브러리 링크" 메뉴에서 적절한 항목을 선택하여 변경 내용을 라이브러리에 전파하거나 폐기할 수 있습니다.</entry>
    <entry key="MAResultWeaklyTypedDataStores">다음 블록은 데이터형 또는 신호 유형을 상속하는 Data Store Memory 블록입니다. 데이터 저장소 메모리 유형을 강하게 지정하여 예기치 않은 데이터형 전파나 신호 유형 전파를 방지할 수 있습니다. 데이터형이 강하게 지정된 Simulink.Signal 객체로 맺은 연결을 통해서나 블록 대화 상자를 통해 데이터 저장소 메모리 유형을 강하게 지정할 수 있습니다.</entry>
    <entry key="MATitleCheckUnresolvedLinks">연결이 맺어지지 않은 라이브러리 링크 식별</entry>
    <entry key="MATitletipCheckUnresolvedLinks">모델에서 연결이 맺어지지 않은 라이브러리 링크를 검색합니다. 이는 해당하는 라이브러리 블록을 찾을 수 없는 라이브러리 링크입니다. 모델에 연결이 맺어지지 않은 링크가 있는 상태에서는 모델을 시뮬레이션할 수 없습니다.</entry>
    <entry key="MAResultCheckUnresolvedLinks">다음 블록은 연결이 맺어지지 않은 라이브러리 링크입니다. 각각의 경우 라이브러리를 찾을 수 없거나 지정된 이름의 블록이 라이브러리에 없습니다.</entry>
    <entry key="MALibLinksTaskTitle">라이브러리 링크 및 Variant 관리</entry>
    <entry key="MALibLinksTaskTitleTips">라이브러리 링크와 Variant에 자주 발생하는 문제를 식별하기 위해 검사합니다.</entry>
    <entry key="MATitleCheckVariantOverride">Variant 선택지를 재정의하는 Variant 블록 식별</entry>
    <entry key="MATitletipCheckVariantOverride">활성 Variant 제어를 사용하는 대신 재정의 옵션을 사용하여 Variant 선택지를 지정하는 Variant 블록을 식별합니다.</entry>
    <entry key="MAResultCheckVariantOverride"> 다음 블록은 OverrideUsingVariant 파라미터를 사용하여 Variant 선택지를 지정합니다.</entry>
    <entry key="MASubResultStatusVariantOverride">활성 Variant를 확인하려면 Variant 제어를 사용하십시오.</entry>
    <entry key="MAVariantOverrideCheckPassed">Variant 선택지를 재지정하는 Variant 블록을 찾을 수 없습니다.</entry>
    <entry key="VariantBlocks">블록</entry>
    <entry key="CurrentOverrideSetting">값 재정의</entry>
    <entry key="MAColTitle1ConvertMdlrefVarToVSS">블록 이름</entry>
    <entry key="MAColTitle2ConvertMdlrefVarToVSS">결과</entry>
    <entry key="MAColResultSuccessConvertMdlrefVarToVSS">변환됨</entry>
    <entry key="MATitleIdentConfigSubsys">모델에서 Variant Subsystem 블록으로 변환할 Configurable Subsystem 블록을 식별합니다.</entry>
    <entry key="MATitletipIdentConfigSubsys">모델 수준이나 서브시스템 수준에서 Configurable Subsystem 블록을 식별하고 업그레이드합니다. Variant Subsystem은 동일한 기능성을 유지하면서 향상된 기능을 제공합니다. 블록의 컨테이너로 사용된 Configurable Subsystem은 향후 릴리스에서 제거될 예정입니다. </entry>
    <entry key="MAConfigSubsysAction">모두 변환</entry>
    <entry key="MAConfigSubsysActionDescription">식별된 Configurable Subsystem 템플릿 블록을 Variant Subsystem 블록으로 변환합니다.</entry>
    <entry key="MADescriptionConfigSubsys">모델 수준이나 서브시스템 수준에서 Configurable Subsystem 블록을 식별하고 업그레이드합니다.</entry>
    <entry key="MADescriptionConfigSubsysByModelDisc">모델 또는 서브시스템 수준에서 모델 이산화로 생성된 Configurable Subsystem 인스턴스를 식별하고 업그레이드합니다.</entry>
    <entry key="MATitleConvertMdlrefVarToVSS">Model Variants 블록을 식별한 후 Model 블록 선택지가 포함된 Variant Subsystem 블록으로 변환</entry>
    <entry key="MATitletipConvertMdlrefVarToVSS">Model Variants 블록을 Model 블록 선택지가 포함된 Variant Subsystem 블록으로 업그레이드합니다. Variant Subsystem은 동일한 기능성을 유지하면서 향상된 기능을 제공합니다. Variant 모델의 컨테이너로 사용된 Model 블록은 향후 릴리스에서 제거될 예정입니다.</entry>
    <entry key="MADescriptionConvertMdlrefVarToVSS">Model Variants 블록을 모델 수준에서 식별합니다.</entry>
    <entry key="MAConvertMdlrefVarToVSSCheckActionButtonName">변환</entry>
    <entry key="MAConvertMdlrefVarToVSSCheckActionButtonDescription">Model Variants 블록을 Model 블록 선택지가 포함된 Variant Subsystem으로 변환합니다.</entry>
    <entry key="MAResultCheckForCSSTempBlocks">모델에서 다음 Configurable Subsystem 템플릿 블록이 발견되었습니다.</entry>
    <entry key="MAResultCheckForCSSBlocks">모델에서 다음 Configurable Subsystem 블록이 발견되었습니다.</entry>
    <entry key="MAResultInfoOnParameterizedCSSInstances">Configurable Subsystem 블록을 변환할 때 파라미터화된 데이터의 손실을 방지하려면 파라미터화된 모든 Configurable Subsystem 링크 블록을 업데이트해야 합니다. '파라미터화된 라이브러리 링크 식별' 모델 어드바이저 검사를 사용하여 파라미터화된 Configurable Subsystem 링크가 있는 모든 모델을 업데이트하십시오.
    </entry>
    <entry key="MAResultCheckStatusPass">변환 성공: ''{0}''</entry>
    <entry key="MAResultCheckStatusFail">변환 실패: ''{0}''</entry>
    <entry key="MAResultCheckStatusTitle">변환 상태:</entry>
    <entry key="MAResultCheckForCSSBlocksByModelDisc">모델 이산화로 생성된 다음 Configurable Subsystem 인스턴스가 모델에서 발견되었습니다.</entry>
    <entry key="MAResultCheckForConvertMdlrefVarToVSS">다음 Model Variants 블록이 발견됨</entry>
    <entry key="MAResultCheckForConvertMdlrefVarToVSSPass">Model Variants 블록을 찾을 수 없습니다.</entry>
    <entry key="MAResultActionForConvertMdlrefVarToVSSWarn">일부 Model Variants 블록을 Model 블록을 선택지로 갖는 Variant Subsystem 블록으로 변환할 수 없습니다. 그러한 Model Variant 블록을 Variant Subsystem 블록으로 변환하려면 다음 단계를 수행하십시오. 1) Variant Subsystem 블록을 추가합니다. 예: vssHandle = add_block('simulink/Ports &amp; Subsystems/Variant Subsystem', 'Model/VariantSubsystem', 'MakeNameUnique', 'on') 2) Model Variants 블록에서 참조하는 모든 Model 블록의 파라미터를 가져옵니다. 예: varParams = get_param('Model/ModelVariantsBlock', 'Variants'); 3) Variant Subsystem 블록에서 Model 블록을 선택지로 추가합니다. 예를 들어, 명령 choiceHandle = add_block('Model/ModelVariantsBlock', ['Model/VariantSubsystem/', varParams.ModelName(1)];을 사용하여 단일 선택지를 추가합니다. 4) 원래 Model Variants 블록에서 필수 파라미터를 설정합니다. set_param(choiceHandle, parameter, value)를 사용하여 파라미터 'Name', 'ModelName', 'ParameterArgumentValues', 'Simulation mode'를 설정합니다.</entry>
    <entry key="MAResultActionForConvertMdlrefVarToVSSPass">모든 Model Variants 블록을 Model 블록 선택지가 포함된 Variant Subsystem 블록으로 성공적으로 변환했습니다.</entry>
    <entry key="MASubResultStatusForCSSBlocks">&lt;p&gt;&lt;b&gt;모델 계층 구조를 분석하고 계속해서 업그레이드 시퀀스 진행&lt;/b&gt; 검사를 실행하고 Configurable Subsystem 템플릿 블록을 변환하여 나열된 Configurable Subsystem 블록을 업데이트합니다.&lt;/p&gt; </entry>
    <entry key="MASubResultStatusForCSSBlocksByModelDisc">&lt;p&gt;이산화에 대한 정보를 유지하려면 목록에 제공된 각 Configurable Subsystem 인스턴스를 마우스 오른쪽 버튼으로 클릭한 다음, [서브시스템 및 모델 참조] -&gt; [다음으로 변환] -&gt; [Variant Subsystem]을 선택하여 인스턴스를 Variant Subsystem으로 변환하십시오.&lt;/p&gt; </entry>
    <entry key="MACheckForCSSPassed">Configurable Subsystem 블록을 찾을 수 없습니다.</entry>
    <entry key="ParserConfigUnknownLang">인식할 수 없는 언어 ''{0}''입니다.</entry>
    <entry key="LCTErrorInvalidAction">''{0}''은(는) 유효하지 않은 동작임</entry>
    <entry key="LCTErrorFirstFcnArgumentMustBeStruct">First argument must be a structure (or an array of structures) initialized with legacy_code(''initialize'')</entry>
    <entry key="LCTErrorSecondFcnArgumentMustBeStruct">두 번째 인수는 legacy_code(''initialize'')로 초기화된 구조체(또는 구조체로 구성된 배열)여야 합니다</entry>
    <entry key="LCTErrorFirstFcnArgumentMustBeScalarStruct">First argument must be a 1x1 structure initialized with legacy_code(''initialize'')</entry>
    <entry key="LCTErrorCannotOpenFile">파일 "{0}.{1}" {2}을(를) 열 수 없음</entry>
    <entry key="LCTErrorCannotFindIncludePath">include 경로 "{0}"을(를) 찾을 수 없음</entry>
    <entry key="LCTErrorCannotFindSourcePath">소스 경로 "{0}"을(를) 찾을 수 없음</entry>
    <entry key="LCTErrorCannotFindLibraryPath">라이브러리 경로 "{0}"을(를) 찾을 수 없음</entry>
    <entry key="LCTErrorCannotFindSourceFile">소스 파일 "{0}"을(를) 찾을 수 없음</entry>
    <entry key="LCTErrorCannotFindLibraryFile">라이브러리 파일 "{0}"을(를) 찾을 수 없음</entry>
    <entry key="LCTErrorBadSimulinkVersion">Simulink 버전 "{0}"은(는) 지원되지 않음</entry>
    <entry key="LCTWarnFileConflict">파일 "{0}"이(가) 이미 존재하며 CMEX 파일이 아닙니다. 이 파일을 다른 디렉터리로 이동하거나 이름을 바꾸어야 하며, 아니면 SFunctionName이 달라야 합니다</entry>
    <entry key="LCTErrorBadArgumentOptionForCompilation">The second argument OPT must be a character vector or a cell array of character vectors</entry>
    <entry key="LCTErrorMexNotConfigured">''compile'' 옵션으로 legacy_code()를 호출하기 전에 먼저 C 컴파일러를 설정해야 합니다. MATLAB 명령 창에 mex(''-setup'')을 입력하십시오</entry>
    <entry key="LCTMsgStartCompiling">{0} 컴파일 시작</entry>
    <entry key="LCTMsgFinishCompiling">{0} 컴파일 마침</entry>
    <entry key="LCTMsgEndCompiling">종료</entry>
    <entry key="LCTBlkMaskDescription">이 블록을 사용하면 다음 레거시 코드 툴 정의를 통해 지정된 레거시 함수를 호출할 수 있습니다.\n{0}</entry>
    <entry key="LCTBlkMaskHelp">이 블록은 레거시 코드 툴로 자동으로 생성되었습니다. 이 툴에 대한 자세한 도움말을 보려면 다음을 호출하십시오.</entry>
    <entry key="LCTBlkMaskSampleTimeParam">샘플 시간(상속된 경우 -1)</entry>
    <entry key="LCTBlkMaskShowFcnSpecParam">함수 사양 표시</entry>
    <entry key="LCTErrorSLObjectNotFound">The data type "{0}" is neither a built-in data type, nor defined by a Simulink.AliasType, Simulink.NumericType, Simulink.Bus object, or an enumerated data type</entry>
    <entry key="LCTErrorSLObjectHeaderFile">The Simulink data object "{0}" (of class {1}) must provide a header file</entry>
    <entry key="LCTErrorEnumTypeMustSpecifyHeaderFile">The enumerated data type "{0}" must provide a header file</entry>
    <entry key="LCTErrorAddClassNameToEnumNamesNotSupported">The enumerated data type "{0}" cannot be configured for adding the class''s name to the enumerated values</entry>
    <entry key="LCTErrorBusElementEmpty">The Bus/StructType object "{0}" must contain 1 Bus/StructType element at least</entry>
    <entry key="LCTErrorBusElementBoolComplex">The Bus/StructType Element "{0}" (of Bus/StructType Object "{1}") can be only a native complex data type. Boolean complex data type is not supported</entry>
    <entry key="LCTErrorBusElementNonScalar">Bus 객체 "{1}"의 버스 요소 "{0}"은(는) 스칼라여야 함</entry>
    <entry key="LCTErrorBusElementBadDim">The dimensions of Bus Element "{0}" (of Bus Object "{1}") must be a valid numeric value.</entry>
    <entry key="LCTErrorUnspecifiedScaling">Simulink.NumericType with unspecified scaling is not supported ("{0}")</entry>
    <entry key="LCTErrorBadDimToTest">Bad dimensions to test</entry>
    <entry key="LCTErrorParseBadAssignement">Bad assignment in function specification "{0}". The return from the function must be only assigned to an output port value</entry>
    <entry key="LCTErrorParseUnrecognizedToken">Token (or expression) "{0}" not recognized (in "{1}")</entry>
    <entry key="LCTErrorParseMissingDataType">The data type (in expression "{0}") must be specified or is not valid (in "{1}")</entry>
    <entry key="LCTErrorParseBadDataId">An input/output/parameter/work number must be specified and &gt; 0 (in expression "{0}" from "{1}")</entry>
    <entry key="LCTErrorParseBadOutputOrDWorkDim">An output or a work dimension must be fully specified (in expression "{0}" from "{1}")</entry>
    <entry key="LCTErrorParseBadOutputOrDWorkDimForDynSize">An output or work dimension cannot be used for specifying a dynamically sized input/output/parameter/work  (in expression "{0}" from "{1}")</entry>
    <entry key="LCTErrorParseBadParameterDim">A parameter dimension cannot be specified by another parameter or input dimension  (in expression "{0}" from "{1}")</entry>
    <entry key="LCTErrorParseBadInputDim">An input dimension cannot be specified by another input dimension  (in expression "{0}" from "{1}")</entry>
    <entry key="LCTErrorParseDifferentDataSpec">The dimension and data type specifications must be the same across all function specifications</entry>
    <entry key="LCTErrorParseDuplicatedArgName">Function argument names must be unique</entry>
    <entry key="LCTErrorParseBadComplexSizeArg">The return value from the function size() cannot be complex</entry>
    <entry key="LCTErrorParseBadTrailingDim">For N-Dimensional input/output/parameter/work, the trailing dimension must be &gt; 1 (in expression "{0}" from "{1}")</entry>
    <entry key="LCTErrorParseBadDimSpec">The dimension specifications must be empty (for dynamically sized) or &gt; 0 otherwise (in expression "{0}" from "{1}")</entry>
    <entry key="LCTErrorParseBadDataAccessForMethod">During "{0}" method, the legacy code cannot access input/output value or address (in expression "{1}" from "{2}")</entry>
    <entry key="LCTErrorValidateDataId">{0} number must start at 1 and monotonically increased</entry>
    <entry key="LCTErrorValidateScalarBusObject">{0}은(는) Simulink.Bus 객체임. 스칼라여야 함</entry>
    <entry key="LCTErrorValidateParameterBusObject">파라미터는 Simulink.Bus 객체일 수 없음</entry>
    <entry key="LCTErrorValidateBadBooleanComplex">Only no-boolean complex built-in data types are supported ({0} {1,number,integer})</entry>
    <entry key="LCTErrorValidateBadParameterOrInputAsDim">{0} {1}{2,number,integer} has a reference to the non-existing {3} {4}{5,number,integer}</entry>
    <entry key="LCTErrorValidateBadScalarParameterOrInputAsDim">{0} {1}{2,number,integer} has a reference to the size of the scalar {3} {4}{5,number,integer}</entry>
    <entry key="LCTErrorValidateBadDimParameterOrInputAsDim">{0} {1}{2,number,integer} has a reference to a non-existing dimension of the {3} {4}{5,number,integer}</entry>
    <entry key="LCTErrorValidateBadComplexParamAsDim">The data type of the parameter p{0,number,integer} cannot be complex when its value is used for defining a dimension</entry>
    <entry key="LCTErrorValidateBadFixedPointParamAsDim">The data type of the parameter p{0,number,integer} cannot be fixed-point when its is used for defining a dimension</entry>
    <entry key="LCTErrorValidateBadParamValueAsDim">{0} {1}{2,number,integer} has a reference to the non-scalar Parameter p{3,number,integer}</entry>
    <entry key="LCTErrorValidateAllDynSize">When specifying input/output/parameter/work dynamically sized, all dimensions must be dynamically sized ({0} {1,number,integer})</entry>
    <entry key="LCTErrorValidateSizeArgDataType">The data type of the argument "{0}" (in function specification {1}FcnSpec) cannot be fixed-point nor a Bus Object</entry>
    <entry key="LCTErrorValidateSizeArgDataId">The argument "{0}" (in function specification {1}FcnSpec) has a reference to a non-existing {2} {3,number,integer}</entry>
    <entry key="LCTErrorValidateSizeArgDataDim">The argument "{0}" (in function specification {1}FcnSpec) has a reference to a non-existing dimension of the {2} {3,number,integer}</entry>
    <entry key="LCTErrorValidateVoidArg">Only work data can have the data type "void*" or "void**":\n{0}</entry>
    <entry key="LCTErrorValidateInvalideFieldName">함수 사양 구조체의 "{0}"이(가) 유효하지 않은 필드임</entry>
    <entry key="LCTErrorValidateInvalideFieldDataType">필드 "{0}"은(는) 현재 "{1}" 클래스인데, "{2}" 클래스여야 합니다</entry>
    <entry key="LCTErrorValidateInvalideStringFieldDataType">필드 "{0}"은(는) 문자형 벡터이거나 string형이어야 합니다</entry>
    <entry key="LCTErrorValidateBadLanguage">The field "Options.language" must be "C" or "C++"</entry>
    <entry key="LCTErrorValidateSampleTimeValue">SampleTime field must be non-negative (or -1 for inherited)</entry>
    <entry key="LCTErrorValidateSampleTimeOffsetValue">Offset must be smaller than period</entry>
    <entry key="LCTErrorValidateSampleTimeOffsetValue1">When period is -1, offset must be 0</entry>
    <entry key="LCTErrorValidateSampleTimeOffsetValue2">When period is 0, offset must be 1</entry>
    <entry key="LCTErrorValidateSampleTimeField">SampleTime 필드는 ''inherited'' 또는 ''parameterized''이거나 [값 오프셋] 또는 [값]이어야 합니다</entry>
    <entry key="LCTErrorValidateEmptyStringField">필드 "{0}"은(는) 비어 있지 않은 문자형 벡터여야 합니다</entry>
    <entry key="LCTErrorValidateSFunctionName">필드 "SFunctionName"에 유효하지 않은 문자("{0}")가 포함되어 있습니다</entry>
    <entry key="LCTErrorValidateCellString">필드 "{0}"은(는) 문자형 벡터로 구성된 셀 또는 string형 배열이어야 합니다</entry>
    <entry key="LCTErrorValidateBadHeaderFile">필드 "HeaderFiles"는 파일 이름만 허용합니다. "IncPaths" 필드에 경로 "{0}"을(를) 추가해야 합니다</entry>
    <entry key="LCTErrorValidateBadFile">Bad {0} file "{1}"</entry>
    <entry key="LCTErrorDataTypeWordlengthTooBig">The "Wordlength" property of the Simulink.NumericType "{0}" must be less than or equal to 64</entry>
    <entry key="LCTWarningDataTypeWordlengthModified">The data type "{0}" uses a word length ({1,number,integer}) that is not supported.\nFixed-point signals using this data type will be put inside a larger word length ({2,number,integer}).</entry>
    <entry key="LCTSFcnCppCodeAPIWarningSkipTLC">The specification for "{0}" is configured for using the S-Function Code Construction API. The TLC block file is not generated.</entry>
    <entry key="LCTSFcnCppCodeAPIWarningCppNotSupported">C++ 언어는 아직 S-Function 코드 생성 API에서 지원되지 않습니다. TLC 기반의 코드 생성을 사용해야 합니다.</entry>
    <entry key="LCTSFcnCppCodeAPIWarningNoSLDataObjectSupport">Simulink.AliasType, Simulink.NumericType 또는 Simulink.Bus에 대해 사용자가 제공한 헤더 파일은 아직 S-Function 코드 생성 API에서 지원되지 않습니다. TLC 기반의 코드 생성을 사용해야 합니다.</entry>
    <entry key="LCTSFcnCppCodeAPIWarningVoidWorkNotSupported">Void 작업은 아직 S-Function 코드 생성 API에서 지원되지 않습니다. TLC 기반 코드 생성을 사용해야 합니다.</entry>
    <entry key="LCTSFcnCppCodeAPIWarningManyHeaderfilesNotSupported">두 개 이상의 헤더 파일을 지정하는 것은 아직 S-Function 코드 생성 API에서 지원되지 않습니다. TLC 기반의 코드 생성을 사용해야 합니다.</entry>
    <entry key="LCTSFcnCppCodeAPIWarningEnclosedHeaderfilesNotSupported">''"'' 또는 ''&lt;&gt;''로 묶인 헤더 파일은 아직 S-Function 코드 생성 API에서 지원되지 않습니다. TLC 기반의 코드 생성을 사용해야 합니다.</entry>
    <entry key="LCTSFcnCodeAPIError2DMatrixNotSupported">Handling 2D Row Major Matrix is not yet supported by the S-Function Code Construction API. Must use TLC based code generation.</entry>
    <entry key="LCTSFcnBusElementCplx2DMatrixNotSupported">The Bus/StructType Element "{0}" (of Bus/StructType Object "{1}" specified by "{2}") is a 2D array of a complex type which is not supported when the option "convert2DMatrixToRowMajor" is true.</entry>
    <entry key="LCTSFcnCplx2DMatrixNotSupported">"{0}" is a 2D array of a complex type which is not supported when the option "convert2DMatrixToRowMajor" is true.</entry>
    <entry key="LCTSFcnCodeAPIErrorNDArrayNotSupported">Handling ND Row Major Array is not yet supported by the S-Function Code Construction API. Must use TLC based code generation.</entry>
    <entry key="LCTSFcnBusElementCplxNDArrayNotSupported">"{2}"에 의해 지정된 Bus/StructType 객체 "{1}"의 Bus/StructType 요소 "{0}"은(는) 옵션 "convertNDArrayToRowMajor"가 true인 경우 지원되지 않는 복소수형 N차원 배열입니다.</entry>
    <entry key="LCTSFcnCplxNDArrayNotSupported">"{0}"은(는) 옵션 "convertNDArrayToRowMajor"가 true인 경우 지원되지 않는 복소수형 N차원 배열입니다.</entry>
    <entry key="LCTSpecParserBadOutputAccessForMethod">레거시 코드는 조건부로 할당되지 않았기 때문에 "Output" 메서드 중에만 출력값 또는 주소에 액세스할 수 있습니다:\n{0}</entry>
    <entry key="LCTSpecParserBadOutputAccessForTerminate">The legacy code cannot access output value or address during the "Terminate" method:\n{0}</entry>
    <entry key="LCTSpecParserBadInputAccessForMethod">레거시 코드는 "Output" 메서드 중에만 입력값 또는 주소에 액세스할 수 있습니다:\n{0}</entry>
    <entry key="LCTSpecParserBadDimSpec">The dimension specifications must be empty (for dynamically sized) or &gt; 0 otherwise:\n{0}</entry>
    <entry key="LCTSpecParserBadTrailingDim">N차원의 입력/출력/파라미터/작업에서는 후행 차원이 1보다 커야 합니다.\n{0}</entry>
    <entry key="LCTSpecParserBadComplexSizeArg">함수 "size" 또는 "numel"의 반환 값은 복소수일 수 없습니다.\n{0}</entry>
    <entry key="LCTSpecParserBadFcnReturn">스칼라 출력값만 함수의 반환 값으로 지정할 수 있습니다:\n{0}</entry>
    <entry key="LCTSpecParserBadParameterDim">파라미터 차원은 또 다른 파라미터나 입력 차원으로 지정할 수 없습니다.\n{0}</entry>
    <entry key="LCTSpecParserBadInputDim">입력 차원은 또 다른 입력 차원으로 지정할 수 없습니다.\n{0}</entry>
    <entry key="LCTSpecParserBadOutputOrDWorkDimForDynSize">동적 크기의 입력/출력/파라미터/작업을 지정할 때 출력 차원이나 작업 차원을 사용할 수 없습니다.\n{0}</entry>
    <entry key="LCTSpecParserBadOutputOrDWorkDim">출력 차원이나 작업 차원을 완전히 지정해야 합니다:\n{0}</entry>
    <entry key="LCTSpecParserBadDataId">An input/output/parameter/work number must be specified and &gt; 0:\n{0}</entry>
    <entry key="LCTSpecParserUnrecognizedToken">인식할 수 없는 토큰(또는 표현식)임:\n{0}</entry>
    <entry key="LCTSpecParserBadSpec">표현식에서 유효한 함수 사양을 찾을 수 없습니다:\n{0}</entry>
    <entry key="LCTSpecParserBadLhsExpr">함수 사양에서 유효한 좌변 표현식을 찾을 수 없습니다(스칼라 출력값만 함수의 반환 값으로 지정할 수 있음):\n{0}</entry>
    <entry key="LCTSpecParserBadArgListExpr">함수 사양에서 유효한 인수 목록을 찾을 수 없습니다:\n{0}</entry>
    <entry key="LCTSpecParserBadRhsExpr">함수 사양의 요소를 인식할 수 없습니다:\n{0}</entry>
    <entry key="LCTSpecParserBadArgExpr">Unrecognized argument in the function specification:\n{0}</entry>
    <entry key="LCTSpecParserBadStars">Only 1 or 2 stars are allowed in the specification:\n{0}</entry>
    <entry key="LCTSpecParserBadVoidArg">지원되지 않는 void 인수 표현식입니다:\n{0}</entry>
    <entry key="LCTSpecParserBadMixedDynFixDims">Cannot mix dynamic and fix dimensions in the same specification:\n{0}</entry>
    <entry key="LCTSpecParserBadDynamicArrayRowMajor">동적 배열 차원은 행 우선이 지원되지 않음:\n{0}</entry>
    <entry key="LCTSpecParserBadDynamicArrayDWork">동적 배열 차원은 Dwork가 지원되지 않음:\n{0}</entry>
    <entry key="LCTSpecParserBadDynamicArrayParameter">동적 배열 차원은 파라미터가 지원되지 않음:\n{0}</entry>
    <entry key="LCTSpecParserBadDynamicArrayBusElement">Dynamic array dimensions are not supported for Simulink.BusElement (element "{0}" in Simulink.Bus "{1}")</entry>
    <entry key="LCTSpecParserBadDynamicArrayCodeAPI">Dynamic array dimensions are not supported by the S-Function Code Construction API. Must use TLC based code generation.</entry>
    <entry key="LCTSizeSpecParserBadSizeSyntaxWithDesc">Invalid syntax in the specification:\n{0}</entry>
    <entry key="LCTSizeSpecParserBadSizeSyntax">사양의 구문이 유효하지 않음</entry>
    <entry key="LCTSizeSpecParserSizeExprNotParameterAccess">표현식에는 파라미터 이름만 사용할 수 있음("{0}" 발견됨)</entry>
    <entry key="LCTSizeSpecParserSizeExprNotSupportedFun">함수 "size" 및 "numel"만 지원됨("{0}" 발견됨)</entry>
    <entry key="LCTSizeSpecParserSizeExprArg1NotCallNode">함수 "{1}"에 전달된 첫 번째 인수는 지원되지 않음(현재 "{0}"임)</entry>
    <entry key="LCTSizeSpecParserSizeExprArg1NotDataName">함수 "{1}"에 전달된 첫 번째 인수를 인식할 수 없음("{0}" 발견됨)</entry>
    <entry key="LCTSizeSpecParserSizeExprArg1IsDWork">작업 데이터에 대해 함수 "size"를 호출할 수 없음</entry>
    <entry key="LCTSizeSpecParserSizeExprBadSizeNumArg">함수 "size"는 2개의 인수를 가져야 함({0}개 발견됨)</entry>
    <entry key="LCTSizeSpecParserSizeExprArg2NotInt">함수 "size"에 전달된 두 번째 인수는 정수여야 함("{0}" 발견됨)</entry>
    <entry key="LCTSizeSpecParserSizeExprArg2NotPosInt">함수 "size"에 전달된 두 번째 인수는 0보다 큰 정수여야 함(현재 {0}임)</entry>
    <entry key="LCTSizeSpecParserSizeExprBadNumelNumArg">함수 "numel"은 한 개의 인수를 가져야 함({0}개 발견됨)</entry>
    <entry key="LCTSizeSpecParserSizeExprBadOp">"{0}"은(는) 지원되지 않는 표현식임</entry>
    <entry key="LCTSpecBadId">"{0}"은(는) 지원되지 않는 식별자임</entry>
    <entry key="LCTSizeSpecParserNegExpr">표현식 "{0}"은(는) 음수 값 "{1}"(으)로 평가됨</entry>
    <entry key="LCTSizeSpecParserFltExpr">표현식 "{0}"은(는) 정수가 아닌 값 "{1}"(으)로 평가됨</entry>
    <entry key="LCTGlobalIOInputsOutputsOnly">Invalid global variable specification "{0}". Global variables are only supported for inputs, outputs, parameters and data store memories.</entry>
    <entry key="LCTGetSetIODSMParamOnly">Invalid get/set specification "{0}". Get/set functions are only supported for parameters and data store memories.</entry>
    <entry key="LCTGlobalIOMissingColon">Missing colon in expression. Expected expression of form: {0} ...</entry>
    <entry key="LCTGlobalIONeedsDataTypeAndPortID">Invalid global variable specification "{0}". Global variable specification must contain a data type and a port specification.</entry>
    <entry key="LCTGlobalIOPointerNoExtern">Invalid global variable specification "{0}". Global I/O with pointer variables only supports extern pointer types.</entry>
    <entry key="LCTGlobalIORequireStubSimBehavior">Global I/O and data store memories are only supported through the cross-release code integration workflow.</entry>
    <entry key="LCTGlobalIODoesntSupportSingleCPPMexFile">Global I/O does not support ''SingleCPPMexFile''.</entry>
    <entry key="LCTGlobalIODoesntSupportMultipleExecInstances">Global I/O does not support ''MultipleExecInstances''.</entry>
    <entry key="LCTGlobalIODoesntSupportConvert2DMatrixToRowMajor">Global I/O does not support ''convert2DMatrixToRowMajor''.</entry>
    <entry key="LCTGlobalIODoesntSupportConvertNDArrayToRowMajor">Global I/O does not support ''convertNDArrayToRowMajor''.</entry>
    <entry key="LCTGlobalIncompatibleStorageClass">이름 충돌로 인해 블록 "{2}"의 {0} 포트 {1}이(가) "{3}" 스토리지 클래스와 지정된 식별자 "{4}"을(를) 갖는 신호에 연결되지 못합니다. 다른 식별자 또는 다른 스토리지 클래스를 사용하십시오.</entry>
    <entry key="LCTGlobalIncompatibleRootIOStorageClass">변수 소유권 충돌로 인해 블록 "{2}"의 {0} 포트 {1}이(가) 지정된 식별자 "{3}"을(를) 갖는 신호에 연결되지 못합니다. 다른 식별자를 사용하거나, Simulink 구성 세트 파라미터 ''EnableDataOwnership''을 ''on''으로 설정한 다음 사용자 지정 스토리지 클래스에 Exported Scope(예: ExportToFile)를 사용하고 ''Owner'' 특성을 비어 있지 않도록 구성하십시오.</entry>
    <entry key="LCTGlobalInputOutputOnly">"{0}"은(는) 유효하지 않은 portType입니다. portType은 "Output" 또는 "Input"이어야 합니다.</entry>
    <entry key="LCTGlobalDSMInvalidReadOnlyTag">Invalid global DSM expression "{0}". The only permitted suffix after the variable name "{1}" is "readonly", which indicates a read-only DSM.</entry>
    <entry key="LCTGetSetNeedWorkspaceName">Invalid get/set specification "{0}". Expected signal or parameter workspace object name after colon.</entry>
    <entry key="LCTGetSetNeedGetMethod">Invalid get/set specification "{0}". Get method must always be defined.</entry>
    <entry key="LCTDSMFunctionArgNotSupported">Invalid argument in definition of {1} function "{0}":  Data store memories are not supported as function arguments.</entry>
    <entry key="LCTNamedDataTypeConflictsWithOpaque">Conflict between named data type ''{0}'' and a data type that has already been defined.</entry>
    <entry key="LCTOpaqueDataTypeConflictsWithNamed">Conflict between data type ''{0}'' and a named data type that has already been defined.</entry>
    <entry key="LCTCannotDriveMultipleRootOutportsWithStorageClass">크로스 릴리스 블록 {1}의 &lt;sldiag objui="outport" objparam="{0}" objname="{1}"&gt;출력 포트 {0}&lt;/sldiag&gt;은(는) 두 개 이상의 루트 출력 포트를 직접 구동합니다. 루트 출력 포트 중 한 개 이상이 명시적 스토리지 클래스로 구성되었습니다. 생성된 코드의 출력 포트와 가져온 코드의 변수 간 관계를 정의하려면 부모 모델에서 명명된 신호와 명시적 스토리지 클래스를 블록 출력 포트에 연결된 선에 할당하십시오.</entry>
    <entry key="LCTFileNotGeneratedByLCT">파일 ''{0}''은(는) 레거시 코드 툴로 생성되지 않았습니다.</entry>
    <entry key="LCTCannotParseFileContents">파일 ''{0}''의 내용을 구문 분석할 수 없습니다.</entry>
    <entry key="LCTBadFixedFileContents">파일 ''{0}''을(를) 수정할 수 없습니다.</entry>
    <entry key="slSaveAsBadVersion">저장하려는 버전 ''{0}''은(는) 지원되지 않습니다.</entry>
    <entry key="slSaveAsDepreciatedVersion">선택한 버전 ''{0}''로 저장하는 기능은 더 이상 지원되지 않으며 향후 Simulink 릴리스에서 제거될 예정입니다.</entry>
    <entry key="FxpCheckFailed">''{0}''에 대해 모델 어드바이저 고정소수점 검사를 수행할 수 없습니다. 오류가 발생했습니다. \n''{1}''</entry>
    <entry key="FxpCheckFailedModelIntDivSettings">모델의 정수 나눗셈 설정</entry>
    <entry key="FxpCheckFailedProductBlockRounding">Product 블록 반올림</entry>
    <entry key="FxpCheckFailedLookupBlockRounding">Lookup 블록 반올림</entry>
    <entry key="FxpCheckFailedLookupBreakpointSpacing">Lookup 절점 간격</entry>
    <entry key="FxpCheckFailedPreLookupBlocks">PreLookup 블록</entry>
    <entry key="FxpCheckFailedGainBlocks">Gain 블록</entry>
    <entry key="FxpCheckFailedProductBlocks">Product 블록</entry>
    <entry key="FxpCheckFailedDotProductBlocks">Dot Product 블록</entry>
    <entry key="FxpCheckFailedSumBlocks">Sum 블록</entry>
    <entry key="FxpCheckFailedRelopBlocks">Relational Operator 블록</entry>
    <entry key="FxpCheckFailedMinmaxBlocks">MinMax 블록</entry>
    <entry key="FxpCheckFailedDiscreteIntegratorBlocks">Discrete Integrator 블록</entry>
    <entry key="FxpCheckFailedDTCBlocks">Data Type Conversion 블록</entry>
    <entry key="FxpCheckFailedCompToZeroBlocks">Compare To Zero 블록</entry>
    <entry key="FxpCheckFailedCompToConstBlocks">Compare To Constant 블록</entry>
    <entry key="FxpPreLookupDivision">다음 블록에 대한 최적화 기회: 인덱스 탐색 방법이 ''균일 간격의 점''이고, ''절점'' 데이터가 조정 불가형인\n경우 2의 짝수 거듭제곱 간격을 사용해 보십시오. 그 외의 경우에는 다른 인덱스 탐색 방법을 지정하여\n계산량이 많은 나눗셈 연산을 방지하십시오.</entry>
    <entry key="FxpEvenSpacingSignificant">다음 Lookup Table 블록에 대한 최적화 기회: ''입력값으로 구성된 벡터''가 조정 불가형인 경우,\n''입력값으로 구성된 벡터'' 데이터를 균일한 간격으로 만드십시오. 2의 거듭제곱 간격을 사용하면 더 효율적인 구현을\n생성할 수 있습니다. 자세한 내용은 fixpt_look1_func_approx를 참조하십시오.</entry>
    <entry key="FxpEvenSpacingSlight">다음 Lookup Table 블록에 대한 최적화 기회: ''입력값으로 구성된 벡터'' 데이터가 양자화됐을 때 거의 균일한 간격이 되는 경우,\n''입력값으로 구성된 벡터'' 데이터를 균일한 간격으로 만드십시오. 2의 거듭제곱 간격을 사용하면 더 효율적인 구현을\n 생성할 수 있습니다. 자세한 내용은 fixpt_evenspace_cleanup을 참조하십시오.</entry>
    <entry key="FxpEvenSpacingPerfect">다음 Lookup Table 블록에 대한 최적화 기회: ''입력값으로 구성된 벡터'' 데이터가 균일한 간격으로 되어 있고,\n조정 불가형인 경우 2의 짝수 거듭제곱 간격을 사용하고 그에 따라 테이블을 변경해 보십시오. 그러면 나눗셈 대신에\n시프트를 사용하는 단순화된 구현이 가능해집니다. 자세한 내용은 fixpt_look1_func_approx를 참조하십시오.</entry>
    <entry key="FxpEvenSpacingPow2WithNonEvenSearch">다음 1-D, 2-D 또는 n-D Lookup Table 블록에 대한 최적화 기회: ''절점'' 데이터가 2의 짝수 거듭제곱 간격을 갖고 조정 불가형인 경우\n''균일 간격의 점'' 탐색 방법이 권장됩니다. 나눗셈 연산을 방지하고 ''절점'' 데이터에 대한 메모리 요구 사항이 \n줄어들기 때문에 동일한 결과를 더 효율적으로 달성할 수 있습니다.</entry>
    <entry key="FxpEvenSpacingNotPow2WithNonEvenSearch">다음 1-D, 2-D 또는 n-D Lookup Table 블록에 대한 최적화 기회: ''절점'' 데이터가 균일한 간격으로 되어 있는 경우, 효율성 개선과 메모리 절약을 위해 \n''인덱스 탐색 방법''을 ''균일 간격의 점''으로 설정하십시오. ''절점'' 데이터가 조정 불가형인 경우 효율성을\n더 높이려면 2의 짝수 거듭제곱 간격을 사용해 보십시오. </entry>
    <entry key="FxpEvenSpacingNotPow2WithEvenSearch">다음 1-D, 2-D 또는 n-D Lookup Table 블록에 대한 최적화 기회: ''절점'' 데이터가 균일한 간격으로 되어 있고,\n조정 불가형인 경우 ''절점'' 데이터를 2의 짝수 거듭제곱 간격으로 조정하십시오. 그러면 나눗셈 대신에\n 시프트를 사용하는 단순화된 구현이 가능해집니다. 자세한 내용은 fixpt_look1_func_approx를 참조하십시오.</entry>
    <entry key="FxpNotEvenSpacingWithNonEvenSearch">다음 1-D, 2-D 또는 n-D Lookup Table 블록에 대한 최적화 기회: ''절점'' 데이터가 조정 불가형인 경우,\n ''절점'' 데이터를 2의 짝수 거듭제곱 간격을 갖도록 조정하고 ''균일 간격의 점'' 인덱스 탐색 방법을 사용하십시오.\n 그러면 더 효율적인 구현이 가능해집니다.</entry>
    <entry key="FxpCheckDIntegrateBlock">다음 Discrete Integrator는 복잡한 초기 조건 모드를 갖습니다. \n초기 조건은 상태와 출력을 초기화하는 데 사용됩니다. \n따라서 출력 방정식에 추가 생성 코드가 필요하고 추가 \n전역 변수도 필요합니다. 상태만 초기화하도록 초기 조건 모드를 \n설정하는 것이 더 효율적입니다.</entry>
    <entry key="FxpCouldNotComputeRounding">모델 어드바이저에서 다음 Product 블록에 대한 가장 효율적인 반올림 방법을\n계산할 수 없습니다.</entry>
    <entry key="FxpSuggestMoreEfficientRounding">가장 효율적으로 생성된 코드를 얻으려면 다음 블록의 &lt;b&gt;정수 \n계산의 반올림 방향&lt;/b&gt; 파라미터를 {0}(으)로 변경해야 합니다.</entry>
    <entry key="FxpCheckLookupRounding">가장 효율적으로 생성된 코드를 얻으려면 다음 블록의 &lt;b&gt;정수 \n계산의 반올림 방향&lt;/b&gt; 파라미터를 &lt;code&gt;최대단순(Simplest)&lt;/code&gt;으로 변경해야 합니다.</entry>
    <entry key="FxpCheckDTConvRounding">가장 효율적으로 생성된 코드를 얻으려면 다음 블록의 &lt;b&gt;정수 \n계산의 반올림 방향&lt;/b&gt; 파라미터를 &lt;code&gt;최대단순(Simplest)&lt;/code&gt;으로 변경해야 합니다.</entry>
    <entry key="FxpCheckProductBlock">불변 상수 값을 가진 입력(샘플 시간 색 자홍색)이 \n온라인 나눗셈 연산에서 분모로 사용됩니다. 나눗셈 연산이 곱셈으로 변경되고 \n불변 입력이 역수로 대체되면 나눗셈은 \n오프라인에서 수행되고 곱셈이 온라인 연산이 됩니다. 그 결과 \n종종 만족스러운 수치가 계산되고 대개 더 적은 양의 코드가 더 빨리 \n생성됩니다.</entry>
    <entry key="FxpCheckMultiWord">\n이 옵션을 사용하려면 멀티워드 연산을 방지하도록 다음 블록의 워드 길이를 변경하십시오. </entry>
    <entry key="FxpNetSlopeChangeRndMethod">\n이 옵션을 사용하려면 다음 블록의 &lt;b&gt;정수 반올림 모드&lt;/b&gt; 파라미터를 &lt;code&gt;최대단순(Simplest)&lt;/code&gt;으로 변경하거나, &lt;b&gt;구성 파라미터 &gt; 하드웨어 구현 &gt; 장치 세부 정보 &gt; 부호 있는 정수 나눗셈의 반올림 방식&lt;/b&gt; 설정으로 변경하십시오. </entry>
    <entry key="FxpNetSlopeChangeHWRndMeth">\n이 옵션을 사용하려면 &lt;b&gt;구성 파라미터 &gt; 하드웨어 구현 &gt; 장치 세부 정보 &gt; 부호 있는 정수 나눗셈의 반올림 방식&lt;/b&gt; 설정을 &lt;code&gt;0 방향(Zero)&lt;/code&gt; 또는 &lt;code&gt;내림(Floor)&lt;/code&gt;으로 변경하십시오.</entry>
    <entry key="FxpCheckMulOptSetOnRationalApprox">다음 블록은 곱셈을 위해 순 기울기 계산을 불러옵니다. 이 모델에는 &lt;b&gt;구성 파라미터 &gt; 수학 연산 및 데이터형 &gt; 고정소수점 순 기울기 계산에 나눗셈 사용&lt;/b&gt; 설정이 &lt;code&gt;켜기&lt;/code&gt;로 설정되어 있습니다. </entry>
    <entry key="FxpCheckMulOptSetOnReciprocalOfInt">다음 블록은 곱셈을 위해 순 기울기 계산을 불러옵니다. 이 모델에는 &lt;b&gt;구성 파라미터 &gt; 수학 연산 및 데이터형 &gt; 고정소수점 순 기울기 계산에 나눗셈 사용&lt;/b&gt; 설정이 &lt;code&gt;정수의 역수에만 나눗셈 사용&lt;/code&gt;으로 설정되어 있습니다. </entry>
    <entry key="FxpCheckMulOptSetOffRationalApprox">다음 블록은 곱셈을 위해 순 기울기 계산을 불러옵니다. 순 기울기 계산은 곱셈-및-시프트 또는 정수 곱셈 및/또는 나눗셈을 통해 구현할 수 있습니다. &lt;b&gt;구성 파라미터 &gt; 수학 연산 및 데이터형 &gt; 고정소수점 순 기울기 계산에 나눗셈 사용&lt;/b&gt; 설정을 &lt;code&gt;켜기&lt;/code&gt;로 변경하면 더 효율적인 코드를 생성할 가능성이 있습니다. 예를 들어 fixdt(1, 16, 7/10, 0)부터 fixdt(1, 16, 1, 0)까지의 순 기울기 계산은 Qu*11469 &gt;&gt; 14 대신에 Qy = (Qu*7)/10을 사용하여 수행할 수 있습니다. </entry>
    <entry key="FxpCheckMulOptSetOffReciprocalOfInt">다음 블록은 곱셈을 위해 순 기울기 계산을 불러옵니다. 순 기울기 계산은 곱셈 및 시프트 또는 정수 나눗셈을 통해 구현할 수 있습니다. &lt;b&gt;구성 파라미터 &gt; 수학 연산 및 데이터형 &gt; 고정소수점 순 기울기 계산에 나눗셈 사용&lt;/b&gt; 설정을 &lt;code&gt;정수의 역수에만 나눗셈 사용&lt;/code&gt; 또는 &lt;code&gt;켜기&lt;/code&gt;로 변경하면 더 효율적인 코드를 생성할 가능성이 있습니다. 예를 들어 fixdt(1, 16, 1/1000, 0)부터 fixdt(1, 16, 1, 0)까지의 순 기울기 계산은 Qy = (int16_T)((int32_T)Qu * 1677L &gt;&gt; 24) 대신 Qy = Qu/1000을 사용하여 수행할 수 있습니다. </entry>
    <entry key="FxpCheckMulOptSetOffRationalApproxSetOnReciprocalOfInt">다음 블록은 곱셈을 위해 순 기울기 계산을 불러옵니다. &lt;b&gt;구성 파라미터 &gt; 수학 연산 및 데이터형 &gt; 고정소수점 순 기울기 계산에 나눗셈 사용&lt;/b&gt; 설정이 &lt;code&gt;정수의 역수에만 나눗셈 사용&lt;/code&gt;으로 설정되어 있습니다. 이 설정을 &lt;code&gt;켜기&lt;/code&gt;로 변경하면 더 효율적인 코드를 생성할 가능성이 있습니다. 예를 들어 fixdt(1, 16, 7/10, 0)부터 fixdt(1, 16, 1, 0)까지의 순 기울기 계산은 Qu*11469 &gt;&gt; 14 대신에 Qy = (Qu*7)/10을 사용하여 수행할 수 있습니다. </entry>
    <entry key="FxpCheckCastOptSetOnRationalApprox">다음 블록은 형변환을 위해 순 기울기 계산을 불러옵니다. 이 모델에는 &lt;b&gt;구성 파라미터 &gt; 수학 연산 및 데이터형 &gt; 고정소수점 순 기울기 계산에 나눗셈 사용&lt;/b&gt; 설정이 &lt;code&gt;켜기&lt;/code&gt;로 설정되어 있습니다. </entry>
    <entry key="FxpCheckCastOptSetOnReciprocalOfInt">다음 블록은 형변환을 위해 순 기울기 계산을 불러옵니다. 이 모델에는 &lt;b&gt;구성 파라미터 &gt; 수학 연산 및 데이터형 &gt; 고정소수점 순 기울기 계산에 나눗셈 사용&lt;/b&gt; 설정이 &lt;code&gt;정수의 역수에만 나눗셈 사용&lt;/code&gt;으로 설정되어 있습니다. </entry>
    <entry key="FxpCheckCastOptSetOffRationalApprox">다음 블록은 형변환을 위해 순 기울기 계산을 불러옵니다. 순 기울기 계산은 곱셈-및-시프트 또는 정수 곱셈 및/또는 나눗셈을 통해 구현할 수 있습니다. &lt;b&gt;구성 파라미터 &gt; 수학 연산 및 데이터형 &gt; 고정소수점 순 기울기 계산에 나눗셈 사용&lt;/b&gt; 설정을 &lt;code&gt;켜기&lt;/code&gt;로 변경하면 더 효율적인 코드를 생성할 가능성이 있습니다. 예를 들어 fixdt(1, 16, 7/10, 0)부터 fixdt(1, 16, 1, 0)까지의 순 기울기 계산은 Qu*11469 &gt;&gt; 14 대신에 Qy = (Qu*7)/10을 사용하여 수행할 수 있습니다. </entry>
    <entry key="FxpCheckCastOptSetOffReciprocalOfInt">다음 블록은 형변환을 위해 순 기울기 계산을 불러옵니다. 순 기울기 계산은 곱셈 및 시프트 또는 정수 나눗셈을 통해 구현할 수 있습니다. &lt;b&gt;구성 파라미터 &gt; 수학 연산 및 데이터형 &gt; 고정소수점 순 기울기 계산에 나눗셈 사용&lt;/b&gt; 설정을 &lt;code&gt;정수의 역수에만 나눗셈 사용&lt;/code&gt; 또는 &lt;code&gt;켜기&lt;/code&gt;로 변경하면 더 효율적인 코드를 생성할 가능성이 있습니다. 예를 들어 fixdt(1, 16, 1/1000, 0)부터 fixdt(1, 16, 1, 0)까지의 순 기울기 계산은 Qy = (int16_T)((int32_T)Qu * 1677L &gt;&gt; 24) 대신 Qy = Qu/1000을 사용하여 수행할 수 있습니다. </entry>
    <entry key="FxpCheckCastOptSetOffRationalApproxSetOnReciprocalOfInt">다음 블록은 형변환을 위해 순 기울기 계산을 불러옵니다. &lt;b&gt;구성 파라미터 &gt; 수학 연산 및 데이터형 &gt; 고정소수점 순 기울기 계산에 나눗셈 사용&lt;/b&gt; 설정이 &lt;code&gt;정수의 역수에만 나눗셈 사용&lt;/code&gt;으로 설정되어 있습니다. 이 설정을 &lt;code&gt;켜기&lt;/code&gt;로 변경하면 더 효율적인 코드를 생성할 가능성이 있습니다. 예를 들어 fixdt(1, 16, 7/10, 0)부터 fixdt(1, 16, 1, 0)까지의 순 기울기 계산은 Qu*11469 &gt;&gt; 14 대신에 Qy = (Qu*7)/10을 사용하여 수행할 수 있습니다. </entry>
    <entry key="FxpMulCheckSatOnUseMinMaxOff">다음 블록에는 아주 복잡한 곱셈이 필요합니다. \n첫 번째 입력은 {0,number,* #0}비트입니다. \n두 번째 입력은 {1,number,* #0}비트입니다. \n이상적인 곱은 {2,number,* #0}비트입니다. \n타깃의 최대 정수 크기는 {3,number,integer}비트에 불과합니다. \n포화가 켜짐 상태이기 때문에, C 코드에서 \n이상적인 곱의 {4,number,integer}비트를 모두 확인해야 합니다.\n이 곱셈을 수행하는 데 필요한 C 코드는 크기가 크고 속도가 느립니다. \n이 타깃의 경우 곱셈을 \n{5,number,integer}비트와 {6,number,integer}비트의 곱으로 제한하는 것이 적극 권장됩니다.</entry>
    <entry key="FxpMulCheckSatOffUseMinMaxOff">다음 블록에는 아주 복잡한 곱셈이 필요합니다. \n첫 번째 입력은 {0,number,* #0}비트입니다. \n두 번째 입력은 {1,number,* #0}비트입니다. \n이상적인 곱은 {2,number,* #0}비트입니다. \n타깃의 최대 정수 크기는 {3,number,integer}비트에 불과합니다. \n입력과 출력의 상대 스케일링을 하려면 \n이상적인 곱의 최상위 {4,number,integer}비트 중 일부를 C 코드에서 확인해야 합니다. \n이 곱셈을 수행하는 데 필요한 C 코드는 크기가 크고 속도가 느립니다. \n이 타깃의 경우 곱셈을 \n{5,number,integer}비트와 {6,number,integer}비트의 곱으로 제한하는 것이 적극 권장됩니다.</entry>
    <entry key="FxpMulCheckSatOnUseMinMaxOn">입력 범위가 적절히 지정되지 않은 경우(지정된 최솟값과 최댓값을 사용하여 생성 코드를 최적화하는 방법에 대한 자세한 내용은 관련 문서 참조), 다음 블록에 아주 복잡한 곱셈이 필요할 수 있습니다. \n첫 번째 입력은 {0,number,* #0}비트입니다. \n두 번째 입력은 {1,number,* #0}비트입니다. \n유형 정보만 감안하면 이상적인 곱은 {2,number,* #0}비트입니다. \n타깃의 최대 정수 크기는 {3,number,integer}비트에 불과합니다. \n포화가 켜짐 상태이기 때문에, C 코드에서 이상적인 곱의 {4,number,integer}비트를 \n모두 확인해야 할 수 있습니다.\n이 곱셈을 수행하는 데 필요한 C 코드는 크기가 크고 속도가 느립니다. \n이 타깃의 경우 곱셈을 \n{5,number,integer}비트와 {6,number,integer}비트의 곱으로 제한하는 것이 적극 권장됩니다.</entry>
    <entry key="FxpMulCheckSatOffUseMinMaxOn">입력 범위가 적절히 지정되지 않은 경우(지정된 최솟값과 최댓값을 사용하여 생성 코드를 최적화하는 방법에 대한 자세한 내용은 관련 문서 참조), 다음 블록에 아주 복잡한 곱셈이 필요할 수 있습니다. \n첫 번째 입력은 {0,number,* #0}비트입니다. \n두 번째 입력은 {1,number,* #0}비트입니다. \n유형 정보만 감안하면 이상적인 곱은 {2,number,* #0}비트입니다. \n타깃의 최대 정수 크기는 {3,number,integer}비트에 불과합니다. \n입력과 출력의 상대 스케일링을 하려면 \n이상적인 곱의 최상위 {4,number,integer}비트 중 일부를 C 코드에서 확인해야 할 수 있습니다. \n이 곱셈을 수행하는 데 필요한 C 코드는 크기가 크고 속도가 느립니다. \n이 타깃의 경우 곱셈을 \n{5,number,integer}비트와 {6,number,integer}비트의 곱으로 제한하는 것이 적극 권장됩니다.</entry>
    <entry key="FxpMulCheckNoZeroBias">현재 다음 블록이 0이 아닌 편향을 갖는 신호를 곱하고 있습니다. \n가능하면 이 작업을 피하는 것이 좋습니다. \n곱셈을 구현하려면 추가 단계가 필요하기 때문입니다. \n이 작업을 피하려면 곱셈을 수행하는 블록의 앞 및/또는 뒤에\nData Type Conversion 블록을 삽입하십시오. 그러면 편향이 \n제거되고, 데이터형과 중간 계산에 대한 \n스케일링을 제어할 수 있습니다. 대부분의 경우 \nData Type Conversion 블록을 (서브)시스템의 "가장자리"로 옮길 수 있습니다.\n변환은 한 번만 수행되고, 서브시스템의 모든 블록이 \n더 단순하고 편향 없는 계산을 활용할 수 있습니다.</entry>
    <entry key="FxpMulCheckMismatchSlope">현재 다음 블록이 서로 일치하지 않는 기울기 조정 인자를 가진 신호를 곱하고 있습니다. \n첫 번째 입력의 기울기 조정 인자는 {0}입니다.\n두 번째 입력의 기울기 조정 인자는 {1}입니다. \n출력의 기울기 조정 인자는 {2}입니다. \n순 기울기 조정은 {3}입니다.\n이 같은 불일치로 인해 전반적인 연산에 곱셈 명령이 \n예상한 대로 단 한 개만 사용되는 것이 아니라 두 개가 사용됩니다. 불일치를 제거하려면, \n기울기 조정 인자가 입력 기울기 조정 인자들의 곱이 되도록 \n출력 스케일링을 변경하십시오.</entry>
    <entry key="FxpSumCheckBiasNote">정확도와 효율성 향상을 위해 \n모든 0이 아닌 편향 항이 단일 순 편향 수정 항으로 취합됩니다. 아래에 제공된 \n입력 범위와 출력 범위에는 편향이 제외됩니다. </entry>
    <entry key="FxpSumCheckMinMax">Sum 블록 {0}에 범위 오류가 있을 수 있습니다. 입력 중 하나의 범위가\n{1}~{2}인데\n 이 범위는 출력 범위\n{3}~{4}을(를) 초과합니다. 오버플로 또는 포화의 가능성을 줄이려면 모든 입력의 범위보다 크거나 같도록 출력과 누산기의 데이터형을 변경하십시오. </entry>
    <entry key="FxpSumCheckMismatchSlope">다음 Sum 블록에 있는 입력의 기울기 조정 인자가 \n출력의 기울기 조정 인자와 같지 않습니다. \n입력의 기울기 조정 인자는 {0}입니다. \n출력의 기울기 조정 인자는 {1}입니다. \n순 기울기 조정 인자는 {2}입니다. \n이 같은 불일치로 인해 Sum 블록에 하나 이상의 곱셈 연산을 사용해야 합니다. 불일치를 제거하려면 입력, 출력, 누산기가 모두 동일한 기울기 조정 인자를 갖도록 데이터형을 변경하십시오.</entry>
    <entry key="FxpSumCheckMismatchBias">다음 Sum 블록에서 입력 편향의 순 합계가 \n출력 편향과 같지 않습니다. 순 편향 조정을 \n정확하게 처리하기 위해 구현에 덧셈 또는 뺄셈 명령이 한 개 더 \n추가됩니다. 순 편향 조정을 0으로 만들어 추가 연산이 필요하지 않도록 \n출력 스케일링의 편향을 변경할 수 \n있습니다.</entry>
    <entry key="FxpRelopCheckDataTypeNotSame">다음 Relational Operator 블록에서 첫 번째와 두 번째 입력의 \n데이터형이 동일하지 않습니다. 블록이 실행될 때마다\n변환 연산이 필요합니다. 입력 중 하나가 \n불변(샘플 시간 색 자홍색)인 경우 다른 입력과 일치하도록 \n데이터형을 변경하고 불변 입력을 스케일링하는 것으로 \n모델 효율성이 개선될 수 있습니다.</entry>
    <entry key="FxpRelopCheckSingleInputFixptBool">연산자가 {1}이고 입력 데이터형이 {2}이기 때문에 다음 Relational Operator 블록의 출력은 항상 {0}입니다. 이로 인해 데드 코드(이후에 제거됨)가 발생할 수 있습니다.</entry>
    <entry key="FxpRelopCheckU1Max">다음 Relational Operator 블록에서 첫 번째 입력의 양수 범위가 \n더 큽니다. 관계 연산 수행 전에 \n두 번째 입력이 첫 번째 입력의 데이터형과 스케일링으로 \n변환됩니다. \n첫 번째 입력의 범위는 {0}~{1}이지만 \n두 번째 입력의 범위는 {2}~{3}이기 때문에, \n형변환 시 범위 오류가 발생할 수 있습니다. \nData Type Conversion 블록을 \nRelational Operator 블록 앞에 삽입하여,\n각 입력을 정확하게 나타내는 데 \n충분한 범위와 정밀도를 갖는 공통 데이터형으로 \n두 입력을 변환할 수 있습니다. 그러면 관계 \n연산 시 오류가 발생하지 않습니다.</entry>
    <entry key="FxpRelopCheckU1Slope">다음 Relational Operator 블록에서 첫 번째 입력의 양수 범위가 \n더 큽니다. 관계 연산 수행 전에 \n두 번째 입력이 첫 번째 입력의 데이터형과 스케일링으로 \n변환됩니다. \n첫 번째 입력의 정밀도는 {0}입니다. \n두 번째 입력의 정밀도는 {1}입니다. \n 따라서 변환을 수행할 때마다 정밀도 손실이 발생할 수 있습니다. \nData Type Conversion 블록을 \nRelational Operator 블록 앞에 삽입하여,\n각 입력을 정확하게 나타내는 데 \n충분한 범위와 정밀도를 갖는 공통 데이터형으로 \n두 입력을 변환할 수 있습니다. 그러면 관계 \n연산 시 오류가 발생하지 않습니다.</entry>
    <entry key="FxpRelopCheckU2Max">다음 Relational Operator 블록에서 두 번째 입력의 양수 범위가 \n더 큽니다. 관계 연산 수행 전에 \n첫 번째 입력이 두 번째 입력의 데이터형과 스케일링으로 \n변환됩니다. \n첫 번째 입력의 범위는 {0}~{1}이지만 \n두 번째 입력의 범위는 {2}~{3}이기 때문에, \n형변환 시 범위 오류가 발생할 수 있습니다. \nData Type Conversion 블록을 \nRelational Operator 블록 앞에 삽입하여,\n각 입력을 정확하게 나타내는 데 \n충분한 범위와 정밀도를 갖는 공통 데이터형으로 \n두 입력을 변환할 수 있습니다. 그러면 관계 \n연산 시 오류가 발생하지 않습니다.</entry>
    <entry key="FxpRelopCheckU2Slope">다음 Relational Operator 블록에서 두 번째 입력의 양수 범위가 \n더 큽니다. 관계 연산 수행 전에 \n첫 번째 입력이 두 번째 입력의 데이터형과 스케일링으로 \n변환됩니다. \n첫 번째 입력의 정밀도는 {0}입니다. \n두 번째 입력의 정밀도는 {1}입니다. \n 따라서 변환을 수행할 때마다 정밀도 손실이 발생할 수 있습니다. \nData Type Conversion 블록을 \nRelational Operator 블록 앞에 삽입하여,\n각 입력을 정확하게 나타내는 데 \n충분한 범위와 정밀도를 갖는 공통 데이터형으로 \n두 입력을 변환할 수 있습니다. 그러면 관계 \n연산 시 오류가 발생하지 않습니다.</entry>
    <entry key="FxpRelopCheckMismatchSlope">다음 Relational Operator 블록에서 첫 번째 입력과 두 번째 입력의 기울기 조정 인자가 서로 다릅니다. \n첫 번째 입력의 기울기 조정 인자는 {0}입니다. \n두 번째 입력의 기울기 조정 인자는 {1}입니다. \n순 기울기 조정 인자는 {2}입니다. \n이 같은 불일치로 인해, 양수 범위가 더 작은 입력을 \n양수 범위가 더 큰 입력의 데이터형과 스케일링으로 변환할 때마다 \nRelational Operator 블록에 곱셈 연산이 필요합니다. \n불일치를 제거하려면 어느 한쪽 입력의 스케일링을 변경하십시오.</entry>
    <entry key="FxpMinmaxCheckNotSame">다음 MinMax 블록에서 출력과 입력의 데이터형이 \n동일하지 않습니다. 블록이 실행될 때마다\n변환 연산이 필요합니다. 데이터형이 동일하도록 \n변경하면 모델 효율성이 개선됩니다.</entry>
    <entry key="FxpMinmaxCheckMinMax">다음 MinMax 블록의 경우, 관계 연산 수행 전에 \n입력이 출력의 데이터형과 스케일링으로 \n변환됩니다. \n입력의 범위는 {0}~{1}이지만\n출력의 범위는 {2}~{3}이기 때문에,\n형변환 시 범위 오류가 발생할 수 있습니다. \n각 입력을 정확하게 나타내는 데 충분한 범위와 정밀도를 갖도록 \n출력 데이터형을 변경하면 \n연산에 오류가 발생하지 않습니다.</entry>
    <entry key="FxpMinmaxCheckSlope">다음 MinMax 블록의 경우, 관계 연산 수행 전에 \n입력이 출력의 데이터형과 스케일링으로 \n변환됩니다. \n입력의 정밀도는 {0}입니다.\n출력의 정밀도는 {1}입니다. \n따라서 변환을 수행할 때마다 정밀도 손실이 발생할 수 있습니다. \n각 입력을 정확하게 나타내는 데 충분한 범위와 정밀도를 갖도록 \n출력 데이터형을 변경하면 \n연산에 오류가 발생하지 않습니다.</entry>
    <entry key="FxpMinmaxCheckFracSlope">다음 MinMax 블록에 있는 입력의 기울기 조정 인자가 출력의 \n기울기 조정 인자와 같지 않습니다. \n입력의 기울기 조정 인자는 {0}입니다. \n출력의 기울기 조정 인자는 {1}입니다. \n순 기울기 조정 인자는 {2}입니다. \n이 같은 불일치로 인해 입력을 출력의 데이터형과 스케일링으로 변환할 때마다 \nMinMax 블록에 곱셈 연산이 필요합니다. \n이 불일치를 제거하려면 입력과 출력 중 어느 한쪽의 스케일링을 변경하십시오.</entry>
    <entry key="FxpManyMulDivSameBlock">다음 Product 블록은 곱셈 또는 나눗셈 연산을 두 번 이상 \n수행하도록 구성되었습니다. 이 구성은 지원됩니다. 하지만 출력 데이터형이 \n정수이거나 고정소수점인 경우, 이 연산을 여러 개의 블록으로 분할하고 \n각 블록에서 곱셈이나 나눗셈을 한 번씩 수행하도록 하면 더 나은 결과를 \n얻을 수 있습니다. 여러 개의 블록을 사용하면 중간 계산에 사용되는 \n데이터형과 스케일링을 제어할 수 있습니다. 중간 계산에 사용하기 위해 \n선택한 데이터형은 정밀도와 범위 오류, 효율성에 영향을 줍니다.</entry>
    <entry key="FxpManyDivSameBlock">다음 Product 블록은 나눗셈 연산을 두 번 이상 수행하도록 \n구성되었습니다. 수치 해석 분야에서 일반적인 지침은 \n먼저 모든 분모 항을 서로 곱한 다음 \n나눗셈을 한 번만 수행하는 것입니다. 이렇게 하면 \n정확도가 개선되고 부동소수점 계산과 \n특히 고정소수점 계산의 속도가 종종 빨라집니다. 이렇게 하려면 \nSimulink에서 Product 블록을 종속 연결하면 됩니다.</entry>
    <entry key="FxpEmbedDivRoundUndef">정수 나눗셈 생성 코드가 더 효율적일 수 있습니다. 부호 있는 정수 나눗셈의 반올림 동작이 C 언어 표준으로 완전히 명시되어 있지 않습니다. 이와 같이 명세가 불완전한 상황에서는 시뮬레이션과 코드 생성 간의 비트트루(bit-true) 일치를 보장하기 위해 나눗셈에 대해 생성된 코드의 크기가 클 수 있습니다. 모델의 프로덕션 하드웨어 속성을 사용하면 구현에 특수한 부호 있는 정수 반올림 동작을 지정할 수 있습니다. 현재 반올림 동작은 ''정의되지 않음''으로 설정되어 있습니다. 이 프로덕션 하드웨어 정보를 확인 및 설정하여, 나눗셈에 대해 생성된 코드의 크기를 줄일 수 있습니다. 부호 있는 정수 나눗셈을 0 방향으로 반올림하는 것이 가장 흔히 사용되는 동작입니다.&lt;p&gt;&lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'', ''{0}'', ''ProdIntDivRoundTo'');"&gt;프로덕션 하드웨어 속성&lt;/a&gt;&lt;/p&gt;</entry>
    <entry key="FxpCheckDivZeroProtect">정수 나눗셈 생성 코드에는 0으로 나누기, INT_MIN/-1, LONG_MIN/-1 같은 산술 예외를 방지하는 기능이 들어 있습니다. 하드웨어에 따라 산술 예외가 과도한 동작을 야기할 수 있기 때문에 이러한 예외를 방지하는 것이 중요합니다. 어떤 설계자는 예외를 유발하는 입력 조합이 나눗셈 연산까지 도달하지 않도록 모델을 아주 신중하게 구성합니다. 이러한 모델에서는 나눗셈 연산의 일부로 생성된 방지 코드가 불필요합니다. 중복되는 방지 코드는 [구성 파라미터] 대화 상자에서 고정소수점에 대한 나눗셈 설정을 사용하여 제거할 수 있습니다. 이 작업은 모델에서는 나눗셈 연산에 예외가 발생하지 않는다는 점을 꼼꼼히 확인한 경우에만 수행해야 합니다. &lt;p&gt;&lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'', ''{0}'', ''NoFixptDivByZeroProtection'');"&gt;나눗셈 산술 예외를 방지하는 코드 제거&lt;/a&gt;&lt;/p&gt;</entry>
    <entry key="FxpEmbeddedHardwareNotMicro">모델의 프로덕션 하드웨어 장치의 설정 때문에, 효율적인 C 코드 생성과 관련된 일부 모델 어드바이저 검사를 건너뛰게 됩니다. ASIC 또는 FPGA 타깃 같은 일부 프로덕션 하드웨어 장치는 프로덕션 C 코드와 관련이 없습니다. 모델의 프로덕션 하드웨어 속성은 [구성 파라미터] 대화 상자의 [하드웨어 구현] 창 상단에서 지정됩니다. C 코드 생성과 관련된 검사를 활성화하려면, char 데이터형 비트 수 같은 타깃 C 컴파일러 속성이 표시되도록 프로덕션 하드웨어 장치를 변경하십시오.&lt;p&gt;&lt;a href="matlab:modeladvisorprivate(''openCSAndHighlight'', ''{0}'', ''ProdHWDeviceType'');"&gt;프로덕션 하드웨어 속성&lt;/a&gt;&lt;/p&gt;</entry>
    <entry key="FxpCheckCmpToZero">다음 Compare to Zero 블록에 파라미터 오버플로가 발생했습니다. 이 블록은 0을 표현할 때 입력 데이터형을 사용합니다. 입력 데이터형 {0}은(는) 0을 정확히 표현할 수 없습니다. 그 결과 값이 표현 가능한 가장 가까운 값으로 포화되었습니다. \n이 문제를 해결하려면 0을 표현할 수 있는 입력 데이터형을 선택하십시오. </entry>
    <entry key="FxpCheckCmpToConst">다음 Compare to Constant 블록에 파라미터 오버플로가 발생했습니다. 이 블록은 상수 값 파라미터를 표현할 때 입력 데이터형을 사용합니다. 상수 값 파라미터 {0}은(는) 입력 데이터형 {1}이(가) 표현할 수 있는 범위를 벗어나 있습니다. 그 결과 지정된 값이 표현 가능한 가장 가까운 값으로 포화되었습니다. \n이 문제를 해결하려면, 상수 값 파라미터를 표현할 수 있는 입력 데이터형을 선택하거나 입력 데이터형과 일치하도록 상수 값 파라미터를 변경하십시오.</entry>
    <entry key="FxpCheckCmpToConstAlwaysTrue"> 이 블록은 상수 값 파라미터 {1}을(를) 표현할 때 입력 데이터형 {0}을(를) 사용합니다. 지정된 관계 연산자에서 블록의 출력은 항상 true입니다. \n 이 문제를 해결하려면 (1) 이 블록을 출력 true를 갖는 Constant 블록으로 대체해 보십시오. 또는 (2) {2} 이상의 값을 표현할 수 있도록 입력 데이터형을 변경해 보십시오.</entry>
    <entry key="FxpCheckCmpToConstAlwaysFalse"> 이 블록은 상수 값 파라미터 {1}을(를) 표현할 때 입력 데이터형 {0}을(를) 사용합니다. 지정된 관계 연산자에서 블록의 출력은 항상 false입니다. \n 이 문제를 해결하려면 (1) 이 블록을 출력 false를 갖는 Constant 블록으로 대체해 보십시오. 또는 (2) {2} 이상의 값을 표현할 수 있도록 입력 데이터형을 변경해 보십시오.</entry>
    <entry key="MADisableSignalLoggingT">신호 기록 사용 안 함</entry>
    <entry key="MADisableSignalLoggingTTip">불필요한 신호 기록을 사용하지 않습니다.</entry>
    <entry key="MAActionDisableSignalLogging">기록된 모든 신호에 대해 신호 기록을 비활성화합니다.</entry>
    <entry key="MADisableSignalLoggingFail">다음 표에는 기록을 사용하는 신호가 나열되어 있습니다.</entry>
    <entry key="MADisabledSignalLoggingFor">{0} 신호에 대한 기록을 사용하지 않습니다. </entry>
    <entry key="MANoPortFound">신호 선을 찾을 수 없습니다.</entry>
    <entry key="MAErrAnalyzingLoggingFail">신호 기록 분석에 실패했습니다.</entry>
    <entry key="MASignalAnalysisResult">신호 분석 결과</entry>
    <entry key="MASignalCategory">신호 범주</entry>
    <entry key="MASignalCount">고유 신호 개수</entry>
    <entry key="MASignalCurrentlyLogEnabled">기록됨</entry>
    <entry key="MASignalCurrentlyLogDisabled">기록되지 않음</entry>
    <entry key="MAAll">모두</entry>
    <entry key="MAErrUpdateModelFailTit">모델 업데이트에 실패함</entry>
    <entry key="MAErrUpdateModelFailMsg">모델 업데이트에 실패했습니다. {0} {1}</entry>
    <entry key="MAPassed">통과</entry>
    <entry key="MAFailed">실패</entry>
    <entry key="MAModifyAll">모두 수정</entry>
    <entry key="MATitleDetectReusableSubsystemNotReused">재사용 가능으로 설정되었지만 한 번만 사용된 Subsystem 블록 감지</entry>
    <entry key="MADetectReusableSubsystemNotReusedWarningMsg">다음 subsystem 블록은 &lt;b&gt;함수 패키징&lt;/b&gt; 옵션을 &lt;code&gt;재사용 가능 함수&lt;/code&gt;로 설정합니다. 하지만 블록이 한 번만 사용됩니다. 이로 인해 생성된 코드에서 블록이 비효율적으로 구현될 수 있습니다. 다음 블록에 대해 &lt;b&gt;함수 패키징&lt;/b&gt;을 &lt;code&gt;자동&lt;/code&gt;으로 설정하십시오.</entry>
    <entry key="MADescrDetectReusableSubsystemNotReused">&lt;b&gt;함수 패키징&lt;/b&gt;이 &lt;tt&gt;재사용 가능 함수&lt;/tt&gt;로 지정되었지만 한 번만 사용된 서브시스템을 감지합니다.</entry>
    <entry key="MADetectReusableSubsystemNotReusedRecAction">위 블록에 대해 &lt;b&gt;함수 패키징&lt;/b&gt;을 &lt;code&gt;자동&lt;/code&gt;으로 설정하십시오.</entry>
    <entry key="MATitleCheckEnableMemcpy">효율성 최적화 파라미터가 있는지 검사</entry>
    <entry key="MATitletipCheckEnableMemcpy">&lt;b&gt;실행 효율성&lt;/b&gt; 또는 &lt;b&gt;ROM 효율성&lt;/b&gt; 목표에 종속된 최적화 파라미터를 식별합니다.</entry>
    <entry key="MACheckEnableMemcpyResultNA">모델에서 &lt;b&gt;ROM 효율성&lt;/b&gt; 또는 &lt;b&gt;실행 효율성&lt;/b&gt; 목표를 사용하고 있지 않습니다.</entry>
    <entry key="MACheckEnableMemcpyResultWarning">모델에서 &lt;b&gt;{0}&lt;/b&gt; 목표를 사용하는 중입니다. &lt;b&gt;벡터 할당에 memcpy 사용&lt;/b&gt;의 선택이 해제되었습니다.</entry>
    <entry key="MACheckEnableMemcpyResultPassed">&lt;ul&gt;&lt;li&gt;모델에서 다음 목표를 사용하는 중입니다. &lt;b&gt;{0}&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;벡터 할당에 memcpy 사용&lt;/b&gt;이 선택되었습니다.&lt;/li&gt;&lt;/ul&gt;</entry>
    <entry key="MATitletipDetectReusableSubsystemNotReused">재사용 가능으로 설정되었지만 한 번만 재사용된 Subsystem 블록 감지</entry>
    <entry key="slprof_hilite_usage">Usage: slprofile_hilite_system([''encoded-path'',] ''block-name'')</entry>
    <entry key="slprof_unhilite_usage">Usage: slprofile_unhilite_system(system_name)</entry>
    <entry key="badEncPath">Unexpected encoded path</entry>
    <entry key="openReportFileWritable">Error opening report file for writing</entry>
    <entry key="slprofNotMATLABWebBrowser">MATLAB 웹 브라우저에서 프로파일 리포트를 열 수 없습니다. MATLAB 웹 브라우저에서는 Simulink 모델에 대한 하이퍼링크만 작동합니다.</entry>
    <entry key="slprofBrowserNotFound">Report saved, but could not find web browser</entry>
    <entry key="slprofBrowserNotLaunched">Report saved, but could not launch web browser</entry>
    <entry key="assertExtModeCallback">Assertion: Unrecognized action in main entry point.</entry>
    <entry key="errExtModeConfigDialog">외부 모드 구성 대화 상자에 오류가 발생함</entry>
    <entry key="extModeOpenInvCommand">M Assert: Invalid Command.</entry>
    <entry key="extModeOpenGenericError">''{0}'' 명령을 실행하는 중에 다음 오류가 발생했습니다.\n\n{1}</entry>
    <entry key="extModeOpenUnknownUpInfoIdx">M Assert: Unknown upInfo index.</entry>
    <entry key="extModeOpenUnhandledDataType">Datatype not handled:\n{0}</entry>
    <entry key="extModeOpenSLRTAppNotLoaded">The ''{0}'' application is not loaded on the target.</entry>
    <entry key="extModeOpenSLRTTrigSigNotFound">Selected trigger signal does not exist for Scope: {0}.</entry>
    <entry key="extModeOpenSLRTInvalidUpInfoType">Invalid value for UpInfoType.</entry>
    <entry key="extModeOpenSLRTScopesOutOfScope">Scopes have been deleted. Could no longer continue simulation.</entry>
    <entry key="extModeOpenSLRTScopeWillNotUpload">스코프 ''{0}''은(는) 신호를 업로드하지 않습니다.</entry>
    <entry key="extModeOpenSLRTTargetPCNotDefined">연결 프로세스에 실패했습니다. 타깃 PC ''{0}''이(가) 정의되지 않았습니다.</entry>
    <entry key="extModeOpenSLRTAddSignalCopyBlock">''{0}''의 입력 신호를 업로드할 수 없습니다. SignalCopy 블록을 ''{1}''의 입력 포트에 추가해 보십시오.</entry>
    <entry key="extModeOpenSLRTTgtConnNoStreamingMulticore">''{0}'' 애플리케이션은 신호 데이터를 SDI와 Simulink 대시보드로 스트리밍할 수 없습니다. 멀티코어에 대한 타깃을 구성해야 합니다.</entry>
    <entry key="extModeOpenSLRTTgtConnNoStreamingConnect">''{0}'' 애플리케이션은 신호 데이터를 SDI와 Simulink 대시보드로 스트리밍할 수 없습니다. 타깃 연결에 실패했습니다.</entry>
    <entry key="extModeOpenSLRTTgtConnNoStreamingSDI">''{0}'' 애플리케이션은 신호 데이터를 SDI와 Simulink 대시보드로 스트리밍할 수 없습니다. SDI 시작에 실패했습니다.</entry>
    <entry key="extModeOpenSLRTUnobservableSignal">신호 ''{0}''을(를) ''{1}''에서 관측할 수 없습니다.</entry>
    <entry key="SLFeatureNotEnoughArgs">입력 인수가 부족합니다.</entry>
    <entry key="SLFeatureInvalidCall">slfeature 호출이 유효하지 않습니다.</entry>
    <entry key="AddExecEventListenerInvalidInputArgs">3개의 입력 인수가 필요합니다.</entry>
    <entry key="AddExecEventListenerRequireOneOutputArg">''add_exec_event_listener''의 출력값은 리스너가 활성 상태인 동안 계속해서 유지되는 변수에 할당되어야 합니다.</entry>
    <entry key="AddExecEventListenerOnlyToNonVirtualBlocks">''{0}''의 블록 메서드 실행 이벤트에 대해서는 리스너를 추가할 수 없습니다. 리스너는 비가상 블록에만 추가할 수 있습니다.</entry>
    <entry key="AddExecEventListenerOnlyDuringExecuting">''{0}''의 블록 메서드 실행 이벤트에 대해서는 리스너를 추가할 수 없습니다. 리스너는 블록 다이어그램이 실행 중일 때만 추가할 수 있습니다.</entry>
    <entry key="SFunctionWizardJaveNotEnabled">Java is not currently fully enabled on this platform. Please see Writing S-functions manual for information on how to write S-functions.</entry>
    <entry key="SfunBuilderBusNotFound">Bus not found in workspace</entry>
    <entry key="hmiSLTgtEmptyTagInputArg">태그 입력 인수는 비어 있을 수 없습니다.</entry>
    <entry key="hmiSLTgtIncorrectlyFormedTag">태그의 형식이 잘못되었습니다.</entry>
    <entry key="encPathArgsMustBeStrings">All input arguments must be character vectors.</entry>
    <entry key="decPathFirstArgError">First argument is the encoded path which must be a character vector.</entry>
    <entry key="decPathSecondArgError">Second argument is to combine the model name with the rest of the path and must be true or false.</entry>
    <entry key="enc2normalpathFirstArgError">First argument is the encoded path which must be a character vector.</entry>
    <entry key="ConflictConfigSetRefStateflowTargets">In model ''{0}'' Stateflow sfun target settings conflict with configuration reference. A new configuration set has been created and set as the active configuration set of the model. The new configuration set consists of values from the variable ''{1}'' while the Simulation Target parameters come from Stateflow sfun target settings. The configuration reference has been temporarily marked as inactive. Please use ''updatecsref'' to resolve the conflict and restore the configuration reference to its original active state. Please type ''help updatecsref'' for more information.</entry>
    <entry key="PotentialConflictConfigSetRefStateflowTargets">Cannot store Stateflow sfun target settings into ''{0}'' when loading model ''{1}''. Please load configuration set object ''{2}'' in the base workspace before you load the model.</entry>
    <entry key="UpdatecsrefProgressMessage1">\n단계 1/2: 모델 파일 분석\n----------------------------------</entry>
    <entry key="UpdatecsrefProgressMessage2">\n단계 2/2: Stateflow sfun 타깃 설정 비교 및 모델과 구성 세트 업데이트\n---------------------------------------------------------------------------------------------</entry>
    <entry key="UpdatecsrefConfigSetRefNotFound">업데이트할 구성 참조가 없습니다.</entry>
    <entry key="UpdatecsrefExitUpdatecsref">\nupdatecsref가 종료됩니다.</entry>
    <entry key="UpdatecsrefModelUpdated">\n다음 모델 파일이 업데이트되었습니다.</entry>
    <entry key="UpdatecsrefWSVarUpdated">\n다음 기본 작업 공간 객체가 업데이트되었습니다.</entry>
    <entry key="UpdatecsrefUpdateMATFile">MAT 파일을 업데이트하려면 기본 작업 공간에 현재 값을 사용하십시오.</entry>
    <entry key="UpdatecsrefAppendDescription">''{0}''의 ''설명''에 다음이 추가됩니다.</entry>
    <entry key="UpdatecsrefIgnoreWSVar">객체 ''{0}''은(는) 업데이트할 필요가 없습니다.</entry>
    <entry key="UpdatecsrefChangeWSVar">계속 진행하여 객체 ''{0}''을(를) 변경하시겠습니까? (Y/n)</entry>
    <entry key="UpdatecsrefSetActiveConfigSet">''{0}''을(를) 모델 ''{1}''의 활성 구성 세트로 설정하시겠습니까? (Y/n)</entry>
    <entry key="UpdatecsrefOnlyConfigSetRef">활성 구성 세트로 사용됩니다. 계속하시겠습니까? (Y/n)</entry>
    <entry key="UpdatecsrefOnlyConfigSetRefisActive">    활성 구성 세트로 사용됩니다.</entry>
    <entry key="UpdatecsrefChooseConfigSetRef">유효한 구성 참조를 활성 구성 세트로 선택하십시오(디폴트 값은 [1]임).</entry>
    <entry key="UpdatecsrefWSVarUpdatedSuccessfully">객체 ''{0}''이(가) 성공적으로 업데이트되었습니다.</entry>
    <entry key="UpdatecsrefModelUpdatedSuccessfully">모델 ''{0}''이(가) 성공적으로 업데이트되었습니다.</entry>
    <entry key="UpdatecsrefUpdateParameter">''{1}''의 파라미터 ''{0}''이(가) ''{2}''에서 ''{3}''(으)로 변경됨</entry>
    <entry key="UpdatecsrefWSVarUsedBy">''{0}'' 사용:</entry>
    <entry key="UpdatecsrefConfigSetRefinMdl">모델 ''{1}''의 구성 참조 ''{0}''</entry>
    <entry key="UpdatecsrefDifferentParameterValue">''{0}'' 및 ''{1}''의 파라미터 ''{2}'' 값이 서로 다릅니다.</entry>
    <entry key="UpdatecsrefUpdatedAlready">모델 ''{0}''이(가) 이미 업데이트되었습니다.</entry>
    <entry key="UpdatecsrefNoConfigSetRef">모델 ''{0}''이(가) 무시되었습니다. 이 모델은 구성 참조를 사용하지 않습니다.</entry>
    <entry key="UpdatecsrefInvalidConfigSetRef">모델 ''{0}''에서 다음의 유효하지 않은 구성 참조가 발견됨</entry>
    <entry key="UpdatecsrefNeedValidConfigSetRef">updatecsref를 실행하기 전에 모델 ''{0}''에 유효한 구성 참조를 제공하십시오.</entry>
    <entry key="UpdatecsrefValidConfigSetRef">모델 ''{0}''에서 다음의 유효한 구성 참조가 발견됨</entry>
    <entry key="UpdatecsrefQuit">[{0}] 종료</entry>
    <entry key="UpdatecsrefConfigSetRefValue">[{0}] 구성 참조 ''{1}''이(가) configuration set 객체 ''{2}''을(를) 가리킴</entry>
    <entry key="UpdatecsrefConfigSetRefInfoBase">구성 참조 ''{0}''이(가) configuration set 객체 ''{1}''을(를) 가리킴</entry>
    <entry key="UpdatecsrefInvalidConfigSetRef1">그러나 ''{0}''이(가) 존재하지 않음 </entry>
    <entry key="UpdatecsrefInvalidConfigSetRef2">그러나 ''{0}''이(가) configuration set 객체가 아님</entry>
    <entry key="UpdatecsrefIntroduction">updatecsref는 구성 참조 업데이트를 위한 스크립트입니다. R2008b에는\nStateflow sfun 타깃 설정이 Stateflow 시뮬레이션 타깃 대화 상자에서\n구성 세트의 파라미터(시뮬레이션 타깃)로 옮겨졌습니다. 구성 참조를 통해\n동일한 configuration set 객체를 공유하는 모델이 있는 경우,\nupdatecsref는 이러한 모델이 동일한 Stateflow sfun 타깃 설정을 갖는지와\n그러한 설정을 공유된 configuration set 객체로 옮기는지 확인합니다.\n</entry>
    <entry key="UpdatecsrefNeedModelFiles">구성 참조를 사용하는 모델 파일의 목록을 제공하십시오.\n</entry>
    <entry key="UpdatecsrefNeedCloseModelFiles">다음 모델을 닫으십시오.</entry>
    <entry key="UpdatecsrefRequirements1">updatecsref를 실행하기 전에 다음을 수행하십시오.\n1. 구성 참조를 사용하는 모델 파일의 목록을 찾습니다. \n 구성 참조를 사용하지 않는 모델이 있는 경우 그러한 모델은 무시됩니다. \n 이 목록에 없는 모델에서 구성 참조를 사용하고 Stateflow sfun 타깃 설정이\n 공유된 configuration set 객체에 저장된 설정과 동일하지 않다면 모델을\n 불러올 때 경고가 발생합니다.\n</entry>
    <entry key="UpdatecsrefRequirements2">2. updatecsref를 사용하지 않고 일부 모델을 이미 업데이트한 경우, 원하는\n Stateflow sfun 타깃 설정이 활성 구성 세트의 시뮬레이션 타깃 파라미터에\n 있는지 확인합니다.</entry>
    <entry key="UpdatecsrefRequirements3">3. 목록의 모든 모델 파일을 백업합니다. 기본 작업 공간에서 공유되는\n configuration set 객체를 생성하는 모든 MAT 파일이나 MATLAB 파일을 백업합니다.</entry>
    <entry key="UpdatecsrefRequirements4">4. 열려 있는 모델 파일을 모두 닫습니다.</entry>
    <entry key="UpdatecsrefRequirements5">5. 공유된 configuration set 객체를 기본 작업 공간에 불러옵니다. 데이터\n 사전의 객체는 생략할 수 있습니다. 모델과 함께 자동으로 불러오는 객체도\n 생략할 수 있습니다. 하지만 모델 파일 목록 맨 앞에 관련 모델 이름을 넣으십시오.\n</entry>
    <entry key="UpdatecsrefRequirements6">6. 모델 파일 이름 목록을 updatecsref에 제공합니다.\n 예: updatecsref(''mdlfilename1'',''mdlfilename2'',...)</entry>
    <entry key="UpdatecsrefRequirements7">7. 작업 공간에서 공유된 configuration set 객체를 다시 구성 참조 파일에\n 저장합니다.\n</entry>
    <entry key="UpdatecsrefUnknownFileName">파일 ''{0}''이(가) 존재하지 않습니다.</entry>
    <entry key="UpdatecsrefLoadingModel">\n''{0}'' 분석 중</entry>
    <entry key="UpdatecsrefUpdatingModel">\n''{0}'' 업데이트 중</entry>
    <entry key="UpdatecsrefNoStateflow">모델 ''{0}''이(가) 무시되었습니다. 이 모델은 Stateflow 차트를 가지고 있지 않습니다.</entry>
    <entry key="UpdatecsrefResolveDiffParam">\n모델을 업데이트한 다음 모델마다 위의 각 파라미터의 값이 동일하도록 지정하십시오.</entry>
    <entry key="lbCannotRemoveLockFile">내부 오류: 자물쇠 파일 {0}을(를) 제거할 수 없음</entry>
    <entry key="SimulationOutputWhoEmpty">이 Simulink.SimulationOutput 객체에는 편집 가능한 속성이 없음</entry>
    <entry key="SimulationOutputWhoHeading">이 Simulink.SimulationOutput 객체에 포함된 편집 가능한 속성:</entry>
    <entry key="SimulationOutputDispGetNoLinks">이름을 기준으로 변수에 액세스하려면 ''get''을 사용하십시오.</entry>
    <entry key="SimulationOutputDispGet">이름을 기준으로 변수에 액세스하려면 &lt;a href="matlab: help {0}/get"&gt;get&lt;/a&gt;을 사용하십시오.</entry>
    <entry key="SimulationOutputArrDispHeading"> Simulink.SimulationOutput 배열</entry>
    <entry key="SimulationOutputDispMetadata">시뮬레이션에 대한 메타데이터에 액세스하려면 &lt;a href="matlab: help {0}/getSimulationMetadata"&gt;getSimulationMetadata&lt;/a&gt;를 사용하십시오.</entry>
    <entry key="SimulationOutputDispMetadataNoLinks">시뮬레이션에 대한 메타데이터에 액세스하려면 ''getSimulationMetadata''를 사용하십시오.</entry>
    <entry key="SimulationOutputDispEmpty">    비어 있음</entry>
    <entry key="SimulationMetadataCreationError"> 다음 이유로 Simulink.SimulationMetadata를 생성할 수 없음: </entry>
    <entry key="SimulationMetadataUserStringDatatypeMismatch">UserString needs to be of type char</entry>
    <entry key="RegRuleInvalidSignature">Invalid signature. The input argument ''{0}'' expects a cell array of character vectors.</entry>
    <entry key="RegRuleInvalidRuleSet">Invalid inheritance rules.</entry>
    <entry key="RegRuleInvalidChar">Rule ''{0}'' contains one of the following illegal characters '{' ''|'', '''{''', '''}''' '','' '}'.</entry>
    <entry key="RegRuleInvalidPrefix">Rule ''{0}'' does not start with ''Inherit: ''.</entry>
    <entry key="cpreprocessorUnsupportedPlatform">현재 플랫폼은 아직 cpreprocessor에서 지원되지 않음</entry>
    <entry key="cpreprocessorcppfailure">입력 파일을 전처리하지 못했습니다.\n cpreprocessor의 출력은 {0}입니다.</entry>
    <entry key="cpreprocessorcppoutput">C 전처리기의 메시지:\n{0}</entry>
    <entry key="cpreprocessorFileNotFound">파일 {0}을(를) 찾을 수 없습니다.</entry>
    <entry key="lci_accesslegacywsInternalError">내부 오류입니다. {0}을(를) 찾을 수 없습니다.</entry>
    <entry key="BaseWSVarInconsistentValueWithLegacyCode">변수 ''{0}''의 값이 레거시 코드의 값과 다름</entry>
    <entry key="DirectoryCreationFailure">''{0}'' 아래에 작업 디렉터리를 만들 수 없음</entry>
    <entry key="FileCreationFailure">''{1}''에 파일 ''{0}''을(를) 만들 수 없음</entry>
    <entry key="InconsistentTargetWordSpec">C 데이터형의 타깃 워드 길이가 일치하지 않음</entry>
    <entry key="InconsistentTargetWordLength">C의 ''{0}''형은 시뮬레이션에서는 {1,number,integer}비트로, 타깃 하드웨어에서는 {2,number,integer}비트로 표현됩니다.</entry>
    <entry key="LegacySymbolisReserved">Simulink에서 레거시 기호 ''{0}''이(가) ''{1}''의 디폴트 정의에 의해 가려져 있음</entry>
    <entry key="CTypeNotSupported">Simulink에서는 레거시 기호 ''{0}''의 C 유형이 지원되지 않음</entry>
    <entry key="CTypeWordLengthNotSupported">Simulink에서는 레거시 기호 {1}의 워드 길이({0,number,integer}비트)를 지원하지 않음</entry>
    <entry key="LegacySymbolUnknownDimension">''{0}''의 차원을 알 수 없음</entry>
    <entry key="LegacySymbolZeroDimension">''{0}''의 차원에 요소가 없음</entry>
    <entry key="InlineParamsOff">코드 생성 중에 레거시 기호를 통합하려면 ''구성 파라미터 &gt; 코드 생성 &gt; 최적화 &gt; 디폴트 파라미터 동작''을 ''인라인''으로 설정해야 합니다.</entry>
    <entry key="LegacyDataTypeNameUsedByBaseWSVar">레거시 기호 {1}이(가) 사용하는 C 데이터형 {0}이(가) 동일한 이름을 가진 기본 작업 공간 변수에 의해 가려져 있습니다. 이 데이터형은 블록 다이어그램에서 {2}의 유형 이름으로 표시되지 못합니다.</entry>
    <entry key="CTypeNotSupportedHoweverUsedbyBaseWSVar">Simulink에서는 레거시 기호 ''{0}''의 C 유형이 지원되지 않습니다. 하지만 해당 객체 ''{1}''의 데이터형이 ''{2}''입니다.</entry>
    <entry key="CTypeWordLengthNotSupportedHoweverUsedbyBaseWSVar">Simulink에서는 레거시 기호 {1}의 워드 길이({0,number,integer}비트)를 지원하지 않습니다. 하지만 해당 객체 ''{2}''의 데이터형이 ''{3}''입니다.</entry>
    <entry key="WrongStorageClass">{0}은(는) 이미 레거시 코드에 정의되어 있습니다. 하지만 객체 {1}의 스토리지 클래스가 {2}이기 때문에 중복 정의가 생성될 수 있습니다. 스토리지 클래스를 ImportedExtern, ImportedExternPointer 또는 Custom으로 변경하십시오.</entry>
    <entry key="BaseWSVarWrongDatatype">Simulink에서 레거시 기호 {0}은(는) {1}형이어야 합니다. 하지만 해당 객체 {2}의 데이터형이 {3}입니다.</entry>
    <entry key="FailtoGetSystemHeaderPath">시스템 헤더 파일의 경로 식별에 실패함</entry>
    <entry key="ObjectiveCustomizerNotInitialized">ObjectiveCustomizer가 초기화되지 않았습니다. &lt;a href="matlab:sl_refresh_customizations"&gt;sl_refresh_customizations&lt;/a&gt; 명령을 실행하십시오.</entry>
    <entry key="ObjectiveCustomizerInitializationFailure">ObjectiveCustomizer를 초기화할 수 없습니다. Java가 비활성화되었기 때문입니다. ObjectiveCustomizer를 초기화하려면 -nojvm 시작 옵션을 사용하지 않고 MATLAB을 다시 시작하십시오.</entry>
    <entry key="badCheckIDError">''{0}'' 목표에 유효하지 않은 모델 어드바이저 검사 ID(''{1}'')가 포함되어 있습니다. 유효한 모델 어드바이저 검사 ID를 지정한 다음 sl_refresh_customizations를 실행하십시오. 파일은 {2}에 있습니다.</entry>
    <entry key="badCheckIDErrorMsgBoxTitle">오류</entry>
    <entry key="PreDefinedCheckError">''{0}''은(는) 미리 정의된 검사입니다.\n</entry>
    <entry key="ExistingAdditionalCheckError">''{0}''은(는) 기존의 추가 검사입니다.\n</entry>
    <entry key="multipleSLCustomizationFiles">목표 사용자 지정 API에는 sl_customization.m이 하나만 허용됩니다.\n</entry>
    <entry key="repeatedOrderError">''{0}'' 및 ''{1}''의 순서가 같음: {2,number,integer}\n</entry>
    <entry key="invalidCSParameterError">''{0}''은(는) 유효한 구성 파라미터가 아닙니다.\n</entry>
    <entry key="existedCSParameterError">목표 ''{1}''에 이미 ''{0}''이(가) 있습니다.\n</entry>
    <entry key="noNameSpecifiedCSParameterError">구성 파라미터에 지정된 이름이 없습니다.\n</entry>
    <entry key="noValueSpecifiedCSParameterError">구성 파라미터에 지정된 값이 없음: ''{0}'' .\n</entry>
    <entry key="existedCheckError">목표 ''{1}''에 이미 ''{0}''이(가) 있고 ''{2}''과(와) 연결되어 있습니다.\n</entry>
    <entry key="dependencyViolatedAbsentError">목표 ''{0}''에서 파라미터 ''{1}''은(는) 아직 추가되지 않은 ''{2}''에 종속됩니다. \n</entry>
    <entry key="dependencyViolatedWrongValueError">목표 ''{0}''에서 파라미터 ''{1}''은(는) 값이 올바로 설정되지 않은 ''{2}''에 종속됩니다. \n</entry>
    <entry key="noNameSpecifiedCheckError">검사에 지정된 이름이 없습니다.\n</entry>
    <entry key="invalidBaseObjective">목표 ''{0}''이(가) 존재하지 않습니다.\n</entry>
    <entry key="invalidBaseObjectiveAsCell">셀형 배열은 기본 목표로 허용되지 않습니다.\n</entry>
    <entry key="CSParameterNotExistedInBase">기본 목표에 ''{0}''이(가) 없음: ''{1}''.\n</entry>
    <entry key="checkNotExistedInBase">기본 목표에 ''{0}''이(가) 없음: ''{1}''.\n</entry>
    <entry key="noBaseError">''{0}''에 기본 목표가 없습니다.\n</entry>
    <entry key="duplicatedObjName">''{0}'' is a duplicated objective name, please choose a different one.\n</entry>
    <entry key="duplicatedObjID">''{0}'' is a duplicate objective ID. Specify a unique objective ID.\n</entry>
    <entry key="invalidObjectiveID">''{0}'' is an invalid objective ID. Valid characters are numbers, letters and ''_''.</entry>
    <entry key="invalidObjectiveName">유효하지 않은 목표 이름임: ''{0}''. \n목표 이름은 영문자 또는 ''_''로 시작해야 하고, \n영문자, 숫자, '' '' 및 ''_''만 포함해야 합니다.</entry>
    <entry key="disallowedCheck">''{0}'' is not allowed because it updates diagram not using the common Model Advisor utility.</entry>
    <entry key="noParamError">목표 ''{0}''에 정의된 파라미터가 없습니다.</entry>
    <entry key="badOutputArgumentName">''{0}''은(는) 유효하지 않은 인수 이름입니다. ''-format'', ''-comments'' 또는 ''-varname''을 지정하십시오.</entry>
    <entry key="badOutputFileName">Invalid output file name: ''{0}''. Output file names must start with a letter and can only contain letters, numbers, and ''_''.</entry>
    <entry key="badOutputFileNameDirectory">The directory(''{0}'') does not exist.</entry>
    <entry key="badOutputFileNameExtension">''{0}'' is not a valid extension, only ''.m'' is allowed.</entry>
    <entry key="badFileNameExtension">''{0}''은(는) 유효한 확장자가 아닙니다. ''.m'' 및 ''.mat''만 허용됩니다.</entry>
    <entry key="badOutputRedundantArg">{0}이(가) 두 번 이상 지정되었습니다.</entry>
    <entry key="badOutputConflict">''{0}''이(가) ''{1}''(으)로 설정되었기 때문에, ''{2}''을(를) ''{3}''(으)로 설정할 수 없습니다.</entry>
    <entry key="badOutputVariableName">''{0}''은(는) ''-varname''에 유효하지 않은 값입니다. 유효한 변수 이름을 지정하십시오.</entry>
    <entry key="badOutputFormat">''{0}''은(는) ''-format''에 유효하지 않은 값입니다. ''MATLAB 함수'' 또는 ''MATLAB 스크립트''를 지정하십시오.</entry>
    <entry key="badOutputComments">''{0}''은(는) ''-comments''에 유효하지 않은 값입니다. ''on'' 또는 ''off''를 지정하십시오.</entry>
    <entry key="badOutputUpdate">''{0}''은(는) ''-update''에 유효하지 않은 값입니다. ''true'' 또는 ''false''를 지정하십시오.</entry>
    <entry key="unwritableError">''{0}'' cannot be created successfully.</entry>
    <entry key="badVersion1">첫 번째 파라미터는 유효한 버전 번호가 아닙니다.</entry>
    <entry key="badVersion2">두 번째 파라미터는 유효한 버전 번호가 아닙니다.</entry>
    <entry key="MFileParametersWithNoUI">구성 파라미터 대화 상자에 없는 파라미터</entry>
    <entry key="MFileNotConfigSetError">입력 파라미터는 유효한 구성 세트가 아닙니다.</entry>
    <entry key="MFileUnsuccessful">오류:</entry>
    <entry key="MFileVersionViolation">타깃 구성 세트가 원래 구성 세트보다 더 이전 버전입니다.</entry>
    <entry key="MFileTimestamp">구성 세트에 대한 MATLAB 함수가 {0}에 생성됨</entry>
    <entry key="MFileVersion">MATLAB 버전: {0}</entry>
    <entry key="MFileOrder1">다음 명령의 순서를 변경하지 마십시오. 파라미터 간에 종속성이 있습니다.</entry>
    <entry key="MFileOrder2">다음 명령은 종속성이 없습니다.</entry>
    <entry key="MFileTargetSpecific">다음은 타깃별 파라미터입니다.</entry>
    <entry key="MFileOriginalConfigSetVersion">원래 구성 세트 버전</entry>
    <entry key="MFileOriginalEncoding">문자 인코딩</entry>
    <entry key="MFileBridgeComponentNotSupported">제품별 컴포넌트가 포함된 Simulink.ConfigSet 객체는 모델 탐색기의 기본 작업 공간에서 .m 파일로 내보낼 수 없습니다. Simulink.ConfigSet 객체를 .m 파일로 내보내려면 내보내기 전에 객체를 모델에 연결하거나 saveAs 함수를 사용하십시오.</entry>
    <entry key="MFileNotSupportforLib">구성 세트 saveAs 메서드는 라이브러리에 지원되지 않음</entry>
    <entry key="MFilePane">창</entry>
    <entry key="MFileGeneralPane">일반</entry>
    <entry key="NoReferencedModel">모델 ''{0}''에는 참조된 모델이 없습니다. </entry>
    <entry key="CSRefPropagationPBarTitle">참조된 모델로의 전파</entry>
    <entry key="CSRefPropagationPBarFindRMLabel">참조된 모델 찾기</entry>
    <entry key="CSRefPropagationPBarModelLabel">참조된 모델:</entry>
    <entry key="MFileDefaultToERT">''''시스템 타깃 파일''''을 ''''ert.tlc''''로 설정합니다.</entry>
    <entry key="FileAlreadyExists">타깃 문자 인코딩({0})이 원래 문자 인코딩({1})과 다릅니다.</entry>
    <entry key="CSVersionCompareWrongInput">잘못된 입력</entry>
    <entry key="CSVersionCompareSameVersion">동일한 버전</entry>
    <entry key="CSVersionCompareEarlierVersion">이전 버전</entry>
    <entry key="CSVersionCompareLaterVersion">이후 버전</entry>
    <entry key="MATitletipFcnCallUsageCheck">함수 호출 연결성에 적용되고 모델 실행에 영향을 줄 수 있는 모델 진단 설정을 확인합니다.</entry>
    <entry key="MATitleFcnCallUsageCheck">함수 호출 연결의 사용 상태 확인</entry>
    <entry key="MAFcnCallUsageCheckActionButtonName">설정 수정</entry>
    <entry key="MAFcnCallUsageCheckActionDescription">모델 구성에서 진단 설정을 수정합니다.</entry>
    <entry key="FcnCallUsageSubTitle1">''컨텍스트 종속 입력'' 설정 확인</entry>
    <entry key="FcnCallUsageInfo1">&lt;b&gt;컨텍스트 종속 입력&lt;/b&gt; 진단이 &lt;tt&gt;오류&lt;/tt&gt;로 설정되었는지 확인합니다. </entry>
    <entry key="FcnCallUsagePassMsg1">&lt;b&gt;진단 &gt; 연결성 &gt; 컨텍스트 종속 입력&lt;/b&gt;이 &lt;tt&gt;오류&lt;/tt&gt;로 설정되어 있습니다.</entry>
    <entry key="FcnCallUsageFailMsg1">&lt;b&gt;진단 &gt; 연결성 &gt; 컨텍스트 종속 입력&lt;/b&gt;이 &lt;tt&gt;{0}&lt;/tt&gt;(으)로 설정되어 있습니다. 이로 인해 비결정적 모델 실행이 발생할 수 있습니다.</entry>
    <entry key="FcnCallUsageRecAction">{0}을(를) &lt;tt&gt;오류&lt;/tt&gt;로 설정합니다.</entry>
    <entry key="FcnCallUsageHyperLink1">진단 &gt; 연결성 &gt; 컨텍스트 종속 입력</entry>
    <entry key="slVarStructAlreadyExists">변수 ''{0}''이(가) 이미 존재합니다.</entry>
    <entry key="slVarStructCreatedVariableGlobalWS">모델에 표시되는 전역 네임스페이스에서 변수 ''{0}''이(가) 생성되었습니다.</entry>
    <entry key="slVarStructNonStructArgument">Variable ''{0}'' is not a structure.</entry>
    <entry key="slVarStructDuplicatedNodes">Duplicate leaf node names in structure ''{0}'':\n{1}</entry>
    <entry key="slPVInvalidNumPVInputs">Invalid number of input arguments for Parameter - Value pairs.</entry>
    <entry key="slPVNotStringPVInputs">Parameter - Value pairs should be the character vectors.</entry>
    <entry key="slPVUnrecognizedPInputs">파라미터 ''{0}''을(를) 인식할 수 없습니다.</entry>
    <entry key="slPVUnrecognizedVInputs">Parameter ''{0}'' does not accept value ''{1}''. Expected values: {2}.</entry>
    <entry key="slPVDuplicatedPInputs">Parameter ''{0}''is duplicated.</entry>
    <entry key="indexedGroupItems_InvalidN">The number of columns ''N'' passed to ''getIndexedGroupItems'' is not valid. The number of columns must be a positive integer.</entry>
    <entry key="indexedGroupItems_InvalidStretch">You cannot specify ''stretch'' as the first entry of a row. A row must start with either a valid widget or a ''blank''.</entry>
    <entry key="indexedGroupItems_InvalidOpt">In ''getIndexedGroupItems'', Simulink requires either ''blank'' or ''stretch''.</entry>
    <entry key="Finder_NotEnoughInputs">입력 인수가 부족합니다.</entry>
    <entry key="Finder_RequiresJava">The Find dialog requires Java support.</entry>
    <entry key="Finder_SystemNotFound">시스템 ''{0}''이(가) 존재하지 않습니다.</entry>
    <entry key="Finder_FailedForSimulink">Simulink 객체를 찾는 작업에 실패했습니다.</entry>
    <entry key="Finder_FailedForStateflow">Stateflow 객체를 찾는 작업에 실패했습니다.</entry>
    <entry key="Finder_HandleNotFound">선택한 객체를 찾을 수 없습니다. 검색 실행 후에 모델을 닫거나 편집한 경우 발생할 수 있습니다. 객체를 찾으려면 검색을 다시 실행해야 합니다.</entry>
    <entry key="cannotOpenFile">저장하는 중에 오류가 발생했습니다. 파일 ''{0}''을(를) 열 수 없습니다.</entry>
    <entry key="evalFileFailed">''{0}''을(를) 평가하는 중 오류가 발생했습니다. 오류 메시지: {1}</entry>
    <entry key="ModelVarStructNoChangesApplied">No changes applied to model ''{0}''</entry>
    <entry key="ParserConfig">''Selected'' 컴파일러를 찾을 수 없습니다. mex -setup을 실행해야 할 수 있습니다.</entry>
    <entry key="DependencyViewerParseError">findDependencies: Unable to parse the ''{0}'' parameter. Please ensure it is a {1}.</entry>
    <entry key="csOpenProlog">{0}의 프롤로그</entry>
    <entry key="csOpenEpilog">{0}의 에필로그</entry>
    <entry key="csOpenTitleBar">{0} 사용자 지정 코드</entry>
    <entry key="ccOpenTopOf">{0} 위</entry>
    <entry key="ccOpenBottomOf">{0} 아래</entry>
    <entry key="ccOpenDeclarationCode">{0} 선언 코드</entry>
    <entry key="ccOpenExecutionCode">{0} 실행 코드</entry>
    <entry key="ccOpenExitCode">{0} 종료 코드</entry>
    <entry key="ccOpenCustomCode">{0} 사용자 지정 코드</entry>
    <entry key="connectionAndTriggeringMsg">연결 및 트리거</entry>
    <entry key="floatingScopeMsg">플로팅 스코프</entry>
    <entry key="enableUpload">데이터 업로드 활성화</entry>
    <entry key="durationLabel">기간</entry>
    <entry key="parameterTuningLabel">파라미터 조정</entry>
    <entry key="configurationLabel">구성</entry>
    <entry key="externalModeCtrlPanel">외부 모드 제어판</entry>
    <entry key="externalDataArchiving">외부 데이터 보관</entry>
    <entry key="editFileNote">파일 노트 편집</entry>
    <entry key="ModelAdvisorFileIntegrityTaskTitle">Simulink 모델 파일 무결성</entry>
    <entry key="ModelAdvisorFileIntegrityTaskTitleTips">파일 무결성 확인에 유용한 검사입니다.</entry>
    <entry key="SLXModelPropertyTaskTitle">모델 내역 속성 확인</entry>
    <entry key="SLXModelPropertyTaskModifyActionName">속성 재설정</entry>
    <entry key="SLXModelPropertyTaskModifyActionDesc">모델 내역 속성을 디폴트 값으로 바꿉니다.</entry>
    <entry key="SLXModelPropertyTaskDisplayName">모델에서 편집된 모델 내역 속성값 확인</entry>
    <entry key="SLXModelPropertyTaskDescription">모델 내역 속성값이 소스 컨트롤 툴의 키워드 치환을 통해 편집된 모델이 있는지 확인합니다. 이 키워드 치환은 SLX 파일 형식에는 사용할 수 없습니다.</entry>
    <entry key="SLXModelPropertyTaskInfo">[모델 속성] 대화 상자의 [내역] 창에서 파라미터에 디폴트 태그가 사용되었는지 확인하십시오. MDL 파일 형식에서는 소스 컨트롤 툴의 키워드 치환을 사용하도록 일부 모델 속성을 구성할 수 있습니다. SLX 형식으로 모델을 저장하면 소스 컨트롤 툴에서 키워드 치환을 수행할 수 없습니다. MDL 파일을 처음 SLX로 저장할 때는 이러한 키워드 치환을 통한 모든 정보가 모델 파일에 캐시되지만, 다시 업데이트되지는 않습니다. 모델의 모델 속성 내역 창과 Model Info 블록에 그때부터의 오래된 정보가 표시됩니다.</entry>
    <entry key="SLXModelPropertySuccessOne">이 모델은 속성 {0}에 디폴트 값을 사용합니다.</entry>
    <entry key="SLXModelPropertyFailOne">이 모델에서 속성 {0}의 값은 "{1}"입니다. 디폴트 값은 "{2}"입니다.</entry>
    <entry key="SLXModelPropertyRecAction">[속성 재설정] 버튼을 클릭하여 이러한 속성을 디폴트 값으로 재설정합니다.</entry>
    <entry key="SLXModelPropertyRecWorked">속성 {0}을(를) 디폴트 값 {1}(으)로 설정</entry>
    <entry key="SLXModelPropertyRecFailed">속성 {0} 설정에 실패함:</entry>
    <entry key="ModelInfoKeywordSubstitutionTaskTitle">외부 소스 컨트롤 툴과 상호 작용할 수 있는 Model Info 블록 식별</entry>
    <entry key="ModelInfoKeywordSubstitutionTaskDescription">외부 소스 컨트롤 툴의 키워드 치환을 통해 변경될 것으로 예상되는 Model Info 블록을 식별합니다. 이 검사는 달러 기호로 묶인 Model Info 블록의 텍스트 중에서 외부 소스 컨트롤 툴로 덮어쓰일 가능성이 있는 텍스트를 검색합니다. 키워드 치환은 모델을 손상시킬 수 있기 때문에 권장되지 않습니다.</entry>
    <entry key="ModelInfoKeywordSubstitutionBlockTitle">Model Info 블록이 발견됨: ''{0}''</entry>
    <entry key="ModelInfoKeywordSubstitutionKWSDescription">Model Info 블록 ''{0}''에 외부 소스 컨트롤 툴이 키워드 치환을 사용하여 MDL 파일을 덮어쓰도록 허용할 수 있는 텍스트가 포함되어 있습니다. 키워드 치환은 모델을 손상시킬 수 있기 때문에 권장되지 않습니다. 이 텍스트를 직접 확인하고 제거하려면 Model Info 블록 ''&lt;a href="matlab:open_system(''{0}'');"&gt;{0}&lt;/a&gt;''을(를) 여십시오. 텍스트는 다음과 같습니다.&lt;br/&gt;{1}&lt;br/&gt;</entry>
    <entry key="ModelInfoKeywordSubstitutionKWSDescriptionSLX">Model Info 블록 ''{0}''에 달러 기호로 묶인 텍스트가 포함되어 있습니다. 이러한 텍스트는 소스 컨트롤 툴의 키워드 치환을 통해 MDL 파일을 덮어쓰도록 허용합니다. 키워드 치환은 SLX 파일에서는 작동하지 않습니다. 이 텍스트를 직접 확인하고 제거하려면 Model Info 블록 ''&lt;a href="matlab:open_system(''{0}'');"&gt;{0}&lt;/a&gt;''을(를) 여십시오. 텍스트는 다음과 같습니다.&lt;br/&gt;{1}&lt;br/&gt;</entry>
    <entry key="CGFESecondArgNotAString">두 번째 입력 인수는 문자형 벡터여야 합니다.</entry>
    <entry key="CGFEThirdArgNotAString">세 번째 입력 인수는 문자형 벡터여야 합니다.</entry>
    <entry key="CGFESecondAndThirdArgNotAString">The second and third input arguments must be a character vector.</entry>
    <entry key="CGFESecondArgNotAClassOf">The second input argument must be a {0} object.</entry>
    <entry key="CGFEPropertyValueNotInSet">The value of the property ''{0}'' does not belong to the set of permitted values.</entry>
    <entry key="CGFEPropertyValueNotUInt32">The value of the property ''{0}'' must fit within an uint32.</entry>
    <entry key="CGFEPropertyValueNotInt32">The value of the property ''{0}'' must fit within an int32.</entry>
    <entry key="CGFEPropertyValueNotBool">The value of the property ''{0}'' must be a logical data type.</entry>
    <entry key="CGFEPropertyValueNotString">The value of the property ''{0}'' must be a character vector.</entry>
    <entry key="CGFEPropertyValueNotEnumString">The value of the property ''{0}'' must be a character vector corresponding to an enumerated value.</entry>
    <entry key="CGFEPropertyValueNotClassOf">The value of the property ''{0}'' must belong to the class ''{1}''.</entry>
    <entry key="CGFEPropertyValueNotCellStr">The value of the property ''{0}'' must be a cell of character vectors.</entry>
    <entry key="FENoMexCompilerForLang">''{0}'' 언어에 대해 구성된 mex 컴파일러가 없습니다. 컴파일러를 지정하려면 명령 "mex -setup"을 실행하십시오.</entry>
    <entry key="CodeGenAdvisor">코드 생성 어드바이저(&amp;A)</entry>
    <entry key="CodeGenAdvisorTab">코드 생성 어드바이저</entry>
    <entry key="CodeGenAdvisorForSubSystem">코드 생성 어드바이저(&amp;A)</entry>
    <entry key="CGACheckObj">&lt;b&gt;현재 목표:&lt;/b&gt; &lt;font color="#0000FF"&gt;{0}&lt;/font&gt;&lt;br&gt; 코드 생성 목표가 모델에 설정된 목표({1})와 다릅니다. 모델에 현재 목표를 저장하려면 ''파라미터 수정'' 버튼을 클릭하십시오.</entry>
    <entry key="CGACheckObjEqual">&lt;b&gt;현재 목표:&lt;/b&gt; &lt;font color="#0000FF"&gt;{0}&lt;/font&gt;&lt;br&gt;</entry>
    <entry key="CGAReport">코드 생성 어드바이저 리포트</entry>
    <entry key="MATitleOldMaskTabnamesConversion">마스크 처리된 블록 중에서 MaskTabNames 파라미터를 사용하여 마스크 대화 상자에 탭을 지정하는 블록 식별</entry>
    <entry key="MATitletipOldMaskTabnamesConversion">마스크 처리된 블록 중에서 MaskTabNames 파라미터를 사용하여 프로그래밍 방식으로 마스크 대화 상자에 탭을 생성하는 블록을 식별합니다. R2013b부터 마스크 대화 상자의 탭에 파라미터를 그룹화할 때는 대화 상자 컨트롤이 사용됩니다.</entry>
    <entry key="MALogNoOldMaskTabnamesConversionRequired">마스크 처리된 블록 중에서 MaskTabNames를 사용하여 마스크 대화 상자에 탭을 생성하는 블록은 발견되지 않았습니다.</entry>
    <entry key="MALogUpgradeOldMaskTabnamesConversion">다음 블록은 MaskTabNames 파라미터를 사용합니다. 탭 대화 상자 컨트롤을 사용하도록 이러한 블록을 변환하려면 ''{0}''을(를) 클릭하십시오.</entry>
    <entry key="MAUpgradeButtonOldMaskTabnamesConversion">업그레이드</entry>
    <entry key="MAActionOldMaskTabnamesConversion">마스크 처리된 블록 중에서 MaskTabNames를 사용하여 마스크 대화 상자에 탭을 생성하는 블록을 업그레이드합니다.</entry>
    <entry key="MALogOldMaskTabnamesConversionDone">탭 대화 상자 컨트롤을 사용하도록 다음의 마스크 처리된 블록이 업그레이드되었습니다. 변경 내용을 저장한 다음 검사를 다시 실행하십시오.</entry>
    <entry key="MAConvert">변환</entry>
    <entry key="MAUnitInconsTaskTitle">단위 불일치</entry>
    <entry key="MAUnitInconsTaskTitleTips">단위 불일치 검사를 수행합니다.</entry>
    <entry key="MAUnitInconsOutPortStr">출력 포트</entry>
    <entry key="MAUnitInconsInPortStr">입력 포트</entry>
    <entry key="MAUnitsInconsDst1Units">소스 1 단위</entry>
    <entry key="MAUnitsInconsDst2Units">소스 2 단위</entry>
    <entry key="MAUnitsInconsBusObjUnits">버스 요소 단위</entry>
    <entry key="MAUnitsInconsSrcUnits">소스 단위</entry>
    <entry key="MAUnitsInconsDstUnits">대상 단위</entry>
    <entry key="MATitleIdentUnitMismatchPairs">모델에서 단위 불일치 식별</entry>
    <entry key="MATitletipIdentUnitMismatchPairs">모델에서 단위가 불일치하는 블록 쌍을 식별합니다.</entry>
    <entry key="MAInfoIdentUnitMismatchPairs">모델에서 단위 불일치가 있는지 검사합니다.</entry>
    <entry key="MARawTitleIdentUnitMismatchPairs">단위 불일치 검사</entry>
    <entry key="MAFailIdentUnitMismatchPairsSingular">단위 불일치가 한 건 발견되었습니다.</entry>
    <entry key="MAFailIdentUnitMismatchPairs">단위 불일치가 {0,number,integer}건 발견되었습니다.</entry>
    <entry key="MAPassIdentUnitMismatchPairs">단위 불일치가 발견되지 않았습니다.</entry>
    <entry key="MADetailUnitMismatchPairs">간단한 단위 변환으로 해결할 수 없는 단위 불일치에 대한 자세한 내용은 다음 표를 참조하십시오.</entry>
    <entry key="MAcol1UnitMismatchPairs">소스</entry>
    <entry key="MAcol2UnitMismatchPairs">대상</entry>
    <entry key="MAcol5UnitMismatchPairs">불일치 유형</entry>
    <entry key="MADetailUnitMismatchBus">들어오는 버스와의 단위 불일치에 대한 자세한 내용은 다음 표를 참조하십시오.</entry>
    <entry key="MAcol1UnitBusMismatchPairs">블록</entry>
    <entry key="MAcol2UnitBusMismatchPairs">소스 1</entry>
    <entry key="MAcol3UnitBusMismatchPairs">소스 2</entry>
    <entry key="MADetailUnitMismatchBusObj">Bus 객체와의 단위 불일치에 대한 자세한 내용은 다음 표를 참조하십시오.</entry>
    <entry key="MAcol1UnitBusObjMismatchPairs">블록</entry>
    <entry key="MAcol2UnitBusObjMismatchPairs">버스 요소</entry>
    <entry key="MAcol3UnitBusObjMismatchPairs">Bus 객체</entry>
    <entry key="MADetailUnitMismatchConstBlocks">Constant 블록 내의 단위 불일치에 대한 자세한 내용은 다음 표를 참조하십시오:</entry>
    <entry key="MAcol1UnitMismatchConstBlocks">블록</entry>
    <entry key="MAUnitsInconsConstValueUnits">값 파라미터 단위</entry>
    <entry key="MAUnitsInconsConstValueTypeUnits">ValueType 단위</entry>
    <entry key="MADetailUnitPhysicalQuantityMismatch">단위만 불일치하는 물리량에 대한 자세한 내용은 다음 테이블을 참조하십시오:</entry>
    <entry key="MAcol1UnitPhysicalQuantityMismatch">블록</entry>
    <entry key="MAUnitsInconsPhysicalQuantityMismatchUnit">단위</entry>
    <entry key="MAUnitsInconsPhysicalQuantityMismatchPhysicalQuantity">PhysicalQuantity</entry>
    <entry key="MAcol1UnitLoadingMismatchPairs">불일치 위치</entry>
    <entry key="MAcol2UnitLoadingMismatchPairs">지정된 단위</entry>
    <entry key="MAcol3UnitLoadingMismatchPairs">데이터 단위</entry>
    <entry key="MADetailUnitMismatchLoading">외부 데이터를 불러오는 중에 감지된 단위 불일치에 대한 자세한 내용은 다음 표를 참조하십시오.</entry>
    <entry key="MAcol1UnitParamMismatchPairs">블록</entry>
    <entry key="MAcol2UnitParamMismatchPairs">파라미터</entry>
    <entry key="MAcol3UnitParamMismatchPairs">파라미터 단위</entry>
    <entry key="MAcol4UnitParamMismatchPairs">변수</entry>
    <entry key="MAcol5UnitParamMismatchPairs">변수 단위</entry>
    <entry key="MADetailUnitMismatchParameter">블록 파라미터와 해당 값 간의 단위 불일치에 대한 자세한 내용은 다음 표를 참조하십시오:</entry>
    <entry key="MATitleIdentUnitAutoConv">모델의 자동 단위 변환 식별</entry>
    <entry key="MATitletipIdentUnitAutoConv">모델에 삽입된 자동 단위 변환을 식별합니다.</entry>
    <entry key="MAInfoIdentUnitAutoConv">자동 단위 변환이 있는지 검사합니다.</entry>
    <entry key="MARawTitleIdentUnitAutoConv">자동 단위 변환 검사</entry>
    <entry key="MAWarnIdentUnitAutoConvSingular">1개의 컴포넌트 쌍 사이에 자동 단위 변환이 삽입되었습니다. 자세한 내용은 다음 표를 참조하십시오.</entry>
    <entry key="MAWarnIdentUnitAutoConv">{0,number,integer}개의 컴포넌트 쌍 사이에 자동 단위 변환이 삽입되었습니다. 자세한 내용은 다음 표를 참조하십시오.</entry>
    <entry key="MAPassIdentUnitAutoConv">자동 단위 변환을 찾을 수 없습니다.</entry>
    <entry key="MACol1UnitAutoConv">변환 위치</entry>
    <entry key="MACol4UnitAutoConv">추가 메시지</entry>
    <entry key="MADetailUnitAutoConvUnsuccessful">실패한 단위 불일치의 위치에 대한 자세한 내용은 다음 표를 참조하십시오. 이러한 불일치 문제를 해결하려면 Unit Conversion 블록을 추가하십시오.</entry>
    <entry key="MACol1UnitAutoConvUnsuccessful">변환이 시도된 위치</entry>
    <entry key="MACol1UnitAutoConvUnsuccessfulReason">이유</entry>
    <entry key="MAEfficientTunableParamExprTitle">구성 파라미터에 비효율적인 포화 코드가 생성되었는지 검사</entry>
    <entry key="MAEfficientTunableParamExprTips">비효율적인 포화 코드 생성을 야기할 수 있는 구성 파라미터를 식별합니다.</entry>
    <entry key="MAEfficientTunableParamExprMsg1">범위를 벗어난 값을 처리하는 포화 코드를 생성하기 위한 설정을 확인합니다. 이러한 코드는 애플리케이션의 순 효율을 떨어뜨립니다.</entry>
    <entry key="MAEfficientTunableParamExprActionDesciption">위에 나열된 구성 파라미터를 권장 값으로 수정합니다.</entry>
    <entry key="MATitleIdentDisallowUnitSys">모델에서 허용되지 않는 단위계 식별</entry>
    <entry key="MATitletipIdentDisallowUnitSys">모델에서 허용되지 않는 단위계가 사용되었는지 식별합니다.</entry>
    <entry key="MAInfoIdentDisallowUnitSys">허용되지 않는 단위계가 있는지 검사합니다.</entry>
    <entry key="MARawTitleIdentDisallowUnitSys">허용되지 않는 단위계 검사</entry>
    <entry key="MAWarnIdentDisallowUnitSysSingular">한 곳의 위치에서 허용되지 않는 단위계가 발견되었습니다.</entry>
    <entry key="MAWarnIdentDisallowUnitSys">{0,number,integer}곳의 위치에서 허용되지 않는 단위계가 발견되었습니다.</entry>
    <entry key="MAPassIdentDisallowUnitSys">허용되지 않는 단위계가 발견되지 않았습니다.</entry>
    <entry key="MADetailDisallowUnitSysInBlocks">허용되지 않는 단위계가 모델 내 블록에서 어떻게 사용되었는지 다음 표를 참조하십시오.</entry>
    <entry key="MACol1DisallowUnitSys">사용 위치</entry>
    <entry key="MACol2DisallowUnitSys">사용된 단위</entry>
    <entry key="MACol3DisallowUnitSys">허용된 단위계</entry>
    <entry key="MADetailDisallowUnitSysInParamObjs">허용되지 않는 단위계가 블록 파라미터 참조 객체에서 어떻게 사용되었는지 다음 표를 참조하십시오.</entry>
    <entry key="MACol1DisallowUnitSysParamObj">사용 위치</entry>
    <entry key="MACol2DisallowUnitSysParamObj">사용된 단위</entry>
    <entry key="MACol3DisallowUnitSysParamObj">허용된 단위계</entry>
    <entry key="MACol4DisallowUnitSysParamObj">블록 파라미터가 참조함</entry>
    <entry key="MACol5DisallowUnitSysParamObj">객체 유형</entry>
    <entry key="MACol6DisallowUnitSysParamObj">객체 이름</entry>
    <entry key="MADetailDisallowUnitSysInSignalObjs">허용되지 않는 단위계가 모델 내 Simulink.Signal 객체에서 어떻게 사용되었는지 다음 표를 참조하십시오.</entry>
    <entry key="MACol1DisallowUnitSysSignalObj">사용 위치</entry>
    <entry key="MACol2DisallowUnitSysSignalObj">사용된 단위</entry>
    <entry key="MACol3DisallowUnitSysSignalObj">허용된 단위계</entry>
    <entry key="MACol4DisallowUnitSysSignalObj">Signal 객체</entry>
    <entry key="MATitleIdentUndefinedUnits">모델에서 정의되지 않은 단위가 있는지 식별</entry>
    <entry key="MATitletipIdentUndefinedUnits">정의되지 않은 단위가 사용되었는지 식별합니다.</entry>
    <entry key="MAInfoIdentUndefinedUnits">정의되지 않은 단위가 있는지 검사합니다.</entry>
    <entry key="MARawTitleIdentUndefinedUnits">정의되지 않은 단위 검사.</entry>
    <entry key="MAWarnIdentUndefinedUnitsSingular">한 곳의 위치에서 정의되지 않은 단위가 발견되었습니다.</entry>
    <entry key="MAWarnIdentUndefinedUnits">{0,number,integer}곳의 위치에서 정의되지 않은 단위가 발견되었습니다.</entry>
    <entry key="MADetailUndefinedUnitsInBlocks">정의되지 않은 단위가 모델 내 블록에서 어떻게 사용되었는지 다음 표를 참조하십시오. 지정된 단위를 '제안' 열에 제공된 단위로 바꾸어 보십시오.</entry>
    <entry key="MAPassIdentUndefinedUnits">정의되지 않은 단위가 발견되지 않았습니다.</entry>
    <entry key="MACol1UndefinedUnits">사용된 단위</entry>
    <entry key="MACol2UndefinedUnits">블록</entry>
    <entry key="MASuggColUndefinedUnits">제안</entry>
    <entry key="MADetailUndefinedUnitsInObjs">정의되지 않은 단위가 모델 참조 객체에서 어떻게 사용되었는지 다음 표를 참조하십시오. 지정된 단위를 '제안' 열에 제공된 단위로 바꾸어 보십시오.</entry>
    <entry key="MACol1UndefinedUnitsInObjs">사용된 단위</entry>
    <entry key="MACol2UndefinedUnitsInObjs">사용 위치</entry>
    <entry key="MACol3UndefinedUnitsInObjs">객체 유형</entry>
    <entry key="MACol4UndefinedUnitsInObjs">객체 이름</entry>
    <entry key="MACol1IncompatibleSimscapeUnits">사용된 Simscape 단위</entry>
    <entry key="MACol2IncompatibleSimscapeUnits">블록</entry>
    <entry key="MADetailIncompatibleSimscapeUnits">모델이 참조하는 Simulink 단위와 호환되지 않는 Simscape 단위가 어떻게 사용되었는지 다음 표를 참조하십시오.</entry>
    <entry key="UnitsBadgeDescriptionTitle">자세한 내용:</entry>
    <entry key="UnitsMismatchFixSuggestionRow1">제안 조치(한 가지 수행):</entry>
    <entry key="UnitsMismatchFixSuggestionRow2Col1">1) 소스 단위 수정</entry>
    <entry key="UnitsMismatchFixSuggestionRow2Col2">소스로 이동</entry>
    <entry key="UnitsMismatchFixSuggestionRow3Col1">2) 대상 단위 수정</entry>
    <entry key="UnitsMismatchFixSuggestionRow3Col2">대상으로 이동</entry>
    <entry key="UnitsMismatchFixSuggestionRow4Col1">3) 단위 파라미터를 []로 설정한 상태에서 Signal Specification 블록 삽입</entry>
    <entry key="MATitleIdentAmbiguousUnits">모델에서 모호한 단위 식별</entry>
    <entry key="MATitletipIdentAmbiguousUnits">모호한 단위가 사용되었는지 식별합니다.</entry>
    <entry key="MAInfoIdentAmbiguousUnits">모호한 단위가 있는지 검사합니다.</entry>
    <entry key="MARawTitleIdentAmbiguousUnits">모호한 단위 검사.</entry>
    <entry key="MAWarnIdentAmbiguousUnitsSingular">한 곳의 위치에서 모호한 단위가 발견되었습니다.</entry>
    <entry key="MAWarnIdentAmbiguousUnits">{0,number,integer}곳의 위치에서 모호한 단위가 발견되었습니다.</entry>
    <entry key="MADetailAmbiguousUnitsInBlocks">모호한 단위가 모델 내 블록에서 어떻게 사용되었는지 다음 표를 참조하십시오. 지정된 단위를 '제안' 열에 제공된 단위로 변경할 수 있는지 살펴보십시오.</entry>
    <entry key="MAPassIdentAmbiguousUnits">모호한 단위가 발견되지 않았습니다.</entry>
    <entry key="MACol1AmbiguousUnits">사용된 단위</entry>
    <entry key="MACol2AmbiguousUnits">블록</entry>
    <entry key="MASuggColAmbiguousUnits">제안</entry>
    <entry key="MADetailAmbiguousUnitsInObjs">모호한 단위가 모델 참조 객체에서 어떻게 사용되었는지 다음 표를 참조하십시오. 지정된 단위를 '제안' 열에 제공된 단위로 변경할 수 있는지 살펴보십시오.</entry>
    <entry key="MACol1AmbiguousUnitsInObjs">사용된 단위</entry>
    <entry key="MACol2AmbiguousUnitsInObjs">사용 위치</entry>
    <entry key="MACol3AmbiguousUnitsInObjs">객체 유형</entry>
    <entry key="MACol4AmbiguousUnitsInObjs">객체 이름</entry>
    <entry key="EditTimeMismatchUnitAttr">단위</entry>
    <entry key="EditTimeMismatchDataTypeAttr">데이터형</entry>
    <entry key="EditTimeMismatchComplexityAttr">실수/복소수 여부</entry>
    <entry key="EditTimeMismatchDimensionsAttr">차원</entry>
    <entry key="EditTimeMismatchPortHeader">포트</entry>
    <entry key="EditTimeMismatchSourcePort">소스</entry>
    <entry key="EditTimeMismatchDestPort">대상</entry>
    <entry key="EditTimeMismatchDestPortSelection">대상 포트</entry>
    <entry key="EditTimeMismatchTitle">특성 불일치</entry>
    <entry key="EditTimeMismatchAttribute">특성</entry>
    <entry key="EditTimeMismatchSummary">특성이 불일치하는 {0}개의 대상 포트를 발견했습니다.</entry>
    <entry key="ErrorApplyingHotParamTitle">오류</entry>
    <entry key="MASFunAnalyzerTaskTitle">S-Function 검사</entry>
    <entry key="MASFunAnalyzerTaskTitleTips">S-Function 검사를 수행합니다.</entry>
    <entry key="MATitleSFunctionAnalyzerCheck">모델에서 S-Function 검사</entry>
    <entry key="MATitletipSFunctionAnalyzerCheck">S-Function 검사를 수행합니다.</entry>
    <entry key="MAInfoSFunctionAnalyzerCheck">모델의 S-Function을 검사하고 잠재적 문제와 개선 사항을 보고합니다.</entry>
    <entry key="MAFailSFunctionAnalyzerCheck">S-Function 검사가 실패했습니다.</entry>
    <entry key="MAPassSFunctionAnalyzerCheck">S-Function 검사를 통과했습니다.</entry>
    <entry key="MAWarnSFunctionAnalyzerCheck">S-Function 검사에서 경고가 발생했습니다.</entry>
    <entry key="MASFunAnalyzerReport">세부 정보를 보려면 &lt;a href="matlab:Simulink.sfunction.analyzer.openReport(''{0}'');"&gt;S-Function 검사 리포트&lt;/a&gt;를 여십시오.</entry>
    <entry key="MANoUserSfunctions">모델에 사용자 정의 S-Function이 없습니다.</entry>
    <entry key="MASFcnMexAnalyzerTaskTitle">모델에 S-Function 업그레이드 문제가 있는지 검사</entry>
    <entry key="MASFcnMexAnalyzerTaskTitleTips">S-Function을 검사하여 호환성 문제를 식별합니다.</entry>
    <entry key="MASFcnMexAnalyzerCheckTitle">모델에 S-Function 업그레이드 문제가 있는지 검사</entry>
    <entry key="MASFcnMexAnalyzerCheckTitleTips">S-Function을 검사하여 호환성 문제를 식별합니다.</entry>
    <entry key="MAInfoSFcnMexAnalyzerCheck">모델의 S-Function을 검사하고 업그레이드 문제와 개선 사항을 보고합니다.</entry>
    <entry key="MAPassSFcnMexAnalyzerCheck">S-Function 업그레이드 검사를 통과했습니다.</entry>
    <entry key="MASubTitleENOEVER">사용자 지정 빌드된 이진 MEX 파일</entry>
    <entry key="MASubInfoENOEVER">S-Function에 사용자 지정 빌드된 MEX 파일이 사용되었는지 검사합니다.</entry>
    <entry key="MAComplaintENOEVER">다음 S-Function은 지원되지 않는 사용자 지정 빌드된 MEX 파일을 사용합니다.</entry>
    <entry key="MASubTitleELNKCPP">호환되지 않는 C++ 컴파일 옵션</entry>
    <entry key="MASubInfoELNKCPP">C++ S-Function이 호환되지 않는 옵션으로 컴파일되었는지 검사합니다.</entry>
    <entry key="MAComplaintELNKCPP">다음 S-Function에는 호환되지 않는 옵션으로 컴파일된 MEX 파일이 연결되어 있습니다.</entry>
    <entry key="MASubTitleELNKAPI">호환되지 않는 MEX 컴파일 옵션</entry>
    <entry key="MASubInfoELNKAPI">S-Function이 호환되지 않는 옵션으로 컴파일되었는지 검사합니다.</entry>
    <entry key="MAComplaintELNKAPI">다음 S-Function은 호환되지 않는 옵션으로 컴파일되었습니다.</entry>
    <entry key="MASubTitleEVERAPI">호환되지 않는 컴파일 및 연결</entry>
    <entry key="MASubInfoEVERAPI">S-Function이 호환되지 않는 옵션으로 컴파일되고 연결되었는지 검사합니다.</entry>
    <entry key="MAComplaintEVERAPI">다음 S-Function의 컴파일과 링크 옵션이 호환되지 않습니다.</entry>
    <entry key="MASubTitleEUNKAPI">지원되지 않는 함수</entry>
    <entry key="MASubInfoEUNKAPI">S-Function이 향후 릴리스에서 컴파일되는지 검사합니다.</entry>
    <entry key="MAComplaintEUNKAPI">다음 S-Function은 향후 릴리스에서는 컴파일되지만 현재 릴리스에서는 지원되지 않습니다.</entry>
    <entry key="MASubTitleURECOMP">재컴파일이 필요함</entry>
    <entry key="MASubInfoURECOMP">S-Function이 만료된 API로 컴파일되었는지 검사합니다.</entry>
    <entry key="MAComplaintURECOMP">다음 S-Function은 최신 API로 컴파일되지 않았습니다.</entry>
    <entry key="MASubTitleULATEST">데이터 액세스 함수</entry>
    <entry key="MASubInfoULATEST">컴파일된 S-Function에 데이터형을 지정하지 않은 데이터 액세스 함수가 있는지 검사합니다.</entry>
    <entry key="MAComplaintULATEST">다음 S-Function은 데이터형을 지정하지 않은 데이터 액세스 함수를 하나 이상 호출합니다.</entry>
    <entry key="MASubTitleUCOMPAT">더 이상 사용되지 않는 함수</entry>
    <entry key="MASubInfoUCOMPAT">컴파일된 S-Function에 더 이상 사용되지 않는 함수가 있는지 검사합니다.</entry>
    <entry key="MAComplaintUCOMPAT">다음 S-function은 더 이상 사용되지 않는 함수를 하나 이상 호출합니다.</entry>
    <entry key="MASubTitleULEGACY">호환되지 않는 32비트 함수</entry>
    <entry key="MASubInfoULEGACY">컴파일된 S-Function에 32비트 함수가 있는지 검사합니다.</entry>
    <entry key="MAComplaintULEGACY">다음 S-function은 32비트 함수를 하나 이상 호출합니다.</entry>
    <entry key="MASubTitleUENTRYP">진입점 누락</entry>
    <entry key="MASubInfoUENTRYP">S-Function에 유효한 진입점이 있는지 검사합니다.</entry>
    <entry key="MAComplaintUENTRYP">다음 S-Function은 진입점을 포함하지 않으며 MATLAB에서 실행되지 않습니다. S-Function에 ''simulink.c''가 포함되어 있지 않은 것이 원인일 수 있습니다.</entry>
    <entry key="MAAddtlInfoUENTRYP">C MEX S-Function의 일반 형식에 대한 문서를 참조하십시오.</entry>
    <entry key="CodeBrowserInvalidFileName">Code Browser: Invalid file name: {0}</entry>
    <entry key="MaxIdentifierErrorInConfigParameters">이 충돌은 [구성 파라미터] 대화 상자의 [식별자] 창에서 최대 식별자 길이를 늘리거나 충돌하는 식별자의 이름을 변경하여 해결할 수 있습니다.</entry>
    <entry key="CGAParallelNotSupported">병렬 빌드에는 코드 생성 어드바이저가 지원되지 않습니다. ''{0}''에 대한 모델 검사가 중단되었습니다. 이 경고를 비활성화하려면 구성 파라미터 대화 상자에서 ''코드 생성 전에 모델 검사''를 ''끄기''로 설정하십시오.</entry>
    <entry key="PrefixForCompileCheck">^</entry>
    <entry key="MAMsgContSrcLocation">&lt;tr&gt;&lt;td&gt;&lt;a href="matlab:modeladvisorprivate(''hiliteSystem'',''{0}'');"&gt;{1}&lt;/a&gt;&lt;/td&gt;&lt;td align="right"&gt;{2,number,integer}&lt;/td&gt;&lt;td align="right"&gt;{3,number,integer}&lt;/td&gt;&lt;td align="right"&gt;{4,number,integer}&lt;/td&gt;&lt;/tr&gt;</entry>
    <entry key="rapidAccelTgtConnParamDownloadWarning">{0}</entry>
    <entry key="MADiscreteIntegratorCheckDiscreteIntegrator">Discrete-Time Integrator</entry>
    <entry key="LCTErrorRethrowErrorWithSpec">{1}:\n{0}</entry>
    <entry key="LCTSpecParserBadSizeSyntax">{1}:\n{0}</entry>
    <entry key="extModeOpenSLRTWarning">{0}</entry>
    <entry key="SFunctionWizardInvalidArgs">{0}</entry>
    <entry key="SimulationOutputDispHeading">Simulink.SimulationOutput:</entry>
    <entry key="ParserMessage">{0}</entry>
  </message>
</rsccat>
