<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2024 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ko_KR" product="Simulink" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="StateMatrixA_MP">상태 행렬 A:</entry>
    <entry key="InputMatrixB_MP">입력 행렬 B:</entry>
    <entry key="OutputMatrixC_MP">출력 행렬 C:</entry>
    <entry key="DirectFeedthroughMatrixD_MP">직접 피드스루 행렬 D:</entry>
    <entry key="InitialConditionForState_MP">상태의 초기 조건:</entry>
    <entry key="DataTypeForInternalCalculations_MP">내부 계산을 위한 데이터형(예: fixdt(1, 16), fixdt(''single'')):</entry>
    <entry key="ScalingForStateEquationAXBU_MP">상태 방정식 AX+BU에 대한 스케일링(기울기, 예: 2^-9):</entry>
    <entry key="ScalingForOutputEquationCXDU_MP">출력 방정식 CX+DU에 대한 스케일링(기울기, 예: 2^-9):</entry>
    <entry key="LockOutputDataTypeAgainstFxpTools_MP">고정소수점 툴에 의해 변경되지 않도록 출력 데이터형 설정 잠금</entry>
    <entry key="IntegerRoundingMode_MP">정수 반올림 모드:</entry>
    <entry key="SaturateToMaxOrMinWhenOverflowsOccur_MP">오버플로가 발생할 경우 최대 또는 최소로 포화</entry>
    <entry key="FixedPointStateSpace_MD">이산시간 상태공간 구현</entry>
    <entry key="NumeratorCoefficients_MP">분자 계수:</entry>
    <entry key="DenominatorCoefficientsExcludingLead_MP">선행 계수를 제외한 분모 계수(선행 계수는 반드시 1.0):</entry>
    <entry key="InitialCondition_MP">초기 조건:</entry>
    <entry key="TransferFcnDirectFormII_MD">지정된 전달 함수에 대한 Direct Form II 구현이 사용되었습니다. 단일 입력 다중 출력 전달 함수만 지원됩니다. \n\n출력, 계수 및 모든 임시 변수의 데이터형 및 스케일링은 자동으로 선택됩니다. 자동 선택은 여러 상황에서 용인할 만합니다. 자동 선택으로 용인할 수 없는 결과가 생성되는 경우에는 필터에 대한 수동 레이아웃이 필요합니다. 수동 레이아웃의 경우 이 마스크 내부에 있는 블록을 시작점으로 사용하는 것이 바람직합니다.\n\n참고 1:\n완전한 분모는 선행 계수 +1.0을 가져야 하지만 파라미터를 입력할 때에는 이 선행 계수를 제외해야 합니다. 예를 들어, 분모가 다음과 같은 경우\n den = \n 1 -1.7 0.72\n다음을 입력하십시오.\n den(2:end) =\n -1.7 0.72\n\n참고 2:\n분자는 완전한 분모와 동일한 크기여야 합니다.</entry>
    <entry key="TransferFcnDirectFormIITimeVarying_MD">지정된 전달 함수에 대한 Direct Form II 구현이 사용되었습니다. 단일 입력 단일 출력 전달 함수만 지원됩니다. \n\n출력, 계수 및 모든 임시 변수의 데이터형 및 스케일링은 자동으로 선택됩니다. 자동 선택은 여러 상황에서 용인할 만합니다. 자동 선택으로 용인할 수 없는 결과가 생성되는 경우에는 필터에 대한 수동 레이아웃이 필요합니다. 수동 레이아웃의 경우 이 마스크 내부에 있는 블록을 시작점으로 사용하는 것이 바람직합니다.\n\n참고 1:\n완전한 분모는 선행 계수 +1.0을 가져야 하지만 파라미터를 입력할 때에는 이 선행 계수를 제외해야 합니다. 예를 들어, 분모가 다음과 같은 경우\n den = \n 1 -1.7 0.72\n다음을 입력하십시오.\n den(2:end) =\n -1.7 0.72\n\n참고 2:\n분자는 완전한 분모와 동일한 크기여야 합니다.</entry>
    <entry key="SampleTime_MP">샘플 시간:</entry>
    <entry key="UnitDelayEnabled_MD">일반적으로 출력은 하나의 샘플 주기만큼 지연된 신호 u입니다.\n활성화 신호가 false인 경우 블록이 비활성화되며 상태 및 출력값이 변경되지 않습니다. 활성화 동작은 벡터화되었으며 스칼라 확장을 지원합니다.</entry>
    <entry key="UnitDelayEnabledExternalInitialCondition_MD">일반적으로 출력은 하나의 샘플 주기만큼 지연된 신호 u입니다.\n초기 조건은 신호 IC로 지정됩니다.\n활성화 신호가 false인 경우 블록이 비활성화되며, 재설정하는 경우를 제외하고 상태 및 출력값이 변경되지 않습니다. 활성화 동작은 벡터화되었으며 스칼라 확장을 지원합니다.</entry>
    <entry key="UnitDelayEnabledResettable_MD">일반적으로 출력은 하나의 샘플 주기만큼 지연된 신호 u입니다.\n재설정 신호 R이 true인 경우 상태 및 출력은 항상 초기 조건 파라미터와 같게 설정됩니다. 이 재설정 동작은 벡터화되었으며 스칼라 확장을 지원합니다.\n활성화 신호가 false인 경우 블록이 비활성화되며 재설정하는 경우를 제외하고 상태 및 출력 값이 변경되지 않습니다. 활성화 동작은 벡터화되었으며 스칼라 확장을 지원합니다.</entry>
    <entry key="UnitDelayEnabledResettableExternalInitialCondition_MD">일반적으로 출력은 하나의 샘플 주기만큼 지연된 신호 u입니다.\n재설정 신호 R이 true인 경우 상태 및 출력은 항상 초기 조건 신호 IC와 같게 설정됩니다. 이 재설정 동작은 벡터화되었으며 스칼라 확장을 지원합니다.\n활성화 신호가 false인 경우 블록이 비활성화되며 재설정하는 경우를 제외하고 상태 및 출력 값이 변경되지 않습니다. 활성화 동작은 벡터화되었으며 스칼라 확장을 지원합니다.</entry>
    <entry key="UnitDelayExternalInitialCondition_MD">일반적으로 출력은 하나의 샘플 주기만큼 지연된 신호 u입니다.\n초기 조건은 신호 IC로 지정됩니다.</entry>
    <entry key="UnitDelayResettable_MD">일반적으로 출력은 하나의 샘플 주기만큼 지연된 신호 u입니다.\n재설정 신호 R이 true인 경우 상태 및 출력은 항상 초기 조건 파라미터와 같게 설정됩니다. 이 재설정 동작은 벡터화되었으며 스칼라 확장을 지원합니다.</entry>
    <entry key="UnitDelayResettableExternalInitialCondition_MD">일반적으로 출력은 하나의 샘플 주기만큼 지연된 신호 u입니다.\n재설정 신호 R이 true인 경우 상태 및 출력은 항상 초기 조건 신호 IC와 같게 설정됩니다. 이 재설정 동작은 벡터화되었으며 스칼라 확장을 지원합니다.</entry>
    <entry key="UnitDelayWithPreviewEnabled_MD">Unit Delay With Preview Enabled는 일반적으로 신호 u와 동일한 첫 번째 출력과 그 첫 번째 출력이 단위 지연된 두 번째 출력을 갖습니다.\n\n활성화 신호가 false인 경우 블록이 비활성화되며 재설정하는 동안을 제외하고는 상태 및 출력 값이 변경되지 않습니다.</entry>
    <entry key="UnitDelayWithPreviewEnabledResettable_MD">Unit Delay With Preview Enabled Resettable은 일반적으로 신호 u와 동일한 하나의 출력과 첫 번째 출력의 단위 지연된 버전인 두 번째 출력을 갖습니다.\n\n외부 재설정 신호 R이 true인 경우 첫 번째 출력 신호는 강제로 초기 조건과 같아집니다. 두 번째 출력 신호는 시간 스텝이 하나 지날 때까지 영향을 받지 않습니다. 내부 초기 조건은 또한 모델이 시작되거나 부모 Enabled Subsystem이 재설정되는 경우 상태를 초기화하는 데에도 사용됩니다.\n\n활성화 신호가 false인 경우 블록이 비활성화되며, 재설정하는 동안을 제외하고는 상태 및 출력 값이 변경되지 않습니다.</entry>
    <entry key="UnitDelayWithPreviewEnabledResettableExternalRV_MD">Unit Delay With Preview Enabled Resettable External RV는 외부 재설정 값 RV와 내부 초기 조건이 모두 있어야 합니다. 일반적으로 이 블록은 신호 u와 동일한 하나의 출력과 첫 번째 출력의 단위 지연된 버전인 두 번째 출력을 갖습니다.\n\n재설정 신호 R이 true인 경우 첫 번째 출력 신호는 강제로 RV와 같아집니다. 두 번째 출력 신호는 시간 스텝이 하나 지날 때까지 영향을 받지 않습니다. 내부 초기 조건은 모델이 시작되거나 부모 Enabled Subsystem이 재설정되는 경우 두 번째 출력에 대해서만 직접적인 효과를 갖습니다.\n\n활성화 신호가 false인 경우 블록이 비활성화되며 재설정하는 동안을 제외하고는 상태 및 출력 값이 변경되지 않습니다.</entry>
    <entry key="UnitDelayWithPreviewResettable_MD">Unit Delay With Preview Resettable은 일반적으로 신호 u와 동일한 하나의 출력과 첫 번째 출력의 단위 지연된 버전인 두 번째 출력을 갖습니다.\n\n재설정 신호 R이 true인 경우 첫 번째 출력 신호는 강제로 초기 조건과 같아집니다. 두 번째 출력 신호는 시간 스텝이 하나 지날 때까지 영향을 받지 않습니다. 내부 초기 조건은 또한 모델이 시작되거나 부모 Enabled Subsystem이 재설정되는 경우 상태를 초기화하는 데에도 사용됩니다.</entry>
    <entry key="UnitDelayWithPreviewResettableExternalRV_MD">Unit Delay With Preview Resettable External Rv는 외부 재설정 값 RV와 내부 초기 조건이 모두 있어야 합니다. 이 블록은 일반적으로 신호 u와 동일한 하나의 출력과 첫 번째 출력의 단위 지연된 버전인 두 번째 출력을 갖습니다.\n\n재설정 신호 R이 true인 경우 첫 번째 출력 신호는 강제로 RV와 같아집니다. 두 번째 출력 신호는 시간 스텝이 하나 지날 때까지 영향을 받지 않습니다. 내부 초기 조건은 모델이 시작되거나 부모 Enabled Subsystem이 재설정되는 경우 두 번째 출력에 대해서만 직접적인 효과를 갖습니다.</entry>
    <entry key="RealWorldValueDecrement_MD">신호의 실제 값을 1.0만큼 줄입니다.\n오버플로는 항상 래핑됩니다.</entry>
    <entry key="StoredIntegerValueDecrement_MD">신호의 저장된 값을 1만큼 줄입니다.\n부동소수점 신호가 1.0만큼 줄어듭니다.\n오버플로는 항상 래핑됩니다.</entry>
    <entry key="DecrementToZero_MD">신호의 실제 값을 1.0만큼 줄입니다.\n그러나 0 아래로는 내려가지 않습니다.</entry>
    <entry key="DecrementTimeToZero_MD">신호의 실제 값을 샘플 시간 Ts만큼 줄입니다.\n그러나 0 아래로는 내려가지 않습니다.\n\n이 블록은 고정된 샘플 레이트에서만 동작하므로 Triggered Subsystem 내에서는 동작하지 않습니다.</entry>
    <entry key="RealWorldValueIncrement_MD">신호의 실제 값을 1.0만큼 늘립니다.\n오버플로는 항상 래핑됩니다.</entry>
    <entry key="StoredIntegerValueIncrement_MD">신호의 저장된 값을 1만큼 늘립니다.\n부동소수점 신호가 1.0만큼 늘어납니다.\n오버플로는 항상 래핑됩니다.</entry>
    <entry key="Controller_MP">제어기:</entry>
    <entry key="TimeDomain_MP">시간 영역:</entry>
    <entry key="ContinuousTime_MP">연속시간</entry>
    <entry key="DiscreteTime_MP">이산시간</entry>
    <entry key="SampleTime1ForInherited_MP">샘플 시간(상속된 경우 -1):</entry>
    <entry key="DiscreteTimeSettings_GT">이산시간 설정</entry>
    <entry key="IntegratorMethod_MP">적분기 방법:</entry>
    <entry key="FilterMethod_MP">필터 방법:</entry>
    <entry key="PIDBlockInTriggeredSubsystem_MP">PID Controller가 조건부 실행 서브시스템 내에 있음</entry>
    <entry key="Form_MP">형식:</entry>
    <entry key="ControllerParameters_GT">제어기 파라미터</entry>
    <entry key="ProportionalP_MP">비례(P):</entry>
    <entry key="IntegralI_MP">적분(I):</entry>
    <entry key="DerivativeD_MP">미분(D):</entry>
    <entry key="UseFilter_MP">필터링된 미분 사용</entry>
    <entry key="FilterCoefficientN_MP">필터 계수(N):</entry>
    <entry key="PIDTune">조정...</entry>
    <entry key="InitialConditions_GT">초기 조건</entry>
    <entry key="Source_MP">소스:</entry>
    <entry key="Integrator_MP">적분기:</entry>
    <entry key="Filter_MP">필터:</entry>
    <entry key="ExternalReset_GT">외부 재설정</entry>
    <entry key="ExternalReset_MP">외부 재설정:</entry>
    <entry key="IgnoreResetWhenLinearizing_MP">선형화할 때 재설정 무시</entry>
    <entry key="EnableZerocrossingDetection_MP">영점교차 검출 활성화</entry>
    <entry key="PIDAdvanced_TAB">PID 고급</entry>
    <entry key="OutputSaturation_GT">출력 포화</entry>
    <entry key="OutputSaturation_TAB">포화</entry>
    <entry key="AntiwindupMethod_GT">안티와인드업(Anti-windup)</entry>
    <entry key="LimitOutput_MP">출력 제한</entry>
    <entry key="UpperSaturationLimit_MP">상한:</entry>
    <entry key="LowerSaturationLimit_MP">하한:</entry>
    <entry key="IgnoreSaturationWhenLinearizing_MP">선형화할 때 포화 무시</entry>
    <entry key="AntiwindupMethod_MP">안티와인드업 방법:</entry>
    <entry key="BackcalculationCoefficientKb_MP">역계산 계수(Kb):</entry>
    <entry key="TrackingMode_GT">추적 모드</entry>
    <entry key="EnableTrackingMode_MP">추적 모드 활성화</entry>
    <entry key="TrackingCoefficientKt_MP">추적 계수(Kt):</entry>
    <entry key="SaturateOnIntegerOverflow_MP">정수 오버플로 시 포화</entry>
    <entry key="LockDataTypeAgainstFxpTools_MP">고정소수점 툴에 의해 변경되지 않도록 데이터형 설정 잠금</entry>
    <entry key="PParameterMinimum_MP">P 파라미터 최솟값:</entry>
    <entry key="PParameterMaximum_MP">P 파라미터 최댓값:</entry>
    <entry key="PParameter_MP">P 파라미터:</entry>
    <entry key="IParameterMinimum_MP">I 파라미터 최솟값:</entry>
    <entry key="IParameterMaximum_MP">I 파라미터 최댓값:</entry>
    <entry key="IParameter_MP">I 파라미터:</entry>
    <entry key="DParameterMinimum_MP">D 파라미터 최솟값:</entry>
    <entry key="DParameterMaximum_MP">D 파라미터 최댓값:</entry>
    <entry key="DParameter_MP">D 파라미터:</entry>
    <entry key="NParameterMinimum_MP">N 파라미터 최솟값:</entry>
    <entry key="NParameterMaximum_MP">N 파라미터 최댓값:</entry>
    <entry key="NParameter_MP">N 파라미터:</entry>
    <entry key="KbParameterMinimum_MP">Kb 파라미터 최솟값:</entry>
    <entry key="KbParameterMaximum_MP">Kb 파라미터 최댓값:</entry>
    <entry key="KbParameter_MP">Kb 파라미터:</entry>
    <entry key="KtParameterMinimum_MP">Kt 파라미터 최솟값:</entry>
    <entry key="KtParameterMaximum_MP">Kt 파라미터 최댓값:</entry>
    <entry key="KtParameter_MP">Kt 파라미터:</entry>
    <entry key="PProductOutputMinimum_MP">P 곱 연산 출력 최솟값:</entry>
    <entry key="PProductOutputMaximum_MP">P 곱 연산 출력 최댓값:</entry>
    <entry key="PProductOutput_MP">P 곱 연산 출력:</entry>
    <entry key="IProductOutputMinimum_MP">I 곱 연산 출력 최솟값:</entry>
    <entry key="IProductOutputMaximum_MP">I 곱 연산 출력 최댓값:</entry>
    <entry key="IProductOutput_MP">I 곱 연산 출력:</entry>
    <entry key="DProductOutputMinimum_MP">D 곱 연산 출력 최솟값:</entry>
    <entry key="DProductOutputMaximum_MP">D 곱 연산 출력 최댓값:</entry>
    <entry key="DProductOutput_MP">D 곱 연산 출력:</entry>
    <entry key="NProductOutputMinimum_MP">N 곱 연산 출력 최솟값:</entry>
    <entry key="NProductOutputMaximum_MP">N 곱 연산 출력 최댓값:</entry>
    <entry key="NProductOutput_MP">N 곱 연산 출력:</entry>
    <entry key="KbProductOutputMinimum_MP">Kb 곱 연산 출력 최솟값:</entry>
    <entry key="KbProductOutputMaximum_MP">Kb 곱 연산 출력 최댓값:</entry>
    <entry key="KbProductOutput_MP">Kb 곱 연산 출력:</entry>
    <entry key="KtProductOutputMinimum_MP">Kt 곱 연산 출력 최솟값:</entry>
    <entry key="KtProductOutputMaximum_MP">Kt 곱 연산 출력 최댓값:</entry>
    <entry key="KtProductOutput_MP">Kt 곱 연산 출력:</entry>
    <entry key="IntegratorOutputMinimum_MP">적분기 출력 최솟값:</entry>
    <entry key="IntegratorOutputMaximum_MP">적분기 출력 최댓값:</entry>
    <entry key="IntegratorOutput_MP">적분기 출력:</entry>
    <entry key="FilterOutputMinimum_MP">필터 출력 최솟값:</entry>
    <entry key="FilterOutputMaximum_MP">필터 출력 최댓값:</entry>
    <entry key="FilterOutput_MP">필터 출력:</entry>
    <entry key="DifferentiatorOutputMinimum_MP">미분기 출력 최솟값:</entry>
    <entry key="DifferentiatorOutputMaximum_MP">미분기 출력 최댓값:</entry>
    <entry key="DifferentiatorOutput_MP">미분기 출력:</entry>
    <entry key="SumOutputMinimum_MP">합계 출력 최솟값:</entry>
    <entry key="SumOutputMaximum_MP">합계 출력 최댓값:</entry>
    <entry key="SumOutput_MP">합계 출력:</entry>
    <entry key="SumI1OutputMinimum_MP">SumI1 출력 최솟값:</entry>
    <entry key="SumI1OutputMaximum_MP">SumI1 출력 최댓값:</entry>
    <entry key="SumI1Output_MP">SumI1 출력:</entry>
    <entry key="SumI2OutputMinimum_MP">SumI2 출력 최솟값:</entry>
    <entry key="SumI2OutputMaximum_MP">SumI2 출력 최댓값:</entry>
    <entry key="SumI2Output_MP">SumI2 출력:</entry>
    <entry key="SumI3OutputMinimum_MP">SumI3 출력 최솟값:</entry>
    <entry key="SumI3OutputMaximum_MP">SumI3 출력 최댓값:</entry>
    <entry key="SumI3Output_MP">SumI3 출력:</entry>
    <entry key="SumI4Output_MP">SumI4 출력:</entry>
    <entry key="SumDOutputMinimum_MP">SumD 출력 최솟값:</entry>
    <entry key="SumDOutputMaximum_MP">SumD 출력 최댓값:</entry>
    <entry key="SumDOutput_MP">SumD 출력:</entry>
    <entry key="AccumulatorOfSum_MP">합계 누산기:</entry>
    <entry key="AccumulatorOfSumI1_MP">SumI1 누산기:</entry>
    <entry key="AccumulatorOfSumI2_MP">SumI2 누산기:</entry>
    <entry key="AccumulatorOfSumI3_MP">SumI3 누산기:</entry>
    <entry key="AccumulatorOfSumI4_MP">SumI4 누산기:</entry>
    <entry key="AccumulatorOfSumD_MP">SumD 누산기:</entry>
    <entry key="SaturationOutputMinimum_MP">포화 출력 최솟값:</entry>
    <entry key="SaturationOutputMaximum_MP">포화 출력 최댓값:</entry>
    <entry key="SaturationOutput_MP">포화 출력:</entry>
    <entry key="IntegratorState_GT">적분기 상태</entry>
    <entry key="FilterState_GT">필터 상태</entry>
    <entry key="StateNameegposition_MP">상태 이름: (예: "position")</entry>
    <entry key="StateName_MP">상태 이름:</entry>
    <entry key="StateNameMustResolveToSimulinkSignalObject_MP">상태 이름과 Simulink의 Signal 객체 사이에 연결이 맺어져야 함</entry>
    <entry key="CodeGenerationStorageClass_MP">코드 생성 스토리지 클래스:</entry>
    <entry key="CodeGenerationStorageTypeQualifier_MP">코드 생성 저장공간 유형 한정자:</entry>
    <entry key="PID1dof_MD">이 블록은 연속시간 및 이산시간 PID 제어 알고리즘을 구현하고 안티와인드업, 외부 재설정, 신호 추적과 같은 고급 기능을 포함합니다. ''조정...'' 버튼을 사용하여 PID 이득을 자동으로 조정할 수 있습니다(Simulink Control Design이 필요함).</entry>
    <entry key="SetpointWeightb_MP">설정점 가중치(b):</entry>
    <entry key="SetpointWeightc_MP">설정점 가중치(c):</entry>
    <entry key="bParameterMinimum_MP">b 파라미터 최솟값:</entry>
    <entry key="bParameterMaximum_MP">b 파라미터 최댓값:</entry>
    <entry key="bParameter_MP">b 파라미터:</entry>
    <entry key="cParameterMinimum_MP">c 파라미터 최솟값:</entry>
    <entry key="cParameterMaximum_MP">c 파라미터 최댓값:</entry>
    <entry key="cParameter_MP">c 파라미터:</entry>
    <entry key="bProductOutputMinimum_MP">b 곱 연산 출력 최솟값:</entry>
    <entry key="bProductOutputMaximum_MP">b 곱 연산 출력 최댓값:</entry>
    <entry key="bProductOutput_MP">b 곱 연산 출력:</entry>
    <entry key="cProductOutputMinimum_MP">c 곱 연산 출력 최솟값:</entry>
    <entry key="cProductOutputMaximum_MP">c 곱 연산 출력 최댓값:</entry>
    <entry key="cProductOutput_MP">c 곱 연산 출력:</entry>
    <entry key="Sum1OutputMinimum_MP">Sum1 출력 최솟값:</entry>
    <entry key="Sum1OutputMaximum_MP">Sum1 출력 최댓값:</entry>
    <entry key="Sum1Output_MP">Sum1 출력:</entry>
    <entry key="Sum2OutputMinimum_MP">Sum2 출력 최솟값:</entry>
    <entry key="Sum2OutputMaximum_MP">Sum2 출력 최댓값:</entry>
    <entry key="Sum2Output_MP">Sum2 출력:</entry>
    <entry key="Sum3OutputMinimum_MP">Sum3 출력 최솟값:</entry>
    <entry key="Sum3OutputMaximum_MP">Sum3 출력 최댓값:</entry>
    <entry key="Sum3Output_MP">Sum3 출력:</entry>
    <entry key="AccumulatorOfSum1_MP">Sum1 누산기:</entry>
    <entry key="AccumulatorOfSum2_MP">Sum2 누산기:</entry>
    <entry key="AccumulatorOfSum3_MP">Sum3 누산기:</entry>
    <entry key="PID2dof_MD">이 블록은 설정점 가중을 사용하여 연속시간 및 이산시간 PID 제어 알고리즘을 구현하고 안티와인드업, 외부 재설정, 신호 추적과 같은 고급 기능을 포함합니다. ''조정...'' 버튼을 사용하여 PID 이득을 자동으로 조정할 수 있습니다(Simulink Control Design이 필요함).</entry>
    <entry key="discretePIDToolTip">''순방향 오일러'' 이외의 이산화 방법은 현재 코드 생성 및 고정소수점 시뮬레이션을 지원하지 않습니다.</entry>
    <entry key="PIDCompensatorFormula">보상기 공식</entry>
    <entry key="UnknownMaskType">알 수 없는 마스크 유형임: {0}</entry>
    <entry key="UnknownMaskTypeMfile">PIDMasks {0}에 알 수 없는 마스크 유형이 있습니다.</entry>
    <entry key="CreateDialogError">대화 상자를 생성하는 중 오류가 발생함:</entry>
    <entry key="Differentiator_MP">미분기:</entry>
    <entry key="FilterDiffNumProductOutput_MP">필터 분자 곱 연산 출력:</entry>
    <entry key="FilterDiffNumAccumulator_MP">필터 분자 누산기:</entry>
    <entry key="FilterDiffDenProductOutput_MP">필터 분모 곱 연산 출력:</entry>
    <entry key="FilterDiffDenAccumulator_MP">필터 분모 누산기:</entry>
    <entry key="FilterDiffCoefficientOutput_MP">필터 계수 곱 연산 출력:</entry>
    <entry key="FilterDiffCoefficientOutputMinimum_MP">필터 계수 곱 연산 출력 최솟값:</entry>
    <entry key="FilterDiffCoefficientOutputMaximum_MP">필터 계수 곱 연산 출력 최댓값:</entry>
    <entry key="FilterDiffSumDenAccumulator_MP">SumDen 누산기:</entry>
    <entry key="FilterDiffSumDenOutput_MP">SumDen 출력:</entry>
    <entry key="FilterDiffSumDenOutputMinimum_MP">SumDen 출력 최솟값:</entry>
    <entry key="FilterDiffSumDenOutputMaximum_MP">SumDen 출력 최댓값:</entry>
    <entry key="FilterDiffSumNumAccumulator_MP">SumNum 누산기:</entry>
    <entry key="FilterDiffSumNumOutput_MP">SumNum 출력:</entry>
    <entry key="FilterDiffSumNumOutputMinimum_MP">SumNum 출력 최솟값:</entry>
    <entry key="FilterDiffSumNumOutputMaximum_MP">SumNum 출력 최댓값:</entry>
    <entry key="FilterDiffReciprocalOutput_MP">역수 출력:</entry>
    <entry key="FilterDiffReciprocalOutputMinimum_MP">역수 출력 최솟값:</entry>
    <entry key="FilterDiffReciprocalOutputMaximum_MP">역수 출력 최댓값:</entry>
    <entry key="FilterDiffDivideOutput_MP">나누기 출력:</entry>
    <entry key="FilterDiffDivideOutputMinimum_MP">나누기 출력 최솟값:</entry>
    <entry key="ClampingAlgorithmConstantZero_MP">고정 알고리즘 상수 0(Clamping_zero) 출력:</entry>
    <entry key="FilterCoeffDenConstant_MP">필터 계수 분모 상수(Filter Den Constant) 출력:</entry>
    <entry key="PCopyConstant_MP">P 파라미터 상수(Pcopy) 출력:</entry>
    <entry key="NCopyConstant_MP">N 파라미터 상수(Ncopy) 출력:</entry>
    <entry key="PIDAutoTuningMethodSelect_MP">조정 방법 선택:</entry>
    <entry key="IntFiltMethods_GT">적분기 및 필터 방법:</entry>
    <entry key="Initialization_TAB">초기화</entry>
    <entry key="IntegratorFilterInitialConditions_GT">적분기 및 필터 초기 조건</entry>
    <entry key="AutomatedTuning_GT">자동 조정</entry>
    <entry key="FixedPointToolBtn">고정소수점 툴 열기...</entry>
    <entry key="AdditionalDataTypes_GT">추가 데이터형</entry>
    <entry key="FixedPointOperationalParameters_GT">고정소수점 연산 파라미터</entry>
    <entry key="StateAttributesEmptyTab_GT">현재 구성에서는 PID Controller에 상태가 없습니다.</entry>
    <entry key="InitializationEmptyTab_GT">현재 구성에서는 PID Controller에 초기화할 상태가 없습니다.</entry>
    <entry key="UdiffTsProdOut_MP">U_differentiator * Ts 곱 연산 출력:</entry>
    <entry key="NTsProdOut_MP">N * Ts 곱 연산 출력:</entry>
    <entry key="UintegralTsProdOut_MP">U_integral * Ts 곱 연산 출력:</entry>
    <entry key="UngainTsProdOut_MP">U_Ngain * Ts 곱 연산 출력:</entry>
    <entry key="UseITs_MP">I*Ts 사용(codegen에 최적임)</entry>
    <entry key="IntegralITs_MP">적분(I*T):</entry>
    <entry key="IntegratorSaturation_GT">적분기 포화</entry>
    <entry key="ICSaturationCheck_ErrMsg">적분기 및 필터에 대한 초기 조건은 포화 한도 내에 있어야 합니다.</entry>
    <entry key="UseExternalDerivative_MP">외부에서 가져온 도함수 사용</entry>
    <entry key="CoulombFrictionValueOffset_MP">쿨롱 마찰 값(오프셋):</entry>
    <entry key="CoefficientOfViscousFrictionGain_MP">점성 마찰 계수(이득):</entry>
    <entry key="CoulombicAndViscousFriction_MD">0에서의 불연속 오프셋을 사용해 쿨롱 마찰을 모델링합니다. 선형 이득을 사용해 점성 마찰을 모델링합니다.\ny = sign(x) * (이득 * abs(x) + 오프셋)</entry>
    <entry key="DeadZoneDynamic_MD">불감대 내에서는 입력에 대해 0을 출력합니다. 불감대를 벗어난 경우에는 시작 값 또는 끝 값으로 입력 신호를 오프셋합니다.</entry>
    <entry key="RateLimiterDynamic_MD">첫 번째 입력(상한)과 세 번째 입력(하한)을 사용하여 두 번째 입력에서 신호의 상승 레이트 및 하강 레이트를 제한합니다.</entry>
    <entry key="OutputMinimum_MP">출력 최솟값:</entry>
    <entry key="OutputMaximum_MP">출력 최댓값:</entry>
    <entry key="OutputDataType_MP">출력 데이터형:</entry>
    <entry key="OutputDataTypeMode_MP">출력 데이터형 모드:</entry>
    <entry key="OutputDataTypeegFixdt116Fixdtsingle_MP">출력 데이터형(예: fixdt(1, 16), fixdt(''single'')):</entry>
    <entry key="OutputScalingSlopeEg29OrSlopeBias_MP">출력 스케일링(기울기 또는 [기울기 편향]. 예: 2^-9 또는 [1.25 3]):</entry>
    <entry key="InputDatatype_MP">입력 데이터형:</entry>
    <entry key="SaturationDynamic_MD">첫 번째 입력(상한)과 세 번째 입력(하한)을 사용하여 두 번째 입력의 입력 범위 경계를 지정합니다.</entry>
    <entry key="Threshold_MP">임계값:</entry>
    <entry key="WrapToZero_MD">입력이 임계값보다 높으면 출력이 0입니다. 그렇지 않으면 출력이 입력과 같습니다.</entry>
    <entry key="InitialConditionForPreviousInput_MP">이전 입력의 초기 조건:</entry>
    <entry key="Difference_MD">현재 입력값에서 이전 입력값을 뺀 값을 출력합니다.</entry>
    <entry key="GainValue_MP">이득 값:</entry>
    <entry key="InitialConditionForPreviousWeightedInputKuTs_MP">이전 가중 입력 K*u/Ts의 초기 조건:</entry>
    <entry key="DiscreteDerivative_MD">입력의 이산시간 미분.\n\n이 블록은 고정된 샘플 레이트로만 동작합니다. 비주기적 트리거가 있는 서브시스템에서 이 블록을 사용하지 마십시오.</entry>
    <entry key="FirstOrderHold_MD">일차 유지.</entry>
    <entry key="NumberOfDelays_MP">지연 개수:</entry>
    <entry key="InputProcessing_MP">입력 처리:</entry>
    <entry key="IntegerDelay_MD">신호를 N개 샘플 주기만큼 지연시킵니다.</entry>
    <entry key="OrderOutputVectorStartingWith_MP">출력 벡터에서의 시작 순서 지정:</entry>
    <entry key="IncludeCurrentInputInOutputVector_MP">출력 벡터에 현재 입력 포함</entry>
    <entry key="TappedDelayLine_MD">신호를 N개 샘플 주기만큼 지연시키고 모든 지연 버전을 출력합니다.</entry>
    <entry key="PoleinZPlane_MP">극점(Z 평면):</entry>
    <entry key="InitialConditionForPreviousOutput_MP">이전 출력의 초기 조건:</entry>
    <entry key="FirstOrderTransferFcn_MD">이산시간 1차 전달 함수. 이 전달 함수는 단위 DC 이득을 갖습니다.</entry>
    <entry key="PoleOfCompensatorinZPlane_MP">보상기의 극점(Z 평면):</entry>
    <entry key="ZeroOfCompensatorinZPlane_MP">보상기의 영점(Z 평면):</entry>
    <entry key="LeadOrLagCompensator_MD">이산시간 진상 또는 지상 보상기. 이 보상기는 단위 순시 이득을 가지며 DC 이득은 (1-영점)/(1-극점)과 같습니다.\n\n0 &lt; 극점 &lt; 영점 &lt; 1인 경우 진상 보상이 얻어집니다.\n0 &lt; 영점 &lt; 극점 &lt; 1인 경우 지상 보상이 얻어집니다.</entry>
    <entry key="ZeroinZPlane_MP">영점(Z 평면):</entry>
    <entry key="TransferFcnRealZero_MD">실수 영점을 가지며 (사실상) 극점이 없는 이산시간 전달 함수.</entry>
    <entry key="IndexOfBit0IsLeastSignificant_MP">비트 인덱스(0이 최하위 비트임):</entry>
    <entry key="BitClear_MD">저장된 정수의 i번째 비트를 0으로 지웁니다. 스케일링은 무시됩니다.</entry>
    <entry key="BitSet_MD">저장된 정수의 i번째 비트를 1로 설정합니다. 스케일링은 무시됩니다.</entry>
    <entry key="Operator_MP">연산자:</entry>
    <entry key="UseBitMask_MP">비트 마스크 사용...</entry>
    <entry key="NumberOfInputPorts_MP">입력 포트 개수:</entry>
    <entry key="BitMask_MP">비트 마스크</entry>
    <entry key="TreatMaskAs_MP">마스크를 다음으로 취급:</entry>
    <entry key="BitwiseOperator_MD">입력에 대해 지정된 비트별 연산을 수행합니다. 출력 데이터형은 정확히 0을 나타내야 합니다.</entry>
    <entry key="ConstantValue_MP">상수 값:</entry>
    <entry key="CompareToConstant_MD">신호가 상수와 어떻게 비교되는지를 결정합니다.</entry>
    <entry key="CompareToZero_MD">신호가 0과 어떻게 비교되는지를 결정합니다.</entry>
    <entry key="DetectChange_MD">입력이 이전 값과 같지 않은 경우 TRUE를 출력합니다. 그렇지 않으면 FALSE를 출력합니다. 초기 조건에 따라 이전 입력 U/z의 초기값이 결정됩니다.</entry>
    <entry key="DetectDecrease_MD">입력이 이전 값보다 작은 경우 TRUE를 출력합니다. 그렇지 않으면 FALSE를 출력합니다. 초기 조건에 따라 이전 입력 U/z의 초기값이 결정됩니다.</entry>
    <entry key="DetectIncrease_MD">입력이 이전 값보다 큰 경우 TRUE를 출력합니다. 그렇지 않으면 FALSE를 출력합니다. 초기 조건에 따라 이전 입력 U/z의 초기값이 결정됩니다.</entry>
    <entry key="DetectFallNegative_MD">입력이 음수이고 이전 값은 음수가 아닌 경우 TRUE를 출력합니다. 그렇지 않으면 FALSE를 출력합니다. 초기 조건에 따라 부울 표현식(U/z &lt; 0)의 초기값이 결정됩니다.</entry>
    <entry key="DetectFallNonpositive_MD">입력이 양수가 아니고 이전 값은 양수인 경우 TRUE를 출력합니다. 그렇지 않으면 FALSE를 출력합니다. 초기 조건에 따라 부울 표현식(U/z &lt;= 0)의 초기값이 결정됩니다.</entry>
    <entry key="DetectRiseNonnegative_MD">입력이 음수가 아니고 이전 값은 음수인 경우 TRUE를 출력합니다. 그렇지 않으면 FALSE를 출력합니다. 초기 조건에 따라 부울 표현식(U/z &gt;= 0)의 초기값이 결정됩니다.</entry>
    <entry key="DetectRisePositive_MD">입력이 양수이고 이전 값은 양수가 아닌 경우 TRUE를 출력합니다. 그렇지 않으면 FALSE를 출력합니다. 초기 조건에 따라 부울 표현식(U/z &gt; 0)의 초기값이 결정됩니다.</entry>
    <entry key="BitsToExtract_MP">추출할 비트 수:</entry>
    <entry key="NumberOfBits_MP">비트 수:</entry>
    <entry key="BitIndicesstartEnd0basedRelativeToLSB_MP">비트 인덱스([start end], LSB를 기준으로 0부터 시작):</entry>
    <entry key="OutputScalingMode_MP">출력 스케일링 모드:</entry>
    <entry key="ExtractBits_MD">입력 신호에서 선택한 연속 비트를 출력합니다. 출력할 비트를 선택하려면 "추출할 비트 수" 파라미터를 사용하십시오.</entry>
    <entry key="IntervalClosedOnRight_MP">오른쪽이 닫힌 구간</entry>
    <entry key="UpperLimit_MP">상한:</entry>
    <entry key="IntervalClosedOnLeft_MP">왼쪽이 닫힌 구간</entry>
    <entry key="LowerLimit_MP">하한:</entry>
    <entry key="IntervalTest_MD">입력이 하한과 상한 사이에 있는 경우 출력은 TRUE입니다. 그렇지 않으면 출력은 FALSE입니다.</entry>
    <entry key="IntervalTestDynamic_MD">입력이 하한과 상한 사이에 있는 경우 출력은 TRUE입니다. 그렇지 않으면 출력은 FALSE입니다.</entry>
    <entry key="OutputFormula_MP">출력 공식</entry>
    <entry key="NumberOfDataPointsForLookupTable_MP">룩업 테이블의 데이터 점 개수:</entry>
    <entry key="OutputWordLength_MP">출력 워드 길이:</entry>
    <entry key="InternalRulePriorityForLookupTable_MP">룩업 테이블의 내부 규칙 우선 순위:</entry>
    <entry key="SineAndCosine_MD">사분파 대칭성을 활용하는 룩업 테이블 방식을 사용하여 고정소수점으로 사인 함수 및 코사인 함수를 구현합니다. 출력 소수부 길이는 출력 워드 길이에서 2를 뺀 값과 같습니다.\n\n데이터 점 개수가 (2^n)+1인 경우(n은 정수) 가장 효율적인 구현을 얻습니다.</entry>
    <entry key="LookupMethod_MP">룩업 방법:</entry>
    <entry key="LookupTableDynamic_MD">선택한 룩업 방법을 사용하여 1차원 함수를 근사화합니다.</entry>
    <entry key="MatLibTranspose_MD">M×N 행렬의 전치를 계산합니다.</entry>
    <entry key="MatLibHermitian_MD">M×N 행렬의 에르미트 전치를 계산합니다.</entry>
    <entry key="MatLibMatrixSquare_MD">행렬 제곱 A' * A를 계산합니다. 복소수 입력값의 경우 에르미트 전치가 수행됩니다. [M×1] 및 [1×N] 입력 행렬을 사용하여 외적과 내적을 각각 효율적으로 계산할 수 있습니다.</entry>
    <entry key="MatLibCrossProduct_MD">2개 3×1 벡터의 외적 \na=[a1 a2 a3], b=[b1 b2 b3].\ny = a x b = (a2b3 - a3b2)i + (a3b1 - a1b3)j + (a1b2 - a2b1)k</entry>
    <entry key="InitialGuess_MP">초기 추측값:</entry>
    <entry key="AlgebraicConstraint_MD">입력 신호 f(z)를 0으로 제약하고 대수 상태 z를 출력합니다. 이 블록은 입력에서 0을 생성하는 데 필요한 값을 출력합니다. 출력은 피드백 경로를 통해 입력에 영향을 미쳐야 합니다. 대수 루프 솔버의 효율성을 향상시키려면 출력에 대한 초기 추측값을 제공하십시오.</entry>
    <entry key="Function_MP">함수:</entry>
    <entry key="MinMaxRunningResettable_MD">모든 과거 입력 u의 최댓값 또는 최솟값을 출력합니다. 재설정 입력 신호 R이 TRUE인 경우 출력은 초기 조건으로 재설정됩니다. 이 재설정 동작은 벡터화되었으며 스칼라 확장을 지원합니다.</entry>
    <entry key="Low_MP">낮음</entry>
    <entry key="Gain_MP">이득</entry>
    <entry key="High_MP">높음</entry>
    <entry key="MaximumGradient_MP">최대 기울기:</entry>
    <entry key="EnableAssertion_MP">어설션 활성화</entry>
    <entry key="SimulationCallbackWhenAssertionFails_MP">어설션 실패 시 시뮬레이션 콜백(선택 사항):</entry>
    <entry key="StopSimulationWhenAssertionFails_MP">어설션 실패 시 시뮬레이션 중지</entry>
    <entry key="OutputAssertionSignal_MP">출력 어설션 신호</entry>
    <entry key="SelectIconType_MP">아이콘 유형 선택:</entry>
    <entry key="Checks_Gradient_MD">이산 신호의 연속된 샘플 간 차이의 절댓값이 상한보다 작음을 어설션합니다.</entry>
    <entry key="Checks_DGap_MD">입력 신호 ''u''는 항상 하한 ''min''보다 작거나 상한 ''max''보다 큼을 어설션합니다. 첫 번째 입력은 간격의 상한이고 두 번째 입력은 하한이며 세 번째 입력은 테스트 신호입니다.</entry>
    <entry key="Checks_DRange_MD">하나의 신호는 항상 두 개의 다른 신호 사이에 존재함을 어설션합니다. 첫 번째 입력은 상한 신호이고 두 번째 입력은 하한 신호이며 세 번째 입력은 테스트 신호입니다.</entry>
    <entry key="UpperBound_MP">상한:</entry>
    <entry key="InclusiveUpperBound_MP">상한 포함</entry>
    <entry key="LowerBound_MP">하한:</entry>
    <entry key="InclusiveLowerBound_MP">하한 포함</entry>
    <entry key="Checks_SGap_MD">입력 신호가 정적 하한보다 작거나(또는 선택적으로 같음) 정적 상한보다 큼을(또는 선택적으로 같음) 어설션합니다.</entry>
    <entry key="Checks_SRange_MD">입력 신호가 정적 하한과 정적 상한 사이에 존재하거나 선택적으로 두 경계 중 하나와 같음을 어설션합니다. </entry>
    <entry key="Checks_DMin_MD">한 신호는 항상 다른 신호보다 작음을 어설션합니다. 첫 번째 입력은 하한 신호입니다. 두 번째 입력은 테스트 신호입니다.</entry>
    <entry key="Checks_DMax_MD">한 신호는 항상 다른 신호보다 큼을 어설션합니다. 첫 번째 입력은 상한 신호입니다. 두 번째 입력은 테스트 신호입니다.</entry>
    <entry key="Resolution_MP">분해능:</entry>
    <entry key="Checks_Resolution_MD">입력 신호가 지정된 분해능을 가짐을 어설션합니다. 분해능이 스칼라인 경우 입력 신호는 10e-3 허용오차 내에서 분해능의 배수여야 합니다. 분해능이 벡터인 경우 입력 신호는 분해능 벡터의 요소와 같아야 합니다.</entry>
    <entry key="InclusiveBoundary_MP">경계 포함</entry>
    <entry key="Checks_SMin_MD">입력 신호가 정적 하한보다 큼(또는 선택적으로 같음)을 어설션합니다.</entry>
    <entry key="Checks_SMax_MD">입력 신호가 정적 상한보다 작음(또는 선택적으로 같음)을 어설션합니다.\n</entry>
    <entry key="BlockSupportTable_MD">블록을 더블 클릭하면 Simulink 블록 데이터형 지원 테이블이 실행됩니다.</entry>
    <entry key="DocBlockEmbeddedCoderFlagLabel_MP">코드 생성 템플릿 기호</entry>
    <entry key="DocBlockDocTypeLabel_MP">문서 유형</entry>
    <entry key="DocBlock_MD">모델과 함께 긴 설명 텍스트를 저장하려면 이 블록을 사용하십시오. 블록을 더블 클릭하면 편집기가 열립니다.</entry>
    <entry key="Frame_MP">프레임</entry>
    <entry key="CMBlock_MD">이 블록을 사용하면 수정본 제어 정보가 모델 내에 표시됩니다.</entry>
    <entry key="LinearizationTime_MP">선형화 시간:</entry>
    <entry key="SampleTimeofLinearizedModel_MP">샘플 시간(선형화 모델):</entry>
    <entry key="TimedLinearization_MD">특정 시간에 기본 작업 공간에 선형 모델을 생성합니다.\n</entry>
    <entry key="TriggerType_MP">트리거 유형:</entry>
    <entry key="TriggeredLinearization_MD">트리거 시 기본 작업 공간에 선형 모델을 생성합니다.</entry>
    <entry key="IOPortSubsystem_MD">Inport 블록 및 Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="EnabledSubsystem_MD">Enable Port, Inport 및 Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="ResettableSubsystem_MD">Reset Port, Inport 및 Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="EnabledAndTriggeredSubsystem_MD">Enable Port, State Control, Inport 및 Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="ForEachSubsystem_MD">For Each, Inport 및 Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="NeighborhoodProcessingSubsystem_MD">Neighborhood, Inport 및 Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="ArrayProcessing_MD">배열 처리, Inport 및 Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="PixelProcessing_MD">픽셀 처리, Inport 및 Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="InjectorSubsystem_MD">Injector Inport 블록 및 Injector Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="ForIteratorSubsystem_MD">For Iterator, Inport 및 Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="SynchronousSubsystem_MP">State Control, Inport 및 Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="EnabledSynchronousSubsystem_MP">Enable Port, State Control, Inport 및 Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="ResettableSynchronousSubsystem_MP">Reset Port, State Control, Inport 및 Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="NumberOfIterations_MP">반복 횟수:</entry>
    <entry key="Scalar_MP">폭이 넓은 출력 허용 안 함</entry>
    <entry key="ShowEnablePort_MP">인에이블 포트 표시</entry>
    <entry key="FunctionCallGenerator_MD">지정된 레이트로 이 블록에 연결된 함수 호출 서브시스템, 모델 또는 Stateflow 차트를 실행합니다. 미리 정해진 순서로 여러 함수 호출 블록을 실행하려면 Function-Call Split 블록과 함께 이 블록을 사용하십시오. \n\n''샘플 시간'' 파라미터는 이 블록이 블록에 연결된 각 함수 호출 블록을 실행하는 레이트를 지정합니다. 각 시간 스텝에서 이 블록에 연결된 각 함수 호출 블록을 여러 번 반복적으로 실행하려면 ''반복 횟수'' 파라미터를 사용하십시오. \n\n''인에이블 포트 표시'' 체크박스를 선택한 경우, 인에이블 포트에 대한 입력 신호가 양의 스칼라 값을 가질 때만 블록이 함수 호출 신호를 출력합니다.</entry>
    <entry key="FunctionCallSubsystem_MD">함수 호출 Trigger Port, Inport 및 Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="SimulinkFunction_MD">함수 호출 Trigger Port, 입력 및 출력 인수 블록을 포함하는 Simulink Function으로 구성된 Subsystem 블록 템플릿.</entry>
    <entry key="InitializeFunction_MD">'초기화' 이벤트로 설정된 Event-Listener 블록, Constant 블록, State Writer 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="ReinitializeFunction_MD">'이벤트 이름' 파라미터를 'reinit'로 설정한 상태에서 '재초기화' 이벤트로 설정된 Event Listener 블록, Constant 블록, State Writer 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="ResetFunction_MD">'이벤트 이름' 파라미터를 '재설정'으로 설정한 상태에서 '재설정' 이벤트로 설정된 Event Listener 블록, Constant 블록, State Writer 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="TerminateFunction_MD">'종료' 이벤트로 설정된 Event Listener 블록, State Reader 블록, Terminator 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="RunFirstSubsystem_MD">'처음' 모드로 설정된 Run Order Specifier 블록, Inport 블록, Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="RunLastSubsystem_MD">'마지막' 모드로 설정된 Run Order Specifier 블록, Inport 블록, Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="ActionSubsystem_MD">Action Port, Inport 및 Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="SubsystemExamples_MD">다양한 서브시스템 유형을 사용하는 방법에 대한 예제입니다.</entry>
    <entry key="TriggeredSubsystem_MD">Trigger Port, Inport 및 Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="MessageTriggeredSubsystem_MD">Trigger Port 및 Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="VariantSubsystem_MD">Variant 선택지로 Subsystem 블록을 포함하는 Variant Subsystem 템플릿.</entry>
    <entry key="VariantModel_MD">Variant 선택지로 Model 블록을 포함하는 Variant Subsystem 템플릿.</entry>
    <entry key="VariantAssemblySubsystem_MD">Variant Subsystem 템플릿이 Variant 어셈블리 모드에 있습니다.</entry>
    <entry key="WhileIteratorSubsystem_MD">While Iterator, Inport 및 Outport 블록을 포함하는 Subsystem 블록 템플릿.</entry>
    <entry key="InputAndOutputToHaveEqual_MP">입력과 출력이 같아야 함:</entry>
    <entry key="ConversionInherited_MD">두 번째 입력을 첫 번째 입력의 데이터형과 스케일링으로 변환합니다. \n\n이 변환에는 다음과 같은 두 가지 가능한 목표가 있습니다. 첫 번째 목표는 입력 및 출력의 실제 값을 동일하게 하는 것입니다. 두 번째 목표는 입력 및 출력의 저장된 정수 값을 동일하게 하는 것입니다. 오버플로 및 양자화 오차가 발생할 경우 목표를 완전히 달성하지 못할 수 있습니다.</entry>
    <entry key="x1PropagatedDataType_MP">1. 전파되는 데이터형:</entry>
    <entry key="x11PropagatedDataTypeegFixdt116Fixdtsingle_MP">1.1. 전파되는 데이터형(예: fixdt(1, 16), fixdt(''single'')):</entry>
    <entry key="x11IfAnyReferenceInputIsDoubleOutputIs_MP">1.1. 기준 입력이 double형인 경우 출력은 다음과 같음:</entry>
    <entry key="x12IfAnyReferenceInputIsSingleOutputIs_MP">1.2. 기준 입력이 single형인 경우 출력은 다음과 같음:</entry>
    <entry key="x13IsSigned_MP">1.3. 부호 있음:</entry>
    <entry key="x141NumberofBitsBase_MP">1.4.1. 비트 수: 기준</entry>
    <entry key="x142NumberofBitsMultiplicativeAdjustment_MP">1.4.2. 비트 수: 승산식 조정</entry>
    <entry key="x143NumberofBitsAdditiveAdjustment_MP">1.4.3. 비트 수: 가산식 조정</entry>
    <entry key="x144NumberofBitsAllowableFinalValues_MP">1.4.4. 비트 수: 허용 가능한 최종 값</entry>
    <entry key="x2PropagatedScaling_MP">2. 전파되는 스케일링:</entry>
    <entry key="x21PropagatedScalingSlopeEg29OrSlopeBiasEg1253_MP">2.1. 전파되는 스케일링(기울기 또는 [기울기 편향]. 예: 2^-9 또는 [1.25 3]):</entry>
    <entry key="x21ValuesUsedToDetermineBestPrecisionScaling_MP">2.1. 최적 정밀도 스케일링을 결정하는 데 사용되는 값.</entry>
    <entry key="x211SlopeBase_MP">2.1.1. 기울기: 기준</entry>
    <entry key="x212SlopeMultiplicativeAdjustment_MP">2.1.2. 기울기: 승산식 조정</entry>
    <entry key="x213SlopeAdditiveAdjustment_MP">2.1.3. 기울기: 가산식 조정</entry>
    <entry key="x221BiasBase_MP">2.2.1. 편향: 기준</entry>
    <entry key="x222BiasMultiplicativeAdjustment_MP">2.2.2. 편향: 승산식 조정:</entry>
    <entry key="x223BiasAdditiveAdjustment_MP">2.2.3. 편향: 가산식 조정:</entry>
    <entry key="DataTypePropagation_MD">전파되는 신호의 데이터형과 스케일링을 기준 신호의 정보를 바탕으로 설정합니다.\n참고:\n1) 대화 상자에서 상단에 있는 항목일수록 우선 순위가 더 높습니다.\na) double형의 기준 입력이 다른 모든 기준 입력보다 우선 순위가 더 높습니다.\nb) single형이 정수 및 고정소수점 데이터형보다 우선 순위가 더 높습니다.\nc) 승산식 조정이 가산식 조정보다 먼저 수행됩니다.\nd) 기준 신호에서 정밀도 또는 양수 범위를 상속하기 전에 비트 수를 결정합니다.\n2) PosRange는 신호의 정확한 최대 양수 범위보다 1비트 높습니다.\n3) 계산된 비트 수는 계산된 값보다 크거나 같은 허용 가능한 가장 작은 값으로 승격됩니다. 그러한 비트 수가 존재하지 않는 경우 블록에서 오류를 반환합니다.</entry>
    <entry key="DataTypePropagationExamples_MD">데이터형 전파 예제를 포함하는 모델을 엽니다.</entry>
    <entry key="ScalingStrip_MD">이 블록은 고정소수점 신호의 스케일링을 제거합니다. 이 블록은 입력을 유지하기에 충분한 비트를 가진 가장 작은 내장 데이터형으로 입력 데이터형을 매핑합니다. 입력의 저장된 정수 값이 출력값이 됩니다. 출력은 항상 공칭 스케일링을 가지므로(기울기 = 1.0 및 편향 = 0.0), 출력에서 실제 값과 저장된 정수 값 간에 차이가 없습니다.</entry>
    <entry key="EnvironmentController_MD">현재 환경에 따라 시뮬레이션(Sim) 또는 코드 생성(Coder) 포트를 출력합니다. 최적화가 활성화된 상태에서, 미사용 포트로 연결되는 불필요한 블록은 실행되지 않습니다. 두 입력 신호 모두 너비가 같아야 합니다.</entry>
    <entry key="xmin_MP">X-min:</entry>
    <entry key="xmax_MP">X-max:</entry>
    <entry key="ymin_MP">Y-min:</entry>
    <entry key="ymax_MP">Y-max:</entry>
    <entry key="XYScope_MD">X-Y 플롯을 생성하기 위해 각 시간 스텝마다 첫 번째 입력(X)에 대해 두 번째 입력(Y)을 플로팅합니다. x-min, x-max, y-min, y-max로 지정된 범위를 벗어난 데이터는 무시합니다.</entry>
    <entry key="NoisePower_MP">잡음 전력:</entry>
    <entry key="Seed_MP">시드값:</entry>
    <entry key="InterpretVectorParametersAs1D_MP">벡터 파라미터를 1차원으로 해석</entry>
    <entry key="BandLimitedWhiteNoise_MD">Band-Limited White Noise 블록은 연속 시스템 또는 하이브리드 시스템에서 사용하기에 적합한 정규분포된 난수를 생성합니다.</entry>
    <entry key="InitialFrequencyHz_MP">초기 주파수(Hz):</entry>
    <entry key="TargetTimesecs_MP">목표 시간(초):</entry>
    <entry key="FrequencyAtTargetTimeHz_MP">목표 시간에서의 주파수(Hz):</entry>
    <entry key="chirp_MD">선형 처프 신호를 출력합니다(주파수가 시간에 따라 선형으로 변하는 사인파).</entry>
    <entry key="CounterFreeRunning_MD">이 블록은 지정된 비트 수에 가능한 최댓값에 도달한 후 0으로 다시 오버플로되는 자유 실행(free-running) 카운터입니다. 이 카운터는 항상 0으로 초기화됩니다. 출력은 일반적으로 지정된 비트 수를 가진 부호 없는 정수입니다.</entry>
    <entry key="CounterLimited_MD">이 블록은 지정된 상한 값을 출력한 후 0으로 다시 래핑되는 카운터입니다. 이 카운터는 항상 0으로 초기화됩니다. 출력은 일반적으로 8비트, 16비트 또는 32비트의 부호 없는 정수입니다. 상한 값을 표현하는 데 필요한 최소 비트 수가 사용됩니다.</entry>
    <entry key="Value_MP">값:</entry>
    <entry key="Slope_MP">기울기:</entry>
    <entry key="StartTime_MP">시작 시간:</entry>
    <entry key="InitialOutput_MP">초기 출력:</entry>
    <entry key="Ramp_MD">지정된 시간에 시작하는 램프 신호를 출력합니다.</entry>
    <entry key="SliderGain_MD">슬라이더를 움직여 스칼라 이득을 수정합니다.</entry>
    <entry key="TimeValues_MP">시간 값:</entry>
    <entry key="OutputValues_MP">출력값:</entry>
    <entry key="RepeatingTable_MD">시간-값 쌍으로 구성된 테이블에 지정된 일련의 숫자를 반복적으로 출력합니다. 시간 값은 단조 증가해야 합니다.</entry>
    <entry key="VectorOfOutputValues_MP">출력값으로 구성된 벡터:</entry>
    <entry key="VectorOfTimeValues_MP">시간 값으로 구성된 벡터:</entry>
    <entry key="RepeatingSequenceInterpolated_MD">이산시간 시퀀스가 출력된 후 반복됩니다. 데이터 점 사이의 출력값은 지정된 룩업 방법에 의해 결정됩니다.</entry>
    <entry key="RepeatingSequenceStair_MD">이산시간 시퀀스가 출력된 후 반복됩니다.</entry>
    <entry key="SigbuilderBlock_MD">파형이 조각별 선형인 신호로 구성된 상호 교환 가능 그룹을 생성합니다.\n\nSignal Builder 블록은 권장되지 않습니다. 대신 Signal Editor 블록을 사용하십시오.</entry>
    <entry key="Stateflow_MD">Embedded MATLAB 블록</entry>
    <entry key="SFunctionBuilder_MD">S-Function Builder 블록은 여러 입력 포트, 출력 포트, 가변 개수의 스칼라, 벡터 또는 행렬 파라미터를 통해 제공된 C 코드에서 래퍼 C-MEX S-function을 생성합니다. 입력 포트 및 출력 포트는 Simulink 내장 데이터형, 고정소수점 데이터형, 복소, 1차원, 2차원 신호를 전파할 수 있습니다. 이 블록은 또한 실수형 이산 및 연속 상태를 지원합니다. 선택적으로, 코드 생성에 사용되는 TLC 파일을 이 블록이 생성하도록 할 수 있습니다.</entry>
    <entry key="SFunctionExamples_MD">다양한 S-Function 유형을 사용하는 방법에 대한 예제입니다.</entry>
    <entry key="LookupTableBreakpoints_MP">룩업 테이블 절점</entry>
    <entry key="AllowedSpacingpow2evenOrunrestricteddefault_MP">허용 간격 'pow2','even' 또는 'unrestricted'(디폴트 값) </entry>
    <entry key="MaximumNumberOfBreakpoints_MP">최대 절점 개수</entry>
    <entry key="MaximumWorstCaseApproximationError_MP">최악의 경우의 최대 근사오차</entry>
    <entry key="RoundingMethodfloordefaultceilnearOrzero_MP">반올림 방법 'floor'(디폴트 값),'ceil','near' 또는 'zero'</entry>
    <entry key="OutputScaling_MP">출력 스케일링</entry>
    <entry key="InputScaling_MP">입력 스케일링</entry>
    <entry key="MaximumInputValueOfInterest_MP">최대 관심 입력 값</entry>
    <entry key="MinimumInputValueOfInterest_MP">최소 관심 입력 값</entry>
    <entry key="MEGMAFixedPointCosine_MD">MEGMA 코사인</entry>
    <entry key="MEGMAFixedPointExponent_MD">MEGMA 지수</entry>
    <entry key="MEGMAFixedPointSine_MD">MEGMA 사인</entry>
    <entry key="MEGMAFixedPointSqrt_MD">MEGMA 제곱근</entry>
    <entry key="MEGMAFixedPointTangent_MD">MEGMA 탄젠트</entry>
    <entry key="ComputeAlways">항상 계산</entry>
    <entry key="CacheForASpecificMATLABSession">특정 MATLAB 세션의 캐시</entry>
    <entry key="CacheAcrossDifferentMATLABSessions">서로 다른 MATLAB 세션 전체의 캐시</entry>
    <entry key="Main">기본</entry>
    <entry key="SignalAttributes">신호 특성</entry>
    <entry key="Propagatedtype">전파되는 유형</entry>
    <entry key="Propagatedscaling">전파되는 스케일링</entry>
    <entry key="MultiplyAdd_MD">처음 두 개의 입력값을 곱하고, 그 결과를 세 번째 입력값에 더하거나 세 번째 입력값에서 뺍니다. 함수 옵션에 따라 연산 모드가 정의됩니다. 이 블록은 FPGA의 DSP 슬라이스에 효율적인 매핑을 수행하도록 설계되었습니다.</entry>
    <entry key="BitConcat_MD">입력 워드를 결합합니다. 스칼라 입력값의 경우 두 개 이상의 입력 신호를 블록에 연결해야 합니다. 벡터 입력값의 경우 한 개 이상의 입력값을 블록에 연결해야 합니다. 출력값에 표시되는 워드의 좌우 순서는 입력 신호의 순서를 따릅니다. L 입력값은 순서가 가장 낮은 워드이고, H 입력값은 순서가 가장 높은 워드입니다.</entry>
    <entry key="BitSlice_MD">입력 신호에서 연속 비트 필드를 반환합니다. 필드는 LSB 위치 및 MSB 위치를 기준으로 인덱싱됩니다(LSB를 기준으로 0부터 시작).</entry>
    <entry key="BitReduce_MD">축소 모드 파라미터로 지정된 대로, 입력 신호에 대해 비트별 AND, OR 또는 XOR 축소를 수행합니다.</entry>
    <entry key="BitRotate_MD">Rotate Mode 파라미터로 지정된 대로, 입력 신호를 왼쪽 또는 오른쪽으로 회전합니다. Rotate Length에 따라 회전할 비트 수가 지정됩니다.</entry>
    <entry key="BitShift_MD">Shift Mode 파라미터로 지정된 대로, 입력 신호에 논리 시프트 또는 산술 시프트를 수행합니다. Shift Length에 따라 시프트하는 비트 수가 지정됩니다.</entry>
    <entry key="WordToBits_MD">입력값을 N개의 1비트 값으로 구성된 벡터로 변환합니다. 여기서 N은 최대 워드 길이 마스크 파라미터로 지정됩니다.</entry>
    <entry key="BitsToWord_MD">N개의 1비트 값으로 구성된 입력 벡터를 N비트 정수로 변환합니다.</entry>
    <entry key="HDLCounter_MD">HDL 코드 생성을 위한 카운터.</entry>
    <entry key="TappedDelayEnabledSynchronous_MD">일반적으로 여러 샘플 주기만큼 스칼라 신호를 지연한 다음, 지연된 모든 버전을 출력합니다. \n활성화 신호가 false인 경우 블록이 비활성화되며 상태 및 출력값이 변경되지 않습니다.</entry>
    <entry key="UnitDelayEnabledSynchronous_MD">일반적으로 출력은 하나의 샘플 주기만큼 지연된 신호 u입니다.\n활성화 신호가 false인 경우 블록이 비활성화되며 상태 및 출력값이 변경되지 않습니다. 활성화 동작은 스칼라 입력값만 지원합니다. 신호 u가 벡터인 경우 활성화 동작에 스칼라 확장이 사용됩니다.</entry>
    <entry key="UnitDelayResettableSynchronous_MD">일반적으로 출력은 하나의 샘플 주기만큼 지연된 신호 u입니다.\n재설정 신호 R이 true인 경우 상태 및 출력은 항상 초기 조건 파라미터와 같게 설정됩니다. 이 블록은 하드웨어 친화적인 재설정 동작을 수행합니다. 이 재설정 동작은 스칼라 입력값만 지원합니다. 신호 u가 벡터인 경우 이 재설정 동작에 스칼라 확장이 사용됩니다.</entry>
    <entry key="UnitDelayEnabledResettableSynchronous_MD">일반적으로 출력은 하나의 샘플 주기만큼 지연된 신호 u입니다.\n활성화 신호가 false인 경우 블록이 비활성화되며 상태 및 출력값이 변경되지 않습니다. 활성화 동작은 스칼라 입력값만 지원합니다. 신호 u가 벡터인 경우 활성화 동작에 스칼라 확장이 사용됩니다.\n재설정 신호 R이 true인 경우 상태 및 출력값은 항상 초기 조건 파라미터와 같게 설정됩니다. 이 블록은 하드웨어 친화적인 재설정 동작을 수행합니다. 이 재설정 동작은 스칼라 입력값만 지원합니다. 신호 u가 벡터인 경우 이 재설정 동작에 스칼라 확장이 사용됩니다.</entry>
    <entry key="TappedDelayResettableSynchronous_MD"> 일반적으로 여러 샘플 주기만큼 스칼라 신호를 지연한 다음, 지연된 모든 버전을 출력합니다.\n재설정 신호 R이 true인 경우 상태 및 출력값은 항상 초기 조건 파라미터와 같게 설정됩니다. 이 블록은 하드웨어 친화적인 재설정 동작을 수행합니다.</entry>
    <entry key="TappedDelayEnabledResettableSynchronous_MD">일반적으로 여러 샘플 주기만큼 스칼라 신호를 지연한 다음, 지연된 모든 버전을 출력합니다.\n활성화 신호가 false인 경우 블록이 비활성화되고 상태 및 출력값이 변경되지 않습니다.\n재설정 신호 R이 true인 경우 상태 및 출력값은 항상 초기 조건 파라미터와 같게 설정됩니다. 이 블록은 하드웨어 친화적인 재설정 동작을 수행합니다.</entry>
    <entry key="DualPortRAM_MD">이 블록은 두 개의 데이터 출력 포트를 갖는 이중 포트 RAM을 시뮬레이션합니다.</entry>
    <entry key="SimpleDualPortRAM_MD">이 블록은 한 개의 데이터 출력 포트를 갖는 단순 이중 포트 RAM을 시뮬레이션합니다.</entry>
    <entry key="SinglePortRAM_MD">이 블록은 단일 포트 RAM을 시뮬레이션합니다.</entry>
    <entry key="DualRateDualPortRAM_MD">이 블록은 두 개의 데이터 출력 포트를 갖는, 이중 클록의 이중 포트 RAM을 시뮬레이션합니다.</entry>
    <entry key="HDLFIFO_MD">동기식 FIFO("First In,First Out") 레지스터를 구현합니다.</entry>
    <entry key="MultiplyAccumulate_MD">연산 모드: 벡터\n dataOut= sum(a.*b) + c \n\n연산 모드: 스트리밍 - Start 및 End 포트 사용 \ndataOut(t+1)= dataOut(t) + sum(a(t)*b(t)) + c \n이때 시작 시 valid=high이면 c=bias\n그 외의 경우에는 c=0 \n\n연산 모드: 스트리밍 - 샘플 수 사용 \ndataOut(t+1)= dataOut(t) + sum(a(t)*b(t)) + c \n이때 t=0이면 c=bias \n그 외의 경우에는 c=0 \n\n이 블록은 FPGA의 DSP 슬라이스에 효율적인 매핑을 수행하도록 설계되었습니다.</entry>
    <entry key="Serializer1D_MD">벡터를 스칼라 또는 더 작은 크기의 벡터로 변환합니다. 출력 레이트는 V * (비율 + 유휴 주기)입니다. 여기서 V는 입력 레이트입니다.</entry>
    <entry key="Deserializer1D_MD">스칼라를 벡터로 변환하거나 더 작은 크기의 벡터를 더 큰 크기의 벡터로 변환합니다. 출력 레이트는 S / (비율 + 유휴 주기)입니다. 여기서 S는 입력 레이트입니다.</entry>
    <entry key="RotateMode_MP">회전 모드</entry>
    <entry key="BitRotateLength_MP">회전 길이(0보다 크거나 같아야 함)</entry>
    <entry key="ShiftMode_MP">이동 모드</entry>
    <entry key="BitShiftLength_MP">이동 길이(0보다 크거나 같아야 함)</entry>
    <entry key="CounterType_MP">카운터 유형:</entry>
    <entry key="InitialValue_MP">초기값:</entry>
    <entry key="StepValue_MP">간격 값:</entry>
    <entry key="CountToValue_MP">카운트 끝 값:</entry>
    <entry key="CountFrom_MP">카운트 시작:</entry>
    <entry key="CountFromValue_MP">카운트 시작 값:</entry>
    <entry key="LocalReset_MP">로컬 재설정 포트</entry>
    <entry key="LoadPorts_MP">불러오기 포트</entry>
    <entry key="CountEnable_MP">카운트 인에이블 포트</entry>
    <entry key="CountDirection_MP">카운트 방향 포트</entry>
    <entry key="CountHit_MP">카운트 적중 출력 포트</entry>
    <entry key="CountOutputData_MP">카운터 출력 데이터:</entry>
    <entry key="WordLength_MP">워드 길이:</entry>
    <entry key="FractionLength_MP">소수부 길이:</entry>
    <entry key="AddressPortWidth_MP">주소 포트 너비(2 ~ 29비트)</entry>
    <entry key="OutPutDataWrite_MP">쓰기 작업 중의 출력 데이터:</entry>
    <entry key="AddressPort_MP">주소 포트 너비(2 ~ 28비트)</entry>
    <entry key="RAMType_MP">RAM 유형 지정:</entry>
    <entry key="EnableAsyncRead_MP">비동기 읽기 활성화</entry>
    <entry key="SpecifyOutputDataWrite_MP">쓰기 작업에 대한 출력 데이터 지정:</entry>
    <entry key="RAMInitialVal_MP">RAM 초기값 지정:</entry>
    <entry key="RegisterSize_MP">레지스터 크기:</entry>
    <entry key="Mode_MP">모드:</entry>
    <entry key="OutputInputSampleRatio_MP">입력 샘플 시간에 대한 출력 샘플 시간의 비율:</entry>
    <entry key="PushReg_MP">꽉 찬 레지스터에 밀어넣기(push):</entry>
    <entry key="PopReg_MP">빈 레지스터에서 꺼내기(pop):</entry>
    <entry key="EmptyRegisterIndicator_MP">빈 레지스터 표시자 포트(Empty) 표시</entry>
    <entry key="FullRegisterIndicator_MP">꽉 찬 레지스터 표시자 포트(Full) 표시</entry>
    <entry key="RegisterEntries_MP">레지스터 항목 수 포트(Num) 표시</entry>
    <entry key="NumberInputs_MP">입력 개수</entry>
    <entry key="MSBPos_MP">MSB 위치</entry>
    <entry key="LSBPos_MP">LSB 위치</entry>
    <entry key="ReductionMode_MP">축소 모드</entry>
    <entry key="MaxWordLength_MP">최대 워드 길이</entry>
    <entry key="OutputBitOrder_MP">출력 비트 순서</entry>
    <entry key="OutputSignedness_MP">비트 패킹 후 결과 정수를 다음으로 처리</entry>
    <entry key="InputBitOrder_MP">입력 비트 순서</entry>
    <entry key="FMA_MP">부동소수점 FMA(단일 곱셈-누산)</entry>
    <entry key="OperationMode_MP">연산 모드:</entry>
    <entry key="InputOutputVectorRatio_MP">비율(입력 벡터 크기/출력 벡터 크기)</entry>
    <entry key="IdleCycles_MP">유휴 주기</entry>
    <entry key="ControlPorts_MP">제어 신호 포트</entry>
    <entry key="ValidIn_MP">ValidIn</entry>
    <entry key="ValidOut_MP">ValidOut</entry>
    <entry key="StartOut_MP">StartOut</entry>
    <entry key="InputDataPortDim_MP">입력 데이터 포트 차원(상속된 경우 -1) </entry>
    <entry key="InputSampleTime_MP">입력 샘플 시간(상속된 경우 -1)</entry>
    <entry key="InputSignal_MP">입력 신호 유형</entry>
    <entry key="StartIn_MP">StartIn</entry>
    <entry key="OutputInputVectorRatio_MP">비율(출력 벡터 크기/입력 벡터 크기)</entry>
    <entry key="Ceiling">올림(Ceiling)</entry>
    <entry key="Convergent">수렴(Convergent)</entry>
    <entry key="Floor">내림(Floor)</entry>
    <entry key="Nearest">최근접이웃</entry>
    <entry key="Round">반올림(Round)</entry>
    <entry key="Simplest">최대단순(Simplest)</entry>
    <entry key="Zero">0 방향(Zero)</entry>
    <entry key="ContinuousTime">연속시간</entry>
    <entry key="DiscreteTime">이산시간</entry>
    <entry key="ForwardEuler">순방향 오일러</entry>
    <entry key="BackwardEuler">역방향 오일러</entry>
    <entry key="Trapezoidal">사다리꼴</entry>
    <entry key="Ideal">이상적</entry>
    <entry key="Parallel">병렬</entry>
    <entry key="internal">내부</entry>
    <entry key="external">외부</entry>
    <entry key="none">없음</entry>
    <entry key="rising">상승</entry>
    <entry key="falling">하강</entry>
    <entry key="either">양쪽 모두 가능</entry>
    <entry key="level">수준</entry>
    <entry key="backCalculation">역계산</entry>
    <entry key="clamping">고정</entry>
    <entry key="Auto">자동</entry>
    <entry key="SpecifyViaDialog">대화 상자를 통해 지정</entry>
    <entry key="SameAsSecondInput">두 번째 입력과 동일</entry>
    <entry key="ColumnsAsChannelsFrameBased">열을 채널로(프레임 기반)</entry>
    <entry key="InheritViaInternalRule">내부 규칙을 통해 상속</entry>
    <entry key="InheritViaBackPropagation">역전파를 통해 상속</entry>
    <entry key="Oldest">가장 오래된 항목</entry>
    <entry key="Newest">가장 최근 항목</entry>
    <entry key="RealWorldValue">실제 값</entry>
    <entry key="StoredInteger">저장된 정수</entry>
    <entry key="UpperHalf">위쪽 절반</entry>
    <entry key="LowerHalf">아래쪽 절반</entry>
    <entry key="RangeStartingWithMostSignificantBit">최상위 비트로 시작하는 범위</entry>
    <entry key="RangeEndingWithLeastSignificantBit">최하위 비트로 끝나는 범위</entry>
    <entry key="RangeOfBits">비트 범위</entry>
    <entry key="PreserveFixedPointScaling">고정소수점 스케일링 유지</entry>
    <entry key="TreatBitFieldAsAnInteger">비트 필드를 정수로 취급</entry>
    <entry key="InterpolationExtrapolation">보간-외삽</entry>
    <entry key="InterpolationUseEndValues">보간-끝 값 사용</entry>
    <entry key="InternalRulePrioritySpeed">속도</entry>
    <entry key="InternalRulePriorityPrecision">정밀도</entry>
    <entry key="UseInputNearest">입력에서 가장 가까운 값 사용</entry>
    <entry key="UseInputBelow">입력 아랫값 사용</entry>
    <entry key="UseInputAbove">입력 윗값 사용</entry>
    <entry key="min">최솟값</entry>
    <entry key="max">최댓값</entry>
    <entry key="graphic">그래픽</entry>
    <entry key="text">텍스트</entry>
    <entry key="Text">텍스트</entry>
    <entry key="functionCall">함수 호출</entry>
    <entry key="InheritViaPropagationRule">전파 규칙을 통해 상속</entry>
    <entry key="IsSigned1OrIsSigned2">IsSigned1 또는 IsSigned2</entry>
    <entry key="ObtainViaBestPrecision">최적 정밀도를 통해 획득</entry>
    <entry key="UseSpecifiedScaling">지정된 스케일링 사용</entry>
    <entry key="BestPrecisionVectorWise">최적 정밀도: 벡터별</entry>
    <entry key="ElementsAsChannelsSampleBased">요소를 채널로(샘플 기반)</entry>
    <entry key="Inherited">상속됨</entry>
    <entry key="UsePIDTunerApp">전달 함수 기반(PID 조정기 앱)</entry>
    <entry key="UseOLSimulation">주파수 응답 기반</entry>
    <entry key="GenSFuncName_MP">생성된 S-function 이름(model_sf):</entry>
    <entry key="GenSFuncShowModuleList_MP">모듈 목록 표시</entry>
    <entry key="GenSFuncListOfModules_IC">\n모듈 목록:\n{0}</entry>
    <entry key="GenSFuncNotLicensed_IC">라이선스가 부여되지 않음\n</entry>
    <entry key="GenSFuncNone_IC">없음</entry>
    <entry key="GenSFuncDesc_MD">Simulink Coder로 생성된 S-Function.</entry>
    <entry key="CustCodeQuickHelp_ID">빠른 도움말</entry>
    <entry key="CustCodeMaskParam1_MP">마스크 파라미터 1:</entry>
    <entry key="SL_DSCPT_PWMGenerator">
        각 주기가 시작될 때 입력 신호 값을 듀티 사이클(D)로 사용해 이상적인 펄스 폭 변조(PWM) 신호를 출력합니다.\n\n출력 펄스는 다음과 같이 지정됩니다.\n\ny(t) = 1 (t(k) &lt;= t &lt; t(k) + pw(k))\n = 0 (t(k) + pw(k) &lt;= t &lt; t(k) + 주기)\n\n여기서 t(k)는 'k-1'개 펄스 이후의 시간이고 pw(k)는 t(k)에서의 입력 D(k)와 주기의 곱, 즉 pw(k) = 주기 * D(k)로서 펄스 폭임\n\n듀티 사이클 입력값은 0과 1 사이의 값이어야 합니다.\n\n'듀티 사이클 영(0) 허용 안 함' 체크박스를 선택하면 블록이 직접 피드스루 없이 작동할 수 있으므로, 이를 사용해 대수 루프를 끊을 수 있습니다. 하지만 이 블록은 듀티 사이클 입력값이 0인 경우 시뮬레이션 중에 오류를 발생시킵니다.\n\n고정된 샘플 시간 간격으로 출력 신호 값을 생성하려면 '고정 시간 간격으로 실행' 체크박스를 선택하십시오.
      </entry>
    <entry key="SL_DSCPT_AsyncInterrupt">다운스트림 서브시스템 또는 Task 블록을 실행할 VME 기반 인터럽트 서비스 루틴을 만듭니다.</entry>
    <entry key="VME_InterruptNum_MP">VME 인터럽트 번호:</entry>
    <entry key="VME_InterruptVecOffset_MP">VME 인터럽트 벡터 오프셋:</entry>
    <entry key="TaskPriorities_MP">Simulink 태스크 우선 순위:</entry>
    <entry key="PreemptionFlag_MP">선점 플래그: preemptable-1, non-preemptable-0</entry>
    <entry key="ManageOwnTimer_MP">자체 타이머 관리</entry>
    <entry key="TimerResolution_MP">타이머 분해능(초):</entry>
    <entry key="TimerSize_MP">타이머 크기:</entry>
    <entry key="EnableSimInput_MP">시뮬레이션 입력 활성화</entry>
    <entry key="SL_DSCPT_TaskSync">별개의 VxWorks 태스크로 생성되는 태스크 함수를 만듭니다. 태스크 함수는 다운스트림 Function-Call Subsystem의 코드를 실행합니다. 이 블록이 실행될 경우 태스크 실행을 활성화하기 위해 세마포어가 사용됩니다.</entry>
    <entry key="TaskName_MP">태스크 이름(10자 이하):</entry>
    <entry key="TaskPriority_MP">Simulink 태스크 우선 순위(0-255):</entry>
    <entry key="StackSize_MP">스택 크기(바이트):</entry>
    <entry key="SyncDataTrans_MP">이 태스크의 데이터 전송을 호출자 태스크와 동기화합니다.</entry>
    <entry key="NumBitsPerInteger">정수 유형 비트 수(M):</entry>
    <entry key="InputBitOrder">입력 비트 순서:</entry>
    <entry key="TreatIntegerValuesAs">비트 패킹 후 결과 정수 값을 다음으로 처리:</entry>
    <entry key="OutputDatatype">출력 데이터형:</entry>
    <entry key="TreatInputValuesAs">입력값을 다음으로 처리:</entry>
    <entry key="OutputBitOrder">출력 비트 순서:</entry>
    <entry key="Unsigned">부호 없음</entry>
    <entry key="Signed">부호 있음</entry>
    <entry key="SameAsInput">입력과 동일</entry>
    <entry key="SmallestInteger">가장 작은 정수</entry>
    <entry key="SmallestUnsignedInteger">가장 작은 부호 없는 정수</entry>
    <entry key="MSBFirst">MSB 우선</entry>
    <entry key="LSBFirst">LSB 우선</entry>
    <entry key="PermuteMatrix_MD">정수 값 치환 인덱스로 구성된 벡터 P를 기반으로 행렬 또는 벡터 A의 행이나 열을 치환합니다. 인덱스는 고유하지 않아도 됩니다. [오류] 체크박스를 선택할 때 벡터 P의 길이는 입력 행 또는 입력 열의 개수와 동일해야 합니다(치환 대상에 상관없음).</entry>
    <entry key="Submatrix_MD">입력 행렬의 선택한 부분을 반환합니다. 1차원 입력 신호는 2차원 열 벡터로 취급됩니다. 출력은 항상 2차원입니다. 이 블록은 1부터 시작하는 인덱싱을 수행합니다.</entry>
    <entry key="CreateDiagonalMatrix_MD">대각선 요소로 구성된 벡터를 비희소 행렬로 변환합니다.</entry>
    <entry key="ExtractDiagonal_MD">비희소 행렬의 주대각선을 추출합니다.</entry>
    <entry key="Permute_MP">치환:</entry>
    <entry key="IndexMode_MP">인덱스 모드:</entry>
    <entry key="InvalidPermutationIndex_MP">유효하지 않은 치환 인덱스임:</entry>
    <entry key="ErrorWhenLengthOfPIsNotEqualToPermuteDimensionSize_MP">P의 길이가 치환 차원 크기와 동일하지 않을 때 오류 발생</entry>
    <entry key="Rows_TO">행</entry>
    <entry key="Columns_TO">열</entry>
    <entry key="ZeroBased_TO">0부터 시작</entry>
    <entry key="OneBased_TO">1부터 시작</entry>
    <entry key="ClipIndex_TO">인덱스 자르기</entry>
    <entry key="ClipAndWarn_TO">자르고 경고</entry>
    <entry key="GenerateError_TO">오류 생성</entry>
    <entry key="RowSpan_MP">행 범위:</entry>
    <entry key="StartingRow_MP">시작 행:</entry>
    <entry key="StartingRowIndex_MP">시작 행 인덱스:</entry>
    <entry key="EndingRow_MP">끝 행:</entry>
    <entry key="EndingRowIndex_MP">끝 행 인덱스:</entry>
    <entry key="ColumnSpan_MP">열 범위:</entry>
    <entry key="StartingColumn_MP">시작 열:</entry>
    <entry key="StartingColumnIndex_MP">시작 열 인덱스:</entry>
    <entry key="EndingColumn_MP">끝 열:</entry>
    <entry key="EndingColumnIndex_MP">끝 열 인덱스:</entry>
    <entry key="AllRows_TO">모든 행</entry>
    <entry key="OneRow_TO">1개 행</entry>
    <entry key="RangeOfRows_TO">행 범위</entry>
    <entry key="First_TO">첫 번째</entry>
    <entry key="Index_TO">인덱스</entry>
    <entry key="OffsetFromLast_TO">마지막 항목 기준 오프셋</entry>
    <entry key="Last_TO">마지막</entry>
    <entry key="OffsetFromMiddle_TO">중간 항목 기준 오프셋</entry>
    <entry key="Middle_TO">중간</entry>
    <entry key="AllColumns_TO">모든 열</entry>
    <entry key="OneColumn_TO">1개 열</entry>
    <entry key="RangeOfColumns_TO">열 범위</entry>
    <entry key="InitialSaveTempField_MP">InitialSaveTempField</entry>
    <entry key="InitialBlockCM_MP">InitialBlockCM</entry>
    <entry key="BlockCM_MP">BlockCM</entry>
    <entry key="SaveTempField_MP">SaveTempField</entry>
    <entry key="DisplayStringWithTags_MP">DisplayStringWithTags</entry>
    <entry key="MaskDisplayString_MP">MaskDisplayString</entry>
    <entry key="HorizontalTextAlignment_MP">HorizontalTextAlignment</entry>
    <entry key="LeftAlignmentValue_MP">LeftAlignmentValue</entry>
    <entry key="SourceBlockDiagram_MP">SourceBlockDiagram</entry>
    <entry key="TagMaxNumber_MP">TagMaxNumber</entry>
    <entry key="CMTag1_MP">CMTag1</entry>
    <entry key="CMTag2_MP">CMTag2</entry>
    <entry key="CMTag3_MP">CMTag3</entry>
    <entry key="CMTag4_MP">CMTag4</entry>
    <entry key="CMTag5_MP">CMTag5</entry>
    <entry key="CMTag6_MP">CMTag6</entry>
    <entry key="CMTag7_MP">CMTag7</entry>
    <entry key="CMTag8_MP">CMTag8</entry>
    <entry key="CMTag9_MP">CMTag9</entry>
    <entry key="CMTag10_MP">CMTag10</entry>
    <entry key="CMTag11_MP">CMTag11</entry>
    <entry key="CMTag12_MP">CMTag12</entry>
    <entry key="CMTag13_MP">CMTag13</entry>
    <entry key="CMTag14_MP">CMTag14</entry>
    <entry key="CMTag15_MP">CMTag15</entry>
    <entry key="CMTag16_MP">CMTag16</entry>
    <entry key="CMTag17_MP">CMTag17</entry>
    <entry key="CMTag18_MP">CMTag18</entry>
    <entry key="CMTag19_MP">CMTag19</entry>
    <entry key="CMTag20_MP">CMTag20</entry>
    <entry key="AllowBusInputs_MP">Allow Bus Inputs</entry>
    <entry key="WritesHaveOutput_MP">WritesHaveOutput</entry>
    <entry key="NumReads_MP">NumReads:</entry>
    <entry key="NumWrites_MP">NumWrites:</entry>
    <entry key="PID">PID</entry>
    <entry key="PI">PI</entry>
    <entry key="PD">PD</entry>
    <entry key="P">P</entry>
    <entry key="I">I</entry>
    <entry key="ExportedGlobal">ExportedGlobal</entry>
    <entry key="ImportedExtern">ImportedExtern</entry>
    <entry key="ImportedExternPointer">ImportedExternPointer</entry>
    <entry key="double">double</entry>
    <entry key="single">single</entry>
    <entry key="int8">int8</entry>
    <entry key="uint8">uint8</entry>
    <entry key="int16">int16</entry>
    <entry key="uint16">uint16</entry>
    <entry key="int32">int32</entry>
    <entry key="uint32">uint32</entry>
    <entry key="AND">AND</entry>
    <entry key="OR">OR</entry>
    <entry key="NAND">NAND</entry>
    <entry key="NOR">NOR</entry>
    <entry key="XOR">XOR</entry>
    <entry key="NOT">NOT</entry>
    <entry key="boolean">boolean</entry>
    <entry key="sin2PiU">sin(2*pi*u)</entry>
    <entry key="cos2PiU">cos(2*pi*u)</entry>
    <entry key="expj2PiU">exp(j*2*pi*u)</entry>
    <entry key="sincos2PiU">sin(2*pi*u) and cos(2*pi*u)</entry>
    <entry key="RTF">RTF</entry>
    <entry key="HTML">HTML</entry>
    <entry key="IsSigned1">IsSigned1</entry>
    <entry key="IsSigned2">IsSigned2</entry>
    <entry key="TRUE">TRUE</entry>
    <entry key="FALSE">FALSE</entry>
    <entry key="NumBits1">NumBits1</entry>
    <entry key="NumBits2">NumBits2</entry>
    <entry key="maxNumBits1NumBits2">max([NumBits1 NumBits2])</entry>
    <entry key="Slope1">Slope1</entry>
    <entry key="Slope2">Slope2</entry>
    <entry key="maxSlope1Slope2">max([Slope1 Slope2])</entry>
    <entry key="Bias1">Bias1</entry>
    <entry key="Bias2">Bias2</entry>
    <entry key="maxBias1Bias2">max([Bias1 Bias2])</entry>
  </message>
</rsccat>
