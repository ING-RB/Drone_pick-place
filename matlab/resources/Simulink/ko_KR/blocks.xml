<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 2025 The MathWorks, Inc.-->

<rsccat xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0" locale="ko_KR" product="Simulink" xsi:noNamespaceSchemaLocation="../../resources/schema/msgcat.xsd">
  <message>
    <entry key="DerivativeNonContinuousInput">입력 신호가 미분 불가능하므로 Derivative 블록 ''{0}''이(가) 예기치 않거나 올바르지 않은 출력값을 생성할 수 있습니다. 입력 신호가 연속 샘플 시간을 갖도록 모델을 변경하거나, Derivative 블록 대신 Transfer Fcn 블록을 사용하여 도함수를 구현해 보십시오.</entry>
    <entry key="AlgebraicConstraintTolerancePositive">허용오차는 양수여야 합니다.</entry>
    <entry key="AlgebraicConstraintToleranceScalar">허용오차는 스칼라여야 합니다.</entry>
    <entry key="AlgebraicConstraintInvalidDoubleParameter">파라미터 ''{0}''은(는) ''double''형 값으로 설정해야 합니다.</entry>
    <entry key="AlgebraicConstraintInvalidParameter">Simulink가 블록 ''{0}''에 유효하지 않은 파라미터 설정을 감지했습니다.</entry>
    <entry key="AlgebraicConstraintNaNDoubleParameter">파라미터 ''{0}''이(가) ''Not a Number (NaN)''로 설정되어 있습니다. 이 값을 ''double''형의 숫자로 변경하십시오.</entry>
    <entry key="AlgebraicConstraintInitialValueIsInfinite">''초기 추측값'' 파라미터 ''{0}''이(가) 무한대입니다. 이 값을 ''double''형의 유한수로 변경하십시오.</entry>
    <entry key="EnumConstBlockType">열거형 상수</entry>
    <entry key="EnumConstBlockDescription">''값'' 파라미터로 지정된 열거형 값을 출력합니다.\n\n출력 데이터형은 다음과 같이 입력해야 합니다.\n ''Enum: &lt;class name&gt;''.\n값은 지정된 열거형 클래스의 값으로 구성된 배열이 되는 임의의 표현식일 수 있습니다.</entry>
    <entry key="EnumConstTypePrompt">출력 데이터형:</entry>
    <entry key="EnumConstValuePrompt">값:</entry>
    <entry key="EnumConstSampleTimePrompt">샘플 시간:</entry>
    <entry key="EnumConstEmptyDataType">No data type specified.</entry>
    <entry key="EnumConstInvalidSyntaxForDataType">Invalid data type. Accepted values are enumerated class name preceded by ''Enum: '' or class metadata of enumerated class.</entry>
    <entry key="EnumConstInvalidDataType">Invalid data type ''{0}''. Data type must resolve to an enumerated class.</entry>
    <entry key="EnumConstInvalidEnumValue">Invalid value specified because it is not an instance of the enumerated class ''{0}''.</entry>
    <entry key="EnumConstValueForInvalidDataType">'출력 데이터형' 파라미터에 지정된 클래스 이름이 유효하지 않습니다.</entry>
    <entry key="UnknownAction">M 어설션: 알 수 없는 동작</entry>
    <entry key="TimeRangeOverridden">''{0}''의 시간 범위가 전역 설정에 의해 지금 재정의되는 중입니다.</entry>
    <entry key="ReplaceBlock">XY 그래프 범위 ''{0}''은(는) Simulink 블록 라이브러리에서 새 버전으로 대체해야 합니다.</entry>
    <entry key="slBlocksCannotChangeDatatypeDuringSim">--&gt; To change the ''Upper limit'' to {0,number,integer}, its data type must be changed. The data type cannot be changed while simulation is running.</entry>
    <entry key="SineLookupWordLengthTooSmall">파라미터 출력 워드 길이(OutputWordLength)는 스칼라 숫자형이면서 1보다 큰 정수 값이어야 합니다.</entry>
    <entry key="SineLookupNumDataPtsTooSmall">The parameter number of data points for lookup table must be a scalar numeric and must have an exact integer not less than 2.</entry>
    <entry key="SineLookupEitherTooSmall">룩업 테이블의 데이터 점 개수(NumDataPoints) 파라미터와 출력 워드 길이(OutputWordLength) 파라미터가 서로 호환되지 않습니다. 데이터 점 개수를 줄이거나 워드 길이를 늘려야 합니다. 수식\n ( 2^(OutputWordLength-2) + 1 ) &gt;= NumDataPoints\n가 충족되어야 합니다. NumDataPoints를 {0,number,integer}에서 {1,number,integer}(으)로 줄이거나 OutputWordLength를 {2,number,integer}에서 {3,number,integer}(으)로 늘려야 합니다.</entry>
    <entry key="IntegerPartIsNotBigEnough">블록 ''{0}''에서 정수 비트 수 {1,number,integer}이(가) 출력을 나타내기에 너무 작습니다. 정수 비트 수는 적어도 {2,number,integer}이어야 합니다.</entry>
    <entry key="FractionPartIsNotBigEnough">블록 ''{0}''에서 소수 비트 수 {1,number,integer}이(가) 출력을 나타내기에 너무 작습니다. 소수 비트 수는 적어도 {2,number,integer}이어야 합니다.</entry>
    <entry key="BitMaskWordLengthTooLarge">The value of parameter ''Bit Mask'' must fit in 53 bits, larger values are not supported.</entry>
    <entry key="BitMaskNotComplex">The value of parameter ''Bit Mask'' cannot contain any complex number.</entry>
    <entry key="BitToIntegerConverter">비트로 구성된 벡터를 정수 값으로 구성된 벡터에 매핑합니다. M은 각 출력 정수에 매핑된 비트 수를 정의합니다. 입력 길이는 M의 정수 배수여야 합니다.</entry>
    <entry key="IntegerToBitConverter">정수 값 입력으로 구성된 벡터를 비트로 구성된 벡터에 매핑합니다. 블록 입력은 부호 있음으로 처리된 경우 범위 [-2^(M-1), 2^(M-1)-1] 내에 있는 정수 값이어야 하고, 부호 없음으로 처리된 경우 범위 [0, 2^M-1] 내에 있는 정수 값이어야 합니다. 고정소수점 입력에는 저장된 정수 값이 사용됩니다.</entry>
    <entry key="RenameViewerErr">뷰어의 이름을 {0}(으)로 바꿀 수 없습니다. 다른 Simulink 객체가\n동일한 이름을 가집니다. 이름을 {1}(으)로 바꿉니다.</entry>
    <entry key="CannotViewBus">The Scope {0} is unable to view a signal containing an array of non-virtual buses or a non-virtual bus containing an array of sub-buses. Disconnect the Scope from that signal.</entry>
    <entry key="LibNotFoundOrNA">Library {0} not found or not available.</entry>
    <entry key="RenameErrorTitle">이름 바꾸기 오류</entry>
    <entry key="SSMgrNoSelection">선택 항목 없음</entry>
    <entry key="SSMgrLibraryUnavailable">라이브러리 ''{0}''을(를) 찾을 수 없거나 사용할 수 없음</entry>
    <entry key="ScopeAxes">좌표축</entry>
    <entry key="SSMgrInput">입력</entry>
    <entry key="SSMgrOutput">출력</entry>
    <entry key="CacheUpdateErr">Error updating cache. Model workspace unavailable.</entry>
    <entry key="NoIOSignals">M Assert: unexpected empty return of IOSignals.</entry>
    <entry key="ModelNotFound">Model: {0} not found.</entry>
    <entry key="SigSelectionNADuringSim">Cannot select signal while simulation is running.</entry>
    <entry key="SizeOfDataStructuresDiff">데이터 구조체의 크기가 실행 #1과 실행 #{0} 간에 다릅니다.</entry>
    <entry key="CancelButton">취소</entry>
    <entry key="OKButton">확인</entry>
    <entry key="HelpButton">도움말</entry>
    <entry key="ApplyButton">적용</entry>
    <entry key="ScopeTime">시간</entry>
    <entry key="ScopeParametersDecimation">데시메이션</entry>
    <entry key="IndexOptionPromp">인덱스 옵션</entry>
    <entry key="DataUpdateError">선택 데이터를 업데이트하는 중 오류가 발생했습니다.</entry>
    <entry key="unhandledFlag">"{0}"은(는) 처리되지 않은 플래그입니다.</entry>
    <entry key="linearizationNotSupportedInThisMode">Linearization is not supported in {0} mode.</entry>
    <entry key="oldVersionOfManualSwitchBlock">You are using an old version of the Manual Switch block. ''Please update block "{0}" with the latest version from the Simulink library.</entry>
    <entry key="invalidParameter">Invalid parameter specified.</entry>
    <entry key="mustHaveSameNumberOfElements">{0} must have the same number of elements as TABLE has {1}.</entry>
    <entry key="indexMustMonotonicallyIncrease">{0} must increase monotonically.</entry>
    <entry key="mustSupplyOneParameter">At least one parameter must be supplied.</entry>
    <entry key="replacementOfFunctionByBlock">The {0} graph scope "{1}" should be replaced with a new version from the simulink_extras block library.</entry>
    <entry key="cannotDeleteBlock">Cannot delete block while simulating.</entry>
    <entry key="somethingWrongInGetParam">Something wrong in get_param, You don''t have the current Simulink.</entry>
    <entry key="numberOfBufferPointsGreaterThanPlotFreq">The number of points in the buffer must be more than the plot frequency.</entry>
    <entry key="sampleTimeMustBePositive">The sample time field accepts only positive values.</entry>
    <entry key="axisLimitsMustBeDefined">Axis limits must be defined.</entry>
    <entry key="invalidBlock">Invalid block.</entry>
    <entry key="undefinedCorrelationType">Undefined correlation type "{0}".</entry>
    <entry key="obsoleteMask">Mask of {0}, {1}, is obsolete. Run &lt;a href="matlab:upgradeadvisor(bdroot)"&gt;Upgrade Advisor&lt;/a&gt; on this model.</entry>
    <entry key="licenseRequiredForPIDTuner">''{0}''에서 PID 조정 툴 사용을 요청했습니다. PID 조정 툴을 사용하려면 Simulink Control Design 라이선스가 필요하지만, 라이선스를 체크아웃하지 못했습니다.</entry>
    <entry key="licenseRequiredForFixedPointTool">''{0}'' requested use of the Fixed-Point Tool. Use of the Fixed-Point Tool requires a Fixed-Point Designer license, but license checkout failed.</entry>
    <entry key="tooManyInputArguments">입력 인수가 너무 많습니다.</entry>
    <entry key="GotoUnknownAction">Unknown action in {0}</entry>
    <entry key="invalidNumInputs">입력 인수의 개수가 올바르지 않음: {0}.</entry>
    <entry key="invalidNumInputsSpecified">Invalid number of inputs specified.</entry>
    <entry key="unknownBlockType">Unknown block type!</entry>
    <entry key="invalidType">Invalid type: {0}.</entry>
    <entry key="wrongArgument">Wrong argument "{0}" in "{1}"!</entry>
    <entry key="requiresFixedStepDiscreteSolver">Requires fixed-step discrete solver.</entry>
    <entry key="emptyMatricesNotAllowed">Empty matrices not allowed.</entry>
    <entry key="invalidSamplingPeriod">Invalid sampling period {0}.</entry>
    <entry key="corruptedDialogStructure">Assertion: Dialog structure has been corrupted.</entry>
    <entry key="noSolutionFound">Failed to find an initial condition. Exit flag is "{0}".</entry>
    <entry key="wrongSolutionFound">Calculated initial condition is not feasible. Condition number of the system matrix is {0}.</entry>
    <entry key="tbleditDimensionMatchBreakPoint">블록 ''''{0}''''에서 오류 보고: 테이블 데이터의 차원 크기 {1,number,integer}은(는) 대응하는 절점 데이터의 크기와 같아야 합니다.</entry>
    <entry key="multirateOnePort">The block is supposed to have only one input port.</entry>
    <entry key="multirateInvaliDimension">Invalid dimensions: the input should be 1-D.</entry>
    <entry key="SL_SimscapeBus">Error finding help for Simscape bus block. Simscape must be installed to access this block reference page. Check your installed products.</entry>
    <entry key="SL_ConnectionLabel">Error finding help for Connection Label block. Simscape must be installed to access this block reference page. Check your installed products.</entry>
    <entry key="SL_VariantConnector">Variant Connector 블록에 대한 도움말을 찾는 중 오류가 발생했습니다. 이 블록 도움말 페이지에 액세스하려면 Simscape가 설치되어 있어야 합니다. 설치된 제품을 확인하십시오.</entry>
    <entry key="SL_BlockIsNotMasked">Block is not masked.</entry>
    <entry key="SL_UnknownCommandOption">''{0}''은(는) 알 수 없는 옵션입니다.</entry>
    <entry key="SL_FailedHelper">Failed to run the helper function getBlockHelpMapNameAndPath for BlockType ''{0}'' because of:\n{1}</entry>
    <entry key="SlselsubsNotEnoughArgs">입력 인수가 부족합니다.</entry>
    <entry key="SlselsubsFirstArgNotVector">The first input argument must be a 1xn/nx1 array or cell array.</entry>
    <entry key="SlselsubsSecondArgNotVectorOrScalar">The second input argument must be a numerical vector or scalar.</entry>
    <entry key="SlselsubsThirdArgNotLogicScalar">The third input argument must be a logical scalar.</entry>
    <entry key="SlselsubsSecondArgNotScalarAsStartingIdx">To choose elements through the end of the vector, the second input argument must be a scalar.</entry>
    <entry key="AbortParseXMLFile">이전 오류로 인해 XML 파일 ''{0}''이(가) 무시됩니다.</entry>
    <entry key="AbsValInvalidOutputTypeSetting">''{0}''에 유효하지 않은 출력 데이터형 설정임</entry>
    <entry key="ActionPortExists">An action port already exists in subsystem ''{0}''. Addition of another control block is not allowed.</entry>
    <entry key="ArccosArgOutOfRange">''{0}''에서 역코사인에 대한 인수가 범위를 벗어남</entry>
    <entry key="ArcsinArgOutOfRange">''{0}''에서 역사인에 대한 인수가 범위를 벗어남</entry>
    <entry key="AssertionAssert">시간 {1}에 ''{0}''에서 어설션이 감지됨</entry>
    <entry key="AssertionShadowNotBlock">Shadow 객체는 블록 또는 서브시스템이어야 함</entry>
    <entry key="AssignmentAllDimInvDims">Invalid input dimensions specified for input ports &lt;Y0&gt; and/or &lt;U&gt; of ''{0}''. The two ports must have the same size for dimension {1,number,integer}, because parameter ''{2}'' is specified as ''Assign all'' for this dimension</entry>
    <entry key="AssignmentAllDimInvDimsSkip">''{1}''의 입력 포트 &lt;Y0&gt; 및/또는 파라미터 ''{0}''에 대해 지정된 입력 차원이 유효하지 않습니다. 파라미터 ''{3}''이(가) ''모두 할당''으로 지정되어 있으므로 둘 중 하나는 차원 {2,number,integer}에 대해 이 차원의 입력 포트 &lt;U&gt;에 대한 차원 설정과 동일한 설정을 가져야 합니다.</entry>
    <entry key="AssignmentAllElemsInvDims">''{0}''의 입력 포트 &lt;Y0&gt; 및/또는 &lt;U&gt;에 대해 지정된 입력 차원이 유효하지 않습니다. 파라미터 ''{1}''이(가) ''모두 할당''으로 지정되어 있으므로 두 포트는 너비가 같아야 합니다.</entry>
    <entry key="AssignmentComplexOrNonpositiveOutputDims">''{1}''의 파라미터 ''{0}''이(가) 유효하지 않습니다. 지정된 ''{2}''은(는) 실수형 양의 정수여야 합니다.</entry>
    <entry key="AssignmentDataPortDimsModeMismatch">''{0}''의 입력 포트 &lt;U&gt;의 차원 모드가 대화 상자 파라미터 및 다른 포트의 차원 모드를 기준으로 할 때의 필요한 차원 모드와 일치하지 않음</entry>
    <entry key="AssignmentDataPortInvDType">''{0}''의 입력 포트 &lt;U&gt;의 데이터형이 유효하지 않습니다. 입력 포트 &lt;Y0&gt; 및 &lt;U&gt;는 동일한 데이터형을 가져야 합니다.</entry>
    <entry key="AssignmentDoesNotSupportVB">''{0}''의 입력 포트 &lt;Y0&gt; 및/또는 &lt;U&gt;에 들어오는 신호가 가상 버스 신호입니다. 입력 포트에는 벡터 신호 또는 행렬 신호가 필요합니다. 이 가상 버스 신호를 명시적으로 벡터로 변환하려면 Bus to Vector 블록을 삽입해 보십시오. 이 진단 메시지는 구성 파라미터 대화 상자 -&gt; 진단 -&gt; 연결성 창에서 ''버스 신호가 벡터로 처리됨''을 적절하게 설정하여 제어할 수 있습니다.</entry>
    <entry key="AssignmentIdxPortDoesNotSupportBuses">''{1}''의 &lt;Idx{0,number,integer}&gt;번 입력 포트에 들어오는 신호가 버스 신호이며, 이는 유효하지 않습니다. Assignment 블록의 인덱스 포트는 비 버스 신호여야만 합니다.</entry>
    <entry key="AssignmentInitPortInvDType">''{0}''의 입력 포트 &lt;Y0&gt;의 데이터형이 유효하지 않습니다. 입력 포트 &lt;Y0&gt; 및 &lt;U&gt;는 동일한 데이터형을 가져야 합니다.</entry>
    <entry key="AssignmentInputExceedOutputDims">The dimensions of input port &lt;U&gt; of ''{0}'' for dimension {1,number,integer} should not exceed the specified output port dimensions for this dimension</entry>
    <entry key="AssignmentInputExceedOutputWidth">''{0}''의 입력 포트 &lt;U&gt;의 너비는 지정된 출력 포트 너비를 초과할 수 없음</entry>
    <entry key="AssignmentInvalidConfigInsideIteratorSubsys">Invalid configuration for an Assignment block in a For/While iterator subsystem. The following configuration is not supported: \n \n - Assignment block ''{0}'' is contained in For Each subsystem ''{1}'', which is directly or indirectly contained by For/While iterator subsystem ''{2}''. \n \n - Assignment block ''{0}'' initialization port (Y0 port) is enabled. \n \nUpdate your model to avoid this configuration.</entry>
    <entry key="AssignmentInvalidDataPortDims">''{0}''의 입력 포트 U에 대해 지정된 입력 차원이 유효하지 않습니다. 입력 포트가 차원 {2,number,integer}에서 크기 {1}을(를) 갖도록 지정되었습니다. 이 크기는 입력 포트 &lt;Y0&gt;에서 이 차원의 크기 {3}보다 작거나 같아야 합니다</entry>
    <entry key="AssignmentInvDataPortDimSize">''{0}''의 입력 포트 U에 대해 지정된 입력 차원이 유효하지 않습니다. 입력 포트가 차원 {2,number,integer}에서 크기 {1,number,integer}을(를) 갖도록 지정되었습니다. 이 크기는 입력 포트 &lt;Y0&gt;에서 이 차원의 크기 {3,number,integer}보다 작거나 같아야 합니다.</entry>
    <entry key="AssignmentInvDataPortDims">''{0}''의 입력 포트 &lt;U&gt;에 대해 지정된 입력 차원이 유효하지 않습니다. 지정된 차원 {1}이(가) 필요한 차원 {2}과(와) 일치하지 않습니다</entry>
    <entry key="AssignmentInvDataPortIndexPartialWidth">''{0}''의 입력 포트 &lt;U&gt;에 대해 지정된 입력 차원이 유효하지 않습니다. 지정된 너비 {1}은(는) 파라미터 및 포트 차원을 기준으로 적어도 {2}과(와) 같은 크기여야 합니다</entry>
    <entry key="AssignmentInvDataPortIndexWidth">''{0}''의 입력 포트 &lt;U&gt;에 대해 지정된 입력 차원이 유효하지 않습니다. 지정된 너비 {1}이(가) 필요한 너비 {2}과(와) 일치하지 않습니다</entry>
    <entry key="AssignmentInvDataPortWidth">''{0}''의 입력 포트 &lt;U&gt;에 대해 지정된 입력 차원이 유효하지 않습니다. 입력 포트가 너비 {1}을(를) 갖도록 지정되었지만, 이 포트는 너비가 {2}인 입력 포트 &lt;Y0&gt;보다 작거나 같은 너비를 가져야 합니다</entry>
    <entry key="AssignmentInvDataPortDimsModeForFixedScalarOutput">The signal at input port &lt;U&gt; of Assignment block ''{0}'' is a variable-size signal, but the block is set up to output fixed-size scalar signals. This combination is not supported.</entry>
    <entry key="AssignmentInvIndexPort">Invalid input dimensions specified for input port &lt;Idx{0,number,integer}&gt; of ''{1}''. Only scalar and vector is allowed to be input to this port</entry>
    <entry key="AssignmentInvIndexPortStartValue">''{1}''의 &lt;Idx{0,number,integer}&gt;번 입력 포트에 대해 지정된 입력 차원이 유효하지 않습니다. ''인덱스를 시작 값으로 사용'' 옵션이 선택된 경우 요소, 행 및 열 입력 포트에 대한 입력값에는 스칼라만 허용됩니다.</entry>
    <entry key="AssignmentInvInitMaxElemParam">Invalid input dimensions specified for input port &lt;Y0&gt; of ''{0}''. Specification in parameter ''{1}'' expects at least {2} elements from input port &lt;Y0&gt;, but it only provides {3} elements</entry>
    <entry key="AssignmentInvInitPortElems">''{0}''의 입력 포트 &lt;Y0&gt;에 대해 지정된 입력 차원이 유효하지 않습니다. 지정된 요소 개수 {1}이(가) &lt;Idx{3,number,integer}&gt;번 입력 포트의 차원을 기준으로 할 때의 필요한 최소 요소 개수 {2}과(와) 일치하지 않습니다</entry>
    <entry key="AssignmentInvInitPortSize">''{0}''의 입력 포트 &lt;Y0&gt;에 대해 지정된 입력 차원이 유효하지 않습니다. 차원 {1,number,integer}에 대해 지정된 크기가 {2,number,integer}입니다. 이 크기는 {3,number,integer}보다 크거나 같아야 합니다.</entry>
    <entry key="AssignmentInvInputElement">''{2}''의 &lt;Idx{1,number,integer}&gt;번 입력 포트의 {0,number,integer}번째 요소 값이 {3,number,integer}입니다. 이 값은 유효한 데이터 요소를 할당하기 위해 허용되는 값 범위({4,number,integer}~{5,number,integer}) 내에 속하지 않습니다.</entry>
    <entry key="AssignmentInvInputElementEnd">The ending index for dimension {0,number,integer} in ''{1}'' has a value of {2,number,integer} because the starting index from input port &lt;Idx{3,number,integer}&gt; has a value of {4,number,integer} and the size of this dimension at the input port &lt;U&gt; is {5,number,integer}. This value is not within the range of permissible values ({6,number,integer} through {7,number,integer}) that allows assignment of a valid data element</entry>
    <entry key="AssignmentInvInputElementStart">The starting index from input port &lt;Idx{0,number,integer}&gt; in ''{1}'' has a value of {2,number,integer}. This value is not within the range of permissible values ({3,number,integer} through {4,number,integer}) that allows assignment of a valid data element</entry>
    <entry key="AssignmentInvMatrixDataInpInVecMode">''{0}''의 입력 포트 &lt;U&gt;에 대해 지정된 입력 차원이 유효하지 않습니다. 출력 차원 수가 1인 경우 어떠한 입력 포트도 행렬을 허용하지 않습니다.</entry>
    <entry key="AssignmentInvMatrixInitInpInVecMode">''{0}''의 입력 포트 &lt;Y0&gt;에 대해 지정된 입력 차원이 유효하지 않습니다. 출력 차원 수가 1인 경우 어떠한 입력 포트도 행렬을 허용하지 않습니다.</entry>
    <entry key="AssignmentInvMaxDimParam">''{0}''의 입력 포트 &lt;Y0&gt;에 대해 지정된 입력 차원이 유효하지 않습니다. 파라미터 ''{1}''의 사양에서는 입력 포트 &lt;Y0&gt;에서 차원 {2,number,integer}의 크기가 적어도 {3,number,integer}이어야 하지만, 현재 {4,number,integer}에 불과합니다.</entry>
    <entry key="AssignmentInvNDDataInpInVecMode">''{0}''의 입력 포트 &lt;U&gt;에 대해 지정된 입력 차원이 유효하지 않습니다. 벡터 모드인 경우 어떠한 입력 포트도 {1,number,integer}차원 신호를 허용하지 않습니다.</entry>
    <entry key="AssignmentInvNDDataPortNumDims">''{0}''의 입력 포트 &lt;U&gt;에 대해 지정된 입력 차원이 유효하지 않습니다. 신호는 스칼라이거나 {1,number,integer}차원이어야 합니다</entry>
    <entry key="AssignmentInvNDInitInpInVecMode">''{0}''의 입력 포트 &lt;Y0&gt;에 대해 지정된 입력 차원이 유효하지 않습니다. 벡터 모드인 경우 어떠한 입력 포트도 {1,number,integer}차원 신호를 허용하지 않습니다.</entry>
    <entry key="AssignmentInvInitInpForFrameOutputInVecMode">''{0}''의 입력 포트 &lt;Y0&gt;에 대해 지정된 입력 차원이 유효하지 않습니다. Assignment 블록이 프레임 신호를 출력하고 ''출력 차원 수'' 파라미터가 ''1''로 설정된 경우 이 입력 포트는 1차원 신호를 받지 않습니다.</entry>
    <entry key="AssignmentInvNDInitPortNumDims">''{0}''의 입력 포트 &lt;Y0&gt;에 대해 지정된 입력 차원이 유효하지 않습니다. 신호의 차원 수는 {1,number,integer}이어야 합니다</entry>
    <entry key="AssignmentInvalidMatrixOutputDims">Parameter ''{0}'' in ''{1}'' specifies sizes for {2,number,integer} dimensions. It does not match the number of output dimensions, {3,number,integer}</entry>
    <entry key="AssignmentInvalidSelIdxForEmptyInp">입력 포트 &lt;Y0&gt;에서 차원 {0,number,integer}의 현재 크기가 0입니다. 블록 ''{1}''을(를) 사용하려면 이 크기가 적어도 {2,number,integer}이어야 합니다.</entry>
    <entry key="AssignmentInvalidVectorOutputDims">Invalid ''{0}'' setting for ''{1}''. The specified ''{2}'' for dimension 1 must be: [n] or [n 1] when the number of output dimensions is 1</entry>
    <entry key="AssignmentMatrixOutputDimsVectorInp">Invalid ''{0}'' setting for ''{1}''. The output must be a vector because the number of output dimensions is 1</entry>
    <entry key="AssignmentMismatchDataIndexPortDim">''{1}''의 차원 {0,number,integer}에 대해 지정된 입력 차원이 유효하지 않습니다. &lt;Idx{3,number,integer}&gt;번 입력 포트에 대해 지정된 요소 개수 {2}이(가) 입력 포트 &lt;U&gt;의 차원 {5,number,integer}에 대해 지정된 크기 {4}과(와) 일치하지 않습니다</entry>
    <entry key="AssignmentMismatchDataPortWidth">''{0}''의 입력 포트 &lt;U&gt;에 대해 지정된 입력 차원이 유효하지 않습니다. 지정된 요소 개수 {1}이(가) 필요한 요소 개수 {2}과(와) 일치하지 않습니다</entry>
    <entry key="AssignmentNDDataPortDimMismatch">''{0}''의 출력 포트에는 입력 포트 &lt;U&gt;의 차원 {2,number,integer}을(를) 따라 {1,number,integer}개의 요소가 필요합니다. 입력 포트 &lt;U&gt;에서 차원 {3,number,integer}의 너비는 {4,number,integer}입니다.</entry>
    <entry key="AssignmentNoBooleanIdxPort">''{1}''의 &lt;Idx{0,number,integer}&gt;번 입력 포트에 대한 데이터형 설정이 유효하지 않습니다. 이 포트는 부울, half 또는 숫자형이 아닌 데이터형을 지원하지 않습니다.</entry>
    <entry key="AssignmentNoScaledOrBiasedFxpIdxPort">''{1}''의 &lt;Idx{0,number,integer}&gt;번 입력 포트에 대한 데이터형 설정이 유효하지 않습니다. 인덱스 포트에서 고정소수점을 사용하려면 데이터형은 편향 0, 소수 길이 0, 기울기 1.0이이어야 하며 워드 길이가 128보다 작거나 같아야 합니다.</entry>
    <entry key="AssignmentNonIntegerInput">''{1}''의 &lt;Idx{0,number,integer}&gt;번 입력 포트에서 정수가 아닌 입력값이 잘림</entry>
    <entry key="AssignmentIntegerInputOverflow">''{1}''의 &lt;Idx{0,number,integer}&gt;번 입력 포트에서 정수 입력 오버플로 발생, 입력 데이터가 int32의 범위를 초과하기 때문에 변환하는 동안 손실이 발생했습니다.</entry>
    <entry key="AssignmentNotAllOutputElementAssigned">At least 1 element in the output signal of ''{0}'' has not been assigned</entry>
    <entry key="AssignmentIndexPortDataTypeRangeNotEnough">Assignment 블록 ''{0}''에서 차원 {2,number,integer}에 대한 인덱스 포트 {1,number,integer}의 유형이 ''{3}''입니다. 이 범위는 출력 크기를 기준으로 최대 인덱스 {4,number,integer}에 충분하지 않습니다. 출력 신호의 요소 중 적어도 하나가 할당되지 않게 됩니다.</entry>
    <entry key="AssignmentObsoleteAssignAllSetting">{2}에서 차원 {1,number,integer}에 대한 모든 요소의 할당을 나타내기 위해 파라미터 ''{0}''에 ''-1''이 사용되었습니다. 이 ''-1''은 향후 릴리스에서 더 이상 사용되지 않을 예정입니다. 대신 이 차원에 대해 파라미터 ''{3}''을(를) ''모두 할당''으로 설정하십시오.</entry>
    <entry key="AssignmentOutputDimsNotVector">''{1}''의 파라미터 ''{0}''이(가) 유효하지 않습니다. 지정된 출력 크기는 실수형 양의 정수로 구성된 벡터여야 합니다.</entry>
    <entry key="AssignmentRepeatIdxFromPort">요소 {0,number,integer} 및 {1,number,integer}이(가) 동일한 값 {2,number,integer}을(를) 갖습니다. ''{5}''의 차원 {4,number,integer}에 대한 &lt;sldiag objui="inport" objparam="{3,number,integer}" objname="{5}"&gt;{3,number,integer}번 입력 포트&lt;/sldiag&gt;의 인덱스에는 동일한 값을 사용할 수 없습니다.</entry>
    <entry key="AssignmentRepeatIdxParam">Parameter ''{0}'' in ''{1}'' cannot have repeat value. For dimension {2,number,integer}, elements {3,number,integer} and {4,number,integer} in parameter ''{5}'' have the same value {6,number,integer}</entry>
    <entry key="AssignmentTailDimsTrailing">The output dimension specified for ''{0}'' will be trimmed because the width for the highest {1,number,integer} dimension(s) is 1. The number of dimensions of the output port will be different from the value specified in the dialog</entry>
    <entry key="AssignmentUnequalBusInputs">Incoming signals to input ports &lt;U&gt; and &lt;Y0&gt; for block ''{0}'' are different with respect to names and hierarchies. For the Assignment block to work with bus signals, both input buses must have the same names and hierarchies.</entry>
    <entry key="AssignmentVectorDataPortDimMismatch">''{0}''의 출력 포트에는 입력 포트 &lt;U&gt;의 요소 {1,number,integer}개가 필요합니다. 입력 포트 &lt;U&gt;의 너비는 {2,number,integer}입니다.</entry>
    <entry key="AssumingDefaultSimStateForL2MSFcn">블록 ''{1}''의 MATLAB S-Function ''{0}''이(가) 시뮬레이션 동작점 준수 수준을 지정하지 않았습니다. 디폴트 동작점 스냅샷이 이 블록의 전체 시뮬레이션 동작점을 캡처하기에 충분하다고 가정합니다. 이 경우 {2}.m을 업데이트하여 OperatingPointCompliance 설정을 지정하거나 이 경고를 &lt;a href="matlab:warning(''off'',''Simulink:blocks:AssumingDefaultSimStateForL2MSFcn'')"&gt;비활성화&lt;/a&gt;할 수 있습니다.</entry>
    <entry key="AssumingDefaultSimStateForSFcn">The OperatingPointCompliance setting of the {0} S-Function ({1}) block ''{2}'' is not specified. Simulink therefore assumes that the default simulation operating point save/restore is sufficient to capture the complete simulation operating point of this block. Please specify the OperatingPointCompliance setting in the S-function source code. Alternatively, you can  &lt;a href="matlab:warning(''off'',''Simulink:blocks:AssumingDefaultSimStateForSFcn'')"&gt;disable&lt;/a&gt; this warning.</entry>
    <entry key="BCST_CannotMakeCapabilities">The capabilities cannot be made: {0}</entry>
    <entry key="BMathComplexInputNotSupported">Invalid complex data type specified for the input port of block ''{0}''. Operator ''{1}'' does not support complex input signal type.</entry>
    <entry key="BMathComplexOutputNotSupported">Invalid complex data type specified for the output port of block ''{0}''. Operator ''{1}'' does not support complex output signal type.</entry>
    <entry key="BMathInvDtype">''{0}''의 입력 포트 및 출력 포트의 데이터형을 {1}(으)로 설정할 수 없습니다. ''{2}'' 연산으로 구성된 경우 데이터형은 double형 또는 single형이어야 합니다.</entry>
    <entry key="BMathInvDtype3">Cannot set data type of input and output ports of ''{0}'' to {1}. The data type must be signed when configured to be a ''{2}'' operation.</entry>
    <entry key="BMathNRUnsupportedFloatInputFixptInterm">In ''{0}'', the operator ''{1}'' does not support ''{2}'' method for floating-point input, fixed-point output, and intermediate results data type ''Inherit from output''. Please, consider adding a Data Type Conversion block in front of the Math Function block to convert the original floating-point input to a fixed-point signal.</entry>
    <entry key="BMathSignedSqrtIntermDtpMustBeFloat">In ''{0}'', the input or output to ''signedSqrt'' operator must be floating-point.</entry>
    <entry key="BMathSlopeBiasScaledInputNotSupported">Invalid data type specified for the input port of block ''{0}''. Operator ''{1}'' supports built-in data types and fixed-point data types with bias equal to zero and slope power of two.</entry>
    <entry key="RecipNRSlopeBiasScaledInputNotSupported">Invalid data type specified for the input port of block ''{0}''. Block ''{1}'' supports built-in data types and fixed-point data types with bias equal to zero and slope power of two.</entry>
    <entry key="BMathSlopeBiasScaledOutputNotSupported">Invalid data type specified for the output port of block ''{0}''. Operator ''{1}'' supports built-in data types and fixed-point data types with bias equal to zero and slope power of two.</entry>
    <entry key="RecipNRInvIterationNum">In block ''{0}'', valid value of parameter ''{1}'' is an integer between 1 and 255.</entry>
    <entry key="BMathUnsupportedMethod">In ''{0}'', operator ''{1}'' does not support ''{2}'' method for fixed-point types.</entry>
    <entry key="BadDimensionsForUpperLowerLimit">Invalid dimensions in ''{0}''. The dimensions for ''{1}'' must match the dimensions for ''{2}''</entry>
    <entry key="BadParamValueForUpperLowerLimit">Invalid setting in ''{0}'' ''{1}''. Data type for ''{2}'' must be of type double or single and must be the same as the data type for ''{3}''</entry>
    <entry key="BiasNonScalar">The Bias parameter specified in ''{0}'' is invalid. Since the input signal is variable-size, the Bias parameter must be a scalar. A nonscalar Bias only works for fixed-size signals since the Bias size must equal the signal size.</entry>
    <entry key="BlkParamInvalidLinkStatus">연결된 블록의 경우 블록의 LinkStatus를 ''none'' 또는 ''inactive''로 설정할 수 있습니다. 비활성 링크의 경우에는 LinkStatus를 ''none'', ''restore'' 또는 ''propagate''로 설정할 수 있습니다</entry>
    <entry key="BlkParamInvalidLinkStatusForInactiveLink">비활성 링크의 LinkStatus는 ''none'', ''restore'' 또는 ''propagate''로만 설정할 수 있음</entry>
    <entry key="BlkParamInvalidLinkStatusForLink">연결된 블록의 LinkStatus는 ''none'' 또는 ''inactive''로만 설정할 수 있음</entry>
    <entry key="BlkParamLinkStatusOnNonReference">LinkStatus는 연결된 블록에만 설정할 수 있음</entry>
    <entry key="BlkWithStatePortNotSupported">Subsystem ''{0}'', which contains a For Each block (''{1}''), does not support block ''{2}'' because the block has a state output port.</entry>
    <entry key="PeriodicFCSSDiagNotSupported">Subsystem ''{0}'', which contains a For Each block (''{1}''), does not support Function-Call subsystem ''{2}'' because the ''Sample time type'' parameter of block ''{3}'' is set to ''periodic''. Consider setting this parameter to ''triggered''.</entry>
    <entry key="AsyncFCSSSFcnNotSupported">Simulink does not support an asynchronous S-function initiator block ''{0}'' inside subsystem ''{1}'', which contains a For Each block (''{2}'').</entry>
    <entry key="BlockAliasNotFound">''{1}''에 대한 블록 별칭 ''{0}''을(를) 찾을 수 없습니다. 별칭 ''{2}''은(는) ''{3}''에 대한 것입니다.</entry>
    <entry key="BlockCannotAcceptBusInput">블록 ''{0}''은(는) 비가상 버스 신호, 또는 비가상 서브 버스를 갖는 가상 버스를 받을 수 없습니다. 이 블록에 연결된 버스 신호는 가상 버스 신호여야 합니다. "To Virtual Bus" 블록을 삽입하여 입력 신호를 가상 버스로 변환해 보십시오.</entry>
    <entry key="BlockCannotAcceptMixedVirtualBusInput">Block ''{0}'' does not support virtual buses that contain nonvirtual buses. Use a "To Virtual Bus" block to convert the input bus to a virtual bus.</entry>
    <entry key="BlockCannotProduceBusOutput">블록 ''{0}''은(는) 버스 신호를 출력할 수 없습니다.</entry>
    <entry key="BlockConfiguredToExpectBus">Signal Conversion 블록 ''{0}''은(는) 버스 신호를 받도록 구성된 경우 비 버스 신호에 대해 동작할 수 없습니다. Bus Creator 블록 또는 버스를 지원하는 다른 블록 업스트림을 사용하여 버스 신호를 만들거나, 비 버스 신호에 대해 블록의 출력 파라미터를 ''신호 복사''로 설정하십시오.</entry>
    <entry key="BlockConfiguredToExpectNonVirtualBus">Signal Conversion 블록 ''{0}''이(가) 비가상 버스를 가상 버스로 변환하도록 구성되어 있습니다. 그런데 입력 신호가 이미 가상 버스 신호입니다. 이 경고가 발생하지 않도록 하려면 이 블록에서 파라미터 '출력 파라미터'를 '신호 복사'로 변경하십시오.</entry>
    <entry key="BlockConfiguredToExpectVirtualBus">Signal Conversion 블록 ''{0}''이(가) 가상 버스를 비가상 버스로 변환하도록 구성되어 있습니다. 그런데 입력 신호가 이미 비가상 버스 신호입니다. 이 경고가 발생하지 않도록 하려면 이 블록에서 파라미터 '출력 파라미터'를 '신호 복사'로 변경하십시오.</entry>
    <entry key="BlockContinuousFrame">Continuous-time input signals are not allowed for ''{0}'' because it is operating in frame-based mode</entry>
    <entry key="BlockDoesNotSupportMultiExecInstances">Simulink does not support block ''{0}'' inside subsystem ''{1}'' because the subsystem contains a For Each block (''{2}'').</entry>
    <entry key="BlockDoesNotSupportMultiExecInstancesWithCustomMsg">Simulink does not support block ''{0}'' inside subsystem ''{1}'' because the subsystem contains a For Each block (''{2}''). Open the following message for detail.</entry>
    <entry key="LoggingBlockDoesNotSupportMultiExecInstancesWithCustomMsg">서브시스템 ''{1}''에 For Each 블록(''{2}'')이 들어 있기 때문에 이 서브시스템 내에서 블록 ''{0}''에 대한 기록은 지원되지 않습니다. 자세한 내용을 보려면 다음 메시지를 여십시오.</entry>
    <entry key="BlockElapseTimeOverflow">마지막 두 트리거 사이의 시간이 너무 길어서 경과 시간 카운터에 32비트가 넘는 비트가 사용되었습니다. 이 경우 블록 {0}이(가) 정확한 계산을 수행할 수 없습니다.</entry>
    <entry key="BlockFrameInputPortParameter">Invalid dimensions specified for input port of ''{0}''. The input dimensions should be of the form ''[F x {1,number,integer}]'' to match the dimensions of one or more of its parameters</entry>
    <entry key="BlockFrameMatrixParameter">Invalid parameters specified for ''{0}'' which is operating in frame-based mode. In this mode, all parameters must either be scalars or row vectors whose lengths match the number of frame channels</entry>
    <entry key="BlockFrameOutputPortParameter">''{0}''의 출력 포트에 대해 지정된 차원이 유효하지 않습니다. 하나 이상의 파라미터에 대한 차원과 일치시키려면 출력 차원이 ''[F x {1,number,integer}]'' 형식이어야 합니다.</entry>
    <entry key="BlockHasUnappliedChanges">시뮬레이션을 실행하기 전에 ''{0}''에서 적용되지 않은 변경 내용을 적용하거나 취소합니다.</entry>
    <entry key="BlockTypeStrExists">Cannot register block ''{0}'' in module ''{1}''. This block was previously registered in module ''{2}''.</entry>
    <entry key="BlockWithExplicitICFeedingEmptyOutport">Outport ''{0}''의 초기 출력이 []로 설정되어 있습니다. 이로 인해 예기치 않은 초기화가 발생할 수 있습니다. Subsystem ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;가 Outport 소스 ''{3}''과(와) 동일한 초기값을 갖도록 하려면 ''{4}''에서 이 초기 출력값을 명시적으로 설정하십시오. 이 경고 메시지를 끄려면 &lt;sldiag objui="configset" objparam="CheckSSInitialOutputMsg"&gt;정의되지 않은 서브시스템 초기 출력 확인&lt;/sldiag&gt;의 선택을 취소하십시오.</entry>
    <entry key="BlockWithExplicitICFeedingEmptyOutportConsistentOutportInit">Outport ''{0}''의 초기 출력이 []로 설정되어 있습니다. 이로 인해 예기치 않은 초기화가 발생할 수 있습니다. Subsystem ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;가 Outport 소스 ''{3}''과(와) 동일한 초기값을 갖도록 하려면 ''{4}''에서 이 초기 출력값을 명시적으로 설정하십시오. 이 문제를 해결하려면 &lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;과소 지정된 초기화 감지&lt;/sldiag&gt;를 '단순 방식'으로 설정하십시오. 또한 업그레이드 어드바이저를 사용해 "Outport 및 Merge 블록 초기화 파라미터의 일관성 검사"를 수행하여 단순 방식 초기화 모드로 마이그레이션할 수도 있습니다. 이 경고 메시지를 끄려면 &lt;sldiag objui="configset" objparam="CheckSSInitialOutputMsg"&gt;정의되지 않은 서브시스템 초기 출력 확인&lt;/sldiag&gt;의 선택을 취소하십시오.</entry>
    <entry key="MultipleWarningsBlkWithExpICFeedingEmptyOutport"> 모델 ''{0}''에 위 경고의 Outport 블록과 동일한 문제를 나타내는 Outport 블록이 총 {1,number,integer}개 있습니다.</entry>
    <entry key="BlockWithFewExplicitICsFeedingEmptyOutport">Outport ''{0}''의 초기 출력이 []로 설정되어 있습니다. 이로 인해 예기치 않은 초기화가 발생할 수 있습니다. Subsystem ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;가 Outport 소스 {3}과(와) 동일한 초기값을 갖도록 하려면 ''{4}''에서 이 초기 출력값을 명시적으로 설정하십시오. 이 경고 메시지를 끄려면 &lt;sldiag objui="configset" objparam="CheckSSInitialOutputMsg"&gt;정의되지 않은 서브시스템 초기 출력 확인&lt;/sldiag&gt;의 선택을 취소하십시오.</entry>
    <entry key="BlockWithFewExplicitICsFeedingEmptyOutportConsistentOutportInit">Outport ''{0}''의 초기 출력이 []로 설정되어 있습니다. 이로 인해 예기치 않은 초기화가 발생할 수 있습니다. Subsystem ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;가 Outport 소스 {3}과(와) 동일한 초기값을 갖도록 하려면 ''{4}''에서 이 초기 출력값을 명시적으로 설정하십시오. 이 경고 메시지를 끄려면 &lt;sldiag objui="configset" objparam="CheckSSInitialOutputMsg"&gt;정의되지 않은 서브시스템 초기 출력 확인&lt;/sldiag&gt;의 선택을 취소하십시오.</entry>
    <entry key="BlockWithManyExplicitICsFeedingEmptyOutport">Outport ''{0}''의 초기 출력이 []로 설정되어 있습니다. 이로 인해 예기치 않은 초기화가 발생할 수 있습니다. Subsystem ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;가 Outport 소스 {3} 등과 동일한 초기값을 갖도록 하려면(목록에는 {4,number,integer}개의 블록이 있음) ''{5}''에서 이 초기 출력값을 명시적으로 설정하십시오. 이 경고 메시지를 끄려면 &lt;sldiag objui="configset" objparam="CheckSSInitialOutputMsg"&gt;정의되지 않은 서브시스템 초기 출력 확인&lt;/sldiag&gt;의 선택을 취소하십시오.</entry>
    <entry key="BlockWithManyExplicitICsFeedingEmptyOutportConsistentOutportInit">Outport ''{0}''의 초기 출력이 []로 설정되어 있습니다. 이로 인해 예기치 않은 초기화가 발생할 수 있습니다. Subsystem ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;가 Outport 소스 {3} 등과 동일한 초기값을 갖도록 하려면(목록에는 {4,number,integer}개의 블록이 있음) ''{5}''에서 이 초기 출력값을 명시적으로 설정하십시오. 이 경고 메시지를 끄려면 &lt;sldiag objui="configset" objparam="CheckSSInitialOutputMsg"&gt;정의되지 않은 서브시스템 초기 출력 확인&lt;/sldiag&gt;의 선택을 취소하십시오.</entry>
    <entry key="BmathLogOfNegativeNumber">''{0}''에 음수의 로그가 있습니다. ''출력 신호 유형''을 복소수로 설정해 보십시오.</entry>
    <entry key="BmathRcpSqrtOfNegativeNumber">''{0}''에 음수의 제곱근이 있습니다.</entry>
    <entry key="BmathSqrtOfNegativeNumber">Square root of a negative number in ''{0}''. Consider setting the ''Output signal type'' to complex.</entry>
    <entry key="BmathUndefinedResultOfPow2">2^u의 결과가 ''{0}''에 정의되어 있지 않습니다.</entry>
    <entry key="BmathUndefinedResultOfPow10">10^u의 결과가 ''{0}''에 정의되어 있지 않습니다.</entry>
    <entry key="BreakpointSetMustMatchTable">블록 ''{1}''의 절점 벡터 크기 {0,number,integer}은(는) 테이블의 대응하는 차원과 동일해야 합니다. 절점 벡터 크기는 {2,number,integer}이지만, 테이블의 대응하는 차원 크기는 {3,number,integer}입니다.</entry>
    <entry key="BreakpointSetsMustBeVector">블록 ''{1}''의 절점 벡터 {0,number,integer}은(는) 적어도 2개의 요소를 포함하는 벡터여야 합니다.</entry>
    <entry key="BusSelectorRequiresBusSignal">''{0}''의 입력 포트에 연결된 신호는 버스 신호가 아닙니다. Bus Selector 블록에 대한 입력은 가상 버스 신호 또는 비가상 버스 신호여야 합니다. \n이 오류는 버스 지원 블록(예: Merge 또는 Unit Delay) 사용으로 인해 발생할 수 있습니다. 현재 같은 이 상황에서는 버스 지원 블록이 이 오류에 보고된 블록에 버스 다운스트림을 전파할 수 없습니다. 복합(즉, 버스) 신호와 적절한 사용법에 대한 자세한 내용은 Simulink 도움말 문서를 참조하십시오.</entry>
    <entry key="BusAssignRequiresBusSignal">''{0}''의 &lt;sldiag objui="inport" objparam="1" objname="{0}"&gt;입력 포트 1&lt;/sldiag&gt;에 연결된 신호는 버스 신호가 아닙니다. Bus Assignment 블록에 대한 첫 번째 입력은 가상 버스 신호 또는 비가상 버스 신호여야 합니다. \n이 오류는 버스 지원 블록(예: Merge 또는 Unit Delay) 사용으로 인해 발생할 수 있습니다. 현재 같은 이 상황에서는 버스 지원 블록이 이 오류에 보고된 블록에 버스 다운스트림을 전파할 수 없습니다. 복합(즉, 버스) 신호와 적절한 사용법에 대한 자세한 내용은 Simulink 도움말 문서를 참조하십시오.</entry>
    <entry key="BusAssignmentDupAssignment">신호는 한 번만 할당될 수 있는데, ''{0}''이(가) 블록 ''{1}''에서 여러 번 할당되었습니다.</entry>
    <entry key="BusAssignmentCoveredAssignment">A signal can be assigned only once, but the assigned bus signal ''{0}'' fully covers the assigned signal ''{1}'' in block ''{2}''.</entry>
    <entry key="BusAssignmentInvOutSignal">''{1}''의 선택된 신호 ''{0}''이(가) Bus Assignment 블록에 들어오는 버스의 일부가 아닙니다. 이 오류는 Simulink가 해결할 수 없는 Bus Creator, Bus Selector 및 버스 지원 블록 관련 피드백 루프가 존재하는 경우 발생할 수 있습니다. 이 오류를 해결하는 방법에 대한 자세한 내용은 버스 신호에 대한 Simulink 도움말 문서를 참조하십시오.</entry>
    <entry key="BusAssignmentOutSignalNameUpdate">버스 계층 구조와 일치하도록, 선택된 신호 ''{0}''을(를) ''{2}''의 ''{1}''에 다시 매핑합니다. 이 변경 내용을 영구적으로 적용하려면 파일을 저장하십시오.</entry>
    <entry key="BusAssignmentAssignedSignalIsInsideAoB">The Bus Assignment block ''{0}'' could not replace signal ''{1}'', because this signal is inside an array of buses ''{2}''.</entry>
    <entry key="BusAssignmentInvalidAssignedSignal">Property ''AssignedSignals'' cannot be set to empty character vector.</entry>
    <entry key="BusAssignmentMismatchedAssignedSignal">Bus Assignment 블록 ''{1}''의 ''{0,number,integer}''번 포트에 있는 입력 버스 신호의 구조가 선택된 버스 신호 ''{2}''의 구조와 다릅니다.</entry>
    <entry key="BusAssignmentBusToSignalMismatch">Bus Assignment 블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;가 비 버스 신호를 받도록 구성되어 있습니다. 하지만 실제 입력은 버스 신호입니다.</entry>
    <entry key="BusAssignmentSignalToBusMismatch">Bus Assignment 블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;가 버스 신호를 받도록 구성되어 있습니다. 하지만, 실제 입력은 비 버스 신호입니다.</entry>
    <entry key="BusAssignmentUnconnectedAssignedBusSignal">Bus Assignment 블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;가 버스 신호를 받도록 구성되어 있습니다. 그런데 입력 포트가 연결되지 않았습니다.</entry>
    <entry key="BusBlkOutBadDims2">Error occurred while setting the dimensions of &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' to '{'{2}'}'. The signals contributing to this port indicate that the dimensions should be '{'{3}'}'.</entry>
    <entry key="BusCC_BusCheckFailed">블록 ''{0}''에 대한 입력 버스가 블록 대화 상자에서 버스 객체 ''{1}''에 의해 지정된 버스와 일치하지 않습니다. 다음 오류가 감지되었습니다:</entry>
    <entry key="BusCC_ElementDataTypeMismatch">Bus element ''{0}'' of bus object ''{1}'' is specified to be of data type ''{2}'', but the incoming signal has a data type of ''{3}''.</entry>
    <entry key="BusCC_ElementDimMismatch">Bus element ''{0}'' of bus object ''{1}'' is specified to be of dimensions {2}, but the incoming signal is of dimensions {3}.</entry>
    <entry key="BusCC_ElementRequireAOB">Bus element ''{0}'' of bus object ''{1}'' is specified to be an array of buses, but the incoming signal is a virtual bus. An array of buses must be a nonvirtual bus.</entry>
    <entry key="BusCC_ElementDimMismatchVectMatConv">Bus element ''{0}'' of bus object ''{1}'' is specified to be of dimensions {2}, but the incoming signal is of dimensions {3}. This error is due to the ''Vector/Matrix conversion'' diagnostic setting in the Diagnostics page of Configuration Parameters dialog. Try setting this diagnostic to ''None'' to eliminate this error.</entry>
    <entry key="BusCC_ElementDimensionsModeMismatch">Bus 객체 ''{1}''의 버스 요소 ''{0}''의 차원 모드가 ''{2}''인데, 들어오는 신호의 차원 모드는 ''{3}''입니다.</entry>
    <entry key="BusCC_ElementFramenessMismatch">Bus element ''{0}'' of bus object ''{1}'' is specified to be ''{2}'', but the incoming signal is ''{3}''.</entry>
    <entry key="BusCC_ElementNameMismatch">블록 ''{0}''은(는) ''{2}'' 이름의 신호를 갖는 버스를 수신하지만, Bus 객체 ''{1}''에 기반한 ''{3}'' 이름의 신호가 필요합니다.</entry>
    <entry key="BusCC_ElementNameMismatchWarning">블록 ''{0}''은(는) ''{2}'' 이름의 신호를 갖는 버스를 수신하지만, Bus 객체 ''{1}''에 기반한 ''{3}'' 이름의 신호가 필요합니다. 이 진단을 비활성화하려면 구성 파라미터 &gt; 진단 &gt; 연결성 &gt; ''요소 이름 불일치'' 옵션을 ''안 함''으로 설정하십시오.</entry>
    <entry key="BusCC_ElementNotABus">Bus 객체 ''{1}''의 버스 요소 ''{0}''이(가) 버스가 아닌데, 들어오는 신호는 버스입니다.</entry>
    <entry key="BusCC_ElementSampleTimeMismatch">Bus element ''{0}'' of bus object ''{1}'' is specified to be of sample time {2}, but the incoming signal is of sample time {3}.</entry>
    <entry key="BusCC_ElementSampleTimeMismatchForBusCreatorInExpandedSubsystem">The block ''{0}'' attempts to set the sample time of the outgoing bus to {1}, yet the bus is defined using bus object ''{2}'' which specifies that one or more of its elements are of sample time {3}. The bus object ''{4}'' must define its elements to have inherited sample times by assigning their sample time values to -1.</entry>
    <entry key="BusCC_ElementSignalTypeMismatch">Bus 객체 ''{1}''의 버스 요소 ''{0}''이(가) ''{2}''형으로 지정되었는데, 들어오는 신호는 ''{3}''입니다.</entry>
    <entry key="BusCC_InputNotABus">Bus 객체 ''{1}''의 버스 요소 ''{0}''이(가) 버스인데, 들어오는 신호는 버스가 아닙니다.</entry>
    <entry key="BusCC_InvalidBus">Bus 객체 ''{0}''이(가) 버스가 아닙니다.</entry>
    <entry key="BusCC_NumElementsMismatch">Bus 객체 ''{0}''에 {1,number,integer}개의 버스 요소가 있는데, 들어오는 버스에는 {2,number,integer}개의 신호가 있습니다.</entry>
    <entry key="BusCannotCacheCompBus">Unable to cache compiled bus structure for one of the block ports. The cause of this problem can be reinstantiation of library links or block replacement via callbacks during update diagram. Rerunning the command may fix this problem because the block may no longer need to be reinstantiated or replaced.</entry>
    <entry key="BusComp_ControlPortError1">The signal at &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of block ''{1}'' is of width {2,number,integer}. This must be a scalar for buses to successfully pass through this block.</entry>
    <entry key="BusComp_ControlPortError2">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 있는 신호가 {2}차원입니다. 버스가 이 블록을 성공적으로 통과하려면 이 값이 스칼라여야 합니다.</entry>
    <entry key="BusComp_DataTypeError">Incoming buses to block ''{0}'' have a data type mismatch. The signal at &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;input port {1,number,integer}&lt;/sldiag&gt; of ''{2}'' is of data type ''{3}'', while its corresponding signal at &lt;sldiag objui="inport" objparam="{4,number,integer}" objname="{5}"&gt;input port {4,number,integer}&lt;/sldiag&gt; of ''{5}'' is of data type ''{6}''.</entry>
    <entry key="BusComp_DimensionsModeError">블록 ''{0}''에 들어오는 버스의 차원 모드가 일치하지 않습니다. ''{2}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;에 있는 신호의 차원 모드는 ''{3}''인데, ''{5}''의 &lt;sldiag objui="inport" objparam="{4,number,integer}" objname="{5}"&gt;{4,number,integer}번 입력 포트&lt;/sldiag&gt;에 있는 대응되는 신호의 차원 모드는 ''{6}''입니다.</entry>
    <entry key="BusComp_DimsError1">블록 ''{0}''에 들어오는 버스의 차원이 일치하지 않습니다. ''{2}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;에 있는 신호는 너비가 {3}인데, ''{5}''의 &lt;sldiag objui="inport" objparam="{4,number,integer}" objname="{5}"&gt;{4,number,integer}번 입력 포트&lt;/sldiag&gt;에 있는 대응되는 신호는 너비가 {6}입니다.</entry>
    <entry key="BusComp_DimsError2">블록 ''{0}''에 들어오는 버스의 차원이 일치하지 않습니다. ''{2}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;에 있는 신호는 {3}차원인데, ''{5}''의 &lt;sldiag objui="inport" objparam="{4,number,integer}" objname="{5}"&gt;{4,number,integer}번 입력 포트&lt;/sldiag&gt;에 있는 대응되는 신호는 {6}차원입니다.</entry>
    <entry key="BusComp_DimsNumError">블록 ''{0}''에 들어오는 버스의 차원이 일치하지 않습니다. ''{2}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;에 있는 신호의 차원 수는 {3,number,integer}인데, ''{5}''의 &lt;sldiag objui="inport" objparam="{4,number,integer}" objname="{5}"&gt;{4,number,integer}번 입력 포트&lt;/sldiag&gt;에 있는 대응되는 신호의 차원 수는 {6,number,integer}입니다.</entry>
    <entry key="BusComp_FrameError">블록 ''{0}''에 들어오는 버스의 프레임이 일치하지 않습니다. ''{2}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;에 있는 신호는 ''{3}''인데, ''{5}''의 &lt;sldiag objui="inport" objparam="{4,number,integer}" objname="{5}"&gt;{4,number,integer}번 입력 포트&lt;/sldiag&gt;에 있는 대응되는 신호는 ''{6}''입니다.</entry>
    <entry key="BusComp_SampleTimeError">블록 ''{0}''에 들어오는 버스의 샘플 시간이 일치하지 않습니다. ''{2}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;에 있는 신호는 샘플 시간이 {3}인데, ''{5}''의 &lt;sldiag objui="inport" objparam="{4,number,integer}" objname="{5}"&gt;{4,number,integer}번 입력 포트&lt;/sldiag&gt;에 있는 대응되는 신호는 샘플 시간이 {6}입니다.</entry>
    <entry key="BusComp_SignalTypeError">Incoming buses to block ''{0}'' have a signal type mismatch. The signal at &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;input port {1,number,integer}&lt;/sldiag&gt; of ''{2}'' is of type ''{3}'', while its corresponding signal at &lt;sldiag objui="inport" objparam="{4,number,integer}" objname="{5}"&gt;input port {4,number,integer}&lt;/sldiag&gt; of ''{5}'' is of type ''{6}''.</entry>
    <entry key="BusCreatorInvalidInputComplex">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;의 신호 유형을 복소수로 설정할 수 없습니다. 신호 유형은 실수여야 합니다.</entry>
    <entry key="BusCreatorInvalidInputDataType">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;의 데이터형을 {2}(으)로 설정할 수 없습니다. 필요한 데이터형은 {3}입니다.</entry>
    <entry key="BusCreatorInvalidInputReal">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;의 신호 유형을 실수로 설정할 수 없습니다. 신호 유형은 복소수여야 합니다.</entry>
    <entry key="BusCreatorInvalidInputUnit">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;의 단위를 {2}(으)로 설정할 수 없습니다. 필요한 단위는 {3}입니다.</entry>
    <entry key="BusCreatorInvalidOutputComplex">''{0}''의 출력 신호 유형을 복소수로 설정할 수 없습니다. 출력 신호 유형은 실수여야 합니다.</entry>
    <entry key="BusCreatorInvalidOutputDataType">''{0}''의 출력 데이터형을 {1}(으)로 설정할 수 없습니다. 출력 데이터형은 {2,number,integer}개의 요소를 가진 구조체형이어야 합니다.</entry>
    <entry key="BusCreatorInvalidOutputUnit">''{0}''의 출력 단위를 {1}(으)로 설정할 수 없습니다. 출력은 단위가 없어야 합니다.</entry>
    <entry key="BusInputSignalNotSupportedByForEach">The signal at input {0,number,integer} is a bus signal for subsystem ''{1}''. The corresponding Inport block is set to partition the input signal in the block dialog of the For Each block ''{2}''. A bus input signal can not be partitioned by subsystem ''{3}''. However, subsystem ''{4}'' can accept a bus signal if the corresponding Inport is not selected for partitioning.</entry>
    <entry key="BusObjectAtMdlrefInportNotConsistent">The bus data type ''{0}'' specified for the block ''{1}'' and the bus data type ''{2}'' specified for input {3,number,integer} of ''{4}'' are inconsistent; they must be the same.</entry>
    <entry key="BusObjectAtBusCreatorInputNotConsistent">The bus data type ''{0}'' specified for the block ''{1}'' and the bus data type ''{2}'' specified for input {3,number,integer} of ''{4}'' are inconsistent; they must be the same.</entry>
    <entry key="SignalConversionSaveAsParameters">Signal Conversion 블록의 [변환 출력] 파라미터의 [신호 복사] 옵션은 ''{0}''에서 사용할 수 없습니다. 따라서, [변환 출력]이 [신호 복사]로 설정된 이 모델의 모든 Signal Conversion 블록은 [변환 출력]이 [인접 복사본]으로 설정된 상태로 저장됩니다.</entry>
    <entry key="BusObjectAtSignalConversionNotConsistent">The bus object ''{0}'' specified on the Signal Conversion block ''{1}'' does not match the bus object ''{2}'' specified on the Signal Conversion block's input port. This could be caused by a different bus data type being specified on an upstream block, such as a Bus Creator block, than the one specified on the Signal Conversion block.</entry>
    <entry key="SignalConversionVirtualBusContiguousCopy">Signal Conversion 블록 ''{0}''의 입력이 가상 버스입니다. 이 블록은 인접 벡터를 생성하도록 구성되어 있습니다. R2011b 이전에는 버스를 벡터로 변환하는 작업이 이 블록의 입력 포트에서 자동으로 수행되었습니다. R2011b 이상에서는 \"인접 복사본\" 옵션이 \"신호 복사\" 옵션으로 대체되었습니다. 이 경고가 발생하지 않도록 하려면 가상 버스 입력이 벡터로 변환되도록 Signal Conversion 블록의 입력 포트에 Bus To Vector 블록을 삽입해 보십시오.</entry>
    <entry key="SignalConversionVirtualBusSignalObject">The Simulink.Signal object specified on the line originating from &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is not allowed because it cannot be mapped uniquely to a non-virtual signal. To resolve this issue, consider inserting a Bus To Vector block at the input of the Signal Conversion block. Alternatively, you can change the \"Output\" option of the Signal Conversion block to \"Nonvirtual bus\" and specify a Simulink.Bus object on the block.</entry>
    <entry key="SignalConversionVirtualBusSignalObject2">The Simulink.Signal object specified on the line originating from &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' is not allowed because it cannot be mapped uniquely to a non-virtual signal. To resolve this issue, consider changing the \"Output\" option of the Signal Conversion block to \"Nonvirtual bus\".</entry>
    <entry key="BusObjectAtRootOutportNotConsistent">The bus data type ''{0}'' specified for the block ''{1}'' and the bus data type ''{2}'' specified by ''{3}'' are inconsistent; they must be identical since they both correspond to the same bus type.</entry>
    <entry key="BusObjectNeededForRootOutport">버스가 입력 포트에 들어가고 있기 때문에 블록 ''{0}''에 대한 버스 데이터형을 지정해야 합니다.</entry>
    <entry key="BusObject_SampleTimeMismatch">All elements of bus object ''{0}'' must inherit their sample time or specify the same sample time ({1}).</entry>
    <entry key="BusSelDupBusCreatorSigNames">Signals entering Bus Creator ''{0}'' have duplicated names at input ports: {1}\nAll signals in the resulting bus are being made unique by appending \"(signal #)\". Please update the labels of the signals such that they are all unique.</entry>
    <entry key="BusSelDupMuxSigNames">Signals entering Mux ''{0}'' have duplicated names at input ports: {1}\nAll signals in the resulting bus are being made unique by appending \"(signal #)\". Please update the labels of the signals such that they are all unique.</entry>
    <entry key="BusSelInvBusCreatorSigNames">Bus Creator ''{1}''에 들어오는 신호 {0,number,integer}에 \".\" 및/또는 \",\" 문자가 포함되어 있습니다. 이 문자를 각각 \":\" 및 \";\"으로 대체하여 이 블록에 대한 새 이름이 생성됩니다.</entry>
    <entry key="BusSelInvMuxSigNames">Mux ''{1}''에 들어오는 신호 {0,number,integer}에 \".\" 및/또는 \",\" 문자가 포함되어 있습니다. 이 문자를 각각 \":\" 및 \";\"으로 대체하여 이 블록에 대한 새 이름이 생성됩니다.</entry>
    <entry key="BusSelectorCantChangeSignalLabel">Bus Selector를 연결하는 선의 신호 레이블은 변경할 수 없습니다.</entry>
    <entry key="BusSelectorDuplicateLeafSignalInMuxedOutput">Bus Selector block ''{0}'' might cause incorrect results because the output bus contains signals with duplicate names. Include each signal in the output bus no more than once, rename input signals to have unique names, or clear "Output as virtual bus" and create the bus with a Bus Creator block.</entry>
    <entry key="BusSelectorInputDuplicateSignalNames">입력 버스에 이름이 ''{1}''인 요소가 여러 개 포함되어 있기 때문에 Bus Selector 블록 ''{0}''이(가) 수신하는 버스를 지원하지 않습니다.</entry>
    <entry key="SynthesizedBusSelectorInputDuplicateSignalNames">Block ''{0}'' does not support the bus it receives because the input bus contains multiple elements named ''{1}''.</entry>
    <entry key="DuplicateSignalInBusFromBusSelectorMuxedOutput">블록 ''{0}''에서 오는 출력 버스 신호에 중복된 이름을 갖는 신호가 포함되어 있으며, 이로 인해 기록에서 잘못된 결과가 발생할 수 있습니다. 중복된 이름을 갖는 버스는 기록할 수 없습니다.</entry>
    <entry key="BusSelectorEvalPrmInvOutSignal">Selected signal ''{0}'' in ''{1}'' is not part of the bus entering the Bus Selector. One probable cause of this error is the use of Mux blocks instead of Bus Creator blocks to create buses in this model. Consider changing the ''Mux blocks used to create bus signals'' diagnostic to ''error'' in this model and replace any Muxes that are then reported with Bus Creators. Another possible cause of this error is the use of a bus-capable block (such as Merge or Unit Delay) that in this current situation is unable to propagate the bus downstream to the block reported in this error. Please see Simulink documentation for further information on composite (i.e. bus) signals and their proper usage.</entry>
    <entry key="BusSelectorExpectsBusInput">유효한 버스 신호를 Bus Selector 블록 ''{0}''에 연결해야 합니다.</entry>
    <entry key="SubrefInportExpectsBus">유효한 버스 신호를 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 연결해야 합니다.</entry>
    <entry key="BusSelectorInvBusObject">블록 ''{1}''에 대해 Bus 객체 ''{0}''을(를) 불러올 수 없습니다. \n 지정된 Bus 객체가 MATLAB 작업 공간에 존재하지 않거나 \nSimulink.Bus 유형이 아닙니다.</entry>
    <entry key="BusSelectorInvOutSignal">''{1}''의 선택된 신호 ''{0}''이(가) Bus Selector에 들어오는 버스의 일부가 아닙니다. 이 오류는 Simulink가 해결할 수 없는 Bus Creator, Bus Selector 및 버스 지원 블록 관련 피드백 루프가 존재하는 경우 발생할 수 있습니다. 이 오류를 해결하는 방법에 대한 자세한 내용은 버스 신호에 대한 Simulink 도움말 문서를 참조하십시오.</entry>
    <entry key="BusSelectorOutSignalNameUpdate">버스 계층 구조와 일치하도록, 선택된 신호 ''{0}''을(를) ''{2}''의 ''{1}''에 다시 매핑합니다. 이 변경 내용을 영구적으로 적용하려면 파일을 저장하십시오.</entry>
    <entry key="BusSelectorUnconnected">''{0}'' must be connected to a Bus Creator, Bus Selector or a bus capable block. \n A possible cause of this error is the use of a bus-capable block (such as Merge or Unit Delay) that in this current situation is unable to propagate the bus downstream to the block reported in this error. Please see Simulink documentation for further information on composite (i.e. bus) signals and their proper usage.</entry>
    <entry key="BusSelectorSelectionInsideAoB">Bus Selector 블록 ''{1}''에서 선택한 신호 ''{0}''은(는) 서브 버스로 구성된 배열 내의 버스 요소를 참조하므로 유효하지 않습니다. 서브 버스로 구성된 배열에 대한 경로는 ''{2}''입니다. Bus Selector 블록을 사용하여 버스 내 요소에 액세스하려면 먼저 Selector 블록을 사용하여 적절한 배열 요소를 선택하십시오. </entry>
    <entry key="PhyRouterGeneral">물리적 연결 라우터: ''{0}''</entry>
    <entry key="BrancherHierStringMatlabName">Hierarchy string ''{0}'' specified for child port ''{1,number,integer}'' is not a valid MATLAB variable name. </entry>
    <entry key="SimscapeBusBlockDesc">이 블록은 여러 연결을 하나의 Simscape Bus 선으로 묶습니다. 이 블록을 사용하여 기존 Simscape Bus 선에서 하나 이상의 연결에 액세스할 수도 있습니다. 자동 포트 만들기 기능을 사용하여 새 연결을 이 블록에 추가합니다.</entry>
    <entry key="LabelledConnNodeBlockDesc">이 블록은 물리적 선을 사용하지 않고 두 개의 Simscape 블록 간에 가상 연결을 만드는 데 사용됩니다. 그러면 Simscape 블록 다이어그램을 지저분하게 만드는 요소가 정리됩니다. </entry>
    <entry key="PhyRouterLoopBan">Compilation terminated because of a connection loop involving Simscape blocks ''{0}''.</entry>
    <entry key="ConnectionLabelBlockLoopBan">Compilation terminated because of a connection loop involving Connection Label blocks ''{0}''.</entry>
    <entry key="PhyRouterPhysicalSignalBan">Physical signals are not allowed into Simscape buses; check connection ports on block ''{0}''.</entry>
    <entry key="LabelledConnectionNodesPhysicalSignalBan">Physical signals are not allowed into Connection Label blocks; check connection port on block ''{0}''.</entry>
    <entry key="NonNetworkEngineBan">The connection attached to child port {0,number,integer} on Simscape Bus block ''{1}'' is not allowed to participate in Simscape buses.</entry>
    <entry key="LabelledConnectionNodesNonNetworkEngineBan">The connection attached to the Connection Label block ''{0}'' is not supported.</entry>
    <entry key="InvalidHierStringInSimscapeBusDialog">지정된 계층 구조 문자열이 유효한 MATLAB 변수 이름이 아닙니다. </entry>
    <entry key="BusSelectorSelectionInsideAoBForLogging">
      The signal for logging at ''{0}'' block is a virtual bus that contains an array of bus at ''{1}''.
      Logging does not support an array of bus inside a virtual bus.
      Please convert this virtual bus to a non-virtual bus or disable logging for this port.</entry>
    <entry key="BusSelectorSelectionInsideAoBForBusExp">
      The input signal for ''{0}'' block is a virtual bus that contains an array of bus at ''{1}''.
      This block does not support an array of bus inside a virtual bus.
      Please convert this virtual bus to a non-virtual bus.</entry>
    <entry key="BusSelectorMuxedOutputsDoesNotSupportAOB">Bus Selector block, ''{0}'', has the ''Output as virtual bus'' option enabled, but that setting is not supported for an array of buses input signal or an input signal containing an array of buses.</entry>
    <entry key="BusSupHierarchyMismatch">신호 ''{0}''은(는) 버스인데 신호 ''{1}''은(는) 버스가 아니므로 ''{2}''에 대한 입력 버스가 서로 같지 않습니다.</entry>
    <entry key="BusSupNamesMismatch">신호 ''{0}''은(는) 신호 ''{1}''과(와) 이름이 일치하지 않으므로 ''{2}''에 대한 입력 버스가 서로 같지 않습니다.</entry>
    <entry key="BusSupNumSignalsMismatch">''{0}''에 대한 입력 버스에 포함된 신호 개수가 서로 다릅니다.</entry>
    <entry key="SignalSpecBlockInputBusTypeMismatch">Signal Specification 블록에서 입력 버스 유형이 일치하지 않습니다. ''{0}''의 입력에서 버스 신호가 ''{1}''인데 Signal Specification 블록의 대화 상자에서 ''비가상 버스가 필요함''에 지정된 설정에 따라 이 블록에는 ''{2}''이(가) 필요합니다.</entry>
    <entry key="CGIRUnSupBlockType">블록 ''$PATH$''이(가) {0} 유형입니다. $PRODUCT$은(는) 이 유형의 블록을 지원하지 않습니다.</entry>
    <entry key="CGIRUnSupLookUp2DComplex">Lookup Table (2-D) 블록 ''$PATH$''의 테이블 데이터 파라미터가 복소수 값입니다. $PRODUCT$은(는) 복소수 출력값을 지원하지 않습니다.</entry>
    <entry key="CGIRUnSupLookUp2DDataType">Lookup Table (2-D) 블록 ''$PATH$''의 출력 포트의 데이터형이 {0}입니다. $PRODUCT$은(는) 이 데이터형을 지원하지 않습니다.</entry>
    <entry key="CGIRUnSupLookUp2DHetrCol">Lookup Table (2-D) 블록 ''$PATH$''의 열 인덱스 입력 포트 및 출력 포트의 데이터형이 각각 {0} 및 {1}입니다. $PRODUCT$은(는) 입력 포트와 출력 포트의 데이터형이 서로 다른 것을 지원하지 않습니다.</entry>
    <entry key="CGIRUnSupLookUp2DHetrRow">Lookup Table (2-D) 블록 ''$PATH$''의 행 인덱스 입력 포트 및 출력 포트의 데이터형이 각각 {0} 및 {1}입니다. $PRODUCT$은(는) 입력 포트와 출력 포트의 데이터형이 서로 다른 것을 지원하지 않습니다.</entry>
    <entry key="CGIRUnSupLookUp2DMethod">Lookup Table (2-D) 블록 ''$PATH$''의 룩업 방법 파라미터가 {0}(으)로 구성되어 있습니다. $PRODUCT$은(는) 이 방법을 지원하지 않습니다.</entry>
    <entry key="CGIRUnSupLookUpComplex">Lookup Table 블록 ''$PATH$''은(는) 복소수 값 신호를 출력합니다. $PRODUCT$은(는) 복소수 출력값을 지원하지 않습니다.</entry>
    <entry key="CGIRUnSupLookUpDataType">Lookup Table 블록 ''$PATH$''의 출력 포트의 데이터형이 {0}입니다. $PRODUCT$은(는) 이 데이터형을 지원하지 않습니다.</entry>
    <entry key="CGIRUnSupLookUpHetr">Lookup Table 블록 ''$PATH$''의 입력 포트와 출력 포트의 데이터형이 각각 {0} 및 {1}입니다. $PRODUCT$은(는) 입력 포트와 출력 포트의 데이터형이 서로 다른 것을 지원하지 않습니다.</entry>
    <entry key="CGIRUnSupLookUpMethod">Lookup Table 블록 ''$PATH$''의 룩업 방법 파라미터가 {0}(으)로 구성되어 있습니다. $PRODUCT$은(는) 이 방법을 지원하지 않습니다.</entry>
    <entry key="CGIRUnSupNnZOffset">블록 ''$PATH$''의 컴파일된 샘플 시간은 {0}입니다. $PRODUCT$은(는) 값이 0이 아닌 샘플 시간 오프셋을 갖는 블록을 지원하지 않습니다.</entry>
    <entry key="CGIRUnSupSfunc">$PRODUCT$은(는) 블록 ''$PATH$''에서 호출된 S-Function {0}을(를) 지원하지 않습니다.</entry>
    <entry key="CacheCompiledBusStruct">블록 ''{0}''에 대한 CacheCompiledBusStruct 파라미터의 설정이 유효하지 않습니다. 이 파라미터는 Subsystem Inport 블록, Outport 블록 및 Bus Creator 블록에 대해 설정될 수 있습니다.</entry>
    <entry key="CancelMsg">취소</entry>
    <entry key="CannotChangePortComplexSignal">''{3}''의 {1} {2,number,integer}번 포트의 복소 신호가 설정된 경우 S-Function 메서드 {0}은(는) 이 신호를 변경할 수 있습니다.</entry>
    <entry key="CannotChangePortDataType">S-function method {0} cannot change the data type of {1} port {2,number,integer} of ''{3}'' once the data type has been set</entry>
    <entry key="CannotChangePortDimensions">''{3}''의 {1} {2,number,integer}번 포트의 차원이 설정된 경우 S-Function 메서드 {0}은(는) 이 차원을 변경할 수 없습니다.</entry>
    <entry key="CannotChangePortWidth">''{3}''의 {1} {2,number,integer}번 포트의 너비가 설정된 경우 S-Function 메서드 {0}은(는) 이 너비를 변경할 수 없습니다.</entry>
    <entry key="CannotChangePortUnit">''{3}''의 {1} {2,number,integer}번 포트의 단위가 설정된 경우 S-Function 메서드 {0}은(는) 이 단위를 변경할 수 없습니다.</entry>
    <entry key="CannotConvToVarDimsFrame">''{0}'' cannot convert a variable-size sample-based signal to a variable-size frame-based signal. The size of the first dimension of a variable- size sample-based signal can change during execution. In contrast, the frame-based signal (e.g., [m x n]) must keep its frame length (i.e., m) fixed.</entry>
    <entry key="CannotExtrapData">''{0}'' extrapolation of integer and fixed-point data are not supported by block ''{1}''. In addition, ''{0}'' extrapolation requires that the 'Intermediate results' and 'Output' data types must be the same floating-point data type.</entry>
    <entry key="CannotFindSignalInStrictMode">Bus Selector 블록 ''{1}''의 입력 신호에서 신호 {0}을(를) 찾을 수 없습니다.</entry>
    <entry key="CannotGetSimStateForSFcnWithPWork">Simulink is unable to save the operating point of the {0} S-Function ({1}) block ''{2}'' because the S-function has pointer work (PWork) vectors.</entry>
    <entry key="CannotSetSimStateForSFcnWithPWork">S-Function에 포인터 작업(PWork) 벡터가 있으므로 {0} S-Function({1}) 블록 ''{2}''에 대한 동작점을 복원할 수 없습니다.</entry>
    <entry key="CannotSplitFrameData">''{0}''의 입력에 있는 다중화된 프레임 정보를 다양한 출력 포트로 분할할 수 없습니다. 입력에 있는 다중화된 신호가 {1,number,integer}개의 개별 신호에 대한 프레임 정보에 대응됩니다. 다양한 신호의 프레임 정보가 다양한 출력 포트에서 어떻게 분할되어야 하는지에 대한 정보가 블록 대화 상자에 충분히 없는 것이 문제일 수 있습니다.</entry>
    <entry key="CaseConditionsNotCoverEnums">''{1}''의 ''{0}''이(가) 열거형 데이터형인데, 열거형 데이터형의 모든 기본 값을 포함하지는 않으며 default case가 활성화되어 있지 않습니다.</entry>
    <entry key="CaseNonIntegerInput">Noninteger input truncated at port {0,number,integer} of {1}</entry>
    <entry key="CaseOverflowIntegerInput">{1}의 {0,number,integer}번 포트에서 오버플로 정수 입력값이 잘림</entry>
    <entry key="ColMismatch">''{1}''에 대한 {0}의 요소 개수는 출력 테이블의 열 개수와 일치해야 함</entry>
    <entry key="CollapsedParamRefPartitionedMaskParam">Parameter ''{0}'' of block ''{1}'' cannot reference partitioned mask parameter ''{2}'' of For Each subsystem ''{3}'' because parameter ''{4}'' will be reduced to a numerical value.</entry>
    <entry key="CompileNeededForForeachSubsysCompliant">모델 ''{0}''에서 파라미터 ''ForeachIteratorSubsystemCompliant''에 액세스하려면 모델을 컴파일된 상태로 두어야 합니다.</entry>
    <entry key="CompileNeededForForeachSubsysIncompliantBlkList">모델 ''{0}''에서 파라미터 ''ForeachIteratorSubsystemCompliantBlocks''에 액세스하려면 모델을 컴파일된 상태로 두어야 합니다.</entry>
    <entry key="ConcatBusTypesMustBeSame">{1,number,integer}번 입력 포트에서 ''{0}''에 대해 유효하지 않은 연결이 감지되었습니다. Concatenate 블록에서는 비 버스 신호와 버스 신호를 함께 사용할 수 없습니다. 버스로 구성된 배열을 만들 때 Concatenate 블록에 대한 모든 입력을 동일한 신호 이름과 계층 구조를 갖는 비가상 버스로 만드십시오.</entry>
    <entry key="ConcatInputPortCurrDimsMismatch">Mismatch of current input port dimensions has been detected in ''{0}''. When concatenating variable-size signals, the current sizes of dimensions other than the concatenate dimension must match for all input ports. This requirement is violated along dimension {1,number,integer} of the {2,number,integer}-th input port because its current size {3,number,integer} is not the same as the current size {4,number,integer} specified by the first input port.</entry>
    <entry key="ConcatInvalidCurrDimsInVectorMode">Simulink가 시간 {3}에서 블록 ''{2}''에 대한 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;의 차원 {0,number,integer}에서의 유효하지 않은 런타임 차원 0을 감지했습니다. 벡터 모드의 경우, 입력값이 2차원 벡터이면 결합되지 않는 차원은 고정 값 1이어야 합니다.</entry>
    <entry key="ConcatInvalidDimsInVectorMode">Invalid dimensions {0} encountered from the input ports of Concatenate block ''{1}''. In vector mode, Concatenate blocks with multiple input signals can accept only scalars, 1-D vectors, and either row-vectors or column-vectors (but not both).</entry>
    <entry key="ConfigSubInvChoice">블록 선택지 ''{0}''은(는) ''{1}''의 유효한 멤버가 아님</entry>
    <entry key="ConfigSubInvPortBlockChoice">Block choice ''{0}'' is a port block and hence an invalid member of ''{1}''</entry>
    <entry key="ConfigSubInvMembers">Cannot set member block list for configurable subsystem instance ''{0}''</entry>
    <entry key="ConfigSubInvSubMember">''{0}'' must not be an enabled or triggered subsystem to be a valid choice</entry>
    <entry key="ConfigSubInvTemplate">Cannot change the template parameter for ''{0}''</entry>
    <entry key="ConfigSubInvUsage">''{0}'' must be placed in a library to be used</entry>
    <entry key="ConfigSubMissingChoice">''{0}''에 블록 선택지가 없음</entry>
    <entry key="ConfigSubMissingMember">멤버 ''{0}''이(가) ''{1}''에 존재하지 않음</entry>
    <entry key="ConfigSubOpenMasterError">''{0}'' must be placed in a library to be used</entry>
    <entry key="ConfigSubSaveLibrary">구성 가능한 서브시스템 템플릿을 만들기 전에 라이브러리를 저장해야 합니다.</entry>
    <entry key="ConfigSubVirgin">''{0}''이(가) 구성되지 않음</entry>
    <entry key="ConjComplexHasNoNonZeroBiasSupport">Math Function 블록 ''{0}''에는 복소수 입력값에 0이 아닌 편향이 있어야 함</entry>
    <entry key="CoreFactoryNotFound">Cannot find a valid core factory with name ''{0}''.</entry>
    <entry key="DSAccessedByRTWSFunction">Data store diagnostics are being disabled for the block ''{0}'' because its data store is accessed by the block ''{1}'', which is an S-function generated.</entry>
    <entry key="DSMNameNotInDomain">블록 ''{0}''이(가) 원래 데이터 저장소 이름 ''{1}''을(를) ''{2}''에 매핑합니다. 하지만 ''{3}''의 자식이 원래 데이터 저장소 이름을 사용하여 동일한 데이터 저장소를 사용하려고 합니다.</entry>
    <entry key="DSMNameInvalid">블록 ''{0}''이(가) 유효하지 않은 데이터 저장소 이름 ''{1}''을(를) 지정합니다.</entry>
    <entry key="DSMNameNotUnique">블록 ''{0}''이(가) 데이터 저장소 이름 ''{1}''을(를) 여러 번 지정합니다.</entry>
    <entry key="DSMNameValueMismatch">블록 ''{0}''에 {1,number,integer}개의 데이터 저장소 이름이 있지만, 데이터 저장소 값은 {2,number,integer}개 있습니다.</entry>
    <entry key="DSMNameValueUnsupported">블록 ''{0}''이(가) 데이터 저장소 매핑을 지정할 수 없습니다.</entry>
    <entry key="DSMValueInvalid">The block ''{0}'' specifies an invalid data store value ''{1}''</entry>
    <entry key="DSMValueNotUnique">블록 ''{0}''이(가) 데이터 저장소 값 ''{1}''을(를) 여러 번 지정합니다.</entry>
    <entry key="DSMemoryComplexICWithBooleanSignal">Data Store Memory block ''{0}'' has a complex Initial value yet specifies that its ''Data type'' is boolean. You can resolve this by specifying a non-complex Initial value.</entry>
    <entry key="DSMemoryComplexICWithRealSignal">Data Store Memory block ''{0}'' has a complex Initial value yet specifies that its ''Signal type'' is ''real''. You can resolve this by specifying the ''Signal type'' be ''complex'', or by applying the ''real'' function to the specified Initial value to convert it to a non-complex value, e.g. real(ICValue)</entry>
    <entry key="DSMemoryDimensionsError">Simulink.Signal 객체 ''{0}''은(는) 모델 ''{1}''에 대한 Data Store Memory 블록을 나타내므로 속성 ''차원''은 -1이 아닐 수 있음</entry>
    <entry key="DSMemoryDimensionsModeError">Simulink.Signal 객체 ''{0}''은(는) 모델 ''{1}''에 대한 Data Store Memory 블록을 나타내므로 속성 ''차원 모드''는 ''가변 차원 모드''일 수 없습니다. Data Store Memory 블록은 가변 차원 모드를 지원하지 않습니다.</entry>
    <entry key="DSMemoryFramesError">Global Simulink.Signal object ''{0}'' implies a Data Store Memory block for the model ''{1}'', so the property ''SamplingMode'' cannot be set to ''Frame based''</entry>
    <entry key="DSMemoryLoggingBlockAsyncSampleTime">Data Store Memory 블록 ''{0}''이(가) 기록되도록 설정되었지만 비동기 샘플 시간을 사용합니다. 따라서 이 Data Store Memory 블록에 대해 데이터가 기록되지 않습니다.</entry>
    <entry key="DSMemoryLoggingBlockCustomDType">Data Store Memory 블록 ''{0}''이(가) 기록되도록 설정되었으며 데이터형이 ''{1}''입니다. 내장 데이터형, 고정소수점 데이터형 및 열거형 데이터형에 대해서만 기록이 지원됩니다. 따라서 이 Data Store Memory 블록에 대해 데이터가 기록되지 않습니다.</entry>
    <entry key="DSMemoryLoggingBlockNoFixedPt">Data Store Memory 블록 ''{0}''이(가) 기록되도록 설정되었으며 데이터형이 고정소수점입니다. Fixed-Point Designer 라이선스를 사용할 수 없습니다. 따라서 이 Data Store Memory 블록에 대해 데이터가 기록되지 않습니다.</entry>
    <entry key="DSMemoryLoggingDecimateDataInconsistency">The Data Store Memory block ''{0}'' resolves to Simulink.Signal object ''{1}'' and has inconsistent logging information for DecimateData.</entry>
    <entry key="DSMemoryLoggingDecimationInconsistency">The Data Store Memory block ''{0}'' resolves to Simulink.Signal object ''{1}'' and has inconsistent logging information for Decimation.</entry>
    <entry key="DSMemoryLoggingLimitDataInconsistency">The Data Store Memory block ''{0}'' resolves to Simulink.Signal object ''{1}'' and has inconsistent logging information for LimitDataPoints.</entry>
    <entry key="DSMemoryLoggingMaxPointsInconsistency">The Data Store Memory block ''{0}'' resolves to Simulink.Signal object ''{1}'' and has inconsistent logging information for MaxPoints.</entry>
    <entry key="DSMemoryLoggingMdlRefAccel">전역 Data Store Memory 변수 ''{0}''이(가) 액셀러레이터 모드에서 실행 중인 참조된 모델 ''{1}''에서 직접 또는 간접적으로 액세스됩니다. 전역 변수는 표준 모드에서만 기록될 수 있습니다. 이 변수에 대해 데이터가 기록되지 않습니다.</entry>
    <entry key="DSMemoryLoggingNameInconsistency">The Data Store Memory block ''{0}'' resolves to Simulink.Signal object ''{1}'' and has inconsistent logging information for LoggingName. The block uses ''{2}'' and the Signal object uses ''{3}''.</entry>
    <entry key="DSMemoryLoggingNameModeInconsistency">The Data Store Memory block ''{0}'' resolves to Simulink.Signal object ''{1}'' and has inconsistent logging information for NameMode.</entry>
    <entry key="DSMemoryLoggingSimMode">현재 모델이 Data Store Memory를 기록하도록 구성되었지만 Data Store Memory 기록은 표준 모드 시뮬레이션에서만 지원됩니다. 따라서 Data Store Memory 블록 또는 전역 변수가 기록되지 않습니다. 이 경고가 발생하지 않도록 하려면 [구성 파라미터] 대화 상자의 [데이터 가져오기/내보내기] 페이지에서 Data Store Memory 기록 옵션의 선택을 취소하십시오.</entry>
    <entry key="DSMemoryLoggingVariableCustomDType">Data Store Memory 변수 ''{0}''이(가) 기록되도록 설정되었으며 데이터형이 ''{1}''입니다. 내장 데이터형, 고정소수점 데이터형 및 열거형 데이터형에 대해서만 기록이 지원됩니다. 따라서 이 Data Store Memory에 대해 데이터가 기록되지 않습니다.</entry>
    <entry key="DSMemoryLoggingVariableNoFixedPt">Data Store Memory 변수 ''{0}''이(가) 기록되도록 설정되었으며 데이터형이 고정소수점입니다. Fixed-Point Designer 라이선스를 사용할 수 없습니다. 따라서 이 Data Store Memory에 대해 데이터가 기록되지 않습니다.</entry>
    <entry key="DSMemoryOwnedByAncestorDynamicComplexity">전역 Simulink.Signal 객체 ''{0}''은(는) 참조 모델 ''{1}''의 전역 Data Store Memory 블록을 나타내므로, 속성 ''실수/복소수 여부''를 ''자동''으로 설정해서는 안 됨</entry>
    <entry key="DSMemoryOwnedByAncestorDynamicDataType">Global Simulink.Signal object ''{0}'' implies a global Data Store Memory block for the reference model ''{1}'', so the property ''DataType'' must not be set to ''auto''</entry>
    <entry key="DSRegisteredAfterEvalParams">블록 ''{0}''이(가) mdlInitializeSizes가 아닌 루틴에서 데이터 저장소 메모리를 등록하려 하는데, 이는 허용되지 않습니다.</entry>
    <entry key="DTConvComplexToBool">Complex number cannot be converted to boolean in ''{0}''</entry>
    <entry key="DTConvCustomNoStoreInt">The parameter ''ConvertRealWorld'' in ''{0}'' is set to ''Stored integer''. ''Stored integer'' can only be used when both input and output ports are set to MATLAB built-in data types or fixed-point data types. Currently the data types are user-defined</entry>
    <entry key="DTConversionUncessary">''{0}''은(는) 불필요한 데이터형 변환입니다. 입력 데이터형과 출력 데이터형이 동일합니다&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="DTConversionComplex2Enum">The input port of block ''{0}'' is complex but output port is of enumeration type. This conversion is invalid.</entry>
    <entry key="DemuxBadBusVectorParam">''{1}''의 파라미터 {0}에 사용된 벡터가 포트 정보를 지정하기에 유효하지 않습니다. 벡터에 양의 정수인 유한한 0이 아닌 요소가 있어야 합니다.</entry>
    <entry key="DemuxCannotSplitMatrices">''{0}''의 입력 포트의 차원에 대한 설정이 유효하지 않습니다. Demux는 행렬을 분할하는 데 사용할 수 없습니다.</entry>
    <entry key="DemuxCellOnlyInBusMode">Invalid parameter ''{0}'' specified for ''{1}''. This parameter does not support cell array as input.</entry>
    <entry key="DemuxDimsInfoMismatch1">''{0}''의 입력 포트의 차원에 대한 설정이 유효하지 않습니다. {1,number,integer}개의 다중화된 신호에 대응되는 차원을 갖도록 포트를 설정하는 중입니다. 블록 대화 상자에 지정된 정보가 충분하지 않아 이러한 신호가 출력에 어떻게 표시되는지 확인할 수 없습니다. 셀형 배열 형식을 사용하여 출력 포트 차원을 지정해 보십시오.</entry>
    <entry key="DemuxDimsInfoMismatch2">''{0}''의 입력 포트의 차원에 대한 설정이 유효하지 않습니다. {1,number,integer}개의 다중화된 신호에 대응되는 차원을 갖도록 이 포트를 설정하는 중이지만, 출력 포트는 {2,number,integer}개의 다중화된 신호가 필요하도록 설정되었습니다.</entry>
    <entry key="DemuxInValidPortWidths">''{0}''의 입력 포트 차원에 대한 설정이 유효하지 않습니다. 차원이 {1}(으)로 설정되고 있습니다. 입력 요소와 출력 요소의 총 개수가 같지 않기 때문에 이 설정은 유효하지 않습니다.</entry>
    <entry key="DemuxMatricesOnlyInBusIn">''{0}''의 입력 포트에 대한 차원 설정이 유효하지 않습니다. 차원을 '{'{1}'}'(으)로 설정하는 중입니다. 버스 선택 모드인 경우에만 Demux가 행렬을 처리하기 때문에 이것은 허용되지 않습니다.</entry>
    <entry key="DemuxMatricesOnlyInBusOut">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 대한 차원 설정이 유효하지 않습니다. 차원이 '{'{2}'}'(으)로 설정되고 있습니다. 버스 선택 모드인 경우에만 Demux가 행렬을 처리하기 때문에 이것은 허용되지 않습니다.</entry>
    <entry key="DemuxPortLargerThanOutDims">''{0}''의 입력 포트 차원에 대한 설정이 유효하지 않습니다. 차원이 {1}(으)로 설정되고 있습니다. 입력의 요소 수가 출력 포트에 있는 요소의 총 개수({2,number,integer})보다 작기 때문에 이것은 유효하지 않습니다.</entry>
    <entry key="DemuxSplittingInBusMode">Invalid setting for input port dimensions in ''{0}''. In bus selection mode, the input to the Demux must be a composite signal that was generated by a Bus Creator or Mux.</entry>
    <entry key="DemuxOutputsFcnCallWithGroundSrc">Code generation is not supported because the signal at &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of the Demux block ''{1}'' is a function-call signal but its input is grounded or unconnected.</entry>
    <entry key="DerivJacobian">선형화 시간이 Inf로 설정된 경우 Derivative 블록은 0으로 선형화됩니다. 선형화 시간 파라미터에 유한수를 사용해 보십시오.</entry>
    <entry key="DetermismMustBeOffForAsyncTrateTrans">Rate Transition 블록 ''{0}''의 소스 또는 대상이 비동기 태스크와 연결되어 있기 때문에 데이터 전송의 결정성(determinism)을 보장할 수 없습니다. Rate Transition 블록의 ''결정적 데이터 전송 보장'' 파라미터를 선택 취소하십시오.</entry>
    <entry key="DetermismMustBeOffForExportedTaskTrateTrans">Rate Transition 블록 ''{0}''의 소스 또는 대상이 내보낸 태스크와 연결되어 있기 때문에 데이터 전송의 결정성(determinism)을 보장할 수 없습니다. Rate Transition 블록의 ''결정적 데이터 전송 보장'' 파라미터를 선택 취소하십시오.</entry>
    <entry key="DeterminismMustBeOffForAperiodicRateTrans">
      Rate Transition 블록 ''{0}''의 소스 또는 대상이 비주기적 분할과 연결되어 있기 때문에 데이터 전송의 결정성(determinism)을 보장할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="Deterministic"&gt; &lt;cmd&gt;set_param_action(''{0}'', ''Deterministic'',''off'');&lt;/cmd&gt; &lt;txt&gt;Rate Transition 블록의 ''결정적 데이터 전송 보장'' 파라미터를 선택 취소하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
      
    </entry>
    <entry key="DIntInvStateInitTrigTs">
      Discrete-Time Integrator 블록 ''{0}''에는 주기적인 샘플 시간이 필요합니다. 샘플 시간을 변경하고 싶지 않으면 다음 중 하나를 수행하십시오. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param_action(''{0}'', ''IntegratorMethod'', ''Accumulation: Forward Euler'');&lt;/cmd&gt; &lt;txt&gt;''적분기 방법''을 ''누적: 순방향 오일러''로 설정합니다.&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param_action(''{0}'', ''IntegratorMethod'', ''Accumulation: Backward Euler'');&lt;/cmd&gt; &lt;txt&gt;''적분기 방법''을 ''누적: 역방향 오일러''로 설정합니다.&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param_action(''{0}'', ''IntegratorMethod'', ''Accumulation: Trapezoidal'');&lt;/cmd&gt; &lt;txt&gt;''적분기 방법''을 ''누적: 사다리꼴''로 설정합니다.&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param_action(''{0}'', ''InitialConditionSetting'', ''Output'');&lt;/cmd&gt; &lt;txt&gt;트리거된 샘플 시간의 소스가 주기적인 샘플 시간이면 ''초기 조건 설정''을 ''출력''으로 설정할 수 있습니다.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
      
    </entry>
    <entry key="DIntInvStateInitTrigTsInExpFcnMdl">Discrete-Time Integrator 블록 ''{0}''에서 파라미터 '초기 조건 설정'이 '상태(가장 효율적)'로 설정되어 있고 파라미터 '적분기 방법'이 누적 방법이 아니기 때문에 주기적인 샘플 시간이 필요합니다. 함수 내보내기 모델에서, 함수 호출 루트 수준 Inport 블록에 의해 직접 구동되는 Function-Call Subsystem에 Integrator 블록을 배치하십시오. Subsystem 블록의 Trigger Port 블록에 대한 '샘플 시간 유형'을 '주기적'으로 설정하고 루트 수준 Inport 블록에 대해 주기적인 샘플 시간을 지정하십시오.</entry>
    <entry key="DirectLookupNdBlockIndexOutOfRangeErrorMsg">블록 ''{0}''에서 입력이 테이블의 차원을 초과합니다</entry>
    <entry key="EnforceDirectLookupNdBlockIndexOutOfRangeErrorMsg">블록 ''{0}''에서 입력이 테이블의 차원을 초과합니다. '입력값이 범위 내에 있다고 가정' 파라미터를 선택 해제하거나 입력값을 테이블 차원의 범위 내에 있도록 제한하십시오.</entry>
    <entry key="DirectLookupNdBlockIndexOutOfRangeWarnMsg">블록 ''{0}''에서 입력이 테이블의 차원을 초과합니다. 입력을 고정하고 계속합니다.</entry>
    <entry key="DirectLookupNdBlockNumOfIndexOutOfRangeWarnMsg">블록 ''{0}''에서 입력이 테이블 차원을 {1,number,integer}번 초과했습니다.</entry>
    <entry key="DirectLookupNdIndexInputsSpecMsg">블록 ''{0}''에서, 인덱스 입력 포트는 프레임 기반이 아니고 복소수가 아닌 신호여야 하며, 내장 데이터형(double, single, int8, uint8, int16, uint16, int32, uint32, 부울)이거나 또는 편향 0, 소수부 길이 0, 기울기 1.0인 고정소수점 데이터형이어야 하며, 워드 길이가 65535보다 작거나 같아야 합니다.</entry>
    <entry key="DirectLookupNdInputDimensionsCannotBeDeterminedMsg">블록 ''{0}''에 차원 정보가 충분하지 않아 입력 포트 차원을 확인할 수 없습니다. 권장 사항: 업스트림 블록을 사용하여 입력 포트 차원을 지정하십시오.</entry>
    <entry key="DirectLookupNdInputDimensionsMutuallyIncompatibleMsg">For block ''{0}'', input port dimensions must follow scalar expansion rules: non-scalar port dimensions must all be identical</entry>
    <entry key="DirectLookupNdNumInputsInvMsg">In block ''{0}'', specified output dimensions exceeds table dimensions. Choose output shape (dimensions) up to 2-D and equal to or less than table dimensions</entry>
    <entry key="DirectLookupNdOutputPortDimsIncompatibleMsg">출력 포트가 블록 ''{0}''에서 지정된 입력 차원과 호환되지 않습니다.</entry>
    <entry key="DirectLookupNdOutputTypeMustMatchTableMsg">블록 ''{0}''에서 출력 포트의 데이터형은 테이블 파라미터의 데이터형과 일치해야 합니다.</entry>
    <entry key="DirectLookupNdInvIndexPortType">In block ''{0}'', the index port data type must be one of the following: ''boolean'', ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', ''double'', or ''fixed-point''. Fixed-point data type must have bias equal to 0, slope equal to 1.0, fractional length equal to 0, and word length less than or equal to 65535.</entry>
    <entry key="DirectLookupNdOutputTypeMustMatchTablePortMsg">블록 ''{0}''에서 출력 포트의 데이터형은 테이블 입력 포트의 데이터형(''T''로 표시됨)과 일치해야 합니다.</entry>
    <entry key="DirectLookupNdTableDimsMustMatchExplicitMsg">블록 ''{0}''에서 ''테이블 데이터''의 차원 수는 지정된 명시적 값과 일치하거나, 1차원 테이블 데이터의 행 또는 열 행렬이어야 합니다</entry>
    <entry key="DirectLookupNdTableInOutComplexityMatchMsg">블록 ''{0}''에서 출력 포트의 실수/복소수 여부는 테이블 입력 포트의 실수/복소수 여부(''T''로 표시됨)와 일치해야 합니다.</entry>
    <entry key="DirectLookupNdTableOutComplexityMatchMsg">블록 ''{0}''에서 출력 포트는 테이블의 실수/복소수 여부와 일치해야 합니다.</entry>
    <entry key="DirectLookupNdTablePortDimensionMustBeSpecMsg">블록 ''{0}''에 테이블 포트 차원이 지정되어 있어야 하며, 역으로 상속될 수 없습니다. 권장 사항: 업스트림 블록을 사용하여 테이블 포트 차원을 지정하십시오.</entry>
    <entry key="DirectLookupNdUnsupportedDataTypeInTableMsg">블록 ''{0}''의 테이블 파라미터에 지원되지 않는 데이터형입니다.</entry>
    <entry key="DirectLookupNdTableDimSizeOutOfRange">블록 ''{0}''에서 테이블 요소 개수가 모델의 [하드웨어 구현] 설정에 구성된 정수 크기의 최대 한도 ''{1, number, integer}''보다 큽니다.</entry>
    <entry key="DisallowTuning">In ''{0}'', you cannot tune the leading filter coefficient from a nonzero value to zero or vice versa while a simulation is running, because this changes the direct feedthrough status of the block</entry>
    <entry key="DiscIntegratorWeightNonPositive">Discrete Integrator {1}의 파라미터 {0}의 값은 양수여야 합니다.</entry>
    <entry key="DiscIntegratorSaturPortDataTypeConflict">Discrete-time Integrator 블록 ''{0}''에서 포화 포트의 데이터형 ''{1}''이(가) 출력 포트의 데이터형 ''{2}''과(와) 충돌합니다. 입력과 출력이 동일한 부동소수점 데이터형(double형 또는 single형)인 경우 포화 포트는 출력과 동일한 데이터형을 가져야 합니다.</entry>
    <entry key="DiscInvDisagreeInternalRuleDType">Discrete-time Integrator 블록 ''{0}''의 데이터형 전파가 오류를 발생시킵니다. 원인은 다음 요구 사항 중 하나를 위반하기 때문입니다. (1) 첫 번째 출력, 상태 및 외부 초기 조건의 데이터형이 동일해야 함. (2) 포화 출력의 데이터형이 double형, single형 또는 int8형이어야 함. (3) 입력과 출력이 동일한 부동소수점 데이터형(double형 또는 single형)인 경우 포화 포트는 출력과 동일한 데이터형을 가져야 함.</entry>
    <entry key="DiscNonSupportSaturPortType">Discrete-time Integrator 블록 ''{0}''에서 데이터형 전파 오류가 발생합니다. 포화 포트의 데이터형은 double형, single형 또는 int8형이어야 합니다. 이는 포화 포트가 세 개의 출력값(1.0, 0.0, -1.0)을 나타내야 하기 때문입니다.</entry>
    <entry key="DiscreteFirAllDataTypeMustBeSigned">''{0}''의 입력 데이터형 또는 계수 데이터형이 부호가 있는 경우 해당 누산기, 곱 연산 출력 및 출력 데이터형은 부호가 있어야 합니다.</entry>
    <entry key="DiscreteFirAllDataTypeMustBeUnsigned">''{0}''의 입력 데이터형과 계수 데이터형이 모두 부호가 없는 경우 해당 누산기, 곱 연산 출력 및 출력 데이터형은 부호가 없어야 합니다.</entry>
    <entry key="AllpoleAllDataTypeMustBeSigned">''{0}''의 계수, 누산기, 곱 연산 출력 및 출력 데이터형은 부호가 있어야 합니다.</entry>
    <entry key="DiscreteFirAllInputPortsMustHaveSameDataType">The input and the coefficients of ''{0}''must have the same data type.</entry>
    <entry key="DiscreteFirBinaryScalingOnly">''{0}'' supports binary point-only scaling. For all fixed-point data types, the slope must be a power of two and the bias must be zero.</entry>
    <entry key="DiscreteFirHomogeneousDataType">''{0}''에 사용된 데이터형은 모두 배정밀도이거나, 모두 단정밀도이거나, 모두 고정소수점이어야 합니다.</entry>
    <entry key="DiscreteFirInitialValueMustBeReal">모든 Direct form 필터 구조에 대해 입력이 실수인 경우 ''{0}''의 ''초기 상태'' 파라미터가 실수여야 합니다.</entry>
    <entry key="DiscreteFirInitialValueMustBeScalarOrMatrix">The ''Initial states'' parameter of ''{0}''must either be a scalar or a matrix with the same number of dimensions as the number of filter states.</entry>
    <entry key="DiscreteFirMatrixInputNotAllowed">''{0}''의 계수(Num) 포트에서는 행렬 입력이 지원되지 않습니다.</entry>
    <entry key="DiscreteFirStateWriteNonFloatInput">블록 ''{0}''의 입력이 부동소수점이 아닙니다. State Writer/State Reader 블록을 Discrete FIR Filter와 함께 사용할 경우에는 부동소수점 입력만 지원됩니다.</entry>
    <entry key="DiscreteIIRBaseJacobianNotSupported">이 블록의 선형화는 실수 값의 스칼라 입력, 실수 값의 필터 계수, 대화 상자에 지정된 파라미터 및 샘플 기반 처리에 대해서만 지원됩니다.</entry>
    <entry key="DiscreteFirBaseJacobianNotSupported">이 블록의 선형화는 실수 값의 스칼라 입력, 실수 값의 필터 계수, 대화 상자에 지정된 파라미터 및 샘플 기반 처리에 대해서만 지원됩니다.</entry>
    <entry key="DisplaySINeedsNumericDType">블록 ''{0}''은(는) 숫자 데이터형의 신호에 대해 저장된 정수 값만 표시할 수 있습니다.</entry>
    <entry key="DisplaySINeedsNumericOrDateTimeDType">Block ''{0}'' can only display stored integer values for signals of numeric or DateTime data types.</entry>
    <entry key="WarnEventNameCollision">이벤트 이름 충돌 감지</entry>
    <entry key="WarnEventNameCollisionInfo">이벤트 ''{0}''은(는) ''{1}'' 함수로 정의되었으므로 \n''{2}'' 함수로 재정의할 수 없습니다.</entry>
    <entry key="DetectEventNameCollision">
  이벤트 ''{0}''은(는) 블록 ''{1}''에서 '재초기화'로 정의되어 있습니다. 하지만 블록 ''{2}''에서 '재설정'으로도 정의되어 있는데, 이는 허용되지 않습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="KeepOn"&gt; &lt;cmd&gt;set_param_action(''{2}'', ''EventType'',''Reinitialize'');&lt;/cmd&gt; &lt;txt&gt;블록 ''{2}''의 이벤트 유형을 '재초기화'로 변경하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit" id="KeepOff"&gt; &lt;cmd&gt;set_param_action(''{1}'', ''EventType'',''Reset'');&lt;/cmd&gt; &lt;txt&gt;블록 ''{1}''의 이벤트 유형을 '재설정'으로 변경하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
  
</entry>
    <entry key="EventListenerBlockCannotBeAddedAtTopLevel">Event Listener 블록을 모델 ''{0}''의 최상위 수준에 추가하는 중입니다. 이것은 허용되지 않습니다.</entry>
    <entry key="EventListenerCannotBeAddedToSSHavingEventListenerBlock">서브시스템 ''{0}''에 Event Listener 블록이 이미 포함되어 있습니다. 이러한 서브시스템에는 Event Listener 블록을 더 추가할 수 없습니다.</entry>
    <entry key="EventListenerCannotBeAddedToSSHavingControlPorts">Event Listener block is being added to subsystem ''{0}''. Event Listener blocks can only be added to subsystems which do not already contain control port blocks like Enable or Trigger port blocks.</entry>
    <entry key="EventListenerInSSWithControlPorts">Event Listener 블록이 제어 포트 블록이 포함된 서브시스템 ''{0}'' 내에 있습니다. Event Listener 블록은 Enable Port 또는 Trigger Port 블록과 같은 제어 포트 블록이 아직 포함되지 않은 서브시스템에만 추가할 수 있습니다.</entry>
    <entry key="DuplicateDomainConfiguratorBlocks">''{0}''에 이미 도메인 구성 블록이 포함되어 있습니다. 도메인 구성 블록을 더 추가할 수 없습니다.</entry>
    <entry key="AdditionOfSSHavingEventListenerToGraphHavingEventListener">An Initialize, Reset, or Terminate Function block is being added within the Initialize, Reset, or Terminate Function block ''{0}''. This is not allowed.</entry>
    <entry key="FilterCoefMustBeRowVector">Filter coefficients in ''{0}'' must be a row vector.</entry>
    <entry key="FilterCoefMustBeRowVectorWarn">''{0}''에 대한 입력 필터 계수는 행 벡터여야 합니다. Reshape 블록을 사용하여 필터 계수를 행 벡터로 전치할 수 있습니다. 모델에 Reshape 블록을 자동으로 배치하려면 업그레이드 어드바이저를 실행하십시오.</entry>
    <entry key="FilterCirularFixedPointSpecNotAllowed">When the product output data type of ''{0}'' is set to 'Inherit: Inherit via internal rule', the output data type must be specified explicitly or set to 'Inherit: Same as input'.</entry>
    <entry key="varSizeChannelsNotSupported">''{0}''에 대한 입력이 가변 크기 신호이면 입력 채널 수는 고정된 상태로 유지되어야 합니다.</entry>
    <entry key="IIRFilterCirularFixedPointSpecNotAllowed">When the denominator product output data type of ''{0}'' is set to 'Inherit: Inherit via internal rule', the output data type must be specified explicitly or set to 'Inherit: Same as input'.</entry>
    <entry key="DiscreteFirOnlySignedDataTypeAllowed">Only signed data types are allowed when ''{0}''performs complex arithmetic.</entry>
    <entry key="DiscreteFirOutputDataTypeMismatch">''{0}''의 출력 포트의 데이터형이 블록 대화 상자의 ''출력 데이터형'' 파라미터와 일치하지 않습니다.</entry>
    <entry key="DiscreteFirSIMONotAllowed">Single-input/multiple-output (SIMO) mode is only supported by the direct form and direct form transposed filter structures of ''{0}''.</entry>
    <entry key="DiscreteFirScalarCoefNotAllowed">''{0}''의 Direct-Form 대칭 필터 구조 및 Direct-Form 반대칭 필터 구조는 1보다 긴 계수 길이만 지원합니다.</entry>
    <entry key="DiscreteFirStateDataTypeMustBeSigned">''{0}''의 상태 데이터형은 부호가 있어야 합니다.</entry>
    <entry key="DiscreteFirStateDataTypeMustBeUnsigned">''{0}''의 상태 데이터형은 부호가 없어야 합니다.</entry>
    <entry key="DiscreteFirTapSumDataTypeMustBeSigned">''{0}''의 탭 합계 데이터형은 부호가 있어야 합니다.</entry>
    <entry key="DiscreteFirTapSumDataTypeMustBeUnsigned">''{0}''의 탭 합계 데이터형은 부호가 없어야 합니다.</entry>
    <entry key="DivideByZero">''{0}''에 0으로 나누기 발생&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="DivideZeroByZero">''{0}''에서 0을 0으로 나누기 발생</entry>
    <entry key="DomainTypeStrExists">모듈 ''{1}''에 도메인 ''{0}''을(를) 등록할 수 없습니다. 이 도메인은 모듈 ''{2}''에 이전에 등록되었습니다.</entry>
    <entry key="DotProductInvalidInputPortComplexity">블록 ''{0}''의 출력이 실수인데, 하나 이상의 입력이 복소수임</entry>
    <entry key="DotProductInvalidOutputPortComplexity">블록 ''{0}''의 출력이 복소수인데, 두 입력이 모두 실수임</entry>
    <entry key="DtypeDuplicateInvInputPorts">블록 ''{0}''에서 지정된 입력 포트의 개수는 유한한 양수여야 합니다.</entry>
    <entry key="DtypeDuplicateInvBusInputs">Block ''{0}'' requires all its input ports to have the same bus type. Input port {1,number,integer} of this block expects a nonvirtual bus, while input port {2,number,integer} expects a non-bus or virtual bus signal.</entry>
    <entry key="DupBlockName">이름 ''{0}''이(가) 이미 ''{1}''에 존재합니다. 참고: 이름에서는 줄 바꿈과 공백이 동일하게 처리됩니다</entry>
    <entry key="DupDataLogFileName1">''{1}''에 중복되는 데이터 기록 파일 이름 ''{0}''이(가) 지정되었습니다.</entry>
    <entry key="DupDataLogFileName2">''{0}''은(는) 중복되는 데이터 기록 파일입니다. ''{1}''과(와) ''{2}''에 지정된 파일 이름 파라미터가 동일한 파일로 해석됩니다. 파일 이름은 서로 다른 파일로 해석되어야 합니다.</entry>
    <entry key="DupDataLogFileName3">'Log Dataset data to file' file name ''{0}' is a duplicate of a file name already specified by a To File block in the model hierarchy. The file for the To File block could be in a low-level subfolder, possibly using the UNIX soft link mechanism.</entry>
    <entry key="DupGotoTagVisBlockFound0">Duplicate goto tag visibility scopes named ''{0}'' found</entry>
    <entry key="DupGotoTagVisBlockFound1">First reference is in ''{0}''</entry>
    <entry key="DupGotoTagVisBlockFound2">Second reference is in ''{0}''</entry>
    <entry key="DupToFileFromFileFileName">데이터 기록 및 불러오기 파일 ''{0}''이(가) 중복됩니다. ''{1}''과(와) ''{2}''에 지정된 파일 이름 파라미터가 동일한 파일로 해석됩니다. 동일한 시뮬레이션을 같은 파일에 쓰거나 같은 파일에서 읽어올 수 없습니다.</entry>
    <entry key="EmptyName">''{0}''의 이름을 빈 문자형 벡터로 설정할 수 없음</entry>
    <entry key="EmptyRTWFcnName">The ''Function name'' field in ''{0}'' is empty and cannot be used as the function name. Enter a non-empty and valid function name.</entry>
    <entry key="EmptyRTWFileName">The ''File name'' field in ''{0}'' is empty and cannot be used as the file name. Enter a non-empty and valid file name.</entry>
    <entry key="EnablePortExists">An enable port already exists in subsystem ''{0}''. Addition of a second enable port is not allowed.</entry>
    <entry key="ErrBdMuxBlksUsedAsBusCreator">블록 다이어그램 ''{0}''에서 Mux 블록 {1,number,integer}개를 Bus Creator로 잘못 사용하고 있습니다. 다음 목록에는 최대 10개의 잘못 사용된 Mux 블록이 나와 있습니다.</entry>
    <entry key="ExceedDisplayBlockLimit">Block ''{0}'' shows truncated signal data. The Display block can show up to 200 elements of vector or matrix signals.</entry>
    <entry key="ExpResultUndefined">exp 연산 결과가 ''{0}''의 NaN 입력값에 대해 정의되어 있지 않습니다.</entry>
    <entry key="ExpResultSaturates">exp 연산 결과가 ''{0}''에서 무한대로 포화됩니다.</entry>
    <entry key="FXP_1BitSigned">''{0}''에서 데이터형의 설정이 유효하지 않음: 부호 있는 1비트 데이터형은 지원되지 않습니다.</entry>
    <entry key="FXP_AutoSign">''{0}''에서 데이터형의 설정이 유효하지 않음: 데이터형을 설명하는 MATLAB 구조체의 ''부호의 유무'' 필드는 ''부호 있음'' 또는 ''부호 없음'' 데이터형을 지정해야 합니다.</entry>
    <entry key="FXP_DlgParamNotRealVect">''{0}''에서 파라미터의 설정이 유효하지 않음: 대화 상자 파라미터는 실수형 벡터여야 합니다.</entry>
    <entry key="FXP_DlgParamNumElt">''{0}''에서 파라미터의 설정이 유효하지 않음: 대화 상자 파라미터가 잘못된 개수의 요소를 지정합니다.</entry>
    <entry key="FXP_MantissaGt0">Invalid setting for data type in ''{0}'': Mantissa bits must be greater than or equal to 1 and less than or equal to {1,number,integer}</entry>
    <entry key="FXP_MantissaNotEmpty">''{0}''에서 데이터형의 설정이 유효하지 않음: 데이터형을 설명하는 MATLAB 구조체의 ''MantBits'' 필드는 ''double'' 데이터형을 사용하여 0보다 큰 값을 지정해야 합니다.</entry>
    <entry key="FXP_NotRecognizedType">''{0}''에서 데이터형의 설정이 유효하지 않음: 지정된 데이터형을 인식할 수 없습니다.</entry>
    <entry key="FXP_SignedDoubleNotEmpty">''{0}''에서 데이터형의 설정이 유효하지 않음: 데이터형을 설명하는 MATLAB 구조체의 ''IsSigned'' 필드는 ''double'' 데이터형으로 구성된 비어 있지 않은 배열을 지정해야 합니다.</entry>
    <entry key="FXP_SlopeInf">''{0}''에서 데이터형의 설정이 유효하지 않음: 기울기는 ''Inf''일 수 없습니다.</entry>
    <entry key="FXP_SlopeNaN">''{0}''에서 데이터형의 설정이 유효하지 않음: 기울기는 ''NaN''일 수 없습니다.</entry>
    <entry key="FXP_SlopeNormalized">''{0}''에서 데이터형의 설정이 유효하지 않음: 소수부 기울기(fSlope)는 1 &lt;= fSlope &lt; 2를 충족하는 범위에서 정규화되어야 합니다.</entry>
    <entry key="FXP_UnsupportedType">''{0}''에서 데이터형의 설정이 유효하지 않음: 숫자 데이터형만 지원됩니다.</entry>
    <entry key="FactoryStrExists">모듈 ''{1}''에 팩토리 ''{0}''을(를) 등록할 수 없습니다. 이 도메인은 모듈 ''{2}''에 이전에 등록되었습니다.</entry>
    <entry key="FcnBlkIndexErr">''{1}''의\n표현식 {0}에\n범위를 벗어난 첨자가 있음</entry>
    <entry key="FcnBlkMatchErr">''{1}''의\n표현식 {0}을(를) 구문 분석하는 중 오류가 발생함\n토큰 "{2}"이(가) 발견되었지만 "{3}"이(가) 필요함</entry>
    <entry key="FcnBlkOnlyDblAndSgl">''{1}''의 {0,number,integer}번 포트의 데이터형을 {2}(으)로 설정할 수 없습니다. 데이터형은 double형 또는 single형이어야 합니다.</entry>
    <entry key="FcnBlkSyntaxErr">''{1}''의\n표현식 {0}에\n구문 오류가 있음</entry>
    <entry key="FcnBlkUIdxMustBeNum">Input ("u") index must be a positive integer in the expression: {0}\nin ''{1}''\nwhen used for code generation</entry>
    <entry key="FcnCallSplitInvalidNumOutputs">출력(''{0}'')의 개수가 올바르지 않습니다. 이 값은 2보다 크거나 같은 정수여야 합니다.</entry>
    <entry key="FcnInputWidthErr">''{0}''에 대한 표현식에 오류가 있습니다. 입력 인덱스가 입력 너비({1,number,integer})를 초과합니다.</entry>
    <entry key="FindIncompatibleOutputSize">블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;의 크기를 설정할 수 없습니다. FIND 블록의 출력 포트는 1차원 크기만 받습니다.</entry>
    <entry key="FindInvalidNumPorts">The number of output ports of ''{0}'' must be greater than zero.</entry>
    <entry key="FindIxPortNumberMismatch">''{0}''의 입력 차원 수가 {1,number,integer}(으)로 설정되었지만, 입력 신호에는 {2,number,integer}개의 차원이 있습니다. 입력 차원의 수를 지정하는 파라미터를 수정하십시오.</entry>
    <entry key="FindJacobian">Find 블록의 야코비 행렬은 입력 신호에 0이 없는 경우에만 정의됩니다. 입력 신호에 0이 있으면 출력 차원이 변경되고 야코비 행렬이 잘못 정의되게 됩니다.</entry>
    <entry key="FindWrongFixptType">블록 ''{0}''의 출력 포트에 유효하지 않은 데이터형이 지정되었습니다. 이 블록은 내장 데이터형 및 편향이 0이고 유니타리 기울기를 갖는 고정소수점 데이터형을 지원합니다.</entry>
    <entry key="FixPointSignalsWithNonZeroBias">''{0}'' does not support signals with a nonzero bias</entry>
    <entry key="FixptReciprocalHasNoComplexSupport">No complex fixed point support currently for Reciprocal in Math Function block ''{0}''</entry>
    <entry key="FixptSqrtHasNoComplexSupport">Math Function 블록 ''{0}''에서 sqrt의 복소수 입력에는 현재 고정소수점이 지원되지 않습니다.</entry>
    <entry key="ForInvalidNumItersParamWithOutputPortOn">The For Iterator block is configured to output iteration variable of type {0} in {1,number,integer}-based index mode. Under this configuration, the parameter ''{2}'' of the For Iterator block must evaluate to an integer within the range from {3} to {4}.</entry>
    <entry key="ForInvalidNumItersParamWithOutputPortOff">The For Iterator block is configured to operate in {0,number,integer}-based index mode. Under this configuration, the parameter ''{1}'' of the For Iterator block must evaluate to an integer within the range from {2} to {3}.</entry>
    <entry key="ForInvalidPortInputNumItersWithOutputPortOn">The For Iterator block is configured to output iteration variable of type {0} in {1,number,integer}-based index mode. Under this configuration, the input value at port {2,number,integer} of the For Iterator block must evaluate to an integer within the range from {3} to {4}. Therefore, Simulink truncates the input value {5} to {6} at time {7}.</entry>
    <entry key="ForInvalidPortInputNumItersWithOutputPortOff">The For Iterator block is configured to operate in {0,number,integer}-based index mode. Under this configuration, the input value at port {1,number,integer} of the For Iterator block must evaluate to an integer within the range from {2} to {3}. Therefore, Simulink truncates the input value {4} to {5} at time {6}.</entry>
    <entry key="ForInvalidExternalIncrement">다음 반복 변수의 유효하지 않은 값이 For Iterator 블록 ''{0}''에 전달되었습니다. double형 값 {1}은(는) 32비트 부호 있는 정수 범위 내에 있는 정수로 평가되어야 합니다.</entry>
    <entry key="FormatedBadSignalComplexityForUpperLowerLimit">''{0}''에서 신호의 실수/복소수 여부가 유효하지 않습니다. ''{1}''은(는) 복소수일 수 없습니다. 실수형 데이터만 받습니다.</entry>
    <entry key="FractionOutOfBounds">블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{0}" objname="{2}"&gt;입력 포트 {0}&lt;/sldiag&gt;{1,number,integer}번에 대해 소수부가 0.0보다 작거나 1.0보다 큽니다.</entry>
    <entry key="FractionOutOfBoundsFromBus">블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{0}" objname="{2}"&gt;입력 포트 {0}&lt;/sldiag&gt;{1,number,integer}번으로 전파된 bus 객체의 두 번째 신호에 대해 소수부가 0.0보다 작거나 1.0보다 큽니다.</entry>
    <entry key="EnforceFractionOutOfBounds">블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{0}" objname="{2}"&gt;입력 포트 {0}&lt;/sldiag&gt;{1,number,integer}번에 대해 소수부가 0.0보다 작거나 1.0보다 큽니다. '인덱스가 범위 내에 있다고 가정' 파라미터를 선택 해제하거나 입력값을 테이블 차원의 범위 내에 있도록 제한하십시오.</entry>
    <entry key="EnforceFractionOutOfBoundsFromBus">블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{0}" objname="{2}"&gt;입력 포트 {0}&lt;/sldiag&gt;{1,number,integer}번으로 전파된 bus 객체의 두 번째 신호에 대해 소수부가 0.0보다 작거나 1.0보다 큽니다. '인덱스가 범위 내에 있다고 가정' 파라미터를 선택 해제하거나 입력값을 테이블 차원의 범위 내에 있도록 제한하십시오.</entry>
    <entry key="FromFileBlkErr">''{0}''에서 오류 발생</entry>
    <entry key="FromFileNoLinearInterpolationForEnum">Enumerated data encountered in file ''{0}''. Linear interpolation or extrapolation is not supported for enumerated data. Change any interpolation or extrapolation settings to a value other than ''{1}'' or ''{2}''</entry>
    <entry key="FromFileInvEnumType">MAT 파일 ''{1}''의 데이터형 ''{0}''이(가) MATLAB에서 지정된 열거형 데이터형과 호환되지 않습니다. MAT 파일 데이터에 현재 클래스 정의에 존재하지 않는 열거형 이름이 포함되어 있거나 적어도 하나의 열거형 값이 현재 클래스 정의에 있는 대응값과 일치하지 않습니다. load(''{2}'') 명령을 사용하고, 데이터를 현재 클래스 정의와 일치하도록 업데이트한 후 MAT 파일을 다시 저장하십시오.</entry>
    <entry key="FromFileInvTimeVectorFull">''{0}''에서 오류가 발생했습니다. 파일 ''{1}''의 시간 값은 단조 비감소여야 합니다.</entry>
    <entry key="FromFileOpenErr">''{1}''에서 파일 "{0}"을(를) 여는 중 오류가 발생함: 지정한 파일이 유효한 MAT 파일이 아닙니다. 현재는 MAT 파일만 지원됩니다.</entry>
    <entry key="FromwksDimsModeMismatch1">블록 ''{0}''에 대해 설정된 포트 차원 모드가 유효하지 않습니다. ''{1}''의 출력 포트는 고정 크기 신호로 설정되어 있는데 작업 공간 데이터는 가변 크기 신호를 가지고 있습니다.</entry>
    <entry key="FromwksInvalidRtpForRAccel">지원되지 않는 데이터가 From Workspace 블록 ''{0}''의 ''데이터'' 파라미터를 사용하여 지정되었습니다. 고속 액셀러레이터 시뮬레이션의 경우 From Workspace 블록은 half형이 아닌 내장된 숫자 데이터형의 데이터만 불러올 수 있습니다.</entry>
    <entry key="FromwksInvalidRtpInRsim">Unsupported data specified using ''Data'' parameter of From Workspace block ''{0}''. When generating code for RSIM target, the From Workspace block supports loading only data that has a built-in numeric data type other than half.</entry>
    <entry key="FromwksRAccelInterpolate64Bit">From Workspace 블록은 고속 액셀러레이터 시뮬레이션에서 int64형 데이터 또는 uint64형 데이터의 선형 보간을 지원하지 않는데, From Workspace 블록 "{0}"이(가) int64형 데이터 또는 uint64형 데이터를 불러오고 선형 보간하도록 구성되어 있습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="ClearInterpolateFix"&gt; &lt;cmd&gt;set_param(''{0}'',''Interpolate'',''off'')&lt;/cmd&gt; &lt;txt&gt;From Workspace 블록 "{0}"의 "데이터 보간" 파라미터의 선택을 해제하십시오. &lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" id="ChangeSimModeFix"&gt; &lt;txt&gt;대신 표준 모드 또는 액셀러레이터 모드를 사용하여 모델을 시뮬레이션하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" id="ChangeDataTypeFix"&gt; &lt;txt&gt;int64형, uint64형 또는 half형이 아닌 내장된 숫자 데이터형을 사용하여 데이터를 불러오도록 From Workspace 블록 "{0}"을(를) 구성하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt; 
      
    </entry>
    <entry key="FromwksRAccelInterpolate64BitWithExtrapolation">From Workspace 블록은 고속 액셀러레이터 시뮬레이션에서 int64형 데이터 또는 uint64형 데이터의 선형 보간 또는 선형 외삽을 지원하지 않는데, From Workspace 블록 "{0}"이(가) int64형 데이터 또는 uint64형 데이터를 불러오고 선형 보간 및 선형 외삽하도록 구성되어 있습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="ClearInterpolateFix" retvalue="false"&gt; &lt;cmd&gt;set_param(''{0}'',''Interpolate'',''off'', ''OutputAfterFinalValue'',''__ARG1__'')&lt;/cmd&gt; &lt;cargs&gt; &lt;carg translate="false" name="__ARG1__" type="menu"&gt; &lt;txt_prompt&gt;OutputAfterFinalValue&lt;/txt_prompt&gt; &lt;enum&gt;{1_CMsgID}&lt;/enum&gt; &lt;enum&gt;{2_CMsgID}&lt;/enum&gt; &lt;enum&gt;{3_CMsgID}&lt;/enum&gt; &lt;/carg&gt; &lt;/cargs&gt; &lt;txt&gt;선형 보간을 비활성화하고 외삽 이외의 다른 옵션을 사용하여 외부 입력 데이터의 최종 값이 생성된 후에 출력 값을 생성하도록 From Workspace 블록 "{0}"을(를) 구성하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" id="ChangeSimModeFix"&gt; &lt;txt&gt;대신 표준 모드 또는 액셀러레이터 모드를 사용하여 모델을 시뮬레이션하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion" id="ChangeDataTypeFix"&gt; &lt;txt&gt;int64형, uint64형 또는 half형 이외의 다른 내장된 숫자 데이터형을 사용하여 데이터를 불러오도록 From Workspace 블록 "{0}"을(를) 구성하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt; 
      
    </entry>
    <entry key="FromwksModelRefAccelInterpolate64Bit" context="error">Unable to load data as specified in block "{0}" because the From Workspace block does not support linear interpolation of int64 or uint64 data for code generation or model references that simulate in a mode other than normal.
      
        &lt;actions exclusiveFixIts="yes"&gt;
          &lt;action type="fixit" id="ClearInterpolateFix"&gt;
            &lt;cmd&gt;set_param(''{0}'',''Interpolate'',''off'')&lt;/cmd&gt;
            &lt;txt&gt;Clear the "Interpolate data" parameter of From Workspace block "{0}". &lt;/txt&gt;
          &lt;/action&gt;
          &lt;action type="suggestion" id="ChangeSimModeFix"&gt;
            &lt;txt&gt;Configure the top model and all Model blocks that directly or indirectly reference model "{1}" to use normal mode.&lt;/txt&gt;
          &lt;/action&gt;
          &lt;action type="suggestion" id="ChangeDataTypeFix"&gt;
            &lt;txt&gt;Configure From Workspace block "{0}" to load data using a built-in numeric data type other than int64, uint64, or half.&lt;/txt&gt;
          &lt;/action&gt;
        &lt;/actions&gt; 
      
    </entry>
    <entry key="FromwksOnlyDiscSampleTime1">''{0}''에 전파된 연속 샘플 시간이 유효하지 않습니다. 작업 공간의 입력이 시간 데이터가 없는 구조체인 경우 연속 샘플 시간을 가질 수 없습니다</entry>
    <entry key="FromwksOnlyDiscSampleTime2">''{0}''에 전파된 연속 샘플 시간이 유효하지 않습니다. 데이터를 주기적으로 반복하는 옵션을 선택한 경우 연속 샘플 시간을 가질 수 없습니다.</entry>
    <entry key="FxpPointInvalidFSlopeSpec">''{0}''에 지정된 고정소수점 데이터형이 유효하지 않습니다. 기울기 값은 1 &lt;= Fslope &lt; 2를 충족하는 범위에서 정규화되어야 합니다.</entry>
    <entry key="FxpPointMantBitsTooHighSpec">''{0}''에 지정된 고정소수점 데이터형이 유효하지 않습니다. 가수 비트의 수가 너무 큽니다.</entry>
    <entry key="FxpPointSignedOneMantBitsSpec">''{0}''에 지정된 고정소수점 데이터형이 유효하지 않습니다. 1비트 숫자의 경우 부호 없는 데이터형은 지원되지만 부호 있는 데이터형은 지원되지 않습니다.</entry>
    <entry key="GotoBlockWaitbar">기다려 주십시오...</entry>
    <entry key="GotoTagVisBlockNotFound">''{0}''에 대한 태그 가시성이 발견되지 않음</entry>
    <entry key="GroundNoBus">차원이 '{'{1}'}'인 버스 선을 그라운드하는 데 ''{0}''을(를) 사용하는 것은 유효하지 않습니다. 버스 선에는 그라운드를 사용할 수 없습니다.</entry>
    <entry key="HandleIsNotValid">One of the handles being set in the IOSignals parameter for ''{0}'' is not a valid port object, model reference, or Stateflow chart.</entry>
    <entry key="HardZeroSmallSignalGain">''{0}''이(가) 영이득으로 선형화됨</entry>
    <entry key="HiddenBlockBusExpanPropnErrorBO">Bus 객체 ''{0}''에 지정된 정의와 ''{1}''의 ''데이터형'' 파라미터에 지정된 설정에 따라 개별 버스 요소의 사양을 잠그기 위해 이 블록이 추가됩니다.</entry>
    <entry key="HiddenBlockBusExpanPropnErrorInherit">입력 버스 신호에 있는 개별 요소의 ''{0}'' 파라미터 정의에 따라 사양을 잠그기 위해 이 블록이 추가됩니다.</entry>
    <entry key="HiddenBlockDebugMsg">문제를 디버그하려면 이러한 블록을 수동으로 삽입해 보십시오.</entry>
    <entry key="HiddenBlockIndirectlyRelatedError">이 오류 메시지는 숨겨진 {0} 블록과 간접적으로 관련이 있습니다.</entry>
    <entry key="HiddenBlockOptimizationMsg">블록 삽입 또는 확장의 결과로 이 블록이 블록 ''{0}''에 추가됩니다.</entry>
    <entry key="HiddenBlockParamMsg">이 숨겨진 블록의 파라미터 ''{0}''은(는) ''{1}''(으)로 설정됩니다.</entry>
    <entry key="HiddenBlockPortOptimizationMsg">블록 삽입 또는 확장의 결과로 이 블록이 블록 ''{0}''의 {1}에 추가됩니다.</entry>
    <entry key="HiddenBlockRelatedError">This message is related to a hidden {0} block.</entry>
    <entry key="HiddenBlockSigobjPropnError">이 블록은 블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{2,number,integer}" objname="{1}"&gt;{2,number,integer}번 출력 포트&lt;/sldiag&gt;에서 연결이 맺어진 Signal 객체 ''{0}''에 추가됩니다. 이 충돌을 해결하려면 Signal 객체 속성 또는 블록 설정을 변경해 보십시오.</entry>
    <entry key="HiddenOutportBlockSigobjPropnError">이 블록은 Outport 블록 ''{1}''에서 연결이 맺어진 Signal 객체 ''{0}''에 추가됩니다. 이 충돌을 해결하려면 Signal 객체 속성을 변경해 보십시오.</entry>
    <entry key="HideContents">Contents of masked subsystem ''{0}'' are hidden and cannot be viewed</entry>
    <entry key="ICOutsideOfBlkLimits">초기 조건이 ''{0}''의 한도를 벗어남</entry>
    <entry key="IfBlkDimsPropErr">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대해 지정된 차원이 유효하지 않습니다. 차원이 이 포트의 너비에 지정한 값은 {2,number,integer}인데 if/elseif 조건 중 하나가 이 포트의 요소 {3,number,integer}에 액세스합니다.</entry>
    <entry key="IfBlkIncompatExpressions">''u{0,number,integer}''번 입력의 기호가 ''{1}''에서 호환되지 않는 표현식에 사용되었습니다. 표현식 중 하나가 인덱스를 지정하지 않은 채 이 입력 기호를 사용합니다. 이렇게 사용하는 경우 입력의 너비가 1이라고 가정합니다. 반면, 또 다른 표현식은 이 입력의 요소 ''{2,number,integer}''에 액세스합니다.</entry>
    <entry key="IfBlkIndexErr">''{1}''의 표현식 ''{0}''에 범위를 벗어난 첨자가 있음</entry>
    <entry key="IfBlkScalarBooleanOutput">''{1}''의 표현식 ''{0}''은(는) 스칼라 출력값을 생성해야 합니다. ''{2}''에서 참조되는 입력 신호 또는 파라미터가 스칼라가 아닌 경우 이 요구 사항에 위배될 수 있습니다. </entry>
    <entry key="IfBlockInvalidIndex">블록 ''{2}''의 표현식 ''{1}''에 사용된 입력 ''{0}''에 범위를 벗어난 첨자가 있음</entry>
    <entry key="IfBlockInvalidParamDataType">블록 ''{2}''의 표현식 ''{1}''에 사용된 파라미터 ''{0}''은(는) 호환되지 않습니다. If 블록은 부울, 내장된 숫자형 및 열거형 데이터형만 받습니다. </entry>
    <entry key="IfBlockInvalidParam">블록 ''{2}''의 표현식 ''{1}''에 인식할 수 없는 기호 ''{0}''이(가) 사용되었습니다. 이 기호가 파라미터인 경우, 정의되어 있는지 확인하십시오. 함수인 경우에는 블록 문서 페이지에서 지원되는 함수 목록을 참조하십시오.</entry>
    <entry key="IfBlockInvalidInportLabel">블록 ''{1}''의 새 입력 포트 레이블 ''{0}''이(가) 유효하지 않습니다. </entry>
    <entry key="IfBlockInportLabelSameAsWSVar">블록 ''{1}''의 새 입력 포트 레이블 ''{0}''은(는) 기존 작업 공간 변수의 레이블과 같기 때문에 유효하지 않습니다. </entry>
    <entry key="IfBlockInportLabelInUse">레이블 ''{0}''은(는) 다른 입력 포트에 이미 사용되고 있습니다. </entry>
    <entry key="IfBlockUnusedInputPort">블록 ''{1}''의 {0,number,integer}번 입력 포트가 어떠한 if/elseif 조건에서도 참조되지 않습니다. </entry>
    <entry key="IfBlockInputPortDataTypeErr">블록 ''{1}''의 {0,number,integer}번 입력 포트에 충돌하는 설정이 있습니다. ''{2}''은(는) 각기 다른 유형 ''{3}'' 및 ''{4}''을(를) 갖는 데이터와 비교되며, 이는 허용되지 않습니다. </entry>
    <entry key="IfBlkInvalidElseIfExpr">Invalid parameter ''{0}'' specified for ''{1}''. The parameter must be a comma-separated list of character vectors with as many character vectors as elseif expressions. Furthermore, each character vector must be non-empty and must contain at least one non-whitespace character</entry>
    <entry key="IfBlkMatchErr">Error while parsing expression ''{0}'' in ''{1}''. Token "{2}" was found, whereas "{3}" was expected</entry>
    <entry key="IfBlkSyntaxErr">''{1}''의 표현식 ''{0}''에 구문 오류가 있음</entry>
    <entry key="IfBlkParserErr">다음과 같은 이유로 ''{1}''의 표현식 ''{0}''을(를) 실행할 수 없음: \n''{2}''</entry>
    <entry key="IfBlkTooManyInputs">''{1}''에 대해 지정된 파라미터 ''{0}''이(가) 유효하지 않습니다. 최대 {2,number,integer}개의 입력을 받습니다.</entry>
    <entry key="IfBlkUIdxMustBeNum">입력 기호 인덱스는 ''{1}''의 ''{0}'' 표현식에서 양의 정수여야 합니다.</entry>
    <entry key="IfBlkUIdxTooBig">''{1}''에 대해 지정된 표현식 ''{0}''이(가) 유효하지 않습니다. 이 표현식은 {3,number,integer}개의 입력을 가지지만 입력 지정자 ''{2}''을(를) 사용합니다.</entry>
    <entry key="IfConvertBetweenFcnFailed">''{0}''에서 입력 데이터형을 double형으로 변환하지 못했습니다.</entry>
    <entry key="IfNoConvertBetweenFcn">''{0}''의 입력 포트에 대해 지정된 데이터형이 유효하지 않습니다. 이 데이터형에는 데이터형이 double 데이터형으로 어떻게 변환되는지를 지정하는 ConvertBetween 함수가 등록되어 있어야 합니다.</entry>
    <entry key="IfNoLogOpsForNums">''{1}''의 표현식 ''{0}''에서 논리 연산자에 숫자가 잘못 사용되었습니다. 논리식의 피연산자에는 부울 값 숫자만 허용됩니다</entry>
    <entry key="IfNoLogOpsForOnlyNums">''{1}''의 표현식 ''{0}''에서 논리 연산자에 숫자가 잘못 사용되었습니다. 적어도 하나의 피연산자가 입력 신호(즉, u1, u2, ...)를 참조해야 합니다</entry>
    <entry key="IfNoRelopsForBoolean">''{1}''의 표현식 ''{0}''에서 부울 입력 신호에 관계 연산자가 잘못 사용됨</entry>
    <entry key="IfNoRelopsForOnlyNums">''{1}''의 표현식 ''{0}''에서 관계 연산자가 잘못 사용되었습니다. 적어도 하나의 피연산자가 입력 신호(즉, u1, u2, ...)를 참조해야 합니다</entry>
    <entry key="IfNumericOverflow">Overflow condition during the conversion of the number ''{0}'' in expression ''{1}'' of ''{2}'' from data type ''double'' to ''{3}''</entry>
    <entry key="IfNumericPrecisionLoss">''{2}''의 표현식 ''{1}''에서 숫자 ''{0}''의 데이터형을 ''double''형에서 ''{3}''형으로 변환하는 중에 정밀도 손실이 발생했습니다.</entry>
    <entry key="IfPureNumExprs">Invalid conditional expression ''{0}'' in ''{1}''. The condition must reference an input signal (i.e., u1, u2, ...)</entry>
    <entry key="IfNoUnaryMinusForUnsignedIntDataType">Unary minus operator is not allowed in expression for If block ''{0}'', which has unsigned integer input signal(s). Remove the unary minus operator from the expression or use a 'single' or 'double' data type for the input signal(s).</entry>
    <entry key="IfUnaryMinusOnSignedIntInput">If 블록 ''{0}''의 If 또는 Elseif 표현식에서 데이터형 ''{1}''의 입력 신호에 단항 마이너스 연산자가 적용되고 있습니다. 이 경우 입력 신호가 해당 데이터형의 가장 큰 음수 값({2, number, integer})에 도달하면 시뮬레이션 결과와 코드 생성 결과가 서로 달라질 수 있습니다. 제한 조건에서 신호 값을 더 효과적으로 처리하도록 Simulink 라이브러리에서 Unary Minus 블록을 사용하여 단항 마이너스를 구현해 보십시오. 자세한 내용은 버그 리포트 798453을 참조하십시오.</entry>
    <entry key="IfUnaryMinusOnSignedIntMinVal">If 블록 ''{0}''의 If 또는 Elseif 표현식에서 데이터형 ''{1}''의 가장 큰 음수 값({2, number, integer})에 단항 마이너스 연산자가 적용되고 있습니다. 이 경우 시뮬레이션 결과와 코드 생성 결과가 서로 달라질 수 있습니다. 자세한 내용은 버그 리포트 798453을 참조하십시오.</entry>
    <entry key="IfBlkInvFcnCallInput">If 블록 ''{0}''(으)로 들어오는 입력 신호는 함수 호출 신호일 수 없습니다.</entry>
    <entry key="IfBlkInvActionInput">If 블록 ''{0}''(으)로 들어오는 입력 신호는 동작 신호일 수 없습니다.</entry>
    <entry key="IfBlkNoContTsIfEnsureIfElseCode">
	
	         If 블록 ''{0}''에 '생성 코드에서 if-else 문 제공'이 선택되어 있습니다. 연속 샘플 시간을 사용하는 모델 ''{1}''에 이 블록을 배치할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="NoContTsIfEnsureIfElseCode"&gt; &lt;cmd&gt;set_param_action(''{0}'', ''EnsureIfElseCode'', ''off'');&lt;/cmd&gt; &lt;txt&gt;연속 샘플 시간을 사용하도록 허용하려면 블록 ''{0}''의 블록 대화 상자를 열고 '생성 코드에서 if-else 문 제공' 체크박스를 선택 해제하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
	
    </entry>
    <entry key="RootOutportBlkInvActionInput">루트 수준 Outport 블록 ''{0}''(으)로 들어오는 입력 신호는 동작 신호일 수 없습니다.</entry>
    <entry key="IllegalIndexValue">블록 ''{1}''의 인덱스 포트 k{0,number,integer}에서 값이 잘못되었습니다.</entry>
    <entry key="IllegalSelectionValue">블록 ''{1}''의 선택 포트 sel{0,number,integer}에서 값이 잘못되었습니다.</entry>
    <entry key="ImplicitAssignmentInvalidInputWidth">블록 ''{0}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;로 전파된 신호 크기의 너비가 {2,number,integer}입니다. 이 크기는 {3,number,integer}의 배수여야 합니다. 블록 ''{5}''에서는 차원 {4,number,integer}에 대해 신호 입력 크기가 {6,number,integer}이어야 하므로 이 크기 관계가 반드시 필요합니다.</entry>
    <entry key="ImplicitAssignmentInvalidInputWidth2">블록 ''{0}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;로 전파된 신호 크기의 너비가 {2,number,integer}입니다. 블록 ''{4}''에서는 신호 입력 너비가 최소 {3,number,integer}이어야 하므로 이 너비는 유효하지 않습니다.</entry>
    <entry key="ImplicitAssignmentInvalidInputWidth3">블록 ''{0}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;로 전파된 신호 크기의 너비가 {2,number,integer}입니다. 블록 ''{4}''에서는 신호 입력 너비가 {3,number,integer}이어야 하므로 이 너비는 유효하지 않습니다.</entry>
    <entry key="ImplicitAssignmentIOWidthMismatch">The output signal from &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;port {1,number,integer}&lt;/sldiag&gt; of subsystem ''{0}'' has a width of {2,number,integer}. This width must be a multiple of the width of the input signal {4,number,integer} to Outport block ''{3}''. This size relationship is necessary because the output signal of subsystem ''{5}'' is formed by concatenating the input signal to Outport block ''{6}''.</entry>
    <entry key="ImplicitAssignmentIODimMismatch">서브시스템 ''{0}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 포트&lt;/sldiag&gt;에서 오는 출력 신호는 차원 {3,number,integer}에 대해 크기가 {2,number,integer}입니다. 이 크기는 동일한 차원의 Outport 블록 ''{4}''(으)로 들어오는 입력 신호 크기 {5,number,integer}의 배수여야 합니다. 서브시스템 ''{6}''의 출력 신호는 차원 {7,number,integer}을(를) 따라 Outport 블록 ''{8}''(으)로 들어오는 입력 신호를 결합하여 형성되기 때문에 이 크기 관계가 반드시 필요합니다.</entry>
    <entry key="ImplicitAssignmentWidthBasedNumIterMismatch1">서브시스템 ''{0}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 포트&lt;/sldiag&gt;에서 오는 출력 신호의 너비가 {2,number,integer}입니다. Outport 블록 ''{3}''(으)로 들어오는 입력 신호의 너비가 {4,number,integer}입니다. 따라서 서브시스템 ''{7}''에는 {5,number,integer}번의 반복이 필요합니다. 이 요구 사항은 이 서브시스템의 분할된 마스크 파라미터에 필요한 반복 횟수인 {6,number,integer}과(와) 충돌합니다.</entry>
    <entry key="ImplicitAssignmentWidthBasedNumIterMismatch">The output signal from &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;port {1,number,integer}&lt;/sldiag&gt; of subsystem ''{0}'' has a width of {2,number,integer}. The input signal to Outport block ''{3}'' has a width of {4,number,integer}. Consequently, subsystem ''{7}'' requires {5,number,integer} iterations. This requirement conflicts with {6,number,integer}, the number of iterations expected by another input/output signal of this subsystem.</entry>
    <entry key="ImplicitAssignmentDimBasedNumIterMismatch1">서브시스템 ''{0}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 포트&lt;/sldiag&gt;에서 오는 출력 신호는 차원 {3,number,integer}에 대해 크기가 {2,number,integer}입니다. Outport 블록 ''{4}''(으)로 들어오는 입력 신호는 동일한 차원에 대해 크기가 {5,number,integer}입니다. 따라서 서브시스템 ''{8}''에는 {6,number,integer}번의 반복이 필요합니다. 이 요구 사항은 이 서브시스템의 분할된 마스크 파라미터에 필요한 반복 횟수인 {7,number,integer}과(와) 충돌합니다.</entry>
    <entry key="ImplicitAssignmentDimBasedNumIterMismatch">서브시스템 ''{0}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 포트&lt;/sldiag&gt;에서 오는 출력 신호는 차원 {3,number,integer}에 대해 크기가 {2,number,integer}입니다. Outport 블록 ''{4}''(으)로 들어오는 입력 신호는 동일한 차원에 대해 크기가 {5,number,integer}입니다. 따라서 서브시스템 ''{8}''에는 {6,number,integer}번의 반복이 필요합니다. 이 요구 사항은 이 서브시스템의 또 다른 입력/출력 신호에 필요한 반복 횟수인 {7,number,integer}과(와) 충돌합니다.</entry>
    <entry key="ImplicitAssignmentInvalidOutputWidth">서브시스템 ''{0}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 포트&lt;/sldiag&gt;에서 오는 출력 신호의 너비가 {2,number,integer}입니다. 이는 또 다른 서브시스템 입력/출력 신호에 필요한 반복 횟수인 {3,number,integer}의 배수여야 합니다.</entry>
    <entry key="ImplicitAssignmentInvalidOutputWidth2">서브시스템 ''{0}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 포트&lt;/sldiag&gt;에서 오는 출력 신호의 너비가 {2,number,integer}입니다. 하지만 너비는 적어도 {3,number,integer}이어야 합니다.</entry>
    <entry key="ImplicitAssignmentInvalidOutputWidth3">서브시스템 ''{0}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 포트&lt;/sldiag&gt;에서 오는 출력 신호의 너비가 {2,number,integer}입니다. 하지만 너비는 {3,number,integer}이어야 합니다.</entry>
    <entry key="ImplicitAssignmentInvalidOutputDim">The output signal from &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;port {1,number,integer}&lt;/sldiag&gt; of subsystem ''{0}'' has a size of {2,number,integer} for dimension {3,number,integer}. It must be a multiple of {4,number,integer}, the number of iterations expected by another subsystem input/output signals.</entry>
    <entry key="ImplicitAssignmentInvalidInputSize">차원 {1,number,integer}에 대해 블록 ''{2}''의 입력으로 전파된 입력 크기가 {0,number,integer}입니다. 반면, 블록 ''{5}''에서는 차원 {4,number,integer}에 대해 입력 크기가 {3,number,integer}이어야 합니다.</entry>
    <entry key="ImplicitAssignmentInvalidOutputSize">차원 {1,number,integer}에 대해 서브시스템 ''{2}''의 {3,number,integer}번 출력으로 전파된 출력 크기가 {0,number,integer}입니다. 반면, 서브시스템 ''{6}''에서는 차원 {5,number,integer}에 대해 출력 크기가 {4,number,integer}이어야 합니다.</entry>
    <entry key="ImplicitAssignmentInvalidInputDimsMode">The dimensions mode propagated to the &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of block ''{1}'' is variable. However, block ''{2}'' expects a fixed-size input signal.</entry>
    <entry key="ImplicitIterSS_AnalysisPointNotSupportedInside">Simulink does not support the linearization point inside subsystem ''{0}'' because the subsystem contains a For Each block (''{1}''). Specifically, the output {2,number,integer} of block ''{3}'' is set as a linearization point. Consider clearing this linearization point.</entry>
    <entry key="ImplicitIterSS_DWorkDataNotReusableSC">Block ''{0}'' has a state with a global storage class. However, this block is inside subsystem ''{1}'', which contains a For Each block (''{2}''). Simulink does not support this scenario.</entry>
    <entry key="ForEachSSCallerGroundBlock">The function-call port of ''{0}'' is driven either by a ground block or is unconnected, which marks the block to be non-inlined. However, this block is inside subsystem ''{1}'', which contains a For Each block (''{2}''). Simulink does not support this scenario.</entry>
    <entry key="ImplicitIterSS_DataLoggingNotSupportedInside">The parameter ''Log signal data'' in the ''Signal Properties...'' dialog for the output {0,number,integer} of block ''{1}'' is selected. However, the block is inside subsystem ''{2}'', which contains a For Each block (''{3}''). Simulink does not support this scenario. Consider clearing the parameter ''Log signal data''. (Open the ''Signal Properties...'' dialog by right-clicking the signal line).</entry>
    <entry key="ImplicitIterSS_ExpStorageClassNotSupportedInside">블록 ''{1}''의 {0,number,integer}번 출력에 있는 신호가 자동 스토리지 클래스를 사용하지 않습니다. 서브시스템 ''{2}''에 For Each 블록(''{3}'')이 포함되어 있으므로 이 서브시스템 내에서는 자동 스토리지 클래스만 지원됩니다. ''신호 속성...'' 대화 상자에서 ''스토리지 클래스'' 파라미터를 ''자동''으로 설정해 보십시오. (신호 선을 마우스 오른쪽 버튼으로 클릭하여 ''신호 속성...'' 대화 상자를 엽니다.)</entry>
    <entry key="ImplicitIterSS_FcnCallOutputNotSupported">서브시스템 ''{1}''의 {0,number,integer}번 출력에 있는 신호가 함수 호출 신호입니다. 서브시스템 ''{2}''에 For Each 블록(''{3}'')이 포함되어 있으므로 함수 호출 출력 신호는 이 서브시스템에서 지원되지 않습니다.</entry>
    <entry key="ImplicitIterSS_ForcedNonInline">The function-call port of subsystem block ''{0}'' is being driven either by an S-Function with no TLC implementation or the mdlInitializeSizes function for the TLC implementation''s S-function does not set either ''SS_OPTION_USE_TLC_WITH_ACCELERATOR'', ''SS_OPTION_FORCE_NONINLINED_FCNCALL'', or ''SS_OPTION_WORKS_WITH_CODE_REUSE'' option. Consequently, subsystem block ''{1}'' is a non-reusable function that Simulink does not support inside subsystem ''{2}'', which contains a For Each block (''{3}'').</entry>
    <entry key="ImplicitIterSS_FrameInputNotSupported">{0,number,integer}번 입력에 있는 신호의 샘플링 모드가 서브시스템 ''{1}''에 대해 ''프레임 기반''입니다. 서브시스템 ''{2}''에 For Each 블록(''{3}'')이 포함되어 있으므로 프레임 기반 입력 신호는 이 서브시스템에서 지원되지 않습니다.</entry>
    <entry key="ImplicitIterSS_FrameOutputNotSupported">{0,number,integer}번 출력에 있는 신호의 샘플링 모드는 서브시스템 ''{1}''에 대해 ''프레임 기반''입니다. 서브시스템 ''{2}''에 For Each 블록(''{3}'')이 포함되어 있으므로 프레임 기반 출력 신호는 이 서브시스템에서 지원되지 않습니다.</entry>
    <entry key="ImplicitIterSS_DifferentLevelDSMRW">Block ''{0}'' is inside subsystem ''{1}'', which contains a For Each block (''{2}''). The corresponding Data Store Memory block ''{3}'' is inside subsystem ''{4}'', which contains a For Each block (''{5}''). Simulink currently does not support this scenario. Block ''{6}'' and the corresponding Data Store Memory block ''{7}'' must be in the same subsystem, which contains a For Each block.</entry>
    <entry key="ImplicitIterSS_DifferentLevelDSMRW_Root">Block ''{0}'' is inside subsystem ''{1}'', which contains a For Each block (''{2}''). The corresponding Data Store Memory block ''{3}'' is not inside subsystem ''{4}''. Simulink currently does not support this scenario. Consider moving Block ''{5}'' outside subsystem ''{6}'' or the corresponding Data Store Memory block ''{7}'' into subsystem ''{8}''.</entry>
    <entry key="ImplicitIterSS_FromWorkspaceWithEmptyTimeNotSupported">The From Workspace block ''{0}'' is inside subsystem ''{1}'', which contains a For Each block (''{2}''). Consequently, the corresponding workspace structure variable must contain time data.</entry>
    <entry key="ImplicitIterSS_NonReusableSFcn">S-Function 블록 ''{0}''에 TLC가 구현되어 있지 않거나 이 블록에서 ''SS_OPTION_USE_TLC_WITH_ACCELERATOR'' 옵션 또는 ''SS_OPTION_WORKS_WITH_CODE_REUSE'' 옵션을 설정하지 않습니다. 하지만 이 S-Function은 서브시스템 ''{1}'' 내에 있고 이 서브시스템에는 For Each 블록(''{2}'')이 포함되어 있습니다. Simulink에서는 이러한 경우를 지원하지 않습니다.</entry>
    <entry key="ImplicitIterSS_NonReusableSF">The particular Stateflow chart ''{0}'' is incompatible with the subsystem code reuse feature. However, this chart is inside subsystem ''{1}'', which contains a For Each block (''{2}''). Simulink does not support this scenario. Consider unchecking the check box ''Export Chart Level Functions'' in the chart Properties dialog.</entry>
    <entry key="ImplicitIterSS_SigObjExpStorageClassNotSupportedInside">The signal at output {0,number,integer} of block ''{1}'' is associated with a Simulink.Signal object ''{2}'', which is not using the auto storage class. Only auto storage class is supported inside subsystem ''{3}'' because the subsystem contains a For Each block (''{4}''). Consider setting the Simulink.Signal object storage class to ''Auto''.</entry>
    <entry key="ImplicitIterSS_DWorkStructuredStorageClassNotSupportedInside">블록 ''{1}''의 상태 ''{0}''은(는) 구조화된 스토리지 클래스를 사용합니다. For Each 블록(''{3}'')이 포함된 재사용 불가 서브시스템 ''{2}''에 중첩되어 있는 재사용 가능 서브시스템 내에서는 구조화되지 않은(unstructured) 스토리지 클래스만 지원됩니다. 상태의 스토리지 클래스를 구조화되지 않은(unstructured) 스토리지 클래스로 설정하십시오.</entry>
    <entry key="ImplicitIterSS_SignalViewNotSupportedInside">The output {0,number,integer} of block ''{1}'' is connected with a Scope Viewer. However, the block is inside subsystem ''{2}'', which contains a For Each block (''{3}''). Simulink does not support this scenario. Consider disconnecting the viewer (Open the context menu by right-clicking the signal line).</entry>
    <entry key="StateflowDataLoggingNotSupported">Block ''{0}'' is set to log local data. However, the block is inside subsystem ''{1}'', which contains a For Each block (''{2}''). Simulink currently does not support this scenario. Consider turning off logging of local data in block ''{3}''.</entry>
    <entry key="ImplicitIterSS_TestPointNotSupportedInside">The parameter ''Test point'' in the ''Signal Properties...'' dialog for the output {0,number,integer} of block ''{1}'' is selected. Test-pointed signals are not supported inside subsystem ''{2}'', which contains a For Each block (''{3}''). Consider clearing the parameter ''Test point''. (Open the ''Signal Properties...'' dialog by right-clicking the signal line).</entry>
    <entry key="ImplicitIterSS_UnknownExpStorageClassNotSupportedInside">The storage class of the signal at output {0,number,integer} of block ''{1}'' is not using ''Auto''. This setting was set by Simulink internally. Only auto storage class is supported inside subsystem ''{2}'' because the subsystem contains a For Each block (''{3}'').</entry>
    <entry key="ImplicitIterSS_UnknownTestPointNotSupportedInside">Simulink가 블록 ''{1}''의 {0,number,integer}번 출력에 있는 신호에 대한 숨겨진 테스트 지점을 추가했습니다. 서브시스템 ''{2}''에는 For Each 블록(''{3}'')이 포함되어 있으므로 이 서브시스템 내에서는 테스트 지점 신호가 지원되지 않습니다.</entry>
    <entry key="ImplicitIterSS_VariableDimsSigNotSupportedInside">Simulink does not support a variable-size signal inside subsystem ''{0}'' because the subsystem contains a For Each block (''{1}''). The signal at output {2,number,integer} of block ''{3}'' is variable-size.</entry>
    <entry key="ImplicitIterSS_WideFcnCallTrig">Subsystem 블록 ''{0}''은(는) 너비가 1보다 큰 함수 호출 포트가 있는 Function-Call Subsystem입니다. 하지만 이 서브시스템이 For Each 블록(''{2}'')이 포함된 서브시스템 ''{1}'' 내에 있습니다. Simulink에서는 이러한 경우를 지원하지 않습니다.</entry>
    <entry key="ForEachBlockInvalidSpecNumItersParam">Invalid setting in ''{0}'' for parameter &lt;sldiag objui="blockdlg" objparam="{1}"&gt;'Number of iterations'&lt;/sldiag&gt;. The parameter must evaluate to either -1 or a positive integer.</entry>
    <entry key="ForEachSS_ErrorInOneIter">For Each 블록 ''{1}''이(가) 포함된 서브시스템 ''{0}''의 {2,number,integer}번째 반복에서 오류가 발생합니다.</entry>
    <entry key="ForEachSS_WarningInOneIter">For Each 블록 ''{1}''이(가) 포함된 서브시스템 ''{0}''의 {2,number,integer}번째 반복에서 경고가 발생합니다.</entry>
    <entry key="ForEachSSMaskParamInvalidPartSetting">Invalid setting of ''{0}'' for partitioned mask parameter ''{1}'' of For Each subsystem ''{2}''.</entry>
    <entry key="ForEachSSMaskParamNonScalarPartSetting">The value of ''{0}'' for partitioned mask parameter ''{1}'' of For Each subsystem ''{2}'' is an array of {3,number,integer} element(s). It must be a scalar.</entry>
    <entry key="ForEachSSMaskParamNonPositivePartDim">The value of partition dimension for the mask parameter ''{0}'' of subsystem ''{1}'' is set to {2,number,integer}. It must be a positive integer</entry>
    <entry key="ForEachSSMaskParamNonPositivePartWidth">The value of partition width for the mask parameter ''{0}'' of subsystem ''{1}'' is set to {2,number,integer}. It must be a positive integer</entry>
    <entry key="ForEachSSMaskParamInvalidPartWidth1">The mask parameter ''{0}'' of subsystem ''{1}'' has a size of {2,number,integer} for dimension {3,number,integer}. The value of partition width, {4,number,integer}, is invalid since it is greater than size of dimension {5,number,integer}.</entry>
    <entry key="ForEachSSMaskParamInvalidPartWidth2">The mask parameter ''{0}'' of subsystem ''{1}'' has a size of {2,number,integer} for dimension {3,number,integer}. The value of partition width, {4,number,integer}, is invalid, since it is not a factor of size of dimension {5,number,integer}.</entry>
    <entry key="ForEachSSMaskParamMismatchWithNumIters">The mask parameter ''{0}'' of subsystem ''{1}'' has a size of {2,number,integer} for dimension {3,number,integer}. The partition width is set to {4,number,integer} for this mask parameter. Consequently, subsystem ''{5}'' requires {6,number,integer} iterations. This requirement conflicts with {7,number,integer}, the number of iterations expected by another partitioned mask parameter of this subsystem.</entry>
    <entry key="ForEachSSMaskParamMismatchWithSpecifiedNumIters">Value of {6,number,integer} for &lt;sldiag objui="blockdlg" objparam="{7}" objname="{8}"&gt;'Number of iterations'&lt;/sldiag&gt; in For Each block ''{8}'' is invalid. The mask parameter ''{0}'' of subsystem ''{1}'' has a size of {2,number,integer} for dimension {3,number,integer}, and the partition width is set to {4,number,integer} for this mask parameter. Consequently, no more than {5,number,integer} iterations are possible. To perform all possible iterations, specify &lt;sldiag objui="blockdlg" objparam="{7}" objname="{8}"&gt;'Number of iterations'&lt;/sldiag&gt; as -1.</entry>
    <entry key="ForEachLinNoSupportUnconcatenated"> Linearization is not supported for ForEach subsystems that have outports with concatenation disabled.</entry>
    <entry key="ImplicitSelectorIOWidthMismatch">서브시스템 ''{0}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 포트&lt;/sldiag&gt;로 들어가는 입력 신호의 경우 Inport 블록 ''{5}''의 출력 너비 {4,number,integer}을(를) 기준으로 분할 차원 {3,number,integer}에 대해 계산된 크기가 {2,number,integer}입니다. 분할 차원 크기와 분할 오프셋 {6,number,integer}을(를) 합한 값(즉, 총 {7,number,integer})은 {8,number,integer}의 배수(즉, 분할 너비 {9,number,integer}에 분할 오프셋 {6,number,integer}을(를) 합한 값)여야 합니다. 입력이 분할되도록 구성되었기 때문에 이 크기 관계가 반드시 필요합니다.</entry>
    <entry key="ImplicitSelectorIOWidthMismatch1">The input signal to &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;port {1,number,integer}&lt;/sldiag&gt; of subsystem ''{0}'' has a width of {2,number,integer}. This size must be a multiple of the output partial width {3,number,integer} from Inport block ''{4}'' excluding the size of the partition dimension {5,number,integer}. This size relationship is necessary because the input is configured to be partitioned.</entry>
    <entry key="ImplicitSelectorIOWidthMismatch2">서브시스템 ''{0}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 포트&lt;/sldiag&gt;로 들어오는 입력 신호의 너비가 {2,number,integer}입니다. 이 크기는 분할 차원 {5,number,integer}의 크기를 제외하고 Inport 블록 ''{7}''의 분할 차원 {5,number,integer} 및 출력 분할 너비 {6,number,integer}에 대해 계산된 입력 신호 크기 {4,number,integer}에서 파생된 값인 {3,number,integer}과(와) 충돌합니다. 입력이 분할되도록 구성되었기 때문에 이 크기 관계가 반드시 필요합니다.</entry>
    <entry key="ImplicitSelectorIOWidthMismatchWithSpecifiedNumIters">서브시스템 ''{0}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 포트&lt;/sldiag&gt;로 들어오는 입력 신호의 너비가 {2,number,integer}입니다. 크기가 분할 차원 {5,number,integer}의 크기를 제외하고 Inport 블록 ''{7}''의 분할 차원 {5,number,integer} 및 출력 분할 너비 {6,number,integer}에 대해 계산된 입력 신호 크기 {4,number,integer}에서 파생된 분할에 필요한 최솟값인 {3,number,integer}보다 작습니다. 입력이 분할되도록 구성되었기 때문에 이 크기 관계가 반드시 필요합니다.</entry>
    <entry key="ImplicitSelectorIODimMismatch">The input signal to &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;port {1,number,integer}&lt;/sldiag&gt; of subsystem ''{0}'' has a size of {2,number,integer} for dimension {3,number,integer}. This partition dimension size plus the partition offset {4,number,integer} (i.e. {5,number,integer} in total) must be a multiple of {6,number,integer} (i.e. the sum of output width {7,number,integer} from Inport block ''{8}'' for the same dimension plus the partition offset {4,number,integer}). This size relationship is necessary because the input is configured to be partitioned along dimension {3,number,integer}.</entry>
    <entry key="ImplicitSelectorIODimMismatch1">The input signal to &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;port {1,number,integer}&lt;/sldiag&gt; of subsystem ''{0}'' has a maximum possible size of {2,number,integer} for dimension {3,number,integer}. This partition dimension size plus the partition offset {4,number,integer} (i.e. {5,number,integer} in total) must be a multiple of {6,number,integer} (i.e. the sum of output width {7,number,integer} from Inport block ''{8}'' for the same dimension plus the partition offset {4,number,integer}). This size relationship is necessary because the input is configured to be partitioned along dimension {3,number,integer}.</entry>
    <entry key="ImplicitSelectorWidthBasedNumIterMismatch1">서브시스템 ''{0}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 포트&lt;/sldiag&gt;로 들어가는 입력 신호의 경우 Inport 블록 ''{5}''의 출력 너비 {4,number,integer}을(를) 기준으로 분할 차원 {3,number,integer}에 대해 계산된 크기가 {2,number,integer}입니다. 이 입력에 대한 분할 너비로 {6,number,integer}, 분할 오프셋으로 {7,number,integer}이(가) 주어진 경우 서브시스템 ''{0}''에 {8,number,integer}번의 반복이 필요합니다. 이 요구 사항은 이 서브시스템의 분할된 마스크 파라미터에 필요한 반복 횟수인 {9,number,integer}과(와) 충돌합니다.</entry>
    <entry key="ImplicitSelectorWidthBasedNumIterMismatchWithSpecifiedNumIters">Value of {9,number,integer} for &lt;sldiag objui="blockdlg" objparam="{10}" objname="{11}"&gt;'Number of iterations'&lt;/sldiag&gt; in For Each block ''{11}'' is invalid. The input signal to &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;port {1,number,integer}&lt;/sldiag&gt; of subsystem ''{0}'' has a calculated size of {2,number,integer} for the partition dimension {3,number,integer}, based on output width {4,number,integer} from Inport block ''{5}''. Given the partition width {6,number,integer} and the partition offset {7,number,integer} for this input, no more than {8,number,integer} iterations are possible. To perform all possible iterations, specify &lt;sldiag objui="blockdlg" objparam="{10}" objname="{11}"&gt;'Number of iterations'&lt;/sldiag&gt; as -1.</entry>
    <entry key="ImplicitSelectorWidthBasedNumIterMismatch">서브시스템 ''{0}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 포트&lt;/sldiag&gt;로 들어가는 입력 신호의 경우 Inport 블록 ''{5}''의 출력 너비 {4,number,integer}을(를) 기준으로 분할 차원 {3,number,integer}에 대해 계산된 크기가 {2,number,integer}입니다. 이 입력에 대한 분할 너비로 {6,number,integer}, 분할 오프셋으로 {7,number,integer}이(가) 주어진 경우 서브시스템 ''{0}''에 {8,number,integer}번의 반복이 필요합니다. 이 요구 사항은 이 서브시스템의 또 다른 입력/출력 신호에 필요한 반복 횟수인 {9,number,integer}과(와) 충돌합니다.</entry>
    <entry key="ImplicitSelectorDimBasedNumIterMismatch1">The input signal to &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;port {1,number,integer}&lt;/sldiag&gt; of subsystem ''{0}'' has a size of {2,number,integer} for dimension {3,number,integer}. Given the partition width {4,number,integer} and the partition offset {5,number,integer} for this input, subsystem ''{0}'' requires {6,number,integer} iterations. This requirement conflicts with {7,number,integer}, the number of iterations expected by a partitioned mask parameter of this subsystem.</entry>
    <entry key="ImplicitSelectorDimBasedNumIterMismatchWithSpecifiedNumIters">Value of {7,number,integer} for &lt;sldiag objui="blockdlg" objparam="{8}" objname="{9}"&gt;'Number of iterations'&lt;/sldiag&gt; in For Each block ''{9}'' is invalid. The input signal to &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;port {1,number,integer}&lt;/sldiag&gt; of subsystem ''{0}'' has a size of {2,number,integer} for dimension {3,number,integer}. Given the partition width {4,number,integer} and the partition offset {5,number,integer} for this input, no more than {6,number,integer} iterations are possible. To perform all possible iterations, specify &lt;sldiag objui="blockdlg" objparam="{8}" objname="{9}"&gt;'Number of iterations'&lt;/sldiag&gt; as -1.</entry>
    <entry key="ImplicitSelectorDimBasedNumIterMismatch">차원 {3,number,integer}에 대해 서브시스템 ''{0}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 포트&lt;/sldiag&gt;로 들어오는 입력 신호의 크기가 {2,number,integer}입니다. 이 입력에 대한 분할 너비로 {4,number,integer}, 분할 오프셋으로 {5,number,integer}이(가) 주어진 경우 서브시스템 ''{0}''에 {6,number,integer}번의 반복이 필요합니다. 이 요구 사항은 이 서브시스템의 또 다른 입력/출력 신호에 필요한 반복 횟수인 {7,number,integer}과(와) 충돌합니다.</entry>
    <entry key="ImplicitSelectorInvalidInputWidth">서브시스템 ''{0}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 포트&lt;/sldiag&gt;로 들어오는 입력 신호의 너비가 {2,number,integer}입니다. 이 너비는 분할 차원 {4,number,integer}에 대해 계산된 크기인 {3,number,integer}의 배수여야 합니다.</entry>
    <entry key="ImplicitSelectorInvalidInputWidth2">The input signal to &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;port {1,number,integer}&lt;/sldiag&gt; of subsystem ''{0}'' has a width of {2,number,integer}. However, the width must be at least {3,number,integer}.</entry>
    <entry key="ImplicitSelectorInvalidInputWidth3">서브시스템 ''{0}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 포트&lt;/sldiag&gt;로 들어오는 입력 신호의 너비가 {2,number,integer}입니다. 하지만 너비는 {3,number,integer}이어야 합니다.</entry>
    <entry key="ImplicitSelectorInvalidOutputWidth">블록 ''{0}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에 전파된 신호 크기의 너비는 {2,number,integer}입니다. 이 너비는 파생된 최소 너비 {3,number,integer}의 배수여야 합니다.</entry>
    <entry key="ImplicitSelectorInvalidOutputWidth1">The signal size propagated to the &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;output port {1,number,integer}&lt;/sldiag&gt; of block ''{0}'' has a width of {2,number,integer}. This width must be a multiple of {3,number,integer} because the input {4,number,integer} of subsystem ''{5}'' is configured to be partitioned with a partition size {6,number,integer}.</entry>
    <entry key="ImplicitSelectorInvalidOutputWidth2">블록 ''{0}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에 전파된 신호 크기의 너비는 {2,number,integer}입니다. 이 크기는 최소 {3,number,integer}이어야 합니다.</entry>
    <entry key="ImplicitSelectorInvalidOutputWidth3">블록 ''{0}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에 전파된 신호 크기의 너비는 {2,number,integer}입니다. 이 크기는 {3,number,integer}이어야 합니다.</entry>
    <entry key="ImplicitSelectorInvalidInputSize">차원 {1,number,integer}에 대해 서브시스템 ''{2}''의 {3,number,integer}번 입력에 전파된 입력 크기는 {0,number,integer}입니다. 반면, 서브시스템 ''{2}''에서는 차원 {1,number,integer}에 대해 입력 크기가 {4,number,integer}이어야 합니다.</entry>
    <entry key="ImplicitSelectorInvalidOutputSize">The output size propagated for dimension {1,number,integer} to output of block ''{2}'' is {0,number,integer}. Whereas, block ''{2}'' expects output size {3,number,integer} for dimension {1,number,integer}.</entry>
    <entry key="ImplicitSelectorInvalidOutputDimsMode">블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 있는 신호는 가변 크기 신호입니다. 하지만 Simulink에서는 분할 후 For Each Subsystem의 입력 신호가 고정 크기 신호여야 합니다.</entry>
    <entry key="IncomingSignalIsNotABus">The signal entering &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of block ''{1}'' is not a bus, yet the bus object ''{2}'' is associated with that input port.</entry>
    <entry key="IncompatibleSignalDimsMode">The ports of block ''{0}'' must have the same dimension mode (all fixed dimension or all variable dimension)</entry>
    <entry key="IncompatibleSignalFrameMode">블록 ''{0}''의 포트는 동일한 샘플링 모드를 가져야 함(모두 샘플 기반이거나 모두 프레임 기반이어야 함)</entry>
    <entry key="IncompatibleSignalWidth">블록 ''{0}''의 입력 포트는 너비가 같아야 합니다.</entry>
    <entry key="IncompatibleSignalWidthRuntime">블록 ''{0}''의 입력 포트의 너비가 서로 다릅니다. Reshape 블록의 가변 크기 포트는 실행하는 동안 너비가 같아야 합니다.</entry>
    <entry key="InconsistentDemuxInDimsInfo">''{0}''의 입력 포트의 차원을 설정하는 중 유효하지 않은 차원 문제가 발생했습니다. 차원이 이미 {2}(으)로 설정되었는데 {1}(으)로 설정하려고 합니다.</entry>
    <entry key="InconsistentDemuxOutDimsInfo">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;의 차원을 설정하는 중 유효하지 않은 차원 문제가 발생했습니다. 차원이 이미 {3}(으)로 설정되었는데 {2}(으)로 설정하려고 합니다.</entry>
    <entry key="InconsistentMuxInDimsInfo">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;의 차원을 설정하는 중 유효하지 않은 차원 문제가 발생했습니다. 차원이 이미 {3}(으)로 설정되었는데 {2}(으)로 설정하려고 합니다.</entry>
    <entry key="InconsistentMuxOutDimsInfo">''{0}''의 출력 포트의 차원을 설정하는 중 유효하지 않은 차원 문제가 발생했습니다. 차원이 이미 {2}(으)로 설정되었는데 {1}(으)로 설정하려고 합니다.</entry>
    <entry key="InvalidMuxVarSizeSig">가변 크기 신호는 Mux 블록 ''{0}''에서 지원되지 않습니다. </entry>
    <entry key="InvalidMuxBusArray">버스 신호의 배열은 Mux 블록 ''{0}''에서 지원되지 않습니다.</entry>
    <entry key="InvalidMuxMixedRealComplexSigs">Mux 블록 ''{0}''의 출력이 복소 신호인데 이 블록의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;로 들어오는 신호가 실수인 경우 지원되지 않습니다.</entry>
    <entry key="IncorrectInitialConditionDimension">''{0}''에서 초기 조건의 차원이 올바르지 않습니다. 자세한 내용은 관련 문서의 블록 도움말 페이지를 참조하십시오</entry>
    <entry key="IndexBlkInvIndexingEnumFromDialog">열거형 클래스 ''{0}''의 최소 열거형 값은 음수가 아니어야 합니다.</entry>
    <entry key="IndexBlkInvIndexingEnumFromPort">The minimal enumerated value of the enumerated class ''{0}'' propagated to &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;input port {1,number,integer}&lt;/sldiag&gt; of ''{2}'' must be non-negative.</entry>
    <entry key="IndexConventionMismatch">Inconsistent indexing conventions specified for block ''{0}'' connected to input port {1}{2,number,integer} of block ''{3}''. If you enable the ''Use last breakpoint for input at or above upper limit'' parameter on a Prelookup block, you must also enable the ''Valid index input may reach last index'' parameter for the Interpolation Using Prelookup block to which it connects; otherwise, you must disable both parameters.</entry>
    <entry key="IndexConventionMismatch2">Inconsistent indexing conventions specified for block ''{0}'' connected to input port {1}{2,number,integer} of block ''{3}''. The Interpolation Using Prelookup block expects the Prelookup block to use its last breakpoint for indexing; however, the Prelookup block is not configured to do so. To fix this error, disable the ''Valid index input may reach last index'' parameter for the Interpolation Using Prelookup block.</entry>
    <entry key="IndexConventionMismatch4">블록 ''{3}''의 {1}{2,number,integer}번 입력 포트에 연결된 블록 ''{0}''에 대해 지정된 인덱싱 규칙이 일치하지 않습니다. 이 오류를 해결하려면 두 블록 모두에 동일한 인덱싱 규칙을 지정하십시오. 자세한 내용은 Simulink 도움말 문서에서 Prelookup 및 Interpolation Using Prelookup 블록 도움말 페이지를 참조하십시오.</entry>
    <entry key="IndexConventionMismatch5">Inconsistent indexing conventions specified for block ''{0}'' connected to input port {1}{2,number,integer} of block ''{3}''. The Interpolation Using Prelookup block expects the Prelookup block to not use its last breakpoint for indexing; however, the Prelookup block is not configured to do so. To fix this error, enable the ''Valid index input may reach last index'' parameter for the Interpolation Using Prelookup block.</entry>
    <entry key="IncorrectIndexConventionSelectionPort">''{2}''의 {0}{1,number,integer}번 선택 포트는 지정된 인덱싱 규칙을 지원하지 않습니다. 이 오류를 해결하려면 Prelookup 블록에서 ''상한 지점 이상의 입력에 마지막 절점 사용''을 활성화하고 Interpolation Using Prelookup 블록에서 ''유효한 인덱스 입력이 마지막 인덱스에 도달할 수 있음'' 파라미터를 활성화하십시오.</entry>
    <entry key="IndexRangeMismatch">블록 ''{2}''의 {0}{1,number,integer}번 입력 포트의 값 범위가 대응하는 테이블 차원의 크기 {3,number, integer}과(와) 일치하지 않습니다. 다른 테이블 차원을 지정하거나, {0}{1,number,integer}번 입력 포트의 값 범위를 수정하십시오. </entry>
    <entry key="IndexFromBusRangeMismatch">The range of values for the first signal in the bus object propagated to the input port {0}{1,number,integer} of block ''{2}'' does not match the size of the corresponding table dimension of {3,number, integer}. Specify a different table dimension or modify the range for the first signal in the bus object propagated to the input port {0}{1,number,integer}.</entry>
    <entry key="InportCannotOutputVirtualBusWithVarDimsElement">''{0}''은(는) 가변 크기 요소를 갖는 가상 버스를 출력할 수 없습니다. 버스를 비가상 버스로 변경하거나, ''{1}'' 다음에 ''Signal Conversion'' 블록을 삽입하고 ''출력'' 파라미터를 ''신호 복사'' 또는 ''비가상 버스''로 설정하십시오.</entry>
    <entry key="InportCannotSpecifyTSForFcnCallSignal">입력 포트 ''{0}''에서는 함수 호출 신호의 샘플 시간을 변경할 수 없습니다. 입력 포트의 ''샘플 시간'' 옵션을 -1로 변경해 보십시오.</entry>
    <entry key="OutportCannotSpecifyTSForFcnCallSignal">Output port ''{0}'' is not allowed to change sample time of a function call signal. Consider changing ''Sample time'' option of output port to -1.</entry>
    <entry key="InportDialogTsIsNotInheritedWhenBusObjHasMultTs">입력 포트 ''{0}''의 샘플 시간 파라미터에 상속되지 않은 샘플 시간이 있습니다. 지정된 Bus 객체에 여러 샘플 시간이 있으므로 이 파라미터는 상속되는 것으로 설정해야 합니다.</entry>
    <entry key="InportHasPropedBusTypeButNoBusObj">루트 Inport 블록 ''{0}''의 출력 데이터형이 버스 데이터형 ''{1}''(으)로 설정되었지만, Inport 블록과 연결된 Bus 객체가 없습니다. 이 오류를 해결하려면 Inport 블록 대화 상자에 Bus 객체를 지정하십시오.</entry>
    <entry key="InportIterParamMismatch">The number of Inport blocks indicated by parameter ''{0}'' is {1,number,integer}. This value does not match the actual number of Inport blocks {2,number,integer} for subsystem ''{3}''.</entry>
    <entry key="InportMissingMasterInport">The controlling Inport for ''{0}'' does not exist.</entry>
    <entry key="InportRequiresNVBusForAOB">Inport block ''{0}'' must have dimensions ''1'' to output a virtual bus. Set dimensions to ''1'' or output a nonvirtual bus with dimensions ''{1}''. If you are upgrading a model from a previous version of Simulink, use the &lt;a href="matlab:sl(''upgradeadvisor'', ''{2}'')"&gt;Upgrade Advisor&lt;/a&gt;.</entry>
    <entry key="InportVarDimsCannotInterp">Invalid setting in ''{0}''. When "Dimensions mode" is set to "Variable" in signal specification, deselect the "Interpolate data" checkbox.</entry>
    <entry key="InportVarDimsSettingToZeroWarn">''{0}''에서 작업 공간에 불러온 가변 크기 신호의 길이가 시뮬레이션 스텝의 수보다 작습니다. 따라서 출력값은 최종 데이터 다음에 0으로 설정되고 현재 출력 포트 차원은 최대 출력 포트 차원으로 설정됩니다.</entry>
    <entry key="InputDimMismatch">{0,number,integer}번 입력에 대한 분할된 부분배열 개수는 {1,number,integer}입니다. 이 값은 서브시스템 ''{4}''의 입력 {3,number,integer}에 대한 분할된 부분배열 개수({2,number,integer})와 일치하지 않습니다. 모든 입력 신호의 분할된 부분배열 개수가 같도록 입력 신호의 크기나 분할 너비를 조정하십시오.</entry>
    <entry key="InputPortComplexityErr">Error in ''SetInputPortComplexity'' method of ''{0}''. The signal complexity of input port {1,number,integer} should have been set to ''{2}'', but was instead set to ''{3}''.</entry>
    <entry key="InputPortDatatypeErr">Error in ''SetInputPortDatatype'' method of ''{0}''. The data type ID of input port {1,number,integer} should have been set to {2,number,integer}, but was instead set to {3,number,integer}.</entry>
    <entry key="InputPortDimsErr1To1">Error in ''SetInputPortDimensions'' method of ''{0}''. The dimensions of input port {1,number,integer} should have been set to [{2,number,integer}], but was instead set to [{3,number,integer}].</entry>
    <entry key="InputPortDimsErr1To2">''{0}''의 ''SetOutputPortDimensions'' 메서드에 오류가 있습니다. {1,number,integer}번 입력 포트의 차원이 [{2,number,integer}](으)로 설정되었어야 했는데, 대신 [{3,number,integer}x{4,number,integer}](으)로 설정되었습니다.</entry>
    <entry key="InputPortDimsErr2To1">''{0}''의 ''SetOutputPortDimensions'' 메서드에 오류가 있습니다. {1,number,integer}번 입력 포트의 차원이 [{2,number,integer}x{3,number,integer}](으)로 설정되었어야 했는데, 대신 [{4,number,integer}](으)로 설정되었습니다.</entry>
    <entry key="InputPortDimsErr2To2">''{0}''의 ''SetOutputPortDimensions'' 메서드에 오류가 있습니다. {1,number,integer}번 입력 포트의 차원이 [{2,number,integer}x{3,number,integer}](으)로 설정되었어야 했는데, 대신 [{4,number,integer}x{5,number,integer}](으)로 설정되었습니다.</entry>
    <entry key="InputPortDimsModeErr">''{0}''의 ''SetInputPortDimensionsMode'' 메서드에 오류가 있습니다. {1,number,integer}번 입력 포트의 샘플링 모드가 ''{2}''(으)로 설정되었어야 했는데, 대신 ''{3}''(으)로 설정되었습니다.</entry>
    <entry key="InputPortFramenessErr">Error in ''SetInputPortSamplingMode'' method of ''{0}''. The sampling mode of input port {1,number,integer} should have been set to ''{2}'', but was instead set to ''{3}''.</entry>
    <entry key="InsertedGlobalDSMMsg">이 블록은 전역 작업 공간에 있는 Simulink.Signal 객체 ''{0}''에 해당하는 전역 데이터 저장소를 지원하기 위해 삽입됩니다.</entry>
    <entry key="InsertedLocalDSMMsg">이 블록은 모델 작업 공간에 있는 Simulink.Signal 객체 ''{0}''에 해당하는 로컬 데이터 저장소를 지원하기 위해 삽입됩니다.</entry>
    <entry key="InsertedDSMRefMsg">이 블록은 서브모델에서 데이터 저장소 ''{0}''에 대한 참조를 지원하기 위해 삽입됩니다</entry>
    <entry key="InsertedSharedLocalDSMMsg">이 블록은 ''{1}''에 있는 이름이 ''{0}''인 데이터 저장소에 해당하는 공유 로컬 데이터 저장소를 지원하기 위해 삽입됩니다.</entry>
    <entry key="InsertedSharedLocalDSMForHasBeenInitMsg">이 블록은 공유 데이터의 반복된 초기화를 방지하기 위해 삽입됩니다.</entry>
    <entry key="IntegratorStateLimitViolation">블록 {0}의 상태가 블록 파라미터 설정의 상한 및 하한을 위반했습니다. 이것이 섭동 기반 선형화 알고리즘 때문이라면 사용자가 섭동 수준을 조정하거나 해석적 선형화 알고리즘을 사용해 볼 수 있습니다.</entry>
    <entry key="IntermediateDTExceedsMaxFxpBits">블록 ''{0}''에서 '중간 결과' 데이터형의 워드 길이 비트 수가 지원되는 최댓값을 초과합니다. '중간 결과' 데이터형은 입력 및 출력 데이터형에서 파생됩니다.</entry>
    <entry key="IntermediateDTSizeOverSimulationLimit">유효하지 않은 내부 고정소수점 데이터형이 사용되었습니다. 블록 ''{0}''이(가) 내부 계산에 데이터형 ''{1}''을(를) 사용하고 있습니다. 이 데이터형에는 {2,number,integer}비트가 필요한데 이 블록에서 지원되는 최대 비트는 {3,number,integer}입니다.</entry>
    <entry key="IntermediateNotMatching">블록 ''{0}''에서 ''중간 결과 데이터형'' 및 ''테이블 데이터형''이 모두 부동소수점 데이터형이 아닌 경우 기울기와 편향이 같아야 합니다.</entry>
    <entry key="IntermediateNotMatching2">In block ''{0}'', when the ''Table data type'' is floating-point data type and the ''Intermediate results data type'' is fixed-point data type, the ''Intermediate  results data type'' must have trivial slope and bias.</entry>
    <entry key="InvalidInternalDataTypeForFixptMode">The parameter ''{0}'' of block ''{1}'' is of a floating point type, which is not supported. Consider changing the data type or selecting the ''Support floating-point numbers'' option on the Configuration Parameters &gt; Code Generation &gt; Interface pane.</entry>
    <entry key="InterpNDTooBigForCoverage">Interpolation 블록 ''{0}''의 테이블이 커버리지 리포트를 작성하기에 너무 큽니다. 이 테이블은 커버리지 레코딩 동안 무시됩니다.</entry>
    <entry key="MinMaxCollapseModeVarsizeCoverage">MinMax 블록 ''{0}''에 대한 관계형 경계 커버리지를 분석할 수 없습니다. '적용 범위' 파라미터가 '지정된 차원'으로 설정된 경우 가변 크기 입력을 갖는 MinMax 블록에는 관계형 경계 커버리지가 지원되지 않습니다.</entry>
    <entry key="InterpNdNotMultiFraction">블록 ''{0}''은(는) 소수 포트 f{1,number,integer}에 다차원 신호를 지원하지 않습니다.</entry>
    <entry key="InterpNdNotMultiIndex">블록 ''{0}''은(는) 인덱스 포트 k{1,number,integer}에 다차원 신호를 지원하지 않습니다.</entry>
    <entry key="InterpNdNotMultiOut">블록 ''{0}''은(는) 출력 포트에 다차원 신호를 지원하지 않습니다.</entry>
    <entry key="InterpNdNotMultiSelection">블록 ''{0}''은(는) 선택 포트 sel{1,number,integer}에 다차원 신호를 지원하지 않습니다.</entry>
    <entry key="InterpNdNotMultiBus">블록 ''{0}''은(는) 선택 포트 kf{1,number,integer}에 다차원 신호를 지원하지 않습니다.</entry>
    <entry key="NoBusWhenNumSelEqualsNumdims">The checkbox ''{0}'' can be enabled in block ''{1}'' only when block dialog parameter ''{2}'' is less than parameter ''{3}''.</entry>
    <entry key="InvActConnection">''{1}''의 {0,number,integer}번 포트는 하나의 If Action Subsystem 블록에 직접 또는 간접적으로 연결해야 합니다.</entry>
    <entry key="InvActConnectionNoSrc">서브시스템 ''{0}''의 동작 신호는 둘 이상의 대상 블록에 연결될 수 없습니다.</entry>
    <entry key="InvActSubsysConnection">서브시스템 ''{0}''의 동작 포트는 한 개의 If 또는 Switch-Case에만 연결할 수 있고, 두 개 이상의 If 또는 Switch-Case에는 연결할 수 없음</entry>
    <entry key="InvActionPort">서브시스템 ''{0}''에 제어 포트가 이미 존재합니다. 동작 포트를 추가하는 것은 허용되지 않습니다.</entry>
    <entry key="InvBlkMatName">파라미터 ''{1}''에 대해 ''{0}''에 지정된 MATLAB 변수 이름 ''{2}''이(가) 유효하지 않음</entry>
    <entry key="InvBlkParamLens">''{0}''의 파라미터 값에 대한 길이 또는 차원이 일치하지 않음</entry>
    <entry key="InvBusConstruction">블록 ''{1}''에서 생성된 버스에서 신호 ''{0}''을(를) 선택하면 해당 버스 생성 시 지정된 객체는 Bus 객체 ''{2}''이(가) 블록 ''{3}''과(와) 연결된다고 지정합니다. Bus 객체에 {4,number,integer}개의 요소가 있지만, 블록에는 {5,number,integer}개의 들어오는 신호가 있습니다.</entry>
    <entry key="InvBusCreatorInputsParam">''{0}''에서 \"입력\" 파라미터에 대한 설정이 유효하지 않습니다.</entry>
    <entry key="InvBusObjectNumElements">''{1}''에 지정된 버스 데이터형 ''{0_SLBus}''이(가) 유효하지 않습니다. 블록에 대한 입력에서의 신호 개수가 객체 요소의 개수와 일치해야 합니다.</entry>
    <entry key="InvBusObjectNumElements2">''{2}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;와 연결된 Bus 객체 ''{0_SLBus}''이(가) 유효하지 않습니다. 이 입력 포트에 들어오는 버스에 {3,number,integer}개의 신호가 있지만, 객체에는 {4,number,integer}개의 요소가 있습니다. 버스에 포함된 신호의 개수는 객체 요소의 개수와 일치해야 합니다.</entry>
    <entry key="InvCaseConditions">''{1}''의 ''{0}''에 대한 설정이 유효하지 않습니다. 각 셀은 32비트 부호 있는 정수 범위 이내의 정수 집합 또는 열거형 값으로 지정해야 합니다. 각 정수 값은 셀 하나에만 표시될 수 있습니다. 열거형 값에서 모든 값은 동일한 열거형 데이터형이어야 합니다.</entry>
    <entry key="InvCaseConditionsSameEnumType">''{1}''의 ''{0}''에 대한 설정이 유효하지 않습니다. 각 셀은 32비트 부호 있는 정수 범위 이내의 정수 집합 또는 열거형 값으로 지정해야 합니다. 열거형 값에서 모든 값은 동일한 열거형 데이터형이어야 합니다.</entry>
    <entry key="InvCaseConditionsVectorLength">''{1}''의 ''{0}''에 대한 설정이 유효하지 않습니다. 각 셀은 32비트 부호 있는 정수 범위 이내의 정수로 구성된 벡터 또는 열거형 값으로 지정해야 합니다. 모든 셀의 벡터는 길이가 같아야 합니다.</entry>
    <entry key="InvCaseDuplicateConditions">''{1}''의 ''{0}''에서 값 ''{2}''이(가) 중복됩니다. 각 셀은 정수 또는 열거형 값의 집합으로 지정해야 합니다. 각 정수 값은 고유해야 합니다.</entry>
    <entry key="InvCaseDuplicateConditionsEnum">Multiple conditions contain the same underlying integer value as ''{2}'' in ''{0}'' of ''{1}''. Each cell must be specified by a set of integers or enumerated values. For enumerated values, each underlying integer value must be unique.</entry>
    <entry key="InvCaseDuplicateConditionsVector">''{1}''의 ''{0}''에서 값 ''{2}''이(가) 중복됩니다. 각 셀은 정수로 구성된 벡터 또는 열거형 값으로 지정해야 합니다. 각 벡터 값은 고유해야 합니다.</entry>
    <entry key="InvCaseInputPortDataType">''{0}''의 입력 포트에 대한 데이터형 설정이 유효하지 않습니다. 이 포트는 내장 데이터형 및 열거형 데이터형을 받으며, 부울은 예외입니다.</entry>
    <entry key="InvCaseInputPortDataTypeEnum">Invalid data type setting for input port of ''{0}''. This port only accepts an enumerated data type if the case conditions are of that same enumerated data type</entry>
    <entry key="InvClogicTbl">The number of rows for the truth table in ''{0}'' must be a power of two</entry>
    <entry key="InvClogicTblDtype">Non-Boolean values are specified for Parameter {0} of {1}. If the parameter contains non-Boolean values, its data type must be double</entry>
    <entry key="InvConcatConnBusSrcWarn">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에서 ''{3}''의 &lt;sldiag objui="inport" objparam="{2,number,integer}" objname="{3}"&gt;{2,number,integer}번 입력 포트&lt;/sldiag&gt;로의 버스 연결이 부적절합니다. 이 버스는 벡터 신호로 처리됩니다. 이렇게 버스 신호를 부적절하게 사용하는 것은 향후 릴리스에서 더 이상 지원되지 않을 예정입니다. Bus Creator 대신 Concatenate 블록을 사용하여 벡터 신호를 생성해 보십시오.</entry>
    <entry key="InvDataTypeSettingForGain">블록 ''{0}''에 대해 ''이득'' 파라미터의 데이터형을 확인할 수 없습니다. 하지만 ''파라미터 특성'' 대화 상자 창의 ''파라미터 데이터형''이 ''이득에서 상속''으로 설정되었습니다. ''이득'' 파라미터의 데이터형을 지정하거나 ''파라미터 데이터형''에 다른 옵션을 선택하십시오.</entry>
    <entry key="InvDiscDutyCycle">''{0}''에서 듀티 사이클은 0과 100 사이여야 함</entry>
    <entry key="InvDiscPulseWidth">''{0}''에서 펄스 폭은 Pulse Generator 주기보다 작거나 같아야 함</entry>
    <entry key="InvDiscPulseWidthPulsePeriodSetting">The block ''{0}'' has Period and Pulse Width set so that the output is either always 0 or always equal to the amplitude. It is not a pulse signal any longer</entry>
    <entry key="InvDlgPrmTypeForConstantBlockDrivingICPort">Data type mismatch. When the Constant block ''{0}'' is connected to the external initial condition (IC) port of the Integrator block ''{1}'', its output signal data type must be the same as the data type of the ''Constant value'' parameter to ensure correct initialization of the integrator''s states</entry>
    <entry key="InvDlgPrmTypeForInitCondBlockDrivingICPort">Data type mismatch. When the Initial Condition block ''{0}'' is connected to the external initial condition (IC) port of the Integrator block ''{1}'', its output signal data type must be the same as the data type of the ''Initial value'' parameter to ensure correct initialization of the integrator''s states</entry>
    <entry key="InvExpMergeConnMultDst1">{1,number,integer}번 입력 포트에서 블록 ''{0}''을(를) 구동하는 버스 신호를 Merge 블록을 통해 전파할 수 없습니다. 원인은 Merge 블록의 비가상 Inport 블록 ''{2}'' 업스트림때문입니다. Merge 블록을 통해 버스 신호를 전파하려면 Inport 블록 다음에 ''Signal Conversion'' 블록을 삽입하고 해당 출력 파라미터를 ''신호 복사''로 구성하십시오. 그렇지 않은 경우 ''서로 다른 포트 너비 허용'' 체크박스를 선택하여 Merge 블록을 통해 버스 전파를 허용하지 마십시오.</entry>
    <entry key="InvExpMergeConnMultDst2">The connection from ''{0}'' &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;output port {1,number,integer}&lt;/sldiag&gt; to ''{2}'' input port {3,number,integer} is invalid. Signals being merged can only be connected to a Merge input port, must map to a unique element of the Merge block, and should not be connected to any other block input ports</entry>
    <entry key="InvVariantMergeUsage">&lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; of the ''{1}'' block is an input to a top-level outport block of the ''{2}'' variant subsystem block. All signals that are input to top-level outport blocks, must originate from a single output port of a nonvirtual block and cannot branch to multiple destination blocks. The output signal from the above port does not meet this requirement.
    &lt;actions exclusiveFixIts="yes"&gt;
    &lt;action type="fixit"&gt;
    &lt;cmd&gt;slprivate(''variantfixes'',''InsertSignalConversionBlk'',''{3}'')&lt;/cmd&gt;
    &lt;txt&gt;You can fix this error by inserting a Signal Conversion block at the input of the corresponding Outport of the ''{3}'' block in the variant child block.&lt;/txt&gt;
    &lt;/action&gt;
    &lt;/actions&gt; </entry>
    <entry key="InvVariantMergeUsage_fix">Signal Conversion 블록이 해당 Outport의 입력에 삽입되었습니다. </entry>
    <entry key="InvFcnCallSignalInIteratorSubsys">A function-call initiator inside iterator subsystem ''{0}'' may not call a function-call block that is not contained within the iterator subsystem</entry>
    <entry key="InvFixptBoolAccumDType">Cannot set the accumulator data type of ''{0}'' to ''Boolean''. To fix this problem, do not set the "Accumulator data type" of this block to "Inherit: Same as first input"</entry>
    <entry key="InvForIterVarSizeWidthConn">Port {0,number,integer} of For Iterator ''{1}'' cannot be connected to a width or a probe block whose input is a variable-size signal</entry>
    <entry key="InvForIterPortConn">For ''{1}''의 {0,number,integer}번 포트는 입력 포트, Width 블록, 또는 Probe 블록의 신호 너비 출력 포트에 연결되어야 합니다</entry>
    <entry key="InvIndexPortType">블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{0}" objname="{2}"&gt;입력 포트 {0}&lt;/sldiag&gt; {1,number,integer}번의 데이터형이 유효하지 않습니다. 인덱스 포트는 내장된 부동소수점 데이터형과 정수형, 그리고 기울기 1.0, 편향 0.0, 지수 0을 갖는 부동소수점만 지원합니다.</entry>
    <entry key="InvIndexPortTypeInBus">Invalid index signal in the bus. The first signal in the bus must be a built-in floating-point, integer, or fixed-point data types with a slope of 1.0, bias of 0.0, and exponent of 0.</entry>
    <entry key="InvFractionPortType">Invalid data type at fraction port {0}{1,number,integer} of block ''{2}''. Should be a built-in floating-point, integer, or fixed-point data type with a slope of 1.0, bias of 0.0, exponent less than or equal to 0, and, a range of [0 1] when the parameter ''{3}'' is ''off'' or a range of [0 1) when the parameter ''{4}'' is ''on''.</entry>
    <entry key="InvFractionPortTypeInBus">Invalid fraction signal in the bus. The second signal in the bus must be a built-in floating-point, integer, or a fixed-point data type with a slope of 1.0, bias of 0.0, exponent less than or equal to 0, and, a range of [0 1] when the parameter ''{0}'' is ''off'' or a range of [0 1) when the parameter ''{1}'' is ''on''.</entry>
    <entry key="InvBusDataType">Invalid bus object ''{0}'' propagated to the &lt;sldiag objui="inport" objparam="{1}" objname="{3}"&gt;input port {1}&lt;/sldiag&gt;{2,number,integer} of block ''{3}''.</entry>
    <entry key="InvGotoFromTagName">''{0}''에 지정된 태그 이름은 유효하지 않은 식별자입니다. 유효한 식별자는 영문자로 시작하고, 공백이나 특수 문자를 포함하지 않으며, 최대 {1,number,integer}자여야 합니다</entry>
    <entry key="InvGotoFromConnection">Goto/From 연결은 Variant Subsystem 내의 비가상 서브시스템(''{0}'' 및 ''{1}'')의 경계를 가로지를 수 없습니다. </entry>
    <entry key="InvInterSysConn1">Goto/From 연결은 비가상 서브시스템 경계를 가로지를 수 없습니다. 유일한 예외는 goto가 상태 출력 포트에 연결된 경우입니다</entry>
    <entry key="InvInterSysConn2">''{0}''(으)로 시작하는 연결이 유효하지 않음</entry>
    <entry key="InvInterSysConn3">''{0}''(으)로 끝나는 연결이 유효하지 않음</entry>
    <entry key="InvInterSysConn4">상태 출력 포트에서 시작된 신호를 따르는 Goto 블록 ''{0}''과(와) From 블록 ''{1}'' 사이의 연결은 레이터 변경이 필요한 비가상 서브시스템 경계를 통과하기 때문에 허용되지 않습니다.</entry>
    <entry key="InvInterSysConnImplicitIterSS">The subsystem ''{0}'' contains a For Each block (''{1}'') and has Goto/From connections that cross the subsystem boundaries. Simulink does not permit such crossings.</entry>
    <entry key="InvInterSysIfConnection">''{1}''의 {0,number,integer}번 포트에서 오는 신호는 비가상 서브시스템 경계를 가로지를 수 없습니다.</entry>
    <entry key="InvInterSysActionConnection">동작 신호는 Outport 블록 ''{0}''을(를) 통과하여 비가상 서브시스템 경계를 가로지를 수 없습니다.</entry>
    <entry key="InvInterSysActionConnection2">동작 신호는 비가상 서브시스템 ''{0}''의 경계를 가로지를 수 없습니다.</entry>
    <entry key="InvIteratorBlock">A control port already exists in subsystem ''{0}''. Addition of a For or While is not allowed.</entry>
    <entry key="InvLinblockFormChange">블록 다이어그램이 실행 중인 동안에는 {0} ''{1}''의 구현 형식을 변경할 수 없습니다.</entry>
    <entry key="InvLinblockSparseChange">You cannot change the zero matrix entries of the {0} ''{1}'' while the block diagram is running</entry>
    <entry key="InvLookup2dDataChange">외부 모드 또는 가속화된 모드에서 실행 중인 경우 2차원 룩업 ''{0}''의 행 또는 열 인덱스에서 0의 위치 또는 개수를 변경할 수 없습니다.</entry>
    <entry key="InvMatFile">''{0}''에는 적어도 2개의 행이 있는 비어 있지 않은 유한한 실수 행렬을 포함하는 MAT 파일이 필요합니다. 행렬의 요소는 NaN을 포함하지 않아야 하며 double형 데이터형만 가져야 합니다.</entry>
    <entry key="InvMatFileTimeseries">''{0}'' does not support timeseries input in this code generation mode. Consider converting the timeseries data into the array format. For information about the valid array format, see the documentation for the From File block. </entry>
    <entry key="InvFromFileDatatypeSetting">''{0}'' specifies a data type other than auto, double, or an alias type aliased to double. From File block supports non-double data type settings only for RSIM target. For any other code generation target, From File block must use one of the following data type settings: auto, double, or an alias type aliased to double.</entry>
    <entry key="InvFromFileInterpolationBuildConfig">''{0}'' specifies interpolation or extrapolation different from linear. From File block supports interpolation settings different from linear only for RSIM target. For any other code generation target, From File block must use only linear interpolation and extrapolation.</entry>
    <entry key="InvMergeBlockInAlgLoop">Merge 블록 ''{0}''을(를) 포함하는 대수 루프가 감지되었습니다. 대수 루프에는 Merge 블록이 허용되지 않습니다.</entry>
    <entry key="InvMergeConnBadDst">All elements of the signal from ''{0}'' output port {1,number,integer} must be connected to the same Merge ''{2}'' input port. Signals being merged should completely map onto a contiguous region within a Merge output port</entry>
    <entry key="InvMergeConnBadMdlRefSrc">The signal from Model block ''{0}'' &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;output port {1,number,integer}&lt;/sldiag&gt; cannot be connected to a Merge block. Use the following steps to address this problem, verifying that the problem still persists after each step before continuing to the next step. First, ensure all connections inside the referenced model comply with the Merge block connection rules. See Merge block documentation for rule details. Second, insert a Signal Conversion block before the Outport block of the top-most conditionally executed subsystem that connects directly to the root Outport. Finally, ensure that the signal driving each root Outport block originates from a single output port without any selection or reordering of elements</entry>
    <entry key="InvMergeConnBadMdlRefSrcHasMultiDsts">The signal from Model block ''{0}'' &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;output port {1,number,integer}&lt;/sldiag&gt; cannot be connected to a Merge block because the source block driving the corresponding root Outport in the referenced model is connected to multiple destinations.</entry>
    <entry key="InvMergeConnBadMdlRefSrcLoggedSignal">Model 블록 ''{0}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에서 오는 신호는 Merge 블록에 연결할 수 없습니다. 참조된 모델에서 대응되는 루트 Outport를 구동하는 신호가 현재 기록 중이기 때문입니다.</entry>
    <entry key="InvMergeConnBadMdlRefSrcSILPIL">You cannot connect the signal from Model block ''{0}'' &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;output port {1,number,integer}&lt;/sldiag&gt; to a Merge block when the Model block is in Software-in-the-Loop (SIL) or Processor-in-the-Loop (PIL) simulation mode. To work around this limitation, first make sure that no errors occur when the Model block is in Accelerator simulation mode. Next, restore the Model block simulation mode to its previous setting. Then, if the Model block is inside a conditionally executed subsystem that is connected to the Merge block, add a Signal Conversion block (Signal copy) between the Model block and the Outport of the conditionally executed subsystem. Alternatively, if the Model block is connected directly to the Merge block, add an Enabled Subsystem between the Model block and the Merge block that passes the signal straight through. Configure the Enable Port of the new Enabled Subsystem so that only one Merge block input is active at a time.</entry>
    <entry key="InvMergeConnBadSrc"> Connecting signal from ''{0}'' output port {1,number,integer} to a Merge block is not supported because the signal is required to be persistent.</entry>
    <entry key="InvMergeConnBadBusSelectionSrc"> ''{0}''의 {1,number,integer}번 출력 포트에서 오는 신호를 Merge 블록 ''{2}''(으)로 연결할 수 없습니다. 신호가 Bus Selector 블록에 의해 선택되기 때문입니다.</entry>
    <entry key="InvMemLayoutConnBadBusSelectionSrc"> 버스 요소 선택으로 인해 블록 ''{0}''에서 ''{2}'' 유형의 블록 ''{1}''(으)로의 연결이 유효하지 않습니다.</entry>
    <entry key="InvMergeConnCommonBrFcnCallInitDrivingMultMergeInputs">함수 호출 블록 ''{0}'' 및 ''{1}''에서 각각 Merge 블록 ''{2}'' {3,number,integer}번 입력 포트 및 {4,number,integer}번 입력 포트로 연결된 상태가 유효하지 않습니다. 이 함수 호출 블록은 둘 다 개시자 ''{6}''의 &lt;sldiag objui="outport" objparam="{5,number,integer}" objname="{6}"&gt;{5,number,integer}번 출력 포트&lt;/sldiag&gt;에서 호출됩니다. 같은 함수 호출 개시자에서 호출된 함수 호출 블록의 출력은 병합할 수 없습니다.</entry>
    <entry key="InvMergeConnCondMdlRefDrivingMultMergeInputs">조건부 실행 Model 블록 ''{0}''에서 Merge 블록 ''{1}'' {2,number,integer}번 입력 포트 및 {3,number,integer}번 입력 포트로 연결된 상태가 유효하지 않습니다. 동일한 조건부 실행 Model 블록을 동일한 Merge 블록의 여러 입력 포트에 연결할 수 없습니다. 이 제한 사항은 Model 블록이 Merge 블록에 직접 연결되었거나 다른 Merge 블록을 통해 간접적으로 연결된 경우 적용됩니다.</entry>
    <entry key="InvMergeConnCondSubsysDrivingMultMergeInputs">Invalid connection from conditionally executed subsystem ''{0}'' to Merge block ''{1}'' input port {2,number,integer} and input port {3,number,integer}. The same conditionally executed subsystem cannot be connected to multiple input ports of the same Merge block. This restriction applies when the subsystem is connected to the Merge block directly, or indirectly through other Merge blocks</entry>
    <entry key="InvMergeConnDiscontigCondSubsysSrc">Invalid connection from block ''{0}'' output port {1,number,integer} to Merge block ''{2}'' input port {3,number,integer}. An input signal to a Merge block that has been combined or reordered using Mux, Bus Creator, or Selector blocks must be combined inside of a single conditionally executed subsystem.</entry>
    <entry key="InvMergeConnDiscontigTaskSrc">Invalid connections from block ''{0}'' output port {1,number,integer} and block ''{2}'' output port {3,number,integer} to Merge block ''{4}'' input port {5,number,integer}. An input signal to a Merge block that has been combined or reordered using Mux, Bus Creator, or Selector blocks must originate from sources in the same task.</entry>
    <entry key="InvMergeConnMultDst">분기된 신호를 Merge 블록에 입력할 수 없습니다. ''{0}''의 {1,number,integer}번 출력 포트에서 오는 신호가 Merge 블록 ''{2}''의 {3,number,integer}번 입력 포트와 ''{4}''의 {5,number,integer}번 입력 포트에 모두 연결되어 있습니다. 이 오류를 수정하려면, &lt;sldiag objui="configset" objparam="UnderspecifiedInitializationDetection"&gt;과소 지정된 초기화 감지&lt;/sldiag&gt;를 '단순'으로 설정하거나 Signal Conversion 블록을 신호 복사 모드로 삽입하고 Signal Conversion 블록의 출력을 Merge 블록에만 입력하면 됩니다.</entry>
    <entry key="InvMergeConnLoggedSignal">기록된 신호를 Merge 블록에 입력할 수 없습니다. 이 오류를 해결하려면 Merge 블록 ''{0}''의 {1,number,integer}번 입력 포트에 연결된 신호에 대한 신호 기록을 끄십시오.</entry>
    <entry key="InvMergeConnMultWrite">Each element of the signal from ''{0}'' output port {1,number,integer} must map to a unique element of the Merge block ''{2}'' input port {3,number,integer}. All elements of a signal connected to a Merge input should completely map onto a unique and contiguous region within the output port of the Merge block</entry>
    <entry key="InvMergeConnNonCondSubsysSrc">
      
          블록 ''{0}''은(는) Iterator Subsystem이 아닌 조건부 실행 서브시스템 내에 있어야 합니다. &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;가 Merge 블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{3,number,integer}" objname="{2}"&gt;{3,number,integer}번 입력 포트&lt;/sldiag&gt;에 연결되어 있기 때문입니다.
      
    </entry>
    <entry key="InvMergeConnMultSrcTs">
      
          블록 ''{0}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;의 샘플 시간이 현재 {2}이고, 블록 ''{3}''의 &lt;sldiag objui="outport" objparam="{4,number,integer}" objname="{3}"&gt;{4,number,integer}번 출력 포트&lt;/sldiag&gt;의 샘플 시간이 현재 {5}인데, 이 두 샘플 시간이 일치해야 합니다. 둘 다 Merge 블록 ''{6}''에 병합되기 때문입니다.
      
    </entry>
    <entry key="InvalidMultiTaskMergeLocation">
      
          Merge block ''{0}'' must only merge to root Outport block because it has sources in multiple tasks, but it merges to block ''{1}''. Other Merge and Variant Source blocks are valid destinations of the Merge block ''{0}'' if they eventually merge to a root Outport block.
      
    </entry>
    <entry key="InvalidMultiTaskMergeRootOutport" context="error"> Merge block ''{0}'' with sources in multiple tasks was unable to merge to the root Outport block ''{1}'' with sample time specification.
      
        &lt;actions exclusiveFixIts="yes"&gt;
          &lt;action type="fixit" id="ResetRootOutputTsSpec" retvalue="false"&gt;
            &lt;cmd&gt;set_param(''{1}'', ''SampleTime'', ''-1'');&lt;/cmd&gt;
            &lt;txt&gt;Set the ''SampleTime'' parameter of root Outport block ''{1}'' to ''-1''.&lt;/txt&gt;
          &lt;/action&gt;
        &lt;/actions&gt;
      
    </entry>
    <entry key="InvalidMultiTaskMergeModelSetting" context="error">Connecting Merge block ''{0}'' to sources in multiple tasks is not supported.
      
        &lt;actions exclusiveFixIts="yes"&gt;
          &lt;action type="fixit" id="EnableBIMO" retvalue="false"&gt;
            &lt;cmd&gt;set_param(''{1}'', ''AllowMultiTaskInputOutput'', ''on'');&lt;/cmd&gt;
            &lt;txt&gt;Enable configuration parameter Allow multiple tasks to access inputs and outputs for model ''{1}''.&lt;/txt&gt;
          &lt;/action&gt;
        &lt;/actions&gt;
      
    </entry>
    <entry key="AllMergeBlocksDoNotSupportPartialWrite">Merge 블록 ''{0}''에서는 파라미터 '상호 배타적 쓰기와 전체 쓰기 보장'이 켜져 있는 반면, Merge 블록 ''{1}''에서는 이 파라미터가 꺼져 있습니다. 동일한 병합 트리에 속한 Merge 블록들은 이 파라미터의 설정이 같아야 합니다. 따라서 이 병합 트리에 속한 Merge 블록들에서 파라미터 '상호 배타적 쓰기와 전체 쓰기 보장'이 모두 '켜기'로 설정하거나 모두 '끄기'로 설정해야 합니다.</entry>
    <entry key="InvMergeConnNonScalarSrc">''{0}'' &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;는 입력 포트가 단 하나인 Merge 블록 ''{2}''에 연결되어 있으므로 이 포트에서 오는 신호는 스칼라여야 합니다.</entry>
    <entry key="InvMergeConnRootInport">Invalid connection to ''{0}'' input port {1,number,integer}, from Inport ''{2}''. External signals from root level inports can not be merged with internal block output signals</entry>
    <entry key="InvMergeConnSrcResetOnDisable">블록 ''{0}''의 {1,number,integer}번 출력 포트에서 Merge 블록 ''{2}''의 {3,number,integer}번 입력 포트로의 연결이 잘못되었습니다. 비활성화될 경우 블록 ''{4}''의 {5,number,integer}번 출력 포트(또는 소스 중 하나)는 값을 초기화하도록 구성되었기 때문에, Merge 블록에 연결할 수 없습니다.</entry>
    <entry key="InvMergePortWidths">Port width mismatch. For ''{0}'', the width+offset ({1,number,integer}) of input port {2,number,integer} is greater than the output port width ({3,number,integer})</entry>
    <entry key="InvMergeRunTimeMultipleWriters">Output of Merge block ''{0}'' is being updated concurrently at t = {1} by both block ''{2}'' &lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{2}"&gt;output port {3,number,integer}&lt;/sldiag&gt; and block ''{4}'' &lt;sldiag objui="outport" objparam="{5,number,integer}" objname="{4}"&gt;output port {5,number,integer}&lt;/sldiag&gt;. Ensure that the Merge block output is updated by only one of its input signals at every time step.
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="suggestion" btn="apply"&gt;
        &lt;cmd&gt;set_param(''{6}'',''MergeDetectMultiDrivingBlocksExec'',''none'');&lt;/cmd&gt;
        &lt;txt&gt;To disable this diagnostic for the model ''{6}'', set &lt;sldiag objui="configset" objparam="MergeDetectMultiDrivingBlocksExec" objname="{6}"&gt;Detect multiple driving blocks executing at the same time step&lt;/sldiag&gt; to ''none''.&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    
    </entry>
    <entry key="InvMergeRunTimeNoWriter">Output of Merge block ''{0}'' is not being updated at t = {1} because none of the blocks connected to the input ports of the Merge block are active. Ensure that the Merge block output is updated by one of its input signals at every time step.
      &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="suggestion" btn="apply"&gt;
        &lt;cmd&gt;set_param(''{2}'',''MergeDetectMultiDrivingBlocksExec'',''none'');&lt;/cmd&gt;
        &lt;txt&gt;To disable this diagnostic for the model ''{2}'', set &lt;sldiag objui="configset" objparam="MergeDetectMultiDrivingBlocksExec" objname="{2}"&gt;Detect multiple driving blocks executing at the same time step&lt;/sldiag&gt; to ''none''.&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    
    </entry>
    <entry key="InvMergeUnequalPortWidthsWhenUsingConsistentOutportInit">Invalid parameter ''{0}'' specified for the Merge block ''{1}''. This parameter cannot be set to ''on'' when the parameter ''UnderspecifiedInitializationDetection'' of the model ''{2}'' is set to ''Simplified''</entry>
    <entry key="InvMultidimConcatInputPortDims">유효하지 않은 포트 차원 {0}이(가) ''{2}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;에 지정되었습니다. 다차원 배열 모드의 경우 모든 입력 포트와 출력 포트에서 결합 차원 외의 다른 차원의 크기가 일치해야 합니다. 이 요구 사항이 입력 포트의 차원 {3,number,integer}에서 위반됩니다. 지정된 크기 {4,number,integer}이(가) 일부 다른 포트로 지정된 크기 {5,number,integer}과(와) 동일하지 않기 때문입니다.</entry>
    <entry key="InfMultidimConcatInputPortDims">유효하지 않은 포트 차원 {0}이(가) ''{2}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;에 지정되었습니다. 다차원 배열 모드에서는 결합 차원만 비유계일 수 있습니다. 이 요구 사항이 입력 포트의 차원 {3,number,integer}에서 위반됩니다.</entry>
    <entry key="InvMultidimConcatInputPortWidth">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 유효하지 않은 포트 너비가 지정되었습니다. 다차원 배열 모드의 경우 모든 입력 포트와 출력 포트에서 결합 차원 외의 다른 차원의 크기가 일치해야 합니다. 이 입력 포트에 대해 지정된 너비({2,number,integer})가 포트 중 하나에서 나타내는 차원 {4,number,integer}의 크기인 {3,number,integer}의 배수가 아닙니다.</entry>
    <entry key="InvMultidimConcatOutputPortDims">''{1}''의 출력 포트에 유효하지 않은 포트 차원 {0}이(가) 지정되었습니다. 다차원 배열 모드의 경우 모든 입력 포트와 출력 포트에서 결합 차원 외의 다른 차원의 크기가 일치해야 합니다. 이 요구 사항이 출력 포트의 차원 {2,number,integer}에서 위반됩니다. 지정된 크기 {3,number,integer}이(가) 일부 다른 포트로 지정된 크기 {4,number,integer}과(와) 동일하지 않기 때문입니다.</entry>
    <entry key="InfMultidimConcatOutputPortDims">유효하지 않은 포트 차원 {0}이(가) ''{2}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에 지정되었습니다. 다차원 배열 모드에서는 결합 차원만 비유계일 수 있습니다. 이 요구 사항이 출력 포트의 차원 {3,number,integer}에서 위반됩니다.</entry>
    <entry key="InvMultidimConcatOutputPortWidth">''{0}''의 출력 포트에 유효하지 않은 포트 너비가 지정되었습니다. 다차원 배열 모드의 경우 모든 입력 포트와 출력 포트에서 결합 차원 외의 다른 차원의 크기가 일치해야 합니다. 이 출력 포트에 대해 지정된 너비({1,number,integer})가 포트 중 하나에서 나타내는 차원 {3,number,integer}의 크기인 {2,number,integer}의 배수가 아닙니다.</entry>
    <entry key="InvMultidimConcatPortDimsTooLong">''{0}''에 유효하지 않은 포트 차원입니다. 다차원 배열 모드의 경우 출력 포트의 결합 차원 크기는 모든 입력 포트의 이 차원 크기를 합한 것과 같아야 합니다. 그러나 이 합은 허용 가능한 최대 32비트 부호 있는 정수 값보다 큽니다.</entry>
    <entry key="InvMultidimConcatPortDimsMismatch1">Port dimensions mismatch between input and output ports of ''{0}''. In multidimensional array mode, the size of the concatenate dimension for the output port must be equal to the sum of the sizes of this dimension for all input ports. This requirement is violated because this sum is at least {1,number,integer}, which exceeds the size {2,number,integer} of the concatenate dimension for the output port.</entry>
    <entry key="InvMultidimConcatPortDimsMismatch2">''{0}''의 입력 포트와 출력 포트 간의 포트 차원이 일치하지 않습니다. 다차원 배열 모드의 경우 출력 포트의 결합 차원 크기는 모든 입력 포트의 이 차원 크기를 합한 것과 같아야 합니다. 이 요구 사항이 위반됩니다. 합이 {1,number,integer}인데, 이 합은 해당 출력 포트의 결합 차원 크기 {2,number,integer}과(와) 같지 않기 때문입니다.</entry>
    <entry key="InvNumSelDimsSpec">Invalid ''Number of sub-table selection dimensions'' parameter specified for block ''{0}''. The number must be greater than or equal to 0 and less than or equal to the ''Number of table dimensions'' parameter value.</entry>
    <entry key="InvPortNumber">''{0}''에 지정된 포트 번호가 유효하지 않습니다. 포트 번호는 {1,number,integer}보다 작거나 같은 양의 정수 상수여야 합니다.</entry>
    <entry key="InvSFcnBlkName">''{0}''에 지정된 S-Function 이름이 유효하지 않음</entry>
    <entry key="InvSelBlkElParam">''{1}''에 지정된 파라미터 ''{0}''이(가) 차원 {2,number,integer}에 유효하지 않습니다. 파라미터는 범위 {3,number,integer}~{4,number,integer} 내에 있어야 합니다</entry>
    <entry key="InvSelBlkElParam2">Invalid parameter ''{0}'' specified in ''{1}'' for dimension {2,number,integer} due to integer overflow.</entry>
    <entry key="InvSelBlkElParam3">''{1}''에 지정된 파라미터 ''{0}''이(가) 차원 {2,number,integer}에 유효하지 않습니다. 이 파라미터는 {3,number,integer}보다 크거나 같아야 합니다</entry>
    <entry key="InvSelBlkElParamExpr">파라미터 ''{0}''의 표현식이 ''{2}''의 차원 {1,number,integer}에 유효하지 않음</entry>
    <entry key="InvSelBlkIdxParam">''{1}''에 지정된 파라미터 ''{0}''이(가) 유효하지 않음</entry>
    <entry key="InvSelBlkMxArrayParam">''{1}''에 지정된 파라미터 ''{0}''이(가) 유효하지 않습니다. 문자형 벡터로 구성된 셀형 배열이어야 합니다</entry>
    <entry key="InvSelOutWParam">In ''{0}'', parameter ''{1}'' for dimension {2,number,integer} should be less than or equal to input port width {3,number,integer}</entry>
    <entry key="InvSelectionPortType">블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{0}" objname="{2}"&gt;입력 포트 {0}&lt;/sldiag&gt; {1,number,integer}번의 데이터형이 유효하지 않습니다. 선택 포트는 내장된 부동소수점 데이터형과 정수형, 그리고 기울기 1.0, 편향 0.0, 지수 0을 갖는 부동소수점만 지원합니다.</entry>
    <entry key="InvStateSpaceXform">변환 "{1}"을(를) 사용하여 ''{0}''에서 얻은 A,B,C,D 행렬이 일관되지 않음</entry>
    <entry key="InvToFromFileNameFull">''{1}''에 유효하지 않은 파일 이름 ''{0}''이(가) 지정됨</entry>
    <entry key="InvToFromFileNameIncr">유효하지 않은 파일 이름</entry>
    <entry key="InvVectSelInpWidth">''{1}''에 지정된 파라미터 ''{0}''이(가) 유효하지 않습니다. 입력 포트 &lt;U&gt;에서 상속되는 경우 양의 정수이거나 -1이어야 합니다</entry>
    <entry key="InvWhileICPortConn">The actual source block ''{0}'' feeding the initial condition (IC) port of the While Iterator block ''{1}'' must be located outside the While Iterator subsystem ''{2}''.</entry>
    <entry key="InvalNumOutputPorts">Switch-Case 또는 If ''{0}''의 최대 아웃포트 개수는 128임</entry>
    <entry key="InvalidActSigSize">활성 신호의 너비가 {0,number,integer}입니다. 이 값은 서브시스템 ''{2}''의 분할된 부분배열 개수({1,number,integer})와 일치하지 않습니다. For Each 블록 ''{3}''의 블록 대화 상자에 지정된 파라미터 값을 변경하면 분할된 부분배열의 개수를 조정할 수 있습니다.</entry>
    <entry key="DidNotOutlineRTBWithForeach">Rate Transition 블록 ''{0}''이(가) For Each Subsystem 내에 있으므로 이 블록에 대한 코드가 별도의 함수로 생성되지 않습니다.</entry>
    <entry key="InvalidAsyncRTBDst">Rate Transition 블록 ''{0}''의 비동기 출력 포트가 또 다른 Rate Transition 블록 ''{1}''에 연결되어 있습니다. Rate Transition 블록의 비동기 출력 포트는 비동기 Function-Call Subsystem에 바로 연결해야 합니다. 비동기 Function-Call Subsystem의 각 입력 포트 앞과 각 출력 포트 뒤에 Rate Transition 블록을 추가하십시오. 두 개의 비동기 Function-Call Subsystem이 분기 없이 바로 연결된 경우에는 Rate Transition 블록이 하나만 필요합니다.</entry>
    <entry key="InvalidAsyncRTBSrc">The asynchronous input port of Rate Transition block ''{0}'' connects to another Rate Transition block ''{1}''. An asynchronous input port of a Rate Transition block must connect directly to an asynchronous function call subsystem. Add a Rate Transition block before each input port and after each output port of an asynchronous function call subsystem. If two asynchronous function call subsystems are directly connected without branching, only one Rate Transition block is needed.</entry>
    <entry key="AsyncRateTransBlkNotAllowedNoneInlinedSys">The rate transition block ''{0}'' cannot be placed in non-inlined subsystem. Changing the Code generation function packaging setting of the subsystem ''{1}'' to ''Inlined'' .</entry>
    <entry key="InvalidBlockName">Invalid block name ''{0}''. Block names may not begin or end with /</entry>
    <entry key="InvalidBusSelectorOutputSignals">''{0}''의 출력 신호는 쉼표로 구분된, 비어 있지 않은 문자형 벡터 목록이어야 합니다.</entry>
    <entry key="InvalidEnumStringCellArray">Parameter ''{0}'' specified in block ''{1}'' is invalid. Element {2,number,integer} in the cell array is not a valid character vector.</entry>
    <entry key="InvalidInputDim">The size of dimension {0,number,integer} of input {1,number,integer} to subsystem ''{2}'' must be a multiple of {3,number,integer}, the sum of the partition width {4,number,integer} and the partition offset {5,number,integer}. The subsystem, which contains a For Each block (''{6}''), can only partition an input signal into an integer number of subarrays.</entry>
    <entry key="InvalidIntParam">블록 ''{1}''의 파라미터 ''{0}''은(는) 스칼라여야 합니다.</entry>
    <entry key="InvalidMxArrayParam">Invalid parameter ''{0}'' specified in block ''{1}''. It should be a cell array of character vectors</entry>
    <entry key="InvalidNegOperationDim">''{1}''의 파라미터 ''{0}''은(는) 양의 정수여야 합니다.</entry>
    <entry key="InvalidNumTableDims">Invalid ''Number of table dimensions'' specified for block ''{0}''. Must be an integer between 1 and 30 and match the number of dimensions specified by the ''Table data'' parameter.</entry>
    <entry key="InvalidNumTableDimsForAkima">아키마 스플라인 보간 방법을 사용하는 블록 ''{0}''에 지정된 ''테이블 차원 수''가 유효하지 않습니다. 1과 6 사이의 정수여야 합니다.</entry>
    <entry key="InvalidNumWorkspaceCoefficientsForAkima">블록 ''{1}''의 계산된 작업 공간 계수의 수({0,number,integer})가 최댓값(2147483647)을 초과합니다. 차원에서 더 작은 '테이블 차원 수' 값 또는 더 적은 절점을 지정하십시오.</entry>
    <entry key="InvalidNumberOfOperationDim">''{1}''의 파라미터 ''{0}''은(는) 스칼라여야 함</entry>
    <entry key="InvalidDimValueSingletonMatrix">한원소 행렬 출력값이 유효하지 않습니다. ''{1}''의 ''{0}''은(는) 1보다 커야 합니다.</entry>
    <entry key="InvalidOutputDimensionsSize">''{1}''의 파라미터 ''{0}''에 대한 차원은 스칼라이거나 요소를 2개 가진 2차원 벡터여야 합니다.</entry>
    <entry key="InvalidSymbDimForIdentityMatrix">'단위 행렬' 모드의 기호 차원은 크기가 2인 벡터여야 합니다.</entry>
    <entry key="InvalidOperationDimExceedsBound">''{1}''의 파라미터 ''{0}''이(가) 입력 포트에서 신호의 차원 수보다 큽니다</entry>
    <entry key="InvalidRTBTsMultiple">Rate Transition block ''{0}'' parameter ''Multiple of input port sample time'' must be a positive value</entry>
    <entry key="InvalidRTWFcnName">서브시스템 ''{1}''에서 코드 생성을 위한 함수 이름 ''{0}''이(가) 유효한 함수 이름이 아님</entry>
    <entry key="InvalidResetIdentifierName">The event name ''{0}'' is an invalid identifier. Valid identifiers start with a letter and contain no spaces or special characters.</entry>
    <entry key="InvalidResetIdentifierNameReserved">이벤트 이름 ''{0}''은(는) Simulink Coder의 예약된 식별자이기 때문에 유효한 함수 이름이 아님</entry>
    <entry key="InvalidReinitIdentifierNameReserved">이벤트 이름 ''{0}''은(는) 디폴트 재초기화에 예약된 식별자이기 때문에 유효한 함수 이름이 아님</entry>
    <entry key="InvalidRTWFileName">The filename ''{0}'' for code generation in subsystem ''{1}'' is not a valid filename</entry>
    <entry key="InvalidResetSigSize">재설정 신호의 너비가 {0,number,integer}입니다. 이 값은 서브시스템 ''{2}''의 분할된 부분배열 개수({1,number,integer})와 일치하지 않습니다. For Each 블록 ''{3}''의 블록 대화 상자에 지정된 파라미터 값을 변경하면 분할된 부분배열의 개수를 조정할 수 있습니다.</entry>
    <entry key="InvalidRowDimension">''{0}''에서 ''{1}''의 행 개수는 S의 길이와 일치해야 합니다.</entry>
    <entry key="InvalidStringCellArray">Parameter ''{0}'' specified in block ''{1}'' is invalid. Element {2,number,integer} in the cell array should be a character vector.</entry>
    <entry key="InvalidSumInputNumber">''{0}'' must have at least one input</entry>
    <entry key="IteratedInputDimsModeMismatch1">For subsystem ''{0}'', the dimension mode of all input signals must be the same because the subsystem contains a For Each block (''{1}'').</entry>
    <entry key="IteratorBlockExists">A For, While, or For Each block already exists in subsystem ''{0}''. Addition of another control block is not allowed.</entry>
    <entry key="NeighborhoodBlockExists">A Neighborhood block already exists in subsystem ''{0}''. Addition of another control block is not allowed.</entry>
    <entry key="InvalidCtrlPortAddedToInitTermOrResetSS">''{0}''이(가) Initialize, Reinitialize, Reset 또는 Terminate Subsystem이므로 ''{0}''에 제어 포트를 추가할 수 없습니다.</entry>
    <entry key="JacobianTypeNotFound">블록 {0}에 대한 알 수 없는 야코비 행렬 유형임</entry>
    <entry key="LabelledConnectionNodeHasInvalidLabelString">The label specified for the block ''{0}'' is not a valid MATLAB variable name.</entry>
    <entry key="LinearizeComplexValue">''{0}''에서: 파라미터 값의 복소수부는 선형화 시 무시됨</entry>
    <entry key="LinearizeIsCustomizableAsGain">블록이 해석적으로 선형화되었습니다. 사용자는 이 블록을 이득으로 근사하도록 선형화할 수 있습니다.</entry>
    <entry key="LinearizeIsZeroAndCustomizableAsGain">블록이 0으로 해석적 선형화되었습니다. 사용자는 이 블록을 이득으로 근사하도록 선형화할 수 있습니다.</entry>
    <entry key="LogOfNegative">''{0}''에 음수의 로그가 있음</entry>
    <entry key="LogOfZero">Log of zero in ''{0}''</entry>
    <entry key="LogicBlkNeedsWideInput">''{0}''이(가) 하나의 입력 포트를 사용하도록 구성된 경우에는 와이드 벡터가 필요합니다(단, "NOT", "AND" 또는 "OR" 연산을 수행하는 경우는 제외). 이 오류를 해결하려면, 입력을 와이드 벡터로 만들거나 이 블록을 Data Type Conversion 블록으로 바꾸십시오.</entry>
    <entry key="LookupIgnoreDupValues">''{0}''에서 테이블 끝점의 중복 값은 무시됩니다.</entry>
    <entry key="LookupInputIsNaN">Input to lookup table in ''{0}'' is NaN</entry>
    <entry key="LookupInputMustBeVector">블록 ''{0}''에서 ''입력값으로 구성된 벡터''는 적어도 2개의 요소를 포함하는 실수형 벡터여야 함</entry>
    <entry key="LookupInputVectorAfterDup">블록 ''{0}''에서 ''입력값으로 구성된 벡터''는 중복 끝점이 제거된 후 적어도 2개의 요소를 포함하는 벡터여야 함</entry>
    <entry key="LookupInvDupEndpointChange">You cannot change the number of duplicate end points of the run-time parameter ''{0}'' in ''{1}'' from {2,number,integer} to {3,number,integer} while the model is simulating</entry>
    <entry key="LookupInvalidChangeToZeroVals">Invalid change made to the value of parameter ''{0}'' in ''{1}. The number of zeros in the vector of values cannot be changed during model execution</entry>
    <entry key="LookupMismatchedParams">블록 ''{0}''에서 ''입력값으로 구성된 벡터'' 파라미터와 ''테이블 데이터'' 파라미터의 길이가 동일해야 함</entry>
    <entry key="LookupNDCannotAnalyzeBpMsg">블록 ''{0}''에서 선형 탐색 방법을 사용하여 차원 {1,number,integer}의 절점 벡터에 대한 인덱스를 계산할 수 없습니다. 이러한 경우는 예를 들어 블록의 입력 신호에 NaN이 포함되어 있으면 발생할 수 있습니다. 블록의 입력 신호에서 NaN 값을 제거하거나 ''이진 탐색''을 블록의 ''인덱스 탐색 방법'' 파라미터 값으로 지정해 보십시오.</entry>
    <entry key="LookupNdEvenSpacingSpecificationSplineInvalid">Block ''{0}'' does not support ''Cubic spline'' and ''Akima spline' interpolation methods when breakpoint specification is set to ''Even spacing''. Use ''Explicit values'' instead.</entry>
    <entry key="LookupNDTooBigForCoverage">블록 ''{0}''의 룩업 테이블이 커버리지 리포트를 작성하기에 너무 큽니다. 이 테이블은 커버리지 레코딩 동안 무시됩니다.</entry>
    <entry key="LookupNdOutofRangeInputError">블록 ''{0}''의 입력 값이 차원 {1,number,integer}에 대한 절점 벡터의 범위를 초과합니다.</entry>
    <entry key="EnforceLookupNdOutofRangeInputError">블록 ''{0}''의 입력 값이 차원 {1,number,integer}에 대한 절점 벡터의 범위를 초과합니다. '입력값이 범위 내에 있다고 가정' 파라미터를 선택 해제하거나 입력값을 테이블 차원의 범위 내에 있도록 제한하십시오.</entry>
    <entry key="LookupNdOutputDataTypeInheritsUnsupportedType">Output data type of block ''{0}'' is set to "Inherit: Same as first input". The Output data type does not support the inherited type. Either change the Output data type setting from "Inherit: Same as first input" or change the first input data type.</entry>
    <entry key="LookupNdSplineHomogeneousInput">Block ''{0}'' supports ''Cubic spline'' and ''Akima spline'' interpolations only when all the Breakpoints data types are ''Inherit: Same as corresponding input''</entry>
    <entry key="LookupNdSplineHomogeneousInputParameterPort">블록 ''{0}''에서 {1,number,integer}번 입력 포트와 {2,number,integer}번 입력 포트의 데이터형이 일치하지 않습니다. ''3차 스플라인'' 및 ''아키마 스플라인'' 보간 방법을 사용하려면 입력 데이터형과 해당 절점 데이터형이 일치해야 합니다.</entry>
    <entry key="LookupNdComparisonDataTypeIsNotIdeal">블록 ''{0}''에, 차원 {1,number,integer}에 대한 입력 데이터와 절점 데이터를 모두 정확히 나타내는 데 이상적인 비교 데이터형이 없습니다. 입력 데이터형 또는 절점 데이터형을 변경하십시오.</entry>
    <entry key="LookupNdSplineHomogeneousOutput">Block ''{0}'' supports ''Cubic spline'' and ''Akima spline'' interpolations only when the Table data type is ''Inherit: Same as output''</entry>
    <entry key="LookupNdSplineHomogeneousOutputParameterPort">블록 ''{0}''에서 {1,number,integer}번 입력 포트의 데이터형과 출력의 데이터형이 일치하지 않습니다. ''3차 스플라인'' 및 ''아키마 스플라인'' 보간 방법을 사용하려면 테이블 데이터형과 출력 데이터형이 일치해야 합니다.</entry>
    <entry key="LUTObjDoesNotSupportSpline"> Block ''{0}'' specifies data using Lookup Table Object format. Spline interpolation/extrapolation is not supported for this format. Consider using a different method. </entry>
    <entry key="LUTObjDoesNotSupportAkimaSpline">'데이터 사양'이 ''lookup table 객체''로 설정된 경우 블록 ''{0}''은(는) 아키마 스플라인 보간 방법을 지원하지 않습니다. '데이터 사양'을 '테이블 및 절점'으로 설정해 보거나 다른 '보간 방법'을 사용해 보십시오.</entry>
    <entry key="SplineDoesNotSupportEnumBP">블록 ''{0}''에서 파라미터 ''{1}''의 데이터형이 열거형입니다. 이 데이터형은 ''3차 스플라인'' 및 ''아키마 스플라인'' 보간 방법에서 지원되지 않습니다.</entry>
    <entry key="LUTObjectDoesNotMatchBlockDimensions">Value of 'Number of table dimensions' parameter in block ''{0}'' ({1,number,integer}) must match the number of breakpoints of the referenced Simulink.LookupTable object ({2,number,integer}).</entry>
    <entry key="LookupNdMaxIndexIsNotValid">In block ''{0}'', the setting of parameter ''{1}'' is not valid. It should be a real scalar or vector. The individual value represents the maximum index value of corresponding break point data. As for this block, the correct value for this parameter is ''{2}''.</entry>
    <entry key="LookupNdMaxIndexIsNotDefined">The parameter ''{0}'' of ''{1}'' is not defined. When parameter ''{2}'' is checked, ''{3}'' must be defined.</entry>
    <entry key="LookupNdMaxIndexIsNotTunable">The parameter ''{0}'' of ''{1}'' is not tunable. When parameter ''{2}'' is checked, ''{3}'' must be tunable parameter.</entry>
    <entry key="LookupNdMaxIndexDataTypeIsNotSupported">In block ''{0}'', the data type for parameter ''{1}'' is ''{2}'', which is not supported. Only built-in integer types and floating point types are supported. </entry>
    <entry key="LookupTableMustBeVector">블록 ''{0}''의 ''테이블 데이터''는 적어도 2개의 요소를 포함하는 벡터여야 함</entry>
    <entry key="LookupNdMultidimensionalInputsOutputsNotSupported">블록 ''{0}''은(는) 다차원 신호를 입력 또는 출력으로 지원하지 않습니다.</entry>
    <entry key="LookupTableMismatchEvenspacingSpecification"> 블록 ''{0}''이(가) 테이블 데이터를 지정하는 데 Simulink.LookupTable 객체를 사용하고, 참조된 Simulink.LookupTable 객체의 ''BreakpointsSpecification''이 ''균일한 간격''으로 설정되어 있습니다. 그러나 블록 ''{0}''의 알고리즘 탭에서 '인덱스 탐색 방법' 파라미터가 ''균일 간격의 점''으로 설정되지 않았습니다. 블록은 이 설정을 무시합니다. 이 경고를 제거하려면 '인덱스 탐색 방법' 파라미터를 ''균일 간격의 점''으로 설정하십시오.</entry>
    <entry key="MATLABFcnBadDataType">''{0}''에서 오류가 발생했습니다. 표현식 실행 결과, 유효하지 않는 출력이 발생했습니다. 유한한 double형 벡터 또는 행렬 출력만 지원됩니다</entry>
    <entry key="MATLABFcnEvalErr">표현식을 평가하는 중 ''{0}''에서 오류가 발생했습니다.</entry>
    <entry key="LockedMATLABFunction">The MATLABFunctionConfiguration object cannot be modified because the library containing the MATLAB Function block is locked. Unlock the library to make changes to the block. </entry>
    <entry key="LinkedMATLABFunction">The MATLABFunctionConfiguration object cannot be modified because the MATLAB Function block is currently linked to a library. Modify the block from the library or break the link to the library to modify this block.</entry>
    <entry key="MATLABFcnIncompleteSimState">지정된 MATLAB 함수 또는 표현식의 영속 변수가 MATLAB Function 블록 {0}의 동작점에 포함되어 있지 않기 때문에 해당 동작점이 불완전할 수 있습니다. 자세한 설명은 Simulink 도움말 문서에서 동작점 저장/복원 제한 사항을 참조하십시오.</entry>
    <entry key="MATLABFcnInv1DCollapse">Invalid setting for parameter ''{0}'' of {1}. The 2-D output dimensions specified contradict the option to collapse the function output into a 1-D vector</entry>
    <entry key="MATLABFcnInvInDims1">차원 {1}을(를) 갖도록 {0}의 &lt;sldiag objui="inport" objparam="1" objname="{0}"&gt;1번 입력 포트&lt;/sldiag&gt;를 설정할 수 없습니다. 이러한 차원을 갖는 입력에 대해, 지정된 MATLAB 함수 또는 표현식은 {2,number,integer}개 요소를 갖는 출력을 생성하는 데 반해 출력은 이미 {3,number,integer}개 요소를 갖도록 설정되어 있습니다</entry>
    <entry key="MATLABFcnInvInDims2">차원 {1}을(를) 갖도록 {0}의 &lt;sldiag objui="inport" objparam="1" objname="{0}"&gt;1번 입력 포트&lt;/sldiag&gt;를 설정할 수 없습니다. 이러한 차원을 갖는 입력에 대해, 지정된 MATLAB 함수 또는 표현식은 차원 {2}의 행렬을 생성하는 데 반해 출력은 이미 1차원 벡터로 설정되어 있습니다</entry>
    <entry key="MATLABFcnInvInDims3">차원 {1}을(를) 갖도록 {0}의 &lt;sldiag objui="inport" objparam="1" objname="{0}"&gt;1번 입력 포트&lt;/sldiag&gt;를 설정할 수 없습니다. 이러한 차원을 갖는 입력에 대해, 지정된 MATLAB 함수 또는 표현식은 차원 {2}의 행렬을 생성하는 데 반해 출력은 이미 차원 {3}을(를) 갖도록 설정되어 있습니다</entry>
    <entry key="MATLABFcnInvMultiDims">{0}의 입력 차원을 설정할 수 없습니다. 지정된 MATLAB 함수 또는 표현식은 차원이 2보다 큰 출력을 반환합니다.</entry>
    <entry key="MATLABFcnInvParamSetting">Parameter ''Output dimensions'' specified in ''{0}'' is invalid. Output dimensions must be either -1 (dynamically sized), or a scalar greater than or equal to 0, or a positive, non-zero vector of length 2</entry>
    <entry key="MATLABFcnOutputFcnErr">Error evaluating MATLAB function in ''{0}''</entry>
    <entry key="MATLABFcnOutputIsComplex">''{0}''의 출력 포트 신호 유형은 실수(복소수 아님)이지만, 평가된 출력은 복소수입니다. ''{1}''을(를) 복소수로 설정해 보십시오.</entry>
    <entry key="MATLABFcnOutputMatrixTypeErr">출력을 계산하는 중 ''{0}''에서 오류가 발생했습니다. {2} 행렬이 필요한데 결과가 {1} 행렬입니다</entry>
    <entry key="MATLABFcnOutputWidthErr">출력을 계산하는 중 ''{0}''에서 오류가 발생했습니다. 필요한 너비는 {2,number,integer}인데 결과로 발생한 너비는 {1,number,integer}입니다</entry>
    <entry key="MATLABFcnReshapeWarning">''{0}''이(가) {1} 행렬 데이터를 생성했습니다. 그리고 데이터의 형태를 {2,number,integer}개의 요소를 갖는 1차원 벡터로 자동으로 변경했습니다.</entry>
    <entry key="MergeBlockDrivenByConstantSampleTime">In {1}, when the merge block ''{0}'' receives a constant value and non-constant sample times, one of these conditions must hold:
    \n *  The source of the constant value is a grounded signal.
    \n *  The source of the constant value is a constant block with a non-tunable parameter.
    \n     - There is only one constant block that feeds the merge block.
    \n     - All other input signals to the merge block are from conditionally executed subsystems.
    \n     - The merge block and the outport blocks of all conditionally executed subsystems should not specify any initial outputs.</entry>
    <entry key="MPSwitchDeadPorts">The control port data type of block ''{0}'' cannot represent the values ''{1}''. These values are being used as data port indices, the corresponding data ports are dead ports and will never be used in simulation.</entry>
    <entry key="MPSwitchControlInputRangeError">블록 ''{0}''에서 제어 포트 값 ''{1}''이(가) 범위를 벗어납니다. 이 블록에서 값은 ''{2}''과(와) ''{3}'' 사이여야 합니다.</entry>
    <entry key="MPSwitchControlInputOORIndexValue">블록 ''{0}''에서 제어 포트 값 ''{1}''이(가) ''{2}''과(와) ''{3}'' 사이에 있지 않습니다. 이 메시지를 표시하지 않고 default 포트를 사용하려면 ''default case에 대한 진단''의 설정을 ''안 함''으로 변경하면 됩니다</entry>
    <entry key="MPSwitchEnumTypeWithContiguousInputs">The ''Data port order'' for block ''{0}'' is set to be contiguous and the data type of the control port for this block is of enumerated type. If the control port is of enumerated type then the  ''Data port order'' should be set to ''Specify indices''. You can also use &lt;a href="matlab:upgradeadvisor(bdroot)"&gt;Upgrade Advisor&lt;/a&gt; to update this block</entry>
    <entry key="MPSwitchInvalidControlPortValue">''{1}''에 대한 제어 값 ''{0}''이(가) 어떤 데이터 포트 인덱스에도 대응되지 않습니다. 이 메시지를 표시하지 않고 default 포트를 사용하려면 ''default case에 대한 진단''의 설정을 ''안 함''으로 변경하면 됩니다</entry>
    <entry key="MPSwitchInvalidValueForEnumDataType">''{0}''의 입력은 열거형이고 기본 값 {1,number,integer}({2,number,integer}번 데이터 포트의 인덱스)이(가) 포함되어 있지 않습니다.</entry>
    <entry key="MPSwitchNonIntegerControlInput">''{0}''에서 정수가 아닌 제어 신호가 잘림</entry>
    <entry key="MPSwitchDynamicArrayReqScalarControlPort">''{0}''에 대한 출력이 동적 배열 신호인 경우 제어 포트에 대한 입력 신호는 스칼라여야 합니다.</entry>
    <entry key="MPSwitchDoesNotSupportVarDimsMode">The input port {1, number, integer} of block ''{0}'' is a variable-size signal, the block does not support variable-size input signals.</entry>
    <entry key="MPSwitchOneDataPortWithIndexSpecification">블록 ''{0}''의 ''데이터 포트 순서''에 옵션 ''인덱스 지정''이 선택되어 있습니다. 이 옵션에서는 한 개의 데이터 포트 case는 지원되지 않습니다. ''데이터 포트 인덱스''에 둘 이상의 데이터 포트에 대한 값을 지정하십시오.</entry>
    <entry key="MPSwitchTurnOnVarDimsMode">Multiport Switch 블록 ''{0}''의 데이터 입력 포트의 신호 차원이 서로 다릅니다. 가변 크기 출력 신호를 지원하려면, 해당 블록 대화 상자의 "신호 특성" 창에서 파라미터 "서로 다른 데이터 입력 크기 허용(가변 크기의 출력 신호 발생)"을 선택하십시오.</entry>
    <entry key="MPSwitchVarDimsModeFrameReqFirstDimMatch">''{0}''에 대해 "서로 다른 데이터 입력 크기 허용(가변 크기의 출력 신호 발생)" 파라미터가 선택되고 입력 신호가 프레임 기반 신호인 경우, 모든 입력 신호의 첫 번째 차원은 같은 크기여야 합니다.</entry>
    <entry key="SwitchVarDimsModeReqInputFrameMatch">When the "Allow different data input sizes (Results in variable-size output signal)" parameter is selected for ''{0}'', the data input signals must have the same sampling mode.</entry>
    <entry key="MPSwitchVarDimsModeReqMultipleDataPorts">''{0}''에 대해 "서로 다른 데이터 입력 크기 허용(가변 크기의 출력 신호 발생)" 파라미터가 선택된 경우, 입력 데이터 포트의 개수는 1보다 커야 합니다.</entry>
    <entry key="MPSwitchVarDimsModeReqOneBranchFitOther">When the "Allow different data input sizes (Results in variable-size output signal)" parameter is selected for ''{0}'', the signal at one input port must have dimensions that are greater than or equal to the corresponding dimensions of any other input signal.</entry>
    <entry key="MPSwitchCtrlPortEnumWithNumTypeDataPorts">For block ''{0}'', the data type of the control port is enumerated type but the data ports specified in ''Data port indices'' are numerical type. Please specify ''Data port indices'' using the corresponding enumerated type.</entry>
    <entry key="MPSwitchCtrlPortNumTypeWithEnumDataPorts">블록 ''{0}''에서 제어 포트의 데이터형은 숫자형이지만, ''데이터 포트 인덱스''에 지정된 데이터 포트는 열거형입니다. 숫자형을 사용하여 ''데이터 포트 인덱스''를 지정하거나, Upstream 블록을 사용하여 제어 포트 데이터형을 열거형으로 지정하십시오.</entry>
    <entry key="MPSwitchControlInputOORDataType">블록 ''{0}''의 경우 부동소수점 데이터형의 제어 포트 값 ''{1}''은(는) 프로덕션 하드웨어에서 'int'의 데이터형 범위 내에 있어야 합니다.</entry>
    <entry key="MSFBInAccelerateModeWithoutTLC">The method block.SetAccelRunOnTLC(true) is specified for the MATLAB S-function ''{0}'' in block ''{1}''. However, a corresponding ''{2}.tlc'' file does not exist in the current working directory, the MATLAB S-function directory ''{3}'', or the directory ''{4}''</entry>
    <entry key="MSFBMFileExistsWithoutTLC">블록 ''{2}''의 MATLAB S-Function ''{1}''에 대응되는 ''{0}.tlc'' 파일은 현재 작업 디렉터리, MATLAB S-Function 디렉터리 ''{3}'' 또는 디렉터리 ''{4}''에 있어야 합니다</entry>
    <entry key="MSFB_AutoRegRTPCalledInUnallowedPhase">''{0}'' of MATLAB S-Function ''{1}'' can be called only in the PostPropagationSetup method of ''{2}''</entry>
    <entry key="MSFB_AutoUpdateRTPCalledInUnallowedPhase">MATLAB S-Function ''{0}''의 ''AutoUpdateRuntimePrms''는 ''{1}''의 ProcessParameters 메서드에서만 호출할 수 있음</entry>
    <entry key="MSFB_BlockMethodDoesNotExist">''{2}''에 있는 MATLAB S-Function ''{1}''의 메서드 ''{0}''에 대해 지정된 함수 핸들이 유효하지 않습니다.</entry>
    <entry key="MSFB_BlockMethodFailed">''{2}''에서 MATLAB S-Function ''{1}''의 등록된 메서드 ''{0}''을(를) 실행하는 중 오류가 발생했습니다. 이 오류를 생성한 MATLAB 호출 스택(파일 이름 및 라인 번호)은 다음과 같습니다: {3}</entry>
    <entry key="MSFB_BlockMethodFailed_NoStacktrace">''{2}''에서 MATLAB S-Function ''{1}''의 등록된 메서드 ''{0}''을(를) 실행하는 중 오류가 발생했습니다.</entry>
    <entry key="MSFB_DworkRegComplexDynamic">''{1}''의 Dwork {0,number,integer}에 대한 실수/복소수 여부는 ''Real'' 또는 ''Complex''만 될 수 있음</entry>
    <entry key="MSFB_DworkRegDatatypeDynamic">''{1}''의 Dwork {0,number,integer} 데이터형은 동적으로 지정될 수 없습니다. Dwork의 데이터형은 MATLAB ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'', ''double'' 데이터형 중 하나여야 함</entry>
    <entry key="MSFB_DworkRegNameEmpty">The name of Dwork {0,number,integer} in ''{1}'' cannot be an empty character vector</entry>
    <entry key="MSFB_DworkRegWidthDynamic">''{1}''의 Dwork {0,number,integer}의 너비는 양의 정수여야 함</entry>
    <entry key="NoCompiledData">사용 가능한 컴파일된 데이터가 없습니다. DWork 오프셋을 쿼리하려면 컴파일된 데이터가 필요합니다.</entry>
    <entry key="DWorkRecListIsNULL">블록의 DWork 레코드 목록이 null입니다.</entry>
    <entry key="MSFB_InvNumPrms">''{0}''의 대화 상자 파라미터 개수는 음수일 수 없음</entry>
    <entry key="MSFB_InvalidDlgPrmTunableSetting">Invalid setting specified for the tunability of the dialog parameters of ''{0}'' in ''{1}''. The tunability for dialog parameters should be a [1x{2,number,integer}] cell array of the form '{'''Tunable'',''Nontunable'',''SimOnlyTunable'',...'}'</entry>
    <entry key="MSFB_InvalidInputIndexForDependencyRuleTerm">''{0}''의 메서드 ''AddOutputDimsDependencyRules''의 두 번째 입력에 대해 지정된 입력 포트 인덱스가 유효하지 않습니다. 입력 포트 인덱스는 1~{1,number,integer} 범위의 양의 정수로 구성된 배열이어야 합니다.</entry>
    <entry key="MSFB_InvalidOutputIndexForDependencyRuleTerm1">''{0}''의 메서드 ''AddOutputDimsDependencyRules''의 첫 번째 입력에 대해 지정된 출력 포트 인덱스가 유효하지 않습니다. 출력 포트 인덱스는 1이어야 합니다.</entry>
    <entry key="MSFB_InvalidOutputIndexForDependencyRuleTerm2">''{0}''의 메서드 ''AddOutputDimsDependencyRules''의 첫 번째 입력에 대해 지정된 출력 포트 인덱스가 유효하지 않습니다. 출력 포트 인덱스는 1~{1,number,integer}의 범위에 있어야 합니다.</entry>
    <entry key="MSFB_InvalidSetDimFcnForDependencyRuleTerm">''{0}''의 메서드 ''AddOutputDimsDependencyRules''의 세 번째 입력에 대해 지정된 인수가 유효하지 않습니다. 세 번째 입력은 함수 핸들이어야 합니다.</entry>
    <entry key="MSFB_InvalidVarSizeTypeSetting">Invalid setting specified for ''SignalSizesComputeType'' of ''{0}''. The ''SignalSizesComputeType'' should be ''FromInputSize'' or ''FromInputValueAndSize''</entry>
    <entry key="MSFB_MFileNotExist">Level-2 MATLAB S-Function ''{0}''이(가) 존재하지 않습니다.</entry>
    <entry key="MSFB_NumPrmsError">''{0}''의 필요한 대화 상자 파라미터 개수({1,number,integer})가 MATLAB S-Function 파라미터 대화 상자에 지정된 대화 상자 파라미터 개수({2,number,integer})와 일치하지 않음</entry>
    <entry key="MSFB_RTWInvPrmName">''{1}''에 있는 MATLAB S-Function ''{0}''의 파라미터 이름은 문자형 벡터여야 함</entry>
    <entry key="MSFB_RTWInvStrPrmVal">The parameter ''{0}'' of  MATLAB S-Function ''{1}'' in ''{2}'' must be a character vector</entry>
    <entry key="MSFB_SetDlgPrmPropBeforeSetNumDlgPrms">대화 상자 파라미터의 조정 가능성을 설정하기 전에 ''{1}''에 있는 MATLAB S-Function ''{0}''의 대화 상자 파라미터 개수를 설정해야 함</entry>
    <entry key="MSFB_SetOutputDimsMethodFailed">''{1}''의 MATLAB S-Function ''{0}''에 ''AddOutputDimsDependencyRules''를 사용하여 등록된 setOutputDims 메서드를 실행하는 중 오류가 발생했습니다. 이 오류를 생성한 MATLAB 호출 스택(파일 이름 및 라인 번호)은 다음과 같습니다: {2}</entry>
    <entry key="MSFB_SetOutputDimsMethodFailed_NoStacktrace">''{1}''의 MATLAB S-Function ''{0}''에 ''AddOutputDimsDependencyRules''를 사용하여 등록된 setOutputDims 메서드를 실행하는 중 오류가 발생했습니다.</entry>
    <entry key="MSFB_Setup">MATLAB S-Function ''{0}''에 대한 초기화를 실행하는 중 오류가 발생했습니다. 이 오류를 생성한 MATLAB 호출 스택(파일 이름 및 라인 번호)은 다음과 같습니다: {1}</entry>
    <entry key="MSFB_Setup_NoStacktrace">MATLAB S-Function ''{0}''에 대한 초기화를 실행하는 중 오류가 발생했습니다.</entry>
    <entry key="MSFB_UnknownMethod">''{0}''에 대한 메서드를 등록하는 중 오류가 발생했습니다. ''{1}''은(는) 알 수 없는 메서드입니다.</entry>
    <entry key="MSFB_WriteRTWPrmCalledInUnallowedPhase">MATLAB S-Function ''{0}''의 ''WriteRTWParam''은 ''{1}''의 WriteRTW 메서드에서만 호출할 수 있음</entry>
    <entry key="MSFCN_NOT_PST_WITH_PSTFCN">In ''{0}'', you have registered either ''SetInputPortSampleTime'' or ''SetOutputPortSampleTime'' method without initializing port sample times in the block setup method</entry>
    <entry key="MSFcnCustomSimStateNotSupported">블록 ''{2}''의 MATLAB S-Function ''{1}''에는 SimStateCompliance에 대한 ''{0}'' 설정이 지원되지 않음</entry>
    <entry key="MSFcnInvCompNonRuntimeRate"> ''{0}'' has an invalid constant sample time. Discrete states are not allowed with constant sample times.</entry>
    <entry key="MSFcnInvTnext">Time of next hit, {0}, specified in S-function ''{1}'' in ''{2}'' must be greater than previous time hit value of {3}</entry>
    <entry key="MSFcnInvalidDWorkIndex">''{0}''에 대한 메서드 ''MSFcnDWorkRequireResetForSignalSize''에 대해 지정된 dwork 인덱스가 유효하지 않습니다. 입력 포트 인덱스는 1~{1,number,integer} 범위의 양의 정수로 구성된 배열이어야 합니다.</entry>
    <entry key="MSFcnInvalidRTPNameSpec">Invalid run-time parameter names specified in ''{0}'' when calling ''AutoRegRuntimePrms'' method. The run-time parameter names should be a cell array containing character vectors and of length {1,number,integer}</entry>
    <entry key="MSFcnInvalidSimStateComplianceSetting">블록 ''{1}''의 MATLAB S-Function ''{0}''에서 SimStateCompliance에 대한 설정이 유효하지 않습니다. 이 설정은 문자형 벡터 {2} 중 하나여야 합니다.</entry>
    <entry key="MSFcnMissingSetInputDimsMode">''{1}''의 Level-2 MATLAB S-Function ''{0}''에 ''SetInputPortDimensionsMode'' 메서드가 없습니다. 여러 개의 출력 포트가 있는 Level-2 MATLAB S-Function에서 포트 중 하나라도 차원 모드 설정을 상속하는 경우 ''SetInputPortDimensionsMode'' 메서드를 등록해야 합니다.</entry>
    <entry key="MSFcnMissingSetPortSampleTime">Level-2 MATLAB S-function ''{0}'' in ''{1}'' has port-based sample times, but it does not register ''SetInputPortSampleTime'' or ''SetOutputPortSampleTime'' method</entry>
    <entry key="MSFcnSimViewingDeviceWithOutput">Level-2 MATLAB S-function ''{0}'' in ''{1}'' specifies ''SetSimViewingDevice(true)'' , which prevents an output port from being created for the S-function.</entry>
    <entry key="MSFcnSimStateMethodNotFound">블록 ''{1}''의 Level-2 MATLAB S-Function ''{0}''이(가) 시뮬레이션 동작점 준수를 ''{2}''(으)로 지정했지만, ''{3}'' 메서드를 갖고 있지 않음</entry>
    <entry key="MSfcnRedundantDimsDepRule">블록 ''{1}''의 Level-2 MATLAB S-Function ''{0}''이(가) 출력 {2,number,integer}에 대해 중복된 출력 차원 종속성 규칙을 등록했습니다. 규칙 {3,number,integer}에 등록된 입력 인덱스는 기존 규칙의 부분 집합이거나 상위 집합입니다. 예를 들어, 입력 인덱스 "1, 2"를 포함한 규칙은 입력 인덱스 "1", "2" 또는 "1, 2"를 포함한 다른 규칙이 이미 있으면 중복 규칙입니다.</entry>
    <entry key="MatCheckPureSingularity">시간 {2}에서 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 있는 입력 행렬이 특이 행렬입니다.&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="MatCheckSingularity">시간 {2}에서 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;의 입력 행렬이 특이 행렬에 가깝습니다.</entry>
    <entry key="MatDivNoSquareMatrix_1D">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 대해 지정된 차원이 유효하지 않습니다. 행렬 나누기는 정사각 행렬에만 사용할 수 있습니다. 하지만 입력 신호는 {2,number,integer}개의 요소를 갖는 1차원 벡터입니다</entry>
    <entry key="MatDivNoSquareMatrix_2D">Invalid dimensions specified for the &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of ''{1}''. Matrix division is only supported for square matrices. However, the input signal is a {2} matrix</entry>
    <entry key="MatGainInvInDimsKuBasic">''{0}''의 &lt;sldiag objui="inport" objparam="1" objname="{0}"&gt;1번 입력 포트&lt;/sldiag&gt;에 대해 지정된 차원이 유효하지 않습니다. 지정된 이득은 차원 {1}을(를) 갖습니다. 그러나 입력 신호와 이득의 행렬 곱을 생성하는 데 입력 차원이 적합하지 않습니다. 입력 신호의 첫 번째 차원이 이득의 마지막 차원과 일치해야 합니다</entry>
    <entry key="MatGainInvInDimsuKBasic">''{0}''의 &lt;sldiag objui="inport" objparam="1" objname="{0}"&gt;1번 입력 포트&lt;/sldiag&gt;에 대해 지정된 차원이 유효하지 않습니다. 지정된 이득은 차원 {1}을(를) 갖습니다. 그러나 입력 신호와 이득의 행렬 곱을 생성하는 데 입력 차원이 적합하지 않습니다. 입력 신호의 마지막 차원이 이득의 첫 번째 차원과 일치해야 합니다.</entry>
    <entry key="MatGainInvOutDimsKuBasic">''{0}''의 &lt;sldiag objui="outport" objparam="1" objname="{0}"&gt;1번 출력 포트&lt;/sldiag&gt;에 대해 지정된 차원이 유효하지 않습니다. 지정된 이득은 차원 {1}을(를) 갖습니다. 그러나 이득과 입력 신호의 행렬 곱을 생성하는 데 출력 차원이 적합하지 않습니다. 출력 신호의 첫 번째 차원이 이득의 첫 번째 차원과 일치해야 합니다. 그리고 출력 신호의 마지막 차원이 입력 신호의 마지막 차원과 일치해야 합니다.</entry>
    <entry key="MatGainInvOutDimsuKBasic">''{0}''의 &lt;sldiag objui="outport" objparam="1" objname="{0}"&gt;1번 출력 포트&lt;/sldiag&gt;에 대해 지정된 차원이 유효하지 않습니다. 지정된 이득은 차원 {1}을(를) 갖습니다. 그러나 입력 신호와 이득의 행렬 곱을 생성하는 데 출력 차원이 적합하지 않습니다. 출력 신호의 첫 번째 차원이 입력 신호의 첫 번째 차원과 일치해야 합니다. 그리고 출력 신호의 마지막 차원이 이득의 마지막 차원과 일치해야 합니다.</entry>
    <entry key="MatGainInvInDimsKu">''{0}''의 &lt;sldiag objui="inport" objparam="1" objname="{0}"&gt;1번 입력 포트&lt;/sldiag&gt;에 대해 지정된 차원이 유효하지 않습니다. 지정된 이득은 차원 {1}을(를) 갖는데, 차원 {2}을(를) 갖도록 입력을 설정하려 하고 있습니다. 이러한 차원은 이득과 입력 신호의 행렬 곱을 생성하는 데 적합하지 않습니다</entry>
    <entry key="MatGainInvInDimsuK">''{0}''의 &lt;sldiag objui="inport" objparam="1" objname="{0}"&gt;1번 입력 포트&lt;/sldiag&gt;에 대해 지정된 차원이 유효하지 않습니다. 입력 차원을 {1}(으)로 설정하려는데, 지정된 이득이 차원 {2}을(를) 갖습니다. 이러한 차원은 입력 신호와 이득의 행렬 곱을 생성하는 데 적합하지 않습니다</entry>
    <entry key="MatGainInvOutDimsKu">''{0}''의 &lt;sldiag objui="outport" objparam="1" objname="{0}"&gt;1번 출력 포트&lt;/sldiag&gt;에 대해 지정된 차원이 유효하지 않습니다. 출력 차원을 {1}(으)로 설정하려는데, 지정된 이득이 차원 {2}을(를) 갖습니다. 이러한 차원은 이득과 입력 신호의 행렬 곱을 생성하는 데 적합하지 않습니다</entry>
    <entry key="MatGainInvOutDimsuK">''{0}''의 &lt;sldiag objui="outport" objparam="1" objname="{0}"&gt;1번 출력 포트&lt;/sldiag&gt;에 대해 지정된 차원이 유효하지 않습니다. 출력 차원을 {1}(으)로 설정하려는데, 지정된 이득이 차원 {2}을(를) 갖습니다. 이러한 차원은 입력 신호와 이득의 행렬 곱을 생성하는 데 적합하지 않습니다</entry>
    <entry key="MatGainNoND">Invalid gain parameter specified for ''{0}''. When the block is in one of the matrix gain modes, the gain parameter must have at most two dimensions</entry>
    <entry key="MatMultBadDimsInp">행렬 곱셈 차원 전파 오류입니다. ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;를 차원 {2}을(를) 갖도록 설정하는 중에 오류가 발생했습니다. 이러한 차원이 다른 포트에 있는 부분 차원 정보와 일치하지 않는 것이 오류의 원인일 수 있습니다.</entry>
    <entry key="MatMultBadDimsOut">행렬 곱셈 차원 전파 오류입니다. ''{0}''의 출력 포트를 차원 {1}을(를) 갖도록 설정하는 중에 오류가 발생했습니다. 이러한 차원이 다른 포트에 있는 부분 차원 정보와 일치하지 않는 것이 오류의 원인일 수 있습니다.</entry>
    <entry key="MatMultDivOnlyDblAndSgl">The product block ''{0}'' is in matrix operations mode, but the block has data type combinations that are not supported in this mode. When matrix inverse is required, the input and output data types must all be double or must all be single.</entry>
    <entry key="MatMultInput2Dims">{2,number,integer}차원을 갖도록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;의 차원을 설정할 수 없습니다. 2차원 데이터만 지원됩니다.</entry>
    <entry key="MatMultOutput2Dims">{2,number,integer}차원을 갖도록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;의 차원을 설정할 수 없습니다. 2차원 데이터만 지원됩니다.</entry>
    <entry key="MatSelBadInDims1">''{0}''의 입력 포트 &lt;U&gt;에 설정하려는 차원이 유효하지 않습니다. 너비가 {1}이(가) 되도록 포트를 설정하는 중입니다. 하지만 이 너비는 파라미터와 포트 차원을 집계하여 얻은 차원 {2}에 맞지 않습니다</entry>
    <entry key="MatSelBadInDims2">''{0}''의 입력 포트 &lt;U&gt;에 설정하려는 차원이 유효하지 않습니다. 차원 {1}을(를) 갖도록 포트를 설정하는 중이지만, 파라미터와 포트 차원의 집계에 따라 차원이 {2}과(와) 일치해야 합니다.</entry>
    <entry key="MatSelBadOutDims1">''{0}''의 출력 포트 &lt;Y&gt;에 설정하려는 차원이 유효하지 않습니다. 너비가 {1}이(가) 되도록 포트를 설정하는 중입니다. 하지만 이 너비는 파라미터와 포트 차원을 집계하여 얻은 차원 {2}에 맞지 않습니다</entry>
    <entry key="MatSelBadOutDims2">Invalid dimensions being set to output port &lt;Y&gt; of ''{0}''. The port is being set to have the dimensions {1}, while an aggregation of parameters and port dimensions indicate that the dimensions should be consistent with {2}</entry>
    <entry key="MatSelInvDataInpDims">''{0}''은(는) 입력 포트 &lt;U&gt;에 행렬 입력값을 필요로 합니다. 입력 포트 &lt;U&gt;의 차원 수는 2보다 클 수 없습니다. 차원 수를 {1,number,integer}(으)로 설정하려고 합니다.</entry>
    <entry key="MatSelbadRowOrColDims">Invalid dimensions being set to input port &lt;Idx{0,number,integer}&gt; of ''{1}''. The port is being set to have the dimensions {2} even though this port can accept only vector signals</entry>
    <entry key="MatchingFromNotFound">"Goto" ''{0}''과(와) 짝을 이루는 "From"이 발견되지 않음</entry>
    <entry key="MatchingGotoNotFound">"From" ''{0}''과(와) 짝을 이루는 "Goto"가 발견되지 않음</entry>
    <entry key="MergeICInconsistency">''{1}'' 및 ''{2}''에 지정된 {0} 파라미터가 일치하지 않습니다. 소스 ''{4}''에 지정된 {3}이(가) 무시됩니다. 이 경고는 양쪽의 {5}을(를) 동일한 값으로 설정하거나 해당 소스의 {6}을(를) [](빈 행렬)로 설정하여 방지할 수 있습니다.</entry>
    <entry key="MergeInputCrossForEachSSBoundary">Input {0,number,integer} of Merge block ''{1}'' connects to Output {2,number,integer} of block ''{3}''. This connect crosses the boundary of subsystem ''{4}''. This is not supported because subsystem ''{5}'' contains a For Each block (''{6}'').</entry>
    <entry key="MinMaxInputWithDiffBias">''{0}'' has inputs with different biases. In this situation, automatically determining the data type and scaling of the output is not supported. Please, manually set the output''s data type and scaling.</entry>
    <entry key="MinMaxBooleanInputOutputType">블록 {0}의 한 입력 데이터형이나 출력 데이터형이 부울이면 모든 데이터형이 부울이어야 합니다.</entry>
    <entry key="ModuleNameExists">모듈 ''{0}''을(를) 등록할 수 없습니다. 이 모듈은 Simulink에 등록되어 있습니다.</entry>
    <entry key="MultipleGotoSrcNotAllowed0">Multiple signal sources found for Goto Tag Visibility ''{0}''</entry>
    <entry key="MultipleGotoSrcNotAllowed1">First source is From ''{0}''</entry>
    <entry key="MultipleGotoSrcNotAllowed2">Second source is From ''{0}''</entry>
    <entry key="MultipleGotoTagsFound0">이름이 ''{0}''인 태그를 갖는 Goto가 여러 개 발견됨</entry>
    <entry key="MultipleGotoTagsFound1">문제가 되는 첫 번째 Goto ''{0}''</entry>
    <entry key="MultipleGotoTagsFound2">문제가 되는 두 번째 Goto ''{0}''</entry>
    <entry key="MuxBlkUsedAsBus_ByBusSelector">블록 ''{1}''이(가) Mux 블록 ''{0}''의 출력을 버스 신호로 처리했습니다.</entry>
    <entry key="MuxBlkUsedAsBus_complexity">Mux 블록 ''{0}''이(가) 유형(실수/복소수)이 서로 다른 신호가 포함된 버스 신호를 출력했습니다.</entry>
    <entry key="MuxBlkUsedAsBus_datatype">Mux 블록 ''{0}''이(가) 데이터형이 서로 다른 신호가 포함된 비가상 버스 신호 또는 가상 버스 신호를 출력했습니다.</entry>
    <entry key="MuxBlkUsedAsBus_dimension">Mux 블록 ''{0}''이(가) 차원 수가 서로 다른 신호가 포함된 버스 신호를 출력했습니다.</entry>
    <entry key="MuxBlkUsedAsBus_frame">Mux 블록 ''{0}''이(가) 샘플링 모드(샘플 기반/프레임 기반)가 서로 다른 신호가 포함된 버스 신호를 출력했습니다.</entry>
    <entry key="MuxCannotJoinMatrices">Invalid setting for dimensions of input port of ''{0}''. It cannot be used to concatenate matrices</entry>
    <entry key="MuxDimsInfoMismatch1">''{0}''의 출력 포트 차원에 대한 설정이 유효하지 않습니다. {1,number,integer}개의 다중화된 신호에 대응되는 차원을 갖도록 포트를 설정하는 중입니다. 블록 대화 상자에 지정된 정보가 충분하지 않아, 입력에서의 신호가 이 다중화된 신호를 어떻게 생성하는지 확인할 수 없습니다. 셀형 배열 형식을 사용하여 입력 포트 차원을 지정해 보십시오.</entry>
    <entry key="MuxDimsInfoMismatch2">''{0}''의 출력 포트 차원에 대한 설정이 유효하지 않습니다. {1,number,integer}개의 다중화된 신호에 대응되는 차원을 갖도록 이 포트를 설정하는 중이지만, 입력 포트는 {2,number,integer}개의 다중화된 신호를 생성하도록 설정되어 있습니다.</entry>
    <entry key="MuxInValidPortWidths">''{0}''의 출력 포트 차원에 대한 설정이 유효하지 않습니다. 차원이 {1}(으)로 설정되고 있습니다. 입력 요소와 출력 요소의 총 개수가 같지 않기 때문에 이 설정은 유효하지 않습니다.</entry>
    <entry key="MuxInvalidDimsInStrictNonBusMode_Dims">Mux 블록 ''{1}''의 입력 포트에서 유효하지 않은 차원 {0}이(가) 발견되었습니다. 여러 개의 입력 신호가 있는 Mux 블록은 스칼라, 1차원 벡터, 행 벡터나 열 벡터(그러나 둘 다는 아님)만 허용합니다. 자세한 내용은 Mux 블록에 대한 문서를 참조하십시오.</entry>
    <entry key="MuxInvalidDimsInStrictNonBusMode_Prm">Mux 블록 ''{1}''의 파라미터 ''{0}''에 유효하지 않은 값이 지정되었습니다. 여러 개의 입력 신호가 있는 Mux 블록은 스칼라, 1차원 벡터, 행 벡터나 열 벡터(그러나 둘 다는 아님)만 허용합니다. 자세한 내용은 Mux 블록에 대한 문서를 참조하십시오.</entry>
    <entry key="MuxMayNotSpecifyPropertiesViaObject">''{1}''의 ''{0}'' 파라미터에 대한 설정이 유효하지 않습니다. 이 옵션은 Bus Creator 블록에만 선택할 수 있습니다.</entry>
    <entry key="MuxNonuniformDistribution">Nonuniform distribution of output to dynamically sized inputs in block ''{0}''</entry>
    <entry key="MuxOrDemuxBadCellParam">포트 정보 지정을 위해 ''{1}''의 파라미터 {0}에 사용된 셀형 배열이 유효하지 않습니다. 각 셀형 배열 요소는 0이 아닌 유한한 양의 정수로 구성된 벡터이거나 그러한 벡터 요소로만 구성된 셀형 배열이어야 합니다. 해당 포트의 차원을 알 수 없는 경우 셀 요소가 -1일 수 있습니다.</entry>
    <entry key="MuxOrDemuxBadNumPortsParam">''{1}''의 파라미터 {0}에 지정된 포트 개수가 올바르지 않습니다. 포트 개수는 유한한 양의 정수여야 합니다</entry>
    <entry key="MuxOrDemuxBadParam">Invalid entry specified for parameter {0} of ''{1}'' to specify port information. The entry must be a single number, a vector, or a cell array</entry>
    <entry key="MuxOrDemuxBadVectorParam">''{1}''의 파라미터 {0}에 사용된 벡터가 포트 정보를 지정하기에 유효하지 않습니다. 벡터에 양의 정수인 유한한 0이 아닌 요소가 있어야 합니다. 해당 포트의 차원을 알 수 없는 경우 요소가 -1일 수 있습니다.</entry>
    <entry key="MuxPortLargerThanInDims">''{0}''의 출력 포트 차원에 대한 설정이 유효하지 않습니다. 차원이 {1}(으)로 설정되고 있습니다. 출력 요소 개수가 입력 포트의 총 요소 개수({2,number,integer})보다 작기 때문에 이 설정은 유효하지 않습니다.</entry>
    <entry key="MuxSignalNameMismatch">신호 이름 ''{0}''이(가) ''{3}''의 ''{2,number,integer}''번 포트에 지정된 신호 이름 ''{1}''과(와) 일치하지 않음</entry>
    <entry key="BusCreatorSignalNameMismatch">Bus Creator block "{2}" renames input "{0}" to "{1}", which is not recommended. Set "Inputs" to an integer programmatically.</entry>
    <entry key="MuxBlkNamesPortsMismatch">Specified number of inputs ({0,number,integer}) must match the number of input ports ({2,number,integer}) on Mux block ''{1}''.</entry>
    <entry key="NamePlacementInconsistentState">NamePlacement 파라미터는 더 이상 사용되지 않습니다. 블록 이름 위치를 가져오려면 NameLocation 파라미터를 사용하십시오.</entry>
    <entry key="NegativeInputIterationDimension">The partition dimension of input {0,number,integer}, specified for the For Each block (''{1}'') in subsystem ''{2}'', must be a positive integer.</entry>
    <entry key="NegativeInputIterationStepSize">The partition width of input {0,number,integer}, specified for the For Each block (''{1}'') in subsystem ''{2}'', must be a positive integer.</entry>
    <entry key="NegativeInputIterationStepSizeWithOffset">The sum of the partition width and the partition offset of input {0,number,integer}, specified for the For Each block (''{1}'') in subsystem ''{2}'', must be a positive integer.</entry>
    <entry key="NegativeOutputConcatenationDimension">The concatenation dimension for output {0,number,integer}, specified for the For Each block (''{1}'') in subsystem ''{2}'', must be a positive integer.</entry>
    <entry key="No1DVarDimsForTranspose">''{0}'' can only process 2-D variable-size signals for Transpose and Hermitian.</entry>
    <entry key="NoInitOutForOutportReset">초기 출력이 지정되지 않았기 때문에 자신의 출력을 유지하도록 ''{0}''을(를) 구성해야 함</entry>
    <entry key="NoInputSignalOrMaskPrmForIteration">서브시스템 ''{0}''에 For Each 블록(''{1}'')이 포함되어 있으므로, For Each 블록 ''{2}''의 블록 대화 상자에서 하나 이상의 Inport 파라미터 또는 서브시스템 마스크 파라미터를 분할하도록 설정해야 합니다.</entry>
    <entry key="NoRootIteratorBlocks">For Iterator, While Iterator, Neighborhood, and For Each blocks are not allowed in the root window of a block diagram.</entry>
    <entry key="NoSrcForGotoTagVisBlk">No source goto for goto tag visibility ''{0}''</entry>
    <entry key="NonMonotonicEndPointsErr">런타임 데이터형으로의 변환 후에는 ''{1}''의 {0}에 대한 파라미터 값이 끝점에서 순단조여야 함</entry>
    <entry key="NonMonotonicErr">런타임 데이터형으로의 변환 전후에는 ''{1}''의 {0}에 대한 파라미터 값이 단조 증가해야 함</entry>
    <entry key="NonPositiveIntegerValueSeed">''{1}''의 파라미터 {0}은(는) 음수 값 또는 정수가 아닌 값을 지정합니다. 하지만 이 파라미터에는 0보다 크거나 같은 정수 값이 필요합니다. Simulink가 이 파라미터의 지정된 값을 데이터형 ''{2}''(으)로 변환했습니다.</entry>
    <entry key="NonPositiveWeightNotHandled">블록 ''{0}''의 가중치 파라미터에 대한 음수 값이 처리되지 않음</entry>
    <entry key="NonScalarICNotSupportVarDims">When the input signal of ''{0}'' is variable-size, only scalar is allowed for initial value</entry>
    <entry key="NonTunableParamRefPartitionedMaskParam">Parameter ''{0}'' of block ''{1}'' cannot reference partitioned mask parameter ''{2}'' of For Each subsystem ''{3}'' because parameter ''{4}'' is not tunable.</entry>
    <entry key="NonVirtualBusMustHaveObject">''{1}''의 ''{0}'' 파라미터에 대한 설정이 유효하지 않습니다. 이 옵션은 Bus 객체가 지정되어 있을 때만 선택할 수 있습니다.</entry>
    <entry key="NormModelRefBlkNotSupported">The parameter ''Simulation mode'' of the Model block ''{0}'' is set to ''Normal''. However, the Model block is inside subsystem ''{1}'', which contains a For Each block (''{2}''). Simulink currently does not support this scenario. Consider changing the parameter ''Simulation mode'' of ''{3}'' to ''Accelerator''.</entry>
    <entry key="NotAValidCellArrayOfStructs">The value being set in the IOSignals parameter for ''{0}'' is not of the proper form. The value must be a cell array of structs. Each struct must have {1,number,integer} fields with the names ''{2}'' and ''{3}'' and the types ''double'' and ''char array'', respectively.</entry>
    <entry key="OnlyExtrapFloat">블록 ''{0}''은(는) ''외삽 방법''을 ''{1}''(으)로 지정합니다. 이 방법은 모든 입력, 출력, 소수부, 중간값, 테이블, 절점의 데이터형이 동일한 부동소수점 유형인 경우에만 외삽할 수 있습니다. ''외삽 방법''을 '자르기'로 설정해 보십시오.</entry>
    <entry key="OnlyExtrapFloatAndHalf">블록 ''{0}''은(는) ''외삽 방법''을 ''{1}''(으)로 지정합니다. 이 방법은 모든 입력, 출력, 소수부, 중간값, 테이블, 절점의 데이터형이 동일한 부동소수점 유형인 경우나, 블록이 지원되는 반정밀도 및 단정밀도 이종 부동소수점 모드에 있는 경우에만 외삽할 수 있습니다. ''외삽 방법''을 '자르기'로 설정해 보십시오.</entry>
    <entry key="OutportBlockInconsistentDims">Port dimensions parameter of outport block ''{0}'' is inconsistent with the initial output parameter. If the initial output parameter of this block is non-scalar and not an empty matrix, then the dimensions of this parameter must exactly match the port dimensions parameter.</entry>
    <entry key="OutportConcatParamMismatch">The number of Outport blocks indicated by parameter ''{0}'' is {1,number,integer}. This value does not match the actual number of Outport blocks {2,number,integer} for subsystem ''{3}''.</entry>
    <entry key="OutportRequiresNVBusForAOB">Outport block ''{0}'' must have dimensions ''1'' to output a virtual bus in the parent model. Set dimensions to ''1'' or output a nonvirtual bus with dimensions ''{1}''. If you are upgrading a model from a previous version of Simulink, use the &lt;a href="matlab:sl(''upgradeadvisor'', ''{2}'')"&gt;Upgrade Advisor&lt;/a&gt;.</entry>
    <entry key="OutputPortComplexityErr">Error in ''SetInputPortComplexity'' method of ''{0}''. The signal complexity of output port {1,number,integer} should have been set to ''{2}'', but was instead set to ''{3}''.</entry>
    <entry key="OutputPortDatatypeErr">Error in ''SetOutputPortDatatype'' method of ''{0}''. The data type ID of output port {1,number,integer} should have been set to {2,number,integer}, but was instead set to {3,number,integer}.</entry>
    <entry key="OutputPortDimsErr1To1">Error in ''SetOutputPortDimensions'' method of ''{0}''. The dimensions of output port {1,number,integer} should have been set to [{2,number,integer}], but was instead set to [{3,number,integer}].</entry>
    <entry key="OutputPortDimsErr1To2">''{0}''의 ''SetOutputPortDimensions'' 메서드에 오류가 있습니다. {1,number,integer}번 출력 포트의 차원이 [{2,number,integer}](으)로 설정되었어야 했는데, 대신 [{3,number,integer}x{4,number,integer}](으)로 설정되었습니다.</entry>
    <entry key="OutputPortDimsErr2To1">''{0}''의 ''SetOutputPortDimensions'' 메서드에 오류가 있습니다. {1,number,integer}번 출력 포트의 차원이 [{2,number,integer}x{3,number,integer}](으)로 설정되었어야 했는데, 대신 [{4,number,integer}](으)로 설정되었습니다.</entry>
    <entry key="OutputPortDimsErr2To2">''{0}''의 ''SetOutputPortDimensions'' 메서드에 오류가 있습니다. {1,number,integer}번 출력 포트의 차원이 [{2,number,integer}x{3,number,integer}](으)로 설정되었어야 했는데, 대신 [{4,number,integer}x{5,number,integer}](으)로 설정되었습니다.</entry>
    <entry key="PadeApproximateDelay">''{0}''이(가) 파데 차수가 0인 상태에서 단위 이득으로 선형화됨</entry>
    <entry key="ParameterValueMustBeKnown">Block ''{0}'' does not specify a value for parameter ''{1}''.</entry>
    <entry key="PartitionedMaskParamReferencedInMaskInit">The mask variable ''{0}'' of ''{1}'' cannot be used in mask initialization or icon drawing commands because the mask parameter ''{2}'' is referencing a partitioned mask parameter on a parent For Each subsystem.</entry>
    <entry key="PartitionedMaskParamReferencedInMaskInit2">Partitioned mask parameter ''{0}'' of For Each subsystem ''{1}'' cannot be referenced in mask initialization or icon drawing commands.</entry>
    <entry key="EvalFunctionsUsedInMaskInit">함수 ''{0}''은(는) ''{1}''의 아이콘 그리기 명령 또는 마스크 초기화에 사용할 수 없습니다. 이 함수가 하나 이상의 분할된 마스크 파라미터를 가진 For Each Subsystem이거나 이러한 Subsystem 내에 있기 때문입니다.</entry>
    <entry key="PermuteDimsInvPermVectLen">블록 ''{0}''에 대해 지정된 치환 벡터가 유효하지 않습니다. 치환 벡터 내 요소 개수는 입력 신호의 차원 수 및 출력 신호의 차원 수보다 크거나 같아야 합니다</entry>
    <entry key="PermuteDimsInvPermVector">Invalid permutation vector specified for block ''{0}''. The elements of the permutation vector must be a rearrangement of the values 1 to N</entry>
    <entry key="PortDataTypesMustBeNumeric">블록 ''{0}''은(는) 숫자 데이터형만 지원합니다. 부울형은 지원하지 않습니다.</entry>
    <entry key="PortIndexBaseInconsistent">Mismatch found between indexing mode settings of &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' ({2,number,integer}-based) and &lt;sldiag objui="outport" objparam="{3,number,integer}" objname="{4}"&gt;output port {3,number,integer}&lt;/sldiag&gt; of ''{4}'' ({5,number,integer}-based)</entry>
    <entry key="PortPairDimsMismatch">블록 ''{0}''의 해당 인덱스 포트와 소수 포트인 k{1,number,integer} 및 f{2,number,integer}의 차원이 호환되지 않습니다.</entry>
    <entry key="PowResultUndefined">''{0}''에 거듭제곱 결과가 정의되어 있지 않습니다.</entry>
    <entry key="DeprecatedLookupBlock">The Lookup Table and Lookup Table (2-D) block will be removed in a future release. Replace ''{0}'' with the 1-D Lookup Table or 2-D Lookup Table block.</entry>
    <entry key="PrelookupEnumTypeHasNonZeroStoredValueAsDefault">In block ''{0}'', when the Source of ''{1}'' is 'Input port', the enumeration class default must be 0. For enumeration class ''{2}'', default value of enumeration member ''{3}'' must be 0.</entry>
    <entry key="InputBreakpointsDatatypeMismatch">In block ''{0}'', the data type of parameter ''{1}'' is ''{2}'' and the data type of input is ''{3}''. When using enumerated data, the data type of the input and breakpoints must be the same enumerated data type.</entry>
    <entry key="DuplicateEnumDefinitionsNotAllowed">''{0}'' in block ''{1}'' expects each member of enumerated data class ''{2}'' to have a unique underlying integer.</entry>
    <entry key="DuplicateEnumBreakpointElementsNotAllowed">''{0}'' in block ''{1}'' expects each member of enumerated data class ''{2}'' to be a unique enumerated value. A duplicate appears at element {3,number,integer}.</entry>
    <entry key="BreakpointsMustContainEveryDefinedEnumElement">Block ''{0}'' expects every member of enumerated data class ''{1}'' to appear as a value of ''{2}''. Partial sets are not allowed. Use enumeration(''{1}'') to include every member.</entry>
    <entry key="BreakpointsMustContainOneOccurrenceOfDefinedEnumElement">''{0}'' in block ''{1}'' expects one occurrence of each member of enumerated data class ''{2}''.</entry>
    <entry key="InheritedBreakpointsEnumDataTypeMismatch">블록 ''{0}''에서 ''{1}''의 데이터형은 '기본' 탭에서 ''{2}''이고, ''{1}''의 상속된 데이터형은 '데이터형' 탭에서 ''{3}''입니다. 열거형 데이터를 사용할 경우 두 데이터형이 모두 동일해야 합니다.</entry>
    <entry key="LookupNDEnumDoesNotSupportTunableTableSize">In block ''{0}'', the data type of ''{1}'' is ''{2}''. The ''Support tunable table size in code generation'' parameter is not supported for enumerated data types.</entry>
    <entry key="EnumDoesNotSupportSymbolicDimensions">블록 ''{0}''에서 ''{1}''의 데이터형은 ''{2}''입니다. 열거 데이터형에는 ''기호 차원 지정 허용'' 파라미터가 지원되지 않습니다.</entry>
    <entry key="PreLookupEvenSpacingMsg">Breakpoint data of block ''{0}'' must be evenly spaced to the last precision bit before and after conversion to its run-time data type; either change data to even spacing or select another search method. See help for tips on creating evenly spaced data</entry>
    <entry key="LookupEvenSpacingMsg">런타임 데이터형으로의 변환 전후에는 블록 ''{1}''에서 차원 {0,number,integer}의 절점 데이터가 마지막 정밀도 비트까지 간격이 균일해야 합니다. 데이터를 균일 간격으로 변경하거나 다른 탐색 방법을 선택하십시오. 데이터를 균일한 간격으로 만드는 팁은 도움말을 참조하십시오</entry>
    <entry key="PreLookupEnumNonMonotonicErrRuntimeParam">Values of ''{0}'' in ''{1}'' must be strictly monotonically increasing. For enumerated breakpoints data, if the ''Index search method'' is 'Linear' and the ''Begin index search using previous index result'' check box is selected, the breakpoints data must be strictly monotonically increasing. The values are not strictly monotonically increasing at element {2,number,integer}. Change the breakpoints data or clear the "Begin index search using previous index result" check box.</entry>
    <entry key="PriorityErr">Invalid Priority setting ''{0}'' for block ''{1}''. The value must be either an empty character vector ('''') or an integer character vector literal (e.g. ''3'')</entry>
    <entry key="ProbeInvDims1">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 대해 지정된 출력 차원이 유효하지 않습니다. 출력 신호가 2차원 이상을 갖도록 잘못 지정되었습니다.</entry>
    <entry key="ProbeInvDims2">Probe 블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 대해 지정된 출력 차원이 유효하지 않습니다. 이 출력 포트의 너비는 Probe 블록의 입력에 연결된 {3,number,integer}차원 신호에 맞도록 {2,number,integer}(으)로 설정되어야 합니다. 하지만 출력 포트는 이미 너비 ''{4,number,integer}''을(를) 갖도록 설정되어 있습니다.</entry>
    <entry key="ProbeOutPortSameAsInput">''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;가 입력과 동일한 데이터형을 갖도록 설정되어 있습니다.</entry>
    <entry key="ProductComplexDivCodeGenOnlyForCollapseAll">블록 ''{0}''은(는) 복소 신호에 지정된 차원에 대한 차원 축소 나누기를 위해 코드를 생성할 수 없음</entry>
    <entry key="ProductInvComplexDivPort">For fixed-point or heterogeneous built-in data types, ''{0}'' does not support complex values at divide input ports</entry>
    <entry key="ProductInvOutputDataType">Inherited output data type of ''{0}'' contains more bits than is supported</entry>
    <entry key="ProductViolateInheritanceRule">''{0}''에 대한 데이터형 전파로 인해 상속 규칙 위반이 발생했습니다. 이 오류를 제거하는 방법 중 하나는 데이터형과 스케일링을 수동으로 설정하는 것입니다</entry>
    <entry key="PulseGenComputedTsFixedStepMismatchErr">''{0}''에서 오류가 발생함: 계산된 샘플 시간({1})이 고정 스텝 크기({2})의 정수 배수가 아닙니다. 이 블록의 주기, 펄스 폭 및 위상 지연 파라미터는 고정 스텝 크기의 정수 배수여야 합니다</entry>
    <entry key="PulseGenDelayTsMismatchErr">Error in ''{0}'': The phase delay ({1}) parameter must be an integer multiple of the sample time ({2})</entry>
    <entry key="PulseGenRunTimeTsMismatchErr">''{0}''에서 오류 발생: 주기({1})와 펄스 폭({2})은 샘플 시간({3})의 정수 배수여야 합니다</entry>
    <entry key="PulseGenSampModeNonDClock">Source of the Pulse Generator ''{0}'' must be Digital Clock when the Pulse Generator is operating in Sample based mode</entry>
    <entry key="ToFileNameIsModelName">Data logging file name, ''{0}'' specified in ''{1}'' is the same as the model name ''{2}''. Code generation and rapid accelerator do not support data logging names that are the same as the model name.</entry>
    <entry key="RTWSfcnTargetNotSupported">Model ''{0}'' cannot generate code for the S-function target because the model has one or more subsystems which contain a For Each block</entry>
    <entry key="TrigATAN2NotSupportComplexIN">In block ''{0}'', the function ''atan2'' does not support complex inputs</entry>
    <entry key="RaiseToNegative">''{0}''에서 음수 값을 정수가 아닌 값으로 거듭제곱하려고 합니다.</entry>
    <entry key="RateLimConstantSampleTime">Input signals to Rate Limiter block ''{0}'' are neither discrete nor continuous sample time signals. Only discrete or continuous input signals are supported.</entry>
    <entry key="RateLimFixptContinuousTime">Input signals to Rate Limiter block ''{0}'' are continuous time signals or have zero sample time. These conditions are not allowed when input data types are Integer or Fixed-point data types.</entry>
    <entry key="RateLimInconsistentDataTypes">Rate Limiter 블록 ''{0}''에서 ''상승 슬루 레이트'' 및 ''하강 슬루 레이트'' 파라미터는 데이터형이 같아야 합니다.</entry>
    <entry key="RateLimUnsignedFixPtNotSupported">Rate Limiter 블록 ''{0}''에서 ''상승 슬루 레이트'' 및 ''하강 슬루 레이트'' 파라미터의 데이터형은 부호 없는 고정소수점일 수 없습니다.</entry>
    <entry key="RateLimFixptInTriggeredSubsystem">Rate Limiter 블록 ''{0}''이(가) 이산 샘플 시간 모드에서 작동하고 있습니다. 이는 Rate Limiter가 Triggered Subsystem 내에 있는 경우 허용되지 않습니다. 이 문제를 해결하려면 Rate Limiter 블록을 Triggered Subsystem 밖으로 옮기십시오.</entry>
    <entry key="RateTransMultipleIptsOpts">''{0}''과(와) ''{1}'' 간에 부적절한 레이트 변경이 발견되었습니다. ''{3}''의 샘플 시간 {2}과(와) ''{5}''의 샘플 시간 {4}은(는) 정수 배수여야 하지만, 현재 그렇지 않습니다. 파라미터 ''결정적 데이터 전송 보장''을 선택 해제한 상태로 Rate Transition 블록을 사용하여 이 문제를 해결할 수 있습니다.</entry>
    <entry key="InvalidPrmSampleTimeCauseCodeGenMismatch"> Sample time propagated to block ''{0}'' causes mismatch between simulation and generated executable program results. Insert a Unit Delay block at block ''{0}''output port {1,number,integer} and set the sample time  of that Unit Delay block to {2}. </entry>
    <entry key="ReadOnlyMaskParamRefPartitionedMaskParam">Mask parameter ''{0}'' of subsystem ''{1}'' cannot reference a partitioned mask parameter of a For Each subsystem because parameter ''{2}'' is not set to be tunable.</entry>
    <entry key="RealizationNotSupported">''{0}''의 ''구현'' 파라미터는 더 이상 사용되지 않습니다. 이 파라미터에 set_param 함수와 get_param 함수를 사용할 수 없습니다. 이 블록에 대해 생성된 코드는 이전 ''일반'' 구현에서처럼 조정 가능성을 그대로 가지면서, 이전 ''희소'' 구현과 유사한 성격을 갖도록 개선되었습니다.</entry>
    <entry key="RefBlockNoLongerLinked">''{0}''은(는) 더 이상 ''{1}''에 연결되지 않습니다.</entry>
    <entry key="RefBlockUnknownParameter">In instantiating linked block ''{0}'' : {1}</entry>
    <entry key="RefIsNotLibrary1">참조 ''{0}''이(가) 모델에 있는 ''{1}''에 연결되어 있습니다. 참조는 라이브러리의 내용에만 연결되어야 합니다. 이 문제를 해결하려면 (a) ''{2}''에 대한 연결을 끊거나 (b) ''{3}''을(를) 라이브러리로 옮기십시오.</entry>
    <entry key="RelayContinuousFrame">''{0}''이(가) 프레임 기반 모드에서 작동하므로 이에 대해 연속시간 입력 신호가 허용되지 않습니다</entry>
    <entry key="RelopComplexNotSupported">''{0}''의 복소수 입력에는 관계 연산( &gt;, &lt;, &lt;=, &gt;= )이 지원되지 않음</entry>
    <entry key="OutputPortSingleHalfNotSupported">single 데이터형과 half 데이터형은 블록 ''{0}''의 출력 포트에서 지원되지 않습니다.</entry>
    <entry key="ResetIntegratorDeprecated">더 이상 ResetIntegrator 블록 ''{0}''이(가) 지원되지 않습니다. 이 블록을 '레벨' 재설정과 '외부' 초기 조건으로 구성된 Integrator로 바꾸십시오. 출력을 대체 Integrator의 재설정 또는 초기 조건 입력 포트로 다시 전달할 때 대수 루프가 발생하는 경우, 일반 출력 포트가 아닌 Integrator의 상태 출력 포트를 사용해야 합니다.</entry>
    <entry key="RequireHomogeneousPortDataTypes">''{0}''의 포트 데이터형은 동일해야 합니다. 즉, 데이터형이 모두 double형이거나 모두 single형이거나 모두 고정소수점이어야 합니다. 이렇게 만드는 방법 중에는 출력 데이터형에 상속된 모드를 선택하는 방법이 있습니다.</entry>
    <entry key="UnderspecifiedFixedPointPortDataTypes">Fixed-point data types are under-specified in ''{0}''. You need to provide fixed-point data type specifications for the input ports</entry>
    <entry key="UnderspecifiedComplexPortDataTypes">Complex data types are incorrectly specified or under-specified in ''{0}''.</entry>
    <entry key="RequireRealInitialConditions">''{0}''에서 초기 조건은 실수여야 함</entry>
    <entry key="ResetPortExists">A reset port already exists in subsystem ''{0}''. Addition of a second reset port is not allowed.</entry>
    <entry key="ResetintObsoleteBlock">다음 위치에서 더 이상 사용되지 않는 레벨 기반 Reset Integrator가 발견되었습니다.\n \n ''{0}''.\n\n 출력 포트가 (직접 피드스루 경로를 통해) 재설정 포트로 다시 전달될 경우 일관성 검사 진단을 활성화하면 일관성 오류가 발생할 수 있습니다. Simulink 라이브러리에서 ''레벨'' 재설정과 ''외부'' IC 포트가 선택된 상태로 구성된 Integrator를 사용하여 이 문제를 방지할 수 있습니다. 출력을 재설정 입력으로 다시 전달할 때 대수 루프가 발생하는 경우, 일반 출력 포트가 아닌 상태 출력 포트를 사용해야 합니다. </entry>
    <entry key="RowMismatch">''{1}''에 대한 {0}의 요소 개수는 출력 테이블의 행 개수와 일치해야 함</entry>
    <entry key="RunTimeModelAPINotSupported">Error executing the model API call because the block ''{0}'' is configured to disallow model API calls for the ''{1}'' method</entry>
    <entry key="slgetcompilerinfIsUNIXorMAC"> 'slgetcompilerinfo is not supported on this platform'</entry>
    <entry key="SFunctionBuilderInvalidParameterSettings"> 오류: S-Function 파라미터에 대한 설정이 유효하지 않음: ''{0}''</entry>
    <entry key="SFunctionBuilderInvalidPortName">\n 오류: 유효하지 않은 ''{0}'' 포트 이름임: ''{1}''</entry>
    <entry key="SFunctionBuilderInvalidPortName1">\n 오류: ''{0}'' 포트에 대해 지정된 이름이 유효하지 않음: {1}</entry>
    <entry key="SFunctionBuilderInvalidParamName">오류: 유효하지 않은 ''{0}'' 포트 이름임: ''{1}''</entry>
    <entry key="SFunctionBuilderInvalidSampleTime">\n\n 오류: 유효하지 않은 샘플 시간 값입니다. 샘플 시간 값은 비어 있을 수 없습니다.</entry>
    <entry key="SFunctionBuilderInvalidInput">유효하지 않은 입력값임</entry>
    <entry key="SFunctionBuilderInvalidSlope">Invalid Slope</entry>
    <entry key="SFunctionBuilderCannotOpenFile">파일 ''{0}''을(를) 열 수 없음</entry>
    <entry key="SFunctionBuilderCreation">### S-Function ''{0}''이(가) 성공적으로 생성됨</entry>
    <entry key="SFunctionBuilderCreationWSL">### WSL에서 S-Function ''{0}''이(가) 성공적으로 생성됨</entry>
    <entry key="SFunctionBuilderCreationWithHyperlinks">### &lt;a href="matlab:edit(''{0}'')"&gt;''{1}''&lt;/a&gt;이(가) 성공적으로 생성됨</entry>
    <entry key="SFunctionBuilderInvalidBuilderVersion">다음 위치의 S-Function Builder 버전이 유효하지 않음: ''{0}''. 디폴트 파라미터가 사용됩니다.</entry>
    <entry key="SFunctionBuilderOverwritingTLC">TLC 파일을 덮어씀: ''{0}''</entry>
    <entry key="SFunctionBuilderUnsavedChanges">S-Function Builder에 저장되지 않은 변경 사항이 있습니다.\n그러한 변경 사항을 폐기하거나 S-Function에 저장할 수 있습니다.</entry>
    <entry key="SFunctionBuilderCompileMsg">\n\n''{0}''을(를) 컴파일하는 중입니다. 기다려 주십시오.</entry>
    <entry key="SFunctionBuilderPackageMsg">\n\n''{0}'' 패키지를 생성하는 중.... 기다려 주십시오</entry>
    <entry key="SFunctionBuilderPackageSuccess">\n\n''{0}'' 패키지를 생성했습니다.</entry>
    <entry key="SFunctionBuilderPackageError">\n\n''{0}'' 패키지를 생성하지 못했습니다.</entry>
    <entry key="SFunctionBuilderGenerateMsg">\n\n''{0}''을(를) 생성하는 중입니다. 기다려 주십시오.</entry>
    <entry key="SFunctionBuilderOverwritingFile">파일 ''{0}''을(를) 덮어씀</entry>
    <entry key="SFunctionBuilderReferenceConfigSetWarning">\n\n경고: 참조 구성으로 코드를 생성할 때 define과 undefine을 설정할 수 없습니다. 모델을 빌드할 때 define와 undefine을 설정하려면 구성에서 RTWMakeCommand를 ''{0}''(으)로 설정하십시오.</entry>
    <entry key="SFunctionBuilderInvalidName">오류: S-Function 이름이 유효한 MATLAB 함수 이름이 아니기 때문에 S-Function 파일을 ''{0}''(으)로 만들 수 없습니다.</entry>
    <entry key="SFunctionBuilderBlockError">S-Function Builder 블록 ''{0}''에 오류가 발생했습니다.</entry>
    <entry key="SFunctionBuilderPathIsUNC">지정된 경로 ''{0}''은(는) 네트워크 드라이브 위치 아래에 있습니다. WSL에서 Linux 이진 생성이 완벽히 지원되도록 하려면 이 네트워크 드라이브를 새 문자 드라이브(예: K:)에 매핑하십시오.</entry>
    <entry key="SFunctionBuilderCannotMountNetworkDrive">지정된 경로 ''{0}''은(는) 네트워크 드라이브 위치 아래에 있으므로 WSL에서 마운트할 수 없습니다. WSL에서 Linux 이진 생성이 완벽히 지원되도록 하려면 제공된 Linux 배포판을 사용하거나 기존 WSL 환경의 네트워크 드라이브를 수동으로 마운트하십시오.</entry>
    <entry key="SFunctionBuilderWSLMatlabRootUnknown">S-Function ''{0}''에 대한 mex를 생성하는 데 필요한, MATLAB의 WSL 설치 경로가 제공되지 않았습니다. 함수 Simulink.setWSLSettings('WSLMatlabRoot', wslMatlabRoot)를 사용하여 Linux 또는 Windows 경로를 제공하십시오. </entry>
    <entry key="SFcnDidnotSetPortComplexSignal">S-Function은 ''{2}''의 {0} {1,number,integer}번 포트의 복소 신호를 메서드 {3}의 입력 인수로 지정된 값으로 설정해야 합니다.</entry>
    <entry key="SFcnDidnotSetPortDataType">S-Function은 ''{2}''의 {0} {1,number,integer}번 포트의 데이터형을 메서드 {3}의 입력 인수로 지정된 데이터형으로 설정해야 합니다.</entry>
    <entry key="SFcnDidnotSetPortDimensions">S-Function은 ''{2}''의 {0} {1,number,integer}번 포트의 차원을 메서드 {3}의 입력 인수로 지정된 값으로 설정해야 합니다.</entry>
    <entry key="SFcnDidnotSetPortWidth">S-Function은 ''{2}''의 {0} {1,number,integer}번 포트의 너비를 메서드 {3}의 입력 인수로 지정된 값으로 설정해야 합니다.</entry>
    <entry key="SFcnDisallowsSimState">{0} S-Function({1}) 블록 ''{2}''이(가) 해당 시뮬레이션 상태에 대한 액세스를 허용하지 않기 때문에 시뮬레이션 상태에 액세스할 수 없습니다.</entry>
    <entry key="SSProxyInvalid">프록시 핸들은 유효한 서브시스템이어야 함</entry>
    <entry key="SampleTimeOffsetMustZero">Determinism of data transfer between ''{0}'' and ''{1}'' cannot be ensured because either or both blocks have non-zero sample time offset. You can resolve this by using a rate transition block whose parameter ''Ensure deterministic data transfer'' is unchecked</entry>
    <entry key="SampleTimePropagationNotCompleted">The parameter ''{0}'' for block ''{1}'' cannot be obtained until after sample time propagation is completed</entry>
    <entry key="SaveAsMsg">다른 이름으로 저장...</entry>
    <entry key="ScopeSignalHasMixedType">혼합된 데이터형을 갖고 있기 때문에 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;를 볼 수 없습니다. 이 포트는 ''{2}''에서 제거되었습니다. 표시할 신호를 ''{3}''의 신호 선택기를 사용하여 다시 선택하십시오. </entry>
    <entry key="ScopeSignalHasMixedUnit">혼성 신호 단위를 갖고 있기 때문에 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;를 볼 수 없습니다. 이 포트는 ''{2}''에서 제거되었습니다. 표시할 신호를 ''{3}''의 신호 선택기를 사용하여 다시 선택하십시오. </entry>
    <entry key="ScopedTagCrossFcnMask">Goto Tag Visibility ''{0}''의 신호 소스가 함수 마스크를 가로지름</entry>
    <entry key="DSRWInvalidDataStoreElementsForIndexing1">블록 ''{2}''의 파라미터 ''{1}''에 대한 설정 ''{0}''이(가) 유효하지 않습니다. 이 블록의 파라미터 ''{3}''이(가) ''켜기''로 설정된 경우 한 개의 요소만 지정할 수 있습니다.</entry>
    <entry key="DSRWInvalidDataStoreElementsForIndexing2">블록 ''{2}''의 파라미터 ''{1}''에 대한 설정 ''{0}''이(가) 유효하지 않습니다. 이 블록의 파라미터 ''{3}''이(가) ''켜기''로 설정된 경우 파라미터 ''{1}''에 리터럴 인덱싱 표현식이 포함될 수 없습니다.</entry>
    <entry key="DSMDataInputDimMismatch">''{0}''의 데이터 입력 포트의 신호 차원(또는 이에 상응하는 요소)이 {1}입니다. 입력 신호의 차원 {2,number,integer}의 너비({3,number,integer})가 이 차원의 인덱싱 너비({4,number,integer})와 일치하지 않습니다.</entry>
    <entry key="DSMDataOutputDimMismatch">''{0}''의 데이터 출력 포트의 신호 차원(또는 이에 상응하는 요소)이 {1}입니다. 출력 신호의 차원 {2,number,integer}의 너비({3,number,integer})가 이 차원의 인덱싱 너비({4,number,integer})와 일치하지 않습니다.</entry>
    <entry key="DSMDataInputVectorDimMismatch">''{0}''의 데이터 입력 포트의 벡터 크기({1,number,integer})가 이 블록의 1차원 인덱싱 크기({2,number,integer})와 일치하지 않습니다.</entry>
    <entry key="DSMDataOutputVectorDimMismatch">''{0}''의 데이터 출력 포트의 벡터 크기({1,number,integer})가 이 블록의 1차원 인덱싱 크기({2,number,integer})와 일치하지 않습니다.</entry>
    <entry key="DSMDataInputNumDimsMismatch">''{0}''의 데이터 입력 포트의 차원 수({1,number,integer})가 Data Store Memory ''{2}''의 차원 수({3,number,integer})보다 큽니다.</entry>
    <entry key="DSMDataOutputNumDimsMismatch">''{0}''의 데이터 출력 포트의 차원 수({1,number,integer})가 Data Store Memory ''{2}''의 차원 수({3,number,integer})보다 큽니다.</entry>
    <entry key="DSMIndexHasSingleElement">데이터 저장소 요소 ''{0}''에는 요소가 하나만 있기 때문에 인덱싱이 지원되지 않습니다.</entry>
    <entry key="DSMIndexNumDimsMismatch">''{0}''의 인덱싱 옵션에 지정된 차원 수({1,number,integer})가 Data Store Memory ''{2}''의 차원 수({3,number,integer})와 일치하지 않습니다.</entry>
    <entry key="DSMIndexVectorPortOutOfBound">Element {0,number,integer} of input port &lt;Idx{1,number,integer}&gt; in ''{2}'' has a value of {3,number,integer}. This value is not within the range of permissible values ({4,number,integer} through {5,number,integer}) that allows selection of a valid element of Data Store Memory ''{6}''.</entry>
    <entry key="DSMIndexVectorDialogOutOfBound">''{2}''에서 차원 {1,number,integer}의 인덱스 벡터(대화 상자)의 {0,number,integer}번째 요소 값이 {3,number,integer}입니다. 이 값은 Data Store Memory ''{6}''의 유효한 요소를 선택하기 위해 허용되는 값 범위({4,number,integer}~{5,number,integer}) 내에 속하지 않습니다.</entry>
    <entry key="DSMStartIndexPortOutOfBound1">Starting index at input port &lt;Idx{0,number,integer}&gt; for dimension {1,number,integer} of ''{2}'' has a value of {3,number,integer}. This value is not within the range of permissible values ({4,number,integer} through {5,number,integer}) that allows selection of a valid element of Data Store Memory ''{6}''.</entry>
    <entry key="DSMStartIndexPortOutOfBound2">The ending index for dimension {0,number,integer} in ''{1}'' is invalid because it references a nonexistent element of the Data Store Memory ''{2}''. To fix this error, reduce the value of either or both of the following: the starting index at the input port &lt;Idx{3,number,integer}&gt; and the output size for dimension {4,number,integer}, such that the ending index is within the range {5,number,integer} through {6,number,integer}</entry>
    <entry key="DSMStartIndexDialogOutOfBound1">''{1}''에서 차원 {0,number,integer}의 시작 인덱스(대화 상자)의 값이 {2,number,integer}입니다. 이 값은 Data Store Memory ''{5}''의 유효한 요소를 선택하기 위해 허용되는 값 범위({3,number,integer}~{4,number,integer}) 내에 속하지 않습니다.</entry>
    <entry key="DSMStartIndexDialogOutOfBound2">''{0}''의 차원은 차원 {1,number,integer}의 너비가 {2,number,integer}임을 나타냅니다. 그러나, ''{3}''의 시작 인덱스(대화 상자)와 출력 크기(대화 상자)는 이 차원의 너비가 적어도 {4,number,integer}임을 나타냅니다.</entry>
    <entry key="DSMStartIndexDialogOutOfBound3">''{0}''의 차원은 차원 {1,number,integer}의 너비가 {2,number,integer}임을 나타냅니다. 그러나, ''{3}''의 데이터 입력 포트의 시작 인덱스(대화 상자)와 차원 너비에 따르면 이 차원의 너비가 적어도 {4,number,integer}임을 나타냅니다.</entry>
    <entry key="DSMStartIndexWidthOutOfBound1">''{0}''의 차원은 차원 {1,number,integer}의 너비가 {2,number,integer}임을 나타냅니다. 블록 ''{3}''은(는) 이 차원에 시작 인덱스 옵션을 사용하고 있지만 출력 크기(대화 상자)가 {4,number,integer}이며 이 값은 Data Store Memory의 해당 차원의 너비보다 큽니다.</entry>
    <entry key="DSMStartIndexWidthOutOfBound2">''{0}''의 차원은 차원 {1,number,integer}의 너비가 {2,number,integer}임을 나타냅니다. 블록 ''{3}''은(는) 이 차원에 시작 인덱스 옵션을 사용하고 있지만 해당 데이터 입력 포트에서 이 차원의 너비는 {4,number,integer}이며 이 값은 Data Store Memory의 해당 차원의 너비보다 큽니다.</entry>
    <entry key="DSMIndexPortDataTypeNotSupported">블록 ''{1}''의 인덱스 포트 &lt;Idx{0,number,integer}&gt;에 지원되지 않는 데이터형입니다. int8, uint8, int16, uint16, int32 정수 데이터형만 지원됩니다.</entry>
    <entry key="DSMDataStoreElementNotSelected">트리에서 데이터 저장소 요소를 선택하십시오.</entry>
    <entry key="SelDimPropParamEvalError">''{2}''의 차원 {0,number,integer}, 파라미터 ''{1}''에 대한 설정이 올바르지 않습니다.</entry>
    <entry key="SelEmptyIndexOrOutputSizeParam">''{1}''의 차원 {0,number,integer}에 대해 파라미터 ''인덱스'' 또는 ''출력 크기''가 설정되지 않았습니다.</entry>
    <entry key="SelEsCellArray">''{1}''에 지정된 파라미터 ''{0}''이(가) 차원 {2,number,integer}에 유효하지 않습니다. 실수형 정수로 구성된 벡터이거나 실수형 정수여야 합니다.</entry>
    <entry key="SelEsMismatch">Parameter ''{0}'' specified in ''{1}'' provides index elements for {2,number,integer} dimensions. It does not match the number of input dimensions, {3,number,integer}</entry>
    <entry key="SelIdxOptMismatch">''{1}''에 지정된 파라미터 ''{0}''은(는) {2,number,integer}개 차원에 대한 인덱스 옵션을 제공합니다. 이는 입력 차원 수 {3,number,integer}과(와) 일치하지 않습니다</entry>
    <entry key="SelIdxOverflow">''{0}''의 입력 포트 &lt;U&gt;에 대해 지정된 차원이 유효하지 않습니다. 파라미터 ''{3}''은(는) 입력의 차원 {4,number,integer}의 너비가 최소 {5}임을 나타내는데 차원은 입력의 차원 {1,number,integer}의 너비가 {2}임을 나타냅니다</entry>
    <entry key="SelIntegerOutOfBounds">''{2}''의 &lt;Idx{1,number,integer}&gt;번 입력 포트의 {0,number,integer}번째 요소 값이 {3,number,integer}입니다. 이 값은 유효한 입력 데이터 요소 선택을 허용하는 허용 가능한 값 범위({4,number,integer}~{5,number,integer}) 내에 없습니다</entry>
    <entry key="SelInvDataInpDims">입력 포트 &lt;U&gt;의 차원 수가 ''{0}''에 지정된 입력 차원 수와 일치하지 않습니다.</entry>
    <entry key="SelInvDataInpSize">''{0}''의 입력 포트 &lt;U&gt;에 대한 차원 설정이 차원 {1,number,integer}에 대해 유효하지 않습니다. 값 {2,number,integer}은(는) 이 차원에 대한 출력 포트 &lt;Y&gt;의 설정인 {3,number,integer}보다 크거나 같아야 합니다.</entry>
    <entry key="SelInvIdxOpt">The ''{0}'' specification for dimension {1,number,integer} in ''{2}'' is invalid. It should be one of the following: ''Select all'', ''Index vector (dialog)'', ''Index vector (port)'' and ''Starting index (port)''</entry>
    <entry key="SelInvIndexPortElems">''{1}''의 &lt;Idx{0,number,integer}&gt;번 입력 포트에 대해 지정된 입력 차원이 유효하지 않습니다. 지정된 요소 개수 {2,number,integer}이(가) 필요한 요소 개수 {3,number,integer}과(와) 일치하지 않습니다.</entry>
    <entry key="SelInvInputElementE2">The value of the second element at input port &lt;Idx{0,number,integer}&gt; in ''{1}'' should be no less than the value of the first element</entry>
    <entry key="SelInvInputElementE2OutOfBound">''{2}''에 있는 &lt;Idx{1,number,integer}&gt;번 입력 포트의 두 번째 요소 {0,number,integer}은(는) 유효한 입력 데이터 요소 선택을 허용하는 허용 가능한 값 범위({3,number,integer}~{4,number,integer}) 내에 없습니다.</entry>
    <entry key="SelInvInputElementENOutOfBound">''{1}''의 {0,number,integer}에 대한 끝 인덱스는 입력 포트 &lt;U&gt;에 존재하지 않는 요소를 참조하기 때문에 유효하지 않습니다. 이 오류를 수정하려면 끝 인덱스가 범위 {4,number,integer}~{5,number,integer} 내에 있도록 &lt;Idx{2,number,integer}&gt;번 입력 포트의 시작 인덱스와 차원 {3,number,integer}의 "출력 크기" 중 하나 또는 둘 모두를 줄이십시오.</entry>
    <entry key="SelInvNumDims">Number of input dimensions specified in ''{0}'' is invalid. Number of input dimensions must be a positive integer constant and no larger than 65535.</entry>
    <entry key="SelInvNumElements">In ''{0}'', parameter ''{1}'' is specified as ''Starting index (dialog)'' for dimension {2,number,integer}. Parameter ''{3}'' for this dimension should be a scalar</entry>
    <entry key="SelInvOutDimsLen">Parameter ''{0}'' parameter specified in ''{1}'' provides output sizes for {2,number,integer} dimensions. It does not match the number of input dimensions</entry>
    <entry key="SelInvOutDimsVal">Parameter ''{0}'' for dimension {1,number,integer} is specified as ''Starting index (port)'' in ''{2}''. The corresponding output dimension should be a positive integer</entry>
    <entry key="SelInvVarDimsFrameOutputDims">Block ''{0}'' outputs a variable-sized frame-based signal. The current size of the first dimension of port &lt;Y&gt; is set to {1,number,integer}, which is not equal to the maximum size, {2,number,integer}. Frame size, i.e., the size of the first dimension, cannot change in variable-sized frame-based signals</entry>
    <entry key="SelInvalidSelIdxForEmptyInp">The current size of dimension {0,number,integer} at input port &lt;U&gt; is 0. Block ''{1}'' requires this size to be at least {2,number,integer}</entry>
    <entry key="SelNoBooleanIdxPort">''{1}''의 &lt;Idx{0,number,integer}&gt;번 포트에 대한 데이터형 설정이 유효하지 않습니다. 이 포트는 부울, half 또는 숫자형이 아닌 데이터형을 지원하지 않습니다.</entry>
    <entry key="SelNoScaledOrBiasedFxpIdxPort">''{1}''의 &lt;Idx{0,number,integer}&gt;번 포트에 대한 데이터형 설정이 유효하지 않습니다. 인덱스 포트에서 고정소수점을 사용하려면 데이터형은 편향 0, 소수 길이 0, 기울기 1.0이이어야 하며 워드 길이가 128보다 작거나 같아야 합니다.</entry>
    <entry key="SelNonIntegerInput">{1}의 &lt;Idx{0,number,integer}&gt;번 입력 포트에서 정수가 아닌 입력값이 잘림</entry>
    <entry key="SelIntegerInputOverflow">{1}의 &lt;Idx{0,number,integer}&gt;번 입력 포트에서 정수 입력 오버플로 발생, 입력 데이터가 int32의 범위를 초과하기 때문에 변환하는 동안 손실이 발생했습니다.</entry>
    <entry key="SelIdxInputIsNaN">Incoming signal to input port &lt;Idx{0,number,integer}&gt; of block ''{1}'' contains NaN. Selector and Assignment blocks do not support NaN signals as index inputs</entry>
    <entry key="SelObsoleteSelectAllSetting">{2}에서 차원 {1,number,integer}에 대한 모든 요소의 선택을 나타내기 위해 파라미터 ''{0}''에 ''-1''이 사용되었습니다. 이 ''-1''은 향후 릴리스에서 더 이상 사용되지 않을 예정입니다. 대신 이 차원에 대해 파라미터 ''{3}''을(를) ''모두 선택''으로 설정하십시오.</entry>
    <entry key="SelStringCellArray">''{1}''에 지정된 파라미터 ''{0}''이(가) 차원 {2,number,integer}에 유효하지 않습니다. 문자형 벡터여야 합니다.</entry>
    <entry key="SelectorIdxPortDoesNotSupportBuses">''{1}''의 &lt;Idx{0,number,integer}&gt;번 입력 포트에 들어오는 신호가 버스 신호이며, 이는 유효하지 않습니다. Selector 블록의 인덱스 포트는 비 버스 신호여야 합니다.</entry>
    <entry key="SelectorRemoveComments">In block ''{0}'', parameter ''{1}'' for dimension {2,number,integer} contains comments. It is disallowed.</entry>
    <entry key="SelectorRemoveComments2">블록 ''{0}''에서 파라미터 ''{1}''의 주석이 제거되었습니다.</entry>
    <entry key="SelectorNonVirtualForImage">블록 ''{0}''은(는) 비가상 블록이기 때문에 이미지 데이터형을 지원하지 않음</entry>
    <entry key="SetAllowMoreThan2DOnlyInEval">setup 메서드 내에서만 ''{1}''에 있는 MATLAB S-Function ''{0}''의 ''AllowSignalsWithMoreThan2D''를 설정할 수 있음</entry>
    <entry key="SetExecContextInheritNotAllowed">Virtual Subsystem 또는 Atomic Subsystem에만 파라미터 ''RequestExecContextInheritance''를 설정할 수 있음</entry>
    <entry key="SetNextTimeHitInExecOnly">시뮬레이션이 실행 중일 때만 ''{1}''에 있는 MATLAB S-Function ''{0}''의 ''NextTimeHit''을 설정할 수 있습니다.</entry>
    <entry key="SetNumTicksToNextTimeHitInExecOnly">시뮬레이션의 주 시간 스텝에서만 ''{1}''에 있는 MATLAB S-Function ''{0}''의 ''NumTicksToNextSampleHit''을 설정할 수 있습니다.</entry>
    <entry key="GetNumTicksToNextTimeHitInExecOnly">시뮬레이션의 주 시간 스텝에서만 ''{1}''에 있는 MATLAB S-Function ''{0}''의 ''NumTicksToNextSampleHit''을 구할 수 있습니다.</entry>
    <entry key="GetNumTicksToNextTimeHitWithControllableSampleTime">''NumTicksToNextSampleHit'' of MATLAB S-Function ''{0}'' in ''{1}'' can be obtained only when it has a controllable sample time.</entry>
    <entry key="SetParamConnPortConnTypeErr">파라미터 ''{0}''을(를) 지정된 값 ''{1}''(으)로 설정할 수 없습니다. 지정된 값은 연결 유형을 명명해야 합니다.</entry>
    <entry key="SetParamConnPortErr">지정된 포트에 대해 파라미터 ''{0}''을(를) 설정할 수 없습니다. 지정된 포트는 연결 포트여야 합니다.</entry>
    <entry key="SetParamOutPortErr">지정된 포트에 대해 파라미터 ''{0}''을(를) 설정할 수 없습니다. 지정된 포트는 출력 포트여야 합니다</entry>
    <entry key="SetSupportsMultipleExecInstancesOnlyInEvalOrPostProp">setup 메서드 또는 PostPropagationSetup 메서드 내에서만 ''{1}''에 있는 MATLAB S-Function ''{0}''의 ''SupportsMultipleExecInstances''를 설정할 수 있습니다.</entry>
    <entry key="ShiftNonIntParam">''{0}''의 파라미터는 -2147483648과 2147483647 사이의 정수 값이어야 합니다.</entry>
    <entry key="ShiftNonIntNetShift">블록 ''{0}''에서 순 시프트 값 {1}은(는) 지원되지 않습니다. 시프트된 값은 -2147483648과 2147483647 사이의 정수 값이어야 합니다.</entry>
    <entry key="ShiftResultSaturates">산술 시프트 연산 결과가 ''{0}''에서 무한대로 포화됩니다.</entry>
    <entry key="ShiftInvalidBitShiftValue">In block ''{0}'', the number of 'Bits to shift' is invalid. This block parameter supports finite, non-complex values in scalar, 1-D, or 2-D format</entry>
    <entry key="ShiftInvalidBitShiftOrBinPtShiftType">Unsupported data type for ''{1}'', in block ''{0}''. Data types supported are built-in data types and fixed point data types with slope equal to one and bias equal to zero</entry>
    <entry key="ShiftNonScalarBNP">''{1}''의 파라미터 ''{0}''은(는) 스칼라여야 함</entry>
    <entry key="ShiftViaPortWithNonZeroBias">For ''{0}'', when 'BitShiftSource' is set to 'Input port', data type of input port cannot support non-zero bias</entry>
    <entry key="ShiftNonScalar1D2Dimension">''{0}''에서 &lt;sldiag objui="inport" objparam="1" objname="{1, number, integer}"&gt;1번 입력 포트&lt;/sldiag&gt;의 차원 수는 {1, number, integer}입니다. 차원 수는 스칼라, 1차원 또는 2차원이어야 합니다.</entry>
    <entry key="ShiftDimsMismatch">''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;의 차원은 ''{2}''이지만 {3,number,integer}번 입력 포트의 차원은 ''{4}''입니다. 두 차원이 모두 스칼라가 아닌 경우 서로 일치해야 합니다.</entry>
    <entry key="ShiftOutOfRange">블록 ''{0}''에서 순 시프트 값 {1, number, integer}이(가) 범위를 벗어났습니다. 시프트된 값은 {2, number, integer}과(와) {3, number, integer} 사이여야 합니다.</entry>
    <entry key="ShiftNonScalarParamInFrameMode">When the input signal is frame-based, parameters of ''{0}'' must be scalar</entry>
    <entry key="ShiftNonTrivialBias">The parameter ''{0}'' of ''{1}'' is not a scalar and the input signal has non-zero bias. This mode is not supported since the shift operation need to involve inefficient bias handling that might not be desired. In order to resolve this issue, set the parameter to be a scalar or set input signal''s bias to be 0.0</entry>
    <entry key="SigConvBlockRequiresBusObj">Signal Conversion 블록 ''{0}''은(는) 입력 버스 신호를 비가상 버스 신호로 변환할 수 없습니다. 유효한 Bus 객체가 Signal Conversion 블록 또는 구동 블록에 지정되지 않았기 때문입니다. ''데이터형'' 파라미터를 사용하여 Signal Conversion 블록에 버스 데이터형을 지정하거나, 구동 블록이 Bus Creator인 경우 해당 블록의 ''데이터형'' 파라미터를 사용하여 버스 데이터형을 지정하십시오.</entry>
    <entry key="SigPropDisabledDupBusCreatorSigNames">Cannot automatically propagate signal labels through Bus Creator ''{0}'' because input signals have duplicate names.</entry>
    <entry key="SigPropDisabledDupMuxSigNames">입력 신호에 중복된 이름이 있기 때문에 Mux ''{0}''을(를) 통해 신호 레이블을 자동으로 전파할 수 없음</entry>
    <entry key="SigSpecRequiresNVBusForAOB">Signal Specification block ''{0}'' cannot output a multi-dimensional virtual bus. Please check the ''Require nonvirtual bus'' option in the ''Signal Attributes'' pane of the block dialog.</entry>
    <entry key="SigSpecIgnoresConfigSetDiagnostics"> 블록 ''{0}''에 대한 입력 버스에 포함된 하나 이상의 신호 이름이 블록 대화 상자에서 Bus 객체 ''{1}''에 의해 지정된 버스에 포함된 신호 이름과 일치하지 않습니다. Signal Specification 블록은 ''요소 이름 불일치'' 옵션 설정에 관계없이 요소 이름 불일치를 항상 오류로 처리합니다. 지정된 Bus 객체를 변경하거나 Bus 객체와 일치하도록 입력 버스 요소 신호의 이름을 바꾸십시오.</entry>
    <entry key="SigViewScopeDimsMismatch">행렬을 갖는 버스(다중화된) 신호이기 때문에 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;를 볼 수 없습니다. 이 포트는 ''{2}''에서 제거되었습니다. 표시할 신호를 ''{3}''의 신호 선택기를 사용하여 다시 선택하십시오. </entry>
    <entry key="SigViewScopeMessageSignal">메시지 신호이기 때문에 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;를 볼 수 없습니다. 이 포트는 ''{2}''에서 제거되었습니다. 표시할 신호를 ''{3}''의 신호 선택기를 사용하여 다시 선택하십시오. </entry>
    <entry key="SiggenNoRandomWaveForRTW">The random wave of the signal generator ''{0}'' is not supported by Simulink Coder - use the appropriate random noise generator</entry>
    <entry key="SiggenNoRandomWaveForTimePort">When the Signal Generator ''{0}'' has input ports, the random wave is not supported</entry>
    <entry key="SiggenRandomWaveObsolete">이전 버전과의 호환성을 위해 ''{0}''에 대해 "랜덤" 파형을 선택할 수 있습니다. 이 선택 항목은 향후 버전에서 제거될 예정이며, 적절한 난수 생성기로 교체돼야 합니다.</entry>
    <entry key="SignumInfiniteGain">''{0}''이(가) 현재 동작점에서 무한 이득으로 선형화됨</entry>
    <entry key="SignumInvalidInputDType">''{0}'' does not support input signals of data type ''{1}'' since signals of that type can not represent the real world value 0.0</entry>
    <entry key="SinWaveInvalidTsErr">''{0}''의 샘플 시간이 유효하지 않습니다. 샘플 기반 사인파에는 유한한 이산 샘플 시간이 필요합니다. 연속 또는 상속된 샘플 시간에는 시간 기반 사인파 유형을 사용하십시오</entry>
    <entry key="SinWaveNegFreqErr">''{0}''에는 음수 주파수가 더 이상 허용되지 않음</entry>
    <entry key="SinWaveSampModeNonDClock">사인파가 샘플 기반 모드에서 작동하는 경우 사인파 ''{0}''의 소스는 디지털 클록이어야 함</entry>
    <entry key="SingleInstModelRefBlkNotSupported">In the Configuration Parameters &gt;  Model Referencing pane of referenced model ''{0}'', the parameter ''Total number of instances allowed per top model'' is set to ''One''. The associated Model block ''{1}'' is not supported inside subsystem ''{2}'' because the subsystem contains a For Each block (''{3}''). Consider changing the parameter ''Total number of instances allowed per top model'' to ''Multiple'' for referenced model ''{4}''.</entry>
    <entry key="SignalLoggingInModelRefBlkInRapidForEachNotSupported">The model containing the For Each subsystem is running in accelerated mode, and the referenced model ''{0}'' has a signal selected for logging. Simulink does not support this configuration. To resolve this issue, do not log signals in ''{1}'' or simulate in normal mode. </entry>
    <entry key="SparseMatricesNotSupported">블록 ''{0}''은(는) 파라미터 ''{1}''에 대한 희소 행렬을 지원하지 않음</entry>
    <entry key="SplineExtrapOnlyForSplineInterp">Block ''{0}'' supports ''Cubic spline'' as its ''Extrapolation method'' only if its ''Interpolation method''  parameter specifies ''Cubic spline''.</entry>
    <entry key="SplineOnlyFloat">Block ''{0}'' supports ''Cubic spline'' or ''Akima spline'' interpolation method only when all the input, output, fraction, intermediate, table, and breakpoint data types are the same floating-point type.</entry>
    <entry key="SquareRootOfNegative">''{0}''에 음수의 제곱근이 있음</entry>
    <entry key="StateEnabledSubsystemNonComplianceInternal">Block ''{0}'' is not allowed in subsystem ''{1}''. The use of this block in a subsystem with the enable port in hardware enable mode is currently not supported.</entry>
    <entry key="StateEnabledSubsystemNonComplianceModelRef">Model block ''{0}'' is not allowed in subsystem ''{1}''. To find the particular block in the referenced model that is causing this issue, duplicate the content of such model in a subsystem with state enable port and update the resulting block diagram.</entry>
    <entry key="StateEnabledSubsystemNonComplianceStateflowEML">Block ''{0}'' is not allowed in subsystem ''{1}''. The use of Stateflow or MATLAB Function block in subsystem with state enable port is currently not supported.</entry>
    <entry key="StateEnabledSubsystemNonComplianceSubsystem">Subsystem ''{0}'' is not allowed in subsystem ''{1}''. The use subsystem that combines Output and Update method, such as function-call, triggered, or iterator subsystem, in another subsystem with state enable port is not supported.</entry>
    <entry key="StateReadWriteOwnSelectorTreeEmpty">계층 구조에 상태 소유자 블록이 없습니다.</entry>
    <entry key="StateReadWriteBlockDiagramChanged1">블록 다이어그램이 변경되었습니다. </entry>
    <entry key="StateReadWriteBlockDiagramChanged2"> 소유자 선택기 트리입니다.</entry>
    <entry key="StateReadWriteBlockStateNameNotSet">No state has been selected. A state of owner block ''{0}'' must be selected.</entry>
    <entry key="StateReadWriteBlockStateNameNotSet2">State Reader 블록 또는 State Writer 블록 ''{0}''에 대해 상태가 선택되지 않았습니다. 소유자 블록 ''{1}''의 상태를 선택해야 합니다.</entry>
    <entry key="StateOwnerResetPort">블록 ''{0}''에 재설정 포트가 있습니다.</entry>
    <entry key="StateOwnerInitCondPort">블록 ''{0}''에 초기 조건 포트가 있습니다.</entry>
    <entry key="StateReadOrWriteHasNoOwnerBlk">모델 ''{1}'' 내에서 State Reader 블록 또는 State Writer 블록 ''{0}''에 대한 상태 소유자 블록을 찾을 수 없습니다.</entry>
    <entry key="StateOwnerNotSingleRate">''{0}''은(는) State Reader 블록 또는 State Writer 블록에서 그 상태에 액세스할 수 있도록 설정되어 있습니다. 따라서 이 블록은 싱글레이트에서 실행해야 합니다.</entry>
    <entry key="StateOwnerNotInExpFcnMdlRootFcnCall">함수를 내보내도록 설정된 모델에서 블록 ''{0}''은(는) State Reader 블록 또는 State Writer 블록에서 그 상태에 액세스할 수 있도록 설정되어 있습니다. 따라서 이 블록은 루트 수준 함수 호출 Inport 블록에 의해 구동되는 함수 호출 컨텍스트 내에서 사용해야 합니다.</entry>
    <entry key="StateOwnerHasConstantTs">''{0}''은(는) State Reader 블록 또는 State Writer 블록에서 그 상태에 액세스할 수 있도록 설정되어 있습니다. 따라서 이 블록은 상수 샘플 시간을 갖거나 상수 샘플 시간을 갖는 서브시스템 내에 배치할 수 없습니다.</entry>
    <entry key="StateOwnerBlkCannotBeInsideForEachSS">''{0}''은(는) State Reader 블록 또는 State Writer 블록에서 그 상태에 액세스할 수 있도록 설정되어 있습니다. 이 블록은 For Each Subsystem 내에 배치할 수 없습니다.</entry>
    <entry key="StateAccessorAndOwnerInDiffForEach">상태 접근자 블록 ''{0}''은(는) ''{1}''이(가) 소유한 상태에 액세스할 수 없습니다. 상태 접근자 블록은 상태 소유자 블록과 동일한 For Each Subsystem 내에 있어야 합니다. </entry>
    <entry key="AccessorAndOwnerInResetFunction">접근자 블록 ''{0}'' 및 소유자 블록 ''{1}''이(가) 모두 Reset Functions 내에 있으며, 이는 허용되지 않습니다. </entry>
    <entry key="StateOwnerICMustBeZeroOrStructForNvBus">블록 ''{0}''의 파라미터 '초기 조건'에 지정된 값이 유효하지 않습니다. 이 블록은 State Reader 블록 또는 State Writer 블록에서 그 상태에 액세스할 수 있도록 구성되어 있으며, 입력 신호는 비가상 버스입니다. 파라미터에 허용되는 값은 0 또는 유한한 숫자형 MATLAB 구조체입니다. 0을 지정하거나 Simulink.Bus.createMATLABStruct를 사용하여 버스 신호에서 MATLAB 구조체를 생성하십시오.</entry>
    <entry key="StateReadOrWriteNotDrvByFcnCallRootInport">함수를 내보내도록 설정된 모델에서 State Reader 블록 또는 State Writer 블록 ''{0}''은(는) 함수 호출 신호를 출력하는 루트 수준 Inport 블록에 의해 구동되는 함수 호출 컨텍스트 내에 배치하거나, Initialize Function 또는 Terminate Function 블록 내에 배치해야 합니다.</entry>
    <entry key="StateReadOrWriteHasConstantTs">State Reader 블록 또는 State Writer 블록 ''{0}''은(는) 상수 샘플 시간을 갖거나 상수 샘플 시간을 갖는 서브시스템 내에 배치할 수 없습니다.</entry>
    <entry key="StateAccessorAndOwnerInDiffCharts">
      State Reader 블록 또는 State Writer 블록 ''{0}''은(는) ''{1}''이(가) 소유한 상태에 액세스할 수 없습니다. 상태 접근자 블록은 상태 소유자 블록과 동일한 Stateflow 차트 내에 있어야 합니다.
    </entry>
    <entry key="StateAccessorInLibraryLink">
      State Reader 블록 또는 State Writer 블록 ''{0}''은(는) 연결된 블록이기 때문에 상태 소유자 블록을 설정할 수 없습니다.
    </entry>
    <entry key="ActionPortInSimulinkStateCannotChangeParam">
      Action Port 블록 ''{0}''은(는) Simulink State 내에서 사용되는 경우 파라미터 ''{1}''의 값을 변경할 수 없습니다.
    </entry>
    <entry key="DuplicateStateNamesInSimulinkState">
      블록 ''{0}''은(는) 상태 이름을 ''{1}''에서 ''{2}''(으)로 변경할 수 없습니다. 새 이름이 이미 블록 ''{3}''에 정의되어 있고 Stateflow 차트에서 액세스되기 때문입니다.
    </entry>
    <entry key="StateAccessorAndOwnerInDiffTasks">
      The State Reader or State Writer block ''{0}'' is accessing the state owned by ''{1}'', which is in a different task with diagnostic &lt;sldiag objui="configset" objparam="MultiTaskRateTransMsg"&gt;''Multitask data transfer''&lt;/sldiag&gt; set to 'error'.  Consider changing the parameter from ''error'' to ''warning'', or placing the blocks in separate function-call subsystems that are either (1) driven by different root-level Inport blocks inside an export-function model, (2) driven by a branched function-call signal, with different execution orders specified by Function-Call Split blocks, or (3) controlled by a common initiator, an If block, or a Switch Case block.\n Alternatively, consider placing block ''{0}'' in an Initialize or Terminate Function block whose parent subsystem contains the state owner block ''{1}''. 
    </entry>
    <entry key="StateAccessorAndOwnerInDiffTasksWarning">
      State Reader 블록 또는 State Writer 블록 ''{0}''이(가) 다른 태스크에서 ''{1}''이(가) 소유한 상태에 액세스하고 있습니다. 이 블록을 다음의 성격을 갖는 두 Function-Call Subsystem에 배치해 보십시오. (1) 함수 내보내기 모델에서 각기 다른 루트 수준 Inport 블록에 의해 구동되는 서브시스템, (2) 분기된 함수 호출 신호로 구동되고 Function-Call Split 블록에 의해 서로 다른 실행 순서가 지정된 서브시스템, 또는 (3) 공통 개시자, If 블록 또는 Switch Case 블록에 의해 제어되는 서브시스템.\n 또는 부모 서브시스템에 상태 소유자 블록 ''{1}''이(가) 있는 Initialize 또는 Terminate Function 블록에 블록 ''{0}''을(를) 배치해 보십시오.
    </entry>
    <entry key="StateAccessorBlocksInSameCompInfo">
      Blocks ''{0}'' and ''{1}'' cannot be placed in the same non-virtual hierarchy because they access the same state owned by ''{2}''. Consider placing them in two function-call subsystems (1) driven by different root-level Inport blocks inside an export function model (2) driven by a branched function-call signal and having different execution orders specified by Function-Call Split blocks, or (3) controlled by a common initiator, an If block, or a Switch Case block.\n Alternatively, consider placing blocks ''{0}'' and ''{1}'' in Initialize and Terminate Function blocks whose parent subsystem contains the state owner block ''{2}''.
    </entry>
    <entry key="StateAccessorAndOwnerInSameCompInfo">
      블록 ''{0}''은(는) ''{1}''이(가) 소유한 상태에 액세스합니다. 따라서 이들을 동일한 비가상 계층 구조에 둘 수 없습니다. 이들 블록을 다음의 성격을 갖는 두 Function-Call Subsystem에 배치해 보십시오. (1) 함수 내보내기 모델 내의 각기 다른 루트 수준 Inport 블록에 의해 구동되는 서브시스템, (2) 분기된 함수 호출 신호로 구동되고 Function-Call Split 블록에 의해 서로 다른 실행 순서가 지정된 서브시스템, 또는 (3) 공통 개시자, If 블록 또는 Switch Case 블록에 의해 제어되는 서브시스템.\n 또는 부모 서브시스템에 상태 소유자 블록 ''{1}''이(가) 있는 Initialize Function 블록 또는 Terminate Function 블록에 블록 ''{0}''을(를) 배치해 보십시오.
    </entry>
    <entry key="StateReaderAndWriterBlocksInSameTaskError">
      State Reader 블록 또는 State Writer 블록 ''{0}''과(와) ''{1}''이(가) ''{2}''이(가) 소유한 동일한 상태에 액세스하고 있습니다. 그리고 동일한 루트 수준 Inport 블록에 의해 구동되고 있거나, 함수 내보내기 모델 내의 동일한 Simulink Function에 있습니다. 결정적 상대 실행 순서를 보장하려면 이러한 블록을 동일한 비가상 서브시스템에 배치해 보십시오. 그렇지 않으면 (1) 분기된 함수 호출 신호로 구동되고 Function-Call Split 블록에 의해 서로 다른 실행 순서가 지정되었거나 (2) 공통 함수 호출 개시자, If 블록 또는 Switch Case 블록에 의해 제어되는 두 서브시스템에 이러한 블록을 배치하십시오. 또는 부모 서브시스템에 상태 소유자 블록 ''{2}''이(가) 포함된 Initialize 블록과 Terminate Function 블록에 블록 ''{0}''과(와) ''{1}''을(를) 배치해 보십시오.
    </entry>
    <entry key="StateReaderAndWriterBlocksInNonExpFcnMdlSameTsError">
      State Reader 블록 또는 State Writer 블록 ''{0}''과(와) ''{1}''이(가) ''{2}''이(가) 소유한 동일한 상태에 액세스하고, 동일한 샘플 시간을 갖습니다. 결정적 상대 실행 순서를 보장하려면 이러한 블록을 동일한 비가상 서브시스템에 배치해 보십시오. 그렇지 않으면 (1) 분기된 함수 호출 신호로 구동되고 Function-Call Split 블록에 의해 서로 다른 실행 순서가 지정되었거나 (2) 공통 함수 호출 개시자, If 블록 또는 Switch Case 블록에 의해 제어되는 두 서브시스템에 이러한 블록을 배치하십시오. 또는 부모 서브시스템에 상태 소유자 블록 ''{2}''이(가) 포함된 Initialize 블록과 Terminate Function 블록에 블록 ''{0}''과(와) ''{1}''을(를) 배치해 보십시오.
    </entry>
    <entry key="StateAccessorBlocksInSameTaskError">
      State Reader 블록 또는 State Writer 블록 ''{0}''과(와) ''{1}''이(가) ''{2}''이(가) 소유한 동일한 상태에 액세스하고 있습니다. 그리고 동일한 루트 수준 Inport 블록에 의해 구동되고 있거나, 함수 내보내기 모델 내의 동일한 Simulink Function에 있습니다. 결정적 상대 실행 순서를 보장하려면, (1) 분기된 함수 호출 신호로 구동되고 Function-Call Split 블록에 의해 서로 다른 실행 순서가 지정되었거나 (2) 공통 함수 호출 개시자, If 블록 또는 Switch Case 블록에 의해 제어되는 두 서브시스템에 이러한 블록을 배치해 보십시오. 또는 부모 서브시스템에 상태 소유자 블록 ''{2}''이(가) 포함된 Initialize 블록과 Terminate Function 블록에 블록 ''{0}''과(와) ''{1}''을(를) 배치해 보십시오.
    </entry>
    <entry key="StateAccessorBlocksInNonExpFcnMdlSameTsError">
      State Reader 블록 또는 State Writer 블록 ''{0}''과(와) ''{1}''이(가) ''{2}''이(가) 소유한 동일한 상태에 액세스하고, 동일한 샘플 시간을 갖습니다. 결정적 상대 실행 순서를 보장하려면, (1) 분기된 함수 호출 신호로 구동되고 Function-Call Split 블록에 의해 서로 다른 실행 순서가 지정되었거나 (2) 공통 함수 호출 개시자, If 블록 또는 Switch Case 블록에 의해 제어되는 두 서브시스템에 이러한 블록을 배치해 보십시오. 또는 부모 서브시스템에 상태 소유자 블록 ''{2}''이(가) 포함된 Initialize 블록과 Terminate Function 블록에 블록 ''{0}''과(와) ''{1}''을(를) 배치해 보십시오.
    </entry>
    <entry key="StateAccessorAndOwnerInSameTaskError">
      블록 ''{0}''이(가) ''{1}''이(가) 소유한 상태에 액세스하고 있습니다. 그리고 두 블록은 동일한 루트 수준 Inport 블록에 의해 구동되고 있거나 함수 내보내기 모델 내의 동일한 Simulink Function에 있습니다. 결정적 상대 실행 순서를 보장하려면, (1) 분기된 함수 호출 신호로 구동되고 Function-Call Split 블록에 의해 서로 다른 실행 순서가 지정되었거나 (2) 공통 함수 호출 개시자, If 블록 또는 Switch Case 블록에 의해 제어되는 두 서브시스템에 이러한 블록을 배치해 보십시오. 또는 부모 서브시스템에 상태 소유자 블록 ''{1}''이(가) 포함된 Initialize 블록 또는 Terminate Function 블록에 블록 ''{0}''을(를) 배치해 보십시오.
    </entry>
    <entry key="StateAccessorInSimulinkFunction">
      State Reader 블록 또는 State Writer 블록 ''{0}''이(가) Simulink Function ''{1}'' 내에 있습니다.
    </entry>
    <entry key="StateAccessorAndOwnerCallerInSameSimulinkFunctionChain">
      Function Caller 블록 ''{0}'' 및 ''{1}''이(가) 동일한 태스크에 있습니다. 이 두 블록은 ''{3}''이(가) 포함된 Simulink Function ''{2}''과(와) ''{5}''이(가) 포함된 Simulink Function ''{4}''을(를) 각각 호출합니다.
    </entry>
    <entry key="StateAccessorAndFcnCallerInSameTask">
      ''{2}''을(를) 호출하는 Function Caller 블록 ''{1}''과(와) State Reader 또는 State Writer 블록 ''{0}''은(는) 동일한 루트 수준 Inport 블록에 의해 구동되고 있거나, 함수 내보내기 모델 내의 동일한 Simulink Function에 있습니다.
    </entry>
    <entry key="StateOwnerInSimulinkFunction">
      상태 소유자 블록 ''{0}''이(가) Simulink Function ''{1}'' 내에 있습니다.
    </entry>
    <entry key="StateOwnerAndFcnCallerInSameTask">
      ''{2}''을(를) 호출하는 Function Caller 블록 ''{1}''과(와) 상태 소유자 블록 ''{0}''이(가) 동일한 루트 수준 Inport 블록에 의해 구동되고 있거나, 함수 내보내기 모델 내의 동일한 Simulink Function에 있습니다.
    </entry>
    <entry key="StateAccessorAndOwnerInNonExpFcnMdlSameTsError">
      블록 ''{0}''은(는) 동일한 샘플 시간을 갖는, ''{1}''이(가) 소유한 상태에 액세스합니다. 결정적 상대 실행 순서를 보장하려면, (1) 분기된 함수 호출 신호로 구동되고 Function-Call Split 블록에 의해 서로 다른 실행 순서가 지정되었거나 (2) 공통 함수 호출 개시자, If 블록 또는 Switch Case 블록에 의해 제어되는 두 서브시스템에 이러한 블록을 배치해 보십시오. 또는 부모 서브시스템에 상태 소유자 블록 ''{1}''이(가) 포함된 Initialize 블록 또는 Terminate Function 블록에 블록 ''{0}''을(를) 배치해 보십시오.
    </entry>
    <entry key="StateUnnamedForMulStatesBlks">Name the states of the block ''{0}'' before selecting.</entry>
    <entry key="StateUnnamedForMultipleStatesOwner">블록 ''{0}''에 명명되지 않은 하나 이상의 상태가 있습니다. 블록 ''{0}''에 여러 개의 상태가 있기 때문에, 상태에 액세스하려면 상태를 명시적으로 명명해야 합니다.</entry>
    <entry key="InvalidStateNameForMultipleStatesAccessor">블록 ''{1}''이(가) 블록 ''{2}''에서 액세스하려고 하는 상태 ''{0}''이(가) 존재하지 않습니다. ''{1}''이(가) 올바른 상태에 액세스하도록 구성되어 있는지 확인하십시오.</entry>
    <entry key="StateUnnamedForMulStatesBlksDropMenu">Cannot create a State Reader or State Writer since the states of the block ''{0}'' are unnamed. Name all the states of the block before creating a State Reader or State Writer.</entry>
    <entry key="StateNameAccessedCanNotBeEmpty">State Reader/State Writer 블록이 해당 블록에 액세스하는 중이기 때문에 상태 이름을 빈 값으로 설정할 수 없습니다.</entry>
    <entry key="StateReaderOrWriterInvalidStateOwner">Cannot set block ''{0}'' as the state owner block for State Reader, State Writer or Stateflow chart ''{1}''.</entry>
    <entry key="InvalidStateOwnerInitTermResetSS">State Reader 블록 또는 State Writer 블록 ''{0}''이(가) Initialize Function, Terminate Function, Reinitialize Function 또는 Reset Function 블록 ''{1}'' 내에 배치되어 있습니다. 상태 소유자 블록 ''{2}''은(는) 블록 ''{1}''의 부모 서브시스템 외부에 있을 수 없습니다.</entry>
    <entry key="InvalidStateOwnerReasonGeneric">유형 ''{0}''의 블록은 상태 소유자 블록일 수 없습니다.</entry>
    <entry key="InvalidParameterOwnerReasonGeneric">유형 ''{0}''의 블록은 파라미터 소유자 블록일 수 없습니다.</entry>
    <entry key="ParamAccessorNotWithinIRT">Parameter Writer 블록 ''{0}''은(는) Initialize Function, Reinitialize Function, Reset Function 또는 Terminate Function 블록 내에서만 사용할 수 있습니다. 블록 ''{0}''이(가) 잘못 사용되고 있습니다.</entry>
    <entry key="ParameterAccessorBlockNotConnected"> 파라미터 이름을 지정하기 전에 Parameter Writer 블록 ''{0}''에 대해 파라미터 소유자 블록을 지정해야 합니다. </entry>
    <entry key="ParamAccessorParamNameExpired">소유자 블록 ''{1}''에 대해 인식할 수 없는 파라미터 이름 ''{2}''이(가) Parameter Writer 블록 ''{0}''에 지정되었습니다.</entry>
    <entry key="ParamAccessorParamNameNotUsed">Model 블록 ''{1}''에 대해 사용되지 않는 파라미터 ''{2}''이(가) Parameter Writer 블록 ''{0}''에 지정되었습니다.</entry>
    <entry key="ParamAccessorParamBeenPromoted">Parameter Writer 블록 ''{0}''은(는) Model 블록 ''{1}''의 파라미터 ''{2}''에 액세스할 수 없습니다. 이 파라미터가 Model 블록 ''{1}''에 의해 인수로 승격되었기 때문입니다. 다른 파라미터를 선택하거나, 파라미터가 더 이상 승격되지 않도록 하려면 Model 블록 대화 상자에서 ''인수'' 체크박스의 선택을 해제하십시오.</entry>
    <entry key="ParamAccessorInLibraryLink">Parameter Writer 블록 ''{0}''은(는) 연결된 블록이기 때문에 파라미터 소유자 블록을 설정할 수 없습니다.</entry>
    <entry key="ParamAccessorAndOwnerInDiffForEach">Parameter Writer 블록 ''{0}''이(가) 블록 ''{1}''의 파라미터에 액세스할 수 없습니다. Parameter Writer 블록은 파라미터 소유자 블록과 동일한 For Each Subsystem에 있어야 합니다. </entry>
    <entry key="ParamAccessorParamBusTypeInfoNotAvailable">Parameter Writer 블록 ''{0}''은(는) 블록 ''{1}''의 버스 유형 파라미터에 쓸 수 없습니다. 버스 유형 정보를 사용할 수 없기 때문입니다.</entry>
    <entry key="InvalidStateOwnerReasonSFcn">S-Function 블록을 상태 소유자 블록으로 구성하려면, ssSetDWorkUsedAsDState를 사용하여 정확히 하나의 데이터형 작업 벡터를 이산 상태 벡터로 선언하고 mdlInitializeSizes에서 ssSetDWorkName 또는 ssSetDWorkRTWIdentifier를 사용하여 그 벡터를 명명해야 합니다.</entry>
    <entry key="InvalidStateOwnerReasonOutport">출력 포트를 나타내는 블록이 상태 소유자 블록이 되려면 이 블록이 조건부 실행 서브시스템에서 Outport 블록이어야 합니다. Out Bus Element 블록은 상태 소유자 블록으로 사용할 수 없습니다.</entry>
    <entry key="InvalidStateOwnerReasonTriggerPort">Trigger Port 블록을 상태 소유자 블록으로 구성하려면 파라미터 ''트리거 유형''을 ''상승'', ''하강'' 또는 ''양쪽 모두 가능''으로 설정하십시오.</entry>
    <entry key="InvalidStateOwnerReasonDiscreteFilter">Discrete Filter 블록을 상태 소유자 블록으로 구성하려면 파라미터 ''필터 구조''를 ''Direct form II''로 설정하십시오.</entry>
    <entry key="InvalidStateOwnerReasonSampleBasedInputs">{0} 블록이 다중채널 입력값을 갖는 상태 소유자 블록이고 블록 대화 상자에서 입력 처리 파라미터를 '요소를 채널로(샘플 기반)'로 설정하면 {0} 블록이 행 우선 코드 생성을 지원하지 않습니다. 코드를 생성하려면 코드 생성 &gt; 인터페이스 창에서 '배열 레이아웃' 모델 구성 파라미터를 '열 우선'으로 설정하십시오.</entry>
    <entry key="InvalidStateOwnerInDiffModel">블록 ''{0}''과(와) ''{1}''이(가) 동일한 모델 내에 있지 않습니다.</entry>
    <entry key="InvalidResourceOwnerCommented">블록 ''{0}''이(가) 주석 처리되었습니다.</entry>
    <entry key="InvalidStateOwnerInactiveVariant1">블록 ''{0}''이(가) 비활성 Variant의 일부입니다. 다음 해결 방법 중 하나를 사용해 보십시오:\n (1) 이 블록이 Variant Subsystem 안에 있는 경우 ''Variant 활성화 시점''을 ''코드 컴파일'', ''시작'' 또는 ''런타임''으로 설정합니다.\n (2) 이 블록이 Variant Source 블록 또는 Variant Sink 블록에 연결된 경우 ''Variant 활성화 시점''을 ''코드 컴파일'' 또는 ''시작''으로 설정합니다.\n (3) 이 블록이 활성 상태가 되고 관련된 모든 State Reader 블록과 State Writer 블록이 동일한 활성화 상태에 있도록 Variant 조건을 변경합니다.</entry>
    <entry key="InvalidStateOwnerInactiveVariant2">모델 ''{2}''은(는) ERT 타깃의 코드를 업데이트하거나 생성할 수는 있지만, 시뮬레이션할 수는 없습니다. State Reader 또는 State Writer 블록 ''{0}''이(가) 비활성 Variant의 일부인 ''{1}''이(가) 소유한 상태에 액세스하도록 구성되었기 때문입니다. 이 블록이 활성 상태가 되고 관련된 모든 State Reader 블록과 State Writer 블록이 동일한 활성화 상태에 있도록 Variant 조건을 변경해 보십시오.</entry>
    <entry key="InvalidParameterOwnerInactiveVariant2">모델 ''{2}''은(는) ERT 타깃의 코드를 업데이트하거나 생성할 수는 있지만, 시뮬레이션할 수는 없습니다. Parameter Writer 블록 ''{0}''이(가) 비활성 Variant의 일부인 ''{1}'' 소유의 파라미터에 액세스하도록 구성되었기 때문입니다. 이 블록이 활성 상태가 되고 관련된 모든 Parameter Writer 블록이 동일한 활성화 상태에 있도록 Variant 조건을 변경해 보십시오.</entry>
    <entry key="StateAccessorBlockJacobianNotSupported">State Reader 블록과 State Writer 블록은 선형화할 수 없습니다.</entry>
    <entry key="ParameterReadOrWriteHasNoOwnerBlk">Parameter Writer 블록 ''{0}''에 지정된 파라미터가 없습니다.</entry>
    <entry key="ParameterReaderWriterSelectorTreeEmpty">쓰기 가능한 블록 파라미터가 없습니다.</entry>
    <entry key="MdlWithParamAccessorCannotHaveInlinedParams">Parameter Writer 블록이 있는 모델은 인라인 파라미터를 가질 수 없습니다. configset 파라미터 "디폴트 파라미터 동작"의 값을 "조정 가능형"으로 변경하십시오.</entry>
    <entry key="InvalidParameterAccessorSimulinkFunction">Simulink Function 블록 ''{1}'' 내에 Parameter Writer 블록 ''{0}''을(를) 사용하는 것은 지원되지 않습니다.</entry>
    <entry key="ParameterAccessorPromotedParamsOrderMismatch">블록 ''{1}'' 마스크 대화 상자에서 Parameter Writer 블록 ''{0}''의 파라미터 ''ParameterOwnerBlock''은 파라미터 ''ParameterName'' 앞에 배치되어야 합니다.</entry>
    <entry key="ParameterAccessorParamsCannotBeFurtherPromoted">Parameter Writer 블록의 ''{0}''의 파라미터 ''ParameterOwnerBlock'' 및 ''ParameterName''을 모델 계층 구조에서 블록 ''{1}''보다 더 높은 수준에 있는 마스크로 승격하는 것은 지원되지 않습니다.</entry>
    <entry key="ParamWriterWritingToBlockParamUsedOutsideParentSS">블록 ''{2}''이(가) 서브시스템 ''{3}'' 밖에 있으므로 Parameter Writer 블록 ''{0}''을(를) 사용하여 블록 ''{2}''의 파라미터 ''{1}''에 쓸 수 없습니다.</entry>
    <entry key="ParamWriterInsideReinitSSWithParamChangeEventOutport">서브시스템 ''{1}''에 재초기화 포트가 있고 상수 샘플 시간을 갖는 Outport 블록이 포함되어 있기 때문에 서브시스템 ''{1}''에 Parameter Writer 블록 ''{0}''을(를) 사용할 수 없습니다.</entry>
    <entry key="InvalidParameterAccessToOlderProtectedModel1">Parameter Writer 블록 ''{0}''은(는) 보호된 Model 블록 ''{2}''의 파라미터 ''{1}''에 쓸 수 없습니다. 모델이 이전 버전의 Simulink에서 생성되었기 때문입니다. Parameter Writer 블록이 Model 블록 파라미터에 쓸 수 있도록 허용하려면 R2019a 이상 버전에서 보호된 모델을 저장하십시오.</entry>
    <entry key="InvalidParameterAccessToOlderProtectedModel2">Parameter Writer 블록 ''{0}''이(가) 보호된 함수 호출 Model 블록 ''{2}''의 파라미터 ''{1}''에 쓰려고 하고 있습니다. 이 보호 모델은 이전 버전의 Simulink에서 생성되었으며, 해당 파라미터에 대한 액세스를 허용하는 데 필요한 정보를 갖고 있지 않습니다. 보호 모델이 R2022a 이상에서 생성되었는지 확인하십시오.</entry>
    <entry key="MultipleParameterAccessorsInSameIRTSystem">Parameter Writer 블록 ''{0}'' 및 ''{1}''이(가) ''{2}''의 동일한 파라미터에 액세스하고 동일한 샘플 시간을 갖습니다. 결정적 상대 실행 순서를 보장하려면, 이 두 Writer 블록에 대해 서로 다른 파라미터를 선택하십시오. 또는 (1) 공통 함수 호출 개시자, If 블록 또는 Switch Case 블록에 의해 제어되거나 (2) 분기된 함수 호출 신호로 구동되고 Function-Call Split 블록에 의해 서로 다른 실행 순서가 지정된 두 서브시스템에 이러한 블록을 배치해 보십시오.</entry>
    <entry key="InvalidParameterOwnerInitTermResetSS">Parameter Writer 블록 ''{0}''이(가) Initialize Function, TerminateFunction, Reinitialize Function 또는 Reset Function 블록 ''{1}'' 내에 배치되어 있습니다. 이 블록이 액세스하는 Model 블록 ''{2}''은(는) 블록 ''{1}''의 부모 서브시스템 외부에 있을 수 없습니다.</entry>
    <entry key="InvalidParameterOwnerInDiffModel">블록 ''{0}''과(와) ''{1}''이(가) 동일한 모델 내에 있지 않습니다.</entry>
    <entry key="InvalidParameterAccessorOutsideIRT">
      
               Parameter Writer 블록 ''{0}''이(가) Initialize Function, Reinitialize Function, Reset Function 또는 Terminate Function 블록 내에 있지 않습니다. Parameter Writer 블록은 이러한 Function 블록 내에서만 사용할 수 있습니다. 자세한 내용은 Simulink 도움말 문서에서 &lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''],''ParameterWriter'')"&gt;Parameter Writer 블록&lt;/a&gt; 사용법을 참조하십시오.
      
    </entry>
    <entry key="InvalidParameterAccessorOutsideIRTAndCondSS">
      
               Parameter Writer 블록 ''{0}''이(가) Initialize Function, Reset Function, Terminate Function 블록 내에 있지 않거나, Enabled Subsystem 또는 Function-Call Subsystem 같은 조건부 실행 서브시스템 내에 있지 않습니다. Parameter Writer 블록은 이러한 Function 블록 내에서만 사용할 수 있습니다. 자세한 내용은 Simulink 도움말 문서에서 &lt;a href="matlab:helpview([docroot ''/simulink/helptargets.map''],''ParameterWriter'')"&gt;Parameter Writer 블록&lt;/a&gt; 사용법을 참조하십시오.
      
    </entry>
    <entry key="InvalidParameterOwnerInactiveVariant1">블록 ''{0}''이(가) 비활성 Variant의 일부입니다. 다음 해결 방법 중 하나를 사용해 보십시오:\n (1) 이 블록이 Variant Subsystem에 있는 경우 ''Variant 활성화 시점''을 ''코드 컴파일'' 또는 ''시작''으로 설정합니다.\n (2) 이 블록이 Variant Source 블록 또는 Variant Sink 블록에 연결된 경우 ''Variant 활성화 시점''을 ''코드 컴파일'' 또는 ''시작''으로 설정합니다.\n (3) 이 블록이 활성 상태가 되고 관련된 모든 Parameter Writer 블록이 동일한 활성화 상태에 있도록 Variant 조건을 변경합니다.</entry>
    <entry key="ParamAccessorCannotWriteToInvalidStorageClassParam">
      
               Unable to generate code for model ''{0}'' since a Parameter Writer block is attempting to write to parameter ''{1}'' which does not have ''Auto'' or ''Model default'' Storage Class.
               &lt;actions exclusiveFixIts="yes"&gt;
               &lt;action type="suggestion"&gt;
               &lt;txt&gt;Set the storage class of the workspace parameter ''{1}'' to ''Auto'' or ''Model default''.
               &lt;/txt&gt;
               &lt;/action&gt;
               &lt;/actions&gt;
      
    </entry>
    <entry key="ParamAccessorCannotWriteToInvalidStorageClassParam2">Parameter Writer 블록 ''{0}''이(가) 코드에서 매크로 또는 상수로 생성된 스토리지 클래스를 가진 파라미터 ''{1}''에 쓰는 중이므로 코드를 생성할 수 없습니다.
    </entry>
    <entry key="ParamAccessorCannotWriteToAutoStorageClassModelParam">
      
               모델 ''{0}''에 대한 코드를 생성할 수 없습니다. Parameter Writer 블록이 Model 블록 ''{2}''에 속하고 동시에 ''Auto'' 스토리지 클래스를 갖는 파라미터 ''{1}''에 쓰려고 하기 때문입니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'','DefaultParameterBehavior','Tunable');&lt;/cmd&gt; &lt;txt&gt;파라미터 ''디폴트 파라미터 동작''을 ''조정 가능형''으로 설정하십시오. &lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;모델에 있는 파라미터 ''{2}''의 스토리지 클래스를 ''Auto''가 아닌 다른 값으로 설정하십시오. &lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
      
    </entry>
    <entry key="ParamAccessWritingToParamWithinIRT">The parameter ''{0}'' of the Model block ''{1}'' which is being written to by the Parameter Writer Block ''{2}'', is being referenced within an Initialize, Reinitialize, Reset or Terminate Function block within ''{1}''. Writing to such parameters is not allowed using the Parameter Writer block. Ensure that the parameter is used outside Initialize, Reinitialize, Reset or Terminate Functions.</entry>
    <entry key="ParamAccessWritingToParamUsedAsInitialValue">Parameter ''{0}'' of Model block ''{1}'' is written to by Parameter Writer block ''{2}'' and is used as an Initial Condition of a block in model ''{1}'', which is not supported.</entry>
    <entry key="ParamAccessWritingToParamUsedAsNonTunableParam">Parameter Writer 블록 ''{2}''을(를) 사용하여 Model 블록 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 파라미터는 Parameter Writer 블록에서 지원하지 않는 참조된 모델의 블록 파라미터가 사용하기 때문입니다.</entry>
    <entry key="ParamAccessWritingToParamAssociatedWithVariantCond">Parameter Writer 블록 ''{1}''은(는) Model 블록 ''{2}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 파라미터에 Variant 조건이 연결되어 있기 때문입니다.</entry>
    <entry key="ParamAccessWritingToParamWhichIsNotSimulinkParameterObj">Parameter Writer 블록 ''{2}''은(는) Model 블록 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 파라미터가 Simulink.Parameter 객체나 matlab 변수가 아니기 때문입니다.</entry>
    <entry key="ParamWriterWritingToParamWhichHasNonAutoParamMapping">Parameter Writer block ''{2}'' is unable to write to parameter ''{0}'' of Model block ''{1}'' because the parameter is from an AUTOSAR target or does not have auto parameter mapping in an AUTOSAR target.</entry>
    <entry key="ParamWriterWritingToParamWithConstTs">Parameter Writer 블록 ''{2}''은(는) Model 블록 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 파라미터가 모델 ''{1}'' 내에서 상수 샘플 시간을 갖는 블록에서 사용되고 있기 때문입니다. Initialize Function, Reset Function 및 Terminate Function 외부에 있는 Parameter Writer 블록을 사용하여 그러한 파라미터에 쓰는 것은 지원되지 않습니다.</entry>
    <entry key="ParamWriterWritingToWSVarNonExisting">변수 ''{1}''이(가) {2} 작업 공간에 존재하지 않기 때문에 Parameter Writer 블록 ''{0}''을(를) 사용하여 작업 공간 변수 ''{1}''에 쓸 수 없습니다.</entry>
    <entry key="ParamWriterWritingToWSVarNotUsed">Unable to write to {2} workspace variable ''{1}'' using Parameter Writer block ''{0}'' because {2} workspace variable ''{1}'' is not used by any blocks in the model.</entry>
    <entry key="ParamWriterWritingToWSVarSubField">''{1}''이(가) 구조체형 {2} 작업 공간 변수의 필드이므로 Parameter Writer 블록 ''{0}''을(를) 사용하여 이 필드에 쓸 수 없습니다.</entry>
    <entry key="ParamWriterWritingToGWSVarNotUsedInBd">변수 ''{1}''이(가) 현재 모델 내 어떠한 블록에도 사용되지 않으므로, Parameter Writer 블록 ''{0}''을(를) 사용하여 기본 작업 공간 변수 ''{1}''에 쓸 수 없습니다.</entry>
    <entry key="ParamWriterWritingToWSVarUsedByParentSS">변수 ''{1}''이(가) Parameter Writer 블록 ''{0}''의 부모 서브시스템 ''{2}''에서 사용되므로, 블록 ''{0}''을(를) 사용하여 작업 공간 변수 ''{1}''에 쓸 수 없습니다.</entry>
    <entry key="ParamWriterWritingToModelParamArg1">Unable to write to model workspace variable ''{1}'' in model ''{0}'' using Parameter Writer blocks because it is a model parameter argument.</entry>
    <entry key="ParamWriterWritingToModelParamArg2">모델 작업 공간 변수 ''{0}''은(는) 모델 파라미터 인수이기 때문에 Parameter Writer 블록을 사용하여 이 변수에 쓸 수 없습니다.</entry>
    <entry key="ParamWriterWritingToWSVarNonSimulinkObj">Parameter Writer 블록 ''{0}''이(가) Simulink.Parameter 객체가 아닌 변수 ''{1}''에 쓰려고 합니다. Parameter Writer 블록을 사용하여 Simulink.Parameter 객체로 정의되지 않은 작업 공간 변수에 쓰는 것은 지원되지 않습니다.</entry>
    <entry key="ParamWriterWritingToWSVarUsedAsInitialValue">The Parameter Writer block ''{0}'' is trying to write to the variable ''{1}'' which is used as an initial condition of a block within the model. Writing to parameters used as initial conditions using the Parameter Writer block is not supported.</entry>
    <entry key="ParamWriterWritingToWSVarUsedAsNonTunableParam">Unable to write to workspace variable ''{2}'' using Parameter Writer block ''{0}'' because variable ''{2}'' is used by a parameter of block ''{1}'' that the Parameter Writer block does not support.</entry>
    <entry key="ParamWriterWritingToWSVarUsedByNonBlock">변수 ''{1}''을(를) 사용하는 것들 중 일부가 Simulink 블록이 아니라서 Parameter Writer 블록 ''{0}''을(를) 사용하여 작업 공간 변수 ''{1}''에 쓸 수 없습니다.</entry>
    <entry key="ParamWriterWritingToWSVarUsedByPort">변수 ''{1}''이(가) ''{2}''의 포트에 사용되므로, Parameter Writer 블록 ''{0}''을(를) 사용하여 작업 공간 변수 ''{1}''에 쓸 수 없습니다.</entry>
    <entry key="ParamWriterWritingToWSVarUsedInExpression">변수 ''{1}''이(가) 블록 ''{3}''의 표현식 ''{2}''에서 사용되므로, Parameter Writer 블록 ''{0}''을(를) 사용하여 작업 공간 변수 ''{1}''에 쓸 수 없습니다.</entry>
    <entry key="ParamWriterWritingToWSVarWithConstTs">변수 ''{1}''이(가) 상수 샘플 시간을 갖는 블록에 사용되므로, Parameter Writer 블록 ''{0}''을(를) 사용하여 작업 공간 변수 ''{1}''에 쓸 수 없습니다.</entry>
    <entry key="MultipleParamWriteToSameWSVar">Parameter Writer 블록 ''{0}'' 및 ''{1}''이(가) 동일한 작업 공간 변수에 액세스하고 동일한 샘플 시간을 갖습니다. 결정적 상대 실행 순서를 보장하려면, 이 두 Writer 블록에 대해 서로 다른 파라미터를 선택하십시오. 또는 (1) 공통 함수 호출 개시자, If 블록 또는 Switch Case 블록에 의해 제어되거나 (2) 분기된 함수 호출 신호로 구동되고 Function-Call Split 블록에 의해 서로 다른 실행 순서가 지정된 두 서브시스템에 이러한 블록을 배치해 보십시오.</entry>
    <entry key="MultipleParamWriteToSameWSVarDiffIRT">Initialize Function, Reset Function 또는 Reinitialize Function 블록 ''{2}'' 및 ''{3}''은(는) 동일한 작업 공간 변수에 쓰는 Parameter Writer 블록 ''{0}'' 및 ''{1}''을(를) 포함하기 때문에 동일한 Atomic Subsystem에 있어야 합니다.</entry>
    <entry key="ParamWriterWritingToWSVarUpdatedInSim">Parameter Writer 블록이 작업 공간/데이터 사전 변수 ''{0}''에 자신의 값을 쓰기 때문에 시뮬레이션 중에 이 변수의 값을 수동으로 변경할 수 없습니다.</entry>
    <entry key="ParamWriterWritingToGWSVarInMultiModels">기본 작업 공간 변수 ''{0}''이(가) 서로 다른 모델에 있거나 여러 번 참조된 동일한 모델에 있는 Parameter Writer 블록 ''{1}'' 및 ''{2}''에 의해 쓰기 작업이 수행되었기 때문에 이 변수에 쓸 수 없습니다.</entry>
    <entry key="ParamWriterWritingToGWSVarUsedInRefMdl">Parameter Writer 블록 ''{0}''이(가) 작업 공간 변수 ''{1}''에 쓰는 중인데, 이 변수는 비자동 스토리지 클래스를 갖는 Simulink.Parameter 객체가 아니므로 변수 ''{1}''을(를) 사용하는 참조 모델의 생성 코드에서 인라인으로 처리될 수 있습니다.</entry>
    <entry key="ParamWriterWritingToGWSVarUsedInRefMdlInlined">Parameter Writer 블록 ''{0}''이(가) 작업 공간 변수 ''{1}''에 쓰는 중인데, Model 블록 ''{2}''의 참조 모델의 구성 파라미터 ''디폴트 파라미터 동작''이 ''인라인''으로 설정되어 있기 때문에 참조 모델의 생성 코드에서 이 변수는 인라인으로 처리될 수 있습니다.</entry>
    <entry key="ParamWriterWritingToGWSVarValidationOff">
        
                 Parameter Writer 블록 ''{0}''이(가) Model 블록 ''{2}''에서 참조하는 모델에 사용된 작업 공간 변수 ''{1}''에 쓰기 때문에 이 Parameter Writer 블록의 ''IsParameterValidationOn'' 파라미터를 ''off''로 설정할 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{0}'','IsParameterValidationOn','on');&lt;/cmd&gt; &lt;txt&gt;Parameter Writer 블록 파라미터 ''IsParameterValidationOn''을 ''on''으로 설정하십시오. &lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
        
    </entry>
    <entry key="ParamWriterWritingToGWSVarUsedInUpperLevel">Unable to use variable ''{1}'' in block ''{2}'' because a Parameter Writer block writes to workspace variable ''{1}'' in the model referenced by Model block ''{0}''.</entry>
    <entry key="ParamWriterWritingToGWSVarUsedByVariantInUpperLevel">Parameter Writer 블록이 Model 블록 ''{0}''에서 참조하는 모델의 작업 공간 변수 ''{1}''에 쓰고 Model 블록이 이 파라미터를 포함하는 Variant 조건을 최상위 모델에 전파하고 있기 때문에, 블록 ''{2}''에서 변수 ''{1}''을(를) 사용할 수 없습니다.</entry>
    <entry key="ParamWriterWritingToGWSVarUsedInXILModelBlock">기본 작업 공간 변수에 쓰기 작업을 수행하는 Parameter Writer 블록이 Model 블록 ''{0}''에서 참조하는 모델과 현재 모델에 모두 사용되기 때문에, Model 블록 ''{0}''의 시뮬레이션 모드를 ''SIL(Software-in-the-Loop)'' 또는 ''PIL(Processor-in-the-Loop)''로 설정할 수 없습니다.</entry>
    <entry key="ParamWriterWritingToGWSVarNonWritableInModelBlock">기본 작업 공간 변수 ''{1}''이(가) 시뮬레이션 중에 Model 블록 ''{0}''에서 참조되는 모델의 Parameter Writer에 의해 변경되도록 설정되지 않았기 때문에 이 변수에 쓸 수 없습니다. 예를 들어, 이 변수는 상수 샘플 시간을 갖는 블록에서 사용하거나 블록의 조정 불가형 파라미터에 의해 사용됩니다.</entry>
    <entry key="ParamWriterWritingToWSVarUsedOutsideParentSS">변수 ''{1}''이(가) 서브시스템 ''{3}'' 외부에 있는 블록 ''{2}''에서 사용되므로, Parameter Writer 블록 ''{0}''을(를) 사용하여 작업 공간 변수 ''{1}''에 쓸 수 없습니다.</entry>
    <entry key="ParamWriterWritingToVirtualMaskedSubsys">
      
               Parameter Writer 블록 ''{2}''은(는) 마스크 처리된 서브시스템 ''{1}''의 파라미터 ''{0}''을(를) 쓸 수 없습니다. 서브시스템이 가상이기 때문입니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{1}'','TreatAsAtomicUnit','on');&lt;/cmd&gt; &lt;txt&gt;서브시스템 파라미터 ''아토믹 단위로 처리''를 ''on''으로 설정하십시오. &lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
      
    </entry>
    <entry key="ParamWriterWritingToMaskParamNonExisting">Parameter Writer 블록 ''{2}''은(는) 마스크 처리된 서브시스템 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 파라미터가 존재하지 않거나 어떠한 내부 블록에서도 사용되고 있지 않기 때문입니다.</entry>
    <entry key="ParamWriterWritingToMaskParamUsedWithinIRT">Parameter Writer 블록 ''{2}''은(는) 마스크 처리된 서브시스템 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 파라미터가 마스크 처리된 서브시스템의 Initialize Function, Reinitialize Function, Reset Function 또는 Terminate Function 블록 내에서 참조되고 있기 때문입니다. Parameter Writer 블록을 사용하여 이러한 파라미터에 쓰는 것은 지원되지 않습니다.</entry>
    <entry key="ParamWriterWritingToMaskParamUsedAsInitialValue">Parameter Writer 블록 ''{2}''은(는) 마스크 처리된 서브시스템 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 파라미터가 마스크 처리된 서브시스템 내에서 블록의 초기 조건으로 사용되고 있기 때문입니다. Parameter Writer 블록을 사용하여 초기 조건으로 사용된 파라미터에 쓰는 것은 지원되지 않습니다.</entry>
    <entry key="ParamWriterWritingToMaskParamUsedAsNonTunableParam">Parameter Writer 블록 ''{2}''을(를) 사용하여 마스크 처리된 서브시스템 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 파라미터는 Parameter Writer 블록에서 지원하지 않는 마스크 처리된 서브시스템의 블록 파라미터가 사용하기 때문입니다.</entry>
    <entry key="ParamWriterWritingToMaskParamAssociatedWithVariantCond">Parameter Writer 블록 ''{2}''은(는) 마스크 처리된 서브시스템 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 파라미터가 Variant 조건과 연결되어 있기 때문입니다. Parameter Writer 블록을 사용하여 Variant 조건에 연결된 파라미터에 쓰는 것은 지원되지 않습니다.</entry>
    <entry key="ParamWriterWritingToMaskParamUsedByNonBlock">Parameter Writer 블록 ''{2}''은(는) 마스크 처리된 서브시스템 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 파라미터가 Simulink 블록에서 사용되고 있지 않기 때문입니다. Parameter Writer 블록을 사용하여 이러한 파라미터에 쓰는 것은 지원되지 않습니다.</entry>
    <entry key="ParamWriterWritingToMaskParamUsedInExpression">Parameter Writer 블록 ''{2}''은(는) 마스크 처리된 서브시스템 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 파라미터가 블록 ''{4}''의 표현식 ''{3}''에 사용되고 있기 때문입니다. Parameter Writer 블록을 사용하여 표현식에 사용된 마스크 파라미터에 쓰는 것은 지원되지 않습니다.</entry>
    <entry key="ParamWriterWritingToMaskParamWithConstTs">Parameter Writer 블록 ''{2}''은(는) 마스크 처리된 서브시스템 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 파라미터가 서브시스템 내에서 상수 샘플 시간을 갖는 블록에서 사용되고 있기 때문입니다. Initialize Function, Reset Function 및 Terminate Function 외부에 있는 Parameter Writer 블록을 사용하여 그러한 파라미터에 쓰는 것은 지원되지 않습니다.</entry>
    <entry key="ParamWriterWritingToDisabledMaskParam">Parameter Writer 블록 ''{2}''을(를) 사용하여 마스크 처리된 서브시스템 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 파라미터는 활성화되어 있지 않기 때문입니다.</entry>
    <entry key="ParamWriterToMaskInitInSimOn">Parameter Writer 블록 ''{1}''을(를) 사용하여 마스크 처리된 블록 ''{0}''에 쓸 수 없습니다. 쓰려는 파라미터가 초기화 코드를 갖는 마스크 처리된 블록에 의해 사용되고 구성 파라미터 ''SkipMaskInitInSimulation''이 ''off''로 설정되어 있기 때문입니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="SetSkipMaskInitInSimulation1" retvalue="false"&gt; &lt;cmd&gt;set_param(''{2}'', ''SkipMaskInitInSimulation'', ''on'')&lt;/cmd&gt; &lt;txt&gt;시뮬레이션 중에 마스크 초기화를 건너뛰십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="ParamWriterToMaskInitInSimOnThroughWSVar">Parameter Writer 블록 ''{1}''을(를) 사용하여 작업 공간 변수 ''{2}''에 쓸 수 없습니다. 작업 공간 변수가 초기화 코드를 갖는 마스크 처리된 블록에 의해 사용되고 구성 파라미터 ''SkipMaskInitInSimulation''이 ''off''로 설정되어 있기 때문입니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="SetSkipMaskInitInSimulation2" retvalue="false"&gt; &lt;cmd&gt;set_param(''{0}'', ''SkipMaskInitInSimulation'', ''on'')&lt;/cmd&gt; &lt;txt&gt;시뮬레이션 중에 마스크 초기화를 건너뛰십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="RunFirstLastDateTimeBlk">Block ''{0}'' does not support an ''Execution Order'' value of 'First' or 'Last' because block ''{0}'' is a DateTime Clock or DateTime Clock Reader block.</entry>
    <entry key="RunFirstLastDSMBlk">Block ''{0}'' does not support an ''Execution Order'' value of 'First' or 'Last' because block ''{0}'' is a Data Store Memory block.</entry>
    <entry key="RunFirstLastBlockWithFcnCallOutput">블록 ''{0}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;는 함수 호출 신호를 지원하지 않습니다. 블록의 ''실행 순서'' 값이 'First' 또는 'Last'으로 설정되었기 때문입니다.</entry>
    <entry key="RunFirstLastBlockWithFcnCallInput">블록 ''{0}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{0}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;는 함수 호출 신호를 지원하지 않습니다. 블록의 ''실행 순서'' 값이 'First' 또는 'Last'으로 설정되었기 때문입니다.</entry>
    <entry key="RunFirstLastVirtualBlock">블록 ''{0}''이(가) 가상 블록이기 때문에 블록 ''{0}''은(는) ''실행 순서'' 값으로 '첫 번째' 또는 '마지막'을 지원하지 않습니다.</entry>
    <entry key="RunFirstLastIRTSubsystemBlock">Block ''{0}'' does not support an ''Execution Order'' value of 'First' or 'Last' because block ''{0}'' is an Initialize Function, Reset Function, Reinitialize Function, or Terminate Function block.</entry>
    <entry key="RunFirstLastActionBlock">Block ''{0}'' does not support ''Execution Order'' value of 'First' or 'Last' because block ''{0}'' is an If or Switch Case block.</entry>
    <entry key="RunFirstLastInportOutportBlk">Block ''{0}'' with ''Execution Order'' value set to 'First' or 'Last' is not supported because block ''{0}'' is an Inport or Outport block.</entry>
    <entry key="RunLastBlockNotConnectedToOutport">블록 ''{0}''을(를) ''실행 순서''가 'Last'로 설정된 블록 ''{2}''의 &lt;sldiag objui="outport" objparam="{1, number, integer}" objname="{0}"&gt;{1, number, integer}번 출력 포트&lt;/sldiag&gt;에 연결할 수 없습니다. ''실행 순서''가 'Last'로 설정된 블록의 출력 신호를 연결하려면 Outport 블록을 사용하십시오.</entry>
    <entry key="RunFirstBlockNotConnectedToInport">블록 ''{0}''을(를) ''실행 순서''가 'First'로 설정된 블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{1, number, integer}" objname="{0}"&gt;{1, number, integer}번 입력 포트&lt;/sldiag&gt;에 연결할 수 없습니다. ''실행 순서''가 'First'로 설정된 블록에 입력 신호를 연결하려면 Inport 블록을 사용하십시오.</entry>
    <entry key="RunFirstLastBlockCannotBeHardwareSubsystem">Subsystem 블록 ''{0}''은(는) 옵션이 '동기식'으로 설정된 State Control 블록을 포함하기 때문에 ''실행 순서'' 값으로 'First' 또는 'Last'을 지원하지 않습니다.</entry>
    <entry key="RunFirstLastBlockCannotBeSSHavingControlPorts">Subsystem 블록 ''{0}''은(는) Enable 블록 또는 Trigger 블록과 같은 블록에 대응하는 제어 포트를 갖기 때문에 ''실행 순서'' 값으로 'First' 또는 'Last'을 지원하지 않습니다.</entry>
    <entry key="RunFirstLastBlockInMultiTaskingSystem">'실행 순서'가 'First' 또는 'Last'으로 설정된 블록 ''{0}''은(는) 싱글태스크에서 실행되는 시스템에 사용되어야 합니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param_action(''{1}'', 'Solver', 'FixedStepDiscrete');set_param_action(''{1}'', ''SolverMode'', ''SingleTasking'');&lt;/cmd&gt; &lt;txt&gt;싱글태스킹 모드에서 실행되도록 모델 ''{1}''을(를) 구성해 보십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="RunFirstLastBlockInVirtualSystem"> Block ''{0}'' with 'Execution Order' value set to 'First' or 'Last' is not supported because block ''{0}'' is placed inside a Virtual Subsystem block ''{1}''.
    &lt;actions exclusiveFixIts="yes"&gt;
        &lt;action type="fixit"&gt;
            &lt;cmd&gt;set_param_action(''{1}'', 'TreatAsAtomicUnit', 'on');&lt;/cmd&gt;
            &lt;txt&gt;Consider configuring its parent ''{1}'' to an Atomic subsystem.&lt;/txt&gt;
        &lt;/action&gt;
      &lt;/actions&gt;
    </entry>
    <entry key="RunFirstLastBlockInVariantSystem">'실행 순서' 값이 '첫 번째' 또는 '마지막'으로 설정된 블록 ''{0}''은(는) 지원되지 않습니다. 블록 ''{0}''이(가) Variant Subsystem 블록 ''{1}'' 내에 배치되어 있기 때문입니다.</entry>
    <entry key="DupRunFirstLastBlock">블록 ''{0}'' 및 블록 ''{1}''의 '실행 순서' 값을 '첫 번째' 또는 '마지막'로 설정할 수 없습니다. 두 블록 모두 동일한 계층 수준에 있기 때문입니다.</entry>
    <entry key="RunFirstLastBlockWithVariantCondition">블록 ''{0}''을(를) Variant 조건으로 제어할 수 없습니다. 블록 ''{0}''의 '실행 순서' 값이 'First' 또는 'Last'으로 설정되어 있기 때문입니다. 블록 ''{0}''의 '실행 순서' 값을 'Based on Priority'로 설정하거나, Variant 조건 ''{1}''을(를) 사용하여 블록 ''{0}''을(를) 제어하지 마십시오.</entry>
    <entry key="RunFirstLastBlockInContinuousTimeSystem">연속 샘플 시간을 포함하는 시스템 내에서는 '실행 순서' 값이 'First' 또는 'Last'으로 설정된 블록 ''{0}''이(가) 지원되지 않습니다.</entry>
    <entry key="RunFirstLastBlockInConstantRate">상수 샘플 시간만 갖기 때문에 '실행 순서' 값이 'First' 또는 'Last'로 설정된 블록 ''{0}''은(는) 지원되지 않습니다.</entry>
    <entry key="RunFirstLastBlockWithCState">'실행 순서' 값이 '첫 번째' 또는 '마지막'으로 설정된 블록 ''{0}''은(는) 지원되지 않습니다. 블록 ''{0}''에 연속 상태가 포함되어 있기 때문입니다.</entry>
    <entry key="RunFirstLastBlockMinAlgLoop1">Subsystem 블록 ''{0}''에서 파라미터 '인위적 대수 루프 발생 최소화'에 대한 설정이 유효하지 않습니다. '실행 순서' 값이 'First' 또는 'Last'로 설정된 블록 ''{1}''이(가) 서브시스템의 서브시스템 계층 구조 내부에 있기 때문에 이 설정은 지원되지 않습니다. '인위적 대수 루프 발생 최소화' 파라미터를 '끄기'로 설정하십시오. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param_action(''{0}'', 'MinAlgLoopOccurrences', 'off');&lt;/cmd&gt; &lt;txt&gt;''{0}''에 대해 옵션 ''인위적 대수 루프 발생 최소화''의 선택을 해제해 보십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="RunFirstLastBlockMinAlgLoop2">Subsystem 블록 ''{0}''에서 파라미터 '인위적 대수 루프 발생 최소화'에 대한 설정이 유효하지 않습니다. Subsystem 블록 ''{0}''은(는) 블록 ''{2}''을(를) 포함하는 모델을 참조하는 Model 블록 ''{1}''을(를) 포함하기 때문에 이 설정은 지원되지 않습니다. 블록 ''{2}''은(는) '실행 순서' 값이 'First' 또는 'Last'으로 설정된 블록이거나 서브시스템 또는 모델 참조 계층 구조 하위의 블록을 포함하는 모델을 참조하는 다른 Model 블록입니다. '인위적 대수 루프 발생 최소화' 파라미터를 '끄기'로 설정하십시오. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param_action(''{0}'', 'MinAlgLoopOccurrences', 'off');&lt;/cmd&gt; &lt;txt&gt;''{0}''에 대해 옵션 ''인위적 대수 루프 발생 최소화''의 선택을 해제해 보십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="RunFirstLastBlockMdlRefMinAlgLoop1">모델 ''{0}''에서 모델 구성 파라미터 &lt;sldiag objui="configset" objparam="ModelReferenceMinAlgLoopOccurrences"&gt;'인위적 대수 루프 발생 최소화'&lt;/sldiag&gt;에 대한 설정이 유효하지 않습니다. 블록 ''{1}''의 '실행 순서' 값이 '첫 번째' 또는 '마지막'으로 설정되었기 때문에 이 설정은 지원되지 않습니다. &lt;sldiag objui="configset" objparam="ModelReferenceMinAlgLoopOccurrences"&gt;'인위적 대수 루프 발생 최소화'&lt;/sldiag&gt; 파라미터를 '끄기'로 설정하십시오. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param_action(''{0}'', 'ModelReferenceMinAlgLoopOccurrences', 'off');&lt;/cmd&gt; &lt;txt&gt;''{0}''에 대해 구성 파라미터 &lt;sldiag objui="configset" objparam="ModelReferenceMinAlgLoopOccurrences"&gt;''인위적 대수 루프 발생 최소화''&lt;/sldiag&gt;의 선택을 해제해 보십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="RunFirstLastBlockMdlRefMinAlgLoop2">모델 ''{0}''에서 구성 파라미터 &lt;sldiag objui="configset" objparam="ModelReferenceMinAlgLoopOccurrences"&gt;'인위적 대수 루프 발생 최소화'&lt;/sldiag&gt;에 대한 설정이 유효하지 않습니다. 모델 ''{0}''은(는) '실행 순서' 값이 '첫 번째' 또는 '마지막'으로 설정된 블록 ''{2}''을(를) 참조하는 Model 블록 ''{1}''을(를) 포함하기 때문에 이 설정은 지원되지 않습니다. &lt;sldiag objui="configset" objparam="ModelReferenceMinAlgLoopOccurrences"&gt;'인위적 대수 루프 발생 최소화'&lt;/sldiag&gt; 파라미터를 '끄기'로 설정하십시오. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param_action(''{0}'', 'ModelReferenceMinAlgLoopOccurrences', 'off');&lt;/cmd&gt; &lt;txt&gt;''{0}''에 대해 구성 파라미터 &lt;sldiag objui="configset" objparam="ModelReferenceMinAlgLoopOccurrences"&gt;''인위적 대수 루프 발생 최소화''&lt;/sldiag&gt;의 선택을 해제해 보십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
    </entry>
    <entry key="RunFirstLastBlockInAlgebraicLoop1">Subsystem 블록 ''{0}''을(를) 포함하는 대수 루프의 해를 구할 수 없습니다. Subsystem 블록 ''{0}'' 내부에 있는 블록 ''{1}''의 '실행 순서' 값이 'First' 또는 'Last'으로 설정되어 있기 때문입니다.
    </entry>
    <entry key="RunFirstLastBlockInAlgebraicLoop2">Subsystem 블록 ''{0}''을(를) 포함하는 대수 루프의 해를 구할 수 없습니다. Subsystem 블록 ''{0}''이(가) 블록 ''{2}''을(를) 포함하는 모델을 참조하는 Model 블록 ''{1}''을(를) 포함하기 때문입니다. 블록 ''{2}''은(는) '실행 순서' 값이 '첫 번째' 또는 '마지막'으로 설정된 블록이거나 서브시스템 또는 모델 참조 계층 구조에서 더 하위의 블록을 포함하는 모델을 참조하는 또 다른 Model 블록입니다.
    </entry>
    <entry key="RunFirstLastBlockInAlgebraicLoop3">Unable to solve algebraic loop containing Model block ''{0}'' because Model block ''{0}'' refers to a model that contains block ''{1}'' which is either a block with 'Execution Order' value set to 'First' or 'Last' or another Model block that refers to a model containing such subsystem further down in the subsystem or model reference hierarchy.
    </entry>
    <entry key="FcnCallCompBlockWithFcnCallOutput">블록 ''{0}''은(는) 소프트웨어 아키텍처 컴포넌트이거나 소프트웨어 아키텍처 컴포넌트 내에 위치하기 때문에, 함수 호출 신호 출력을 지원하지 않습니다.</entry>
    <entry key="SWArchCompBlockWithSelfLoop">소프트웨어 아키텍처 컴포넌트 ''{0}''은(는) 자기 루프를 지원하지 않습니다.</entry>
    <entry key="SWArchCompBlockWithSelfLoop2">블록 ''{0}''이(가) 소프트웨어 아키텍처 컴포넌트 내에 있기 때문에, 자기 루프는 이 블록에 대해 지원되지 않습니다.</entry>
    <entry key="SWArchComposationWithFcnSplit">블록 ''{0}''은(는) Function-Call Split 블록이므로 소프트웨어 아키텍처 함수 복합 모델에서 지원되지 않습니다.</entry>
    <entry key="SWArchComposationWithFcnLatch">블록 ''{0}''은(는) Function-Call Feedback Latch 블록이므로, 소프트웨어 아키텍처 함수 복합 모델에서 지원되지 않습니다.</entry>
    <entry key="ParamWriterWritingToBlockParamInitWithWSVariable">Parameter Writer 블록 ''{2}''은(는) 블록 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 블록이 대화 상자의 마스크 파라미터 또는 작업 공간 변수로 초기화되기 때문입니다. Parameter Writer 블록을 사용하여 이러한 파라미터에 쓰는 것은 지원되지 않습니다.</entry>
    <entry key="ParamWriterWritingToBlockParamWithConstTs">Parameter Writer 블록 ''{2}''은(는) 블록 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 블록이 상수 샘플 시간을 갖기 때문입니다. Initialize Function, Reset Function 및 Terminate Function 외부에 있는 Parameter Writer 블록을 사용하여 그러한 블록 파라미터에 쓰는 것은 지원되지 않습니다.</entry>
    <entry key="ParamAccessorCannotWriteToInlinedBlockParam">
      
               모델 ''{0}''에 대한 코드를 생성할 수 없습니다. Parameter Writer 블록이 모델에 사용되고 모델의 파라미터 동작이 "인라인"으로 설정되어 있기 때문입니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'','DefaultParameterBehavior','Tunable');&lt;/cmd&gt; &lt;txt&gt;파라미터 ''디폴트 파라미터 동작''을 ''조정 가능형''으로 설정하십시오. &lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
      
    </entry>
    <entry key="ParameterReaderOrWriterInvalidParameterOwner">Parameter Writer 블록 ''{1}''에 대해 블록 ''{0}''을(를) 파라미터 소유자 블록으로 설정할 수 없습니다.</entry>
    <entry key="ParamWriterWritingToBlockParamNotTunable">Parameter Writer 블록 ''{2}''을(를) 사용하여 블록 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 파라미터는 런타임 중에 조정이 불가능하기 때문입니다.</entry>
    <entry key="ParamWriterWritingToBlockParamNoRTP">Parameter Writer 블록 ''{2}''을(를) 사용하여 블록 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 파라미터에는 대응하는 런타임 파라미터가 없기 때문입니다.</entry>
    <entry key="ParamWriterWritingToBlockParamInvalidTransform">Parameter Writer 블록 ''{2}''은(는) 블록 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 해당 대화 상자 파라미터와 런타임 파라미터가 일대일로 매핑되지 않기 때문입니다.</entry>
    <entry key="ParamWriterWritingToBlockUnderDiffMask">Parameter Writer 블록 ''{2}''을(를) 사용하여 블록 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 두 블록이 마스크 처리된 동일한 직속 부모 서브시스템을 갖고 있지 않거나 블록 ''{1}''의 마스크에 이름이 ''{0}''인 파라미터가 없기 때문입니다.</entry>
    <entry key="ParamWriterAndOwnerInDiffCharts"> Parameter Writer 블록 ''{0}''은(는) Parameter Owner 블록 ''{1}''과(와) 동일한 Stateflow 차트에 있어야 합니다.</entry>
    <entry key="ParamWriterParameterNameNotSet">No parameter has been selected. A parameter of owner block ''{0}'' must be selected.</entry>
    <entry key="ParamWriterParameterNameNotSet2">Parameter Writer ''{0}''에 대해 파라미터가 선택되지 않았습니다. 선택된 소유자 블록의 파라미터를 선택해야 합니다.</entry>
    <entry key="ParamWriterParameterNameNotValid">Parameter Writer 블록 ''{2}''은(는) 블록 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 파라미터는 더 이상 유효하지 않습니다. 최신 블록 구성으로 인해 파라미터 ''{0}''이(가) 제거되었거나 이름이 변경되었을 수 있습니다.</entry>
    <entry key="ParamWriterWritingToBlockParamArg">Parameter Writer 블록 ''{2}''을(를) 사용하여 블록 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 파라미터는 인수로 확인되기 때문입니다.</entry>
    <entry key="ParamWriterBlockParameterMultiInstances">
        Model 블록 ''{1}'' 및 ''{2}''에 의해 직접적으로 또는 간접적으로 참조되는 모델 ''{0}'' 또는 해당 계층 구조 내의 모델에 블록, 마스크 또는 Model 블록 파라미터에 쓰는 Parameter Writer 블록이 있습니다. 다중 인스턴스화된 모델에서는 Parameter Writer 블록이 블록, 마스크 또는 Model 블록 파라미터에 쓸 수 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;Simulink.ModelReference.internal.ModelRefFixes(''MultiInstanceToFile'',''{0}'')&lt;/cmd&gt; &lt;txt&gt;구성 파라미터 ''최상위 모델당 허용되는 인스턴스의 총 개수''를 ''1개''로 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt;모델 ''{0}''이(가) 한 번만 참조되도록 모델 참조 계층 구조를 편집하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
      </entry>
    <entry key="ParamWriterWritingToSigGenBlock">Parameter Writer 블록 ''{2}''을(를) 사용하여 블록 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. 이 파라미터의 단위가 "rad/sec"로 설정되어 있기 때문입니다.</entry>
    <entry key="ParamWriterWritingToMultiWordParam">Parameter Writer 블록 ''{1}''에서 제공하는 값이 멀티워드 유형의 파라미터 ''{0}''(으)로 변환되기 때문에 시뮬레이션과 코드 생성을 수행할 수 없습니다.</entry>
    <entry key="ParamWriterWritingToLongLongParam">Parameter Writer 블록 ''{1}''에서 제공하는 값이 ''int64'' 데이터형의 파라미터 ''{0}''(으)로 변환되는데 이는 지원되는 비트 수를 초과하기 때문에 코드를 생성할 수 없습니다.
    
             &lt;actions&gt;
             &lt;action type="fixit" id="SetLongLongModeForParamWriter"&gt;
             &lt;cmd&gt;configset.internal.fixIt(''{2}'','ProdLongLongMode',''on'')&lt;/cmd&gt;
             &lt;txt&gt;&lt;sldiag objui="configset" objparam="ProdLongLongMode"&gt;C 컴파일러가 C long long 데이터형을 지원하도록 지정하십시오.&lt;/sldiag&gt;&lt;/txt&gt;
             &lt;/action&gt;
             &lt;/actions&gt;
    </entry>
    <entry key="ParamWriterWritingToBlockParamUpdatedInSim">Parameter Writer 블록이 블록 ''{1}''의 파라미터 ''{0}''에 쓰기 때문에 시뮬레이션 중에 이 파라미터의 값을 수동으로 변경할 수 없습니다.</entry>
    <entry key="ParamWriterWritingToBlockParamValidation">파라미터 소유자 블록 ''{1}''에 작성되는, ''{0}''의 Parameter Writer 블록은 동일한 파라미터 유효성 검사 설정을 가져야 합니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="SetValidationLocalOffForBlockParamWriters" retvalue="false"&gt; &lt;cmd&gt;Simulink.internal.setParamWriterValidationStatus(''{1}'',''off'')&lt;/cmd&gt; &lt;txt&gt;소유자 블록 ''{1}''에 작성되는 모든 Parameter Writer 블록에 대해 파라미터 유효성 검사를 비활성화하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit" id="SetValidationLocalOnForBlockParamWriters" retvalue="false"&gt; &lt;cmd&gt;Simulink.internal.setParamWriterValidationStatus(''{1}'',''on'')&lt;/cmd&gt; &lt;txt&gt;소유자 블록 ''{1}''에 작성되는 모든 Parameter Writer 블록에 대해 파라미터 유효성 검사를 활성화하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit" id="SetValidationGlobalOffForParamWriters1"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''ParamWriterValidationControl'',''DisableAll'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="ParamWriterValidationControl"&gt;모든 Parameter Writer 블록에 대해 파라미터 유효성 검사를 비활성화하십시오.&lt;/sldiag&gt;&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit" id="SetValidationGlobalOnForParamWriters1"&gt; &lt;cmd&gt;configset.internal.fixIt(''{0}'',''ParamWriterValidationControl'',''EnableAll'')&lt;/cmd&gt; &lt;txt&gt;&lt;sldiag objui="configset" objparam="ParamWriterValidationControl"&gt;모든 Parameter Writer 블록에 대해 파라미터 유효성 검사를 활성화하십시오.&lt;/sldiag&gt;&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
   </entry>
    <entry key="ParamWriterWritingToWSParamValidation">Parameter Writer blocks in ''{0}'' that write to workspace variables must have the same parameter validation settings.
    
             &lt;actions exclusiveFixIts="yes"&gt;
             &lt;action type="fixit" id="SetValidationLocalOffForWSParamWriters" retvalue="false"&gt; 
             &lt;cmd&gt;Simulink.internal.setParamWriterValidationStatus(''{0}'',''off'')&lt;/cmd&gt;
             &lt;txt&gt;Disable parameter validation for all Parameter Writer blocks that write to workspace variables.&lt;/txt&gt;
             &lt;/action&gt;
             &lt;action type="fixit" id="SetValidationLocalOnForWSParamWriters" retvalue="false"&gt; 
             &lt;cmd&gt;Simulink.internal.setParamWriterValidationStatus(''{0}'',''on'')&lt;/cmd&gt;
             &lt;txt&gt;Enable parameter validation for all Parameter Writer blocks that write to workspace variables.&lt;/txt&gt;
             &lt;/action&gt;
             &lt;action type="fixit" id="SetValidationGlobalOffForParamWriters2"&gt;
             &lt;cmd&gt;configset.internal.fixIt(''{0}'',''ParamWriterValidationControl'',''DisableAll'')&lt;/cmd&gt;
             &lt;txt&gt;&lt;sldiag objui="configset" objparam="ParamWriterValidationControl"&gt;Disable parameter validation for all Parameter Writer blocks.&lt;/sldiag&gt;&lt;/txt&gt;
             &lt;/action&gt;
             &lt;action type="fixit" id="SetValidationGlobalOnForParamWriters2"&gt;
             &lt;cmd&gt;configset.internal.fixIt(''{0}'',''ParamWriterValidationControl'',''EnableAll'')&lt;/cmd&gt;
             &lt;txt&gt;&lt;sldiag objui="configset" objparam="ParamWriterValidationControl"&gt;Enable parameter validation for all Parameter Writer blocks.&lt;/sldiag&gt;&lt;/txt&gt;
             &lt;/action&gt;
             &lt;/actions&gt;
   </entry>
    <entry key="ParamWriterToModelArgValidationOff1">
      Parameter Writer 블록 ''{1}''에 대해 파라미터 유효성 검사를 비활성할 수 없습니다. 이 블록이 Model 블록 ''{0}''에 작성되기 때문입니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="SetValidationLocalOnForMdlArgParamWriters1" retvalue="false"&gt; &lt;cmd&gt;Simulink.internal.setParamWriterValidationStatus(''{0}'',''on'')&lt;/cmd&gt; &lt;txt&gt;Model 블록 ''{1}''에 작성되는 모든 Parameter Writer 블록에 대해 파라미터 유효성 검사를 활성화하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;           
   </entry>
    <entry key="ParamWriterToModelArgValidationOff2">
      Parameter Writer 블록 ''{2}''에 대해 파라미터 유효성 검사를 비활성할 수 없습니다. 블록 ''{1}''의 마스크 파라미터 ''{0}''이(가) Model 블록에 사용되기 때문입니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="SetValidationLocalOnForMdlArgParamWriters2" retvalue="false"&gt; &lt;cmd&gt;Simulink.internal.setParamWriterValidationStatus(''{1}'',''on'')&lt;/cmd&gt; &lt;txt&gt;마스크 처리된 블록 ''{1}''에 작성되는 모든 Parameter Writer 블록에 대해 파라미터 유효성 검사를 활성화하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;  
   </entry>
    <entry key="ParamWriterToModelArgValidationOff3">
      Parameter Writer 블록 ''{1}''에 대해 파라미터 유효성 검사를 비활성할 수 없습니다. 작업 공간 변수 ''{0}''이(가) Model 블록에 사용되기 때문입니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="SetValidationLocalOnForMdlArgParamWriters3" retvalue="false"&gt; &lt;cmd&gt;Simulink.internal.setParamWriterValidationStatus(bdroot(''{1}''),''on'')&lt;/cmd&gt; &lt;txt&gt;작업 공간 변수에 쓰기 작업을 수행하는 모든 Parameter Writer 블록에 대해 파라미터 유효성 검사를 활성화하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;  
   </entry>
    <entry key="ParamAccessorBlocksInSameCompInfo">
      블록 ''{0}''과(와) ''{1}''을(를) 동일한 비가상 계층 구조에 둘 수 없습니다. 이 두 블록이 ''{2}''이(가) 소유한 동일한 파라미터에 액세스하기 때문입니다. 이 블록을 다음의 성격을 갖는 두 Function-Call Subsystem에 배치해 보십시오. (1) 함수 내보내기 모델에서 각기 다른 루트 수준 Inport 블록에 의해 구동되는 서브시스템, (2) 분기된 함수 호출 신호로 구동되고 Function-Call Split 블록에 의해 서로 다른 실행 순서가 지정된 서브시스템, 또는 (3) 공통 개시자, If 블록 또는 Switch Case 블록에 의해 제어되는 서브시스템.\n 또는 부모 서브시스템에 파라미터 소유자 블록 ''{2}''이(가) 있는 Initialize Function 블록 및 Terminate Function 블록에 블록 ''{0}''과(와) ''{1}''을(를) 배치해 보십시오.
    </entry>
    <entry key="ParamAccessorBlocksInSameCompInfo2">
      Blocks ''{0}'' and ''{1}'' cannot be placed in the same non-virtual hierarchy because they access the same workspace parameter ''{2}''. Consider placing them in two function-call subsystems (1) driven by different root-level Inport blocks inside an export function model (2) driven by a branched function-call signal and having different execution orders specified by Function-Call Split blocks, or (3) controlled by a common initiator, an If block, or a Switch Case block.\n Alternatively, consider placing blocks ''{0}'' and ''{1}'' in Initialize and Terminate Function blocks whose parent subsystem contains the parameter owner block ''{2}''.
    </entry>
    <entry key="ParamAccessorAndOwnerInSameCompInfo">
      블록 ''{0}''은(는) ''{1}''이(가) 소유한 파라미터에 액세스합니다. 따라서 이들을 동일한 비가상 계층 구조에 둘 수 없습니다. 이 블록을 다음의 성격을 갖는 두 Function-Call Subsystem에 배치해 보십시오. (1) 함수 내보내기 모델에서 각기 다른 루트 수준 Inport 블록에 의해 구동되는 서브시스템, (2) 분기된 함수 호출 신호로 구동되고 Function-Call Split 블록에 의해 서로 다른 실행 순서가 지정된 서브시스템, 또는 (3) 공통 개시자, If 블록 또는 Switch Case 블록에 의해 제어되는 서브시스템.\n 또는 부모 서브시스템에 파라미터 소유자 블록 ''{1}''이(가) 있는 Initialize Function 블록 또는 Terminate Function 블록에 블록 ''{0}''을(를) 배치해 보십시오.
    </entry>
    <entry key="ParamAccessorBlocksInSameTaskError">
      Param Writer 블록 ''{0}''과(와) ''{1}''이(가) ''{2}''이(가) 소유한 동일한 파라미터에 액세스하고 있습니다. 그리고 동일한 루트 수준 Inport 블록에 의해 구동되고 있거나, 함수 내보내기 모델 내의 동일한 Simulink Function에 있습니다. 결정적 상대 실행 순서를 보장하려면, (1) 분기된 함수 호출 신호로 구동되고 Function-Call Split 블록에 의해 서로 다른 실행 순서가 지정되었거나 (2) 공통 함수 호출 개시자, If 블록 또는 Switch Case 블록에 의해 제어되는 두 서브시스템에 이러한 블록을 배치해 보십시오. 또는 부모 서브시스템에 파라미터 소유자 블록 ''{2}''이(가) 포함된 Initialize Function 블록과 Terminate Function 블록에 블록 ''{0}''과(와) ''{1}''을(를) 배치해 보십시오.
    </entry>
    <entry key="ParamAccessorBlocksInSameTaskError2">
      Param Writer 블록 ''{0}''과(와) ''{1}''이(가) 동일한 작업 공간 파라미터 ''{2}''에 액세스하고 있습니다. 그리고 동일한 루트 수준 Inport 블록에 의해 구동되고 있거나, 함수 내보내기 모델 내의 동일한 Simulink Function에 있습니다. 결정적 상대 실행 순서를 보장하려면, (1) 분기된 함수 호출 신호로 구동되고 Function-Call Split 블록에 의해 서로 다른 실행 순서가 지정되었거나 (2) 공통 함수 호출 개시자, If 블록 또는 Switch Case 블록에 의해 제어되는 두 서브시스템에 이러한 블록을 배치해 보십시오. 또는 부모 서브시스템에 파라미터 소유자 블록 ''{2}''이(가) 포함된 Initialize Function 블록과 Terminate Function 블록에 블록 ''{0}''과(와) ''{1}''을(를) 배치해 보십시오.
    </entry>
    <entry key="ParamAccessorBlocksInNonExpFcnMdlSameTsError">
      Parameter Writer 블록 ''{0}'' 및 ''{1}''이(가) ''{2}''이(가) 소유한 동일한 파라미터에 액세스하고 동일한 샘플 시간을 갖습니다. 결정적 상대 실행 순서를 보장하려면, (1) 분기된 함수 호출 신호로 구동되고 Function-Call Split 블록에 의해 서로 다른 실행 순서가 지정되었거나 (2) 공통 함수 호출 개시자, If 블록 또는 Switch Case 블록에 의해 제어되는 두 서브시스템에 이러한 블록을 배치해 보십시오. 또는 부모 서브시스템에 파라미터 소유자 블록 ''{2}''이(가) 포함된 Initialize Function 블록과 Terminate Function 블록에 블록 ''{0}''과(와) ''{1}''을(를) 배치해 보십시오.
    </entry>
    <entry key="ParamAccessorBlocksInNonExpFcnMdlSameTsError2">
      Parameter Writer blocks ''{0}'' and ''{1}'' access the same workspace parameter ''{2}'', and they have the same sample time. To ensure deterministic relative execution order, consider placing them in two subsystems that are (1) driven by a branched function-call signal and have different execution orders specified by Function-Call Split blocks or (2) controlled by a common function-call initiator, an If block, or a Switch Case block. Alternatively, consider placing blocks ''{0}'' and ''{1}'' in Initialize and Terminate Function blocks whose parent subsystem contains the parameter owner block ''{2}''.
    </entry>
    <entry key="ParamAccessorAndOwnerInSameTaskError">
      블록 ''{0}''이(가) ''{1}''이(가) 소유한 파라미터에 액세스하고 있습니다. 그리고 두 블록은 동일한 루트 수준 Inport 블록에 의해 구동되고 있거나 함수 내보내기 모델 내의 동일한 Simulink Function에 있습니다. 결정적 상대 실행 순서를 보장하려면, (1) 분기된 함수 호출 신호로 구동되고 Function-Call Split 블록에 의해 서로 다른 실행 순서가 지정되었거나 (2) 공통 함수 호출 개시자, If 블록 또는 Switch Case 블록에 의해 제어되는 두 서브시스템에 이러한 블록을 배치해 보십시오. 또는 부모 서브시스템에 파라미터 소유자 블록 ''{1}''이(가) 포함된 Initialize Function 블록 또는 Terminate Function 블록에 블록 ''{0}''을(를) 배치해 보십시오.
    </entry>
    <entry key="ParamAccessorAndOwnerInNonExpFcnMdlSameTsError">
      블록 ''{0}''은(는) 동일한 샘플 시간을 갖는, ''{1}''이(가) 소유한 파라미터에 액세스합니다. 결정적 상대 실행 순서를 보장하려면, (1) 분기된 함수 호출 신호로 구동되고 Function-Call Split 블록에 의해 서로 다른 실행 순서가 지정되었거나 (2) 공통 함수 호출 개시자, If 블록 또는 Switch Case 블록에 의해 제어되는 두 서브시스템에 이러한 블록을 배치해 보십시오. 또는 부모 서브시스템에 파라미터 소유자 블록 ''{1}''이(가) 포함된 Initialize Function 블록 또는 Terminate Function 블록에 블록 ''{0}''을(를) 배치해 보십시오.
    </entry>
    <entry key="ParamWriteNotDrvByFcnCallRootInport">모델이 함수 내보내기 모델이므로, Parameter Writer 블록 ''{0}''은(는) 함수 호출 신호를 출력하는 루트 수준 Inport 블록에 의해 구동되는 함수 호출 컨텍스트 내에 배치하거나 Initialize Function 블록 또는 Terminate Function 블록 내에 배치해야 합니다.</entry>
    <entry key="ParamOwnerNotInExpFcnMdlRootFcnCall">모델이 함수 내보내기 모델이므로, Parameter Writer 블록 ''{1}''이(가) 액세스할 수 있도록 구성된 블록 ''{0}''은(는) 루트 수준 함수 호출 Inport 블록에 의해 구동되는 Function-Call Subsystem 내에 있어야 합니다.</entry>
    <entry key="ParamOwnerNotSingleRate">블록 ''{0}''이(가) 여러 태스크와 연결되어 있으므로, Parameter Writer 블록 ''{1}''을(를) 사용하여 블록 ''{0}''의 파라미터를 업데이트할 수 없습니다.</entry>
    <entry key="ParamOwnerNotSingleRate2">Parameter Writer 블록 ''{2}''은(는) Model 블록 ''{1}''의 파라미터 ''{0}''에 쓸 수 없습니다. Model 블록이 함수 내보내기 모델이 아니면서 여러 태스크를 갖거나, Model 블록이 함수 내보내기 모델이면서 파라미터가 Model 블록 내에 있는 여러 포트 그룹에 의해 참조되기 때문입니다.</entry>
    <entry key="ParamOwnerBlkCannotBeInsideForEachSS">블록 ''{0}''은(는) 자신의 파라미터에 Parameter Writer 블록이 액세스할 수 있도록 설정되어 있습니다. 이 블록은 For Each Subsystem 내에 배치할 수 없습니다.</entry>
    <entry key="ParamAccessorAndOwnerInDiffTasks">
            Parameter Writer 블록 ''{0}''이(가) 진단 &lt;sldiag objui="configset" objparam="MultiTaskRateTransMsg"&gt;''멀티태스크 데이터 전송''&lt;/sldiag&gt;이 '오류'로 설정된 다른 태스크에서 ''{1}''이(가) 소유한 파라미터에 쓰고 있습니다. 파라미터를 ''오류''에서 ''경고''로 변경하거나 블록을 다음의 성격을 갖는 별도의 Function-Call Subsystem에 배치해 보십시오. (1) 함수 내보내기 모델에서 각기 다른 루트 수준 Inport 블록에 의해 구동되는 서브시스템, (2) 분기된 함수 호출 신호로 구동되고 Function-Call Split 블록에 의해 서로 다른 실행 순서가 지정된 서브시스템, 또는 (3) 공통 개시자, If 블록 또는 Switch Case 블록에 의해 제어되는 서브시스템.\n 또는 부모 서브시스템에 파라미터 소유자 블록 ''{1}''이(가) 있는 Initialize Function 블록 또는 Terminate Function 블록에 블록 ''{0}''을(를) 배치해 보십시오.
    </entry>
    <entry key="ParamAccessorAndOwnerInDiffTasksWarning">
      Parameter Writer 블록 ''{0}''은(는) 다른 태스크에서 ''{1}''이(가) 소유한 파라미터에 쓸 수 없습니다. 이 블록을 다음의 성격을 갖는 두 Function-Call Subsystem에 배치해 보십시오. (1) 함수 내보내기 모델에서 각기 다른 루트 수준 Inport 블록에 의해 구동되는 서브시스템, (2) 분기된 함수 호출 신호로 구동되고 Function-Call Split 블록에 의해 서로 다른 실행 순서가 지정된 서브시스템, 또는 (3) 공통 개시자, If 블록 또는 Switch Case 블록에 의해 제어되는 서브시스템.\n 또는 부모 서브시스템에 파라미터 소유자 블록 ''{1}''이(가) 있는 Initialize Function 블록 또는 Terminate Function 블록에 블록 ''{0}''을(를) 배치해 보십시오.
    </entry>
    <entry key="ParamAccessorAndOwnerCallerInSameSimulinkFunctionChain">
      Function Caller 블록 ''{0}''과(와) ''{1}''이(가) 동일한 태스크에 있습니다. 이 두 블록은 ''{3}''이(가) 포함된 Simulink Function ''{2}''과(와) ''{5}''이(가) 포함된 Simulink Function ''{4}''을(를) 각각 호출합니다.
    </entry>
    <entry key="ParamWriteHasConstantTs">Parameter Writer 블록 ''{0}''은(는) 상수 샘플 시간을 가질 수 없고 상수 샘플 시간을 갖는 서브시스템 내에 배치할 수 없습니다.</entry>
    <entry key="ParamOwnerHasConstantTs">''{0}''은(는) 자신의 파라미터에 Initialize Function, Reinitialize Function, Reset Function 또는 Terminate Function 블록 밖에 있는 Parameter Writer 블록이 액세스할 수 있도록 설정되어 있습니다. 따라서 이 블록은 상수 샘플 시간을 갖거나 상수 샘플 시간을 갖는 서브시스템 내에 배치할 수 없습니다.</entry>
    <entry key="StateSpaceXformErr">Error from ''{0}'' in ''{1}''.</entry>
    <entry key="StrictMsgIsSetToNonStrict">The ''Mux blocks used to create bus signals'' option in the block diagram ''{0}'' is set to ''warning'' or ''none''. Before getting the compiled bus structure, you should set this option to ''error'' in the Connectivity pane of the Diagnostics page in the Configuration Parameters Dialog. It is assumed all Mux blocks in the model are used to concatenate signals. That is, no Mux block is used to create a bus signal. See Simulink documentation for more information about StrictBusMsg.</entry>
    <entry key="StrictMsgIsSetToNonStrictBusType">블록 다이어그램 ''{0}''에서 ''버스 신호를 생성하는 데 사용되는 Mux 블록'' 옵션이 ''경고'' 또는 ''안 함''으로 설정되었습니다. 컴파일된 버스 데이터형을 가져오려면 먼저 [구성 파라미터] 대화 상자에서 [진단] 페이지의 [연결성] 창에 있는 이 옵션을 ''오류''로 설정해야 합니다.</entry>
    <entry key="StrictMsgIsSetToNonStrictSigHier">The ''Mux blocks used to create bus signals'' option in the block diagram ''{0}'' is set to ''warning'' or ''none''. Before getting the signal hierarchy, you should set this option to ''error'' in the Connectivity pane of the Diagnostics page in the Configuration Parameters Dialog.</entry>
    <entry key="StrictMsgIsSetToNonStrictBusDesignMinMax">블록 다이어그램 ''{0}''에서 ''버스 신호를 생성하는 데 사용되는 Mux 블록'' 옵션이 ''경고'' 또는 ''안 함''으로 설정되었습니다. 버스 신호를 갖는 포트에서 컴파일된 설계 최솟값 또는 설계 최댓값을 가져오려면 먼저 [구성 파라미터] 대화 상자에서 [진단] 페이지의 [연결성] 창에 있는 이 옵션을 ''오류''로 설정해야 합니다.</entry>
    <entry key="SubscriptOutOfBounds">인덱스가 블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{0}" objname="{2}"&gt;입력 포트 {0}&lt;/sldiag&gt;{1,number,integer}번의 테이블 차원을 초과합니다.</entry>
    <entry key="EnforceSubscriptOutOfBounds">인덱스가 블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{0}" objname="{2}"&gt;입력 포트 {0}&lt;/sldiag&gt;{1,number,integer}번의 테이블 차원을 초과합니다. '인덱스가 범위 내에 있다고 가정' 파라미터를 선택 해제하거나 인덱스를 테이블 차원의 범위 내에 있도록 제한하십시오.</entry>
    <entry key="InterpSubscriptOutOfBoundsIndexFromBus">인덱스가 블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{0}" objname="{2}"&gt;입력 포트 {0}&lt;/sldiag&gt;{1,number,integer}번으로 전파된 bus 객체의 첫 번째 신호의 테이블 차원을 초과합니다.</entry>
    <entry key="EnforceInterpSubscriptOutOfBoundsIndexFromBus">인덱스가 블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{0}" objname="{2}"&gt;입력 포트 {0}&lt;/sldiag&gt;{1,number,integer}번으로 전파된 bus 객체의 첫 번째 신호의 테이블 차원을 초과합니다. '인덱스가 범위 내에 있다고 가정' 파라미터를 선택 해제하거나 인덱스를 테이블 차원의 범위 내에 있도록 제한하십시오.</entry>
    <entry key="SubsysDisableFcnCallError">시간 {2}에서 함수 호출 {1,number,integer}번 입력 포트 요소에 대해 함수 호출 비활성화를 진행하는 중 서브시스템 ''{0}''에 오류가 발생함</entry>
    <entry key="SubsysEnableFcnCallError">시간 {2}에서 함수 호출 {1,number,integer}번 입력 포트 요소에 대해 함수 호출 활성화를 진행하는 중 서브시스템 ''{0}''에 오류가 발생함</entry>
    <entry key="SubsysGndedFCSSCodeGenError">Simulink Coder does not guarantee proper execution of models containing unconnected function-call inputs. Try using the Simulink Function-Call Generator block to drive the function-call input port of block ''{0}''.</entry>
    <entry key="SubsysErrFcnMsg">''{0}''에서 오류가 발생했습니다. {1}</entry>
    <entry key="SubsysErrFcnMsgInvCB">서브시스템 ''{1}''의 오류 콜백 함수 ''{0}''을(를) 호출하는 중 오류가 발생했습니다. 콜백 함수는 블록 핸들과 오류 ID를 입력 인수로 취하고, 서브시스템 내에서 생성된 오류를 대체하는 문자형 벡터를 반환해야 합니다. 오류 콜백 함수가 호출되었을 때 다음 오류가 생성됨: {2}</entry>
    <entry key="SubsysErrFcnMsgInvCBRetVal">Error occurred while calling the error callback function ''{0}'' of subsystem ''{1}''. The function incorrectly returns a non-character vector value. The callback function should take a block handle and error ID as input arguments, and return a character vector that replaces the error produced within the subsystem</entry>
    <entry key="SubsysReadProtectErr">읽기 방지된 ''{0}'' 내에서 오류가 발생했습니다. 읽기 권한이 켜져 있지 않으면 이 오류를 표시할 수 없습니다.</entry>
    <entry key="SubsysRunFcnCallError">시간 {2}에서 함수 호출 {1,number,integer}번 입력 포트 요소에 대해 함수 호출을 실행하는 중 서브시스템 ''{0}''에 오류가 발생함</entry>
    <entry key="SubsysSetAsFcnNotSupported">The parameter ''Code generation function packaging'' of subsystem ''{0}'' is set to ''Function''. However, this subsystem is inside subsystem ''{1}'', which contains a For Each block (''{2}''). Simulink does not support this scenario. Consider changing the parameter ''Code generation function packaging'' of subsystem ''{3}'' to ''Inline'', ''Auto'' or ''Reusable function''.</entry>
    <entry key="DataflowForEachNotSupported">서브시스템 ''{1}''에 For Each 블록(''{2}'')이 포함되어 있으므로 ''{0}''의 실행 영역을 ''Dataflow''로 설정할 수 없습니다. 서브시스템 ''{0}''의 실행 영역을 변경하거나 (''{2}'')을(를) 제거하십시오.</entry>
    <entry key="SubsysSettingSetNotAllowed">서브시스템 ''{1}''이(가) 컴파일되고 있거나 시뮬레이션이 실행 중일 때에는 파라미터 ''{0}''을(를) 변경할 수 없음</entry>
    <entry key="SubsysWriteProtected">Modifying ''{0}'' is not supported because it is in a write-protected subsystem.</entry>
    <entry key="SumBlockOutputDataTypeIsBool"> Cannot set the output data type of ''{0}'' to ''Boolean''. One way to eliminate the error is to manually set the output data type of this block.</entry>
    <entry key="SwitchEnumTypeAndNonZeroCriteria">Cannot use criteria ''u2 ~= 0'' for ''{0}'' because the control input has an enumerated data type. Either change the criteria or use a Relational Operator block to do the comparison for the control input signal.</entry>
    <entry key="SwitchIgnoringThreshold">The control input of ''{0}'' is a boolean signal. Input 3 is passed to the output if control input is false (0), otherwise input 1 is passed to the output. The current threshold values are being ignored. To eliminate this warning, set the criteria and threshold to any of the following three combinations: u2 ~= 0, u2 &gt; Threshold with Threshold equal to 0, or u2 &gt;= Threshold with Threshold equal to 1.</entry>
    <entry key="SwitchTurnOnVarDimsMode">Switch 블록 ''{0}''의 첫 번째와 세 번째 입력 포트의 신호 차원이 서로 다릅니다. 가변 크기 출력 신호를 지원하려면, 해당 블록 대화 상자의 "신호 특성" 창에서 파라미터 "서로 다른 데이터 입력 크기 허용(가변 크기의 출력 신호 발생)"을 선택하십시오.</entry>
    <entry key="TDelayBufferTooSmall">''{0}''에 대해 지정된 버퍼가 너무 작습니다. 시뮬레이션 중에 버퍼 크기가 일시적으로 {1,number,integer}(으)로 증가되었습니다. 코드를 생성하려면 버퍼 크기 파라미터를 업데이트해야 합니다.</entry>
    <entry key="TDelayDirectThroughAutoSet">지연 시간이 0으로 설정되면 Transport Delay 블록 ''{0}''이(가) 직접 피드스루를 지원하도록 자동으로 설정됩니다. 이로 인해 대수 루프가 발생할 수 있습니다. Transport Delay 대신 Memory 블록을 사용하여 대수 루프를 끊을 수 있습니다.</entry>
    <entry key="TDelayFixedBuffer">''{0}''에서 고정 버퍼 크기 사용이 선택되지 않았습니다. GRT/ERT 코드 생성 시 Simulink는 사용자가 설정한 초기 버퍼 크기를 갖는 고정 버퍼를 사용합니다. 코드 생성 결과와 시뮬레이션 결과가 다를 수 있습니다.</entry>
    <entry key="TDelayNegDelayErr">''{0}''에는 음수 시간 지연이 지원되지 않음</entry>
    <entry key="TDelayNegDelayOutputFcn">''{0}''에 음수 시간 지연은 허용되지 않습니다. 지연이 0으로 설정되었습니다. 출력은 이전 입력 이력에 따른 순방향 외삽을 사용하여 계산되었습니다.</entry>
    <entry key="TDelayOverMaximumDelay">시간 {0}에서 지연 입력 포트의 {2,number,integer}번 요소 값({1})이 블록 ''{4}''에 지정된 최대 지연 파라미터 값({3})보다 큽니다. 지연 값이 최대 지연 시간으로 제한됩니다. 시뮬레이션 정확성을 높이려면 최대 지연 파라미터 값을 늘려 보십시오.</entry>
    <entry key="TDelayPadeOrder">''{0}''의 파데 차수는 음이 아닌 정수를 포함해야 함</entry>
    <entry key="TDelayTimeTooSmall">''{0}''에 지정된 지연 시간이 고정 스텝 솔버의 스텝 크기보다 작습니다. 이로 인해 시뮬레이션 결과가 정확하지 않을 수 있습니다. 정확성을 높이려면 솔버의 스텝 크기를 줄여 보십시오.</entry>
    <entry key="TDelayUndefinedFixedStep">시간 지연 파라미터는 솔버의 고정 스텝 크기에 종속되어 있어 해당 값을 가져올 수 없습니다.</entry>
    <entry key="TFLMutexEntryNotFound">코드 대체 라이브러리는 세마포어/뮤텍스 생성을 위한 항목을 제공해야 합니다.</entry>
    <entry key="CRLAtomicCheckAndSetEntryNotFound">Code Replacement Library registers keyword AtomicCheckAndSet, however, a replacement is not found in this Code Replacement Library for the given input type. Run RTW.viewTfl(get_param(bdroot,'TargetFcnLibHandle')) to identify the possible replacements that did not occur in MissCache. Code Replacement Library table must have an entry that have an input that is a pointer of {0}, or switch to use the default Code Replacement Library</entry>
    <entry key="TableDimAtLeastTwo">블록 ''{1}''에서 테이블의 차원 {0,number,integer}은(는) 크기가 1입니다. 각 테이블 차원은 적어도 2개의 요소를 가져야 합니다.</entry>
    <entry key="TableDimExceedsIndexType">블록 ''{2}''의 경우, &lt;sldiag objui="inport" objparam="{0}" objname="{2}"&gt;입력 포트 {0}&lt;/sldiag&gt;{1,number,integer}번의 데이터형이 ''{3}''입니다. '테이블 데이터' 파라미터에서 이에 대응하는 차원은 ({4,number,integer})입니다. 이 차원에 대해 데이터형이 최대 인덱스({5,number,integer})를 표현하지 못합니다. 최대 인덱스를 표현할 수 있도록 데이터형을 업데이트하십시오.</entry>
    <entry key="TableDimExceedsIndexFromBusType">For block ''{2}'', data type of the first signal in the bus object propagated to &lt;sldiag objui="inport" objparam="{0}" objname="{2}"&gt;input port {0}&lt;/sldiag&gt;{1,number,integer} is ''{3}''. The corresponding dimension from the 'Table data' parameter is ({4,number,integer}).The data type cannot represent max index ({5,number,integer}) for this dimension. Update the data type so that it can represent the max index.</entry>
    <entry key="TableDimensionMismatch">블록 ''{0}''에서 ''테이블 데이터''의 차원 수는 {1,number,integer}인데, 블록 파라미터 ''테이블 차원 수''는 {2,number,integer}입니다. ''테이블 데이터''의 차원과 ''테이블 차원 수''의 값은 서로 일치해야 합니다.</entry>
    <entry key="LUTObjTableDimensionMismatch">In block ''{0}'', the ''Number of table dimensions'' ({1,number,integer}) must match the number of dimensions of ''Table'' ({2,number,integer}) in Lookup Table Object ''{3}''.</entry>
    <entry key="TablePortDimensionMismatch">블록 ''{0}''에서 테이블 입력 포트에 의해 지정된 차원 수({1,number,integer})는 ''{2}'' 파라미터 값({3,number,integer})과 일치해야 합니다.</entry>
    <entry key="TableMayNotBeComplex">Complex values specified for ''Table data'' parameter in block ''{0}''. Only real data is supported.</entry>
    <entry key="TableMayNotBeComplexForSpline">Complex values specified for ''Table data'' parameter in block ''{0}''. Only real data is supported for ''Cubic spline'' and ''Akima spline'' interpolation methods.</entry>
    <entry key="TableMustBeNonEmpty">블록 ''{0}''의 테이블 데이터는 비어 있어서는 안 됩니다.</entry>
    <entry key="TableMustBeNumeric">Non-numeric values specified for ''Table data'' parameter in block ''{0}''. Only numeric data is supported.</entry>
    <entry key="TimeseriesNotSupportedInRTW">''{0}''에 대해 생성된 코드는 현재 타깃 ''{1}''을(를) 사용한 Timeseries 기록 형식을 지원할 수 없습니다. 기록 형식을 배열로 전환하거나, Timeseries 형식을 지원하는 타깃을 선택해 보십시오.</entry>
    <entry key="ToFileInconsistentFormatVsComplexityErr">''{0}''의 입력 포트에서 데이터의 실수/복소수 여부가 일치하지 않습니다. 복소수가 아닌 데이터만 배열 형식으로 기록할 수 있습니다. Timeseries 형식을 사용해 보십시오.</entry>
    <entry key="ToFileInconsistentFormatVsDatatypeErr">''{0}''의 입력 포트에서 데이터형이 일치하지 않습니다. double형 데이터 또는 별칭이 double형으로 지정된 데이터만 배열 형식으로 기록할 수 있습니다. Timeseries 형식을 사용해 보십시오.</entry>
    <entry key="ToFileInconsistentFormatVsDimensionErr">''{0}''의 입력 포트에서 차원이 일치하지 않습니다. 1차원 데이터만 배열 형식으로 기록할 수 있습니다. Timeseries 형식을 사용해 보십시오.</entry>
    <entry key="ToFileInvalidDimRank">Number of dimensions at the input port of To File block ''{0}'' is {1,number,integer}. To File blocks do not support inputs with number dimensions greater than {2,number,integer}.</entry>
    <entry key="ToFileInvalidFileDir">''{1}''에 지정된 파일 이름 ''{0}''의 디렉터리가 존재하지 않습니다.</entry>
    <entry key="ToFileInvalidInputDataType">The To File block ''{0}'' cannot log the given data type.  Supported types are double, single, int8, uint8, int16, uint16, int32, uint32, and 32-bit signed enum types. However, the input port is driven by a signal of data type ''{1}''</entry>
    <entry key="ToFromFileGeneralErr">블록 ''{0}''에서 보고된 진단</entry>
    <entry key="ToFromFileLicenseError">Logging and loading of fixed-point data requires a Fixed-Point Designer license.</entry>
    <entry key="ToFromFileMultiwordFiError">Logging and loading fixed-point data with word length greater than 32 bits is not supported.</entry>
    <entry key="TranposeBlkInvDims">''{0}''의 입력 포트에 대해 지정된 차원이 유효하지 않습니다. 차원({1})이 출력 차원({2})과 일치하지 않습니다.</entry>
    <entry key="CordicPositiveNumOfIterations">The number of iterations for block ''{0}'' should be a positive real number greater than zero</entry>
    <entry key="CordicSlopeBiasScaledInputNotSupported">Invalid data type specified for the input port of block ''{0}''. CORDIC approximation supports floating point or fixed-point data types with bias equal to zero and slope power of two.</entry>
    <entry key="CordicViolateInheritOutDType">블록 ''{0}''의 출력 데이터형은 계산한 대로 ''{1}''여야 하지만, ''{2}''(으)로 설정되는 중입니다.</entry>
    <entry key="TrigfcnSineInvalid">''{0}''에서는 sin에 대해 무한대 입력값이 유효하지 않습니다.</entry>
    <entry key="TrigfcnCosineInvalid">''{0}''에서는 cos에 대해 무한대 입력값이 유효하지 않습니다.</entry>
    <entry key="TrigfcnTanInvalid">''{0}''에서는 tan에 대해 무한대 입력값이 유효하지 않습니다.</entry>
    <entry key="TrigfcnHypsineSaturates">sinh 연산 결과가 ''{0}''에서 무한대로 포화됩니다.</entry>
    <entry key="TrigfcnHypcosineSaturates">cosh 연산 결과가 ''{0}''에서 무한대로 포화됩니다.</entry>
    <entry key="TrigfcnArchyptanDivByZero">''{0}''의 atanh에서 0으로 나누기가 발생했습니다.</entry>
    <entry key="TrigfcnArccosineArgOutOfRange">''{0}''에서 역코사인에 대한 인수가 범위를 벗어났습니다. ''출력 신호 유형''을 복소수로 설정해 보십시오.</entry>
    <entry key="TrigfcnArccosineArgOutOfRangeWithoutProtection">''{0}''에서 역코사인에 대한 인수가 범위를 벗어났습니다. 범위를 벗어난 입력에 대한 방지가 비활성화되었습니다.</entry>
    <entry key="TrigfcnArchypcosArgOutOfRange">''{0}''에서 역쌍곡코사인에 대한 인수가 범위를 벗어났습니다. ''출력 신호 유형''을 복소수로 설정해 보십시오.</entry>
    <entry key="TrigfcnArchyptanArgOutOfRange">''{0}''에서 역쌍곡탄젠트에 대한 인수가 범위를 벗어났습니다. ''출력 신호 유형''을 복소수로 설정해 보십시오.</entry>
    <entry key="TrigfcnArcsineArgOutOfRange">''{0}''에서 역사인에 대한 인수가 범위를 벗어났습니다. ''출력 신호 유형''을 복소수로 설정해 보십시오.</entry>
    <entry key="TrigfcnArcsineArgOutOfRangeWithoutProtection">''{0}''에서 역사인에 대한 인수가 범위를 벗어났습니다. 범위를 벗어난 입력에 대한 방지가 비활성화되었습니다.</entry>
    <entry key="CordicAngleOutOfRange">The input angle for block ''{0}'' is out-of-range after being recast to double. For CORDIC approximation, this angle must be between [ double(-2pi), double(2pi) ).</entry>
    <entry key="LutAngleOutOfRangeRad">블록 ''{0}''의 입력 각도가 double형으로 다시 형변환된 후 범위를 벗어났습니다. 룩업 근사에서 이 각도는 [ double(-2pi), double(2pi) ) 사이여야 합니다.</entry>
    <entry key="LutAngleOutOfRangeRev">블록 ''{0}''의 입력 각도가 double형으로 다시 형변환된 후 범위를 벗어났습니다. 룩업 근사에서 이 각도는 [ double(-1), double(1) ) 사이여야 합니다.</entry>
    <entry key="CordicMagnitudeIsInfOrNaN">The magnitude for block ''{0}'' is either Inf or NaN. CORDIC Approximation method does not support Inf or NaN values.</entry>
    <entry key="CordicATan2InputIsInfOrNaN">The input for block ''{0}'' is either Inf or NaN. CORDIC Approximation method does not support Inf or NaN values.</entry>
    <entry key="LUTInputIsInfOrNaN">블록 ''{0}''의 입력은 Inf 또는 NaN입니다. Inf 또는 NaN 값은 룩업 근사법에서 지원되지 않습니다.</entry>
    <entry key="CordicWordLengthEqualToNumberIterations">The word length of the input fixed point data type for the block ''{0}'' is equal to the number of iterations specified in the block. This word length is not supported for "CORDIC" setting of the "Approximation method" parameter. Choose the number of iterations to be less than the word length of the input data type.</entry>
    <entry key="CordicLutATan2RequireHomogeneousPortDataTypes">''{0}''의 입력 포트 데이터형은 동일해야 합니다. 모든 포트를 동일한 데이터형(double형, single형 또는 고정소수점)으로 설정하십시오.</entry>
    <entry key="CordicInputWLCannotRepresentPi">블록 ''{0}''의 입력 포트에 대해 지정된 데이터형이 유효하지 않습니다. CORDIC 근사를 통해 필요한 사분면 수정을 진행할 수 없습니다. 입력 데이터형으로 Pi를 표현할 수 없고 입력 워드 길이가 시뮬레이션의 최대 제한에 해당하기 때문입니다.</entry>
    <entry key="CordicInputUnsignedMaxWL">블록 ''{0}''의 입력 포트에 대해 지정된 데이터형이 유효하지 않습니다. CORDIC 근사를 통해 필요한 사분면 수정을 진행할 수 없습니다. 입력 데이터형이 부호 없는 데이터형이고 입력 워드 길이가 시뮬레이션의 최대 제한에 해당하기 때문입니다.</entry>
    <entry key="CordicOutputWLGreaterThan128"> Input data type word length specified for the input port of block ''{0}'' is large, which requires output data type word length to exceed maximum supported limit.</entry>
    <entry key="CordicIterationsGreaterThanInputWL">The number of specified iterations must be less than the input word length at port {0, number, integer} for CORDIC approximation in block ''{1}''.</entry>
    <entry key="CordicIterationsGreaterThanMax">블록 ''{1}''에서 CORDIC 근사에 대해 {0, number, integer}번 포트에 지정된 반복 횟수는 127보다 작아야 합니다.</entry>
    <entry key="CordicATan2SignedInputWLGreaterThan126"> 블록 ''{0}''에서 부호 있는 입력 데이터형에 대해 지정된 워드 길이가 127 이상입니다. 이로 인해 내부 데이터형의 워드 길이가 지원되는 최대 제한(128)을 초과합니다. 입력 포트에 대한 워드 길이를 126 이하로 지정하십시오.</entry>
    <entry key="CordicATan2UnSignedInputWLGreaterThan125"> 블록 ''{0}''에서 부호 없는 입력 데이터형에 대해 지정된 워드 길이가 126 이상입니다. 이로 인해 내부 데이터형의 워드 길이가 지원되는 최대 제한(128)을 초과합니다. 입력 포트에 대한 워드 길이를 125 이하로 지정하십시오.</entry>
    <entry key="MagAng2CmpxMixedFloatFixed">CORDIC Approximation for block ''{0}'' does not support one port to be fixed point type and other to be floating point type. Input port data types can be homogeneous or heterogeneous fixed point types, or homogeneous floating point types. </entry>
    <entry key="MagAng2CmpxPortMixedFloat">CORDIC Approximation for block ''{0}'' supports fixed point data types and homogeneous floating point data types via input ports </entry>
    <entry key="MagAng2CmpxFloatPortFixedDialog">CORDIC Approximation for block ''{0}'' does not support floating point input port data type and non floating point types for dialog parameter. When the input port type is floating point, the dialog parameter (Angle or Magnitude) must be floating point data type. When the input port type is fixed point, the dialog parameter can be fixed point or floating point data type </entry>
    <entry key="BlockInOutCannotBeBoolean">블록 ''{0}''의 입력 및 출력 데이터형이 부울일 수 없습니다. 데이터형은 Simulink에 내장된 ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'' 또는 ''double'' 중 하나이거나 고정소수점 데이터형 중 하나여야 합니다.</entry>
    <entry key="CORDICNotSupportedForComplexToMagnitudeBlock">''{0}'' 블록에는 CORDIC 알고리즘이 지원되지 않습니다.</entry>
    <entry key="TrigfcnSineLookupWordLengthTooSmall">파라미터 출력 워드 길이(OutputWordLength)는 블록 ''{0}''에서 스칼라 숫자형이면서 1보다 큰 정수 값이어야 합니다.</entry>
    <entry key="TrigfcnSineLookupNumDataPtsTooSmall">블록 ''{0}''에 대한 데이터 점 개수(NumberOfDataPoints) 파라미터는 스칼라 숫자형이면서 2보다 작지 않은 정확한 정수여야 합니다.</entry>
    <entry key="TrigfcnSineLookupEitherTooSmall">블록 ''{0}''에서 입력 데이터형 소수부 길이가 파라미터 "룩업 테이블의 데이터 점 개수"에서 제공하는 데이터 점 개수를 수용할 만큼 충분히 크지 않습니다. 데이터 점 개수를 {1,number,integer}에서 {2,number,integer}(으)로 줄이거나 입력 데이터형 소수부 길이를 {3,number,integer}에서 {4,number,integer}(으)로 늘려야 합니다.</entry>
    <entry key="TrigfcnLookupNumDataPtsTooBigSingle">블록 ''{0}''에서 입력 데이터형이 single형일 때 데이터 점의 개수는 {1, number, integer}개 미만이어야 합니다.</entry>
    <entry key="TrigfcnSineLookupWordLengthTooBig">파라미터 출력 워드 길이(OutputWordLength)는 블록 ''{0}''에서 스칼라 숫자형이면서 65보다 작은 정수 값이어야 합니다.</entry>
    <entry key="TrigfcnDoubleOrSingleOnly">''{0}''의 입력 포트 및 출력 포트의 데이터형을 {1}(으)로 설정하는 것은 지원되지 않습니다. 데이터형은 double형 또는 single형이어야 합니다.</entry>
    <entry key="TrigfcnRTWComplexInpNotSupported">Simulink Coder에서 블록 ''{0}''은(는) 현재 복소 신호를 지원하지 않음</entry>
    <entry key="TrigfcnLUTHalfNotSupported">블록 ''{0}''에서 반정밀도 입력은 룩업 근사법의 경우 지원되지 않습니다.</entry>
    <entry key="TrigfcnLUTOutputCannotBeUnsigned">블록 ''{0}''의 출력은 부호 있는 형식이어야 합니다.</entry>
    <entry key="TrigFcnLUTSlopeBiasScaledInputNotSupported">블록 ''{0}''의 입력 포트에 대해 지정된 데이터형이 유효하지 않습니다. '룩업' 근사에서는 편향이 0이고 기울기가 2의 거듭제곱인 부동소수점 또는 고정소수점 데이터형이 지원됩니다.</entry>
    <entry key="TrigfcnSingularArgument">블록 {0}에서 Function이 'atan'으로 설정되어 있는 경우, 입력이 +i 또는 -i이면 출력이 정의되지 않습니다.</entry>
    <entry key="TriggerPortExists">A trigger port already exists in ''{0}''. Adding another trigger port is not allowed.</entry>
    <entry key="RTBBetweenAsyncWithCommonInitiator"> Rate Transition 블록 ''{0}''이(가) 공통 개시자를 사용하여 두 개의 비동기 Function-Call Subsystem을 연결하고 있습니다. 소스 태스크가 대상 태스크를 선점하는 경우 이 블록은 데이터 무결성을 보장할 수 없습니다. 소스 태스크에 더 낮은 우선 순위를 할당하거나, 소스 태스크에 더 낮은 우선 순위를 할당하거나, 각각의 개별 비동기 개시자를 사용하여 두 개의 Function-Call Subsystem을 구동하십시오.</entry>
    <entry key="TsMultipleNotWorkWithAsyncTs">Rate Transition 블록 ''{2}''의 {0} {1,number,integer}번 포트에서 비동기 샘플 시간이 발견되었습니다. Rate Transition 블록 파라미터 ''출력 포트 샘플 시간 옵션''이 ''입력 포트 샘플 시간의 배수''인 경우 비동기 샘플 시간이 허용되지 않습니다. ''출력 포트 샘플 시간 옵션''을 "지정" 또는 "상속"으로 변경해 보십시오.</entry>
    <entry key="TsMultipleNotWorkWithAperiodicTs">
      Rate Transition 블록 ''{2}''의 {0} {1,number,integer}번 포트에서 비주기적 분할이 발견되었습니다. Rate Transition 블록 파라미터 ''출력 포트 샘플 시간 옵션''이 ''입력 포트 샘플 시간의 배수''인 경우 비주기적 분할이 허용되지 않습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit" id="Inherit"&gt; &lt;cmd&gt;set_param_action(''{2}'', ''OutPortSampleTimeOpt'',''Inherit'');&lt;/cmd&gt; &lt;txt&gt;''출력 포트 샘플 시간 옵션''을 ''상속''으로 변경하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit" id="Specify"&gt; &lt;cmd&gt;set_param_action(''{2}'', ''OutPortSampleTimeOpt'',''Specify'',''OutPortSampleTime'',''__ARG1__'');&lt;/cmd&gt; &lt;cargs&gt; &lt;carg name="__ARG1__"&gt; &lt;txt_prompt&gt;주기적 이산 샘플 시간 지정&lt;/txt_prompt&gt; &lt;/carg&gt; &lt;/cargs&gt; &lt;txt&gt;주기적 이산 샘플 시간을 지정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
      
    </entry>
    <entry key="TsMultipleNotWorkWithContinuousTs">Rate Transition 블록 ''{2}''의 {0} {1,number,integer}번 포트에서 연속 샘플 시간이 발견되었습니다. Rate Transition 블록 파라미터 ''출력 포트 샘플 시간 옵션''이 ''입력 포트 샘플 시간의 배수''인 경우 연속 샘플 시간이 허용되지 않습니다. ''출력 포트 샘플 시간 옵션''을 "지정" 또는 "상속"으로 변경해 보십시오.</entry>
    <entry key="TsMultipleNotWorkWithTrigTs">Rate Transition 블록 ''{2}''의 {0} {1,number,integer}번 포트에서 트리거된 샘플 시간이 발견되었습니다. Rate Transition 블록 파라미터 ''출력 포트 샘플 시간 옵션''이 ''입력 포트 샘플 시간의 배수''인 경우 트리거된 샘플 시간이 허용되지 않습니다. ''출력 포트 샘플 시간 옵션''을 "상속"으로 변경해 보십시오.</entry>
    <entry key="TsMultipleNotWorkWithZOHContinuousTs">Rate Transition 블록 ''{2}''의 {0} {1,number,integer}번 포트에서 ZOH 연속 샘플 시간이 발견되었습니다. Rate Transition 블록 파라미터 ''출력 포트 샘플 시간 옵션''이 ''입력 포트 샘플 시간의 배수''인 경우 ZOH 연속 샘플 시간이 허용되지 않습니다. 대부분의 경우 Rate Transition 블록이 ZOH 연속 샘플 시간을 상속할 수 있습니다. 소스 블록이나 대상 블록이 연속 또는 상수이거나 샘플 시간이 지정되지 않은 경우 Simulink에서는 샘플 시간 전파 시 Rate Transition 블록에 ZOH 연속 샘플 시간을 설정할 수 있습니다. 이 오류를 해결하려면 ''출력 포트 샘플 시간 옵션''을 "지정" 또는 "상속"으로 변경하거나, 이 Rate Transition 블록의 소스 블록 중 하나에 이산 샘플 시간을 지정해 보십시오</entry>
    <entry key="TsMultipleNotWorkWithTooSmallTs"> Rate Transition 블록 ''{2}''의 {0} {1,number,integer}번 포트에서 샘플 시간이 너무 작습니다. 이렇게 샘플 시간이 작으면 출력 포트에 연속 샘플 시간이 야기됩니다. 그 이유는 블록 파라미터 ''출력 포트 샘플 시간 옵션''이 ''입력 포트 샘플 시간의 배수''로 설정되었고 ''샘플 시간 배수'' 값이 1보다 작기 때문입니다. 이러한 조건이 연속 샘플 시간을 블록의 출력 포트로 전파하는 것입니다. Rate Transition 블록은 연속 샘플 시간을 지원하지 않습니다.</entry>
    <entry key="TwowayConnInvInterSysConn">Two-Way Connection block ''{0}'' cannot cross nonvirtual subsystem boundaries.</entry>
    <entry key="TwowayConnTooManyConnections">여러 개의 Two-Way Connection 블록 연결이 유효하지 않음. 쌍이어야 함: ''{0}'', ''{1}'', ''{2}''.</entry>
    <entry key="UnableToFindSymbolInLibrary">공유 오브젝트 파일 ''{1}''에서 기호 ''{0}''을(를) 찾을 수 없음</entry>
    <entry key="UnableToLoadUserData">블록 ''{0}''에 대한 UserData를 불러올 수 없습니다. 클래스 정의가 포함된 폴더가 MATLAB 경로에서 누락되었기 때문일 수 있습니다.</entry>
    <entry key="UnifiedAllPortSameDataType">''{0}''의 모든 입력 포트와 출력 포트는 데이터형이 동일해야 합니다.</entry>
    <entry key="UnifiedInputDataPortsSameDataType">''{0}''의 모든 데이터 입력값은 데이터형이 동일해야 합니다.</entry>
    <entry key="UnifiedInputDataPortsSameNonNumericDataType">''{0}''의 모든 데이터 입력은 그중 하나가 숫자형이 아닌 데이터형을 갖는 경우 동일한 데이터형을 가져야 합니다.</entry>
    <entry key="UnifiedInputPortSameDataType">''{0}''의 모든 입력값은 데이터형이 동일해야 합니다.</entry>
    <entry key="UnifiedOutputPortSameNonNumericDataType">Output port of ''{0}'' is required to have the same data type as its inputs if their data type is not numeric.</entry>
    <entry key="UnitDelayMixedSamplingModeBusForCodeGen">The nonvirtual bus entering the Delay block ''{0}'' has both frame-based and sample-based elements. Nonvirtual buses with mixed sampling mode is not supported for code generation. </entry>
    <entry key="UnitDelayMixedSamplingModeBusWarning">The bus entering the Delay block ''{0}'' has both frame-based and sample-based elements. Buses with mixed sampling mode will not be supported in a future release.</entry>
    <entry key="UnitDelayFrameNonScalarParameter" context="error">프레임 기반 모드에서 작동하는 ''{0}''에 대해 지정된 파라미터가 유효하지 않습니다. 프레임 기반 모드에서는 초기 조건이 스칼라여야 합니다.</entry>
    <entry key="Unnamed_Library">이름 없는 라이브러리 경고임</entry>
    <entry key="Unnamed_Library_Message">서브시스템 템플릿을 구성하기 전에 라이브러리를 저장해야 함</entry>
    <entry key="UnsupportedParameterDataType">The value of parameter ''{0}'' in ''{1}'' is of an unsupported data type. This parameter supports floating point data types and fixed-point data types with up to 32 Mantissa bits.</entry>
    <entry key="UserMSFcnBlockDoesNotSupportMultiExecInstances">Simulink does not support block ''{0}'' inside subsystem ''{1}'' because the subsystem contains a For Each block (''{2}''). If this is a user-defined S-Function and it satisfies the multiple execution instances requirements, consider turning on the compliance flag using the ''SupportsMultipleExecInstances'' property in the setup method.</entry>
    <entry key="UserSFcnBlockDoesNotSupportMultiExecInstances">Simulink does not support block ''{0}'' inside subsystem ''{1}'' because the subsystem contains a For Each block (''{2}''). If this is a user-defined S-Function and it satisfies the multiple execution instances requirements, consider turning on the compliance flag using the SimStruct function ''ssSupportsMultipleExecInstances'' in the ''mdlSetWorkWidths'' method.</entry>
    <entry key="UserSystemObjectDoesNotSupportMultiExecInstances">Simulink does not support block ''{0}'' inside subsystem ''{1}'' because the subsystem contains a For Each block (''{2}''). If this is a user-defined System object and it satisfies the multiple execution instances requirements, consider implementing the System object authoring method ''supportsMultipleInstanceImpl'' for ''{3}''.</entry>
    <entry key="VTDelayWrongDirection">''{0}''의 2번 입력 포트에 음수 값을 지정하는 것은 허용되지 않습니다. 값이 무한대로 설정되었습니다.</entry>
    <entry key="VTDelayZeroDelay">시간 ''{0}''에서 ''{1}''의 2번 입력 포트에 0 지연을 지정하면 시뮬레이션 결과가 정확하지 않을 수 있습니다. 올바른 결과를 보장하려면 파라미터 대화 상자에서 ''0 지연 처리''를 선택하십시오. 그렇게 하면 Variable Time Delay 블록이 직접 피드스루 블록으로 바뀝니다.</entry>
    <entry key="VTDelayZeroMaxDelay">전송 지연 모드에서 최대 지연 시간을 0으로 설정할 수 없습니다.</entry>
    <entry key="VarDimsIteratedInputNotSupported">The dimensions mode of the signal at input {0,number,integer} is variable-size for subsystem ''{1}''. Variable-size input signals are not supported by subsystem ''{2}'' because the subsystem contains a For Each block (''{3}'').</entry>
    <entry key="VarDimsModeFrameReqFirstDimMatch">When the "Allow different data input sizes (Results in variable-size output signal)" parameter is selected for ''{0}'', and the signals to input 1 and 3 are frame-based signals, the size of the first dimension of these two signals must be the same. For example, the pair [3x3] and [3x2] is allowed, but the pair [3x3] and [2x2] is disallowed.</entry>
    <entry key="VarDimsModeReqOneBranchFitOther">Simulink does not support the input signals provided to the block ''{0}''. The "Allow different data input sizes (Results in variable-size output signal)" parameter is selected. Therefore, the size of each dimension of one data input must be larger than the size of the corresponding dimension of the other data input. In other words, the maximum dimension sizes for the block must be determined completely from one input.</entry>
    <entry key="VarDimsModeReqScalarTrigPort">When the "Allow different data input sizes (Results in variable-size output signal)" parameter is selected for ''{0}'', the input signal to the control port and the threshold value must both be scalars.</entry>
    <entry key="BlkCannotBeCommented">블록 ''{0}''은(는) 지원되지 않기 때문에 주석 처리할 수 없습니다.</entry>
    <entry key="BlkCannotBeCommentedInCallback">Incorrect to comment or uncomment block “{0}” during callback execution. </entry>
    <entry key="BlkHasNoPorts">Block ''{0}'' cannot be commented through because it does not contain any ports.</entry>
    <entry key="BlkHasMixOfDataAndConnPorts">Block ''{0}'' cannot be commented through because it has a mix of both data and connection ports.</entry>
    <entry key="BlkHasUnequalInAndOutPorts">Block ''{0}'' cannot be commented through because the number of input ports do not match the number of output ports.</entry>
    <entry key="BlkHasControlPorts">Block ''{0}'' cannot be commented through because it contains control ports.</entry>
    <entry key="SimscapeBlkWithoutExactlyTwoConnPorts">Block ''{0}'' cannot be commented through because it does not have exactly two connection ports.</entry>
    <entry key="SimscapeBlkWithPortsFromMultipleDomains">Block ''{0}'' cannot be commented through because it has connection ports from multiple domains.</entry>
    <entry key="BlkIsSimscapeBus">블록 ''{0}''이(가) 통과형 주석 처리에 지원되지 않는 Simscape 버스입니다.</entry>
    <entry key="InvCommentThroughWireLoop">Invalid wire loop detected involving block ''{0}'' &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{0}"&gt;output port {1,number,integer}&lt;/sldiag&gt; due to one or more blocks that act as pass-through blocks.</entry>
    <entry key="VariantMemberInputConnected">&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of the variant block ''{1}'' must be unconnected because it is part of a Variant Subsystem block.</entry>
    <entry key="VariantMemberOutputConnected">Variant 블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;는 Variant Subsystem 블록의 일부이기 때문에 연결되지 않아야 합니다.</entry>
    <entry key="VariantInportConnected">Inport 블록 ''{0}''은(는) Variant Subsystem 블록의 일부이기 때문에 연결되지 않아야 합니다.</entry>
    <entry key="VariantInvalidBlock">Invalid block ''{0}'' found in Variant Subsystem block ''{1}''. Only Inport, Outport, Connection Port, Subsystem and Model blocks are allowed in a Variant Subsystem.
    &lt;actions exclusiveFixIts="yes"&gt;
    &lt;action type="fixit"&gt;
    &lt;cmd&gt;slprivate(''variantfixes'',''DeleteBlock'',''{1}'', ''{0}'')&lt;/cmd&gt;
    &lt;txt&gt;Delete Variant choice block ''{0}'' from ''{1}''.&lt;/txt&gt;
    &lt;/action&gt;
    &lt;/actions&gt;</entry>
    <entry key="VariantInvalidBlock_fix">Variant 선택지 블록 ''{0}''이(가) 삭제되었습니다.</entry>
    <entry key="CommentedNotSupported">Variant Subsystem 블록 ''{1}''에서 유효하지 않은 블록 ''{0}''이(가) 발견되었습니다. Variant Subsystem에서 블록을 주석 처리하는 것은 허용되지 않습니다.</entry>
    <entry key="VariantInvalidSet">Subsystem 블록 ''{0}''의 Variant 속성은 변경할 수 없습니다.</entry>
    <entry key="VariantMultipleVariants">Variant Subsystem 블록 ''{0}''에는 Variant 제어가 단 하나만 활성화될 수 있습니다. 하지만 다음 Variant 제어가 활성 상태입니다: {1}.</entry>
    <entry key="VariantMultipleDefaultVariants">Only one variant choice block can be default variant for the Variant Subsystem block ''{0}''. There are more than one default variants specified for ''{1}'', which is invalid.</entry>
    <entry key="VariantNoVariants">Variant Subsystem 블록 ''{0}''에 활성 상태의 Variant 제어가 없습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;slprivate(''variantfixes'',''VariantSubsystemEnableAZVC'',''{0}'')&lt;/cmd&gt; &lt;txt&gt;Variant Subsystem 블록 ''{0}''에서 '내장된 빈 선택지'를 선택해야 합니다.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;</entry>
    <entry key="VariantNoVariantsWithoutFixIt">Variant Subsystem block ''{0}'' contains no active variant controls.
    &lt;actions&gt;
    &lt;action type="suggestion"&gt;
    &lt;txt&gt;To explicitly allow empty choice variant for this block, turn off ''Fast Restart'' and select the ''Built-in empty choice'' check box in the block parameters dialog box.&lt;/txt&gt;
    &lt;/action&gt;
    &lt;/actions&gt; </entry>
    <entry key="EmptyVariantControl">Variant control must be non-empty and uncommented for at least one choice block of Variant Subsystem block ''{0}''.</entry>
    <entry key="VariantNoVariants_fix">Variant Subsystem 블록에 대해 명령 'set_param(blkName, 'EmptyChoice', 'on')'이 실행되었습니다</entry>
    <entry key="VariantNoVariantsFixAll">  Fix all nested Variant Subsystem blocks of loaded systems with no active variant controls.
    &lt;actions exclusiveFixIts="yes"&gt;
    &lt;action type="fixit"&gt;
    &lt;cmd&gt;slprivate(''variantfixes'',''AllVariantSubsystemEnableAZVC'')&lt;/cmd&gt;
    &lt;txt&gt;'Built-in empty choice' must be selected in all nested Variant Subsystem blocks.&lt;/txt&gt;
    &lt;/action&gt;
    &lt;/actions&gt;</entry>
    <entry key="VariantSubsystemPortsNotSynched"> Ports of variant choices do not match the ports of containing Variant Subsystem block ''{0}'' .
	&lt;actions exclusiveFixIts="yes"&gt;
    &lt;action type="fixit"&gt;
	&lt;cmd&gt;slprivate(''variantfixes'',''MatchVariantSubsystemPorts'', ''{0}'')&lt;/cmd&gt;
    &lt;txt&gt;Match ports of variant choices with ports of ''{0}''.&lt;/txt&gt;
    &lt;/action&gt;
	&lt;action type="fixit"&gt;
	&lt;cmd&gt;slprivate(''variantfixes'',''EnableFlexibleInterface'', ''{0}'')&lt;/cmd&gt;
    &lt;txt&gt;Set ''Allow flexible interface'' of ''{0}'' to ''on''.&lt;/txt&gt;
    &lt;/action&gt;
    &lt;/actions&gt;
	</entry>
    <entry key="PortMatchingPerformedSuccessfully">Variant 선택지와 포함되어 있는 Variant Subsystem 블록이 동일한 포트 집합을 가집니다.</entry>
    <entry key="UnsupportedBlockPortMatchFixedOthers">Port matching performed on variant choices, but matching the ports with variant subsystem is required for the following failed variant choices.</entry>
    <entry key="UnsupportedBlockOperationFail">Port matching failed for following variant choices.</entry>
    <entry key="TurnFlexibleInterfaceOn">Variant Subsystem 블록 ''{0}''의 '유연한 인터페이스 허용'이 'on'으로 설정되었습니다.</entry>
    <entry key="UnsupportedBlockWarning">''{0}''</entry>
    <entry key="FindSystemFailedForFix">블록 ''{0}''에서 포트 정보를 수집할 수 없습니다. 모델 블록을 불러오지 않았거나 이 블록에 대한 수정 작업이 지원되지 않습니다.</entry>
    <entry key="SamePortNamesDifferentPortTypes">포트 일치에 실패했습니다. 이름은 같지만 포트 유형이 다른 ''{2}'' 블록이 있어 ''{0}'' 블록을 선택지 블록 ''{1}''에 추가할 수 없기 때문입니다.</entry>
    <entry key="AddBlockFailure">동일한 이름의 블록이 이미 존재하므로, Variant Subsystem의 포트 블록 ''{0}''을(를) 선택지 블록 ''{1}''에 추가하는 것은 지원되지 않습니다.</entry>
    <entry key="VariantNoVariantsFixAll_fix">다음 Variant Subsystem 블록에 대해 명령 'set_param(blkName, 'EmptyChoice', 'on')'이 실행됨: {0} </entry>
    <entry key="NotValidSubsystemToConvertToVariant">Unable to convert block ''{0}'' to Variant Subsystem. Only Subsystem or Model blocks can be converted to Variant Subsystem.</entry>
    <entry key="PartitionedSubsystemConvertToVariantInvalid">Unable to convert block ''{0}'' to Variant Subsystem because only a non-partitioned Subsystem can be converted to a Variant Subsystem.</entry>
    <entry key="VariantOutportConnected">Outport 블록 ''{0}''은(는) Variant Subsystem 블록의 일부이기 때문에 연결되지 않아야 합니다.</entry>
    <entry key="VectSelInvDataInpDims">파라미터 ''{1}''이(가) 1로 지정된 경우 ''{0}''은(는) 입력 포트 &lt;U&gt;에 벡터 입력값을 필요로 합니다. 입력 포트 &lt;U&gt;의 차원 수는 2보다 클 수 없습니다. 차원 수를 {2,number,integer}(으)로 설정하려고 합니다.</entry>
    <entry key="VirtualSelectorCannotSupportVarDims">''{0}'' cannot take 1-D variable sized input signal when its dialog parameter ''{1}'' is set to ''{2}''. To fix the problem, try to change the ''{3}'' setting to ''{4}''</entry>
    <entry key="WSTimeDivideByZero">블록 ''{0}''에서 가중치 파라미터가 ''0''으로 설정되어 있고 선택된 연산 파라미터가 ''/'' 또는 ''1/Ts''입니다. 나눗셈을 하면 무한대가 나옵니다.</entry>
    <entry key="WSTimeInfiniteSampleTime">블록 ''{0}''의 샘플 시간은 유한해야 함</entry>
    <entry key="WSTimeOnlineBiasHandling">For * or / case, online bias handling is not supported by block ''{0}''</entry>
    <entry key="WSTimeTriggeredAndNonPositiveWeight">Triggered Subsystem에서 블록 ''{0}''이(가) 정수 경과 시간 카운터와 함께 사용되고 있습니다. 이 경우에는 가중치 값이 순양수여야 합니다.</entry>
    <entry key="WSTimeTrivialScaling">블록 ''{0}''이(가) boolean, double, single 같이 자명한 스케일링만 허용하는 데이터형의 크기를 조정하려 함</entry>
    <entry key="WSTimeControllableSampleTime">블록 ''{0}''은(는) 제어 가능한 샘플 시간을 지원하지 않음</entry>
    <entry key="WSTimeIODifferentBias">Block ''{0}'' requires that the input data type and output data type have same bias when the output data type is not inherited via internal rule.</entry>
    <entry key="WarnBdMuxBlksUsedAsBusCreator">블록 다이어그램 ''{0}''에서 Mux 블록 {1,number,integer}개를 Bus Creator로 잘못 사용하고 있습니다. 이로 인해 모델링 오류가 발생할 수 있습니다. 자세한 내용은 Mux 블록 문서를 참조하십시오. 올바르지 않게 사용된 Mux 블록을 업그레이드 어드바이저와 slreplace_mux 명령을 사용하여 수정하십시오. 그런 다음 구성 파라미터 대화 상자 -&gt; 진단 -&gt; 연결성에서 ''버스 신호를 생성하는 데 사용되는 Mux 블록''을 ''오류''로 설정하십시오. 참고로, 이 진단의 ''안 함'' 및 ''경고'' 옵션은 Simulink 향후 버전에서 제거될 예정입니다.\n 각 Mux 블록에 대한 개별 경고(최대 10개)가 아래에 보고되어 있습니다.</entry>
    <entry key="WarnIISSkippedForStateLogging">Model ''{0}'' has blocks with states inside one or more subsystems, which contain a For Each block. Simulink does not log such states.</entry>
    <entry key="WarnMuxUsedAsBusIsSetToNone">구성 파라미터 대화 상자 -&gt; 진단 -&gt; 연결성에서 블록 다이어그램 ''{0}''에 대한 ''버스 신호를 생성하는 데 사용되는 Mux 블록''이 ''안 함''으로 설정되어 있습니다. 이 진단의 ''안 함'' 및 ''경고'' 옵션은 Simulink 향후 버전에서 제거될 예정입니다. 다음을 수행하십시오.\n 1. 먼저 진단을 ''경고''로 설정하여 모델에 잘못 사용된 Mux 블록을 알아냅니다.\n 2. 올바르지 않게 사용된 Mux 블록을 업그레이드 어드바이저와 ''slreplace_mux'' 명령을 사용하여 수정합니다.</entry>
    <entry key="WarnTuningWhenCoverage">Cannot tune parameters in block ''{0}'' while using the Lookup Table Coverage option. The Coverage tool will ignore the new parameter values.</entry>
    <entry key="WarningMatCheckPureSingularity">시간 {2}에서 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;의 입력 행렬이 특이 행렬입니다. Simulink 제품의 역행렬 결과가 정확하지 않을 수 있습니다. 특이 행렬에 대한 추가 경고가 차단되는 상태로 시뮬레이션이 계속됩니다.&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="WarningMatCheckSingularity">시간 {2}에서 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;의 입력 행렬이 특이 행렬에 가깝습니다. Simulink 제품의 역행렬 결과가 정확하지 않을 수 있습니다. 특이 행렬에 대한 추가 경고가 차단되는 상태로 시뮬레이션이 계속됩니다.</entry>
    <entry key="WhileExceedMaxIters">''{0}''의 반복 횟수가 출력 포트 데이터형 ''{1}''에 허용되는 최대 값을 초과함</entry>
    <entry key="WhileInvalidMaxItersSymbolicParamValue">Parameter ''{0}'' of the While Iterator block has a value of -1 specified using a Simulink.Parameter object, which is not supported in the generated code. For unlimited iterations, specify the ''{0}'' parameter using numeric constant ''-1''.</entry>
    <entry key="WhileInvalidMaxItersParamWithOutputPortOn">The While Iterator block is configured to output iteration number of type {0} in ''{1}'' mode. Under this configuration, the parameter ''{2}'' of the While Iterator block must evaluate to a scalar integer either with value of -1 or within the range from {3} to {4}.</entry>
    <entry key="WhileInvalidMaxItersParamWithOutputPortOff">The While Iterator block is configured to operate in ''{0}'' mode. Under this configuration, the parameter ''{1}'' of the While Iterator block must evaluate to a scalar integer either with value of -1 or within the range from {2} to {3}.</entry>
    <entry key="WideSignalsNotConsistent">Nonscalar input and output signals of block ''{0}'' are inconsistent.</entry>
    <entry key="WidthOverflow">''{0}''에 출력 오버플로가 발생했습니다. 지정된 출력 유형({2})을 사용하여 신호 너비({1,number,integer})를 표현할 수 없습니다.</entry>
    <entry key="BlockDoesNotSupportVB">구성 파라미터-&gt;진단-&gt;연결성-&gt;\"버스 신호가 벡터로 처리됨\" 진단이 \"오류\"로 설정되어 있으면 ''{0}'' 블록은 가상 버스 신호를 받을 수 없습니다. 가상 버스가 블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;에 연결되어 있습니다. 입력에서 Bus to Vector 블록을 사용하여 가상 버스를 벡터로 변환해 보십시오. 또는 입력에 \"출력\" 옵션을 \"비가상 버스\"로 설정한 Signal Conversion 블록을 삽입하여 가상 버스를 비가상 버스로 변환해 보십시오.</entry>
    <entry key="InvalidVirtualBusUsageSelector">Selector block does NOT support virtual bus input signals. It can only accept vector/matrix/multidimensional non-bus signals or arrays of nonvirtual bus signals.\n\nA virtual bus signal is connected to &lt;sldiag objui="inport" objparam="{0, number, integer}" objname="{1}"&gt;input port {0, number, integer}&lt;/sldiag&gt; of Selector block ''{1}''. To correct this error, please consider one of the following options: \n\n(1) If the input virtual bus signal consists only of scalar elements, 1-D elements, or either row or column vectors, and all elements have the same data type, signal type, and sampling mode, convert the bus signal into a vector using a Bus to Vector block. \n(2) Otherwise, replace the Selector block with a Bus Selector block. </entry>
    <entry key="InvalidVirtualBusUsageDelay">Delay block does not support virtual bus input signals when its ''State name'' field is specified and its ''Initial condition'' is of struct type or a zero scalar from dialog, or its ''Initial condition'' is from an input port. The block accepts only vector/matrix/multidimensional non-bus signals or arrays of nonvirtual bus signals.\n\nA virtual bus signal is connected to &lt;sldiag objui="inport" objparam="{0, number, integer}" objname="{1}"&gt;input port {0, number, integer}&lt;/sldiag&gt; of Delay block ''{1}''. To correct this error, consider converting the bus signal into a vector using a Bus to Vector block.</entry>
    <entry key="InvalidVirtualBusUsageOther">{0} block does NOT support virtual bus input signals. It can only accept vector/matrix/multidimensional non-bus signals or arrays of nonvirtual bus signals.\n\nA virtual bus signal is connected to &lt;sldiag objui="inport" objparam="{1, number, integer}" objname="{3}"&gt;input port {1, number, integer}&lt;/sldiag&gt; of {2} block ''{3}''. To correct this error, please consider converting the bus signal into a vector using a Bus to Vector block.</entry>
    <entry key="InvalidVirtualBusUsageSuggestUA">위에 보고된 가상 버스 사용 오류가 모델에서 총 {0, number, integer}번 발생했습니다. \n\n모델을 자동으로 업데이트하고 Bus to Vector 블록을 삽입하려는 경우 또는 이전 Simulink 버전에서 업그레이드하는 중인 경우 다음을 수행하십시오.\n(1) {1} 및 ''블록에 대한 가상 버스 입력 검사''를 실행합니다. \n(2) 이 검사의 권장 사항을 따라 모델을 호환되도록 설정하십시오.</entry>
    <entry key="a0EqualOneCheckboxSelect">''{0}''에서 ''선행 분모 계수(a0)로 나누기를 건너뜀으로써 최적화'' 체크박스를 선택해야 합니다.</entry>
    <entry key="a0MustBeNonZero">''{0}''에서 선행 분모 계수는 0이 아니어야 함</entry>
    <entry key="a0MustBeOne">''{0}''에서 선행 분모 계수는 1이어야 함</entry>
    <entry key="DisallowSIMOInFrameBasedProcessing">''{0}''에서 '입력 처리' 파라미터가 '열을 채널로(프레임 기반)'로 설정되어 있으면 필터 계수는 스칼라이거나 행 벡터여야 함</entry>
    <entry key="a0MustBeReal">출력값이 고정소수점인 경우 또는 모델 파라미터 MinMaxOverflowLogging에 '' MinMaxAndOverflow''가 지정된 경우, 또는 고정소수점 툴에서 ''데이터형 재정의''에 ''스케일링된 double형''이 선택된 경우 ''{0}''의 선행 분모 계수는 실수여야 합니다</entry>
    <entry key="denOrderGTEnumOrder">''{0}''에서 분모의 차수는 분자의 차수보다 크거나 같아야 함</entry>
    <entry key="unsupportedStructure">''{0}''에서 전달 함수 구조는 'Direct form II'여야 함</entry>
    <entry key="dialogDTMustBeFixpt">''{0}''에서 ''데이터형 특성'' 탭에 지정된 데이터형은 부동소수점일 수 없습니다. 데이터형 표현식을 사용하여 데이터형을 지정하려면 해당 표현식이 고정소수점 데이터형으로 평가되어야 합니다.</entry>
    <entry key="invalidIntermediateDtypeWL">Invalid word length for ''Intermediate results data type'' in block ''{0}''. It needs at least 4 bits.</entry>
    <entry key="CannotEnsureRTBControlDWTypeAtomic">Control flags used by Rate Transition block ''{0}'' may not be atomic because model's ''Number of bits per char in test hardware'' ({1,number,integer}) configuration parameter is not 8, 16, or 32. The next largest data type that is multiple of 8 has been chosen.</entry>
    <entry key="MultiCoreRateTransNotSupportedInRightClickBuild"> Rate Transition block ''{0}'' is in a mode to support concurrent tasks. This mode is not supported for right click build. </entry>
    <entry key="sigLicenseFailed">'입력 처리' 파라미터가 '열을 채널로(프레임 기반)'로 설정되어 있고 필터 구조가 디폴트 값으로 설정되지 않은 경우 ''{0}''에 DSP System Toolbox 라이선스가 필요합니다.</entry>
    <entry key="inNotSampForElemChan">''{0}'' 블록에 대한 입력이 프레임 기반 신호인 경우 '입력 처리' 파라미터를 '열을 채널로(프레임 기반)'로 설정해야 합니다.</entry>
    <entry key="fvtoolCoefficientsPortIIR">''분자 소스'' 또는 ''분모 소스''가 ''입력 포트''로 설정된 경우 필터 응답을 계산할 수 없습니다. \n 필터 응답을 보려면 ''분자 소스'' 및 ''분모 소스'' 파라미터를 ''대화 상자''로 설정하십시오.</entry>
    <entry key="fvtoolCoefficientsPortFIR">''계수 소스''가 ''입력 포트''로 설정된 경우 필터 응답을 계산할 수 없습니다. \n 필터 응답을 보려면 ''계수 소스'' 파라미터를 ''대화 상자 파라미터''로 설정하십시오.</entry>
    <entry key="prodInvTempMtx">유효하지 않은 임시 행렬 인덱스임</entry>
    <entry key="prodResultInOutputPortBuff">체인의 마지막 항목이 출력 포트 버퍼에 결과를 배치해야 함</entry>
    <entry key="BusInputNotAllowed"> Block ''{0}'' does not support nonvirtual bus input signals when you select the 'Allow different data input sizes (Results in variable-size output signal)' parameter.</entry>
    <entry key="PreLookupComparisonDataTypeIsNotIdeal">In block ''{0}'',  there is no ideal comparison data type which can exactly represent both input and breakpoint data. Please change either the input data types or the breakpoint data types.</entry>
    <entry key="PreLookupBadParamValue">블록 ''{0}''에 대한 절점 데이터가 유효하지 않습니다. 데이터는 너비가 1보다 큰, 1차원의 유한한 실수 숫자형 벡터여야 합니다</entry>
    <entry key="LookupBadParamValue">블록 ''{0}''의 차원({1,number,integer})에 유효하지 않은 절점 데이터가 있습니다. 데이터는 너비가 1보다 큰, 1차원의 유한한 실수 숫자형 벡터여야 합니다.</entry>
    <entry key="PreLookupCannotAnalyzeBpMsg">블록 ''{0}''에 지정된 절점 세트를 인덱스 탐색으로 분석할 수 없습니다.</entry>
    <entry key="PreLookupExtrapMethodError">Block ''{0}'' has parameter ''Extrapolation method'' set to 'Linear'. This setting is supported only when the input, breakpoint, and fraction output are all floating-point data types and the index data type specifies a built-in integer. Consider setting ''Extrapolation method'' to 'Clip'.</entry>
    <entry key="PreLookupFractionOverflow">Block ''{0}'' has been assigned an invalid ''Fraction data type''.\nIf parameter ''{1}'' is ''off'', when specifying a signed data type,''Fraction length'' must be less than or equal to ''Word length'' minus 2. When specifying an unsigned data type, the ''Fraction length'' must be less than or equal to the ''Word length'' minus 1.\nIf parameter ''{2}'' is ''on'',  when specifying a signed data type, ''Fraction length'' must be less than or equal to ''Word length'' minus 1. When specifying an unsigned data type, the ''Fraction length'' must be less than or equal to ''Word length''.\nChange the ''Fraction length'' to {3,number,integer} or less to prevent the error.</entry>
    <entry key="PreLookupInvalidBpBoolType">{0}은(는) ''boolean'' 절점 데이터형을 허용하지 않습니다. ''{1}''의 절점 데이터형은 Simulink에 내장된 ''uint8'', ''uint16'', ''uint32'', ''int8'', ''int16'', ''int32'', ''single'' 또는 ''double'' 중 하나이거나 고정소수점 데이터형 중 하나여야 합니다.</entry>
    <entry key="PreLookupNearestUAndBpDataTypeMismatch">The breakpoint data type of block ''{0}'' does not match the corresponding input data type. When interpolation method is ''{1}'', the breakpoint and input data types must match. To fix this error, change the breakpoint data type to ''Inherit: Same as corresponding input''.</entry>
    <entry key="LUTObjNearestUAndBpDataTypeMismatch">The breakpoint data type of block ''{0}'' does not match the corresponding input data type. When interpolation method is ''{1}'', the breakpoint and input data types must match. To fix this error, change the breakpoint data type to be same as the corresponding input data type.</entry>
    <entry key="LUTObjectReferencedBPObjectMismatch">The Simulink.Breakpoint object used in block ''{0}'' is not the same as the Simulink.Breakpoint object referenced by the Simulink.LookupTable object used in block ''{1}''.</entry>
    <entry key="PrelookupInvalidBreakpointsSpecification">The Simulink.LookupTable object used in block ''{0}'' refers to a Simulink.Breakpoint object. Therefore, block ''{1}'' must set 'BreakpointsSpecification' to 'Breakpoint object' and use the same Simulink.Breakpoint object.</entry>
    <entry key="PreLookupInvalidBpTypeBias">The input and breakpoint data types of block ''{0}'' do not have the same bias. The breakpoint data type has a bias of {1} and the input data type has a bias of {2}.</entry>
    <entry key="PreLookupInvalidBpTypeSetting">''{0}''의 입력 및 절점 데이터형이 호환되지 않습니다.</entry>
    <entry key="PreLookupInvalidBpTypeSlope">The input and breakpoint data types of block ''{0}'' do not have the same SlopeAdjustmentFactor. The breakpoint data type has a SlopeAdjustmentFactor of {1} and the input data type has a SlopeAdjustmentFactor of {2}.</entry>
    <entry key="PreLookupInvalidExtrapMethod">For ''{0}'' block, when ''Extrapolation method'' is set to ''Linear'', the ''Output selection'' must be set to ''Index and fraction'' or ''Index and fraction as bus''.</entry>
    <entry key="PreLookupInvalidFractionDataType">''{0}'' has been assigned an invalid ''Fraction data type''. Fraction data type only supports ''Binary-point-only'' scaling mode. Also, the ''Fraction length'' must be greater than or equal to zero.</entry>
    <entry key="PreLookupInvalidFractionSetting">''{0}'' has incompatible input and fraction data types.</entry>
    <entry key="PreLookupInvalidIndexDataType">''{0}'' has been assigned an invalid index data type. The index must be an integer.</entry>
    <entry key="PreLookupInvalidIndexType">The specified index data type of ''{0}'' cannot represent the index range of the breakpoint data set.</entry>
    <entry key="PreLookupNonBooleanMsg">The breakpoints data of ''{0}'' does not support Boolean data type.</entry>
    <entry key="PreLookupNonFloatIndexType">블록 ''{0}''은(는) 인덱스에 double형 또는 single형을 지원하지 않습니다.</entry>
    <entry key="PreLookupNonMonotonicErr">''{1}''에서 ''{0}''의 값은 순단조(Strictly Monotonic) 증가해야 합니다. 요소 {2,number,integer}에서 문제가 발생했습니다. 절점 데이터를 변경하거나, 자동 스케일링 또는 고정소수점 어드바이저 같은 고정소수점 툴을 사용하여 다른 파라미터 대화 상자 유형을 확인하십시오.</entry>
    <entry key="PreLookupEnumNonMonotonicErr">Values of ''{0}'' in ''{1}'' must be strictly monotonically increasing. For enumerated breakpoints data, if the ''Index search method'' is 'Linear' and the ''Begin index search using previous index result'' check box is selected, the breakpoints data must be strictly monotonically increasing. The values become not strictly monotonically increasing at element {2,number,integer}. Change the breakpoints data or clear the "Begin index search using previous index result" parameter.</entry>
    <entry key="PreLookupOutOfRangeRemoveInputProtectionChecked">''{0}''의 입력값이 절점 범위 ''{1}''을(를) 초과합니다. 이로 인해, '입력값이 범위 내에 있다고 가정' 옵션이 선택된 경우 생성 코드에 정의되지 않은 동작이 발생할 수 있습니다. 이 동작을 방지하려면 생성 코드를 실행하기 전에 입력 값을 절점 범위 내에 있도록 변경하십시오.</entry>
    <entry key="PreLookupOutofRangeInputError">''{0}''의 입력값이 절점 범위를 초과합니다.</entry>
    <entry key="EnforcePreLookupOutofRangeInputError">''{0}''의 입력값이 절점 범위를 초과합니다. '입력값이 범위 내에 있다고 가정' 파라미터를 선택 해제하거나 입력값을 테이블 차원의 범위 내에 있도록 제한하십시오.</entry>
    <entry key="PreLookupOutofRangeInputWarn_Clip">블록 ''{0}''의 입력이 절점 데이터 범위를 초과합니다. 입력이 해당 범위로 잘리고 시뮬레이션이 계속됩니다.</entry>
    <entry key="PreLookupOutofRangeInputWarn_Extrap">블록 ''{0}''의 입력이 절점 데이터 범위를 초과합니다. 범위 밖으로 외삽되고 시뮬레이션이 계속됩니다.</entry>
    <entry key="UdtEmptyDataTypeInBus">요소 ''{0}''의 string형은 비어 있을 수 없음</entry>
    <entry key="AlgorithmDescriptorInternalErrorAlgorithmNameInvalid">''{0}'' 블록 '알고리즘 이름' ''{1}''은(는) 영숫자만 포함해야 합니다.</entry>
    <entry key="AlgorithmDescriptorInternalErrorAlgorithmParameterNameInvalid">''{0}'' 블록 '알고리즘 파라미터 이름 {1,number,integer}' ''{2}''은(는) 영숫자만 포함해야 합니다.</entry>
    <entry key="AlgorithmDescriptorInternalErrorAlgorithmParameterValueInvalid">''{0}'' 블록 '알고리즘 파라미터 값 {1,number,integer}' ''{2}''은(는) 영숫자만 포함해야 합니다.</entry>
    <entry key="AlgorithmDescriptorInternalErrorReferencedBlockNotValidSource">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 연결된 블록은 Inport 블록 또는 Data Store Read 블록이어야 합니다.</entry>
    <entry key="AlgorithmDescriptorInternalErrorReferencedBlockNotValidDestination">블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결된 블록은 Outport 블록 또는 Data Store Write 블록이어야 합니다.</entry>
    <entry key="AlgorithmDescriptorInternalErrorReferencedBlockNotAtCorrectGraphicalLevel">''{0}'' 블록과 지정된 블록 ''{1}''은(는) 동일한 계층 수준에 있어야 합니다.</entry>
    <entry key="AlgorithmDescriptorInternalErrorReferencedBlockNotFound">지정된 블록 ''{1}''이(가) ''{0}'' 블록에서 발견되지 않았습니다. ''{1}''은(는) 블록 ''{0}''에 상대적인 유효 블록 경로여야 합니다. 계층의 하위를 나타내려면 '/'를 사용하십시오.</entry>
    <entry key="AlgorithmDescriptorInternalErrorReferencedParameterNotFound">''{0}'' 블록에서 블록 ''{2}''의 지정된 파라미터 ''{1}''은(는) 유효한 프로그래밍 방식 파라미터 이름이어야 합니다.</entry>
    <entry key="AlgorithmDescriptorInternalErrorRTPDoesNotExist">For ''{0}'' block, parameter ''{1}'' of block ''{2}'' not supported because the corresponding run-time parameter (RTP) could not be found.</entry>
    <entry key="AlgorithmDescriptorInternalErrorStateDoesNotExist">For ''{0}'' block, state of block ''{1}'' must be registered.</entry>
    <entry key="AlgorithmDescriptorInternalErrorBlockNotAllowedInSubsystem">Block ''{0}'' is not supported inside Algorithm Descriptor subsystems.</entry>
    <entry key="AlgorithmDescriptorInternalErrorParentSSNotAtomic">Subsystem ''{0}'' must be atomic when it contains ''{1}''.</entry>
    <entry key="AlgorithmDescriptorUnsupportedSampleTime">Subsystem block containing block ''{0}'' supports only discrete, constant, triggered and asynchronous sample times.</entry>
    <entry key="AlgorithmDescriptorSupportsOnlySingleRateSampleTime">Subsystem block containing block ''{0}'' supports only single-rate sample time.</entry>
    <entry key="AlgorithmDescriptorInternalErrorParentNotSS">Block ''{0}'' must be inside an atomic subsystem.</entry>
    <entry key="UdtInvBuiltinInBus">Built-in data type ''{0}'' is not allowed for element ''{1}''</entry>
    <entry key="UdtInvBuiltinInBusWithSuggestion">
      Data type ''{0}'' is not allowed for element ''{1}''
               &lt;actions exclusiveFixIts="no"&gt;
               &lt;action type="fixit"&gt;
               &lt;cmd&gt;sl('busUtils','resetprelookupbusindexdatatypefordtoprotection', ''{2}'', ''{3}'')&lt;/cmd&gt;
               &lt;txt&gt;This may have been caused by data type overriding(DTO). The first signal of the bus must remain integer. To protect it against DTO, consider redefining the signal type to a fixed point type with zero fraction length and DTO mode 'off'.&lt;/txt&gt;
               &lt;/action&gt;
               &lt;/actions&gt;
      
    </entry>
    <entry key="UdtInvNoDataTypeOverrideForIndexInVirtualBus">''{0}''의 출력으로 지정된 버스의 첫 번째 신호에는 정수가 아닌 내장 데이터형을 사용할 수 없습니다. 데이터형 재정의를 통해 이 버스가 생성된 경우, 소수부 길이가 0이고 데이터형 재정의가 ''끄기''로 설정된 고정소수점 데이터형으로 신호를 정의하십시오. </entry>
    <entry key="UdtInvInheritInBus">요소 ''{1}''에는 상속 규칙 ''{0}''이(가) 허용되지 않음</entry>
    <entry key="UdtNoEnumInBus">Enumerated data type is not allowed for element ''{0}'' of bus ''{1}''</entry>
    <entry key="UdtInvEnumNameInBus">요소 ''{1}''의 열거 데이터형 이름 ''{0}''이(가) 유효하지 않음</entry>
    <entry key="UdtNoBusInBus">Bus data types are not allowed for element ''{0}'' of bus ''{1}''</entry>
    <entry key="UdtInvBusNameInBus">요소 ''{1}''의 버스 데이터형 이름 ''{0}''이(가) 유효하지 않음</entry>
    <entry key="UdtInvFixdtInBus">고정소수점 데이터형 ''{0}'' 표현식에 요소 ''{1}''에 대한 잘못된 구문이 있음</entry>
    <entry key="InterpInvalidInputBus">Bus object ''{0}'' specified at &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;input port {1,number,integer}&lt;/sldiag&gt; of block ''{2}'' is invalid.</entry>
    <entry key="InterpInvalidInputVirtBusNoName">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 지정된 버스 신호가 유효하지 않습니다.</entry>
    <entry key="PreLookupInvalidOutputBus">Bus object ''{0}'' specified at output port of Prelookup block ''{1}'' is invalid. Prelookup block only supports bus output with bus objects consisting of two non-bus signals. The data type of the first (index) and the second (fraction) signal in the bus is respectively subject to the same restrictions imposed on individual index and fraction signals (block parameters ''{2}'' and ''{3}''). For more details on these restrictions, refer to the documentation for Prelookup block.</entry>
    <entry key="InterpInputBusWrongNumberOfElements">Bus object ''{0}'' can have only two elements and each element must be scalar.</entry>
    <entry key="InterpInputBusHasBusElements">&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; of block ''{1}'' connects to a bus signal composed of bus signals. The block input expects a bus signal composed of two non-bus signals.</entry>
    <entry key="InterpRequiresBusSignal">The signal connected to &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of ''{1}'' must be a bus signal when the ''{2}'' checkbox is checked. Note that the port cannot be grounded or unconnected when the ''{2}'' checkbox is checked.</entry>
    <entry key="InterpRequiresNonBusSignal">''{2}'' 체크박스를 선택하지 않은 경우 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에 연결된 신호는 버스 신호여서는 안 됩니다.</entry>
    <entry key="PreLookupOutputBusWrongNumberOfElements">Bus object ''{0}'' can have only two elements.</entry>
    <entry key="PreLookupOutputBusElementIsABus">Element ''{0}'' in bus object ''{1}'' is itself a bus. Bus object ''{1}'' can have only non-bus elements.</entry>
    <entry key="PreLookupBusObjectComplex">Element ''{0}'' in bus object ''{1}'' is complex. Prelookup block only supports real signals.</entry>
    <entry key="InterpInputBusElementIsABus">Element ''{0}'' in bus object ''{1}'' is itself a bus. Bus object ''{1}'' can have only non-bus elements.</entry>
    <entry key="BreakpointsSpacingNoBias">In block ''{0}'', breakpoint spacing data type has a non-zero bias in dimension {1, number, integer}, which is not supported </entry>
    <entry key="BreakpointsSpacingLargerThanZero">In block ''{0}'', value of breakpoint spacing is less than or equal to zero in dimension {1, number, integer} of Simulink.Lookuptable object ''{2}''. Change the breakpoint spacing to a positive value. </entry>
    <entry key="PrelookupBreakpointsSpacingNoBias">In block ''{0}'', breakpoint spacing data type has a non-zero bias, which is not supported </entry>
    <entry key="PreLookupBreakpointsSpacingDoesNotFitInDerivedDatatype">In block ''{0}'', data type ''{2}'' cannot represent parameter ''{1}''. The data type for ''{1}'' is internally computed as the unsigned version of the breakpoint data type with zero bias. The value of ''{1}'' must fit in data type ''{2}'' to the last precision bit. Either change the breakpoint data type or the breakpoint spacing value.</entry>
    <entry key="PreLookupArrayofBusDoesnotSupportJacobian">Block ''{0}'' must not have array of buses as output to run model linearization, select separate index and fraction outputs if input is not a scalar.</entry>
    <entry key="LookupNdBreakpointsSpacingDoesNotFitInDerivedDatatype">In block ''{0}'', data type ''{1}'' cannot represent breakpoint spacing. The data type ''{1}'' is internally computed as the unsigned version of the breakpoint data type with zero bias. The value of breakpoints spacing for dimension {2,number,integer} must fit in data type ''{1}'' to the last precision bit. Either change the breakpoint data type or the breakpoint spacing value.</entry>
    <entry key="LookupNdBreakpointsValueOutOfRange">In block "{0}", the breakpoint data type specified for dimension {1, number, integer} cannot represent all generated breakpoints. Consider changing the data type or the even spacing parameters to generate these breakpoints.</entry>
    <entry key="PreLookupBreakpointsValueOutOfRange">In block ''{0}'', the range of the breakpoint data type specified is not large enough to represent all breakpoints</entry>
    <entry key="PreLookupBreakpointsNumPointsInvalid">In block ''{0}'', the number of breakpoints must be an unsigned integer value greater than or equal to 2 and less than maximum of unsigned 32 bit integer.</entry>
    <entry key="GetInternalDataTypeAPIInvalidParameter">Simulink.Block.getInternalDataType does not support parameter ''{0}'' in block ''{1}''. For a list of supported blocks and parameters, see the Simulink.Block.getInternalDataType reference page.</entry>
    <entry key="GetInternalDataTypeAPILUTOnlySupportCompiled">n-D Lookup Table 블록은 ''컴파일됨'' 모드만 지원합니다.</entry>
    <entry key="GetInternalDataTypeAPIPutModelToCompilation">모드가 ''컴파일됨''으로 설정된 경우 모델은 컴파일 단계에 있습니다.</entry>
    <entry key="SecondOrderIntegrator_ContAttrInconsistentArrayDimension">''상태 이름'' 파라미터 중에서 한 파라미터의 배열 요소 개수가 다른 파라미터와 다릅니다. 모든 ''상태 이름'' 파라미터는 배열 요소 개수가 같아야 합니다.</entry>
    <entry key="SecondOrderIntegrator_ContAttrInconsistentCharArrayDimension">''상태 이름'' 파라미터 ''{0}''에 대한 문자형 배열이 두 개 이상의 차원을 갖습니다. 문자형 배열은 문자형 벡터로 처리되기 때문에 차원을 한 개만 가져야 합니다.</entry>
    <entry key="SecondOrderIntegrator_ContAttrInvalidType">x ''{0}''의 ''상태 이름'' 파라미터 유형은 ''{1}''이지만, dx/dt ''{2}''의 ''상태 이름'' 파라미터 유형은 ''{3}''입니다. 모든 ''상태 이름'' 파라미터는 유형이 동일해야 하고, string형, 셀형 또는 문자형 배열이어야 합니다.</entry>
    <entry key="SecondOrderIntegrator_ContAttrNotStringOrCellOrCharArray">모든 ''상태 이름'' 파라미터는 유형이 동일해야 하고, string형, 셀형 또는 문자형 배열이어야 합니다.</entry>
    <entry key="SecondOrderIntegrator_ContAttrOnlyxORdxIsSet">''상태 이름'' 파라미터 중 한 개만 지정되었습니다. 모든 상태 이름을 지정하거나 지정하지 마십시오.</entry>
    <entry key="SecondOrderIntegrator_ContAttrMissingStringSpecified">''상태 이름'' 파라미터 중 한 개가 하나 이상의 누락값인 string형으로 지정되었습니다. 상태 이름에는 누락값인 string형을 사용할 수 없습니다. </entry>
    <entry key="SecondOrderIntegrator_ICDXDTIgnored">For the block ''{0}'', element {1,number,integer} of state x is saturated at time {2}; whereas, the initial condition for the state dx/dt is {3}. Consequently, the block states are mathematically inconsistent and dx/dt will be initialized to zero. If this behavior is unexpected, ensure that the sign of the initial condition for dx/dt allows x to leave the saturation. You can turn off this warning by using the MATLAB command: warning(''off'', ''Simulink:blocks:SecondOrderIntegrator_ICDXDTIgnored'')</entry>
    <entry key="ContinuousIntegrator_InconsistentParameterOrPortWidth">Either the parameter widths or port widths associated with block ''{0}'' are inconsistent.</entry>
    <entry key="SecondOrderIntegrator_Invalid_dxdt_Bounds">dx/dt의 상한과 하한에 의해 정의된 구간에 0이 없습니다. x가 포화된 경우 x의 도함수는 0이어야 하고, x가 포화 상태를 벗어나도록 하려면 도함수가 영점을 교차해야 합니다. 따라서 dx/dt의 제한이 0이 아니고 구간에 0이 포함되도록 제한을 조정하십시오.</entry>
    <entry key="SecondOrderIntegrator_SizeOverflow">블록 ''{0}''에서 요청한 메모리가 최대 제한인 32비트 정수를 초과할 것으로 예상됩니다. 따라서 메모리를 할당할 수 없습니다.</entry>
    <entry key="CheckPWLBound_LogWriteError">The ''{0}'' block could not pass the logged data to MATLAB.</entry>
    <entry key="invalidblocktype">연결 포트가 아닙니다.</entry>
    <entry key="CrossCorrelationReplacement">The Cross Correlation scope ''{0}'' should be replaced with a new version from the simulink_extras block library.</entry>
    <entry key="OutportOverwritesSignalObjectIC">The ''Initial output'' parameter of Outport block ''{0}'' has been explicitly specified. Therefore, the initial value being specified by the signal object on its signal line will not be honored.
    
             &lt;actions exclusiveFixIts="yes"&gt;
             &lt;action type="fixit"&gt;
             &lt;cmd&gt;set_param(''{0}'', ''InitialOutput'',''[]'')&lt;/cmd&gt;
             &lt;txt&gt;To avoid this diagnostic, Use ''[]'' as Initial output.&lt;/txt&gt;
             &lt;/action&gt;
             &lt;action type="suggestion"&gt;
             &lt;txt&gt;Alternatively, set ''[]'' as the value for the 'InitialValue' field of the Simulink.Signal object specified on the input signal of the Outport block.&lt;/txt&gt;
             &lt;/action&gt;
             &lt;/actions&gt;
    
    </entry>
    <entry key="WarnSigObjWithICOutsideOutport">Signal 객체 ''{0}''이(가) 명시적 초기값을 갖지만 서브시스템 ''{1}'' 외부에 지정되어 있습니다. 이 경우 Signal 객체의 초기값이 무시됩니다. 초기값이 사용되도록 하려면 지정된 Signal 객체를 서브시스템 ''{1}'' 안으로 옮기십시오. </entry>
    <entry key="WarnSigObjWithICIgnoredDefaultIC">Outport 블록 ''{0}''은(는) Signal 객체 ''{1}''에서 제공하는 초기값을 사용하지 않습니다. 하나 이상의 다른 소스에서 유효한 초기 조건을 제공하지 않기 때문입니다. 따라서 Outport 블록은 디폴트 초기값 0을 가져옵니다. </entry>
    <entry key="SigObjWithICFoundOnVirtualOutport">초기값이 입력 신호 선으로 정의되는 Signal 객체가 Outport 블록 ''{0}''에 있습니다. 이 같은 상황이 발생하는 경우 신호가 Signal 객체에서 올바로 초기값을 가져오도록 하기 위해 Simulink는 버퍼를 삽입해야 합니다. 그러나 Outport 블록 ''{0}''의 체크박스 ''가상 아웃포트여야 함''이 켜기로 설정되어 있기 때문에, Simulink가 입력에 버퍼를 삽입할 수 없습니다. 이 문제를 해결하려면 파라미터 ''가상 아웃포트여야 함''을 끄거나 입력에서 Signal 객체의 InitialValue 필드를 ''''로 설정하십시오. </entry>
    <entry key="SigObjWithICRootOutportExpFcnMdl">초기값이 입력 신호 선으로 정의되는 Signal 객체가 루트 Outport 블록 ''{0}''에 있습니다. 이 같은 상황에서 Simulink는 올바른 초기화를 보장하기 위해 버퍼를 삽입해야 합니다. 그러나 함수 내보내기 모델이기 때문에 루트 수준에서 버퍼를 삽입할 수 없습니다. 이 문제를 해결하려면 지정된 Signal 객체를 Inner Subsystem으로 옮기거나 Signal 객체의 InitialValue 필드를 ''''로 설정하십시오. </entry>
    <entry key="WarnMergeOverwriteSignalObjectICParam">단순 방식 초기화 모드에서 더이상 Signal 객체를 사용하여 Merge 블록 ''{0}''의 ''초기 출력'' 파라미터를 지정할 수 없습니다. Signal 객체를 사용하여 Merge 블록의 입력 신호 또는 출력 신호를 초기화할 수는 있지만, 그 초기화 결과를 Merge 블록의 초기화 결과가 덮어쓸 수 있습니다.&lt;actions exclusiveFixIts="no"&gt;&lt;action type="suppression"&gt;&lt;/action&gt;&lt;/actions&gt;</entry>
    <entry key="InportOutportNameConflict">멤버 블록의 인포트와 아웃포트 간에 이름 충돌이 있음</entry>
    <entry key="InvalidWrapperMode">유효하지 않은 래퍼 모드임</entry>
    <entry key="InvalidIOSignalCellArrayDimension">IO 신호의 셀형 배열은 3개 이상의 차원을 가질 수 없음</entry>
    <entry key="InvalidIOSignalCellArray">IO 신호의 셀형 배열은 열 벡터이거나 행 벡터여야 함</entry>
    <entry key="IOSignalCellArrayLengthMismatch">IO 신호의 셀형 배열 길이는 IO 포트 수와 같아야 함</entry>
    <entry key="InvalidIOSignalCell">IO 신호 셀은 셀당 1개의 핸들을 가져야 함</entry>
    <entry key="InvalidConnPortConnection">''{0}'' 및 ''{1}''의 포트는 서로 호환되지 않기 때문에 이들 포트가 포함된 연결은 유효하지 않습니다.</entry>
    <entry key="BlockNameConflict">동일한 이름의 ''{2}''이(가) 이미 존재하므로 이름이 ''{1}''인 ''{0}''을(를) 추가할 수 없습니다. 이 충돌을 없애려면 라이브러리를 수정해야 합니다.</entry>
    <entry key="ConfigSubsysNotInModel">Configurable Subsystem을 사용하려면 모델에 배치해야 함</entry>
    <entry key="SubsysconfigInvalidArg">subsystem_configuration은 5가지 인수 즉, 'new', 'establish', 'reestablish', 'copy', 'update' 중 하나를 사용하여 호출해야 합니다.</entry>
    <entry key="SubsysNotALib">시스템 ''{0}''은(는) 라이브러리가 아니라 단일 블록임</entry>
    <entry key="LibraryNotFound">경로에서 라이브러리 ''{0}''을(를) 찾을 수 없음</entry>
    <entry key="MissingLibraryNameInModel">''{1}''에서 시스템 ''{0}''을(를) 찾을 수 없음</entry>
    <entry key="MuxedOutputPortWidthMustMatchSignalElementSrcDims">Bus Selector 블록 ''{1}''의 아웃포트 너비({0, number, integer})가 선택한 신호 너비({2, number, integer})의 합과 일치하지 않습니다.</entry>
    <entry key="UnitDelayCouldNotDefineBus">블록 ''{1}''이(가) 입력 포트로 Bus 객체 ''{0}''을(를) 지정했습니다. 그러나 이 블록의 입력은 Bus가 아닙니다. Bus 객체를 사용하려면 Signal Specification 블록을 이 블록의 입력에 연결하십시오. Signal Specification 블록에서 데이터형에 위 Bus 객체를 사용하십시오.</entry>
    <entry key="VariantSameInportName">Inport 블록 ''{0}'' 및 ''{1}''의 이름이 동일합니다. 블록 이름에서 공백 문자는 무시됩니다. Variant Subsystem 또는 Variant 선택지 블록의 경우, 포트 블록 이름에는 공백 문자가 제외된 고유 문자를 사용하십시오.</entry>
    <entry key="VariantModelBlockSameInportName">Variant 선택지 블록 ''{2}''의 {0, number, integer}번과 {1, number, integer}번 입력 포트의 이름이 동일합니다. 포트 이름에서 공백 문자는 무시됩니다. Variant 선택지 블록의 경우, 포트 이름에는 공백 문자가 제외된 고유 문자를 사용하십시오.</entry>
    <entry key="VariantSameOutportName">Outport blocks ''{0}'' and ''{1}'' have the same name, ignoring whitespace characters in block names. For a variant subsystem or a variant choice block, use port block names with unique characters excluding whitespace characters.</entry>
    <entry key="VariantModelBlockSameOutportName">Variant 선택지 블록 ''{2}''의 {0, number, integer}번과 {1, number, integer}번 출력 포트의 이름이 동일합니다. 포트 이름에서 공백 문자는 무시됩니다. Variant 선택지 블록의 경우, 포트 이름에는 공백 문자가 제외된 고유 문자를 사용하십시오.</entry>
    <entry key="VariantSameLeftConnPortName">Left connection port blocks ''{0}'' and ''{1}'' have the same name, ignoring whitespace characters in block names. For a variant subsystem or a variant choice block, use port block names with unique characters excluding whitespace characters.</entry>
    <entry key="VariantSameRightConnPortName">오른쪽 연결 포트 블록 ''{0}'' 및 ''{1}''의 이름이 동일합니다. 블록 이름에서 공백 문자는 무시됩니다. Variant Subsystem 또는 Variant 선택지 블록의 경우, 포트 블록 이름에는 공백 문자가 제외된 고유 문자를 사용하십시오.</entry>
    <entry key="SetModelVariantChoiceNotAllowedInVSS">이 Model 블록이 Variant Subsystem의 Variant 선택지이므로 ''{0}''의 [Variant] 파라미터를 ''켜기''로 설정하는 것은 허용되지 않습니다. 대신 여러 개의 Model 블록이 포함된, ''{1}''의 Variant Subsystem 선택지 블록을 만들 수 있습니다. </entry>
    <entry key="UniqueName">''{0}''이(가) 이미 존재합니다. 고유한 이름을 지정하십시오.</entry>
    <entry key="UnitConversionError"> Unit Conversion 블록 ''{0}''이(가) 변환 인자를 계산하는 중 오류를 감지했습니다.</entry>
    <entry key="UnitConversionTypeMismatch"> Unit Conversion block ''{0}'' determined output port data type to be ''{1}'', but the propagated data type  is ''{2}''. Consider changing 'Output data type' parameter to 'Inherit: Inherit via back propagation'.</entry>
    <entry key="InvalidBlockMaskForCompositionSubDomain">마스크 처리된 블록을 아키텍처 모델의 컴포넌트로 변환할 수 없습니다.</entry>
    <entry key="NonCompositePortBlockNotValidForCompositionSubDomain">Inport and Outport blocks cannot be added to an architecture model. Use In Bus Element and Out Bus Element blocks instead.</entry>
    <entry key="InvalidBlockTypeForCompositionSubDomain">''{0}'' 유형의 블록은 아키텍처 모델에 추가할 수 없습니다.</entry>
    <entry key="InvalidBlockServiceComponentForAutosarAdaptiveComposition">AUTOSAR 서비스 컴포넌트는 AUTOSAR 적응형 아키텍처 모델에 추가할 수 없습니다.</entry>
    <entry key="InvalidBlockTypeForActivityDiagram">Unable to add block type ''{0}'' to activity models.</entry>
    <entry key="InvalidBlockAddedToAdapterSubDomain">Block of type ''{0}'' cannot be added to an Adapter block.</entry>
    <entry key="InvalidBlockAddedToMergeSubDomain">Block of type ''{0}'' cannot be added to a Merge component.</entry>
    <entry key="InvalidCrossDomainSubsystemForCompositionSubDomain">A {0} subsystem cannot be converted to a component in an architecture model.</entry>
    <entry key="InvalidSubsystemConversionAttemptForCompositionSubDomain"> Component ''{0}'' in an architecture model cannot be converted into an atomic subsystem.</entry>
    <entry key="InvalidCrossDomainComponentForSimulinkSubDomain">An architecture component cannot be converted to a block in a Simulink model.</entry>
    <entry key="NonEmptyVirtualSubsystemForCompositionSubDomain">A non-empty subsystem cannot be converted to a component in an architecture model.</entry>
    <entry key="InvalidMaskForCompositionSubDomain">마스크 처리된 블록을 아키텍처 모델의 컴포넌트로 변환할 수 없습니다.</entry>
    <entry key="DataPortNotAllowedForCompositionSubDomain">Block of type ''{0}'' cannot be added to architecture ''{1}''. Use Bus Element Ports.</entry>
    <entry key="CannotDisableScheduleRatesInSWArch">소프트웨어 아키텍처에서는 컴포넌트 ''{0}''의 ScheduleRates 파라미터를 ''off''로 설정할 수 없습니다.</entry>
    <entry key="CannotChangeScheduleRatesWithInSWArch">소프트웨어 아키텍처에서는 컴포넌트 ''{0}''의 ScheduleRatesWith 파라미터를 변경할 수 없습니다.</entry>
    <entry key="ConnectionPortBlockCannotBeAddedAtArchitectureTopLevel">모델 ''{0}''의 루트 아키텍처에 물리적 포트를 추가할 수 없습니다.</entry>
    <entry key="ConvertToVariantUnsupportedInArchitectureModel">Simulink.VariantUtils.convertToVariantSubsystem is not supported for architecture models. Use systemcomposer.arch.Component.makeVariant instead to convert a component into a variant choice.</entry>
    <entry key="bufferOutDimBufSizeMismatch">''{0}''에서 오류 발생: 아웃포트 차원을 전파하는 중 오류가 발생했습니다.</entry>
    <entry key="bufferFrmSizeSpecMismatch">''{0}''에서 오류 발생: 출력 프레임 크기가 블록 대화 상자에 지정된 내용과 일치하지 않습니다.</entry>
    <entry key="bufferOverlapTooBig">''{0}''에서 오류가 발생함: 버퍼 중첩이 버퍼 크기보다 작아야 합니다.</entry>
    <entry key="bufferSampTimeNotDiscreteNonConst">''{0}''에서 오류가 발생함: 모든 샘플 시간은 이산 시간이어야 합니다. 연속 또는 상수 샘플 시간은 허용되지 않습니다.</entry>
    <entry key="bufferSampTimeAtDFBoundary">Automatic buffering at dataflow input ports to match required input sizes is not supported for ''{0}'' because the signal at &lt;sldiag objui="inport" objparam="{1, number, integer}" objname="{2}"&gt;input port {1, number, integer}&lt;/sldiag&gt; of block ''{2}'' has continuous or constant sample time. Adjust the frames sizes of the input signals to match the calculated frame sizes.</entry>
    <entry key="bufferUnderlapNotSupported">Error in ''{0}'':Underlap is not supported when unbuffering.</entry>
    <entry key="bufferUnderlapNotSupportFrm">Error in ''{0}'': Underlap is not supported for frame-based inputs.</entry>
    <entry key="bufferInitCondWrongDims">''{0}''에서 오류 발생: 초기 조건 벡터의 차원이 잘못되었습니다.</entry>
    <entry key="bufferChansInNotChanOut">''{0}''에서 오류 발생: 입력의 채널 수는 출력의 채널 수와 같아야 합니다.</entry>
    <entry key="complexICNotAllowed">''{0}''에서 오류 발생: 입력이 실수인 경우 초기 조건은 실수여야 합니다.</entry>
    <entry key="bufferHiddenBufferDataflowBusNotSupported">Dataflow Subsystem ''{1}''의 {0,number,integer}번 입력 포트에 있는 신호가 버스 신호입니다. 프레임 크기 자동 계산에는 버스를 사용할 수 없습니다. ''{1}'' Subsystem에 대해 버스를 사용하지 않거나 프레임 크기 자동 계산을 비활성화하십시오. &lt;actions&gt; &lt;action type="fixit" retvalue="yes"&gt; &lt;cmd&gt;dfs.disableMultirateForSubsystem(''{1}'');&lt;/cmd&gt; &lt;txt&gt;''{1}'' Subsystem에 대해 프레임 크기 자동 계산을 비활성화합니다.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
             
    </entry>
    <entry key="SystemBlockParameterNameClash">Block ''{0}'' has a property named ''{1}'', which conflicts with a reserved parameter name. Simulink cannot set this property as a parameter on the block. Rename the property.</entry>
    <entry key="SysExtInterfParameterNameClash">Simulink가 블록 ''{1}''에서 파라미터 ''{0}''의 값을 설정할 수 없습니다. 파라미터 이름이 예약된 파라미터 이름과 충돌하기 때문입니다. 파라미터 이름을 바꾸십시오.</entry>
    <entry key="SystemBlockInvalidModification">Invalid to modify block ''{0}'', modify class definition instead. </entry>
    <entry key="SysExtInterfInvalidModification">Simulink is unable to modify the mask on block ''{0}''.</entry>
    <entry key="MatFileWriteError">모델 ''{0}''에서 MATLAB System 블록에 대한 캐시를 쓰는 중 오류가 발생했습니다.
    </entry>
    <entry key="BlockOutsideOfBlockDiagram">유효하지 않은 작업이 감지됨: ''{0}''이(가) 블록 다이어그램과 연결되어 있지 않습니다.</entry>
    <entry key="OutportDoesNotSupportReusableCSC">Unsupported storage class ''{0}'' on outport block ''{1}''. To use this storage class, set the storage class on outport block ''{1}'' to ''Auto'' and configure the driving signal with ''{0}'' storage class.</entry>
    <entry key="OutportDoesNotSupportReusableCSC2">''{0}''은(는) Outport 블록 ''{1}''에서 지원되지 않는 스토리지 클래스입니다. 구동 신호가 ''{0}'' 스토리지 클래스로 구성되어 있으므로 Outport 블록의 스토리지 클래스를 ''Auto''로 설정하십시오.</entry>
    <entry key="OutportDoesNotSupportCoderDictReusableCSC">''{0}''은(는) Outport 블록 ''{1}''에서 지원되지 않는 스토리지 클래스입니다. 이 스토리지 클래스를 사용하려면 구동 신호를 ''{0}'' 스토리지 클래스로 구성하십시오.</entry>
    <entry key="OutportDoesNotSupportCSCforMessages">Unsupported storage class on outport block ''{0}''. Outport blocks that receive message signals must have their storage class set to ''Auto''.</entry>
    <entry key="UnifiedOutputPortLargerStringBufferNeeded">Output port of ''{0}'' must have a string type whose maximum length equals or exceeds the maximum length of the largest input string type.</entry>
    <entry key="BlockDoesNotSupportStringInput">&lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;블록 ''{1}''의 {0,number,integer}번 입력 포트&lt;/sldiag&gt;에서는 string형 신호가 지원되지 않습니다. 지원되는 데이터형 목록은 관련 블록 도움말 문서 페이지를 참조하십시오.</entry>
    <entry key="HiddenBlockDoesNotSupportStringInput">삽입된 숨겨진 블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에서는 string형 신호가 지원되지 않습니다. 지원되는 데이터형 목록은 관련 블록 도움말 문서 페이지를 참조하십시오.</entry>
    <entry key="BlockDoesNotSupportVirtualBusInputContainingStrings">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에서는 string형이 포함된 가상 버스 신호가 지원되지 않습니다. 지원되는 데이터형 목록은 관련 블록 도움말 문서 페이지를 참조하십시오.</entry>
    <entry key="BlockDoesNotSupportNonVirtualBusInputContainingStrings">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에서는 string형이 포함된 비가상 버스 신호가 지원되지 않습니다. 지원되는 데이터형 목록은 관련 블록 도움말 문서 페이지를 참조하십시오.</entry>
    <entry key="BlockDoesNotSupportStringOutput">A signal of data type string is not supported on &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of block ''{1}''. For a list of supported data types, see the block documentation page.</entry>
    <entry key="BlockDoesNotSupportNonVirtualBusOutputContainingStrings">A nonvirtual bus signal containing string data type is not supported on &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of block ''{1}''. For a list of supported data types, see the block documentation page.</entry>
    <entry key="BlockDoesNotSupportImageInput">A signal of data type image is not supported on &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of block ''{1}''. For a list of supported data types, see the block documentation page.</entry>
    <entry key="BlockDoesNotSupportImageOutput">블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에서는 이미지 데이터형의 신호가 지원되지 않습니다. 지원되는 데이터형 목록은 관련 블록 도움말 문서 페이지를 참조하십시오.</entry>
    <entry key="BlockDoesNotSupportFMUBinaryInput"> ''{0}'' 블록은 FMUBinary 유형의 신호를 받을 수 없습니다. FMUBinary 유형의 신호가 블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;에 연결되어 있습니다.</entry>
    <entry key="BlockDoesNotSupportFMUBinaryOutput">''{0}'' 블록은 FMUBinary 유형의 신호를 생성할 수 없습니다. FMUBinary 유형의 신호가 블록 ''{2}''의 &lt;sldiag objui="outport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 출력 포트&lt;/sldiag&gt;에 연결되어 있습니다.</entry>
    <entry key="BlockDoesNotSupportOpaqueInput">A signal of custom data type is not supported on &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of block ''{1}''. For a list of supported data types, see the block documentation page.</entry>
    <entry key="BlockDoesNotSupportOpaqueOutput">블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에서는 사용자 지정 데이터형의 신호가 지원되지 않습니다. 지원되는 데이터형 목록은 관련 블록 도움말 문서 페이지를 참조하십시오.</entry>
    <entry key="BlockDoesNotSupportOpaqueMatrixInput">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에서는 사용자 지정 데이터형의 행렬 신호가 지원되지 않습니다. 지원되는 데이터형 목록은 관련 블록 도움말 문서 페이지를 참조하십시오.</entry>
    <entry key="BlockDoesNotSupportOpaqueMatrixOutput">블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에서는 사용자 지정 데이터형의 행렬 신호가 지원되지 않습니다. 지원되는 데이터형 목록은 관련 블록 도움말 문서 페이지를 참조하십시오.</entry>
    <entry key="BlockDoesNotSupportDynamicArrayInput">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에서는 비유계 배열 유형의 신호가 지원되지 않습니다. 지원되는 데이터형 목록은 관련 블록 도움말 문서 페이지를 참조하십시오.</entry>
    <entry key="BlockDoesNotSupportDynamicArrayOutput">블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에서는 비유계 배열 유형의 신호가 지원되지 않습니다. 지원되는 데이터형 목록은 관련 블록 도움말 문서 페이지를 참조하십시오.</entry>
    <entry key="HalfUnsupportedTypes">블록 ''{0}''에서 반정밀도 유형은 다른 고정소수점 유형과만 사용할 수 있습니다.</entry>
    <entry key="BlockDoesNotSupportBusInputContainingFMUBinaries"> FMUBinary가 포함된 버스가 블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{1,number,integer}" objname="{2}"&gt;{1,number,integer}번 입력 포트&lt;/sldiag&gt;에 연결되어 있습니다. 버스의 FMUBinary가 포함된 입력은 블록 ''{0}''에서 지원되지 않습니다.</entry>
    <entry key="BlockDoesNotSupportHalfPrecisionInput">A signal of data type half is not supported on &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; of block ''{1}''. For a list of supported data types, see the block documentation page.</entry>
    <entry key="BlockDoesNotSupportHalfPrecisionOutput">A signal of data type half is not supported on &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; of block ''{1}''. For a list of supported data types, see the block documentation page.</entry>
    <entry key="BlockDoesNotSupportBusInputContainingImages">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에서는 이미지 데이터형이 포함된 버스 신호가 지원되지 않습니다. 지원되는 데이터형 목록은 관련 블록 도움말 문서 페이지를 참조하십시오.</entry>
    <entry key="BlockDoesNotSupportBusInputContainingOpaques">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에서는 사용자 지정 데이터형이 포함된 버스 신호가 지원되지 않습니다. 지원되는 데이터형 목록은 관련 블록 도움말 문서 페이지를 참조하십시오.</entry>
    <entry key="BlockDoesNotSupportBusInputContainingOpaqueMatrices">블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에서는 사용자 지정 데이터형 행렬이 포함된 버스 신호가 지원되지 않습니다. 지원되는 데이터형 목록은 관련 블록 도움말 문서 페이지를 참조하십시오.</entry>
    <entry key="InvInputVarDimSignal"> Variable-size signals are not supported at &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; in block ''{1}'' when data type is {2}. </entry>
    <entry key="InvInputFramedSignal"> 데이터형이 {2}인 경우, 블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;에서 프레임 기반 신호가 지원되지 않습니다. </entry>
    <entry key="InvOutputVarDimSignal"> Variable-size signals are not supported at &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; in block ''{1}'' when data type is {2}. </entry>
    <entry key="InvOutputFramedSignal"> 데이터형이 {2}인 경우, 블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 출력 포트&lt;/sldiag&gt;에서 프레임 기반 신호가 지원되지 않습니다. </entry>
    <entry key="InvInputContinuousSignal"> &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; in block ''{1}'' either sets or inherits a non-discrete sample time. However, the input port must have discrete sample time when it is a {2} signal or a bus signal that contains {2} elements. </entry>
    <entry key="InvOutputContinuousSignal"> &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; in block ''{1}'' either sets or inherits a non-discrete sample time. However, the input port must have discrete sample time when it is a {2} signal or a bus signal that contains {2} elements. </entry>
    <entry key="InvInputNonScalarSignal"> &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;Input port {0,number,integer}&lt;/sldiag&gt; in block ''{1}'' must be a scalar signal when data type is {2}. </entry>
    <entry key="InvOutputNonScalarSignal"> &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;Output port {0,number,integer}&lt;/sldiag&gt; in block ''{1}'' must be a scalar signal when data type is {2}. </entry>
    <entry key="InvInputComplexSignal">Complex signals are not supported at &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;input port {0,number,integer}&lt;/sldiag&gt; in block ''{1}'' when data type is {2}. </entry>
    <entry key="InvOutputComplexSignal">Complex signals are not supported at &lt;sldiag objui="outport" objparam="{0,number,integer}" objname="{1}"&gt;output port {0,number,integer}&lt;/sldiag&gt; in block ''{1}'' when data type is {2}. </entry>
    <entry key="InvContinuousSignal"> 연속 샘플 시간을 갖는 {0} 신호는 지원되지 않습니다. </entry>
    <entry key="InvNonScalarSignal"> Non-scalar {0} signals are not supported. </entry>
    <entry key="InvVarDimSignal"> Variable-size {0} signals are not supported. </entry>
    <entry key="InvComplexSignal"> Complex {0} signals are not supported. </entry>
    <entry key="HomogeneousVirtualBusBecomesVector"> 모든 요소의 유형이 동일하기 때문에, 블록 ''{0}''의 가상 버스 출력이 벡터로 처리됩니다. {1} 유형의 벡터는 지원되지 않습니다. </entry>
    <entry key="NoControlBlocksAndDataflowDomain">Subsystem 블록 ''{0}''이(가) Dataflow 도메인 유형을 지정했습니다. Dataflow 도메인에서는 Control 블록이 지원되지 않습니다.</entry>
    <entry key="NoEventListenerAndDataflowDomain">Subsystem 블록 ''{0}''이(가) Dataflow 도메인 유형을 지정했습니다. Dataflow 도메인에서는 Event Listener 블록이 지원되지 않습니다.</entry>
    <entry key="matrixInterpolationTitle">행렬 보간</entry>
    <entry key="matrixInterpolationDesc">행렬 데이터 점 간에 보간 또는 외삽을 수행합니다. m차원 행렬 데이터 점을 사용한 n차원 보간의 경우 테이블은 (m+n)차원의 행렬이 됩니다. 데이터 점이 스칼라이면 테이블은 보간 차원과 동일한 개수의 차원을 갖습니다. 예를 들어, 크기 [4,5]의 2차원 데이터 점을 사용한 1차원 보간에서는 테이블 차원이 [4,5,9]입니다. 여기서 9는 해당 절점의 크기입니다. 입력은 사전 계산된 인덱스 값과 소수 값입니다.</entry>
    <entry key="TitleParameters">파라미터</entry>
    <entry key="PropInterpMethod">보간 방법</entry>
    <entry key="PropExtrapMethod">외삽 방법</entry>
    <entry key="PropInterpolateDimension">보간 차원</entry>
    <entry key="PropTableData">테이블 데이터</entry>
    <entry key="BlockDoesNotSupportRowMajor">Block ''{0}'' at ''{1}'' does not support row major code generation.</entry>
    <entry key="RowMajorSFunctionDoesNotSupportCodeGeneration">S-Function ''{0}'' has SS_ROW_MAJOR configuration and does not support column major code generation.</entry>
    <entry key="BlockDoesNotSupportPreserveDimensionsForBuses">Block ''{0}'' at ''{1}'' does not support bus objects that preserve dimensions for code generation.</entry>
    <entry key="CompiledOutportError">Failed to find the requested compiled port parameter for the block ''{0}'' as the block was optimized during compilation.</entry>
    <entry key="PortValidationInputError"> 블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0, number, integer}" objname="{1}"&gt;{0, number, integer}번 입력 포트&lt;/sldiag&gt;의 데이터가 유효하지 않습니다.</entry>
    <entry key="RunTimeDataConstraintError">런타임 값이 ''{1}''입니다. 하지만 런타임 값은 ''{0}''이어야 합니다.</entry>
    <entry key="PortValidationOutputError"> 블록 ''{1}''의 &lt;sldiag objui="outport" objparam="{0, number, integer}" objname="{1}"&gt;{0, number, integer}번 출력 포트&lt;/sldiag&gt;의 데이터가 유효하지 않습니다.</entry>
    <entry key="PortCrossSatisfyMatrixMultiplication">다음 포트의 차원은 2차원 행렬이어야 하고 행렬 곱셈에 유효해야 합니다.</entry>
    <entry key="PortCrossSameDataType">The following ports or parameters must have same data type.</entry>
    <entry key="PortCrossSameComplexity">다음 포트 또는 파라미터는 실수/복소수 여부가 동일해야 합니다.</entry>
    <entry key="PortCrossSameDimension">The following ports or parameters must have same dimensions.</entry>
    <entry key="PortCrossSameWordLength">The following two ports must have same word length.</entry>
    <entry key="PortCrossGEIntegerBits">The data type at this port must have greater or equal number of integer bits than the data type at the other port.</entry>
    <entry key="PortCrossGEWordLengthMinusSignBit">The data type at this port must have a greater or equal word length than the data type at the other port. If both have the same word length, a port with an unsigned type is considered greater than a port with a signed type.</entry>
    <entry key="PortCrossValidationInputInputError"> Data at &lt;sldiag objui="inport" objparam="{0, number, integer}" objname="{4}"&gt;input port {0, number, integer}&lt;/sldiag&gt; of block ''{4}'' is ''{1}''. However, &lt;sldiag objui="inport" objparam="{2, number, integer}" objname="{4}"&gt;input port {2, number, integer}&lt;/sldiag&gt; of block ''{4}'' is ''{3}''.</entry>
    <entry key="PortCrossValidationError"> 블록 ''{4}''의 &lt;sldiag objui="port" objparam="{0, number, integer}" objname="{4}"&gt;{0, number, integer}번 포트&lt;/sldiag&gt;에 있는 데이터(''{1}'')는 블록 ''{4}''의 &lt;sldiag objui="port" objparam="{2, number, integer}" objname="{4}"&gt;{2, number, integer}번 포트&lt;/sldiag&gt;에 있는 데이터(''{3}'')와 동일해야 합니다.</entry>
    <entry key="PortCrossValidationInputOutputError"> Data at &lt;sldiag objui="inport" objparam="{0, number, integer}" objname="{4}"&gt;input port {0, number, integer}&lt;/sldiag&gt; of block ''{4}'' is ''{1}''. However, &lt;sldiag objui="outport" objparam="{2, number, integer}" objname="{4}"&gt;output port {2, number, integer}&lt;/sldiag&gt; of block ''{4}'' is ''{3}''.</entry>
    <entry key="PortCrossValidationOutputInputError"> Data at &lt;sldiag objui="outport" objparam="{0, number, integer}" objname="{4}"&gt;output port {0, number, integer}&lt;/sldiag&gt; of block ''{4}'' is ''{1}''. However, &lt;sldiag objui="inport" objparam="{2, number, integer}" objname="{4}"&gt;input port {2, number, integer}&lt;/sldiag&gt; of block ''{4}'' is ''{3}''.</entry>
    <entry key="PortCrossValidationOutputOutputError"> 블록 ''{4}''의 &lt;sldiag objui="outport" objparam="{0, number, integer}" objname="{4}"&gt;{0, number, integer}번 출력 포트&lt;/sldiag&gt;의 데이터가 ''{1}''입니다. 그러나 블록 ''{4}''의 &lt;sldiag objui="outport" objparam="{2, number, integer}" objname="{4}"&gt;{2, number, integer}번 출력 포트&lt;/sldiag&gt;는 ''{3}''입니다.</entry>
    <entry key="InputPortInformation"> 블록 ''{2}''의 &lt;sldiag objui="inport" objparam="{0, number, integer}" objname="{2}"&gt;{0, number, integer}번 입력 포트&lt;/sldiag&gt;의 데이터는 ''{1}''입니다. </entry>
    <entry key="OutputPortInformation"> 블록 ''{2}''의 &lt;sldiag objui="outport" objparam="{0, number, integer}" objname="{2}"&gt;{0, number, integer}번 출력 포트&lt;/sldiag&gt;의 데이터는 ''{1}''입니다. </entry>
    <entry key="ParameterInformation"> 블록 ''{2}''의 파라미터 &lt;sldiag objui="blockdlg" objparam="{0}" objname="{2}"&gt;''{0}''&lt;/sldiag&gt;의 데이터는 ''{1}''입니다.</entry>
    <entry key="CrossValidationSameDataTypeCanNotSupportStruct"> 버스 데이터형의 포트 신호 및 구조체 데이터형의 파라미터 값에는 동일한 데이터형 규칙에 대한 유효성 검사가 지원되지 않습니다.</entry>
    <entry key="PortValidationFixptError"> Expected data type must be ''{1}''. However, the port data type is ''{0}''.</entry>
    <entry key="PortValidationSignalTypeError"> Expected signal type must be ''{1}''. However, the port signal type is ''{0}''.</entry>
    <entry key="PortValidation2dSquareDimsError"> 신호는 '2차원 정사각 행렬'이어야 합니다. 그런데 포트 차원이 ''{0}''입니다.</entry>
    <entry key="FixedpointConstraintsConflict"> ''{1}''의 고정소수점 제약 조건을 ''{0}''의 기존 고정소수점 제약 조건에 추가하는 것은 지원되지 않습니다.</entry>
    <entry key="PortValidationErrorMsgPlaceHolder"> ''{0}''.</entry>
    <entry key="SameInputPortHasDifferentConstraints"> 블록 ''{0}''의 {1, number, integer}번 입력 포트가 서로 호환되지 않는 ''{3}'' 및 ''{2}''의 포트 식별자를 통해 특성 제약 조건과 연결되어 있습니다. 그 결과, {1, number, integer}번 입력 포트가 두 특성 제약 조건의 합집합을 취합니다. 의도한 설정이 아니라면 ''{3}'' 또는 ''{2}''에서 중복된 포트 식별자를 제거하십시오.</entry>
    <entry key="SameOutputPortHasDifferentConstraints"> 블록 ''{0}''의 {1, number, integer}번 출력 포트가 서로 호환되지 않는 ''{3}'' 및 ''{2}''의 포트 식별자를 통해 특성 제약 조건과 연결되어 있습니다. 그 결과, {1, number, integer}번 출력 포트가 두 특성 제약 조건의 합집합을 취합니다. 의도한 설정이 아니라면 ''{3}'' 또는 ''{2}''에서 중복된 포트 식별자를 제거하십시오.</entry>
    <entry key="InvalidKeywords">Invalid value specified for 'BlockKeywords' at  block ''{0}''. The value must be character vector, string scalar or string array.</entry>
    <entry key="KeywordUnSupported">쉼표(,)는 키워드에 사용할 수 없습니다.</entry>
    <entry key="SubsystemContainingScopedSimulinkFunctionCallChangedToBeInline">범위가 설정된 Simulink Function Caller가 블록 ''{1}''에 있기 때문에 ''{0}''의 구현이 인라인 함수로 변경됩니다.</entry>
    <entry key="UninitializedBlockData">블록 ''{0}''에 Simulink에서 액세스 중인 초기화되지 않은 데이터가 있습니다.</entry>
    <entry key="ValueTypeMismatch1">Block ''{0}'' expects a signal with value type ''{1}'' but receives a signal with value type ''{2}''.</entry>
    <entry key="ValueTypeShadowWarning">블록 ''{0}''이(가) ''{2}'' 속성을 가리는 값 유형 ''{1}''을(를) 지정합니다. </entry>
    <entry key="TransposeUnsupportedForDynamicArraySignals">블록 ''{0}''은(는) 동적 배열 신호에 대해 전치 연산을 지원하지 않습니다.</entry>
    <entry key="SingleInputSumUnsupportedForDynamicArraySignals">블록 ''{0}''은(는) 동적 배열 신호에 대해 단일 입력을 지원하지 않습니다.</entry>
    <entry key="FOHInvInitOutPrm">
      {1} 블록 ''{0}''의 ''{2}'' 파라미터는 유한한 double형이어야 합니다.
    </entry>
    <entry key="FOHInvErrTolPrm">
      {1} 블록 ''{0}''의 ''{2}'' 파라미터는 음이 아닌 double형이어야 합니다.
    </entry>
    <entry key="FOHInconsitentPrmDims">
      {1} 블록 ''{0}''의 파라미터 차원이 일치하지 않습니다.
    </entry>
    <entry key="FOHInputCannotBeContinuous">
      
               {1} 블록 ''{0}''이(가) 연속 입력을 허용하도록 구성되지 않았습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="suggestion"&gt; &lt;cmd&gt; load_system(''{0}''); open_system(''{0}''); &lt;/cmd&gt; &lt;txt&gt; 연속 입력을 허용하려면, 블록의 ''연속 입력 허용'' 파라미터를 활성화하고 파라미터 ''외삽 오차를 상대적으로 초과하면 재설정''을 유한수(예: 0.1)로 설정하여 연속 입력 신호의 구간별 선형 근사에 해당하는 연속 출력 신호를 생성하십시오. 이 파라미터를 활성화하면 시뮬레이션의 수치가 부정확할 수 있습니다. &lt;/txt&gt; &lt;/action&gt; &lt;action type="suggestion"&gt; &lt;txt&gt; 이 블록을 모델에서 입력 신호가 이산 신호인 다른 위치로 옮겨 보십시오. &lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
      
    </entry>
    <entry key="EntityDelayNonPositiveTi">블록 ''{0}''의 2번 입력 포트에 양수 값이 필요한데 입력 신호가 0보다 작거나 같습니다. 값이 무한대로 설정되었습니다.</entry>
    <entry key="FOHWarnNumericInaccuracy">
      블록 ''{0}''의 입력 신호는 연속 신호인데 파라미터 'ErrorTolerance'가 'Inf'로 설정되어 있습니다. 이로 인해 시뮬레이션의 수치가 부정확할 수 있습니다. 이 블록을 모델에서 입력 신호가 이산 신호인 다른 위치로 옮겨보십시오.
    </entry>
    <entry key="InvSamplingModeSetting" context="error">
  
           블록 ''{0}''은(는) 고정 스텝 솔버에서 작동하도록 구성되어 있지 않습니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{0}'',''RunAtFixedTimeIntervals'',''on'')&lt;/cmd&gt; &lt;txt&gt;블록에 대한 '고정 시간 간격으로 실행' 파라미터를 활성화하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{1}'',''SolverType'',''Variable-step'')&lt;/cmd&gt; &lt;txt&gt;'SolverType'을 가변 스텝 솔버로 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
  
</entry>
    <entry key="InvInputDutyCycleForVPG">
      
               At time {2}, the duty cycle input {1} of the Variable Pulse Generator block ''{0}'' is invalid. To produce 
               a valid output the duty cycle must be greater than 0.
               &lt;actions exclusiveFixIts="yes"&gt;
                   &lt;action type="fixit"&gt;
                       &lt;cmd&gt;set_param(''{0}'',''AllowZeroPulseWidth'',''on'');&lt;/cmd&gt;
                       &lt;txt&gt;Enable the parameter 'Allow zero pulse width' to allow zero duty cycle. Note that
                            this may cause algebraic loops.
                       &lt;/txt&gt;
                   &lt;/action&gt;
               &lt;/actions&gt;
      
    </entry>
    <entry key="InvInputPeriodForVPG">
      
               At time {2}, the period input {1} of the Variable Pulse Generator block ''{0}'' is invalid. To produce a 
               valid output the period must be finite and greater than the smallest time resolution in 
               Simulink (128*eps).
      
    </entry>
    <entry key="InvInputPeriodForVPGDiscMode" context="error">
  
           시간 {2}에서 Variable Pulse Generator 블록 ''{0}''의 주기 입력 {1}이(가) 유효하지 않습니다. 유효한 출력을 생성하려면 주기가 유한하고 샘플 시간 {3}의 2배보다 커야 합니다.
  
</entry>
    <entry key="InvSamplingRateForVPG">
      
               At time {4}, the product of the duty cycle input signal value {2} and the period input signal value {3} for 
               the variable pulse generator block ''{0}''is too small. To produce a valid output, this product must be 
               greater than the parameter sample time {1}.
               &lt;actions exclusiveFixIts="yes"&gt;
                   &lt;action type="fixit"&gt;
                       &lt;cmd&gt;set_param(''{0}'',''AllowZeroPulseWidth'',''on'');&lt;/cmd&gt;
                       &lt;txt&gt;Enable the parameter 'Allow zero pulse width' to allow small pulse width. Note that
                            this may cause algebraic loops.
                       &lt;/txt&gt;
                   &lt;/action&gt;
                   &lt;action type="suggestion"&gt;
                       &lt;txt&gt;Decrease the sample time for the block {0}.&lt;/txt&gt;
                   &lt;/action&gt;
               &lt;/actions&gt;
      
    </entry>
    <entry key="OutofBoundSamplingRateForVPG">
      
               Invalid value of the parameter 'Sample time' on the block ''{0}''. The sampling rate must be finite and
               greater than the smallest time resolution in Simulink (128*eps).
      
    </entry>
    <entry key="FailedToCopyPortsForSubsystemBlock">Subsystem 블록 ''{0}''에 대한 포트를 복사하지 못했습니다. Subsystem 블록을 검사하고 포트가 유효하고 모델이 손상되지 않았는지 확인하십시오.</entry>
    <entry key="InvPulseWidthForVPG">
  
           시간 {3}에서 Variable Pulse Generator 블록 {0}에 대한 듀티 사이클 입력 {1}과(와) 주기 입력 {2}의 곱이 너무 작습니다. 유효한 출력을 생성하려면 이 곱이 현재 시간의 eps {4}보다 커야 합니다.
  
</entry>
    <entry key="warnDutyCycleGreaterThanOne">
  
           시간 {0}에서 Variable Pulse Generator 블록 {2}에 대한 입력 듀티 사이클 {1}이(가) 1보다 큽니다. 유효한 신호를 생성하기 위해 이 시간과 시뮬레이션의 남은 시간 동안 이 조건이 발생할 때마다 입력 듀티 사이클이 1로 잘렸습니다.
  
</entry>
    <entry key="warnDutyCycleLessThanZero">
  
           시간 {0}에서 Variable Pulse Generator 블록 {2}에 대한 입력 듀티 사이클 {1}이(가) 0보다 작습니다. 유효한 신호를 생성하기 위해 이 시간과 시뮬레이션의 남은 시간 동안 이 조건이 발생할 때마다 입력 듀티 사이클이 0으로 잘렸습니다.
  
</entry>
    <entry key="InvInputDutyCycleForPWM">
      
               At time {2}, the duty cycle input {1} of the PWM block ''{0}'' is invalid. To produce 
               a valid output the duty cycle must be greater than 0.
               &lt;actions exclusiveFixIts="yes"&gt;
                   &lt;action type="fixit"&gt;
                       &lt;cmd&gt;set_param(''{0}'',''DisallowZeroDutyCycle'',''off'');&lt;/cmd&gt;
                       &lt;txt&gt;Disable the parameter 'Disallow zero duty cycle' to allow zero 
                            duty cycle. Note that this may cause algebraic loops.
                       &lt;/txt&gt;
                   &lt;/action&gt;
               &lt;/actions&gt;
      
      
    </entry>
    <entry key="InvSampleTimeForPWM">
      
               At time {4}, the product of the duty cycle input signal value {2} and the parameter period {3} for 
               the PWM block ''{0}''is too small. To produce a valid output, this product must be 
               greater than the parameter sample time {1}.
               &lt;actions exclusiveFixIts="yes"&gt;
                   &lt;action type="fixit"&gt;
                       &lt;cmd&gt;set_param(''{0}'',''DisallowZeroDutyCycle'',''off'');&lt;/cmd&gt;
                       &lt;txt&gt;Disable the parameter 'Disallow zero duty cycle' to allow small pulse width. Note that
                            this may cause algebraic loops.
                       &lt;/txt&gt;
                   &lt;/action&gt;
                   &lt;action type="suggestion"&gt;
                       &lt;txt&gt;Decrease the sample time for the block {0}.&lt;/txt&gt;
                   &lt;/action&gt;
               &lt;/actions&gt;
      
    </entry>
    <entry key="InvInitialDelayForPWM" context="error">
        
                 PWM 블록 {1}에 대한 초기 지연 {0}이(가) 샘플 시간 파라미터 {2}보다 작습니다. 유효한 PWM 신호를 생성하려면, 
                 초기 지연이 양수이고 파라미터 샘플 시간 값 {2}의 배수여야 합니다.
        
    </entry>
    <entry key="VarSizeAoBNotSupportedInPermuteDimensions">가변 크기를 갖는 버스로 구성된 배열이 포함된 신호는 Permute Dimensions 블록 {0}에 대한 입력으로 사용할 수 없습니다.</entry>
    <entry key="ZcNotSupportedInFixedStep" context="error">
      
               블록 {0}은(는) 고정 스텝 시뮬레이션의 영점교차 검출에서 지원되지 않습니다. Simulink는 이 블록과 관련된 영점교차를 검출하지 않습니다. &lt;actions exclusiveFixIts="no"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(''{0}'',''ZeroCross'',''off'');&lt;/cmd&gt; &lt;txt&gt;블록 {0}에 대한 영점교차 검출을 비활성화하십시오. &lt;/txt&gt; &lt;/action&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;set_param(bdroot(''{0}''),''SolverType'',''Variable-Step'');&lt;/cmd&gt; &lt;txt&gt;가변 스텝 솔버를 사용하여 블록 {0}과(와) 관련된 영점교차를 검출하십시오. &lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;
      
    </entry>
    <entry key="HitSchedulerRequireVariableStep" context="error">
      
               Hit Scheduler block ''{0}'' does not support simulation with fixed-step solver.
               &lt;actions exclusiveFixIts="no"&gt;
               &lt;action type="fixit"&gt;
               &lt;cmd&gt;set_param(bdroot(''{0}''),''SolverType'',''Variable-Step'');&lt;/cmd&gt;
               &lt;txt&gt;Select a variable-step solver to use Hit Scheduler block in this model.
               &lt;/txt&gt;
               &lt;/action&gt;
               &lt;/actions&gt;
      
    </entry>
    <entry key="HitSchedulerInvalidInput" context="error">
      
               Invalid time delay value ''{1}'' for block ''{0}''. Time delay value must be positive and finite.
      
    </entry>
    <entry key="warnBufferOverwrite">
      
               Hit Scheduler 블록 ''{0}''의 버퍼가 가득 찼습니다. 지금이든 다른 언제든, 버퍼에서 가장 오래된 값을 제거하면 시뮬레이션의 나머지 부분에서 버퍼가 오버플로됩니다. 버퍼 오버플로를 방지하려면 버퍼 크기를 늘리거나 고정된 버퍼 크기를 사용하지 마십시오.
      
    </entry>
    <entry key="warnDeltaTTooSmall">
      
               시간 {0}에 Hit Scheduler 블록 {2}에 대한 &amp;Delta;t 입력값 {1}이(가) 솔버가 허용하는 최소 스텝 크기보다 작습니다. 시간 {0} 및 기타 모든 시간에 대해 솔버에 의해 결정된 최소 스텝 크기를 사용하면 &amp;Delta;t 값이 시뮬레이션의 나머지 부분에서 너무 작아집니다.
      
    </entry>
    <entry key="StructVariableWithInherit">블록 ''{0}''의 Variant 활성화 시점은 '다음에서 상속: Simulink.VariantControl'로 설정되어 있지만, 블록은 구조체 요소를 Variant 제어 변수로 갖습니다.</entry>
    <entry key="UseInheritVATWithSlVarCtrl">Variant 블록 ''{0}''의 Variant 조건에 Simulink.VariantControl 유형의 Variant 제어 변수 {1}이(가) 있지만 이 블록의 Variant 활성화 시점이 ''{2}''(으)로 설정되어 있습니다. 블록 ''{0}''은(는) 동일한 Variant 활성화 시점을 갖는 Simulink.VariantControl 변수에서 활성화 시점을 상속해야 합니다. &lt;actions exclusiveFixIts="yes"&gt; &lt;action type="fixit"&gt; &lt;cmd&gt;slprivate(''variantfixes'',''ActivationTimeToInheritVATFromSVC'',''{0}'')&lt;/cmd&gt; &lt;txt&gt;블록 ''{0}''의 Variant 활성화 시점을 ''Simulink.VariantControl에서 상속''으로 설정하십시오.&lt;/txt&gt; &lt;/action&gt; &lt;/actions&gt;</entry>
    <entry key="OutportRequiresNVBusForAOBValueType">Outport 블록 ''{0}''은(는) 부모 모델의 값 유형 ''{2}''과(와) 일치하도록 차원이 ''{1}''인 비가상 버스로 구성된 배열을 출력해야 합니다. 비가상 버스 출력 또는 서로 다른 데이터 유형을 지정하십시오.</entry>
    <entry key="InportRequiresNVBusForAOBValueType">Inport block ''{0}'' must output an array of nonvirtual buses with dimensions ''{1}'' to match value type ''{2}''. Specify nonvirtual bus output or a different data type.</entry>
    <entry key="VarSizeConvInconsistentNumDims">Bus Creator 블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;는 차원 수가 {3,number,integer}인 가변 크기 신호를 필요로 하지만, 차원 수가 {2,number,integer}인 가변 크기 신호에 의해 구동되었습니다.</entry>
    <entry key="VarSizeConvIncompatibleDims">Bus Creator 블록 ''{1}''의 &lt;sldiag objui="inport" objparam="{0,number,integer}" objname="{1}"&gt;{0,number,integer}번 입력 포트&lt;/sldiag&gt;는 차원 ''{3}''을(를) 갖는 가변 크기 신호를 필요로 하지만, 차원 ''{2}''을(를) 갖는 가변 크기 신호에 의해 구동되었습니다.</entry>
    <entry key="ConstantValueTypeDimensionsModeMismatchWithValue">Constant 블록 ''{0}''이(가) 변수 차원을 지원하지 않는데, 해당 값 유형(''{1}'')이 ''가변'' 차원 모드를 지정합니다.</entry>
    <entry key="ConstantValueTypeComplexityMismatchWithValue">Constant 블록 ''{0}''의 상수 출력값의 실수/복소수 여부는 ''{1}''인데, 블록 값 유형(''{2}'')의 실수/복소수 여부는 ''{3}''입니다.</entry>
    <entry key="ConstantValueTypeSymbDimsMismatchWithValue1">Constant 블록 ''{0}''의 상수 출력값의 기호 차원은 ''{1}''인데, 블록 값 유형(''{2}'')의 기호 차원은 ''{3}''입니다.</entry>
    <entry key="ConstantValueTypeSymbDimsMismatchWithValue2">Constant 블록 ''{0}''의 상수 출력값이 기호 차원을 지정하지 않는데, 블록 값 유형(''{1}'')이 기호 차원 ''{2}''을(를) 지정합니다.</entry>
    <entry key="ConstantValueTypeSymbDimsMismatchWithValue3">Constant 블록 ''{0}''의 상수 출력값의 기호 차원은 ''{1}''인데, 블록 값 유형(''{2}'')이(가) 기호 차원을 지정하지 않습니다.</entry>
    <entry key="ConstantValueTypeDimsMismatchWithValue">Constant 블록 ''{0}''의 상수 출력값의 차원은 ''{1}''인데, 블록 값 유형(''{2}'')의 차원은 ''{3}''입니다.</entry>
    <entry key="InheritVatActivationTime">블록에 대해 명령 'set_param(''{0}'','VariantActivationTime','inherit from Simulink.VariantControl')'이 실행됩니다.</entry>
    <entry key="InvalidNVB2VConversionAtMultiInputBusCapableBlocks">Block ''{1}'' expects all inputs to have the same data type, but the nonvirtual bus at input port {0, number, integer} has a different data type than another input.</entry>
    <entry key="globalNumberOfFieldsChanged">실행 중에는 전역 구조체 ''{0}''의 필드 수를 변경할 수 없습니다. 필드 수가 원래 {1,number,integer}이었는데, {2,number,integer}(으)로 변경되었습니다.</entry>
    <entry key="globalFieldNamesChanged">실행 중에는 전역 구조체 ''{0}''의 필드 이름을 변경할 수 없습니다. 필드 이름이 원래 ''{1}''이었는데, ''{2}''(으)로 변경되었습니다.</entry>
    <entry key="globalDimsChanged">실행 중에는 전역 변수 ''{0}''의 차원을 변경할 수 없습니다. 지정된 차원이 원래 "{1}"이었는데, "{2}"(으)로 변경되었습니다.</entry>
    <entry key="globalTypeChangedSummary">실행 중에는 전역 변수 ''{0}''의 데이터형을 변경할 수 없습니다.</entry>
    <entry key="globalTypeChangedDetailed">The data type for global variable ''{0}'' cannot be changed during execution.  Specified data type was initially "{1}" and changed to "{2}".</entry>
    <entry key="globalComplexityChanged">실행 중에는 전역 변수 ''{0}''의 실수/복소수 여부를 변경할 수 없습니다. 지정된 실수/복소수 여부가 원래 "{1}"이었는데, "{2}"(으)로 변경되었습니다.</entry>
    <entry key="SizeOfBitRangeArray">값은 스칼라이거나 요소를 2개 가진 벡터여야 합니다.</entry>
    <entry key="TunableSizeValueMustBeIntegerGeq2">차원 {0, number, integer}의 조정 가능한 크기는 2보다 크거나 같은 정수여야 합니다.</entry>
    <entry key="TunableSizeCanNotBeDefaultWhenBPFromPort">차원 {0, number, integer}의 조정 가능한 크기가 유효하지 않습니다. 절점 소스가 "입력 포트"인 경우 조정 가능한 크기 값은 2보다 크거나 같고 절점 배열의 길이보다 작거나 같은 정수여야 합니다.</entry>
    <entry key="TunableSizeCanNotBeDefaultWhenTableFromPort">차원 {0, number, integer}의 조정 가능한 크기가 유효하지 않습니다. 절점 사양이 "균일 간격"이고 테이블 소스가 "입력 포트"인 경우, 조정 가능한 크기 값은 2보다 크거나 같고 룩업 테이블의 차원 {0, number, integer}의 길이보다 작거나 같은 정수여야 합니다.</entry>
    <entry key="TunableSizeValueMustBeLeqBPArrayLen">차원 {0, number, integer}의 조정 가능한 크기 값이 절점 배열의 길이를 초과하므로, 조정 가능한 크기가 유효하지 않습니다. 조정 가능한 크기 값은 {2, number, integer}보다 작거나 같아야 하는데 {1, number, integer}(으)로 설정되었습니다.</entry>
    <entry key="TunableSizeValueMustBeLeqTableDimSize">차원 {0, number, integer}의 조정 가능한 크기 값이 테이블에서 대응되는 차원의 크기를 초과하므로, 조정 가능한 크기가 유효하지 않습니다. 조정 가능한 크기 값은 {2, number, integer}보다 작거나 같아야 하는데 {1, number, integer}(으)로 설정되었습니다.</entry>
    <entry key="ConflictingTunableSizeParameters">''SupportTunableSize''와 ''SupportTunableTableSize''를 모두 활성화하는 것은 지원되지 않습니다. ''SupportTunableTableSize''를 'off'로 설정하십시오.</entry>
    <entry key="CannotChangeMaskHideContentsToOff">MathWorks 라이브러리 블록에 대해 'MaskHideContents'를 'off'로 설정할 수 없습니다.</entry>
    <entry key="BlockDoesNotSupportMultiExecInstancesCustomMsg">{0}</entry>
    <entry key="FIRFilterBlockType">Discrete FIR Filter</entry>
    <entry key="IIRFilterBlockType">Discrete Filter</entry>
    <entry key="AllpoleFilterBlockType">Allpole Filter</entry>
    <entry key="DTFBlockType">Discrete Transfer Fcn</entry>
    <entry key="HPODerivativeCoefficientInTFapproximation">c</entry>
    <entry key="HPOUDPSendRemoteURL">IP</entry>
  </message>
</rsccat>
