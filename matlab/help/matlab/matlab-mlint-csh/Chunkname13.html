<!DOCTYPE HTML><html xmlns="http://www.w3.org/1999/xhtml"><body><strong>Explanation</strong><br/><p>The <code><a href="matlab: doc parfor" target="_blank">parfor</a></code>
                    statement allows only a range of increasing sequential numbers with a step value
                    of 1.</p><br/><strong>Suggested Action</strong><br/><p>Adjust your code, as follows:</p><p>If your code contains a statement such as <code>parfor 1:2:10</code>,
                    rewrite your code so that step intervals of 1 return the expected results. </p><p>If your code contains a statement such as <code>parfor i = V</code>,
                    ensure that <code>V</code> resolves to a contiguous series of values in a
                    vector array, and the step between values is 1. </p><p>For example, assume your code is similar to the following, where
                        <code>&lt;myArray&gt;</code> is an actual array, such as [2, 6,
                    7]:</p><code><br/>vectorValues&nbsp;=&nbsp;[1,&nbsp;4,&nbsp;9,&nbsp;16,&nbsp;25,&nbsp;36,&nbsp;49];<br/>vectorSequence&nbsp;=&nbsp;&lt;myArray&gt;;<br/>parfor&nbsp;ii&nbsp;=&nbsp;vectorSequence<br/>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;=&nbsp;vectorValues(ii);<br/>&nbsp;&nbsp;&nbsp;&nbsp;sprintf('index&nbsp;=&nbsp;%d&nbsp;&nbsp;value&nbsp;=&nbsp;%d\n',&nbsp;ii,&nbsp;val)<br/>end<br/></code><p>Change your code as follows, depending on whether the
                        <code>vectorSequence</code> array is sparse. Keep in mind that MATLAB
                    transfers data to workers once per iteration.</p><p>If the <code>vectorSequence</code> array is sparse, use this code, which
                    results in fewer data transfers than the original code, but incurs the cost of
                    copying the data into <code>vectorValueSubset</code>.</p><code><br/>vectorValues&nbsp;=&nbsp;[1,&nbsp;4,&nbsp;9,&nbsp;16,&nbsp;25,&nbsp;36,&nbsp;49];<br/>vectorSequence&nbsp;=&nbsp;[2,&nbsp;6,&nbsp;7];<br/>vectorValueSubset&nbsp;=&nbsp;vectorValues(vectorSequence);<br/>parfor&nbsp;jj&nbsp;=&nbsp;1:length(vectorSequence)<br/>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;=&nbsp;vectorValueSubset(jj);<br/>&nbsp;&nbsp;&nbsp;&nbsp;sprintf('index&nbsp;=&nbsp;%d&nbsp;&nbsp;value&nbsp;=&nbsp;%d\n',&nbsp;vectorSequence(jj),&nbsp;val)<br/>end<br/></code><p>If the <code>vectorSequence</code> array is <span class="emphasis"><em>not</em></span>
                    sparse, use this code, which results in more data transfers than the original
                    code, but does not incur the cost of copying data. The extra transfers are
                    computationally lightweight.</p><code><br/>vectorValues&nbsp;=&nbsp;[1,&nbsp;4,&nbsp;9,&nbsp;16,&nbsp;25,&nbsp;36,&nbsp;49];<br/>vectorSequence&nbsp;=&nbsp;[2:3,&nbsp;5:7];<br/>parfor&nbsp;kk&nbsp;=&nbsp;min(vectorSequence):max(vectorSequence)<br/>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(find(&nbsp;vectorSequence&nbsp;==&nbsp;kk))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;=&nbsp;vectorValues(kk);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf('index&nbsp;=&nbsp;%d&nbsp;&nbsp;value&nbsp;=&nbsp;%d\n',&nbsp;kk,&nbsp;val)<br/>&nbsp;&nbsp;&nbsp;&nbsp;end<br/>end<br/></code></body></html>