<!DOCTYPE HTML><html xmlns="http://www.w3.org/1999/xhtml"><body><strong>Explanation</strong><br/><p>A <code>for</code> statement within a <code>parfor</code> loop
                    must be a range of sequential numbers with a step value of 1. The form of the
                        <code>for</code> loop must include an explicit colon operation between
                    the low and high values. For example, if a <code>parfor</code> loop
                    contains <code>for ii = V</code>, you need to adjust your code, even if
                        <code>V</code> resolves to a contiguous series of values in a vector
                    array with a step value of 1.</p><br/><strong>Suggested Action</strong><br/><p>Adjust the <code><a href="matlab: doc for" target="_blank">for</a></code>
                    loop statement within the <code><a href="matlab: doc parfor" target="_blank">parfor</a></code> loop. For example, assume your code is similar
                    to the following, where <code>&lt;myArray&gt;</code> is an actual array,
                    such as [2, 6, 7] :</p><code><br/>vectorValues&nbsp;=&nbsp;[1,&nbsp;4,&nbsp;9,&nbsp;16,&nbsp;25,&nbsp;36,&nbsp;49;&nbsp;1,&nbsp;8,&nbsp;27,&nbsp;64,&nbsp;125,&nbsp;216,&nbsp;343];<br/>vectorSequence&nbsp;=&nbsp;&lt;myArray&gt;;<br/>parfor&nbsp;ii&nbsp;=&nbsp;1:2<br/>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;jj&nbsp;=&nbsp;vectorSequence<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;=&nbsp;vectorValues(ii,&nbsp;jj);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf('index&nbsp;=&nbsp;%d&nbsp;index&nbsp;=&nbsp;%d&nbsp;value&nbsp;=&nbsp;%d\n',&nbsp;ii,&nbsp;jj,&nbsp;val)<br/>&nbsp;&nbsp;&nbsp;&nbsp;end<br/>end<br/></code><p>Change your code as follows, depending on whether the
                        <code>vectorSequence</code> array is sparse. Keep in mind that MATLAB
                    transfers data to workers once per iteration.</p><p>If the <code>vectorSequence</code> array is sparse, use this code which
                    results in fewer data transfers than the original code, but incurs the cost of
                    copying the data into <code>vectorValueSubset</code>.</p><code><br/>vectorValues&nbsp;=&nbsp;[1,&nbsp;4,&nbsp;9,&nbsp;16,&nbsp;25,&nbsp;36,&nbsp;49;&nbsp;1,&nbsp;8,&nbsp;27,&nbsp;64,&nbsp;125,&nbsp;216,&nbsp;343];<br/>vectorSequence&nbsp;=&nbsp;[2,&nbsp;6,&nbsp;7];<br/>vectorValueSubset&nbsp;=&nbsp;vectorValues(vectorSequence);<br/>parfor&nbsp;ii&nbsp;=&nbsp;1:2<br/>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;jj&nbsp;=&nbsp;1:length(vectorSequence)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;=&nbsp;vectorValueSubset(ii,&nbsp;jj);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf('index&nbsp;=&nbsp;%d&nbsp;index&nbsp;=&nbsp;%d&nbsp;value&nbsp;=&nbsp;%d\n',&nbsp;ii,&nbsp;vectorSequence(jj),&nbsp;val)<br/>&nbsp;&nbsp;&nbsp;&nbsp;end<br/>end<br/></code><p>If the <code>vectorSequence</code> array is <span class="emphasis"><em>not</em></span>
                    sparse, use this code which results in more data transfers than the original
                    code, but does not incur the cost of copying data. The extra transfers are
                    computationally lightweight.</p><code><br/>vectorValues&nbsp;=&nbsp;[1,&nbsp;4,&nbsp;9,&nbsp;16,&nbsp;25,&nbsp;36,&nbsp;49;&nbsp;1,&nbsp;8,&nbsp;27,&nbsp;64,&nbsp;125,&nbsp;216,&nbsp;343];<br/>vectorSequence&nbsp;=&nbsp;[2,&nbsp;3,&nbsp;5,&nbsp;6,&nbsp;7];<br/>parfor&nbsp;ii=1:2<br/>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;jj&nbsp;=min(vectorSequence):max(vectorSequence)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(find(&nbsp;vectorSequence&nbsp;==&nbsp;jj))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;=&nbsp;vectorValues(ii,&nbsp;jj);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf('index=%d&nbsp;index=%d&nbsp;value=%d\n',&nbsp;ii,&nbsp;jj,&nbsp;val)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>&nbsp;&nbsp;&nbsp;&nbsp;end<br/>end<br/></code></body></html>