classdef TimedElasticBand < matlab.System & nav.algs.internal.controllerTEBImpl
    %This class is for internal use only. It may be removed in the future.

    %TIMEDELASTICBAND Avoid unseen obstacles with time optimal trajectories
    %   The TimedElasticBand system object creates a controller (local planner)
    %   using the Timed Elastic Band (TEB) algorithm. The controller
    %   enables a robot to follow a reference path typically generated by
    %   a global planner, such as the RRT or Hybrid A*. Additionally, the
    %   planner avoids obstacles and smooths out the path while optimizing the
    %   travel time. Furthermore, the planner maintains a safe distance from
    %   obstacles, known or unknown to the global planner. The object computes
    %   velocity commands and optimal trajectory using the current pose and
    %   current linear and angular velocity of the robot. It can be used for
    %   most mobile robots and ground vehicles using standard motion models,
    %   e.g. differential-drive and car-like robots.
    %
    %   TEB = nav.slalgs.internal.TIMEDELASTICBAND() returns a TEB
    %   controller object that computes the linear and angular velocity commands
    %   for a robot.
    %
    %   TEB = nav.slalgs.internal.TIMEDELASTICBAND(...,Name=Value) specifies
    %   properties using one or more name-value arguments in addition to the
    %   argument from the previous syntax.
    %
    %   TIMEDELASTICBAND properties:
    %
    %   Time                  - Time weight for cost function optimization
    %   Smoothness            - Smoothness weight for cost function
    %                           optimization
    %   Obstacle              - Obstacle weight for cost function optimization
    %   Shape                 - Shape of the robot, specified as "Rectangle" or
    %                           "Point".
    %   Dimension             - Size of the robot, specified as a two-element
    %                           positive vector of the form [length width].
    %   FixedTransform        - Fixed transform relative to the local frame of
    %                           the robot.
    %   ObstacleSafetyMargin  - Safe distance between robot and obstacles
    %   NumIteration          - Number of iterations to optimize trajectory
    %   MaxVelocity           - Maximum linear and angular velocity for
    %                           velocity commands
    %   MaxReverseVelocity    - Maximum velocity during reverse motion for
    %                           velocity commands
    %   MaxAcceleration       - Maximum linear and angular acceleration for
    %                           velocity commands
    %   MinTurningRadius      - Minimum turning radius for optimized path
    %   ReferenceDeltaTime    - Reference travel time between two consecutive
    %                           poses
    %   LookAheadTime         - Look-ahead time
    %   GoalTolerance         - Tolerance value to determine if goal is reached
    %
    %   TIMEDELASTICBAND methods:
    %
    %   step                  - Compute velocity commands and optimal
    %                           trajectory for subsequent time steps.
    %   clone                 - Create local planner object with same property
    %                           values
    %   release               - Allow property value changes
    %   reset                 - Reset internal states to default
    %   isLocked              - Locked status (logical)
    %   info                  - Get additional information about the object
    %
    %   Example:
    %
    %        load("parkingMap.mat");
    %        map = occupancyMap(map, 3);
    %        
    %        % Setup and run global planner
    %        validator = validatorOccupancyMap(stateSpaceSE2, Map=map);
    %        validator.ValidationDistance = .1;
    %        rng(42, 'twister')
    %        rrtstar = plannerRRTStar(validator.StateSpace, validator);
    %        rrtstar.MaxConnectionDistance = .2;
    %        route = plan(rrtstar, [2 9 0], [27 18 -pi/2]);
    %        refpath = route.States;
    %        
    %        % RRT* gives random orientation which can cause unnecessary turns
    %        headingToNextPose = headingFromXY(refpath(:,1:2));
    %        
    %        % Align orientation to path except for start and goal
    %        refpath(2:end-1, 3) = headingToNextPose(2:end-1);
    %        localmap = occupancyMap(15, 15, map.Resolution);
    %        teb = nav.slalgs.internal.TimedElasticBand();
    %        teb.LookAheadTime = 10; % In sec
    %        teb.ObstacleSafetyMargin = .4; % In meters
    %        % To generate more time-optimal trajectories, specify a larger
    %        % value for CostWeights.Time. To follow the reference path closely
    %        % keep the weight to a smaller value like 1e-3.
    %        teb.Time = 100;
    %        curpose = refpath(1,:);
    %        curvel = [0 0];
    %        simtime = 0;
    %        % Reducing timestep can lead to more accurate path tracking
    %        timestep = 0.1;
    %        itr = 0;
    %        goalReached = false;
    %        
    %        while ~goalReached && simtime < 60
    %            % Update map to keep robot in center of the map. Also update
    %            % the map with new information from global map or measurement
    %            % from sensors.
    %            moveMapBy = curpose(1:2) - localmap.XLocalLimits(end)/2;
    %            localmap.move(moveMapBy, FillValue=0.5);
    %            syncWith(localmap, map);
    %            if mod(itr,10)==0 % every 1 sec
    %                %Extract map information
    %        
    %                if(isa(localmap,'binaryOccupancyMap'))
    %                    occMat = localmap.occupancyMatrix();
    %                else % This can only be occupancyMap. vehicleCostmap was converted to this.
    %                    occMat = localmap.occupancyMatrix() > localmap.OccupiedThreshold;
    %                end
    %        
    %                mapInfo = struct();
    %                mapInfo.Resolution = localmap.Resolution;
    %                mapInfo.GridLocationInWorld = localmap.GridLocationInWorld;
    %                mapInfo.OccupancyMatrix = false(localmap.GridSize(1),localmap.GridSize(2));
    %                mapInfo.OccupancyMatrix(1:localmap.GridSize(1),1:localmap.GridSize(2)) = occMat;
    %                mapInfo.GridSize = localmap.GridSize;
    %                mapInfo.GridOriginInLocal = localmap.GridOriginInLocal;
    %                % Generate new vel commands with teb
    %                [velcmds, tstamps, curpath, info] = teb(curpose, curvel, mapInfo, refpath);
    %                goalReached = info.HasReachedGoal;
    %                feasibleDriveDuration = tstamps(info.LastFeasibleIdx);
    %                % If robot is far from goal and only less than third of
    %                % trajectory is feasible, then an option is to re-plan
    %                % the path to follow to reach the goal.
    %                if info.ExitFlag == 1 && ...
    %                        feasibleDriveDuration < (teb.LookAheadTime/3)
    %                    route = plan(rrtstar, curpose, [27 18 -pi/2]);
    %                    refpath = route.States;
    %                    headingToNextPose = headingFromXY(refpath(:,1:2));
    %                    refpath(2:end-1,3) = headingToNextPose(2:end-1);
    %                    teb.ReferencePath = refpath;
    %                end
    %                timestamps = tstamps + simtime;
    %                % Show the updated information which is input to or output
    %                % from controllerTEB
    %                clf
    %                show(localmap)
    %                hold on
    %                plot(refpath(:,1), refpath(:,2), ".-", Color="#EDB120", ...
    %                    DisplayName="Reference Path")
    %                quiver(curpath(:,1), curpath(:,2), ...
    %                    cos(curpath(:,3)), sin(curpath(:,3)), .2, ...
    %                    Color="#A2142F", DisplayName="Current Path")
    %                quiver(curpose(:,1), curpose(:,2), ...
    %                    cos(curpose(:,3)), sin(curpose(:,3)), .5, ...
    %                    "o", MarkerSize=20, ShowArrowHead="off", ...
    %                    Color="#0072BD", DisplayName="Start Pose")
    %            end
    %            simtime = simtime + timestep;
    %            % Compute the instantaneous velocity to be sent to the robot
    %            % from the series of timestamped commands generated by
    %            % controllerTEB
    %            velcmd = velocityCommand(velcmds, timestamps, simtime);
    %            % Very basic robot model, should be replaced by simulator.
    %            statedot = [velcmd(1)*cos(curpose(3)) ...
    %                velcmd(1)*sin(curpose(3)) ...
    %                velcmd(2)];
    %            curpose = curpose + statedot * timestep;
    %            curvel = velcmd;
    %            if exist("hndl", "var")
    %                delete(hndl)
    %            end
    %            hndl = quiver(curpose(:,1), curpose(:,2), ...
    %                cos(curpose(:,3)), sin(curpose(:,3)), .5, ...
    %                "o", MarkerSize=20, ShowArrowHead="off", ...
    %                Color="#D95319", DisplayName="Current Robot Pose");
    %            itr = itr + 1;
    %            drawnow
    %        end
    %        legend
    %
    %   See also VELOCITYCOMMAND, HEADINGFROMXY, PLANNERASTARGRID,
    %   BINARYOCCUPANCYMAP, OCCUPANCYMAP, CONTROLLERPUREPURSUIT

    %   Copyright 2024-2025 The MathWorks, Inc.

    %#codegen

    properties (Nontunable)

        %Main tab parameter information
        %Specify lookahead time using input port
        LookAheadTimePort (1, 1) logical = false;
        %Specify goal tolerance port time using input port
        GoalTolerancePort (1, 1) logical = false;
        %Dimension - Size of the robot, specified as a two-element
        % positive vector of the form [length width] in meters.
        Dimension = [1 0.6700];
        %Shape - Shape of the robot, specified as "Rectangle" or "Point".
        Shape = "Rectangle";
        %FixedTransform - Fixed transform relative to the local frame of
        % the robot. Specify the transform as an array of form [x,y,theta]
        % or an se2 object. To keep the default robot origin, specify the
        % transform as se2. This field is applicable for "Rectangle" shaped
        % robot. This field is optional.
        FixedTransform = se2;
        %Specify obstacle safety margin using input port
        ObstacleSafetyMarginPort (1, 1) logical = false;

        %Trajectory parameter information
        %Specify maximum velocity using input port
        MaxVelocityPort (1, 1) logical = false;
        %Specify maximum reverse velocity using input port
        MaxReverseVelocityPort (1, 1) logical = false;
        %Specify maximum acceleration using input port
        MaxAccelerationPort (1, 1) logical = false;
        %Specify minimum turning radius using input port
        MinTurningRadiusPort (1, 1) logical = false;
        %Specify refernce delta time using input port
        ReferenceDeltaTimePort (1, 1) logical = false;

        %Optimization parameter information
        %Specify number of iterations using input port
        NumIterationPort (1, 1) logical = false;
        %Specify time using input port
        TimePort (1, 1) logical = false;
        %Specify smootheness using input port
        SmoothnessPort (1, 1) logical = false;
        %Specify dimension using input port
        ObstaclePort (1, 1) logical = false;

        %Solution information output bus
        OutputBusName = 'extraInfo_bus';
    end

    % Public, tunable properties
    properties

        %Main tab parameter information
        %SampleTime - Specify sample time
        SampleTime = 1;
        %LookAheadTime - Look-ahead time.
        LookAheadTime = 5;
        %GoalTolerance - Tolerance values to consider robot has reached
        % goal.
        GoalTolerance = [0.1 0.1 0.1];
        %ObstacleSafetyMargin - Safe distance between robot and obstacles.
        ObstacleSafetyMargin = 0.5;

        %Trajectory parameter information
        %MaxVelocity - Maximum limit of linear and angular velocity.
        MaxVelocity = [0.8 1.6];
        %MaxReverseVelocity - Maximum velocity for reverse motion.
        MaxReverseVelocity = NaN;
        %MaxAcceleration - Maximum limit of linear and angular acceleration
        MaxAcceleration = [2.4 4.8];
        %MinTurningRadius - Minimum Turning Radius of turns in optimized
        % path.
        MinTurningRadius = 0;
        %ReferenceDeltaTime - Reference travel time between consecutive
        % poses.
        ReferenceDeltaTime = 0.3;

        %Optimization parameter information
        %NumIteration - Number of iteration to optimize trajectory.
        NumIteration = 2;
        %Time - Cost function weight for time, specified as a positive
        % scalar. To lower the travel time, increase this weight value.
        Time = 10;
        %Smoothness - Cost function weight for smooth motion, specified as a
        % a positive scalar. To obtain smoother path, increase this weight
        % value.
        Smoothness = 1000;
        %Obstacles  - Cost function weight for maintaining safe distance
        % from obstacles, specified as a positive scalar. To maintain the
        % safe distance from obstacles, increase this weight value.
        Obstacle = 50;
    end


    properties (Constant, Hidden)

        %Main tab parameter information
        LookAheadTimeSet = matlab.system.SourceSet({'PropertyOrInput', ...
            'SystemBlock', 'LookAheadTimePort', 10, "LookAheadTime"});
        GoalToleranceSet = matlab.system.SourceSet({'PropertyOrInput', ...
            'SystemBlock', 'GoalTolerancePort', 11, "GoalTol"});
        ShapeSet = matlab.system.StringSet(["Rectangle", "Point"]);
        ObstacleSafetyMarginSet = matlab.system.SourceSet({'PropertyOrInput', ...
            'SystemBlock', 'ObstacleSafetyMarginPort', 8, "ObstMargin"});

        %Trajectory parameter information
        MaxVelocitySet = matlab.system.SourceSet({'PropertyOrInput', ...
            'SystemBlock', 'MaxVelocityPort', 1, "MaxVel"});
        MaxReverseVelocitySet = matlab.system.SourceSet({'PropertyOrInput', ...
            'SystemBlock', 'MaxReverseVelocityPort', 2, "MaxRevVel"});
        MaxAccelerationSet = matlab.system.SourceSet({'PropertyOrInput', ...
            'SystemBlock', 'MaxAccelerationPort', 3, "MaxAccel"});
        MinTurningRadiusSet = matlab.system.SourceSet({'PropertyOrInput', ...
            'SystemBlock', 'MinTurningRadiusPort', 4, "MinTurnRad"});
        ReferenceDeltaTimeSet = matlab.system.SourceSet({'PropertyOrInput', ...
            'SystemBlock', 'ReferenceDeltaTimePort', 12, "RefDelTime"});

        %Optimization parameter information
        NumIterationSet = matlab.system.SourceSet({'PropertyOrInput', ...
            'SystemBlock', 'NumIterationPort', 9, "NumIter"});
        TimeSet = matlab.system.SourceSet({'PropertyOrInput', ...
            'SystemBlock', 'TimePort', 5, "TimeWeight"});
        SmoothnessSet = matlab.system.SourceSet({'PropertyOrInput', ...
            'SystemBlock', 'SmoothnessPort', 6, "SmoothWeight"});
        ObstacleSet = matlab.system.SourceSet({'PropertyOrInput', ...
            'SystemBlock', 'ObstaclePort', 7, "ObstWeight"});
    end

    methods
        function obj = TimedElasticBand(varargin)
            %Constructor Support name-value pair arguments when constructing object

            referencePath = zeros(4,3);
            coder.varsize('referencePath',[inf 3], [1 1]);

            % Need to call it here before accessing obj
            obj@nav.algs.internal.controllerTEBImpl(referencePath);

            updateCellHalfDiagLen(obj);
            setProperties(obj,nargin,varargin{:});

            %Update robot center and radius value
            nav.internal.validation.validateTEBParams.updateRobotInfo(obj);
        end
    end

    methods

        function set.SampleTime(obj, sampleTime)
            %SampleTime parameter 
            
            % This parameter is defined only for the Simulink block and not
            % shared with controllerTEB function
            validateattributes(sampleTime, 'numeric',...
                {'nonempty', 'scalar', 'nonnan', 'finite', 'real'} , ...
                obj.getClassName, 'SampleTime');
            obj.SampleTime = sampleTime;       
        end

        function set.LookAheadTime(obj, lookAheadTime)
            nav.internal.validation.validateTEBParams.setLookAheadTime(obj,lookAheadTime);
        end

        function lat = get.LookAheadTime(obj)
            lat = nav.internal.validation.validateTEBParams.getLookAheadTime(obj);
        end

        function set.GoalTolerance(obj, goalTol)
            nav.internal.validation.validateTEBParams.setGoalTolerance(obj,goalTol);
        end

        function goalTol = get.GoalTolerance(obj)
            goalTol = nav.internal.validation.validateTEBParams.getGoalTolerance(obj);
        end

        function set.ObstacleSafetyMargin(obj, margin) 
            nav.internal.validation.validateTEBParams.setObstacleSafetyMargin(obj,margin);
            obj.ObstacleSafetyMargin = margin;
        end

        function refDelT = get.ReferenceDeltaTime(obj)
            refDelT = nav.internal.validation.validateTEBParams.getReferenceDeltaTime(obj);
        end

        function set.ReferenceDeltaTime(obj, refDelT)
            nav.internal.validation.validateTEBParams.setReferenceDeltaTime(obj,refDelT);
        end

        function set.MaxVelocity(obj, maxVel)
            nav.internal.validation.validateTEBParams.setMaxVelocity(obj,maxVel);
        end

        function maxVel = get.MaxVelocity(obj)
            maxVel = nav.internal.validation.validateTEBParams.getMaxVelocity(obj);
        end

        function set.MaxReverseVelocity(obj, maxReverseVel)
            nav.internal.validation.validateTEBParams.setMaxReverseVelocity(obj,maxReverseVel);
        end

        function maxReverseVel = get.MaxReverseVelocity(obj)
            maxReverseVel = nav.internal.validation.validateTEBParams.getMaxReverseVelocity(obj);
        end

        function set.MinTurningRadius(obj, minTurnRadius)
            nav.internal.validation.validateTEBParams.setMinTurningRadius(obj,minTurnRadius);
        end

        function minTurnRadius = get.MinTurningRadius(obj)
            minTurnRadius = nav.internal.validation.validateTEBParams.getMinTurningRadius(obj);
        end

        function set.MaxAcceleration(obj, maxAccel)
            nav.internal.validation.validateTEBParams.setMaxAcceleration(obj,maxAccel);
        end

        function maxAccel = get.MaxAcceleration(obj)
            maxAccel = nav.internal.validation.validateTEBParams.getMaxAcceleration(obj);
        end

        function set.NumIteration(obj, numIter)
            nav.internal.validation.validateTEBParams.setNumIteration(obj,numIter);
        end

        function numIter = get.NumIteration(obj)
            numIter = nav.internal.validation.validateTEBParams.getNumIteration(obj);
        end

        function set.Time(obj, tw)
            nav.internal.validation.validateTEBParams.setWeightTime(obj,tw);
        end

        function tw = get.Time(obj)
            tw = nav.internal.validation.validateTEBParams.getWeightTime(obj);
        end

        function set.Smoothness(obj, sw)
            nav.internal.validation.validateTEBParams.setWeightSmoothness(obj,sw);
        end

        function sw = get.Smoothness(obj)
            sw = nav.internal.validation.validateTEBParams.getWeightSmoothness(obj);
        end

        function set.Obstacle(obj, ow)
            nav.internal.validation.validateTEBParams.setWeightObstacle(obj,ow);
        end

        function ow = get.Obstacle(obj)
            ow = nav.internal.validation.validateTEBParams.getWeightObstacle(obj);
        end

        function set.Dimension(obj,dim)
            %Setter for dimension property

            nav.internal.validation.validateTEBParams.setRobotDimension(obj,dim,obj.Shape); %#ok<MCSUP>
            obj.Dimension = dim;
        end

        function set.Shape(obj,shape)
            %Setter for shape property
            nav.internal.validation.validateTEBParams.setRobotShape(obj,shape);
            obj.Shape = shape;
        end

        function set.FixedTransform(obj,ft)
            %Setter for fixed transform property
            ft = nav.internal.validation.validateTEBParams.setRobotFixedTransform(obj,ft);
            obj.FixedTransform = ft;
        end

    end

    methods (Access = protected)
        %% Common functions
        function setupImpl(obj)
            % Perform one-time calculations, such as computing constants
            % Configure default parameter values for TEB

            obj.StateSpace = stateSpaceSE2;
            obj.StateSpace.StateBounds = [-inf inf; -inf inf; -pi pi];
            obj.StateSpace.SkipStateValidation = true;

            assignProperties(obj);
        end

        function validateInputsImpl(obj,curstate,curvel,mapInfo,refPath)

            if  ~isstruct(mapInfo)
                coder.internal.error("nav:navslalgs:controllerTEB:BusInput");
            end

            if ~(isfield(mapInfo,'GridLocationInWorld') && isfield(mapInfo,'Resolution') ...
                && isfield(mapInfo,'GridSize') && isfield(mapInfo,'OccupancyMatrix') ...
                && isfield(mapInfo,'GridOriginInLocal'))
                coder.internal.error("nav:navslalgs:controllerTEB:InvalidBusElements");
            end

            %During simulink block initialization all input values are
            %zeros and map resolution and grid size can not be zero 
            %otherwise occupancy map will throw an error hence assigning
            %default values of resolution and grid size.
            if mapInfo.Resolution == 0
                mapInfo.Resolution = 1;
                mapInfo.GridSize = [10 10];
            end

            sdfMap = signedDistanceMap(...
                mapInfo.OccupancyMatrix(1:mapInfo.GridSize(1),1:mapInfo.GridSize(2)),...
                mapInfo.Resolution, InterpolationMethod='linear');
            sdfMap.GridOriginInLocal = mapInfo.GridOriginInLocal;
            sdfMap.GridLocationInWorld = mapInfo.GridLocationInWorld;

            %Validate Inputs
            nav.internal.validation.validateTEBParams.stepInputs(obj,curstate,curvel,sdfMap);

            nav.internal.validation.validateTEBParams.setReferencePath(obj,refPath);
        end

        function varargout = stepImpl(obj,curstate,curvel, mapInfo, refPath) %#ok<INUSD>
            %stepImpl Compute control commands

            sdfMap = signedDistanceMap(mapInfo.OccupancyMatrix(1:mapInfo.GridSize(1),1:mapInfo.GridSize(2)), mapInfo.Resolution, InterpolationMethod='linear');
            sdfMap.GridOriginInLocal = mapInfo.GridOriginInLocal;
            sdfMap.GridLocationInWorld = mapInfo.GridLocationInWorld;

            %Update safety margin parameters for new map resolution.
            margin = obj.TEBParams.ObstacleSafetyMargin - obj.CellHalfDiagLen;
            updateCellHalfDiagLen(obj,mapInfo.Resolution);
            nav.internal.validation.validateTEBParams.updateSafetyMargin(obj,margin);

            obj.ReferencePathInternal = refPath;

            % Do the deed
            [velcmds, optpath, tstamps, ei] = stepImplInternal(obj, curstate, sdfMap);

            % Calculate/extract information for extra information output
            extraInfo = processStepImplOutputs(obj, optpath,...
                velcmds, tstamps, ei, sdfMap);

            varargout = {velcmds, tstamps, optpath, extraInfo};
        end

        function resetImpl(obj)
            % Initialize / reset internal or discrete properties

            obj.StateSpace.StateBounds = [-inf inf; -inf inf; -pi pi];
            obj.StateSpace.SkipStateValidation = true;

            nav.internal.validation.validateTEBParams.updateRobotInfo(obj);
            assignProperties(obj);
        end

        function processTunedPropertiesImpl(obj)

            if isChangedProperty(obj,'Time')
                nav.internal.validation.validateTEBParams.setWeightTime(obj,obj.Time);
            end
            if isChangedProperty(obj,'Smoothness')
                nav.internal.validation.validateTEBParams.setWeightSmoothness(obj,obj.Smoothness);
            end
            if isChangedProperty(obj,'Obstacle')
                nav.internal.validation.validateTEBParams.setWeightObstacle(obj,obj.Obstacle);
            end

            if isChangedProperty(obj,'ObstacleSafetyMargin')
                nav.internal.validation.validateTEBParams.setObstacleSafetyMargin(obj,obj.ObstacleSafetyMargin);
            end
            if isChangedProperty(obj,'NumIteration')
                nav.internal.validation.validateTEBParams.setNumIteration(obj,obj.NumIteration);
            end

            if isChangedProperty(obj,'MaxVelocity')
                nav.internal.validation.validateTEBParams.setMaxVelocity(obj,obj.MaxVelocity);
            end

            if isChangedProperty(obj,'MaxReverseVelocity')
                nav.internal.validation.validateTEBParams.setMaxReverseVelocity(obj,obj.MaxReverseVelocity);
            end
            if isChangedProperty(obj,'MaxAcceleration')
                nav.internal.validation.validateTEBParams.setMaxAcceleration(obj,obj.MaxAcceleration);
            end

            if isChangedProperty(obj,'MinTurningRadius')
                nav.internal.validation.validateTEBParams.setMinTurningRadius(obj,obj.MinTurningRadius);
            end

            if isChangedProperty(obj,'ReferenceDeltaTime')
                nav.internal.validation.validateTEBParams.setReferenceDeltaTime(obj,obj.ReferenceDeltaTime);
            end

            if isChangedProperty(obj,'LookAheadTime')
                nav.internal.validation.validateTEBParams.setLookAheadTime(obj,obj.LookAheadTime);
            end

            if isChangedProperty(obj,'GoalTolerance')
                nav.internal.validation.validateTEBParams.setGoalTolerance(obj,obj.GoalTolerance);
            end
        end

        function varargout = getOutputSizeImpl(~)
            % Return size for each output port
            
            %Output size depends on the properties ReferenceDeltaTime and
            %   LookAheadTime. Maximum size of output is LookAheadDistance 
            %   divided by ReferenceDeltaTime.
            % outputSize   = ceil(obj.LookAheadDistance/obj.ReferenceDeltaTime)*2;
            outputSize = 10000;
            varargout{1} = [outputSize 2];
            varargout{2} = [outputSize 1];
            varargout{3} = [outputSize 3];

            varargout{4} = [1 1];
        end

        function varargout = getOutputDataTypeImpl(obj)
            %getOutputDataTypeImpl Return data type for each output port
            
            outputDT = propagatedInputDataType(obj, 1);
            %Output data type depends on the data-type of the first
            %input argument.
            varargout{1} = outputDT;
            varargout{2} = outputDT;
            varargout{3} = outputDT;
            varargout{4} = obj.OutputBusName;

        end

        function flag = isInputSizeMutableImpl(~,index)
            flag = ~(index==3);
        end

        function varargout = isOutputComplexImpl(~)
            %isOutputComplexImpl Return true for each output port with complex data
            varargout{1} = false;
            varargout{2} = false;
            varargout{3} = false;
            varargout{4} = false;
        end

        function varargout = isOutputFixedSizeImpl(~)
            %isOutputFixedSizeImpl Return true for each output port with fixed size

            %velocity command is variable size
            varargout{1} = false;

            %timestamp is variable size
            varargout{2} = false;

            %pose is variable size
            varargout{3} = false;

            %solution information is scalar
            varargout{4} = true;
        end

        function sts = getSampleTimeImpl(obj)
            % Define sample time type and parameters

            if obj.SampleTime == -1.0
                sts = obj.createSampleTime(Type = "Inherited",...
                    ErrorOnPropagation = "Continuous");
            else
                sts = obj.createSampleTime(Type = "Discrete",...
                    SampleTime = obj.SampleTime);
            end
        end

        function num = getNumInputsImpl(~)
            num = 4;
        end

        function num = getNumOutputsImpl(~)
            num = 4;
        end

        function n = getInputNamesImpl(~)
            n = ["Pose", "Vel", "MapInfo", "RefPath"];
        end

        function n = getOutputNamesImpl(~)

            n = ["VelCmds", "Timestamps", "OptPath", "SolnInfo"];

        end

        function s = saveObjectImpl(obj)
            %saveObjectImpl Save object to MAT file

            s = saveObjectImpl@matlab.System(obj);
            if isLocked(obj)
                s.Time = obj.Time;
                s.Smoothness = obj.Smoothness;
                s.Obstacle = obj.Obstacle;

                s.Dimension = obj.Dimension;
                s.Shape = obj.Shape;
                s.FixedTransform = obj.FixedTransform;

                s.NumIteration = obj.NumIteration;
                s.MaxVelocity = obj.MaxVelocity;
                s.MaxAcceleration = obj.MaxAcceleration;
                s.ReferenceDeltaTime = obj.ReferenceDeltaTime;
                s.MinTurningRadius = obj.MinTurningRadius;
                s.LookAheadTime = obj.LookAheadTime;

                s.MaxReverseVelocity = obj.MaxReverseVelocity;
                s.GoalTolerance = obj.GoalTolerance;
                s.ObstacleSafetyMargin = obj.ObstacleSafetyMargin;
            end
        end

        function loadObjectImpl(obj,s,wasLocked)
            %loadObjectImpl Load object from MAT file

            if wasLocked
                obj.Time = s.Time;
                obj.Smoothness = s.Smoothness;
                obj.Obstacle = s.Obstacle;

                obj.Dimension = s.Dimension;
                obj.Shape = s.Shape;
                obj.FixedTransform = s.FixedTransform;

                obj.NumIteration = s.NumIteration;
                obj.MaxVelocity = s.MaxVelocity;
                obj.MaxAcceleration = s.MaxAcceleration;
                obj.ReferenceDeltaTime = s.ReferenceDeltaTime;
                obj.MinTurningRadius = s.MinTurningRadius;
                obj.LookAheadTime = s.LookAheadTime;

                obj.MaxReverseVelocity = s.MaxReverseVelocity;
                obj.GoalTolerance = s.GoalTolerance;
                obj.ObstacleSafetyMargin = s.ObstacleSafetyMargin;
            end
            loadObjectImpl@matlab.System(obj,s);
        end

        function icon = getIconImpl(~)
            %getIconImpl Define icon for System block
            filepath = fullfile(matlabroot, 'toolbox', 'nav', 'navsimulink', 'blockicons', 'blockIconTEBController.svg');
            icon = matlab.system.display.Icon(filepath); % Example: image file icon
        end
    end

    methods(Hidden)

        function cname = getClassName(obj) %#ok<MANU>
            %getClassName Return class name of this class
            cname = 'TimedElasticBand';
        end

    end

    methods (Static, Access = protected)
        %% Simulink customization functions
        function header = getHeaderImpl
            % Define header panel for System block dialog
            header = matlab.system.display.Header(mfilename("class"), ...
                'Title', message('nav:navslalgs:controllerTEB:controllerTEBTitle').getString, ...
                'Text', message('nav:navslalgs:controllerTEB:controllerTEBDescription').getString, ...
                'ShowSourceLink', false);
        end

        function groups = getPropertyGroupsImpl
            % Define property section(s) for System block dialog

            %% Main tab parameter information

            propSampleTime = matlab.system.display.internal.Property(...
                'SampleTime','Description',getString(...
                message('nav:navslalgs:controllerTEB:SampleTimePrompt')));

            propLookAheadTimePort = matlab.system.display.internal.Property(...
                'LookAheadTimePort','Description',getString(...
                message('nav:navslalgs:controllerTEB:LookAheadTimePortPrompt')));
            propLookAheadTime = matlab.system.display.internal.Property(...
                'LookAheadTime','Description',getString(...
                message('nav:navslalgs:controllerTEB:LookAheadTimePrompt')));

            propGoalTolerancePort = matlab.system.display.internal.Property(...
                'GoalTolerancePort','Description',getString(...
                message('nav:navslalgs:controllerTEB:GoalTolerancePortPrompt')));
            propGoalTolerance = matlab.system.display.internal.Property(...
                'GoalTolerance','Description',getString(...
                message('nav:navslalgs:controllerTEB:GoalTolerancePrompt')));


            propertyList = matlab.system.display.Section(...
                'PropertyList', {propSampleTime, propLookAheadTimePort, propLookAheadTime, ...
                propGoalTolerancePort, propGoalTolerance} ...
                );

            %Robot information section
            RobotInfoInputSectionName = getString(...
                message('nav:navslalgs:controllerTEB:RobotInfomationSectionName'));
            propDimension = matlab.system.display.internal.Property(...
                'Dimension','Description',getString(...
                message('nav:navslalgs:controllerTEB:DimensionPrompt')));
            propShape = matlab.system.display.internal.Property(...
                'Shape','Description',getString(...
                message('nav:navslalgs:controllerTEB:ShapePrompt')));
            propFixedTransform = matlab.system.display.internal.Property(...
                'FixedTransform','Description',getString(...
                message('nav:navslalgs:controllerTEB:FixedTransformPrompt')));

            robotInfoSection = matlab.system.display.Section(...
                'Title', RobotInfoInputSectionName, 'PropertyList', ...
                {propShape, propDimension, propFixedTransform});

            %Map information section
            MapInfoInputSectionName = getString(...
                message('nav:navslalgs:controllerTEB:MapInfomationSectionName'));
            propObstacleSafetyMarginPort = matlab.system.display.internal.Property(...
                'ObstacleSafetyMarginPort','Description',getString(...
                message('nav:navslalgs:controllerTEB:ObstacleSafetyMarginPortPrompt')));
            propObstacleSafetyMargin = matlab.system.display.internal.Property(...
                'ObstacleSafetyMargin','Description',getString(...
                message('nav:navslalgs:controllerTEB:ObstacleSafetyMarginPrompt')));

            mapInfoSection = matlab.system.display.Section(...
                'Title', MapInfoInputSectionName, 'PropertyList', ...
                {propObstacleSafetyMarginPort, propObstacleSafetyMargin});

            mainGroup = matlab.system.display.SectionGroup(...
                'Title', getString(message('nav:navslalgs:controllerTEB:FirstTabName')), ...
                'Sections', [propertyList robotInfoSection mapInfoSection]);

            %% Trajectory parameter information

            propMaxVelocityPort = matlab.system.display.internal.Property(...
                'MaxVelocityPort', 'Description',getString(message(...
                'nav:navslalgs:controllerTEB:MaxVelocityPortPrompt')));
            propMaxVelocity = matlab.system.display.internal.Property(...
                'MaxVelocity','Description',getString(message(...
                'nav:navslalgs:controllerTEB:MaxVelocityPrompt')));

            propMaxReverseVelocityPort = matlab.system.display.internal.Property(...
                'MaxReverseVelocityPort', 'Description',getString(...
                message('nav:navslalgs:controllerTEB:MaxReverseVelocityPortPrompt')));
            propMaxReverseVelocity = matlab.system.display.internal.Property(...
                'MaxReverseVelocity','Description',getString(...
                message('nav:navslalgs:controllerTEB:MaxReverseVelocityPrompt')));

            propMaxAccelerationPort = matlab.system.display.internal.Property(...
                'MaxAccelerationPort', 'Description',getString(...
                message('nav:navslalgs:controllerTEB:MaxAccelerationPortPrompt')));
            propMaxAcceleration = matlab.system.display.internal.Property(...
                'MaxAcceleration','Description',getString(...
                message('nav:navslalgs:controllerTEB:MaxAccelerationPrompt')));

            propMinTurningRadiusPort = matlab.system.display.internal.Property(...
                'MinTurningRadiusPort', 'Description',getString(...
                message('nav:navslalgs:controllerTEB:MinTurningRadiusPortPrompt')));
            propMinTurningRadius = matlab.system.display.internal.Property(...
                'MinTurningRadius','Description',getString(message(...
                'nav:navslalgs:controllerTEB:MinTurningRadiusPrompt')));

            propReferenceDeltaTimePort = matlab.system.display.internal.Property(...
                'ReferenceDeltaTimePort','Description',getString(...
                message('nav:navslalgs:controllerTEB:ReferenceDeltaTimePortPrompt')));
            propReferenceDeltaTime = matlab.system.display.internal.Property(...
                'ReferenceDeltaTime','Description',getString(...
                message('nav:navslalgs:controllerTEB:ReferenceDeltaTimePrompt')));

            trajParamsSection = matlab.system.display.Section(...
                'PropertyList',{propMaxVelocityPort, propMaxVelocity, ...
                propMaxReverseVelocityPort, propMaxReverseVelocity, ...
                propMaxAccelerationPort, propMaxAcceleration,...
                propMinTurningRadiusPort, propMinTurningRadius, ...
                propReferenceDeltaTimePort, propReferenceDeltaTime});

            trajParamsGroup = matlab.system.display.SectionGroup('Title', ...
                message('nav:navslalgs:controllerTEB:TrajectoryParametersTabName').getString,...
                'Sections', trajParamsSection);

            %% Optimization parameter information

            propNumIterationPort = matlab.system.display.internal.Property(...
                'NumIterationPort','Description',getString(...
                message('nav:navslalgs:controllerTEB:NumIterationPortPrompt')));
            propNumIteration = matlab.system.display.internal.Property(...
                'NumIteration','Description',getString(...
                message('nav:navslalgs:controllerTEB:NumIterationPrompt')));

            optParamsSection = matlab.system.display.Section(...
                'PropertyList', {propNumIterationPort, propNumIteration});

            CostFunctionWeightsSectionName = getString(...
                message('nav:navslalgs:controllerTEB:CostFunctionWeightsSectionName'));

            propTimePort = matlab.system.display.internal.Property(...
                'TimePort','Description',getString(...
                message('nav:navslalgs:controllerTEB:TimePortPrompt')));
            propTime = matlab.system.display.internal.Property(...
                'Time','Description',getString(...
                message('nav:navslalgs:controllerTEB:TimePrompt')));

            propSmoothnessPort = matlab.system.display.internal.Property(...
                'SmoothnessPort','Description',getString(...
                message('nav:navslalgs:controllerTEB:SmoothnessPortPrompt')));
            propSmoothness = matlab.system.display.internal.Property(...
                'Smoothness','Description',getString(...
                message('nav:navslalgs:controllerTEB:SmoothnessPrompt')));

            propObstaclePort = matlab.system.display.internal.Property(...
                'ObstaclePort','Description',getString(...
                message('nav:navslalgs:controllerTEB:ObstaclePortPrompt')));
            propObstacle = matlab.system.display.internal.Property(...
                'Obstacle','Description',getString(...
                message('nav:navslalgs:controllerTEB:ObstaclePrompt')));

            costWeightParamsSection = matlab.system.display.Section(...
                'Title', CostFunctionWeightsSectionName, 'PropertyList', ...
                {propTimePort, propTime, propSmoothnessPort, propSmoothness, propObstaclePort, propObstacle});

            costWeightFcnGroup = matlab.system.display.SectionGroup('Title', ...
                message('nav:navslalgs:controllerTEB:OptimizationParametersTabName').getString,...
                'Sections', [optParamsSection costWeightParamsSection]);

            %% Group all tab information
            groups = [mainGroup trajParamsGroup costWeightFcnGroup];
        end
    end

    methods(Access=private)
        function assignProperties(obj)

            nav.internal.validation.validateTEBParams.setWeightTime(obj,obj.Time);

            nav.internal.validation.validateTEBParams.setWeightSmoothness(obj,obj.Smoothness);

            nav.internal.validation.validateTEBParams.setWeightObstacle(obj,obj.Obstacle);

            nav.internal.validation.validateTEBParams.setObstacleSafetyMargin(obj,obj.ObstacleSafetyMargin);

            nav.internal.validation.validateTEBParams.setNumIteration(obj,obj.NumIteration);

            nav.internal.validation.validateTEBParams.setMaxVelocity(obj,obj.MaxVelocity);

            nav.internal.validation.validateTEBParams.setMaxReverseVelocity(obj,obj.MaxReverseVelocity);

            nav.internal.validation.validateTEBParams.setMaxAcceleration(obj,obj.MaxAcceleration);

            nav.internal.validation.validateTEBParams.setMinTurningRadius(obj,obj.MinTurningRadius);

            nav.internal.validation.validateTEBParams.setReferenceDeltaTime(obj,obj.ReferenceDeltaTime);

            nav.internal.validation.validateTEBParams.setLookAheadTime(obj,obj.LookAheadTime);

            nav.internal.validation.validateTEBParams.setGoalTolerance(obj,obj.GoalTolerance);

        end
    end

    methods(Access = protected, Static)
        function simMode = getSimulateUsingImpl
            % Return only allowed simulation mode in System block dialog
            simMode = "Interpreted execution";
        end
        
        function flag = showSimulateUsingImpl
        %showSimulateUsingImpl return false if simulation mode hidden in System block dialog
            flag = false;
        end
    end

end
