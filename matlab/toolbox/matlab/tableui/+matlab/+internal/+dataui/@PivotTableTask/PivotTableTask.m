classdef (Hidden = true) PivotTableTask < matlab.task.LiveTask
    % PIVOTTABLETASK - Summarize tabular data in a pivoted table
    %
    %   H = PivotTableTask constructs a Live Task for pivoting a
    %   table using the pivot function
    %
    %   See also PIVOT

    %   Copyright 2023-2024 The MathWorks, Inc.

    properties(Hidden,Transient)
        UIFigure                  matlab.ui.Figure
        Accordion                 matlab.ui.container.internal.Accordion

        % Accordion 1 control - Input selection
        InputDropDown             matlab.ui.control.internal.model.WorkspaceDropDown

        % Accordion 2 controls - Filter panel
        VELabel                   matlab.ui.control.Label
        VariableEditor            matlab.ui.control.internal.VariableEditor
        SparklinesIcon            matlab.ui.control.Image

        % Accordion 3 controls - Main pivot functionality
        ColumnsPanel              matlab.ui.container.Panel
        ColumnsMainAddButton      matlab.ui.control.Button
        ColumnsDropDowns          matlab.ui.control.DropDown
        ColumnsBinningSelectors   matlab.internal.dataui.BinningPopoutIcon
        ColumnsSubtractButtons    matlab.ui.control.Image
        ColumnsAddButtons         matlab.ui.control.Image

        RowsPanel                 matlab.ui.container.Panel
        RowsMainAddButton         matlab.ui.control.Button
        RowsDropDowns             matlab.ui.control.DropDown
        RowsBinningSelectors      matlab.internal.dataui.BinningPopoutIcon
        RowsSubtractButtons       matlab.ui.control.Image
        RowsAddButtons            matlab.ui.control.Image

        ValuesPanel               matlab.ui.container.Panel
        DataVarDropDown           matlab.ui.control.DropDown
        MethodDropDown            matlab.ui.control.DropDown
        CustomMethodSelector      matlab.internal.dataui.FunctionSelector

        % Accordion 4 controls - optional parameters
        IncludeRowTotalsCB        matlab.ui.control.CheckBox
        IncludeColumnTotalsCB     matlab.ui.control.CheckBox
        IncludeMissingGroupsCB    matlab.ui.control.CheckBox
        IncludeEmptyGroupsCB      matlab.ui.control.CheckBox
        RowLabelLocationLabel     matlab.ui.control.Label
        RowLabelLocationDropDown  matlab.ui.control.DropDown
        OutputFormatLabel         matlab.ui.control.Label
        OutputFormatDropDown      matlab.ui.control.DropDown
        IncludedEdgeLabel         matlab.ui.control.Label
        IncludedEdgeDropDown      matlab.ui.control.DropDown

        % Accordion 5 controls - display
        DisplayTableCB            matlab.ui.control.CheckBox
        ChartDropDown             matlab.ui.control.DropDown
    end

    properties(Access = private)
        % Dynamic internal helper properties
        AvailableGroupingVars = {}; % list of table variables allowed as grouping vars
        DefaultGroupVarIndex = 1; % location of best default grouping var in the above list
        AvailableDataVars = {}; % list of table variables allowed as data vars
        NumColumns = 0; % number of Columns selected by user
        NumRows = 0; % number of Rows selected by user
        VEWorkspace % workspace for the VariableEditor component
        FilterScript = {}; % script generated by the VariableEditor component
        ShowSparklines = false; % Whether sparklines and summaries are showing in the VariableEditor
        StaleFilterState = struct(); % Serialized filter state that was not able to be set on load
        TaskIsStale = false; % Whether task has been loaded with selected input data not in workspace
        FilterSize = [0 0]; % Size of input after filtering, used for label above the VariableEditor
        InputClass = ''; % table or timetable, used for label above the VariableEditor
        InputHeight = 0; % Height of input table before filtering
        HeatmapByDefault = false; % only updated if user types "heatmap" as keyword
        DataVarIsNumeric = true; % used to determine if heatmap is available
        DataVarActsNumeric = true; % numeric or char or logical
    end

    properties(Access = private, Constant)
        % Constant internal helper properties
        AutoRunCutOff = 1e6;  % table height to trigger turning off AutoRun
        TextRowHeight = 22;   % Height of rows with normal controls
        GridPadding = 5;      % Padding of grids within AccordionPanels
        IconWidth = 16;       % For +/-/Rows/Columns/Values/Sparklines icons
        PanelHeight = 100;    % Height of Rows/Columns/Values panels
        PanelBorder = 2;      % BorderWidth of Rows/Columns/Values panels
        SearchableThreshold = 15;     % Grouping and Data Variable DropDowns become searchable when they have more than this many values
        FilterName = 'filteredTable'; % Name used for generated script when filtering
        OutputName = 'pivotedData';   % Name for output of task
        % Default values for controls in the task. Used to set defaults and
        % determine what needs to be saved in the State for serialization
        Defaults = struct("InputDropDown",'select variable',...
            "DataVarDropDown",':',... % Value for <nodatavar>, a character that cannot be confused for a table variable name
            "MethodDropDown",'count',...
            "IncludeColumnTotalsCB",false,...
            "IncludeRowTotalsCB",false,...
            "IncludeMissingGroupsCB",true,...
            "IncludeEmptyGroupsCB",false,....
            "IncludedEdgeDropDown",'left',...
            "OutputFormatDropDown",'nested',...
            "RowLabelLocationDropDown",'rowNames',...
            "DisplayTableCB",true,...
            "ChartDropDown",'none',...
            "MethodDropDownItemsData",{{'count' 'percentage'}},...
            "AvailableGroupingVars",{{}},...
            "AvailableDataVars",{{}},...
            "DefaultGroupVarIndex",1,...
            "NumColumns",0,...
            "NumRows",0,...
            "FilterScript",{{}},...
            "ShowSparklines",false,...
            "FilterSize",[0 0],...
            "InputClass",'',...
            "InputHeight",0,...
            "DataVarIsNumeric",true,...
            "DataVarActsNumeric",true,...
            "HeatmapByDefault",false,...
            "CustomMethodSelectorState",struct("FcnType",'local',...
            "LocalValue",'select variable',"HandleValue",'@(x) nnz(isoutlier(x))'));
        CustomMethodSelectorNoOpState = struct("FcnType",'handle',...
            "LocalValue",'select variable',"HandleValue",'@(x)x');
        % Serialization versions - used for managing forward compatibility
        %   1: Initial ship (R2023b)
        %   2: Add HeatmapByDefault to State (R2024a)
        %   3: Minimize number of State fields (R2024b)
        %   4: Added "no aggregation" method (R2025a)
        Version = 4;
    end

    properties(Dependent)
        State     % State of the live task, a struct used for serialization
        Summary   % Dynamic summary line of the task
        Workspace % WorkspaceDropDowns within the task use this workspace
    end

    methods(Access = public)
        function app = PivotTableTask(fig,workspace)
            % Constructor allows tests to pass in figure and workspace
            arguments
                fig = uifigure(Position=[50 50 1000 1000]);
                workspace = "base";
            end
            % Pass to live task base constructor
            app@matlab.task.LiveTask(Parent=fig);
            % set properties as needed
            app.UIFigure = fig;
            app.Workspace = workspace;
            app.UIFigure.AutoResizeChildren = false;
        end
    end

    methods(Access = protected)
        function setup(app)
            % Method called in LiveTask constructor
            createComponents(app);
            setValuesToDefault(app);
            doUpdate(app);
        end
    end

    methods(Access=private)
        % Helper methods

        % implementation in createComponents.m
        createComponents(app)

        function updateDefaultsFromKeyword(app,kw)
            % Used to change default values on initialization with a keyword
            if startsWith("heatmap",kw,'IgnoreCase',true)
                % User typed keyword 'heatmap', so this instance should
                % have heatmap on by default
                app.HeatmapByDefault = true;
                app.ChartDropDown.Value = 'heatmap';
                doUpdate(app);
            end
        end

        function setValuesToDefault(app)
            % Used to set initial values on construction, to update values
            % on change in input table, and to reset values via the "reset"
            % method
            clearTableVariables(app);
            if hasData(app)
                % Set values based on input data in workspace
                T = app.InputDropDown.WorkspaceValue;
                app.FilterSize = size(T);
                app.InputClass = class(T);
                app.InputHeight = height(T);
                assignin(app.VEWorkspace,app.FilterName,T);
                % Data variables
                app.AvailableDataVars = T.Properties.VariableNames';
                % Grouping variables
                gvars = app.AvailableDataVars(varfun(@matlab.internal.dataui.isValidGroupingVar,T,OutputFormat="uniform"));
                T = T(:,gvars);
                if istimetable(T)
                    gvars = [T.Properties.DimensionNames(1); gvars];
                end
                app.AvailableGroupingVars = gvars;
                app.DefaultGroupVarIndex = matlab.internal.dataui.getDefaultGroupingVarIndex(T);
            end
            % Allow <nodatavar> option for 'count' and 'percentage' methods
            app.DataVarDropDown.Items = [("<" + getMsgText(app,"NoDataVar") + ">"); app.AvailableDataVars];
            app.DataVarDropDown.ItemsData = [{app.Defaults.DataVarDropDown}; app.AvailableDataVars];
            % Make dropdown searchable if there are lots of variables
            app.DataVarDropDown.Editable = numel(app.AvailableDataVars) >= app.SearchableThreshold;
            % Default to no datavar and 'count' method
            app.DataVarDropDown.Value = app.Defaults.DataVarDropDown;
            setMethodDDByDataVar(app);
            % Default values for the 'custom' method
            app.CustomMethodSelector.State = app.Defaults.CustomMethodSelectorState;

            % Remaining options should match function defaults for NVs
            for k = ["IncludeRowTotalsCB" "IncludeColumnTotalsCB" ...
                    "IncludeMissingGroupsCB" "IncludeEmptyGroupsCB" ...
                    "RowLabelLocationDropDown" "OutputFormatDropDown" ...
                    "IncludedEdgeDropDown" "DisplayTableCB"]
                app.(k).Value = app.Defaults.(k);
            end
            % unless user typed 'heatmap' as keyword to launch task
            app.ChartDropDown.Value = app.ChartDropDown.ItemsData{1+app.HeatmapByDefault};
        end

        function clearTableVariables(app)
            % Reset everything reliant on the input table to prep for a new
            % input variable
            if ~isempty(app.FilterScript)
                % resetFilters can be slow, so only run as needed
                % but need to remove any filtering in the VE prior to
                % changing the Variable
                app.VariableEditor.resetFilters();
                app.FilterScript = {};
            end
            % Give the VE a default variable as a placeholder
            assignin(app.VEWorkspace,app.FilterName,table(1));
            for k = ["AvailableGroupingVars" "AvailableDataVars" ...
                    "DefaultGroupVarIndex" "FilterSize" "InputClass" "InputHeight"]
                app.(k) = app.Defaults.(k);
            end
            % Remove any grouping variables selected
            src = struct('UserData',1);
            for k = 1:app.NumColumns
                app.subtractRowsColumnsVar(src,[],'Columns');
            end
            for k = 1:app.NumRows
                app.subtractRowsColumnsVar(src,[],'Rows');
            end
        end

        function updateBinningSelectorData(app,RC,n)
            % Called whenever a new grouping variable is selected.
            % Set the binning controls to default based on this variable
            % and open the popout if binning by default
            varname = app.([RC 'DropDowns'])(n).Value;
            selector = app.([RC 'BinningSelectors'])(n);
            selector.VariableName = varname;
            selector.Variable = app.InputDropDown.WorkspaceValue.(varname);
            if ~isequal(selector.Value,'"none"')
                % First make sure the selector is positioned correctly
                updateBinningSelectors(app,RC);
                drawnow;
                % Then auto-open it
                open(selector);
            end
        end

        function setMethodDDByDataVar(app)
            % Called on reseting task and on changing data variable: Set
            % methods available for the selected variable. Also set
            % DataVarIsNumeric and DataVarActsNumeric. These help us
            % determine if a chart can be created from the pivoted table.

            varName = app.DataVarDropDown.Value;
            if isequal(varName,app.Defaults.DataVarDropDown)
                % no data variable selected, only show counts and percentages
                items = [getMsgText(app,"count") getMsgText(app,"percentage")];
                itemsData = app.Defaults.MethodDropDownItemsData;
                app.DataVarIsNumeric = app.Defaults.DataVarIsNumeric;
                app.DataVarActsNumeric = app.Defaults.DataVarActsNumeric;
            else
                % data variable selected, determine what methods to show
                var = app.InputDropDown.WorkspaceValue.(varName);
                method2filterDictionary = matlab.internal.dataui.groupsummaryMethodName2FilterFcn();
                methods = cellstr(keys(method2filterDictionary));
                N = numel(methods);
                showMethod = true(N,1);
                for k = 1:N
                    fcn = method2filterDictionary(methods{k});
                    showMethod(k) = fcn(var);
                end
                itemsData = methods(showMethod);
                items = getMethodMessages(itemsData);
                app.DataVarIsNumeric = isnumeric(var); % Actually numeric
                app.DataVarActsNumeric = app.DataVarIsNumeric || ischar(var) ...
                    || islogical(var); % Numeric is returned for 'sum' 'mean' 'std' and 'range'
            end
            app.MethodDropDown.Items = items;
            app.MethodDropDown.ItemsData = itemsData;
            app.MethodDropDown.Value = itemsData{1};
        end

        function tf = hasData(app)
            % Determine if an input table been selected
            tf = ~isequal(app.InputDropDown.Value,app.Defaults.InputDropDown);
        end

        function str = getMsgText(~,str,varargin)
            % Get message catalog string
            str = string(message("MATLAB:tableui:pivot" +str,varargin{:}));
        end
    end

    methods(Access = private)
        % Callbacks for controls
        function addRowsColumnsVar(app,~,~,RC,fromSetState)
            % Callback for the Rows/Columns "Add" buttons and the "+"
            % buttons Add a grouping variable dropdown, set its items and
            % default, along with +/- icons and its pop-out binning
            % controls. Binning options are also set to default for the
            % default grouping variable.

            % Second and third inputs are src and ev from the callback
            % which are passed in but not used.
            % RC is either 'Rows' or 'Columns'.
            if nargin < 5
                % from a callback
                if isempty(app.InputDropDown.WorkspaceValue)
                    % Input data has been cleared. Skip to doUpdate to
                    % reset the task since adding a binning icon requires
                    % variable to exist
                    doUpdate(app,struct('Tag',''));
                    return
                end
                fromSetState = false;
            end
            % Set NumRows or NumColumns
            app.(['Num' RC]) = app.(['Num' RC]) + 1;
            n = app.(['Num' RC]);
            % grab the handle to the appropriate grid
            g = app.([RC 'Panel']).Children;
            g.RowHeight = repmat(22,1,n);
            % Create a row of controls: dropdown, binningIcon, -/+ buttons
            app.([RC 'DropDowns'])(n) = uidropdown(g,...
                Items=app.AvailableGroupingVars,...
                ItemsData=app.AvailableGroupingVars,...
                Value=app.AvailableGroupingVars{app.DefaultGroupVarIndex},...
                ValueChangedFcn=@app.handleEditableAndDoUpdate,...
                UserData=n,...
                Tag=[RC 'DropDowns'],...
                Editable=(numel(app.AvailableGroupingVars) > app.SearchableThreshold));
            app.([RC 'DropDowns'])(n).Layout.Column = [1 2];
            app.([RC 'DropDowns'])(n).Layout.Row = n;
            app.([RC 'BinningSelectors'])(n) = matlab.internal.dataui.BinningPopoutIcon( ...
                Parent=g, ValueChangedFcn=@app.doUpdate);
            app.([RC 'BinningSelectors'])(n).Layout.Column = 3;
            app.([RC 'BinningSelectors'])(n).Layout.Row = n;
            if ~fromSetState
                updateBinningSelectorData(app,RC,n);
            end
            app.([RC 'SubtractButtons'])(n) = uiimage(g, ...
                ScaleMethod="none",...
                ImageClickedFcn={@app.subtractRowsColumnsVar RC}, ...
                UserData=n,...
                Tooltip=getMsgText(app,"Remove" + RC,num2str(n)));
            matlab.ui.control.internal.specifyIconID(app.([RC 'SubtractButtons'])(n),...
                'minusUI',app.IconWidth,app.IconWidth);
            app.([RC 'SubtractButtons'])(n).Layout.Column = 4;
            app.([RC 'SubtractButtons'])(n).Layout.Row = n;
            app.([RC 'AddButtons'])(n) = uiimage(g, ...
                ScaleMethod="none",...
                ImageClickedFcn={@app.addRowsColumnsVar RC},...
                Tooltip=getMsgText(app,"Add" + RC));
            matlab.ui.control.internal.specifyIconID(app.([RC 'AddButtons'])(n),...
                'plusUI',app.IconWidth,app.IconWidth);
            app.([RC 'AddButtons'])(n).Layout.Column = 5;
            app.([RC 'AddButtons'])(n).Layout.Row = n;

            if ~fromSetState
                % Auto-open display results - at minimum we need a grouping
                % variable to generate results, so we hide that section by
                % default until then
                app.Accordion.Children(end).Collapsed = false;
                % Send 2nd input so doUpdate knows this came from a callback
                doUpdate(app,struct('Tag',''));
            end
        end

        function subtractRowsColumnsVar(app,src,ev,RC)
            % Delete selected grouping variable dropdown and everything
            % else on its row within its panel

            % update NumRows/NumColumns
            app.(['Num' RC]) = app.(['Num' RC]) -1;

            % Save all the selected Values and redistribute them instead
            % of moving everything. This saves us from having to reset
            % UserData and is a bit faster.
            vars = {app.([RC 'DropDowns']).Value};
            n = src.UserData;
            vars(n) = [];

            % delete last row
            delete(app.([RC 'DropDowns'])(end))
            app.([RC 'DropDowns'])(end) = [];
            delete(app.([RC 'SubtractButtons'])(end))
            app.([RC 'SubtractButtons'])(end) = [];
            delete(app.([RC 'AddButtons'])(end))
            app.([RC 'AddButtons'])(end) = [];

            % Set the value of the remaining dropdowns (same as before, but
            % shifting up as needed)
            % All Items lists and other props are the same
            if ~isempty(vars)
                [app.([RC 'DropDowns']).Value] = deal(vars{:});
            end

            % Also remove corresponding binning selector. Properties are
            % different for each selector based on selected grouping
            % variable, so instead of deleting the last one, delete the nth
            % one and move the rest up as needed
            delete(app.([RC 'BinningSelectors'])(n))
            app.([RC 'BinningSelectors'])(n) = [];
            for k=1:numel(app.([RC 'BinningSelectors']))
                app.([RC 'BinningSelectors'])(k).Layout.Row = k;
            end

            % reset the grid
            if app.(['Num' RC]) > 0
                app.([RC 'Panel']).Children.RowHeight(end) = [];
            end

            if ~isempty(ev)
                % Send 2nd input so doUpdate knows this came from a callback
                doUpdate(app,struct('Tag',''));
                % Else comes from a task reset and will be updated later
            end
        end

        function anyBinnable = updateBinningSelectors(app,RC)
            % Update the Rows/Columns grid based on whether any of the
            % variables are binnable. The Selectors update their own
            % Tooltip/Visible/Icon/etc on interaction.
            anyBinnable = any([app.([RC 'BinningSelectors']).VariableIsBinnable]);
            % If no binnable variables are selected, then we don't need to
            % show the column with the binning icon:
            % Set the column width to 22 or 0
            app.([RC 'Panel']).Children.ColumnWidth{3} = app.TextRowHeight*anyBinnable;
        end

        function handleFilterInteraction(app,userActionObj)
            % Callback for VariableEditor being filtered
            % Save current filter script for use in generated code
            app.FilterScript = cellstr(userActionObj.Code);
            % Get current size of the filtered table for label above VE
            T = evalin(app.VEWorkspace,app.FilterName);
            app.FilterSize = size(T);
            % Send 2nd input so doUpdate knows this came from a callback
            doUpdate(app,struct('Tag',''));
        end

        function sparklinesIconClicked(app,~,~)
            % Callback for sparklines icon clicked
            app.ShowSparklines = ~app.ShowSparklines;
            % Send 2nd input so doUpdate knows this came from a callback
            doUpdate(app,struct('Tag',''));
        end

        function handleEditableAndDoUpdate(app,src,ev)
            % Callback for grouping and data variable dropdowns
            if ev.Edited
                % The dropdown's Editable property is on, and the user has
                % typed something that is not in the dropdown Items list.
                % Revert to previous valid value
                src.Value = ev.PreviousValue;
                return
            end
            % Pass along src so doUpdate knows this came from a callback
            app.doUpdate(src);
        end

        % implementation in doUpdate.m
        doUpdate(app,src,evt)
    end

    methods
        % Public live task methods

        % implementation in generateCode.m
        [code,outputs] = generateCode(app)

        function summary = get.Summary(app)
            % Dynamic summary line of the task changes based on input table
            % name, selected grouping variables, selected method, and
            % selected data variable. It also indicates whether the data
            % has been filtered.

            if ~hasData(app) || (app.NumColumns == 0 && app.NumRows == 0)
                % Match the task description
                summary = string(message('MATLAB:tableui:Tool_PivotTableTask_Description'));
            else
                method = app.MethodDropDown.Value;
                % Add ticks around method name, table name and table
                % variable names. This tells the LE to bold these substrings
                methodStr = ['`' app.MethodDropDown.Items{strcmp(app.MethodDropDown.ItemsData,method)} '`'];
                if ismember(method,{'count' 'percentage'})
                    inputStr = ['`' app.InputDropDown.Value '`'];
                else
                    inputStr = ['`' app.DataVarDropDown.Value '`'];
                end
                groups = append('`',{app.RowsDropDowns.Value app.ColumnsDropDowns.Value},'`');
                N = numel(groups);
                if ~isequal(app.FilterSize(1),app.InputHeight)
                    filterFlag = "F";
                else
                    filterFlag = "";
                end
                if matches(method,["none" "CustomFunction"])
                    % special case messages in catalog rather than pass in
                    % method name to fill message hole
                    if N > 3
                        summary = getMsgText(app,"Summary4" + filterFlag + method,inputStr);
                    else
                        summary = getMsgText(app,"Summary" + N + filterFlag + method,inputStr,groups{:});
                    end
                else
                    if N > 3
                        summary = getMsgText(app,"Summary4" + filterFlag,methodStr,inputStr);
                    else
                        summary = getMsgText(app,"Summary" + N + filterFlag,methodStr,inputStr,groups{:});
                    end
                end
            end
        end

        function state = get.State(app)
            % The State of the live task is a struct with everything needed
            % to reset the task on load. The LE will use jsonencode and
            % jsondecode on this struct for serialization.
            state = struct();
            % Always save these fields in the state
            state.VersionSavedFrom = app.Version;
            state.MinCompatibleVersion = 1;
            state.AccordionsCollapsed = [app.Accordion.Children(2:end).Collapsed];
            state.FilterState = app.VariableEditor.getFilterState();
            state.NumRows = app.NumRows;
            state.NumColumns = app.NumColumns;
            % Save Values of all controls that are not default-valued
            for k = ["InputDropDown" "DataVarDropDown" ...
                    "IncludeColumnTotalsCB" "IncludeRowTotalsCB" ...
                    "IncludeMissingGroupsCB" "IncludeEmptyGroupsCB" ....
                    "IncludedEdgeDropDown" "OutputFormatDropDown" ...
                    "RowLabelLocationDropDown" "DisplayTableCB" "ChartDropDown"]
                if ~isequal(app.(k).Value,app.Defaults.(k))
                    state.(k + "Value") = app.(k).Value;
                end
            end
            if ~isequal(app.MethodDropDown.ItemsData,app.Defaults.MethodDropDownItemsData) || ...
                    ~isequal(app.MethodDropDown.Value,app.Defaults.MethodDropDown)
                state.MethodDropDownItemsData = app.MethodDropDown.ItemsData;
                state.MethodDropDownValue = app.MethodDropDown.Value;
                hasNoneMethod = isequal("none",state.MethodDropDownItemsData{1});
                if hasNoneMethod
                    % For compatibility prior to 25a, the 'none' method
                    % needs to be stripped from the items list and this
                    % value stored separately
                    state.HasNoneMethod = true;
                    state.MethodDropDownItemsData(1) = [];
                    if isequal(state.MethodDropDownValue,'none')
                        state.MethodIsNone = true;
                        % The closest thing to allowing the user to pick
                        % "none" prior to 25a is defining a custom function
                        % that does a no-op: @(x)x
                        state.MethodDropDownValue = 'CustomFunction';
                        state.CustomMethodSelectorState = app.CustomMethodSelectorNoOpState;
                    end
                end
            end

            % Save Values of controls stored in arrays and States of custom
            % components
            if app.NumColumns > 0
                state.ColumnsDropDownsValues = {app.ColumnsDropDowns.Value};
                state.ColumnsBinningSelectorsStates = [app.ColumnsBinningSelectors.State];
            end
            if app.NumRows > 0
                state.RowsDropDownsValues = {app.RowsDropDowns.Value};
                state.RowsBinningSelectorsStates = [app.RowsBinningSelectors.State];
            end
            if ~isequal(app.CustomMethodSelector.State,app.Defaults.CustomMethodSelectorState)
                % If MethodIsNone, but user has defined their own custom
                % function, then user choice overrides the no-op function
                state.CustomMethodSelectorState = app.CustomMethodSelector.State;
            end

            % Save all other properties if non-default
            for k = ["AvailableGroupingVars" "AvailableDataVars" ...
                    "DefaultGroupVarIndex" "FilterScript" "ShowSparklines" ...
                    "FilterSize" "InputClass" "InputHeight" "DataVarIsNumeric" ...
                    "DataVarActsNumeric" "HeatmapByDefault"]
                if ~isequal(app.(k),app.Defaults.(k))
                    state.(k) = app.(k);
                end
            end
        end

        function set.State(app,state)
            % Update the live task based on a saved State struct

            if app.Version < state.MinCompatibleVersion
                % State was saved from a future incompatible version
                return
            end

            clearTableVariables(app);

            % Input table and VE Panel
            if isfield(state,"InputDropDownValue")
                value = state.InputDropDownValue;
                app.InputDropDown.populateVariables();
                if ~ismember(value,app.InputDropDown.ItemsData)
                    % Selected input is not in workspace
                    app.InputDropDown.Value = value;
                    app.StaleFilterState = state.FilterState;
                    app.TaskIsStale = true;
                else
                    % Selected input is listed in workspace (but its value
                    % may be different than when the task was saved, thus
                    % the try/catch!)
                    app.InputDropDown.Value = value;
                    assignin(app.VEWorkspace,app.FilterName,app.InputDropDown.WorkspaceValue);
                    try
                        app.VariableEditor.setFilterState(state.FilterState);
                        app.TaskIsStale = false;
                    catch
                        app.StaleFilterState = state.FilterState;
                        app.TaskIsStale = true;
                    end
                end
            else
                % no input, reset default
                app.InputDropDown.Value = app.Defaults.InputDropDown;
            end
            % Set all other saved task properties
            for k = ["AvailableGroupingVars" "AvailableDataVars" ...
                    "DefaultGroupVarIndex" "FilterScript" "ShowSparklines"...
                    "FilterSize" "InputClass" "InputHeight" ...
                    "DataVarIsNumeric" "DataVarActsNumeric" "HeatmapByDefault"]
                if isfield(state,k)
                    app.(k) = state.(k);
                else
                    app.(k) = app.Defaults.(k);
                end
            end

            % Update Rows/Columns Panels
            for k = 1:state.NumRows
                addRowsColumnsVar(app,[],[],'Rows',true);
                app.RowsDropDowns(k).Value = state.RowsDropDownsValues{k};
                app.RowsBinningSelectors(k).State = state.RowsBinningSelectorsStates(k);
            end
            for k = 1:state.NumColumns
                addRowsColumnsVar(app,[],[],'Columns',true);
                app.ColumnsDropDowns(k).Value = state.ColumnsDropDownsValues{k};
                app.ColumnsBinningSelectors(k).State = state.ColumnsBinningSelectorsStates(k);
            end

            % Update Values Panel
            if isfield(state,"DataVarDropDownValue")
                val = state.DataVarDropDownValue;
            else
                val = app.Defaults.DataVarDropDown;
            end
            app.DataVarDropDown.ItemsData = [{app.Defaults.DataVarDropDown}; app.AvailableDataVars];
            app.DataVarDropDown.Items = [("<" + getMsgText(app,"NoDataVar") + ">"); app.AvailableDataVars];
            app.DataVarDropDown.Value = val;
            if isfield(state,"MethodDropDownItemsData")
                if ismember('count',state.MethodDropDownItemsData)
                    app.MethodDropDown.ItemsData = state.MethodDropDownItemsData;
                    app.MethodDropDown.Items = [getMsgText(app,"count") getMsgText(app,"percentage")];
                else
                    app.MethodDropDown.ItemsData = state.MethodDropDownItemsData;
                    app.MethodDropDown.Items = getMethodMessages(state.MethodDropDownItemsData);
                end
                app.MethodDropDown.Value = state.MethodDropDownValue;
            else
                app.MethodDropDown.ItemsData = app.Defaults.MethodDropDownItemsData;
                app.MethodDropDown.Items = [getMsgText(app,"count") getMsgText(app,"percentage")];
                app.MethodDropDown.Value = app.Defaults.MethodDropDown;
            end
            if isfield(state,"HasNoneMethod")
                % For compatibility with pre-25a, 'none' is stored separately
                app.MethodDropDown.Items = [getMethodMessages({'none'}) app.MethodDropDown.Items];
                app.MethodDropDown.ItemsData = [{'none'} app.MethodDropDown.ItemsData];
                if isfield(state,"MethodIsNone")
                    app.MethodDropDown.Value = 'none';
                end
            end
            if isfield(state,"CustomMethodSelectorState") && ...
                    ~(isfield(state,"MethodIsNone") && ...
                    isequal(state.CustomMethodSelectorState,app.CustomMethodSelectorNoOpState))
                app.CustomMethodSelector.State = state.CustomMethodSelectorState;
            else
                % Not saved in state means default, and MethodIsNone with
                % No-op state means this was most likely saved for
                % compatibility only, revert to default
                app.CustomMethodSelector.State = app.Defaults.CustomMethodSelectorState;
            end

            % Remaining controls
            for k = ["IncludeColumnTotalsCB" "IncludeRowTotalsCB" ...
                    "IncludeMissingGroupsCB" "IncludeEmptyGroupsCB" ....
                    "IncludedEdgeDropDown" "OutputFormatDropDown" ...
                    "RowLabelLocationDropDown" "DisplayTableCB" "ChartDropDown"]
                if isfield(state,k + "Value")
                    app.(k).Value = state.(k + "Value");
                else
                    % Value not saved, so revert to default value
                    app.(k).Value = app.Defaults.(k);
                end
            end

            % Finally, position the accordions as saved
            if isfield(state,"AccordionsCollapsed")
                for k = 1:numel(state.AccordionsCollapsed)
                    app.Accordion.Children(k+1).Collapsed = state.AccordionsCollapsed(k);
                end
            end
            doUpdate(app);
        end

        function reset(app)
            % Called by the LE when user selects "Restore Default Values"
            % from the context menu of the live task

            % Don't change the input data, but reset everything else to
            % default
            setValuesToDefault(app);
            doUpdate(app);
        end

        function initialize(app,NVpairs)
            % Called by the live editor after construction if it has any
            % suggestions for Inputs or if the user typed in a keyword to
            % launch the task
            arguments
                app
                NVpairs.Inputs  string = ""; % potential inputs
                NVpairs.TableVariableNames string = ""; % not used
                NVpairs.Code string = ""; % keyword
            end

            if ~isequal(NVpairs.Code,"")
                updateDefaultsFromKeyword(app,NVpairs.Code);
            end

            if ~isequal(NVpairs.Inputs,"") && ~isempty(NVpairs.Inputs)
                inputs = NVpairs.Inputs;
                % Set the InputDataDropDown value to the first valid item
                % from inputs
                app.InputDropDown.populateVariables();
                for k = 1:numel(inputs)
                    % Check each suggestion to see if it is a valid input
                    if ismember(inputs(1),app.InputDropDown.ItemsData)
                        app.InputDropDown.Value = inputs(k);
                        doUpdate(app,struct("Tag","InputDropDown"));
                        break
                    end
                end
            end
        end

        function set.Workspace(app,ws)
            % Sets the Workspace property of each WorkspaceDropDown within
            % the task
            app.InputDropDown.Workspace = ws;
            for k = 1:app.NumColumns
                app.ColumnsBinningSelectors(k).Workspace = ws;
            end
            for k = 1:app.NumRows
                app.RowsBinningSelectors(k).Workspace = ws;
            end
        end

        function ws = get.Workspace(app)
            ws = app.InputDropDown.Workspace;
        end
    end
end

function strs = getMethodMessages(strsIn)
% Cellstr of messages
% These are shared messages with ComputeByGroup
strs = cellfun(@(s)getString(message(['MATLAB:tableui:grouping' s])),strsIn,UniformOutput=false);
if isequal(strsIn{1},'none')
    % rather than 'groupingnone' which is the 'none' binning method, we
    % need the message for the 'none' aggregation method
    strs{1} = getString(message('MATLAB:tableui:pivotNoAggregation'));
end
end