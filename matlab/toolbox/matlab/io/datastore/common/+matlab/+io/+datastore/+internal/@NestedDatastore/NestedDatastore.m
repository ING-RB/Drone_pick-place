classdef NestedDatastore < matlab.io.Datastore ...
                         & matlab.io.datastore.Partitionable
%matlab.io.datastore.internal.NestedDatastore   A datastore that iterates over another datastore.
%
%   NDS = matlab.io.datastore.internal.NestedDatastore(OUTERDS, INNERDSFCN)
%       creates a datastore NDS that passes every read from OUTERDS to INNERDSFCN and
%       iterates over the generated inner datastore.
%
%       OUTERDS must be a datastore (subclasss of matlab.io.Datastore or
%       matlab.io.datastore.Datastore).
%
%       FCN must have the following signature:
%
%           INNERDS = INNERDSFCN(data)
%
%       where "data" is from each read of OUTERDS. INNERDS must never be empty (i.e.
%       hasdata() on INNERDS should never return false after construction.)
%
%       NestedDatastore is used to describe the idea of "nested iteration" with datastore.
%
%       For example, this NestedDatastore code:
%
%           NDS = NestedDatastore(OUTERDS, INNERDSFCN);
%
%           while hasdata(NDS)
%               nestedData = read(NDS);
%           end
%
%       is similar to manually calling INNERDSFCN in a while-hasdata-read loop:
%
%           while hasdata(OUTERDS)
%               data = read(OUTERDS);
%
%               INNERDS = INNERDSFCN(data);
%               while hasdata(INNERDS)
%                   nestedData = read(INNERDS);
%               end
%           end
%
%       The benefit of using NestedDatastore over the manual while-hasdata-loop is that
%       NestedDatastore can be incrementally iterated over, save-loaded, compared, etc.
%
%       Here is an example of using NestedDatastore to read 3 rows at a time from XML files:
%
%         import matlab.io.datastore.internal.NestedDatastore;
%
%         files = ["students.xml" "music.xml"];
%         XMLds = fileDatastore(files, ReadFcn=@(f) readtable(f, VariableSelectors="//@FirstName"));
%
%         threeRowsXMLds = NestedDatastore(XMLds, @(T) arrayDatastore(T, OutputType="same", ReadSize=3));
%
%         hasdata(threeRowsXMLds) % true
%         read(threeRowsXMLds)    % ["Priya"; "Conor"; "Morgan"]
%         read(threeRowsXMLds)    % ["Salim"; "Salim"; "Dania"]
%         read(threeRowsXMLds)    % ["Rikki"]
%         hasdata(threeRowsXMLds) % false
%
%       NOTE: NestedDatastore will only partition at the OUTERDS level. It will not consider the
%             inner datastore for partitioning.
%             Use matlab.io.datastore.internal.RepeatedDatastore if you need nested datastore
%             functionality with granular partitioning.
%
%   NDS = matlab.io.datastore.internal.NestedDatastore(OUTERDS, INNERDSFCN, IncludeInfo=TF) will
%       include the "info" struct when calling INNERDSFCN.
%
%       So the signature of INNERDSFCN will change to:
%
%           INNERDS = INNERDSFCN(data, info)
%
%       where "data" and "info" are from each read call on the OUTERDS.
%
%   matlab.io.datastore.internal.NestedDatastore Properties:
%
%     OuterDatastore    | The outer datastore used for iteration           | datastore | Read-only
%     InnerDatastore    | The inner datastore currently used for iteration | datastore | Read-only
%     InnerDatastoreFcn | Function used to generate the inner datastore    | function  | Read-only
%     IncludeInfo       | Pass the "info" struct to InnerDatastoreFcn      | logical   | Read-only
%
%   NOTE: InnerDatastore is generated by InnerDatastoreFcn at read-time. After
%         construction (but before read()), InnerDatastore may be set to a default value.
%         This also occurs after reset().
%
%   matlab.io.datastore.internal.NestedDatastore Methods:
%
%     hasdata       - Returns true if there is more data in the datastore.
%     read          - Returns the next read from the InnerDatastore.
%     reset         - Resets the datastore to the start of the range.
%     preview       - Returns the first read from the InnerDatastore.
%     readall       - Returns all the data that can be read.
%     partition     - Returns a new datastore that iterates over a part of the
%                     OuterDatastore.
%     numpartitions - Provides an estimate for a reasonable number of
%                     partitions.
%     transform     - Create an altered form of the current datastore by
%                     specifying a function handle that will execute
%                     after read on the current datastore.
%     combine       - Create a new datastore that horizontally
%                     concatenates the result of read from two or more
%                     input datastores.
%
%   See also: arrayDatastore, matlab.io.datastore.ArrayDatastore.read,
%       matlab.io.Datastore.combine, matlab.io.datastore.ArrayDatastore.readall,
%       matlab.io.datastore.ArrayDatastore.reset

%   Copyright 2021 The MathWorks, Inc.

    properties (SetAccess = private)
        OuterDatastore    (1, 1) {mustBeDatastore} = matlab.io.datastore.internal.RangeDatastore();
        InnerDatastore    (1, 1) {mustBeDatastore} = matlab.io.datastore.internal.RangeDatastore();
        InnerDatastoreFcn (1, 1) {mustBeA(InnerDatastoreFcn, "matlab.mixin.internal.FunctionObject")} = ...
            matlab.io.datastore.internal.functor.FunctionHandleFunctionObject(@(data) matlab.io.datastore.internal.RangeDatastore());
        IncludeInfo       (1, 1) logical           = false;
    end

    properties (Access = private, Constant)
        % Save-load metadata.
        % ClassVersion = 1 corresponds to the first release of NestedDatastore in R2022a.
        ClassVersion(1, 1) double = 1;
    end

    methods
        function nds = NestedDatastore(OuterDatastore, InnerDatastoreFcn, args)
            arguments
                OuterDatastore    (1, 1) {mustBeDatastore}
                InnerDatastoreFcn
                args.IncludeInfo  (1, 1) logical = false;
            end
            import matlab.io.datastore.internal.functor.makeFunctionObject

            nds.OuterDatastore    = copy(OuterDatastore);
            nds.InnerDatastoreFcn = makeFunctionObject(InnerDatastoreFcn);
            nds.IncludeInfo       = args.IncludeInfo;

            nds.OuterDatastore.reset();
        end

        function set.InnerDatastoreFcn(nds, fcn)
            import matlab.io.datastore.internal.functor.makeFunctionObject
            nds.InnerDatastoreFcn = makeFunctionObject(fcn);
        end
    end

    methods (Access=protected)
        n = maxpartitions(nds);

        ndsCopy = copyElement(nds);
    end

    methods (Hidden)
        % Declaration for the progress method, to ensure that it is Hidden.
        frac = progress(nds);

        S = saveobj(nds);

        result = visitUnderlyingDatastores(ds, visitFcn, combineFcn)
    end

    methods (Hidden, Static)
        arrds = loadobj(S);
    end
end

function mustBeDatastore(ds)
    if ~isa(ds, "matlab.io.Datastore") && ~isa(ds, "matlab.io.datastore.Datastore")
        error(message("MATLAB:io:datastore:common:validation:InvalidDatastoreInput"));
    end
end
