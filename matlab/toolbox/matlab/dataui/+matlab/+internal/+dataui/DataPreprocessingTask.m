classdef (Hidden = true, AllowedSubclasses = ...
        {?matlab.internal.dataui.dataSmoother ...
        ?matlab.internal.dataui.missingDataCleaner ...
        ?matlab.internal.dataui.outlierDataCleaner ...
        ?matlab.internal.dataui.localExtremaFinder ...
        ?matlab.internal.dataui.changePointsFinder ...
        ?matlab.internal.dataui.trendRemover ...
        ?matlab.internal.dataui.NormalizeDataTask ...
        ?matlab.internal.dataui.FindSeasonalTrendsTask}) ...
        DataPreprocessingTask < matlab.task.LiveTask
    % DataPreprocessingTask Helper class for data preprocessing live tasks
    %
    %   FOR INTERNAL USE ONLY -- This feature is intentionally undocumented.
    %   Its behavior may change, or it may be removed in a future release.

    %   Copyright 2019-2024 The MathWorks, Inc.

    % All properties are Transient because we do not have a use-case for
    % saving and loading these objects. They get serialized in the Live
    % Editor through the State property.

    % Internal properties for widgets
    properties (Access = public, Transient, Hidden)
        % Widget layout
        UIFigure                            matlab.ui.Figure
        Accordion                           matlab.ui.container.internal.Accordion

        % "Input data" widgets
        InputDataDropDown                   matlab.ui.control.internal.model.WorkspaceDropDown
        DataVarSelectionTypeDropDown        matlab.ui.control.DropDown
        DataVarGrid                         matlab.ui.container.GridLayout
        InputDataTableVarDropDown           matlab.ui.control.DropDown
        InputTableVarAddButton              matlab.ui.control.Image
        InputTableVarSubtractButton         matlab.ui.control.Image
        OutputTypeDropDown                  matlab.ui.control.DropDown

        % "X-axis" (SamplePoints) widgets
        SamplePointsDropDown                matlab.ui.control.internal.model.WorkspaceDropDown
        SamplePointsTableVarDropDown        matlab.ui.control.DropDown

        % Needed for plots
        DisplayVariableLabel                matlab.ui.control.Label
        TableVarPlotDropDown                matlab.ui.control.DropDown
        NoVisualizationLabel                matlab.ui.control.Label
        TemporaryVariables                  cell = cell(1,0); % Names of temp variables generated by the code to be cleared

        % Data attributes so we don't need to rely on data existing
        AllTableVarNames                    cell = cell(1,0); % Complete list of vars in input table
        TableVarNamesForDD                  cell = cell(1,0); % Vars that can be supported with fun(T.Var), could include multicolumn
        SupportedTableVars                  cell = cell(1,0); % Vars that can be supported with fun(T,...DataVariables=vars), + rowtimes if supported
        NumericVarInd                       logical = false;  % logical index into AllTableVarNames, result of @isnumeric
        TimetableDimName                    char = '';
        InputDataHasTableVars               logical = false;
        SamplePointsTableVarNames           cell = cell(1,0);
        SamplePointsTableVarDropDownVisible logical = false;
        SamplePointsVarClass                char = '';
        SamplePointsForPlotOnly             logical = false;
        SupportsVisualization               logical = true;
        InputSize                           double = [0 0];

        % numel to trigger turning off AutoRun, individual task may change
        % this value
        AutoRunCutOff                       double = 1e6;
        % Indicates whether task has been freshly loaded from another
        % version. Some items may need to be updated.
        TaskIsStale                         logical = false;
    end

    % Internal constant properties
    properties (Constant, Transient, Hidden)
        TextRowHeight        = 22; % Same as App Designer default
        InputDataColumnWidth = 120;
        IconWidth            = 16;
        SelectVariable       = 'select variable';
        DefaultValue         = 'default value';
        % This gray works for both dark and light theme
        % All other colors use SeriesIndex to get colororder colors
        % For black/white, use SeriesIndex="none"
        MiddleGray     = '[145 145 145]/255';
    end

    % Abstract methods required for embedding in a Live Script
    methods (Access = public, Abstract)
        [code,outputs] = generateScript(app)
        code = generateVisualizationScript(app)
    end
    
    % Write over constructor so we can keep this API with dataCleaner app
    methods (Access = public)
        function app = DataPreprocessingTask(fig,workspace)
            arguments
                fig = uifigure("Position",[50 50 1000 1000]);
                workspace = "base";
            end
            app@matlab.task.LiveTask("Parent",fig);
            app.UIFigure = fig;
            app.Workspace = workspace;
        end
    end

    % setup required by base class
    methods (Access = protected)
        function setup(app)
            % The entire app uses a uigridlayout
            app.LayoutManager.RowHeight = {'fit'};
            app.LayoutManager.ColumnWidth = {'1x'};
            % the grid is split into accordion panels
            app.Accordion = matlab.ui.container.internal.Accordion('Parent',app.LayoutManager);
            % create controls and set defaults for each task individually
            createWidgets(app);
            setInputDataAndWidgetsToDefault(app);
            doUpdate(app);
        end
    end

    % Required for embedding in live editor
    methods (Access = public)
        function reset(app)
            setOutputTypeValueToDefault(app);
            setWidgetsToDefault(app,true);
            doUpdate(app);
        end

        function [code,outputs] = generateCode(app)
            [code,outputs]  = generateScript(app);
            vcode = generateVisualizationScript(app);
            if ~isempty(vcode)
                code = [code newline newline vcode];
            end
        end

        % Required by data cleaner app
        function initialize(app,NVpairs)
            % Executed by container after creation of task
            % This method programmatically sets widget values and runs the
            % appropriate callbacks
            arguments
                app
                NVpairs.Inputs  string = "";
                NVpairs.TableVariableNames string = "";
                NVpairs.Code string = "";
            end
            % Inputs - the first element is the main input, additional
            %          elements are ignored
            % TableVariableNames - variable names in the table Inputs(1)
            % Code - keyword used in editor to pull up task
            if ~isequal(NVpairs.Code,"")
                updateDefaultsFromKeyword(app,NVpairs.Code);
            end

            if ~isequal(NVpairs.Inputs,"") && ~isempty(NVpairs.Inputs)
                inputs = NVpairs.Inputs;
                % set the InputDataDropDown value
                app.InputDataDropDown.populateVariables();
                if ismember(inputs(1),app.InputDataDropDown.ItemsData)
                    app.InputDataDropDown.Value = inputs(1);
                    app.InputDataTableVarDropDown(1).Value = app.SelectVariable;
                    % update app properties based on input
                    changedInputData(app);
                    changedWidget(app,app.InputDataDropDown,[]);
                    % after setting main input, set table variables
                    if ~isequal(NVpairs.TableVariableNames,"") && ~isempty(NVpairs.TableVariableNames)
                        app.DataVarSelectionTypeDropDown.Value = 'manual';
                        % We need to special case 1 table variable, because
                        % the list of supported variables may be different
                        if isscalar(NVpairs.TableVariableNames)
                            tableVar = NVpairs.TableVariableNames(1);
                            if ismember(tableVar,app.InputDataTableVarDropDown(1).ItemsData)
                                app.InputDataTableVarDropDown(1).Value = tableVar;
                            end
                        else
                            ddcount = 1;
                            for k = 1:numel(NVpairs.TableVariableNames)
                                tableVar = NVpairs.TableVariableNames(k);
                                if ismember(tableVar,app.SupportedTableVars)
                                    if numel(app.InputDataTableVarDropDown) < ddcount
                                        addTableVar(app,app.InputTableVarAddButton(ddcount-1),[],false);
                                        repopulateTableVarDropDowns(app);
                                    end
                                    app.InputDataTableVarDropDown(ddcount).Value = tableVar;
                                    ddcount = ddcount + 1;
                                end
                            end
                        end
                    end
                    % input section updates
                    setOutputTypeDropDownItemsToDefault(app);
                    changedSupportsVisualizationAndUpdatePlotDD(app);
                    % All the variables available to plot are listed in the TableVarPlotDropDown, but we need to remove the
                    % numeric ItemsData corresponding to 'Select all' or 'Select all numeric'
                    plottableVars = app.TableVarPlotDropDown.ItemsData(~cellfun(@isnumeric,app.TableVarPlotDropDown.ItemsData));
                    if ismember(app.InputDataTableVarDropDown(1).Value,plottableVars)
                        % plot the first var selected by user
                        app.TableVarPlotDropDown.Value = app.InputDataTableVarDropDown(1).Value;
                    end
                    % task specific updates
                    changedWidget(app,app.InputDataTableVarDropDown(1),[]);
                    % overall layout updates
                    doUpdate(app);
                end
            end
        end

        function plotCodeMap = getPlotCode(app,varNames)
            % Use this function to get the plot code of all the selected
            % variables OR of the variables specified in varNames
            % Note: we assume the input varNames is a subset of the
            % selected variables
            if nargin < 2
                varNames = {};
            end
            if isempty(varNames)
                % get all the selected variables
                if isequal(app.DataVarSelectionTypeDropDown.Value,'numeric')
                    ind = matlab.internal.math.checkDataVariables(app.InputDataDropDown.WorkspaceValue,@isnumeric);
                    varNames = app.InputDataDropDown.WorkspaceValue.Properties.VariableNames(ind);
                elseif isequal(app.DataVarSelectionTypeDropDown.Value,'manual')
                    varNames = getVariablesFromManualSelection(app);
                else
                    varNames = getAllSupportedVariables(app);
                end
            end
            % for each variable, determine if it can be plotted
            plottableVars = app.TableVarPlotDropDown.ItemsData(~cellfun(@isnumeric,app.TableVarPlotDropDown.ItemsData));
            visSupported = ismember(varNames,plottableVars);

            % for each variable, get the plot code
            N = numel(varNames);
            plotCode = repmat({''},N,1);
            for k = 1:N
                if visSupported(k)
                    app.TableVarPlotDropDown.Value = varNames{k};
                    if isprop(app,"SelectedVarType")
                        % Missing task uses type of selected variable to
                        % generate correct vis script
                        updateSelectedVarType(app);
                    end
                    plotCode{k} = generateVisualizationScript(app);
                else
                    plotCode{k} = '';
                end
            end
            plotCodeMap = [];
            if ~isempty(varNames)
                plotCodeMap = containers.Map(varNames,plotCode);
            end
        end

        function propTable = getPropertyInformation(app)
            % propTable is a list of all the controls visible in the Data
            % Cleaner app along with everything needed to map the
            % uifigure into the property inspector:
            % Name –           name of the object (e.g. ‘SmoothMethodDropDown’)
            % Group –          header name (e.g. ‘Specify method and parameters’)
            % DisplayName –    label for the control (e.g. ‘Smoothing method’)
            % StateName –      field in the state that holds the control’s value (e.g. ‘SmoothMethodDropDownValue’)
            % Type –           class of the control (e.g. ‘matlab.ui.control.DropDown’)
            % Items-           List of translatable values to display in a dropdown (empty if not a dropdown)
            % ItemsData-       List of values to that map to the state values (empty if not a dropdown)
            % Tooltip -        Tooltip on the control (may be empty char)
            % Visible -        Visibility of the object (OnOffSwitchState)
            % Enable -         Whether the object is enabled or disabled (OnOffSwitchState)
            % InitializeFlag - Flag to label the table input with 1 and the variable input with 2
            %                  This flag marks when the task should be updated with the
            %                  initialize method instead of setState
            % InSubgroup       Used to mark certain controls as less used to be in a minimized sub group
            % GroupExpanded     Used to expand/minimize groups by default

            % additionally, properties are in the order they should appear
            % in the property inspector

            % not implemented for the "Find" tasks as these are not used in
            % Data Cleaner app

            Name = ["InputDataDropDown";"DataVarSelectionTypeDropDown";...
                "InputDataTableVarDropDown";...
                "SamplePointsDropDown";"SamplePointsTableVarDropDown"];
            Group = repmat(getMsgText(app,'DataDelimiter'),5,1);
            DisplayName = [getMsgText(app,'InputData'); getMsgText(app,'SelectionMethod');...
                getMsgText(app,'TableVariables');...
                getMsgText(app,'SamplePoints'); getMsgText(app,'TableVariable')];
            StateName = ["InputDataDropDownValue"; "DataVarSelectionTypeDropDownValue";...
                "InputDataTableVarDropDownValues";...
                "SamplePointsDropDownValue";"SamplePointsTableVarDropDownValue"];
            propTableCommon = table(Name,Group,DisplayName,StateName);

            % populate the InputDataDropDown so it has the correct items
            app.InputDataDropDown.populateVariables();
            % gather additional values for the table
            propTableCommon = addFieldsToPropTable(app,propTableCommon);
            % add in the task-specific properties
            propTableLocal = getLocalPropertyInformation(app);
            propTable = [propTableCommon; propTableLocal];

            % label inputs
            propTable.InitializeFlag(1) = 1;
            propTable.InitializeFlag(3) = 2;
            % input dd should only show if there is more than one table in
            % the dropdown ('select' is always there)          
            propTable.Visible(1) = numel(app.InputDataDropDown.Items) > 2;
            % Don't show DataVarSelectionTypeDropDown since
            % multiselect in app has 'select all'/'clear all' making this
            % control unnecessary
            propTable.Visible(2) = 'off';
            % InputDataTableVarDropDown's Visible is depended on its grid
            propTable.Visible(3) = app.DataVarGrid.Visible;
            % minimize x-axis controls by default
            propTable.InSubgroup(4:5) = true;

            % For sample points table var names, ItemsData needs to match
            % the Value saved in the state (with the "."), but Items can be
            % left without the dot for display in the app
            propTable.ItemsData{5} = app.addDot(propTable.ItemsData{5});
            % For input table vars, since app uses a checkbox list, there
            % is no separate items/itemsdata, so instead, we remove the dot
            % from the state field in the app
        end
    end
    methods (Access = protected)
        % Individual tasks implement these methods as needed

        % Tasks in the Data Cleaner app need to implement:
        getLocalPropertyInformation(app);

        % Non-"Find" tasks need to implement:
        adj = getAdjectiveForOutputDropDown(app);

        function updateDefaultsFromKeyword(~,~)
            % Tasks should implement if any task defaults change based on
            % what keyword was used. E.g. using a method name
        end
    end

    % Other abstract methods
    methods (Abstract, Access = protected)
        createWidgets(app)
        createPlotWidgetsRow(app,h)
        setWidgetsToDefault(app,fromResetMethod)
        updateWidgets(app,doEvalinBase)
        changedWidget(app,context,eventData)
        tf = filterInputData(app,A,isTableVar)
        tf = filterSamplePointsType(app,X,isTableVar)
    end

    % Methods for initial layout/construction
    methods (Access = protected)
        function G = createNewSection(app,textLabel,c,numRows)
            S = matlab.ui.container.internal.AccordionPanel('Parent',app.Accordion);
            S.Title = textLabel;
            G = uigridlayout(S,'ColumnWidth',c,'RowHeight',repmat({'fit'},1,numRows));
        end

        function createPlotSection(app,numColumns)
            S = createNewSection(app,getMsgText(app,'Visualizeresults'),{'fit'},2);
            % section consists of two subgrids, only 1 visible at a time
            % plot widget grid
            h = uigridlayout(S,'Padding',0,...
                'RowHeight',{'fit' 'fit'},...
                'ColumnWidth',repmat({'fit'},1,numColumns));
            % row 1
            app.DisplayVariableLabel = uilabel(h,'Text',getMsgText(app,'VariableToDisplay'));
            app.TableVarPlotDropDown = uidropdown(h);
            app.TableVarPlotDropDown.ValueChangedFcn = @app.handleEditableAndDoUpdate;
            app.TableVarPlotDropDown.Tag = 'TableVarPlotDropDown';
            app.TableVarPlotDropDown.Items = {};
            app.TableVarPlotDropDown.ItemsData = {};

            % row 2 is task specific
            createPlotWidgetsRow(app,h);

            % "No visualization" grid
            h = uigridlayout(S,'Padding',0,'RowHeight',{'fit'},'ColumnWidth',{'fit'});
            app.NoVisualizationLabel = uilabel(h,'Text',getMsgText(app,'NoVisualization',''));
        end

        function createInputDataSection(app,outputIsMask)
            if nargin < 2
                outputIsMask = false;
            end
            h = createNewSection(app,getMsgText(app,'DataDelimiter'),...
                {'fit' app.InputDataColumnWidth 'fit' 'fit'},4);
            h.RowHeight{1} = app.TextRowHeight;

            % row 1 - input data
            uilabel(h,'Text',getMsgText(app,'InputData'));

            app.InputDataDropDown = matlab.ui.control.internal.model.WorkspaceDropDown('Parent',h);
            app.InputDataDropDown.ShowNonExistentVariable = true;
            app.InputDataDropDown.Tooltip = getMsgText(app,'InputDataTooltip');
            app.InputDataDropDown.ValueChangedFcn = @app.doUpdateFromWidgetChange;
            app.InputDataDropDown.FilterVariablesFcn = @app.filterInputDataFromWorkspace;
            app.InputDataDropDown.Tag = 'InputDataDropDown';

            app.DataVarSelectionTypeDropDown = uidropdown(h);
            app.DataVarSelectionTypeDropDown.ValueChangedFcn = @app.doUpdateFromWidgetChange;
            app.DataVarSelectionTypeDropDown.Tag = 'ChangedDataVariables';
            app.DataVarSelectionTypeDropDown.DropDownOpeningFcn = @app.refreshStaleTask;

            % grid rolls into row 2, which is otherwise hidden
            app.DataVarGrid = uigridlayout(h,'Padding',0,'RowHeight',{app.TextRowHeight},'ColumnWidth',{'fit',app.IconWidth,app.IconWidth});
            app.DataVarGrid.Layout.Row = [1 2];
            createTableVarSubrow(app,1);

            % row 3, Output type
            L = uilabel(h,'Text',getMsgText(app,'OutputType'));
            L.Layout.Row = 3;
            L.Layout.Column = 1;

            app.OutputTypeDropDown = uidropdown(h);
            app.OutputTypeDropDown.Layout.Column = [2 3];            
            app.OutputTypeDropDown.UserData = outputIsMask;
            app.OutputTypeDropDown.ValueChangedFcn = @app.doUpdateFromWidgetChange;
            app.OutputTypeDropDown.Tag = 'changedOutputType';
            app.OutputTypeDropDown.DropDownOpeningFcn = @app.refreshStaleTask;

            % row 4, Sample Points
            L = uilabel(h,'Text',getMsgText(app,'SamplePoints'));
            L.Layout.Row = 4;
            L.Layout.Column = 1;

            app.SamplePointsDropDown = matlab.ui.control.internal.model.WorkspaceDropDown('Parent',h,...
                'UseDefaultAsPlaceholder',true);
            app.SamplePointsDropDown.ShowNonExistentVariable = true;
            app.SamplePointsDropDown.ValueChangedFcn = @app.doUpdateFromWidgetChange;
            app.SamplePointsDropDown.FilterVariablesFcn = @app.filterSamplePointsFromWorkspace;
            app.SamplePointsDropDown.Tag = 'SamplePointsDropDown';

            app.SamplePointsTableVarDropDown = uidropdown(h);
            app.SamplePointsTableVarDropDown.ValueChangedFcn = @app.doUpdateFromWidgetChange;
            app.SamplePointsTableVarDropDown.Tag = 'SamplePointsTableVarDropDown';
        end

        function createTableVarSubrow(app,n)
            app.InputDataTableVarDropDown(n) = uidropdown(app.DataVarGrid,...
                'ValueChangedFcn',@app.handleEditableAndDoUpdate,...
                'Tag','ChangedDataVariables');

            app.InputTableVarSubtractButton(n) = uiimage(app.DataVarGrid,'ScaleMethod','none',...
                'ImageClickedFcn',@app.subtractTableVar,'UserData',n,...
                'Tooltip',getMsgText(app,'SubtractDataVarTooltip'));
            matlab.ui.control.internal.specifyIconID(app.InputTableVarSubtractButton(n),...
                'minusUI',app.IconWidth,app.IconWidth);

            app.InputTableVarAddButton(n) = uiimage(app.DataVarGrid,'ScaleMethod','none',...
                'ImageClickedFcn',@app.addTableVar,'Tag','ChangedDataVariables','UserData',n,...
                'Tooltip',getMsgText(app,'AddDataVarTooltip'));
            matlab.ui.control.internal.specifyIconID(app.InputTableVarAddButton(n),...
                'plusUI',app.IconWidth,app.IconWidth);
        end

        function handleEditableAndDoUpdate(app,src,ev)
            if ev.Edited
                % Only allow values that are in the dropdown
                src.Value = ev.PreviousValue;
                return
            end
            app.doUpdateFromWidgetChange(src,ev);
        end
    end

    % Methods for setting/updating defaults
    methods (Access = protected)
        function setInputDataAndWidgetsToDefault(app)
            % Just keep the first item, which for "Input Data" should
            % always be "select" because we are using a WorkspaceDropDown
            app.InputSize = [0 0];
            app.InputDataDropDown.Items = app.InputDataDropDown.Items(1);
            app.InputDataDropDown.ItemsData = app.InputDataDropDown.ItemsData(1);
            app.InputDataDropDown.Value = app.InputDataDropDown.ItemsData{1};
            populateInputDataTableVarDropDown(app); % also sets SupportedTableVars, TableVarNamesForDD
            app.InputDataHasTableVars = false;
            app.AllTableVarNames = cell(1,0);
            app.TimetableDimName = '';
            setDataVarSelectionTypeDropDownItemsToDefault(app);
            app.DataVarSelectionTypeDropDown.Value = 'manual';
            setOutputTypeValueToDefault(app);
            setSamplePointsToDefault(app);
            app.TableVarPlotDropDown.Items = {};
            app.TableVarPlotDropDown.ItemsData = {};
            app.NumericVarInd = false;

            setWidgetsToDefault(app);
        end

        function setOutputTypeValueToDefault(app)
            setOutputTypeDropDownItemsToDefault(app);
            if numel(app.OutputTypeDropDown.ItemsData) > 1
                % if tabular options exist, choose 'table' for find tasks,
                % and 'replace' otherwise
                app.OutputTypeDropDown.Value = app.OutputTypeDropDown.ItemsData{end-1};
            end
        end

        function populateInputDataTableVarDropDown(app,varNames)
            numRows = numel(app.InputDataTableVarDropDown);
            if  numRows > 1
                % delete additional rows
                delete(app.InputDataTableVarDropDown(2:numRows));
                delete(app.InputTableVarSubtractButton(2:numRows));
                delete(app.InputTableVarAddButton(2:numRows));

                % delete handles
                app.InputDataTableVarDropDown(2:numRows) = [];
                app.InputTableVarSubtractButton(2:numRows) = [];
                app.InputTableVarAddButton(2:numRows) = [];

                % reset grid
                app.DataVarGrid.RowHeight = {app.TextRowHeight};
            end

            if nargin < 2
                app.InputDataTableVarDropDown.Items = {getSelectVariableText(app)};
                app.InputDataTableVarDropDown.ItemsData = {app.SelectVariable};
                app.TableVarNamesForDD = cell(1,0);
                app.SupportedTableVars = cell(1,0);
            else
                if isAppWorkflow(app)
                    varNames = app.SupportedTableVars;
                end
                varNames = reshape(varNames,1,[]);
                newItems = [{getSelectVariableText(app)} varNames];
                app.InputDataTableVarDropDown.Items = newItems;
                newItems{1} = app.SelectVariable;
                app.InputDataTableVarDropDown.ItemsData = newItems;
                app.TableVarNamesForDD = varNames;

                if isscalar(varNames)
                    % If the task only recognizes one valid variable in the
                    % table, automatically select that variable
                    app.InputDataTableVarDropDown.Value = varNames{1};
                end
            end
        end

        function repopulateTableVarDropDowns(app)
            if numel(app.InputDataTableVarDropDown) > 1 || isAppWorkflow(app)
                % remove Row Times and non-column variables
                varNames = setdiff(app.SupportedTableVars,app.TimetableDimName,'stable');
            else
                varNames = app.TableVarNamesForDD;
            end

            % make sure first one still has all supported table variables:
            val = app.InputDataTableVarDropDown(1).Value;
            app.InputDataTableVarDropDown(1).Items = [{getSelectVariableText(app)} varNames];
            app.InputDataTableVarDropDown(1).ItemsData = [{app.SelectVariable} varNames];
            app.InputDataTableVarDropDown(1).Value = val;

            % loop through the others to give them the same items, but
            % without the value from the previous row so user cannot repeat
            % values
            for k = 2:numel(app.InputDataTableVarDropDown)
                valToRemove = app.InputDataTableVarDropDown(k-1).Value;
                if isequal(valToRemove,app.SelectVariable)
                    valToRemove = {};
                end
                valToSave = app.InputDataTableVarDropDown(k).Value;
                app.InputDataTableVarDropDown(k).ItemsData = setdiff(app.InputDataTableVarDropDown(k-1).ItemsData,valToRemove,'stable');
                app.InputDataTableVarDropDown(k).Items = setdiff(app.InputDataTableVarDropDown(k-1).Items,valToRemove,'stable');
                if ismember(valToSave,app.InputDataTableVarDropDown(k).ItemsData)
                    app.InputDataTableVarDropDown(k).Value = valToSave;
                end
            end
        end

        function setSamplePointsToDefault(app)
            % Just keep the first item, which for "X-axis" should always be
            % "default" because we are using a WorkspaceDropDown
            app.SamplePointsDropDown.Items = app.SamplePointsDropDown.Items(1);
            app.SamplePointsDropDown.ItemsData = app.SamplePointsDropDown.ItemsData(1);
            app.SamplePointsDropDown.Value = app.SamplePointsDropDown.ItemsData{1};
            populateSamplePointsTableVarDropDown(app);
            app.SamplePointsTableVarDropDownVisible = false;
            app.SamplePointsVarClass = '';
        end

        function setDataVarSelectionTypeDropDownItemsToDefault(app)
            app.DataVarSelectionTypeDropDown.Items = [getMsgText(app,'AllSupported') ...
                getMsgText(app,'AllSupported') getMsgText(app,'AllNumeric') getMsgText(app,'ManualSelection')];
            app.DataVarSelectionTypeDropDown.ItemsData = {'all','supported','numeric','manual'};
        end

        function setOutputTypeDropDownItemsToDefault(app)
            % Set items/itemsData, but first, save current value. If it
            % gets changed, we can change it back.
            outputval = app.OutputTypeDropDown.Value;

            hasData = hasInputData(app);
            inputIsTabular = app.InputDataHasTableVars;
            inputIsTimetable = istimetable(app.InputDataDropDown.WorkspaceValue);
            allSelected = app.allTableVariablesSelected;

            % Get substrings for Items
            if hasData && inputIsTabular && ~hasMultipleDataVariables(app)
                varName = app.InputDataTableVarDropDown(~strcmp({app.InputDataTableVarDropDown.Value},app.SelectVariable)).Value;
            else
                varName = getMsgText(app,'SelectedVariable');
            end
            if inputIsTimetable
                tableStr = 'Timetable';
            else
                tableStr = 'Table';
            end % app.InputDataDropDown.Value

            if app.OutputTypeDropDown.UserData % "Find" task/logical output
                itemsData = {'vector' 'smallMask' 'largeMask' 'table' 'append'};
                items = [getMsgText(app,'OutputTypeLogical',varName),...
                    getMsgText(app,'OutputTypeSmallMask'),...
                    getMsgText(app,'OutputTypeLogical', app.InputDataDropDown.Value),...
                    getMsgText(app,'OutputTypeTable',tableStr),...
                    getMsgText(app,'OutputTypeLogicalAppend',tableStr)];
                if ~hasMultipleDataVariables(app)
                    if hasData && inputIsTabular && (~ismember(varName,app.SupportedTableVars) || ...
                            (inputIsTimetable && ~hasValidRowTimes(app)))
                        % remove all table options, variable can only be processed by
                        % itself (e.g. ND variable or timetable with invalid RowTimes)
                        optionsToRemove = 2:5;
                    else
                        % remove smallMask option
                        optionsToRemove = 2;
                    end
                elseif allSelected
                    % remove vector and smallMask options
                    optionsToRemove = 1:2;
                else
                    % remove vector option
                    optionsToRemove = 1;
                end

            else
                itemsData = {'vector' 'smalltable' 'replace' 'append'};
                adj = getAdjectiveForOutputDropDown(app);
                items = [getMsgText(app,'OutputTypeVector',app.InputDataDropDown.Value),...
                   getMsgText(app,['OutputTypeSmallTable' adj],tableStr),...
                   getMsgText(app,'OutputTypeReplace',tableStr),...
                   getMsgText(app,['OutputTypeAppend' adj],tableStr)];
                optionsToRemove = [];
                if hasMultipleDataVariables(app)
                    % remove vector option
                    optionsToRemove = 1;                    
                elseif hasData && inputIsTabular && (~ismember(varName,app.SupportedTableVars) || ...
                        (inputIsTimetable && ~hasValidRowTimes(app) && ~inputIsRowTimes(app)))
                    % remove all table options, variable can only be processed by
                    % itself (e.g. ND variable or timetable with invalid RowTimes)
                    optionsToRemove = 2:4;
                elseif inputIsRowTimes(app)
                    % remove smalltable and append 
                    optionsToRemove = [2 4];
                end
                if allSelected
                    % remove small table
                    optionsToRemove = union(optionsToRemove,2);
                end
            end
            itemsData(optionsToRemove) = [];
            items(optionsToRemove) = [];
            app.OutputTypeDropDown.ItemsData = itemsData;
            app.OutputTypeDropDown.Items = items;

            % Reset value
            if ismember(outputval,app.OutputTypeDropDown.ItemsData)
                app.OutputTypeDropDown.Value = outputval;
            end
        end

        function populateSamplePointsTableVarDropDown(app,varNames)
            if nargin < 2
                app.SamplePointsTableVarDropDown.Items = {getSelectVariableText(app)};
                app.SamplePointsTableVarDropDown.ItemsData = {app.SelectVariable};
                app.SamplePointsTableVarNames = cell(1,0);
            else
                varNames = reshape(varNames,1,[]);
                newItems = [{getSelectVariableText(app)} varNames];
                app.SamplePointsTableVarDropDown.Items = newItems;
                newItems{1} = app.SelectVariable;
                app.SamplePointsTableVarDropDown.ItemsData = newItems;
                app.SamplePointsTableVarNames = varNames;
                if isscalar(varNames)
                    % If the task only recognizes one valid variable in the
                    % table, automatically select that variable
                    app.SamplePointsTableVarDropDown.Value = varNames{1};
                end
            end
        end
    end

    % Filter functions for workspace dropdowns
    methods (Access = protected)
        function isSupported = filterInputDataFromWorkspace(app,A)
            % We cannot allow empties otherwise checkingWorkspaceValue
            % to see if a var has been cleared will not work.
            % Additionally, 1-row tables cause unnecessary strife with
            % default dim of T(:,var) being different than that of T.var
            isSupported = ~istall(A) && ~isempty(A) && ~(istabular(A) && size(A,1) == 1) &&...
                filterInputData(app,A,false);
        end

        function isSupported = filterSamplePointsFromWorkspace(app,X)
            if isempty(app.InputDataDropDown.WorkspaceValue) && ~strcmp(app.InputDataDropDown.Value,app.SelectVariable)
                % input data is no longer in the workspace
                setInputDataAndWidgetsToDefault(app);
                isSupported = false;
                doUpdate(app);
                return
            else
                % Filter by type
                isSupported = hasInputData(app,false) && ~isempty(X) && ...
                    filterSamplePointsType(app,X,false);
                if ~isSupported
                    return;
                end

                % Filter by numel and underlying data
                numelXData = getNumelAlongDefaultDim(app);
                if isa(X,'tabular')
                    % height should match that of the length of the data
                    % or, the table could contain a row vector
                    isSupported = (height(X) == numelXData) || height(X) == 1;
                else
                    isSupported = (numel(X) == numelXData) && filterSamplePointsData(X);
                end
            end
        end
    end

    % Callbacks and update methods
    methods (Access = protected)
        function addTableVar(app,src,event,updateApp)
            % callback for InputTableVarAddButton
            if nargin < 4
                updateApp = true;
            end

            if numel(app.InputDataTableVarDropDown) >= ...
                    numel(app.SupportedTableVars) - ismember(app.TimetableDimName,app.SupportedTableVars)
                % user should only be able to get here by clicking '+' very
                % fast, not testable
                return
            end
            % Create a new dd and buttons
            n = numel(app.InputDataTableVarDropDown) + 1;
            app.DataVarGrid.RowHeight{n} = app.TextRowHeight;
            createTableVarSubrow(app,n);

            if updateApp
                doUpdateFromWidgetChange(app,src,event)
            end
        end

        function subtractTableVar(app,src,~)
            % Callback for InputTableVarSubtractButton
            n = src.UserData;
            % shift items up from n+1 to end
            for k = n+1:numel(app.InputDataTableVarDropDown)
                app.InputDataTableVarDropDown(k-1).ItemsData = app.InputDataTableVarDropDown(k).ItemsData;
                app.InputDataTableVarDropDown(k-1).Items = app.InputDataTableVarDropDown(k).Items;
                app.InputDataTableVarDropDown(k-1).Value = app.InputDataTableVarDropDown(k).Value;
                % this gets the value correct, we'll repopulate items in a moment
            end
            % delete last row of widgets and handles
            delete(app.InputDataTableVarDropDown(end));
            delete(app.InputTableVarSubtractButton(end));
            delete(app.InputTableVarAddButton(end));
            app.InputDataTableVarDropDown(end) = [];
            app.InputTableVarSubtractButton(end) = [];
            app.InputTableVarAddButton(end) = [];
            % update grid size
            app.DataVarGrid.RowHeight(end) = [];

            % need doUpdateFromWidgetChange, but widget might not exist
            % anymore, so we cannot pass current src along to that fcn
            srcStruct = struct('Tag','ChangedDataVariables','UserData',[]);
            doUpdateFromWidgetChange(app,srcStruct,[])
        end

        function doUpdateFromWidgetChange(app,src,event)
            % Callback for almost all other controls
            refreshStaleTask(app);
            % update input data section based on what was clicked
            if isequal(src.Tag,app.InputDataDropDown.Tag)
                changedInputData(app);
                setOutputTypeDropDownItemsToDefault(app);
                changedSupportsVisualizationAndUpdatePlotDD(app);
            elseif isequal(src.Tag,'ChangedDataVariables')
                % this could come from DataVarSelectionTypeDropDown,
                % an InputDataTableVarDropDown, or an add button
                repopulateTableVarDropDowns(app);
                if ~isempty(src.UserData)
                    % this comes from an add button
                    % if only one option in new dd, choose it
                    if numel(app.InputDataTableVarDropDown(end).ItemsData) == 2
                        app.InputDataTableVarDropDown(end).Value = app.InputDataTableVarDropDown(end).ItemsData{2};
                    end
                end
                setOutputTypeDropDownItemsToDefault(app);
                changedSupportsVisualizationAndUpdatePlotDD(app);
            elseif isequal(src.Tag,app.OutputTypeDropDown.Tag)
                changedSupportsVisualizationAndUpdatePlotDD(app);
            elseif isequal(src.Tag,app.SamplePointsDropDown.Tag)
                changedSamplePoints(app);
                changedSamplePointsVarClass(app);
            elseif isequal(src.Tag,app.SamplePointsTableVarDropDown.Tag)
                changedSamplePointsVarClass(app);
            end

            % update other widgets based on what was clicked
            changedWidget(app,src,event);
            % update entire app based on widget values
            doUpdate(app);
        end

        function changedInputData(app)
            % React to a changed InputDataDropDown
            if ~hasInputData(app,false)
                % Reset app when "Input data" was changed to "select"
                setInputDataAndWidgetsToDefault(app);
                return;
            end

            A = app.InputDataDropDown.WorkspaceValue;
            app.InputSize = size(A);
            app.InputDataHasTableVars = isa(A,'tabular');
            if app.InputDataHasTableVars
                app.AllTableVarNames = A.Properties.VariableNames;
                % Populate with table variables of supported type
                varNames = getTableVarNames(A); % could include rowtimes
                validYData = true(1,numel(varNames));
                validYDataTableOutput = true(1,numel(varNames));
                for k = 1:numel(varNames)
                    xk = A.(varNames{k});
                    validYData(k) = filterInputData(app,xk,true);
                    validYDataTableOutput(k) = validYData(k) && iscolumn(xk);
                end
                varNamesForDD = varNames(validYData);
                app.SupportedTableVars = varNames(validYDataTableOutput);
                if istimetable(A)
                    app.TimetableDimName = varNames{1};
                    if isAppWorkflow(app) && validYData(1)
                        app.SupportedTableVars(1) = [];
                    end
                else
                    app.TimetableDimName = '';
                end
                populateInputDataTableVarDropDown(app,varNamesForDD);                

                clsA = class(A);
                clsA(1) = upper(clsA(1));
                app.InputDataTableVarDropDown.Tooltip = getMsgText(app,'TableVarTooltip',clsA,app.InputDataDropDown.Value);

                setDataVarSelectionTypeDropDownItemsFromInput(app);
                % reset dd value to default
                app.DataVarSelectionTypeDropDown.Value = 'manual';
            else
                populateInputDataTableVarDropDown(app);
                setDataVarSelectionTypeDropDownItemsToDefault(app);
            end

            % Reset the Sample Points
            setSamplePointsToDefault(app);

            if istimetable(A)
                % Set Sample Points (X-axis) to T.Time for timetables
                changedSamplePoints(app,app.InputDataDropDown.Value);
                if ~isequal(app.InputDataDropDown.Value,app.SamplePointsDropDown.Value)
                    % time vector was invalid for sample points,
                    % so we only want to allow 'manual'
                    app.DataVarSelectionTypeDropDown.Items = app.DataVarSelectionTypeDropDown.Items(end);
                    app.DataVarSelectionTypeDropDown.ItemsData = app.DataVarSelectionTypeDropDown.ItemsData(end);
                end
                changedSamplePointsVarClass(app);
            end

            % If data is too large, turn auto-run off.
            % Once triggered, user is in control, so no need to reset to
            % true for small data
            if numel(A) > app.AutoRunCutOff
                app.AutoRun = false;
            end
        end

        function setDataVarSelectionTypeDropDownItemsFromInput(app)
            setDataVarSelectionTypeDropDownItemsToDefault(app);
            supportedVars = getAllSupportedVariables(app);
            numSupportedVars = numel(supportedVars);
            A = app.InputDataDropDown.WorkspaceValue;
            numVars = size(A,2);
            % like app.NumericVarInd = varfun(@isnumeric,T,OutputFormat="uniform") but faster
            ind = false(1,numVars);
            for k = 1:size(A,2)
                ind(k) = isnumeric(A.(k));
            end
            app.NumericVarInd = ind;
            if numSupportedVars == 0
                % only allow manual selection
                app.DataVarSelectionTypeDropDown.ItemsData(1:3) = [];
                app.DataVarSelectionTypeDropDown.Items(1:3) = [];
            else
                if  numSupportedVars == numVars
                    % 'all supported' is the same as 'all variables'
                    % so we don't need that option
                    app.DataVarSelectionTypeDropDown.ItemsData(2) = [];
                    app.DataVarSelectionTypeDropDown.Items(2) = [];
                else
                    % not all variables are supported, so 'all' would
                    % result in an error, so we should remove this
                    % option
                    app.DataVarSelectionTypeDropDown.ItemsData(1) = [];
                    app.DataVarSelectionTypeDropDown.Items(1) = [];
                end
                if ~any(app.NumericVarInd) || nnz(app.NumericVarInd) == numel(supportedVars) || ...
                        ~all(matches(app.AllTableVarNames(app.NumericVarInd),supportedVars))
                    % don't show 'numeric' if it applies to 0 variables
                    % or if this option is not distinct from the previous option (all supported vars are numeric, so don't show both options)
                    % or if not all numeric are supported (e.g. ND numeric)
                    app.DataVarSelectionTypeDropDown.ItemsData(2) = [];
                    app.DataVarSelectionTypeDropDown.Items(2) = [];
                end
            end
        end

        function changedSamplePoints(app,newValue)
            % React to a changed SamplePointsDropDown

            if nargin > 1
                % When the "Input Data" is set to a timetable, set the
                % "X-axis" to the same timetable
                setSamplePointsToDefault(app);
                app.SamplePointsDropDown.populateVariables();
                app.SamplePointsDropDown.Value = newValue;
            end

            if isequal(app.SamplePointsDropDown.Value,app.DefaultValue)
                setSamplePointsToDefault(app);
                return
            end

            X = app.SamplePointsDropDown.WorkspaceValue;
            if isa(X,'tabular')
                % Populate with table variables of supported type
                varNames = getTableVarNames(X);
                validXData = true(1,numel(varNames));
                doHeightCheck = (height(X) == 1);
                N = getNumelAlongDefaultDim(app);
                for k = 1:numel(varNames)
                    xk = X.(varNames{k});
                    validXData(k) = app.SamplePointsForPlotOnly || (filterSamplePointsType(app,xk,true) && filterSamplePointsData(xk));
                    if doHeightCheck
                        % table could have a valid row vector, but need to check length
                        validXData(k) = validXData(k) && (numel(xk) == N);
                    end
                    if nargin > 1 && k == 1 && ~validXData(1) && ~isAppWorkflow(app)
                        % When the "Input Data" is set to a timetable, but
                        % the time vector ends up not being valid, revert
                        % to default
                        setSamplePointsToDefault(app);
                        return
                    end
                end
                varNames = varNames(validXData);
                populateSamplePointsTableVarDropDown(app,varNames);
                app.SamplePointsTableVarDropDownVisible = true;

                if istimetable(X)
                    % Set Sample Points (X-axis) to T.Time for timetables
                    % but only if it is a valid SamplePoints vector
                    if validXData(1)
                        app.SamplePointsTableVarDropDown.Value = app.SamplePointsTableVarDropDown.Items{2};
                    elseif isAppWorkflow(app)
                        % in app workflow, still need to show time vector
                        rowTimes = X.Properties.DimensionNames{1};
                        app.SamplePointsTableVarDropDown.Items = [app.SamplePointsTableVarDropDown.Items {rowTimes}];
                        app.SamplePointsTableVarDropDown.ItemsData = [app.SamplePointsTableVarDropDown.ItemsData {rowTimes}];
                        app.SamplePointsTableVarDropDown.Value = rowTimes;
                    end
                end
            else
                populateSamplePointsTableVarDropDown(app);
                app.SamplePointsTableVarDropDownVisible = false;
            end
        end

        function changedSamplePointsVarClass(app)
            if hasSamplePoints(app)
                x = getSamplePointsVarName(app);
                if ~isempty(x)
                    app.SamplePointsVarClass = class(evalin(app.Workspace,x));
                end
            else
                app.SamplePointsVarClass = '';
            end
        end

        function doUpdate(app,doEvalinBase)
            % main update function used by callbacks
            if nargin < 2
                doEvalinBase = true;
            end
            doEditable = numel(app.InputDataTableVarDropDown(1).Items) > 25;
            [app.InputDataTableVarDropDown.Editable] = deal(doEditable);
            app.TableVarPlotDropDown.Editable = numel(app.TableVarPlotDropDown.Items) > 25;
            updateWidgets(app,doEvalinBase);
            notify(app,'StateChanged');
        end

        function updateInputDataAndSamplePointsDropDown(app)
            hasData = hasInputData(app);
            inputIsTabular = app.InputDataHasTableVars;
            inputIsTimetable = istimetable(app.InputDataDropDown.WorkspaceValue);
            inputGrid = app.Accordion.Children(1).Children;

            % Row 1, show/hide table dropdowns, buttons
            app.DataVarSelectionTypeDropDown.Visible = inputIsTabular;
            if inputIsTabular && isequal(app.DataVarSelectionTypeDropDown.Value,'manual')
                app.DataVarGrid.Parent = inputGrid;
                app.DataVarGrid.Visible = 'on';
            else
                app.DataVarGrid.Parent = [];
                app.DataVarGrid.Visible = 'off';
            end
            showSubtractButton = hasInputData(app,false) && (numel(app.InputDataTableVarDropDown) > 1);
            app.DataVarGrid.ColumnWidth{2} = app.IconWidth*showSubtractButton;
            [app.InputTableVarSubtractButton.Visible] = deal(showSubtractButton);
            maxNumRows = numel(app.SupportedTableVars);
            if inputIsTimetable && ismember(app.TimetableDimName,app.SupportedTableVars)
                % row times is in the list but can only be chosen alone
                maxNumRows = max(maxNumRows - 1,1);
            end
            showAddButton = hasInputData(app,false) && (numel(app.InputDataTableVarDropDown) < maxNumRows);
            if hasData && ~hasMultipleDataVariables(app)
                showAddButton = showAddButton && ...
                    ismember(app.InputDataTableVarDropDown(1).Value,app.SupportedTableVars) && ...
                    (~inputIsTimetable || ~inputIsRowTimes(app) && hasValidRowTimes(app));
            end
            app.DataVarGrid.ColumnWidth{3} = app.IconWidth*showAddButton;
            [app.InputTableVarAddButton.Visible] = deal(showAddButton);
            [app.InputTableVarAddButton.Enable] = deal(~any(strcmp({app.InputDataTableVarDropDown.Value},app.SelectVariable)));

            % Row 2, OutputTypeDropDown
            app.Accordion.Children(1).Children.RowHeight{3} = app.TextRowHeight*inputIsTabular;
            app.OutputTypeDropDown.Visible = inputIsTabular;
            app.OutputTypeDropDown.Enable = hasData;

            % Row 3, X-axis
            enableXaxis = hasData && (~inputIsTimetable || isequal(app.OutputTypeDropDown.Value,'vector'));
            app.SamplePointsDropDown.Enable = enableXaxis;
            app.SamplePointsTableVarDropDown.Enable = enableXaxis;
            if hasData && ~enableXaxis
                updateLockedSamplePoints(app);
                if app.OutputTypeDropDown.UserData % output is logical mask
                    app.SamplePointsDropDown.Tooltip = getMsgText(app,'SamplePointsTooltipDisabledLogical');
                    app.SamplePointsTableVarDropDown.Tooltip = getMsgText(app,'SamplePointsTooltipDisabledLogical');
                else
                    app.SamplePointsDropDown.Tooltip = getMsgText(app,'SamplePointsTooltipDisabled');
                    app.SamplePointsTableVarDropDown.Tooltip = getMsgText(app,'SamplePointsTooltipDisabled');
                end
            else
                app.SamplePointsDropDown.Tooltip = getMsgText(app,'SamplePointsTooltip');
                X = app.SamplePointsDropDown.WorkspaceValue;
                if istable(X)
                    app.SamplePointsTableVarDropDown.Tooltip = getMsgText(app,'SamplePointsTableVarTooltip','table');
                elseif istimetable(X)
                    app.SamplePointsTableVarDropDown.Tooltip = getMsgText(app,'SamplePointsTableVarTooltip','timetable');
                end
            end
            app.SamplePointsTableVarDropDown.Visible = app.SamplePointsTableVarDropDownVisible;
            if inputIsTabular || app.SamplePointsTableVarDropDownVisible
                inputGrid.ColumnWidth{3} = 'fit';
            else
                inputGrid.ColumnWidth{3} = 0;
            end

            % Plot Section: update plot dropdown
            if hasMultipleDataVariables(app)
                % show dropdown
                app.TableVarPlotDropDown.Visible = 'on';
                app.DisplayVariableLabel.Visible = 'on';
            else
                % hide dropdown
                app.TableVarPlotDropDown.Visible = 'off';
                app.DisplayVariableLabel.Visible = 'off';
            end
            % controls should get unparented if invisible for correct grid
            % width and height
            plotGrid = app.Accordion.Children(end).Children.Children(1);
            matlab.internal.dataui.setParentForWidgets([app.DisplayVariableLabel app.TableVarPlotDropDown],plotGrid);

            if inputIsTimetable
                app.TableVarPlotDropDown.Tooltip = getMsgText(app,'PlotDropDownTooltip','Timetable');
            else
                app.TableVarPlotDropDown.Tooltip = getMsgText(app,'PlotDropDownTooltip','Table');
            end
        end

        function updateLockedSamplePoints(app)
            T = app.InputDataDropDown.WorkspaceValue;
            if istimetable(T)
                % set samplepoints, this will not be able to be changed by the user
                if inputIsRowTimes(app)
                    % set sample points to default
                    setSamplePointsToDefault(app);
                    changedSamplePointsVarClass(app);
                else
                    % set sample points to inputTimetable.Time
                    changedSamplePoints(app,app.InputDataDropDown.Value);
                    changedSamplePointsVarClass(app);
                end
            end
        end

        function changedSupportsVisualizationAndUpdatePlotDD(app)
            items = {};
            numSelectedNumericVars = 0;
            supportsMoreTypes = isa(app,'matlab.internal.dataui.missingDataCleaner');
            if hasInputData(app)
                filterFcn = @(A)isvector(A) && ((isreal(A) && isnumeric(A)) || ...
                    islogical(A) || isdatetime(A) || isduration(A) || ...
                    iscellstr(A) || isstring(A) || iscalendarduration(A) || iscategorical(A) || ischar(A));
                if ~app.InputDataHasTableVars || isequal(app.OutputTypeDropDown.Value,'vector')
                    A = evalInputDataVarNameWithCheck(app,true);
                    app.SupportsVisualization = filterFcn(A);
                else
                    % in addition to being a vector, since default dim is 1
                    % (table height), must be a column vector
                    filterFcn = @(var) iscolumn(var) && filterFcn(var);
                    T = app.InputDataDropDown.WorkspaceValue;
                    % since this is to show/hide the plot checkboxes, return
                    % true if we can support at least one visualization
                    if isequal(app.DataVarSelectionTypeDropDown.Value,'manual')
                        if inputIsRowTimes(app)
                            app.SupportsVisualization = filterFcn(T.Properties.RowTimes);
                        else
                            vars = getVariablesFromManualSelection(app);
                            supportedVarInd = varfun(filterFcn,T(:,vars),'OutputFormat','uniform');
                            app.SupportsVisualization = any(supportedVarInd);                            
                            items = vars(supportedVarInd);
                            if supportsMoreTypes
                                numSelectedNumericVars = numel(intersect(items,app.AllTableVarNames(app.NumericVarInd)));
                            end
                        end
                    else
                        if isequal(app.DataVarSelectionTypeDropDown.Value,'numeric')
                            fcn = @(x)isnumeric(x) && filterFcn(x);
                        elseif isequal(app.DataVarSelectionTypeDropDown.Value,'supported')
                            fcn = @(x) filterInputDataFromWorkspace(app,x) && filterFcn(x);
                        else
                            fcn = filterFcn;
                        end
                        supportedVarInd = varfun(fcn,T,'OutputFormat','uniform');
                        app.SupportsVisualization = any(supportedVarInd);
                        items = app.AllTableVarNames(supportedVarInd);
                        if supportsMoreTypes
                            numSelectedNumericVars = nnz(app.NumericVarInd(supportedVarInd));
                        end
                    end
                end
            else
                app.SupportsVisualization = true;
            end
            itemsData = items;
            if numel(items) > 1 && (~supportsMoreTypes || numSelectedNumericVars > 1)
                % Add a "select all" option. But for missing data cleaner,
                % tiledlayout only loops over the numeric variables
                if ~supportsMoreTypes || numSelectedNumericVars == numel(items)
                    % Use a numeric value for itemsData so we can
                    % differentiate this option from any table var name
                    itemsData = [items {1}];
                    items = [items getMsgText(app,'SelectAll')];
                else
                    itemsData = [items {2}];
                    items = [items getMsgText(app,'SelectAllNumeric')];
                end
            end
            app.TableVarPlotDropDown.Items = items;
            app.TableVarPlotDropDown.ItemsData = itemsData;
        end

        function showCheckboxes = showPlotCheckboxes(app,varargin)
            showCheckboxes = app.SupportsVisualization;
            app.NoVisualizationLabel.Visible = ~showCheckboxes;
            g = app.Accordion.Children(end).Children;
            if showCheckboxes
                % first subgrid is plot checkboxes
                % second grid is no visualization label
                g.RowHeight{1} = 'fit';
                g.RowHeight{2} = 0;
            else
                g.RowHeight{1} = 0;
                g.RowHeight{2} = app.TextRowHeight;
                if hasMultipleDataVariables(app)
                    app.NoVisualizationLabel.Text = getMsgText(app,'NoVisualizationMulti',getInputDataVarName(app));
                else
                    app.NoVisualizationLabel.Text = getMsgText(app,'NoVisualization',addDotIndexingToTableName(app,getInputDataVarName(app)));
                end
            end
            for idx = 1:numel(varargin)
                varargin{idx}.Visible = showCheckboxes;
            end
        end
    end

    % Helper methods for script generation
    methods (Access = protected)
        function A = getInputDataVarName(app,forceAddTableVarName)
            if nargin < 2
                forceAddTableVarName = false;
            end
            A = app.InputDataDropDown.Value;
            if app.InputDataHasTableVars && (forceAddTableVarName || ...
                    isequal(app.OutputTypeDropDown.Value,'vector'))
                A = addTableVarName(app,A);
            end
        end

        function A = addTableVarName(app,A,varname)
            if nargin < 3
                varInd = ~strcmp({app.InputDataTableVarDropDown.Value},app.SelectVariable);
                varname = app.InputDataTableVarDropDown(find(varInd,1)).Value;
            end
            if isvarname(varname)
                A = [A '.' varname];
            else
                % arbitrary variable name
                name = matlab.internal.dataui.cleanVarName(varname);
                A = [A '.(' name ')'];
            end
        end

        function A = evalInputDataVarNameWithCheck(app,forceAddTableVarName)
            if nargin < 2
                forceAddTableVarName = false;
            end
            if hasInputData(app)
                A = evalin(app.Workspace,getInputDataVarName(app,forceAddTableVarName));
            else
                A = [];
            end
        end

        function A = getInputDataVarNameForGeneratedScript(app,forceAddTableVarName)
            % Markup the variable name to make it clear that the variable
            % name refers to an input data.
            if nargin < 2
                forceAddTableVarName = false;
            end
            A = app.InputDataDropDown.Value;
            if ~isAppWorkflow(app)
                % ticks should go around table name, but not var name
                A = ['`' A '`'];
            end
            if app.InputDataHasTableVars && (forceAddTableVarName || ...
                    isequal(app.OutputTypeDropDown.Value,'vector'))
                A = addTableVarName(app,A);
            end
        end

        function A = getInputDataVarNameForSummary(app)
            % Markup the variable name so that it is displayed in bold in
            % the generateSummary output
            A = getInputDataVarName(app);
            if ~hasMultipleDataVariables(app)
                A = addDotIndexingToTableName(app,A);
            end
            % for multiple variables, just use the table name
            A = ['`' A '`'];
        end

        function xname = getSamplePointsVarName(app)
            if isequal(app.SamplePointsDropDown.Value,app.DefaultValue)
                xname = ''; % default abscissa
            else
                xname = addSamplePointsTableVarName(app,app.SamplePointsDropDown.Value);                
            end
        end

        function xname = addSamplePointsTableVarName(app,xname)
            if app.SamplePointsTableVarDropDownVisible
                if isvarname(app.SamplePointsTableVarDropDown.Value)
                    xname = [xname '.' app.SamplePointsTableVarDropDown.Value];
                else
                    % arbitrary variable name
                    varname = matlab.internal.dataui.cleanVarName(app.SamplePointsTableVarDropDown.Value);
                    xname = [xname '.(' varname ')'];
                end
            end
        end

        function x = evalSamplePointsVarNameWithCheck(app)
            if hasSamplePoints(app)
                x = getSamplePointsVarName(app);
                if ~isempty(x)
                    x = evalin(app.Workspace,x);
                else
                    x = [];
                end
            else
                x = [];
            end
        end

        function xname = getSamplePointsVarNameForGeneratedScript(app)
            % Markup the variable name to make it clear that the variable
            % name refers to an input data. If table, ticks should be
            % around table name
            if isequal(app.SamplePointsDropDown.Value,app.DefaultValue)
                xname = ''; % default abscissa
            else
                xname = addSamplePointsTableVarName(app,['`' app.SamplePointsDropDown.Value '`']);
            end
        end

        function nv = getSamplePointsNameValuePair(app,doTime)
            if nargin < 2
                % when timetable input, doTime says whether or not we
                % should use the samplepoints nv pair
                doTime = false;
            end

            if isequal(app.SamplePointsDropDown.Value,app.DefaultValue) || ...
                    (app.hasInputDataAndSamplePoints && strcmp(app.SamplePointsDropDown.Enable,'off') && ~doTime)
                % default or input is timetable, not timetable.varname
                nv = '';
            else
                nv = [',SamplePoints=' getSamplePointsVarNameForGeneratedScript(app)];
            end
        end

        function nv = getDataVariablesNameValuePair(app,forceGet)
            if nargin < 2
                forceGet = false;
            end
            nv = '';
            if outputIsTable(app) && ~inputIsRowTimes(app) && (~ismember(app.OutputTypeDropDown.Value,{'smallMask','smalltable'}) || forceGet)
                if isequal(app.DataVarSelectionTypeDropDown.Value,'numeric')
                    nv = ',DataVariables=@isnumeric';
                elseif ~allTableVariablesSelected(app)
                    if isequal(app.DataVarSelectionTypeDropDown.Value,'manual')
                        vars = getVariablesFromManualSelection(app);
                    else
                        vars = getAllSupportedVariables(app);
                    end
                    nv = matlab.internal.dataui.addCellStrToCode(',DataVariables=',vars);
                end
                % else all variables selected, underlying default
            end
            % else, we have matrix input or are using indexing to get the correct datavars
        end

        function nv = getOutputFormatNameValuePair(app)
            nv = '';
            if app.InputDataHasTableVars && ismember(app.OutputTypeDropDown.Value,{'table','append','smalltable'})
                nv = ',OutputFormat="tabular"';
            end
        end

        function nv = getReplaceValuesNameValuePair(app)
            nv = '';
            if app.InputDataHasTableVars && isequal(app.OutputTypeDropDown.Value,'append')
                nv = ',ReplaceValues=false';
            end
        end

        function code = generateScriptAppendLogical(app,code,outName,funName)
            if app.InputDataHasTableVars && isequal(app.OutputTypeDropDown.Value,'append')
                tick = '`';
                if isAppWorkflow(app)
                    tick = '';
                end
                code = adjustVarNames(app,code,outName,funName);
                % append to table
                code = [code newline outName ' = [' tick app.InputDataDropDown.Value tick ' ' outName '];'];
            end
        end

        function [code,newVarNames] = adjustVarNames(app,code,tableName,fun,varNamesA)
            if nargin < 5
                varNamesA = app.AllTableVarNames;
            end
            code = [code newline tableName '.Properties.VariableNames = '];
            % Ideally, names look like, e.g. Var1_minima
            idealVarNames = getSelectedVarNames(app) + "_" + fun;
            % But if that is already a table var name, we can't use it. Use
            % existing tooling to check.
            [newVarNames,didModify] = matlab.lang.makeUniqueStrings(idealVarNames,varNamesA,namelengthmax);
            if ~any(didModify)
                % generate script to add the function name to all the variables
                code = matlab.internal.dataui.addCharToCode(code,[tableName '.Properties.VariableNames + "_' fun '";']);
            else
                % generate script that lists all the variables explicitly
                code = matlab.internal.dataui.addCellStrToCode(code,newVarNames);
                code = [code ';'];
            end
        end

        function vars = getSelectedVarNames(app)
            if isequal(app.DataVarSelectionTypeDropDown.Value,'numeric')
                vars = app.AllTableVarNames(app.NumericVarInd);
            elseif isequal(app.DataVarSelectionTypeDropDown.Value,'supported')
                vars = getAllSupportedVariables(app);
            elseif isequal(app.DataVarSelectionTypeDropDown.Value,'manual')
                vars = getVariablesFromManualSelection(app);
            else %all
                vars = app.AllTableVarNames;
            end
        end

        function vars = getVariablesFromManualSelection(app)
            % Use the dropdowns that are not 'select variable'
            vars = {app.InputDataTableVarDropDown.Value};
            vars = vars(~strcmp(vars,app.SelectVariable));
            % sort these by position in input table
            [~,ind] = ismember(vars,app.AllTableVarNames);
            vars = app.AllTableVarNames(sort(ind));
        end

        function vars = getAllSupportedVariables(app)
            vars = app.SupportedTableVars;
            % remove 'Time' from this list
            if ~isempty(app.TimetableDimName)
                vars = setdiff(vars,app.TimetableDimName,'stable');
            end
        end

        function A = addDotIndexingToTableName(app,A)
            if hasMultipleDataVariables(app)
                % this includes case 'all' 'supported' and 'numeric' even
                % if they only have one variable
                val = app.TableVarPlotDropDown.Value;
                if isnumeric(val)
                    % decide what to plot in the input plot for Remove
                    % Trends when output plot is all vars
                    val = app.TableVarPlotDropDown.Items{1};
                end
                A = addTableVarName(app,A,val);
            elseif app.outputIsTable
                % this only includes 'manual' and is only called if we have data
                % So we have exactly one dd with a variable selected
                A = addTableVarName(app,A);
            end
        end

        function [A,k] = addSubscriptIndexingToTableName(app,A,useInputTable,ignoreAppend)
            k = [];
            % Use the ignoreAppend flag to index into selected subtable
            % before the append happens
            doAppend = (nargin < 4 || ~ignoreAppend) && isequal(app.OutputTypeDropDown.Value,'append');
            if app.outputIsTable && ~inputIsRowTimes(app)
                % get location of chosen variable in table;
                if app.InputSize(2) > 1
                    if hasMultipleDataVariables(app)
                        % if dd is empty, we won't get here because
                        % SupportsVisualization will be false
                        varName = app.TableVarPlotDropDown.Value;
                    else
                        % there is only one, but it may not be in first dd
                        ind = ~strcmp({app.InputDataTableVarDropDown.Value},app.SelectVariable);
                        varName = app.InputDataTableVarDropDown(ind).Value;
                    end
                    if nargin < 3
                        useInputTable = ismember(app.OutputTypeDropDown.Value,{'largeMask','replace'}) || ...
                            isequal(app.DataVarSelectionTypeDropDown.Value,'all');
                    end
                    if useInputTable
                        k = find(strcmp(app.AllTableVarNames,varName),1);
                    else
                        vars = getSelectedVarNames(app);
                        k = find(strcmp(vars,varName),1);
                    end
                    if doAppend
                        k = k + app.InputSize(2);
                    end
                elseif doAppend
                    k = 2;
                else
                    return
                end
                % index to the kth vector
                A = [A '(:,' num2str(k) ')'];
            end
        end

        function A = addIndexingIntoAppendedVar(app,A)
            % we can't depend on the variable name for
            % indexing, so subscript by location in table
            [~,subscript] = addSubscriptIndexingToTableName(app,[]);
            A = [A '.(' num2str(subscript) ')'];
        end

        function code = getSmallTableCode(app,forceGet)
            if nargin < 2
                forceGet = false;
            end
            if ~forceGet && (~app.InputDataHasTableVars || ...
                    ~ismember(app.OutputTypeDropDown.Value,{'smalltable','smallMask'}) ||...
                    isequal(app.DataVarSelectionTypeDropDown.Value,'all'))
                code = [];
                return
            end
            if isequal(app.DataVarSelectionTypeDropDown.Value,'numeric')
                code = '(:,vartype("numeric"))';
            else
                if isequal(app.DataVarSelectionTypeDropDown.Value,'manual')
                    vars = getVariablesFromManualSelection(app);
                else
                    vars = getAllSupportedVariables(app);
                end
                code = matlab.internal.dataui.addCellStrToCode('(:,',vars);
                code = [code ')'];
            end
        end

        function code = addComma(~,xVarName)
            if isempty(xVarName)
                code = '';
            else
                code = ',';
            end
        end

        function [code,didHoldOn] = addHold(~,code,onOrOff,didHoldOn,numPlots,tab)
            if numPlots > 1 && isequal(onOrOff,'on') && ~didHoldOn
                % We have multiple plots and we haven't turned on hold yet
                code = [code newline tab 'hold on'];
                didHoldOn = true;
            elseif didHoldOn && isequal(onOrOff,'off') && isempty(tab)
                % We already turned hold on, and we need to turn it back
                % off. Note that non-empty tab means we are in tiledlayout
                % where hold off is not needed since next plot will go into
                % next tile or figure.
                code = [code newline 'hold off'];
            end
        end

        function code = addVisualizeResultsLine(app)
            code = ['% ' char(getMsgText(app,'Visualizeresults'))];
            if isAppWorkflow(app)
                code = [code newline 'cla'];
            elseif isnumeric(app.TableVarPlotDropDown.Value)
                code = [code newline 'f = figure(Units="normalized");'];
                markAsVariablesToBeCleared(app,'f');
            else
                code = [code newline 'figure'];
            end
        end

        function [code,inIndex,outIndex] = generateScriptSetupTiledLayout(app,code,needOutLocation,isNby2)
            allVars = app.AllTableVarNames;
            selectedVars = getSelectedVarNames(app);
            plottableVars = app.TableVarPlotDropDown.Items(1:end-1);
            if isa(app,'matlab.internal.dataui.missingDataCleaner')
                % missingDataCleaner: tiledlayout comes from "Select all
                % numeric", rather than "select all"
                plottableVars = intersect(plottableVars,app.AllTableVarNames(app.NumericVarInd),'stable');
            end
            if numel(plottableVars) == numel(allVars)
                % Loop over all variables
                needDV = false;
                needLoc = false;
            elseif numel(plottableVars) == numel(selectedVars)
                % Either all selected vars are plottable or the plottable
                % vars are left-most in the output table
                % loop over all plottable variables
                needDV = true;
                % output location can be calculated using k and N
                needLoc = false;
            else
                % loop over the plottable variables
                needDV = true;
                % location of variables in the output can't be calculated
                % using k and N
                needLoc = needOutLocation;
            end
            useDVForLoc = false;
            if ~needDV
                code = [code newline 'N = ' num2str(app.InputSize(2)) ';'];
                markAsVariablesToBeCleared(app,'N');
            else
                [~,ind] = ismember(plottableVars,allVars);
                code = [code newline 'dv = ' mat2str(ind) ';'];
                code = [code newline 'N = numel(dv);'];
                markAsVariablesToBeCleared(app,'dv','N');
                if needLoc
                    [~,ind2] = ismember(plottableVars,selectedVars);
                    if ~isequal(ind,ind2)
                        code = [code newline 'loc = ' mat2str(ind2) ';'];
                        markAsVariablesToBeCleared(app,'loc');
                    else
                        useDVForLoc = true;
                    end
                end
            end
            if needLoc
                inIndex = 'dv(k)';
                if ~useDVForLoc
                    outIndex = 'loc(k)';
                else
                    outIndex = 'dv(k)';
                end
            elseif needDV
                inIndex = 'dv(k)';
                if isequal(app.OutputTypeDropDown.Value,'replace')
                    outIndex = 'dv(k)';
                else
                    outIndex = 'k';
                end                
            else
                inIndex = 'k';
                outIndex = 'k';
            end
            code = [code newline 'f.Position = [0 0 1 N/3];'];
            if nargin < 4 || ~isNby2
                code = [code newline 'tiledlayout(N,1,Padding="compact");'];
            else
                code = [code newline 'tiledlayout(N,2,Padding="compact");'];
            end
            code = [code newline 'for k = 1:N'];
            code = [code newline '    nexttile'];
            markAsVariablesToBeCleared(app,'k');
        end

        function code = generateScriptEndTiledLayout(~,code)
            code = [code newline 'end'];
            % Add so next plot in live editor is not in tiledlayout: g2403932
            code = [code newline 'f.NextPlot = "new";'];
        end

        function code = generateScriptPlotInputData(app,code,x,a,tab)
            % Script for plotting input data in the same way in all apps
            code = [code newline tab 'plot(' x addComma(app,x) a];
            isindented = ~isempty(tab);
            code = matlab.internal.dataui.addCharToCode(code,',SeriesIndex=6,',isindented);
            code = addDisplayName(app,code,char(getMsgText(app,'InputData')),isindented);
        end

        function code = generateScriptPlotCleanedData(app,code,x,a,tab,txt)
            % Script for plotting cleaned data in the same way in all apps
            code = [code newline tab 'plot(' x addComma(app,x) a];
            isindented = ~isempty(tab);
            code = matlab.internal.dataui.addCharToCode(code,',SeriesIndex=1,',isindented);
            code = matlab.internal.dataui.addCharToCode(code,'LineWidth=1.5,',isindented);
            if nargin < 6
                txt = char(getMsgText(app,'CleanedData'));
            end
            code = addDisplayName(app,code,txt,isindented);
        end

        function code = addVerticalLines(app,code,xMask,xVarName,txt,colorCode,lw,tab,isLogicalMask,xlineName,ylineName)
            % Plot vertical lines at x locations given by logical mask
            % Generate abscissa for plot()
            if nargin < 9
                isLogicalMask = true;
            end
            if nargin < 10
                xlineName = 'x';
            end
            if nargin < 11
                ylineName = 'y';
            end
            if ~isLogicalMask
                xVarName = xMask;
            elseif isempty(xVarName)
                xVarName = ['find(' xMask ')'];
            else
                xVarName = [xVarName '(' xMask ')'];
            end

            % draw essentially xlines, but only one line object
            code = setAxesLimitToDefault(app,code,'y');
            code = [code newline tab xlineName ' = repelem(' xVarName ',3);'];
            if ~isLogicalMask
                code = [code newline tab ylineName ' = repmat([ylim(gca) missing]'',numel(' xMask '),1);'];
            else
                code = [code newline tab ylineName ' = repmat([ylim(gca) missing]'',nnz(' xMask '),1);'];
            end
            code = [code newline tab 'plot(' xlineName ',' ylineName ','];
            isindented = ~isempty(tab);
            code = matlab.internal.dataui.addCharToCode(code,colorCode,isindented);
            if ~isempty(lw)
                code = matlab.internal.dataui.addCharToCode(code,['LineWidth=' lw ','],isindented);
            end
            code = addDisplayName(app,code,txt,isindented);
            code = restoreAxesLimit(app,code,'y',tab);
            markAsVariablesToBeCleared(app,xlineName,ylineName);
        end

        function code = setAxesLimitToDefault(app,code,xy)
            if isAppWorkflow(app)
                % store current x or y axes limits, i.e. user's zoomed location
                code = [code newline 'limtemp = ' xy 'lim;'];
                % set axes limits back to default to draw appropriate
                % vertical or horizontal lines
                code = [code newline xy 'lim("tickaligned");'];
            end
        end

        function code = restoreAxesLimit(app,code,xy,tab)
            if isAppWorkflow(app)
                % reset to user's zoom
                code = [code newline tab xy 'lim(limtemp);'];
            end
        end

        function code = addDisplayName(app,code,name,isindented)
            if isAppWorkflow(app)
                % add a checkbox for interactive legend
                name = [matlab.internal.dataui.legendHitFcn() ' ' name];
            end
            code = matlab.internal.dataui.addCharToCode(code,['DisplayName="' name '")'],isindented);
        end

        function code = addXLimits(app,code,xVarName,tab)
            if isempty(xVarName)
                code = [code newline tab 'xlim([1 ' num2str(getNumelAlongDefaultDim(app)) '])'];
            else
                code = [code newline tab 'xlim([' xVarName '(1) ' xVarName '(end)])'];
            end
        end

        function code = addLegendAndAxesLabels(app,code,tab,isLinePlot,skipLegend)
            if nargin < 4
                isLinePlot = true;
            end
            if nargin < 5
                skipLegend = false;
            end
            doTiledLayout = ~isempty(tab);
            % add a legend for editor workflow only
            % DataCleaner will have a way for user to turn on legend
            if ~isAppWorkflow(app) && ~skipLegend
                code = [code newline tab 'legend'];
                if doTiledLayout
                    % in tiled layout, legend more likely to cover data
                    % since plots are 1/3 height
                    code = [code '(Location="eastoutside")'];
                end
            end
            plotVarName = '';
            if hasMultipleDataVariables(app)
                % add a y-label for the table variable being plotted
                if doTiledLayout
                    % plottable vars are listed in the dropdown, but we
                    % don't want "select all" which is the last item
                    plottableVars = app.TableVarPlotDropDown.Items(1:end-1);
                    if isa(app,'matlab.internal.dataui.missingDataCleaner')
                        % missingDataCleaner: tiledlayout comes from "Select all
                        % numeric", rather than "select all"
                        plottableVars = intersect(plottableVars,app.AllTableVarNames(app.NumericVarInd));
                    end
                    if numel(plottableVars) == app.InputSize(2)
                        ind = 'k';
                    else
                        ind = 'dv(k)';
                    end
                    plotVarName = [getInputDataVarNameForGeneratedScript(app) '.Properties.VariableNames{' ind '}'];
                else
                    plotVarName = app.TableVarPlotDropDown.Value;
                    plotVarName = matlab.internal.dataui.cleanVarName(plotVarName);
                end
            elseif app.outputIsTable
                % only one table var selected, still need a label
                varInd = ~strcmp({app.InputDataTableVarDropDown.Value},app.SelectVariable);
                plotVarName = app.InputDataTableVarDropDown(varInd).Value;
                plotVarName = matlab.internal.dataui.cleanVarName(plotVarName);
            end
            if ~isempty(plotVarName)
                labelType = 'ylabel';
                if ~isLinePlot
                    % histogram - table var is on x-axis
                    labelType = 'xlabel';
                end
                code = addLabel(code,labelType,plotVarName,tab);
            end
            % add an x-label for non-default x-axis
            if isLinePlot && ~isequal(app.SamplePointsDropDown.Value,app.DefaultValue)
                if app.SamplePointsTableVarDropDownVisible
                    % do just the table var name
                    xname = matlab.internal.dataui.cleanVarName(app.SamplePointsTableVarDropDown.Value);
                else
                    % do the workspace vector name
                    xname = ['"' getSamplePointsVarName(app) '"'];
                end
                if doTiledLayout
                    code = [code newline tab 'if k == N'];
                end
                code = addLabel(code,'xlabel',xname,[tab tab]);
                if doTiledLayout
                    code = [code newline tab 'end'];
                end
            end
        end

        function markAsVariablesToBeCleared(app,varargin)
            % Mark as variables that need to be cleared later
            % unless already captured
            app.TemporaryVariables = union(app.TemporaryVariables,varargin,'stable');
        end

        function resetVariablesToBeCleared(app)
            app.TemporaryVariables = cell(1,0);
        end

        function code = addClear(app,code)

            if ~isempty(app.TemporaryVariables)
                vars = '';
                for k = 1:numel(app.TemporaryVariables)
                    vars = [vars ' ' app.TemporaryVariables{k}]; %#ok<AGROW>
                end
                code = [code newline 'clear' vars];
            end
        end
    end

    % Helper Methods for get/set state
    methods (Access = protected)
        function state = getInputDataAndSamplePointsDropDownValues(app,state)
            if ~isequal(app.InputSize,[0 0])
                state.InputSize = app.InputSize;
            end
            if ~isempty(app.AllTableVarNames)
                state.AllTableVarNames = app.AllTableVarNames;
            end
            if ~isequal(app.NumericVarInd,false) % could be a vector
                state.NumericVarInd = app.NumericVarInd;
            end
            state.InputDataDropDownValue = app.InputDataDropDown.Value;
            % For backward compatibility, save table variable names with a
            % "." on front end.
            state.InputDataTableVarDropDownValues = app.addDot({app.InputDataTableVarDropDown.Value});
            % renamed the property to be more accurate, but keep the same
            % state field name for backward compatibility
            state.InputDataTableVarDropDownVisible = app.InputDataHasTableVars;

            state.SamplePointsDropDownValue = app.SamplePointsDropDown.Value;
            state.SamplePointsTableVarDropDownValue = app.addDot(app.SamplePointsTableVarDropDown.Value);
            state.SamplePointsTableVarDropDownVisible = app.SamplePointsTableVarDropDownVisible;
            state.SamplePointsVarClass = app.SamplePointsVarClass;
            state.SupportsVisualization = app.SupportsVisualization;
            state.InputDataTableVarNames = append('.',app.TableVarNamesForDD);
            state.TimetableDimName = ['.' app.TimetableDimName];
            state.SupportedTableVars = append('.',app.SupportedTableVars);
            state.SamplePointsTableVarNames = append('.',app.SamplePointsTableVarNames);

            state.OutputTypeValue = app.OutputTypeDropDown.Value;
            state.OutputTypeItems = app.OutputTypeDropDown.Items;
            state.OutputTypeItemsData = app.OutputTypeDropDown.ItemsData;

            state.DataVarSelectionTypeDropDownItems = app.DataVarSelectionTypeDropDown.Items;
            state.DataVarSelectionTypeDropDownItemsData = app.DataVarSelectionTypeDropDown.ItemsData;
            state.DataVarSelectionTypeDropDownValue = app.DataVarSelectionTypeDropDown.Value;
            state.TableVarPlotDropDownItems = app.TableVarPlotDropDown.ItemsData(~cellfun(@isnumeric,app.TableVarPlotDropDown.ItemsData));
            state.TableVarPlotDropDownValue = app.TableVarPlotDropDown.Value;
            state.TableVarPlotDropDownDoSelectAll = isnumeric(state.TableVarPlotDropDownValue) && state.TableVarPlotDropDownValue == 1;
            canPlotMultVars = ~isempty(app.TableVarPlotDropDown.ItemsData) && isnumeric(app.TableVarPlotDropDown.ItemsData{end});
            state.TableVarPlotDropDownHasSelectAll = canPlotMultVars && app.TableVarPlotDropDown.ItemsData{end} == 1;
            state.TableVarPlotDropDownDoSelectAllNumeric = isnumeric(state.TableVarPlotDropDownValue) && state.TableVarPlotDropDownValue == 2;
            state.TableVarPlotDropDownHasSelectAllNumeric = canPlotMultVars && app.TableVarPlotDropDown.ItemsData{end} == 2;
            if state.TableVarPlotDropDownDoSelectAll || state.TableVarPlotDropDownDoSelectAllNumeric
                % Older versions can only plot one value, pick the first
                % dropdown item for this
                state.TableVarPlotDropDownValue = app.TableVarPlotDropDown.Items{1};
            end

            % for backward compatibility save what should go in the one
            % table variable dropdown
            if ~hasMultipleDataVariables(app) && hasInputData(app) && app.InputDataHasTableVars
                % use the one selected variable
                varInd = ~strcmp({app.InputDataTableVarDropDown.Value},app.SelectVariable);
                state.InputDataTableVarDropDownValue = ['.' app.InputDataTableVarDropDown(find(varInd,1)).Value];
            elseif ~isempty(app.TableVarPlotDropDown.Items)
                val = app.TableVarPlotDropDown.Value;
                if isnumeric(val)
                    val = app.TableVarPlotDropDown.Items{1};
                end
                state.InputDataTableVarDropDownValue = ['.' val];
            else
                state.InputDataTableVarDropDownValue = app.SelectVariable;
            end
            % also, save what should go in the output type dropdown
            % old list (21a,21b,22a): {'vector' 'smalltable' 'table'};
            % 22b list (find task):{'vector' 'smallMask' 'largeMask' 'table' 'append'};
            % 22b list (other tasks): {'vector' 'smalltable' 'replace' 'append'}
            items = state.OutputTypeItems;
            itemsData = state.OutputTypeItemsData;
            value = state.OutputTypeValue;
            if app.OutputTypeDropDown.UserData % Find task
                if ismember('append',itemsData)
                    % remove 'table' and 'append'
                    items(end-1:end) = [];
                    itemsData(end-1:end) = [];
                end
                if ismember('largeMask',itemsData)
                    % change 'largeMask' to 'table'
                    itemsData{end} = 'table';
                end
                if ismember('smallMask',itemsData)
                    % change 'smallMask' to 'smalltable'
                    itemsData{1} = 'smalltable';
                end
                if ismember(value,{'largeMask' 'table' 'append'})
                        value = 'table';
                elseif isequal(value,'smallMask')
                        value = 'smalltable';
                end
            else
                [tf,ind] = ismember({'replace' 'append'},itemsData);
                if tf(1)
                    % change replace to table
                    itemsData{ind(1)} = 'table';
                end
                if tf(2)
                    % remove append
                    items(end) = [];
                    itemsData(end) = [];
                end  
                if ismember(value,{'replace' 'append'})
                    value = 'table';
                end
            end
            state.OutputTypeDropDownItems = items;
            state.OutputTypeDropDownItemsData = itemsData;
            state.OutputTypeDropDownValue = value;
            state.TaskIsStale = app.TaskIsStale;
        end

        function setInputDataAndSamplePointsDropDownValues(app,state)
            if isfield(state,'InputSize')
                app.InputSize = state.InputSize;
            else
                app.InputSize = [0 0];
            end
            if isfield(state,'AllTableVarNames')
                app.AllTableVarNames = state.AllTableVarNames;
            else
                app.AllTableVarNames = cell(1,0);
            end
            if isfield(state,'NumericVarInd')
                app.NumericVarInd = state.NumericVarInd;
            else
                app.NumericVarInd = false;
            end
            if isfield(state,'TimetableDimName')
                % Table variable names are saved in state with "." on the front
                % for backward compatibility. For use in the tasks now, we need
                % to remove the "."
                app.TimetableDimName = app.rmDot(state.TimetableDimName);
            end
            if isfield(state,'InputDataTableVarNames')
                % this resets the grid and populates only the first row
                populateInputDataTableVarDropDown(app,app.rmDot(state.InputDataTableVarNames));
            end
            if isfield(state,'SupportedTableVars')
                if isempty(state.SupportedTableVars)
                    app.SupportedTableVars = cell.empty(1,0);
                else
                    app.SupportedTableVars = app.rmDot(state.SupportedTableVars);
                    % force into row vector for generateScript
                    % jsonencode/decode can change this
                    app.SupportedTableVars = reshape(app.SupportedTableVars,1,[]);
                end
            end
            if isfield(state,'InputDataTableVarDropDownVisible')
                app.InputDataHasTableVars = state.InputDataTableVarDropDownVisible;
            end

            setValueOfComponents(app,"InputDataDropDown",state);
            if isfield(state,'InputDataTableVarDropDownValues')
                if ~isempty(app.TableVarNamesForDD)
                    vals = app.rmDot(state.InputDataTableVarDropDownValues);
                    n = numel(vals);
                    app.DataVarGrid.RowHeight = repelem({app.TextRowHeight},1,n);
                    app.InputDataTableVarDropDown(1).Value = vals{1};
                    for k = 2:n
                        createTableVarSubrow(app,k);
                        app.InputDataTableVarDropDown(k).Items = app.InputDataTableVarDropDown(1).Items;
                        app.InputDataTableVarDropDown(k).ItemsData = app.InputDataTableVarDropDown(1).ItemsData;
                        app.InputDataTableVarDropDown(k).Value = vals{k};
                    end
                    % trim the Items(Data) based on values of previous dds
                    repopulateTableVarDropDowns(app);
                end
            elseif isfield(state,'InputDataTableVarDropDownValue')
                % comes from a previous version with only one dropdown value
                val = app.rmDot(state.InputDataTableVarDropDownValue);
                if ~ismember(val,app.InputDataTableVarDropDown.ItemsData)
                    % Comes from older version where default items were
                    % named slightly differently
                    app.InputDataTableVarDropDown.Items = [app.InputDataTableVarDropDown.Items {val}];
                    app.InputDataTableVarDropDown.ItemsData = [app.InputDataTableVarDropDown.ItemsData {val}];
                end
                app.InputDataTableVarDropDown.Value = val;
            end
            if isfield(state,'SamplePointsTableVarNames')
                populateSamplePointsTableVarDropDown(app,app.rmDot(state.SamplePointsTableVarNames));
            end
            if isfield(state,'SamplePointsTableVarDropDownVisible')
                app.SamplePointsTableVarDropDownVisible = state.SamplePointsTableVarDropDownVisible;
            end
            if isfield(state,'SamplePointsVarClass')
                app.SamplePointsVarClass = state.SamplePointsVarClass;
            end
            setValueOfComponents(app,"SamplePointsDropDown",state);
            if isfield(state,'SamplePointsTableVarDropDownValue')
                val = app.rmDot(state.SamplePointsTableVarDropDownValue);
                if ~ismember(val,app.SamplePointsTableVarDropDown.ItemsData)
                    % Comes from older version where default items were
                    % named slightly differently
                    app.SamplePointsTableVarDropDown.Items = [app.SamplePointsTableVarDropDown.Items {val}];
                    app.SamplePointsTableVarDropDown.ItemsData = [app.SamplePointsTableVarDropDown.ItemsData {val}];
                end
                app.SamplePointsTableVarDropDown.Value = val;
            end
            if isfield(state,'SupportsVisualization')
                app.SupportsVisualization = state.SupportsVisualization;
            end
            if isfield(state,'OutputTypeItems')
                app.OutputTypeDropDown.Items = state.OutputTypeItems;
                app.OutputTypeDropDown.ItemsData = state.OutputTypeItemsData;
                app.OutputTypeDropDown.Value = state.OutputTypeValue;
            elseif isfield(state,'OutputTypeDropDownItems')
                % Comes from 21a, 21b, or 22a
                % Need to update items from old list: {'vector' 'smalltable' 'table'};
                % to new list: (find task) {'vector' 'smallMask' 'largeMask' 'table' 'append'};
                %            (other tasks) {'vector' 'smalltable' 'replace' 'append'}
                itemsData = state.OutputTypeDropDownItemsData;
                val = state.OutputTypeDropDownValue;
                if app.OutputTypeDropDown.UserData % Find task
                    if ismember('smalltable',itemsData)
                        itemsData{1} = 'smallMask';
                    end
                    if ismember('table',itemsData)
                        itemsData{end} = 'largeMask';
                    end
                    if isequal(val,'smalltable')
                        val = 'smallMask';
                    elseif isequal(val,'table')                    
                        val = 'largeMask';
                    end
                else
                    if ismember('table',itemsData)
                        itemsData{end} = 'replace';
                    end
                    if isequal(val,'table')
                        val = 'replace';
                    end
                end
                % keep the same labels on reload, and don't add new options
                % unless user changes input/variables
                app.OutputTypeDropDown.Items = state.OutputTypeDropDownItems;
                app.OutputTypeDropDown.ItemsData = itemsData;
                app.OutputTypeDropDown.Value = val;
            else
                % comes from Pre-21a where we did vector only
                setOutputTypeDropDownItemsToDefault(app);
                app.OutputTypeDropDown.Value = 'vector'; 
            end
            if isfield(state,'DataVarSelectionTypeDropDownItems')
                app.DataVarSelectionTypeDropDown.Items = state.DataVarSelectionTypeDropDownItems;
                app.DataVarSelectionTypeDropDown.ItemsData = state.DataVarSelectionTypeDropDownItemsData;
                app.DataVarSelectionTypeDropDown.Value = state.DataVarSelectionTypeDropDownValue;
            else
                % comes from an older version where we did vector only
                % use default items and select 'manual'
                setDataVarSelectionTypeDropDownItemsToDefault(app);
                app.DataVarSelectionTypeDropDown.Value = 'manual';
            end
            if isfield(state,'TableVarPlotDropDownItems')
                items = state.TableVarPlotDropDownItems;
                itemsData = items;
                if isfield(state,'TableVarPlotDropDownHasSelectAllNumeric') && state.TableVarPlotDropDownHasSelectAllNumeric
                    items{end+1} = char(getMsgText(app,'SelectAllNumeric'));
                    itemsData{end+1} = 2;
                elseif isfield(state,'TableVarPlotDropDownHasSelectAll') && state.TableVarPlotDropDownHasSelectAll
                    items{end+1} = char(getMsgText(app,'SelectAll'));
                    itemsData{end+1} = 1;
                end
                if ~isempty(items)
                    app.TableVarPlotDropDown.Items = items;
                    app.TableVarPlotDropDown.ItemsData = itemsData;
                else
                    % jsonencoding changes {} to [], so we must change it back
                    app.TableVarPlotDropDown.Items = {};
                    app.TableVarPlotDropDown.ItemsData = {};
                end
                if isfield(state,'TableVarPlotDropDownValue')
                    if isfield(state,'TableVarPlotDropDownDoSelectAll') && state.TableVarPlotDropDownDoSelectAll
                        val = 1;
                    elseif isfield(state,'TableVarPlotDropDownDoSelectAllNumeric') && state.TableVarPlotDropDownDoSelectAllNumeric
                        val = 2;
                    else
                        val = state.TableVarPlotDropDownValue;
                        if isempty(val)
                            % jsonencoding changes {} to [], so we must change it back
                            val = {};
                        end
                    end
                    app.TableVarPlotDropDown.Value = val;
                end
            end
            app.TaskIsStale = ~isfield(state,'TaskIsStale') || state.TaskIsStale || ...
                app.Version ~= state.VersionSavedFrom;
        end

        function setValueOfComponents(app,comp,state)
            for k = 1:numel(comp)
                if isfield(state,comp(k) + "Value")
                    app.(comp(k)).Value = state.(comp(k) + "Value");
                end
            end
        end

        function vals = addDot(app,vals)
            % For backward compatibility, save table variable names with a
            % "." on front end.
            ind = ~strcmp(vals,app.SelectVariable);
            if iscell(vals)
                vals(ind) = append('.',vals(ind));
            elseif ind
                vals = ['.' vals];
            end
        end

        function vals = rmDot(~,vals)
            % Table variable names are saved in state with "." on the front
            % for backward compatibility. For use in the tasks now, we need
            % to remove the "."
            if ~isempty(vals)
                vals = strip(vals,'left','.');
            end
        end
    end

    % General helpers
    methods (Access = protected)
        function hasInput = hasInputData(app,checkTableVar)
            % "Input data" dropdown has a variable selected from workspace
            hasInput = ~isequal(app.InputDataDropDown.Value,app.SelectVariable);

            if nargin < 2
                checkTableVar = true;
            end
            if checkTableVar && hasInput && app.InputDataHasTableVars
                % And has (time)table variable(s) selected
                if isequal(app.DataVarSelectionTypeDropDown.Value,'manual')
                    hasInput = ~all(strcmp({app.InputDataTableVarDropDown.Value},app.SelectVariable));
                end
            end
        end

        function hasInput = hasSamplePoints(app)
            % SamplePoints ("X-axis" dropdown) always has a default value
            hasInput = true;
            if app.SamplePointsTableVarDropDownVisible
                % Has a (time)table variable selected
                hasInput = ~isequal(app.SamplePointsTableVarDropDown.Value,app.SelectVariable);
            end
        end

        function hasInput = hasInputDataAndSamplePoints(app)
            hasInput = hasInputData(app) && hasSamplePoints(app);
        end

        function hasTime = hasDurationOrDatetimeSamplePoints(app)
            hasTime = isequal(app.SamplePointsVarClass,'duration') ...
                || isequal(app.SamplePointsVarClass,'datetime');
        end

        function hasTime = hasDatetimeSamplePoints(app)
            hasTime = isequal(app.SamplePointsVarClass,'datetime');
        end

        function numElements = getNumelAlongDefaultDim(app)
            % Get default dim: Like firstNonSingletonDim(A), but doesn't
            % require A. Also, tables flow through properly since 1-row
            % tables are not allowed.
            dim = find(app.InputSize ~= 1, 1);
            if isempty(dim)
                dim = 2;
            end
            % Get numel along dim
            numElements = app.InputSize(dim);
        end

        function tf = outputIsTable(app)
            tf = app.InputDataHasTableVars && ~strcmp(app.OutputTypeDropDown.Value,'vector');
        end

        function tf = hasMultipleDataVariables(app)
            % note that this returns true for 'All supported' even if there
            % is only one var in the input table
            tf = app.InputDataHasTableVars && ...
                (~isequal(app.DataVarSelectionTypeDropDown.Value,'manual') || ...
                nnz(~strcmp({app.InputDataTableVarDropDown.Value},app.SelectVariable)) > 1);
        end

        function tf = inputIsRowTimes(app)
            tf = false;
            if hasInputData(app) && ~isempty(app.TimetableDimName) && ~hasMultipleDataVariables(app)
                tf = isequal(app.InputDataTableVarDropDown(1).Value,app.TimetableDimName);
            end
        end

        function tf = hasValidRowTimes(app)
            tf = app.InputDataHasTableVars && istimetable(app.InputDataDropDown.WorkspaceValue);
            if tf && ~isAppWorkflow(app) && ~app.SamplePointsForPlotOnly
                % if in preprocessing app or a task where we only need
                % rowtimes for plotting, let bad time vectors flow through
                timevector = app.InputDataDropDown.WorkspaceValue.Properties.RowTimes;
                tf = filterSamplePointsType(app,timevector,true) && filterSamplePointsData(timevector);
            end
        end

        function TF = allTableVariablesSelected(app)
            TF = false;
            if hasInputData(app) && app.InputDataHasTableVars
                if isequal(app.DataVarSelectionTypeDropDown.Value,'all')
                    TF = true;
                elseif isequal(app.DataVarSelectionTypeDropDown.Value,'manual')
                    numVars = nnz(~strcmp({app.InputDataTableVarDropDown.Value},app.SelectVariable));
                    TF = app.InputSize(2) == numVars;
                end
            end
        end

        function s = getMsgText(~,msgId,varargin)
            s = string(message(['MATLAB:dataui:' msgId],varargin{:}));
        end

        function txt = getSelectVariableText(app)
            txt = char(getMsgText(app,'SelectVariable'));
        end

        function tf = isAppWorkflow(app)
            % task is being used in the preprocessing app, not live editor
            tf = ~isequal(app.Workspace,'base');
        end

        function didClearInput = checkForClearedWorkspaceVariables(app)
            didClearInput = false;
            if isempty(app.InputDataDropDown.WorkspaceValue)
                if ~isequal(app.InputDataDropDown.Value,app.SelectVariable)
                    % Variable is no longer in workspace
                    didClearInput = true;
                end %Else, data has not been selected
                setInputDataAndWidgetsToDefault(app);
                % No longer need to worry about updating stale items lists
                app.TaskIsStale = false;
            elseif isempty(app.SamplePointsDropDown.WorkspaceValue) && ~strcmp(app.SamplePointsDropDown.Value,app.DefaultValue)
                % either default or the variable has been cleared
                setSamplePointsToDefault(app);
                changedSamplePointsVarClass(app);
            end
        end

        function refreshStaleTask(app,src,event)            
            didClear = checkForClearedWorkspaceVariables(app);
            if ~app.TaskIsStale
                if didClear && nargin > 1
                    % reset display based on freshly cleared task
                    doUpdate(app);
                end
                return
            end
            T = app.InputDataDropDown.WorkspaceValue;
            app.InputSize = size(T);
            % Update controls that may not have existed in previous
            % versions and that depend on the workspace value of the input
            if app.InputDataHasTableVars
                app.AllTableVarNames = T.Properties.VariableNames;
                % Set app.SupportedTableVars - matches
                % InputDataTableVarDropDown's Items, but removes non-columns
                vars = app.InputDataTableVarDropDown(1).Items(2:end);
                rt = {};
                if istimetable(T)
                    app.TimetableDimName = T.Properties.DimensionNames{1};
                    if isequal(app.TimetableDimName,vars{1})
                        % remove rowtimes from the list for indexing into
                        % T, but keep it for SupportedTableVars
                        vars(1) = [];
                        rt = {app.TimetableDimName};
                    end
                end
                vars(~varfun(@iscolumn,T(:,vars),"OutputFormat","uniform")) = [];
                app.SupportedTableVars = [rt vars];

                % Reset dropdown items
                val = app.DataVarSelectionTypeDropDown.Value;
                setDataVarSelectionTypeDropDownItemsFromInput(app);
                if ismember(val,app.DataVarSelectionTypeDropDown.ItemsData)
                    app.DataVarSelectionTypeDropDown.Value = val;
                end
                setOutputTypeDropDownItemsToDefault(app);
            end
            app.TaskIsStale = false;
            if nargin > 1
                % in case values have changed on clicking a dropdown open,
                % need to update layout and trigger new generateScript
                doUpdateFromWidgetChange(app,src,event)
            end
        end

        function propTable = addFieldsToPropTable(app,propTable)
            N = height(propTable);
            Type = repmat({''},N,1);
            Tooltip = repmat({''},N,1);
            Items = repmat({[]},N,1);
            ItemsData = repmat({[]},N,1);
            Visible = repmat(matlab.lang.OnOffSwitchState.on,N,1);
            Enable = repmat(matlab.lang.OnOffSwitchState.on,N,1);
            SpinnerProperties = repmat({[]},N,1);

            for k = 1:N
                widget = app.(propTable.Name(k));
                Type{k} = class(widget);
                Tooltip{k} = widget.Tooltip;
                if isprop(widget,'Items')
                    Items{k} = widget.Items;
                    ItemsData{k} = widget.ItemsData;
                end
                Visible(k) = widget.Visible;
                Enable(k) = widget.Enable;
                if isa(widget,'matlab.ui.control.Spinner')
                    spinProps = struct;
                    spinProps.Limits = widget.Limits;
                    spinProps.LowerLimitInclusive = logical(widget.LowerLimitInclusive);
                    spinProps.UpperLimitInclusive = logical(widget.UpperLimitInclusive);
                    spinProps.Step = widget.Step;
                    SpinnerProperties{k} = spinProps;
                end
            end
            InitializeFlag = zeros(N,1);
            InSubgroup = false(N,1);
            GroupExpanded = true(N,1);
            propTable = addvars(propTable,Type,Tooltip,Items,ItemsData,Visible,Enable,InitializeFlag,InSubgroup,GroupExpanded,SpinnerProperties);
        end
    end

    % general helper, also used by movwindowWidgets and some subclasses
    methods (Access = {?matlab.internal.dataui.dataSmoother,...
            ?matlab.internal.dataui.missingDataCleaner,...
            ?matlab.internal.dataui.movwindowWidgets,...
            ?matlab.internal.dataui.outlierDataCleaner,...
            ?matlab.internal.dataui.trendRemover,...
            ?matlab.internal.dataui.FindSeasonalTrendsTask})
        function A = getSelectedSubTable(app,A)
            if isequal(app.DataVarSelectionTypeDropDown.Value,'numeric')
                A = A(:,vartype('numeric'));
            elseif inputIsRowTimes(app)
                % in this case, we don't actually want a subtable, but the
                % rowtimes extracted as a vector
                A = A.Properties.RowTimes;
            elseif ismember(app.DataVarSelectionTypeDropDown.Value,{'manual','supported'})
                if isequal(app.DataVarSelectionTypeDropDown.Value,'manual')
                    vars = getVariablesFromManualSelection(app);
                    if isempty(vars)
                        % Input table vars not yet selected. Use all
                        % supported
                        vars = getAllSupportedVariables(app);
                    end
                else
                    vars = getAllSupportedVariables(app);
                end
                A = A(:,vars);
                % else 'all'
            end
        end
    end
end

function tf = filterSamplePointsData(x)
% Check if SamplePoints (X-axis) data is valid
tf = allfinite(x) && ~any(diff(x) <= 0,'all'); % 'all' for empty
end

function varNames = getTableVarNames(T)
% Populate with table variables of supported type
varNames = T.Properties.VariableNames;
if istimetable(T)
    % Add display T.Time in the dropdown
    timeName = T.Properties.DimensionNames{1};
    varNames = [{timeName} varNames];
end
end

function code = addLabel(code,labelType,varname,tab)
code = [code newline tab labelType '(' varname];
if contains(varname,{'_','^','\'}) || (~isempty(tab) && isequal(labelType,'ylabel'))
    % make sure label on plot shows the underscore
    code = [code ',Interpreter="none"'];
end
code = [code ')'];
end