classdef (Abstract) TabularDataModel  < internal.matlab.variableeditor.ArrayDataModel
    
    % This class is unsupported and might change or be removed without notice in
    % a future version.
    
    % This class is the common DataModel class, used for Text and spreadsheet
    % Import
    
    % Copyright 2018-2020 The MathWorks, Inc.

    properties (Constant)
        SampleRowCount = 100;
        SampleColumnCount = 1000;
        DefaultTextType = 'string';
        
        % This is the block count used by the Java Import Tool.  This is used to
        % optimize performance, in an attempt to get closer to COMClient
        % spreadsheet import performance.
        UIBlockColumnCount = 64;
    end
    
    properties (Hidden = true)
        imopts;
        ImportOptionsProvided logical = false;
    end
    
    properties (Access = protected)
        FillInColsAtStart = false;
        StripSpacesFromNames = false;
    end
    
    properties (SetObservable = true)
        CacheData;
        FileName;
        HasFile;
        Data;
        SheetDimensions;
        InitialColumnClasses;
        InitialColumnClassOptions;
        InitialColumnNames;
        DetectedColumnClasses;
        ValidMatlabVarNames = true;
        UseLegacyVariableNames = false;
        CurrentArbitraryVariableNames = strings(0);
        CurrentValidVariableNames = strings(0);
        CurrentVarNamesRow = 0;
        CurrentIsValidMatlabVarNames = true;
    end
    
    methods(Abstract, Access = public)
        % Classes which inherit must implement this method
        columnTypes = getUnderlyingColumnTypes(this);
    end
    
    methods (Access = public)
        function columnNames = getDefaultColumnNames(this, row, avoidShadow, varargin)
            import internal.matlab.importtool.server.ImportUtils;
            
            data = [];
            if this.CurrentVarNamesRow == row
                if this.ValidMatlabVarNames
                    data = this.CurrentValidVariableNames;
                else
                    data = this.CurrentArbitraryVariableNames;
                end
            else
                this.resetStoredNames()
            end
            
            if isempty(data)
                % Would like to use detectImportOptions... but no way to specify the
                % range for the variable names in the constructor.  This also would
                % change the default variable names generated by the Import Tool,
                % since detectImportOptions has a different algorithm for generating
                % variable names from invalid data.
                dataPos = this.getSheetDimensions();
                range = char(ImportUtils.toExcelRange(row, row, 1, ...
                    dataPos(4)));
                
                [~, data] = this.getDataFromExcelRange(range);

                % Check if data is not a viable header name row.
                % A viable header row is only if they data is not all empty
                % or all numeric, i.e. we want to use the data as header
                % names only if it is text data. Additonally, we only need
                % to check this for non legacy variable names since the
                % legacy case is handled by the regex in the
                % getDefaultColumnNames function.
                if (this.UseLegacyVariableNames || ...
                        ~(all(cellfun(@(x) isempty(x) || isnumeric(x), data))))
                    data = data(:)';
                else
                    data = "";
                end
                
                % The data must be of size equal to the number of columns
                % for the column names to be correctly set
                if size(data,2) ~= dataPos(4)
                    data(length(data)+1:dataPos(4)) = {''};
                end
            end

            % Variable names can be optional varargin.  (Depending on the call
            % stack, the variables in 'caller' may not be what we want).
            if nargin == 4
                varNames = varargin{1};
            else
                varNames = evalin('caller', 'who');
            end
            if avoidShadow.isAvoidSomeShadows && ~this.ValidMatlabVarNames
                % For tables, where the user is not enforcing valid matlab
                % names, and arbitrary names are supported
                columnNames = ImportUtils.getArbitraryColumnNames(data, ...
                    this.StripSpacesFromNames, this.UseLegacyVariableNames);
            else
                columnNames = ImportUtils.getDefaultColumnNames(...
                    varNames, data, -1, avoidShadow, this.UseLegacyVariableNames);
                if (this.UseLegacyVariableNames)
                    % If legacy names are not being used, the column names
                    % returned will already be unique.
                    columnNames = matlab.lang.makeUniqueStrings(columnNames, 1:length(columnNames), namelengthmax);
                end
            end
            if isempty(this.InitialColumnNames)
                this.InitialColumnNames = columnNames;
            end
            
            if this.ValidMatlabVarNames
                this.CurrentValidVariableNames = columnNames;
            else
                this.CurrentArbitraryVariableNames = columnNames;
            end
            this.CurrentVarNamesRow = row;
            this.CurrentIsValidMatlabVarNames = this.ValidMatlabVarNames;
        end
        
        function initColumnNames(this)
            headerRow = this.getHeaderRow();
            % avoidShadow is used to avoid creating column names as
            % workspace variables which coincide with existing matlab
            % functions
            avoidShadow = struct('isAvoidSomeShadows', true, 'isAvoidAllShadows', false);
            this.getDefaultColumnNames(headerRow, avoidShadow);
        end
        
        function resetStoredNames(this)
            this.CurrentValidVariableNames = strings(0);
            this.CurrentArbitraryVariableNames = strings(0);
        end

        function columnNames = getColumnNames(this, row, avoidShadow, varargin)
            columnNames = this.getDefaultColumnNames(row, avoidShadow, varargin{:});
        end

        function columnClasses = getColumnClasses(this)
            
            colClasses = this.imopts.VariableTypes;
            dataPos = this.getSheetDimensions();
            numColClasses = size(colClasses);

            % check if the length of the column classes returned is the same as
            % the number of columns if not then the data does not start from the
            % first column fill out the missing column class info with 'string'
            if numColClasses(2) ~= dataPos(4)
                columnClasses = cell(1, dataPos(4));
                % get the difference in length
                diffLength = dataPos(4) - numColClasses(2);
                
                if this.FillInColsAtStart
                    columnClasses(1:diffLength) = {this.DefaultTextType};
                    columnClasses(diffLength + 1:end) = colClasses;
                else
                    columnClasses = colClasses;
                    columnClasses(end+1:end+1+diffLength-1) = {this.DefaultTextType};
                end
            else
                columnClasses = colClasses;
            end
            
            % By default, categorical columns are also returned as string.
            % Replace them with the correct datatypes
            categoricalColumns = this.getCategoricalColumns;
            columnClasses(categoricalColumns) = {'categorical'};

            % The Import Tool doesn't handle logicals.  Treat these as doubles.            
            logicalColumns = cellfun(@(x) x == "logical", columnClasses);
            columnClasses(logicalColumns) = {'double'};

            if isempty(this.InitialColumnClasses)
                this.InitialColumnClasses = columnClasses;
            end
        end
        
        function columnClassOptions = getColumnClassOptions(this)
            dataPos = this.getSheetDimensions();
            numcols = dataPos(4);
            columnClassOptions = repmat({''}, 1, numcols);
        end
        
        function numericColumns = getNumericColumns(this)
            % Setup the numeric columns.  Need to handle cases where the
            % spreadsheet doesn't start at cell A1, so there could be columns
            % prior to the ones that imopts has reported
            dataPos = this.getSheetDimensions();
            numcols = dataPos(4);
            
            numericColumns = false(1, numcols);
            dblColumns = cellfun(@(x) x == "double", this.imopts.VariableTypes);
            numericColumns(dataPos(3):end) = dblColumns;
        end
        
        function categoricalCols = getCategoricalColumns(this)
            % Setup the datetime columns.  Need to handle cases where the
            % spreadsheet doesn't start at cell A1, so there could be columns
            % prior to the ones that imopts has reported
            dataPos = this.getSheetDimensions();
            dims = [dataPos(2) dataPos(4)];
            
            textCols = cellfun(@(x) x == "char" || x == "string", this.imopts.VariableTypes);
            if any(textCols)
                % Need to determine if there are any categorical columns. Read
                % in some sample data to do so (because detectImportOptions
                % doesn't detect categoricals)
                testDims(1) = min(dims(1), this.SampleRowCount);
                testDims(2) = min(dims(2), this.SampleColumnCount);
                range = internal.matlab.importtool.server.ImportUtils.toExcelRange(...
                    1, testDims(1), 1, testDims(2));
                [data, raw, ~] = this.getDataFromExcelRange(range, false);
                raw(~isnan(data)) = {''};
                categoricalCols = internal.matlab.datatoolsservices.preprocessing.VariableTypeDetectionService.getPossibleCategoricalColumnsFromData(raw);
                if ~isequal(length(categoricalCols), length(textCols))
                    % We may have additional categoricalCols because this is
                    % based off of the sheet dimensions, which includes any
                    % additional variables found.
                    sizeDiff = length(categoricalCols) - length(textCols);
                    if sizeDiff > 0
                        textCols(end + 1:end + 1 + (sizeDiff - 1)) = true;
                    else
                        % There are more columns than we checked for
                        % categoricals, fill in the rest as false
                        categoricalCols(end + 1:end + 1 + (abs(sizeDiff) - 1)) = false;
                    end
                end
                categoricalCols = categoricalCols & textCols;
                categoricalCols(1, size(categoricalCols, 2)+1:dims(2)) = true;
            else
                categoricalCols = false(1, dims(2));
            end
        end
        
        function [data, raw, dateData, cachedData, rowRange, colRange] = getData(this, startRow, endRow, startCol, endCol, asDatetime)
            % Get data from the text file for the given range specified by row
            % and column
            newRange = this.getRange(startRow, endRow, startCol, endCol);
            if nargin < 6
                % Unless explicitly set as an argument, dates will be returned
                % as text rather than datetime objects.
                asDatetime = false;
            end
            [data, raw, dateData, cachedData, rowRange, colRange] = this.getDataFromRangeStruct(newRange, asDatetime);
        end
        
        function [data, raw, dateData, cachedData, rowRange, colRange] = getDataFromExcelRange(this, excelRange, asDatetime)
            % Get data from the text file for the given range specified by Excel
            % range, like 'A1:D100'
            newRange = this.getRange(excelRange);
            if nargin <= 2
                % Unless explicitly set as an argument, dates will be returned
                % as text rather than datetime objects.
                asDatetime = false;
            end
            [data, raw, dateData, cachedData, rowRange, colRange] = this.getDataFromRangeStruct(newRange, asDatetime);
        end
        
        function data = updateData(~, varargin)
            % Unused for text import
            data = [];
        end
        
        function data = variableChanged(~, varargin)
            % Unused for text import
            data = [];
        end
        
        function r = getRange(~, varargin)
            if nargin == 5
                startRow = varargin{1};
                endRow = varargin{2};
                startCol = varargin{3};
                endCol = varargin{4};
                excelRange = internal.matlab.importtool.server.ImportUtils.toExcelRange(startRow, endRow, startCol, endCol);
            else
                excelRange = varargin{1};
                [rows, cols] = internal.matlab.importtool.server.ImportUtils.excelRangeToMatlab(excelRange);
                startRow = rows(1);
                endRow = rows(end);
                startCol = cols(1);
                endCol = cols(end);
            end
            
            r = struct('startRow', startRow, ...
                'endRow', endRow, ...
                'startCol', startCol, ...
                'endCol', endCol, ...
                'excelRange', excelRange);
        end
        
        function [data, raw, dateData, cachedData, rowsFromCache, colsFromCache] = ...
            getDataFromRangeStruct(this, newRange, asDatetime)
            key = newRange.excelRange;
            rowsFromCache = [];
            colsFromCache = [];
            if isKey(this.CacheData, key)
                cachedData = this.CacheData(key);
                data = cachedData.data;
                raw = cachedData.raw;
                dateData = cachedData.dateData;
            else
                % No exact match, but check if the requested range is contained
                % in the cacheData
                dataFound = false;
                k = keys(this.CacheData);
                dim = this.getSheetDimensions;
                
                % This is a special case for Java Import Tool performance.  The
                % Java Import Tool always requests a block of at least 64
                % columns, even if there aren't that many columns in the file.
                % But it expects only up to the number of columns in the file.
                % So if the request is to have 64 columns, but there aren't that
                % many columns, just look for the range up to the actual number
                % of columns.
                if newRange.endCol == this.UIBlockColumnCount && newRange.endCol > dim(4)
                    newRange.endCol = dim(4);
                end

                for idx = 1:length(k)
                    mapKey = k{idx};
                    [cacheRows, cacheCols] = ...
                        internal.matlab.importtool.server.ImportUtils.excelRangeToMatlab(mapKey);
                    cachedData = this.CacheData(mapKey);

                    % If the cache contains the specified rows and columns, then
                    % reuse it and return the specified range.
                    if cacheRows(1) <= newRange.startRow && ...
                            cacheRows(end) >= newRange.endRow && ...
                            cacheCols(1) <= newRange.startCol && ...
                            cacheCols(end) >= newRange.endCol && ...
                            cachedData.asDatetime == asDatetime
                        
                        % Figure out where the requested rows are in relation to
                        % the cache data
                        rowIncrement = newRange.startRow - cacheRows(1);
                        colIncrement = newRange.startCol - cacheCols(1);
                        
                        rowsFromCache = rowIncrement + (1:(newRange.endRow - newRange.startRow + 1));
                        colsFromCache = colIncrement + (1:(newRange.endCol - newRange.startCol + 1));
                        
                        try
                            data = cachedData.data(rowsFromCache, colsFromCache);
                            raw = cachedData.raw(rowsFromCache, colsFromCache);
                            dateData = cachedData.dateData(rowsFromCache, colsFromCache);
                            dataFound = true;
                        catch
                        end
                        break;
                    end
                end
                
                if ~dataFound
                    cachedData = read(this, newRange.excelRange, asDatetime);
                    cachedData.asDatetime = asDatetime;
                    this.CacheData(key) = cachedData;
                    
                    data = cachedData.data;
                    raw = cachedData.raw;
                    dateData = cachedData.dateData;
                end
            end
        end
        
        function colsToTrim = getTrimNonNumericCols(this, currVarTypes)
            % Returns the columns that will be set to "TrimNonNumeric".  I went
            % back and forth on the logic for this setting, since it isn't user
            % selectable, but in the end we decided to have it set to true for
            % columns which detectImportOptions did not detect as numeric, but
            % that either the Import Tool's logic to look for prefixes/suffices,
            % or the user has set them to be numeric.
            %
            % currVarTypes can be passed in, or will be taken as the current
            % ImportOptions.VariableTypes property.
            if nargin < 2
                currVarTypes = this.imopts.VariableTypes;
            end
            doubleColumns = cellfun(@(x) x == "double", currVarTypes);
            initialNonDoubleCols = ~cellfun(@(x) x == "double", this.DetectedColumnClasses);

            % It's possible that the current number of colums is different than
            % the originally detected number of columns, because sometimes once
            % we read in the data, additional columns are found.  Any of these
            % newly found columns are considered to be text, so just fill in the
            % non-double columns to be true and the double columns to be false.
            initialNonDoubleCols(end+1:end+(length(doubleColumns)-length(initialNonDoubleCols))) = true;
            
            colsToTrim = doubleColumns & initialNonDoubleCols;
        end
    end
    
    methods(Abstract, Access = protected)
        % Classes which inherit must implement this method
        [data, raw, dateData] = read(this, range, asDatetime);
    end
    
    methods (Access = protected)
        function lhs = getLHS(~, varargin)
            % Unused for text import
            lhs = [];
        end
    end      
end

