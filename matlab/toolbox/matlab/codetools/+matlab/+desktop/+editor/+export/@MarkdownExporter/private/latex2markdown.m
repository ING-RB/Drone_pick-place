function markdown = latex2markdown(latex, latexFilename, varargin)

%--------------------------------------------------------------------------
% latex2markdown converts a LaTeX script to Markdown.
%
% Inputs:
% latex         - a string containing the LaTeX source code.
%                 The string contains the content of the file
%                 'latexFilename'.
% latexFilename - a string containg the name of the LaTeX file.
%                 It must include the absolute path to the file.
% varargin      - Name-value pairs.
%
% Output:
% markdown      - A string containing the Markdown source code
%                 generated from the LaTeX source code.
%
%
% Note:
% latex2markdown is NOT a tool for converting arbitrary LaTeX scripts to
% Markdown files. This tool converts LaTeX scripts generated by
% MATLAB's Live Editor to Markdown.
%
% latex2markdown is based on the contribution from Michio Inoue,
% The MathWorks GK, Japan.
% See https://github.com/minoue-xx/livescript2markdown
%
% This version is a modified implementation of the original implementation
% of latex2markdown - version 1.5.0.
%
% 2 formats for Markdown are available:
% 'github' and 'github_math'.
%
% 'github': GitHub Flavored Markdown (GFM, standard)
% For math equations,
%   "<img src=""https://latex.codecogs.com/svg.latex?...
% is used. Instead of svg.latex, gif.latex or png.latex can also be used.
% SVGs can be rendered fine by web browsers, by the program Typora, and
% on github.com.
%
% https://github.github.com/gfm
%
% 'github-math':
% Since 2022, github can also render math equations given in TeX syntax.
% However, the free versions of Typora and also the Google Chrome plugin
% 'Markdown Viewer' cannot render TeX equations. Therefore, 'github' is
% still the default Markdown format.
%--------------------------------------------------------------------------

%  Copyright 2020-2025 The MathWorks, Inc.

import matlab.desktop.editor.export.ExportUtils

p = inputParser;
addParameter(p, "AcceptHTML"         , true,     @ExportUtils.isLogical            );
addParameter(p, "EmbedImages"        , true,     @ExportUtils.isLogical            );
addParameter(p, "RenderLaTeXOnline"  , "off",    @ExportUtils.isValidCodeCogsValue );
addParameter(p, "MarkdownFormat"     , "github", @ExportUtils.isValidMarkdownFormat);
addParameter(p, "ProgrammingLanguage", "matlab", @ExportUtils.isValidKernel        );
addParameter(p, "ToC"                , true,     @ExportUtils.isLogical            );
addParameter(p, "png2jpeg"           , false,    @ExportUtils.isLogical            );
addParameter(p, "isIPYNB"            , false,    @ExportUtils.isLogical            );
addParameter(p, "HTMLanchors"        , true,     @ExportUtils.isLogical            );

parse(p, varargin{:});
options = p.Results;

str = latex;

% Extract tables
alignments = extractTableAlignments(str);

% Preprocess LaTeX
[str, eqs] = preprocess(str, options);

% Latex filename
[filepath,name] = fileparts(latexFilename);

% Extract body from latex
str = extractBetween(str,"\begin{document}","\end{document}");

% Add a newline after \label{...}
str = regexprep(str,"\\label{([^{}]+)}","\\label{$1}" + newline);

% Remove horizontal line used by section breaks
hline = "\begin{par}" + newline + "\hfill \break" + newline + "\end{par}";
str = erase(str, hline);

% Convert verbatim to preformatted text
verb = extractBetween(str, "\begin{verbatim}", "\end{verbatim}");
newverb = strtrim(verb);
for i=1:numel(verb)
    tmp = strsplit(verb(i), newline);
    tmp = arrayfun(@(s) "    " + s, tmp);
    newverb(i) = strjoin(tmp, newline);
end

if options.AcceptHTML
    str = replace(str, "\begin{verbatim}", "<pre>");
    str = replace(str, "\end{verbatim}", "</pre>");
else
    str = replace(str, "\begin{verbatim}", "```");
    str = replace(str, "\end{verbatim}", "```");
end

%% TableOfContent
% \matlabtitle{...}
% \matlabheading{...}
% \matlabheadingtwo{...}
% \matlabheadingthree{...}
%
% # Table of contents
% - ...
%   - ...
%      - ...

toc = regexp(str,"\\matlabtableofcontents{([^{}]+)}", "match");
toc_title = replace(toc, "\matlabtableofcontents{", "");
toc_title = char(strtrim(toc_title)); toc_title = toc_title(1:end-1);

% Delete strings for literal display from generating ToC
% namely..
% \begin{matlabcode}(code)\end{matlabcode}
% \begin{verbatim}(code)\end{verbatim}
% \begin{matlaboutput}(code)\end{matlaboutput}
tmp = regexprep(str,"\\begin{verbatim}.*?\\end{verbatim}","");
tmp = regexprep(tmp,"\\begin{matlabcode}.*?\\end{matlabcode}","");
tmp = regexprep(tmp,"\\begin{matlaboutput}.*?\\end{matlaboutput}","");

% Generate ToC with hyperlink for markdown
posTitles = strfind(tmp, "\matlabtitle{");

if isempty(posTitles) || isscalar(posTitles)
    toc_md = generateMarkdownToC(tmp, false);
else
    toc_md = string.empty;
    numTitles = numel(posTitles);
    for k=1:numTitles
        cstr = char(tmp);
        if k == numTitles
            tmp1 = cstr(posTitles(k):end);
        else
            tmp1 = cstr(posTitles(k):posTitles(k+1)-1);
        end
        toc_md = [toc_md, generateMarkdownToC(tmp1, true)]; %#ok
    end
end

% Replace Markdown labels in the Table of Content by HTML labels
if options.HTMLanchors
    toc_md = getLabels(str, toc_md);
end

% add ToC title
toc_md = [sprintf("## %s", toc_title), toc_md];

% join the strings
toc_md = join(toc_md,newline);

% Add HTML anchors: Dummy for identifying that this part is a ToC
toc_md = string(sprintf('<!-- Begin Toc -->\n%s\n<!-- End Toc -->\n\n', toc_md));

str = replace(str, toc, toc_md);

%% Devide the body into each environment
% Preprocess 1:
% Add 'newline' to the end of the following.
% \end{lstlisting}, \end{verbatim}, \end{matlabcode}, \end{matlaboutput},\end{center}
% \end{matlabtableoutput}, \end{matlabsymbolicoutput}  \vspace{1em}
str = replace(str,"\end{lstlisting}"+newline,"\end{lstlisting}"+newline+newline);
str = replace(str,"\end{verbatim}"+newline,"\end{verbatim}"+newline+newline);
str = replace(str,"\end{matlabcode}"+newline,"\end{matlabcode}"+newline+newline);
str = replace(str,"\end{matlaboutput}"+newline,"\end{matlaboutput}"+newline+newline);
str = replace(str,"\end{matlabtableoutput}"+newline,"\end{matlabtableoutput}"+newline+newline);
str = replace(str,"\end{matlabsymbolicoutput}"+newline,"\end{matlabsymbolicoutput}"+newline+newline);
str = replace(str,"\end{center}"+newline,"\end{center}"+newline+newline);
str = replace(str,"\vspace{1em}"+newline,"\vspace{1em}"+newline+newline);
str = replace(str,"!!!ENDCENTER!!!"+newline,"!!!ENDCENTER!!!"+newline+newline);
str = replace(str,"```"+newline+"\begin{matlaboutput}","```"+newline+newline+"\begin{matlaboutput}");

% Preprocess 2:
% Replace more than three \n to \n\n.
str = regexprep(str,'\n{3,}','\n\n');
% Devide them into parts by '\n\n'
str = strsplit(str,'\n\n')';

%% Let's convert latex to markdown
% 1: Process parts that require literal output.
[str, idxLiteral] = processLiteralOutput(str, options);

% 2: Process that other parts
str2md = str(~idxLiteral);
str2md = processDocumentOutput(str2md,options);

% Preprocess Equations
str2md = preprocessEquations(str2md, eqs);

% Equations
str2md = processEquations(str2md, options);

% includegraphics
str2md = processincludegraphics(str2md, name, filepath, options);

% Apply vertical/horizontal space
% markdown: two spaces for linebreak
% latex: \vspace{1em}
% latex: \hskip1em
str2md = regexprep(str2md,"\\vspace{1em}", "");
str2md = regexprep(str2md,"\\hskip1em", "");
str(~idxLiteral) = str2md;

%% Nearly done! Merge them together
markdown = join(str,newline);

%% tabular environment
% Note: 2-10: table output must be processed before processing tabular.
%
% \begin{tabular}
%
% \end{tabular}
tblOrig = extractBetween(markdown, "```TableOutput", "```");
tbl = replace(tblOrig, "\begin{tabular}", "$\begin{array}");
tbl = replace(tbl, "\end{tabular}", "\end{array}$");
markdown = replace(markdown, tblOrig, tbl);

tabulars = extractBetween(markdown, "\begin{tabular}", "end{tabular}", "Boundaries", "inclusive");
for k=1:numel(tabulars)
    markdown = latexTabular2Markdown(markdown, alignments{k}, tabulars{k}, options);
end

%% Postprocessing
markdown = postprocess(markdown, options);

end

function str2md = processDocumentOutput(str2md,options)

%% 2-1: Fix latex conventions for non-literal parts
% ^ (live script) -> \textasciicircum{} (latex)
str2md = replace(str2md,"\textasciicircum{}","^");
% ~ (live script) -> \\textasciitilde{} (latex)
str2md = replace(str2md,"\textasciitilde{}","~");
% Decimal 65374 in hex is ff5e. And this unicode character is often used
% in Japanese for ~ (decimal 126, hex 7e). Convert unicode character
% 65374 to standard ASCII character 126.
str2md = replace(str2md,char(65374),"~");
% _ (live script) -> \_ (latex) example: test_case -> test\_ case
str2md = replace(str2md,"\_","_");
% / backslash (live script) -> \textbackslash{} (latex)
str2md = replace(str2md,"\textbackslash{}","!!!BACKSLASH!!!");
% > (live script) -> \textgreater{} (latex)
str2md = replace(str2md,"\textgreater{}",">");
% < (live script) -> \textless{} (latex)
str2md = replace(str2md,"\textless{}","<");
% $ (live script) -> \$ (latex)
str2md = replace(str2md,"\$","$");
% % (live script) -> \% (latex)
str2md = replace(str2md,"\%","%");
% Replace LaTeX encode characters to Markdown characters
str2md = replace(str2md, ["\#", "\&"], ["#", "&"]);

% These will be left as they are till the end of this function
% since these affect the markdown format
% { (live script) -> \} (latex) (leave it till end)
% } (live script) -> \{ (latex) (leave it till end)

% To deal with \{ and \} inside other commands, it's easier to
% make regular expression if we change these to letters. (will change it back later)
str2md = replace(str2md,"\{", "BackslashCurlyBlacketOpen");
str2md = replace(str2md,"\}", "BackslashCurlyBlacketClose");

%% 2-2: Text decoration
% \textbf{bold}
% \textit{italic}
% \underline{underline}
% \texttt{equispace}
% and all the possible conbinations of these four.

for k=1:numel(str2md)
    str2md(k) = replacetexttt(str2md(k));
    str2md(k) = replaceTeX(str2md(k), "\textbf", "**", "**");
    str2md(k) = replaceTeX(str2md(k), "\textit", "*", "*");
    if options.AcceptHTML
        % Use HTML tags <u> ... </u>
        str2md(k) = replaceTeX(str2md(k), "\underline", "<u>", "</u>");
    else
        % Ignore underline
        str2md(k) = replaceTeX(str2md(k), "\underline", "", "");
    end
end

%% 2-3: Hyperlinks
% Markdown: [string](http://xxx.com)
% latex: \href{http://xxx.com}{string}

for i=1:numel(str2md)
    hrefs = extractBetween(str2md(i), "\href{", "}");
    for j=1:numel(hrefs)
        href = hrefs(j);
        if contains(href, "&")
            ref = replace(href, "&", "!!!AMPERSAND!!!");
            str2md = replace(str2md, href, ref);
            href = ref;
        end
        if ~(startsWith(href, "http") || startsWith(href, "#"))
            newhref = "\href{" + replace(href, "\", "/") + "}";
            str2md = replace(str2md, "\href{" + href + "}", newhref);
        end
        % If a filename contains unsafe characters, the filename must
        % be enclosed in < ... > .
        unsafe = [" ", "#", "{", "}", "^", "[", "]", "`", "~"];
        if contains(href, unsafe)
            str2md = replace(str2md, href, "<" + href + ">");
        end
    end
end

% Special case for local videos
str2md = replace(str2md, "\href{run:", "\href{");
str2md = replace(str2md, "\href{<run:", "\href{<");

str2md = regexprep(str2md,"\\href{([^{}]+)}{([^{}]+)}","[$2]($1)");

str2md = monospacedHyperlinks(str2md);

% Internal Hyperlinks
if options.HTMLanchors
    str2md = regexprep(str2md,"\\hyperref\[([^{}]+)\]{([^{}]+)}","[$2](#$1)");
    str2md = regexprep(str2md,"\\hyperref{([^{}]+)}{([^{}]+)}","[$2](#$1)");
    str2md = regexprep(str2md,"\\label{([^{}]+)}","<a id=""$1\""></a>");
else
    str2md = regexprep(str2md,"\\hyperref\[([^{}]+)\]{([^{}]+)}","$2");
    str2md = regexprep(str2md,"\\hyperref{([^{}]+)}{([^{}]+)}","$2");
    str2md = regexprep(str2md,"\\label{([^{}]+)}","");
end

%% 2-4: Title and headings
if options.AcceptHTML
    coloredtitle = "# <span style=""color:rgb(213,80,0)"">$1</span>";
    str2md = regexprep(str2md,"\\matlabtitle{([^{}]+)}", coloredtitle);
    if options.RenderLaTeXOnline == "off"
        % If a title contains TeX, we cannot use HTML for coloring the title.
        % Otherwise, we would get the TeX code in the title.
        titlecolor = '<span style="color:rgb(213,80,0)">';
        for k=1:numel(str2md)
            titles = extractBetween(str2md(k), ...
                "# " + titlecolor, "</span>", "Boundaries", "inclusive");
            for j=1:numel(titles)
                title = titles(j);
                if contains(title, "!!!EQ_")
                    newtitle = erase(title, titlecolor);
                    newtitle = erase(newtitle, "</span>");
                    str2md(k) = replace(str2md(k), title, newtitle);
                end
            end
        end
    end
else
    str2md = regexprep(str2md,"\\matlabtitle{([^{}]+)}","# $1");
end
if options.isIPYNB
    % In Jupyter Notebooks, heading2, heading3, heading4 and
    % normal text can be clearly distinguished. At least when
    % using Visual Studio Code. Therefore we do the following mapping
    % matlabtitle        -> #
    % matlabheading      -> ##
    % matlabheadingtwo   -> ###
    % matlabheadingthree -> ####
    str2md = regexprep(str2md,"\\matlabheading{([^{}]+)}","## $1");
    str2md = regexprep(str2md,"\\matlabheadingtwo{([^{}]+)}","### $1");
    str2md = regexprep(str2md,"\\matlabheadingthree{([^{}]+)}","#### $1");
else
    % In Markdown, it is hard to distinguished between heading3, heading4
    % and normal text. At least when using Visual Studio Code.
    % Therefore we do the following mapping
    % matlabtitle        -> #
    % matlabheading      -> #
    % matlabheadingtwo   -> ##
    % matlabheadingthree -> ###
    str2md = regexprep(str2md,"\\matlabheading{([^{}]+)}","# $1");
    str2md = regexprep(str2md,"\\matlabheadingtwo{([^{}]+)}","## $1");
    str2md = regexprep(str2md,"\\matlabheadingthree{([^{}]+)}","### $1");
end

% Put \{ and \} back.
str2md = replace(str2md,"BackslashCurlyBlacketOpen","\{");
str2md = replace(str2md, "BackslashCurlyBlacketClose","\}");


%% 2-5: Delete unnecessary commands
% Commands to specify the text position
str2md = erase(str2md,"\begin{flushleft}");
str2md = erase(str2md,"\end{flushleft}");
str2md = erase(str2md,"\begin{flushright}");
str2md = erase(str2md,"\end{flushright}");
str2md = erase(str2md,"\begin{center}");
str2md = erase(str2md,"\end{center}");

%% 2-6: Quotation
% Latex:
% \begin{par}
% \begin{center}
% xxxx
% \end{center}
% \end{par}
% Note: \includegraphics is an exception
idxNonGraphics = ~contains(str2md,"\includegraphics");
str2md(idxNonGraphics) = replace(str2md(idxNonGraphics),...
    "\begin{par}"+newline+"\begin{center}"+newline,"> ");

%% 2-7: Unordered list
% markdown: add - to each item
% latex:
%      \begin{itemize}
%      \setlength{\itemsep}{-1ex}
%         \item{\begin{flushleft} ... \end{flushleft}}
%         \item{\begin{flushleft} ... \end{flushleft}}
%         \item{\begin{flushleft} ... \end{flushleft}}
%      \end{itemize}

str2md = LaTeXList2Markdown(str2md, "itemize");

%% 2-8: Ordered list
% markdown: 1. itemname
% latex:
%      \begin{enumerate}
%      \setlength{\itemsep}{-1ex}
%         \item{\begin{flushleft} ... \end{flushleft}}
%         \item{\begin{flushleft} ... \end{flushleft}}
%         \item{\begin{flushleft} ... \end{flushleft}}
%      \end{enumerate}

str2md = LaTeXList2Markdown(str2md, "enumerate");

%% 2-9: Symbolic output
% markdown: inline equation
% latex:
% \begin{matlabsymbolicoutput}
% ans =
%     $\displaystyle -\cos \left(x\right)$
% \end{matlabsymbolicoutput}
%
% and
%
% \begin{matlabsymbolicoutput}
% a =
%     $\displaystyle \left(\begin{array}{cccc}
% \cos \left(\theta \right) & -\sin \left(\theta \right) & 0 & 0\\
% \sin \left(\theta \right) & \cos \left(\theta \right) & 0 & 0\\
% 0 & 0 & 1 & 0\\
% 0 & 0 & 0 & 1
% \end{array}\right)$
% \end{matlabsymbolicoutput}

symoutIdx = contains(str2md,["\begin{matlabsymbolicoutput}","\end{matlabsymbolicoutput}"]);
symoutParts = str2md(symoutIdx);
if options.isIPYNB
    tmp = replace(symoutParts,"\begin{matlabsymbolicoutput}", "```SymbolicOutput");
    partsMarkdown = replace(tmp,"\end{matlabsymbolicoutput}","```");
else
    tmp = erase(symoutParts,"\begin{matlabsymbolicoutput}"+newline);
    tmp = replace(tmp,"$\displaystyle","$$");
    partsMarkdown = replace(tmp,"$"+newline+"\end{matlabsymbolicoutput}","$$");
end
str2md(symoutIdx) = partsMarkdown;
% NOTE: This part will be processed by processEquations.m

%% 2-10: table output
% markdown:
% | TH left | TH center | TH right |
% | :--- | :---: | ---: |
% | TD | TD | TD |
% | TD | TD | TD |
% latex:
% \begin{matlabtableoutput}
% {
% \begin{tabular} {|l|c|r|}\hline
% \mlcell{TD} & \mlcell{TD} & \mlcell{TD} \\ \hline
% \mlcell{TD} & \mlcell{TD} & \mlcell{TD} \\
% \hline
% \end{tabular}
% }
% \end{matlabtableoutput}

idxTblOutput = startsWith(str2md,"\begin{matlabtableoutput}"+newline);
tableLatex = extractBetween(str2md(idxTblOutput),...
    "\begin{tabular}","\end{tabular}");
tableMD = strings(sum(idxTblOutput),1);
for ii=1:sum(idxTblOutput)
    tablecontents = split(tableLatex(ii),"\hline");
    formatLatex = tablecontents(1); % {|l|c|r|}
    headerLatex = tablecontents(2); % \mlcell{TD} & \mlcell{TD} & \mlcell{TD} \\ \hline
    bodyLatex = tablecontents(3:end); % and the rest.

    format = regexp(formatLatex,"\{([^{}]+)}",'tokens');
    format = format{:};
    format = replace(format, "c",":--:");
    format = replace(format, "l",":--");
    format = replace(format, "r","--:");

    % MultiColumn is not standard in markdown.
    % It only happens as a variable name in MATLAB
    % so adding special case for processing headerLatex
    tmp = regexp(headerLatex,"\\mlcell{(.|\s)*?}* (?:&|\\\\)",'tokens');
    if ~contains(headerLatex, '\multicolumn')
        header = "|" + join([tmp{:}],"|") + "|";
    else
        % Need to get grouped columns per header (We can have combinations
        % of grouped and ungrouped columns)
        headers = strsplit(headerLatex, ' & ');
        multicols = regexp(headers,"\\multicolumn{(\d)+}",'tokens');
        empties = cellfun(@isempty, multicols);
        multicols(empties) = {1};
        nRepeat = double(string(multicols));
        header = "|";
        for i=1:length(tmp)
            header = header + join(tmp{i},"|") + join(repmat("|",1,nRepeat(i)));
        end
    end
    header = replace(header, "multicolumn}", "multicolumn");

    body = string;
    for jj=1:length(bodyLatex)
        tmp = regexp(bodyLatex(jj),"\\mlcell{(.|\s)*?} (?:&|\\\\)",'tokens');
        if isempty(tmp)
            break;
        end

        % Adding escape to text that affects markdown table (\n and |)
        tmp = cellfun(@(str1) replace(str1,"|","\|"), tmp, 'UniformOutput', false);
        tmp = cellfun(@(str1) replace(str1,newline,"<br>"), tmp, 'UniformOutput', false);
        body = body + "|" + join([tmp{:}],"|") + "|" + newline;
    end

    tableMD(ii) = strjoin([header,format,body],newline);
    tableMD(ii) = tableMD(ii) + newline;


end

tableMD = newline + "!!!BEGINTABLEOUTPUT!!!" + newline + newline + ...
          tableMD + newline + "!!!ENDTABLEOUTPUT!!!" + newline;

str2md(idxTblOutput) = tableMD;

%% finish up
str2md = replace(str2md,"\{","{");
str2md = replace(str2md,"\}","}");

end

function str2md = processEquations(str2md, options)
% For Github users:
% format = 'github'
% Uses https://latex.codecogs.com
%
% format = 'github_math'
% Use GitHub capability to display equations (first version became
% available in May 2022)
% Leave inline equation as it is and $$equation$$ will be changed to
% $$
% equation
% $$

str2md = replace(str2md, " $$   $$ ", " ");

str2md = GitHubcompatible(str2md);

switch options.MarkdownFormat
    case 'github_math'
        str2md = regexprep(str2md,"[^`]?\$\$([^$]+)\$\$[^`]?", ...
                           newline+"$$" + newline + "$1" + newline + "$$");
        str2md = replace(str2md, "$$" + newline + " ", "$$" + newline);
        str2md = replace(str2md, " " + newline + "$$", newline + "$$");
    case 'github'
        if options.RenderLaTeXOnline == "off"
            return;
        elseif ~options.AcceptHTML
            Warning("CannotUseOnlineLaTeX");
            return;
        else
            % "png", "jpeg", "svg"
            iformat = options.RenderLaTeXOnline;
        end
        str2md = replace(str2md, [" $$", "$$ "], ["$$", "$$"]);
        tt = regexp(str2md,"[^`]?\$\$([^$]+)\$\$[^`]?", 'tokens');
        idx = cellfun(@iscell,tt);
        % if tt contains 0x0 string, horzcat(tt{:}) generates string vector
        % whereas if tt with cell only, horzcat(tt{:}) generates cell
        % vector... so.
        parts = horzcat(tt{idx});
        for ii=1:length(parts)
            eqncode = replace(parts{ii},string(newline)," ");
            eqncode = replace(strtrim(eqncode)," ", "&space;");
            partsMD = sprintf("<center><img src=""https://latex.codecogs.com/%s.latex?%s""/></center>", iformat, eqncode);
            str2md = replace(str2md, "$$"+parts(ii)+"$$", partsMD + newline);
        end
        str2md = replace(str2md, newline + " " + newline, [newline, newline]);

        % Inline
        tt = regexp(str2md,"[^`$]\$([^$]+)\$[^`$]", 'tokens');
        parts = horzcat(tt{:});
        for ii=1:length(parts)
            pii = parts(ii); if iscell(pii); pii = pii{1}; end
            eqncode = replace(pii," ", "&space;");
            partsMD = sprintf("<img src=""https://latex.codecogs.com/%s.latex?\\inline&space;%s"">", iformat, eqncode);
            str2md = replace(str2md, "$"+pii+"$", partsMD);
        end
end

end

function [str, idxLiteral] = processLiteralOutput(str, options)

%% MATLAB Code
% Latex:
% \begin{matlabcode}(code)\end{matlabcode}
% \begin{verbatim}(code)\end{verbatim}
% \begin{lstlisting}(code)\end{lstlisting}
%
% Markdown
% ```matlab:MATLAB Code
% （code）
%```
%% Literal Outputs
% Latex:
% \begin{matlaboutput}(output)\end{matlaboutput}
%
% Markdown
% ```text:Output
%  (output)
% ```
% Note: Other outputs (matlabsymbolicoutout, matlabtableoutput)
% will be processed in processDocumentOutput.m

kernelLanguage = options.ProgrammingLanguage;

idx_lstlisting = startsWith(str,"\begin{lstlisting}");
idx_verbatim = startsWith(str,"\begin{verbatim}");
idx_matlabcode = startsWith(str,"\begin{matlabcode}");
idx_matlaboutput = startsWith(str,"\begin{matlaboutput}");

if options.isIPYNB
    idx_matlabtableoutput = startsWith(str,"\begin{matlabtableoutput}");
    idxLiteral = idx_lstlisting | idx_verbatim | idx_matlabcode | ...
        idx_matlaboutput | idx_matlabtableoutput;
    tableHeader    = "```TableOutput";
else
    idxLiteral = idx_lstlisting | idx_verbatim | idx_matlabcode | ...
                 idx_matlaboutput;
end

codeHeader    = sprintf("```%s", kernelLanguage);
displayHeader = sprintf("```%s:CodeListing", kernelLanguage);
textHeader    = "```matlabTextOutput";

str(idx_lstlisting) = newline + displayHeader + extractBetween(str(idx_lstlisting),...
    "\begin{lstlisting}","\end{lstlisting}") + "```" + newline;
str(idx_matlabcode) = newline + codeHeader + extractBetween(str(idx_matlabcode),...
    "\begin{matlabcode}","\end{matlabcode}") + "```" + newline;
str(idx_matlaboutput) = newline + textHeader + extractBetween(str(idx_matlaboutput),...
    "\begin{matlaboutput}","\end{matlaboutput}") + "```" + newline;

if options.isIPYNB
    str(idx_matlabtableoutput) = newline + tableHeader + extractBetween(str(idx_matlabtableoutput),...
        "\begin{matlabtableoutput}","\end{matlabtableoutput}") + "```" + newline;
    str = replace(str, "{" + newline + "\begin{tabular}", "$\begin{array}");
    str = replace(str, "\end{tabular}" + newline + "}", "\end{array}$");
    str = replace(str, "\mlcell", "\text");
end

end

function str = processincludegraphics(str,filename,filepath,options)

% Note: There are two cases in the tex
% 1: inserted image: \includegraphics[width=\maxwidth{64.52584044154541em}]{image_0}
% 2: generated figure: \includegraphics[width=\maxwidth{52.78474661314601em}]{figure_0.png}
%
% Inserted images needs to

% markdown (GitHub): ![string]('path to a image')
% latex: \includegraphics[width=\maxwidth{56.196688409433015em}]{filename}

imageIdx = contains(str,"\includegraphics");
imageParts = str(imageIdx);

% When exported latex from live script, figures and inserted images
% are saved in 'imagedir' as image files.
imagedir = filename + "_media/";
imagedir = strrep(imagedir, '\', '/');

% for each images
for ii=1:length(imageParts)
    fileid = regexp(imageParts(ii),"\\includegraphics\[[^\]]+\]{([^{}]+)}", "tokens");
    width = extractBetween(imageParts(ii), "\includegraphics[width=\maxwidth{", "}");
    for jj=1:length(fileid)
        [~,fileid_wo_ext,~] = fileparts(fileid{jj});
        imagefilename = ls(fullfile(filepath,imagedir,fileid_wo_ext + ".*")); % get the actual filename with extention

        if ischar(imagefilename) && contains(filepath, " ") && ...
           startsWith(imagefilename, "'") && endsWith(imagefilename, "'" + newline)
            imagefilename = imagefilename(2:end-2);
        end

        [~,imagefilename,ext] = fileparts(string(imagefilename));
        imagefilename = imagefilename + ext;
        % Compress PNG images as JPEG
        if options.png2jpeg
            [~,imagefilename_wo_ext,ext] = fileparts(imagefilename);
            if strcmp(ext,'.png')
                png = fullfile(filepath,imagedir,imagefilename);
                I = imread(png);
                imagefilename = imagefilename_wo_ext + ".jpg";
                imwrite(I,fullfile(filepath,imagedir,imagefilename),'Quality',85);
                delete(png);
            end
        end

        if options.isIPYNB && contains(imageParts(ii), "```FigureOutput")
            images = extractBetween(imageParts(ii), "!!!BEGINCENTER!!!", "!!!ENDCENTER!!!");
            for k=1:numel(images)
                image = strtrim(images{k});
                if startsWith(image, "\includegraphics")
                    old = ['!!!BEGINCENTER!!!', images{k}, '!!!ENDCENTER!!!'];
                    new = ['```FigureOutput', images{k}, '```'];
                    imageParts(ii) = replace(imageParts(ii), old, new);
                end
            end
        end

        %  ![string]('path to a image')
        imageParts(ii) = ...
            regexprep(imageParts(ii), ...
            "\\includegraphics\[[^\]]+\]{"+fileid{jj}+"}",...
            "!["+imagefilename+"]("+imagedir+imagefilename+",width="+width(jj)+")");
    end
end

str(imageIdx) = imageParts;

str = processFigureOutputs(str);

end

%-----------------------------------------------------------------------

function newtoc = getLabels(tex, toc)
lines = strsplit(tex, newline);
n = numel(lines); k = 1; label = ""; newtoc = toc;
while k <= n
    line = lines(k);
    if startsWith(line, "\label")
        label = extractContent(line);
    elseif startsWith(line, ["\matlabheading", "\matlabtitle"])
        heading = strtrim(extractContent(line));
        if ~strcmp(label, "")
            entries = strtrim(toc(contains(toc, heading)));
            if ~isempty(entries)
                m = 1;
                while m <= numel(entries)
                    entry = entries(m);
                    p = strfind(entry, "]("); p = p(1);
                    if iscell(p); p = p{1}; end
                    entry = char(entry); entry = entry(p+2:end-1);
                    if ~isempty(entry); break; else; m = m + 1; end
                end
                newtoc = replaceFirst(newtoc, entry, "#" + label);
                toc =  replaceFirst(toc, entry, "");
                label = "";
            end
        end
    end
    k = k + 1;
end
end

function str = replaceFirst(str, old, new)
str = char(strjoin(str, newline));
index   = strfind(str, old);
if ~isempty(index)
    first   = index(1);
    str = str(1:first - 1) + new + str(first + length(old):end);
end
str = strsplit(str, newline);
end

function content = extractContent(line)
line = char(line);
a = strfind(line, "{");
b = strfind(reverse(line), "}");
content = line(a(1)+1:end-b(1));
end

function str = preprocessStyle(str, cmd)
bf = extractBetweenBraces(str, cmd);
for k=1:numel(bf)
    text = char(bf{k}); texttrimed = strtrim(text);
    oldbf = cmd + "{" + bf{k} + "}";
    if strcmp(texttrimed, "") || isempty(texttrimed)
        str = replace(str, oldbf, " ");
        continue;
    end
    if ~strcmp(bf{k}, texttrimed)
        newbf = " " + cmd + "{" + texttrimed + "}" + " ";
        str = replace(str, oldbf, newbf);
    end
end
end

function [str, eqs, MLcode] = preprocess(str, options)
%------------------------------------------------------------------------
% The order of the preprocessing steps is important!
%------------------------------------------------------------------------
str = escapeSpecialCharacters(str);
%------------------------------------------------------------------------
str = replace(str, "\$", "!!!DOLLAR!!!");
%------------------------------------------------------------------------
code = extractBetween(str, "\begin{matlabcode}", "\end{matlabcode}", "Boundaries", "inclusive");
newcode = replace(code, [newline,newline], [newline, '% !!!INSERTNL!!!', newline]);
newcode = replace(newcode, "$", "<DOLLORSIGN>");
str = replace(str, code, newcode);
verb = extractBetween(str, "\begin{verbatim}", "\end{verbatim}", "Boundaries", "inclusive");
newverb = replace(verb, [newline,newline], [newline, '% !!!INSERTNL!!!', newline]);
newverb = replace(newverb, "$", "<DOLLORSIGN>");
str = replace(str, verb, newverb);
listing = extractBetween(str, "\begin{lstlisting}", "\end{lstlisting}", "Boundaries", "inclusive");
newlisting = replace(listing, [newline,newline], [newline, '% !!!INSERTNL!!!', newline]);
str = replace(str, listing, newlisting);
output = extractBetween(str, "\begin{matlaboutput}", "\end{matlaboutput}", "Boundaries", "inclusive");
newoutput = replace(output, [newline,newline], [newline, '% !!!INSERTNL!!!', newline]);
newoutput = replace(newoutput, "$", "<DOLLORSIGN>");
str = replace(str, output, newoutput);
%------------------------------------------------------------------------
% Remove line breaks between \begin{array} and \end{array}
array = extractBetween(str, "\begin{array}", "\end{array}", ...
                            "Boundaries", "inclusive");
newarray = replace(array, newline, " ");
% Note: Replacing \\ by \newline is needed because of a bug in MathJax
% which is used by GitHub. Even if \newline does not comply with the
% TeX specification, VS Code and GitHub accept it. And VS Code and GitHub
% are the most important tools so we have to support them.
% As soon as the bug in MathJax is fixed, the following code line should
% be removed.
newarray = replace(newarray, "\\", "\newline");
str = replace(str, array, newarray);
%------------------------------------------------------------------------
% Replace tabular characters (tabs) with 4 spaces.
% In Jupyter, tabs are causing an error (Invalid JSON).
str = replace(str, char(9), "    ");
%------------------------------------------------------------------------
str = strsplit(str, newline);
%------------------------------------------------------------------------
% The LaTeX exporter can generate something like
% $ ... $$ ... $
% Several TeX systems like KaTeX, which is integrated in
% Visual Studio Code, cannot parse this correctly.
% The meaning of $ ... $$ ... $ can either be
% $ ... ... $ or $ ... $ $ ... $. We haven choosen the last one.
for k=1:numel(str)
    if (isscalar(strfind(str(k), "$$")) || ...
        all(~strcmp(extractBetween(str(k), "$", "$"), "")))
        str(k) = replace(str(k), "$$", "$ $");
        str(k) = replace(str(k), "$", " $ ");
    end
end
%------------------------------------------------------------------------
% The LaTeX exporter can generate a line with at least 4 trailing spaces
% or a tabular character. In Markdown, this is code. Therefore, 4 and more
% trailing spaces or a tab are replaced with non-breaking spaces.
inCode = false; nbsp = char(160); sp = "    ";
for k=1:numel(str)
    line = char(str(k)); Line = "";
    if startOfCode(line)
        inCode = true; continue;
    elseif endOfCode(line)
        inCode = false;
    elseif ~inCode && ...
           startsWith(line, [sp, nbsp + sp]) && ~isempty(erase(line, ' '))
        i = 1;
        while line(i) == ' ' || line(i) == nbsp
            Line = Line + "&nbsp;"; i = i + 1;
        end
        str(k) = Line + " " + line(i:end);
    end
end
%------------------------------------------------------------------------
str = strjoin(str, newline);
%------------------------------------------------------------------------
eqs = extractBetween(str, "$", "$", "Boundaries", "inclusive");
neweqs = erase(eqs, newline);
str = replace(str, eqs, neweqs);
%------------------------------------------------------------------------
% Insert line breaks if a symbolic output region contains more than
% one output. The line break is marked with the placeholder
% !!!SPLITOUTPUT!!! which is replaced with a real line break later on.
%------------------------------------------------------------------------
symbolic = extractBetween(str, ...
    "\begin{matlabsymbolicoutput}", "\end{matlabsymbolicoutput}" ...
);
for k=1:numel(symbolic)
    eqs = extractBetween(symbolic(k), "$", "$", "Boundaries", "inclusive");

    neweqs = eqs + "!!!SPLITOUTPUT!!!";
    newsymbolic = replace(symbolic(k), eqs, neweqs);
    str = replace(str, symbolic(k), newsymbolic);
end
%------------------------------------------------------------------------
% Replace Equations by Placeholders, if they appear outside MATLAB code.
% Reason: regexp and regexprep can fail if specific characters are
% part of the text. Such characters are interpreted as metacharacters
% and they typically appear in equations.
%------------------------------------------------------------------------
tmp = eraseBetween(str, "\begin{matlabcode}", "\end{matlabcode}");
eqs = extractBetween(tmp, "$", "$", "Boundaries", "inclusive");
for k=1:numel(eqs)
    str = replace(str, eqs(k), "!!!EQ_" + num2str(k) + "!!!");
end
%------------------------------------------------------------------------
% Preprocess text in \textbf{text}, \textit{text}, and \texttt{text}
% Reason: If text has leading or trailing blanks, such blanks need a
% special treatment. Otherwise, Markdown is generated which several
% Markdown Viewers or Markdown Editors cannot render correctly.
str = preprocessStyle(str, "\textbf");
str = preprocessStyle(str, "\textit");
str = preprocessStyle(str, "\texttt");
%------------------------------------------------------------------------
% Preprocess \begin{matlabtableoutput} ... \end{matlabtableoutput}
% Reason: Such an environment can include multiple
% \begin{tabular} ... \end{tabular}.
% In such a case, split the matlabtableoutput environment in multiple
% matlabtableoutput environments, so that each matlabtableoutput
% environment has just a single tabular environment.
startOut = "\begin{matlabtableoutput}"; startTbl = "\begin{tabular}";
endOut   = "\end{matlabtableoutput}";   endTbl   = "\end{tabular}";
nl = newline;
MLcode = extractBetween(str, startOut, endOut, "Boundaries","inclusive");
for j=1:numel(MLcode)
    tbl = extractBetween(MLcode(j), startTbl, endTbl, "Boundaries", "inclusive");
    if isscalar(tbl)
        continue;
    end
    newMLcode = "";
    for k=1:numel(tbl)
        newMLcode = newMLcode + nl + startOut + nl + tbl(k) + nl + endOut +nl;
    end
    str = replace(str, MLcode(j), newMLcode);
end
%------------------------------------------------------------------------
% Preprocess lists.
% Reason: An empty item must be replaced with a non-empty list.
str = replace(str, "\item" + newline, "\item{ }" + newline);
%------------------------------------------------------------------------

if options.AcceptHTML
    str = replaceAlign(str, "center");
    str = replaceAlign(str, "right" );
    str = replaceAlign(str, "left"  );
end

str = replace(str, "\begin{matlaboutput}", ...
                   newline + "!!!BEGINOUTPUT!!!" + newline + ...
                   newline + "\begin{matlaboutput}");
str = replace(str, "\end{matlaboutput}", ...
                   "\end{matlaboutput}" + newline + newline + ...
                   "!!!ENDOUTPUT!!!" + newline + newline);
end

%------------------------------------------------------------------------

function str2md = preprocessEquations(str2md, eqs)
%------------------------------------------------------------------------
% Insert back equations and add a space before and after the equation
%------------------------------------------------------------------------
for k=numel(eqs):-1:1
    str2md = replace(str2md, "!!!EQ_" + num2str(k) + "!!!", " " + eqs(k) + " ");
end
end

%------------------------------------------------------------------------

function str2md = postprocess(str2md, options)
% Need to do some postprocessing
str2md = erase(str2md,"\begin{par}");
str2md = erase(str2md,"\end{par}");

str2md = replace(str2md,"\begin{matlabcode}","```" + options.ProgrammingLanguage);
str2md = replace(str2md,"\end{matlabcode}","```" + newline);

str2md = replace(str2md,"\end{matlabsymbolicoutput}","");

str2md = replace(str2md,"!!!SPLITOUTPUT!!!", newline);
str2md = replace(str2md, "% !!!INSERTNL!!!", newline);

str2md = erase(str2md, sprintf("```matlab\n\n\n```"));

str2md = erase(str2md, "!!!BEGINCENTER!!!");
str2md = replace(str2md, "!!!ENDCENTER!!!", newline);

str2md = replace(str2md, "$ $", "!!!2DOLLARS!!!");
str2md = replace(str2md, " $ ", "$");
str2md = replace(str2md, "!!!2DOLLARS!!!", "$ $");

str2md = replace(str2md, "\degree", "°");

str2md = replace(str2md, "!!!BACKSLASH!!!", "\\");

str2md = replace(str2md, "!!!AMPERSAND!!!", "&");

str2md = imageReferenceAsHTML(str2md, options);
str2md = alignImages(str2md, options);
str2md = postprocessLists(str2md);

str2md = postprocessHeadings(str2md, "\matlabtitle", options);
str2md = postprocessHeadings(str2md, "\matlabheading", options);
str2md = postprocessHeadings(str2md, "\matlabheadingtwo", options);
str2md = postprocessHeadings(str2md, "\matlabheadingthree", options);

if ~strcmp(options.RenderLaTeXOnline, "off")
    tex = extractBetween(str2md, "$$", "$$");
    for k=1:numel(tex)
        eqncode = replace(strtrim(tex{k}), string(newline)," ");
        eqncode = replace(eqncode ," ", "&space;");
        codecogs = "<img src=""https://latex.codecogs.com/";
        partsMD = sprintf("<center>%s%s.latex?%s""/></center>", ...
                          codecogs, options.RenderLaTeXOnline, eqncode);
        str2md = replace(str2md, "$$"+tex(k)+"$$", partsMD + newline);
    end
end

str2md = char(str2md); md = str2md;
p = strfind(str2md, "\href{");
for k=1:numel(p)
    a = p(k)+6; b = a;
    while str2md(b) ~= '}'; b = b + 1; end; b = b - 1;
    url = str2md(a:b);
    a = b + 3; b = a;
    while str2md(b) ~= '}'; b = b + 1; end; b = b - 1;
    text = str2md(a:b);
    mdlink = sprintf("[%s](%s)", text, url);
    md = replace(md, str2md(p(k):b+1), mdlink);
end
str2md = md;

arrays = extractBetween(str2md, "\begin{array}", "\end{array}");
for k=1:numel(arrays)
    array = arrays{k};
    color = extractBetween(array, "\cellcolor", "}", "Boundaries", "inclusive");
    array = erase(array, color);
    str2md = replace(str2md, arrays{k}, array);
end

str2md = string(str2md);
lines = strsplit(str2md, newline, "CollapseDelimiters", false);
skip = false;
for k=2:numel(lines)
    line = lines(k);
    if startsWith(line, "```")
        skip = ~skip;
    elseif ~skip && startsWith(lines(k), "#") && ~strcmp(strtrim(lines(k-1)), "")
        str2md = replace(str2md, lines(k), newline + lines(k));
    end
end

toclines = extractBetween(str2md, "[[", ")](", "Boundaries", "inclusive");
for k=1:numel(toclines)
    tline = char(toclines(k));
    line = extractBetween(tline, "[[", "]"); line = line(1);
    str2md = replace(str2md, tline, "[" + line + "](");
end
md = char(str2md); pos = strfind(md, "](#dummylink)");
for k=1:numel(pos)
    b = pos(k); a = b-1;
    while md(a) ~= "["; a = a - 1; end
    line = md(a:b+12);
    str2md = replace(str2md, line, line(2:end-13));
end

specialChars = ["*", "_", "#", "[", "]", ">", "-"];
maskedChars  = "\" + specialChars;
mono = extractBetween(str2md, "`", "`", "Boundaries", "inclusive");
newmono = replace(mono, maskedChars, specialChars);
str2md = replace(str2md, mono, newmono);
mono = extractBetween(str2md, "<samp>", "</samp>", "Boundaries", "inclusive");
newmono = replace(mono, maskedChars, specialChars);
str2md = replace(str2md, mono, newmono);
str2md = replace(str2md, "$$", "!!!DD!!!");
eqn = extractBetween(str2md, "$", "$", "Boundaries", "inclusive");
neweqn = replace(eqn, "\-", "-");
str2md = replace(str2md, eqn, neweqn);
str2md = replace(str2md, "!!!DD!!!", "$$");

% If more than one $$ ... $$ appear in a single line, e.g.,
% $$ \int f(x) dx $$ some text $$ (\Delta) $$
% then $$ must be replaced by $, e.g.
% $ \int f(x) dx $ some text $ (\Delta) $
lines = strsplit(str2md, newline, "CollapseDelimiters", false);
for k=1:numel(lines)
    if numel(strfind(lines(k), "$$")) > 2
        lines(k) = replace(lines(k), "$$", "$");
    end
end
str2md = strjoin(lines, newline);

% Be careful removing a space after an equation.
% Only punctuation characters can directly follow an equation
% without a space. E.g., $. is allowed, but not $a
p = [".", ",", ";", ":", "!", "?"];
for k=1:numel(p)
    str2md = replace(str2md, "$ " + p(k), "$" + p(k));
end

% Replace Markdown code blocks in a MATLAB table output by inline code
% Example: ```matlab<br> ... <br> ... <br>``` will be replaced by 
% <br>` ... `<br>` ... `
tb = extractBetween(str2md, ...
       "!!!BEGINTABLEOUTPUT!!!", "!!!ENDTABLEOUTPUT!!!", ...
       "Boundaries", "inclusive");
for k=1:numel(tb)
    ml = extractBetween(tb(k), "```", "```", "Boundaries","inclusive");
    newml = extractAfter(ml, "<br>");
    newml = deblank(newml);
    if endsWith(newml, "<br>")
        newml = char(newml);
        newml = newml(1:end-4);
    end
    newml = erase(newml, "<br>    ");
    newml = replace(newml, "<br>", "`<br>`");
    newml = "<br>`" + newml + "`";
    newml = erase(newml, "```");
    newtb = replace(tb(k), ml, newml);
    str2md = replace(str2md, tb(k), newtb);
end
% Remove temporary tags
str2md = erase(str2md, "!!!BEGINTABLEOUTPUT!!!");
str2md = erase(str2md, "!!!ENDTABLEOUTPUT!!!");

% Edge Case: Within ```matlabTextOutput ... ``` ,  if a line starts
% with at least 3 backticks (`), then we have to replace  
% ```matlabTextOutput ... ``` by ``````matlabTextOutput ... ``````
MLoutput = extractBetween(str2md, "!!!BEGINOUTPUT!!!", "!!!ENDOUTPUT!!!");
for k=1:numel(MLoutput)
    if numel(strfind(MLoutput(k), newline + "```")) > 2
        newMLoutput = strtrim(MLoutput(k));
        newMLoutput = "```" + newMLoutput + "```";
        str2md = replace(str2md, MLoutput(k), newline + newMLoutput + newline);
    end
end
% Remove temporary tags
str2md = erase(str2md, "!!!BEGINOUTPUT!!!");
str2md = erase(str2md, "!!!ENDOUTPUT!!!");

if ~options.isIPYNB
    str2md = replace(str2md, "<DOLLORSIGN>", "$");
end

end

%------------------------------------------------------------------------

function str2md = postprocessHeadings(str2md, heading, options)
% Process images in headings
if options.AcceptHTML
    texheader = sprintf("%s{<img src=", heading);
    images = extractBetween(str2md, texheader, ">}", "Boundaries","inclusive");
    newimages = extractBetween(images, heading + "{", "}");
    str2md = replace(str2md, images, newimages);
else
    texheader = sprintf("%s{![", heading);
    images = extractBetween(str2md, texheader, ")}", "Boundaries","inclusive");
    newimages = extractBetween(images, heading + "{", "}");
    str2md = replace(str2md, images, newimages);
end
% Process TeX in headings
stag1 = heading + "{";
etag1 = "}" + newline;
text = extractBetween(str2md, stag1, etag1);
switch heading
    case "\matlabtitle"
        stag2 ="#";
    case "\matlabheading"
        if options.isIPYNB; stag2 = "##"; else; stag2 = "#"; end
    case "\matlabheadingtwo"
        if options.isIPYNB; stag2 = "###"; else; stag2 = "##"; end
    case "\matlabheadingthree"
        if options.isIPYNB; stag2 = "####"; else; stag2 = "###"; end
end
stag2 =  stag2 + " ";
newtext = strtrim(text);
etag2 = newline;
str2md = replace(str2md, stag1 + text + etag1, stag2 + newtext + etag2);
end

%------------------------------------------------------------------------

function extracted = extractBetweenBraces(content, cmd, varargin)
p = strfind(content, cmd + "{");
if isempty(p); extracted = {}; return; end
content = char(content);
p = p(1);
len = strlength(cmd) + 1;

braces = 1; q = p; q = q + len; slen = strlength(content);
while braces ~= 0 && q <= slen
    if content(q) == '}' && (q == 1 || (q > 1 && content(q-1) ~= '\'))
        braces = braces - 1;
    elseif content(q) == '{' && (q == 1 || (q > 1 && content(q-1) ~= '\'))
        braces = braces + 1;
    end
    q = q + 1;
end
extracted = content(p+len:q-2);

fullCmd = cmd + "{" + extracted + "}";
if ~contains(content, fullCmd)
    return;
end
content = replace(content, fullCmd, "");
if nargin == 3 && varargin{1} == true
    cmd = char(cmd);
    extracted = cmd + "{" + extracted + "}";
end
extracted = {extracted};

if ~strcmp(strtrim(content), '')
    extracted = [extracted, extractBetweenBraces(content, cmd, varargin{:})];
end

end

%------------------------------------------------------------------------

function tf = startOfCode(line)
if startsWith(line, "\begin{matlab")     || ...
   startsWith(line, "\begin{verb")       || ...
   startsWith(line, "\begin{lstlisting")
    tf = true;
else
    tf = false;
end
end

function tf = endOfCode(line)
if startsWith(line, "\end{matlab")     || ...
   startsWith(line, "\end{verb")       || ...
   startsWith(line, "\end{lstlisting")
    tf = true;
else
    tf = false;
end
end

%------------------------------------------------------------------------

function markdown = imageReferenceAsHTML(markdown, options)
% images(i) is of the form ![image_0.png](tmp/image_0.png,width=55em)
%  or
% images(i) = ![figure_0.png](tmp/figure_0.png,width=55em)

% Images in MATLAB table outputs must stay untouched.
% Images within ```<tag> ... ``` must also stay untouched.
% Exception: ```FigureOutput ... ``` must be handled.
if options.isIPYNB
    md = eraseBetween(markdown, ...
             "\begin{matlabtableoutput}", "\end{matlabtableoutput}");
else
    md = eraseBetween(markdown, ...
              "!!!BEGINTABLEOUTPUT!!!", "!!!ENDTABLEOUTPUT!!!");
end
raw = extractBetween(markdown, "```", "```", "Boundaries", "inclusive");
raw = raw(~startsWith(raw, "```FigureOutput"));
md = erase(md, raw);

images = extractBetween(md, "![",  ")", "Boundaries", "inclusive");

n = numel(images);
if n == 0
    return;
end

filenames = extractBetween(images, "(",  ",width=");
widths    = extractBetween(images, ",width=",  "em)");
alttext   = extractBetween(images, "![", "]");

newimages = images;

% In the LaTeX file the following holds: 1em = 10px
widths = round(str2double(widths)*10); % widths in px

imageTag = '<img src="%s" width="%d" alt="%s">';

for k=1:n
    if startsWith(alttext(k), "HTML,")
        alttext(k) = erase(alttext(k), "HTML,");
    elseif ~options.AcceptHTML
        newimages(k) = eraseBetween(images(k), ",width=", "em", "Boundaries","inclusive");
        markdown = replace(markdown, images(k), newimages(k));
        continue;
    end
    newimages(k) = sprintf(imageTag, filenames(k), widths(k), alttext(k));
    if contains(filenames(k), "figure_")
        newimages(k) = "<center>" + newimages(k) + "</center>";
    end
    markdown = replace(markdown, images(k), newimages(k));
end

if options.AcceptHTML && options.EmbedImages
    markdown = embedImage(markdown, newimages, options);
elseif ~options.AcceptHTML && options.EmbedImages && ~options.isIPYNB
    Warning("CannotEmbedImage");
end

images = extractBetween(markdown, "<img", ">", "Boundaries", "inclusive");
newimages = erase(images, newline);
markdown = replace(markdown, images, newimages);
images = extractBetween(markdown, "![", ")", "Boundaries", "inclusive");
newimages = erase(images, newline);
markdown = replace(markdown, images, newimages);

end

%---------------------------------------------------------------------
% HTML syntax: <img src="filename" alt="alttext" ...>
% -> <img src="data:image/format:base64,string" alt="alttext" ...>
%    where format is image format, e.g., png,
%    and string is the base64 encoded image stored in filename.

function markdown = embedImage(markdown, tags, options)

images = extractBetween(tags, 'src="', '"');
options.imageDir = fullfile(tempdir, fileparts(images(1)));

for k=1:numel(images)
    image = strtrim(images(k));
    [status, base64] = encodeImage(image, options);
    if status == 0
        % image not found
        Warning("ImageNotFound", image);
        continue;
    end
    [~, ~, ext] = fileparts(char(image)); ext = ext(2:end);
    if ext == "jpeg"; ext = "jpg"; end
    data = sprintf("data:image/%s;base64,%s", ext, base64);
    tag = replace(tags{k}, image, data);
    markdown = replace(markdown, tags{k}, tag);
end

matlab.desktop.editor.export.ExportUtils.deleteFolder(options.imageDir);
end

%------------------------------------------------------------------------

function str2md = alignImages(str2md, options)
if ~options.AcceptHTML
    return;
end
str2md = alignImagesMain(str2md, "center");
str2md = alignImagesMain(str2md, "left"  );
str2md = alignImagesMain(str2md, "right" );

% Markdown is very sensible if an empty line is missing after
% </div>, </p>, or </center>
str2md = replace(str2md, "</div>", "</div>" + newline);
str2md = replace(str2md, "</center>", "</center>" + newline);
str2md = replace(str2md, "</p>", "</p>" + newline + newline);

end

function str2md = alignImagesMain(str2md, format)
beginTag = "!!!BEGIN" + upper(format) + "!!!";
if ~contains(str2md, beginTag)
    return;
end
endTag   = "!!!END"   + upper(format) + "!!!";
align = extractBetween(str2md, beginTag, endTag, "Boundaries", "inclusive");
alignnew = erase(align, newline);
alignnew = eraseBetween(alignnew, "!!!", "!!!", "Boundaries", "inclusive");
for k=1:numel(align)
    if startsWith(alignnew(k), "<img")
        tmp = sprintf('<p style="text-align:%s">\n   %s\n</p>', format, alignnew(k));
        str2md = replace(str2md, align(k), tmp);
    end
end
end

function str = replaceAlign(str, format)
if format == "center"
    beginAlign = "\begin{" + format + "}";
    endAlign   = "\end{" + format + "}";
else % format = "right" or "left"
    beginAlign = "\begin{flush" + format + "}";
    endAlign   = "\end{flush" + format + "}";
end
beginFigure = beginAlign + newline + "\includegraphics";
beginTag   = "!!!BEGIN" + upper(format) + "!!!";
endTag     = "!!!END" + upper(format) + "!!!";
align = extractBetween(str, beginFigure, endAlign, "Boundaries", "inclusive");
newalign = replace(align, beginAlign, beginTag);
newalign = replace(newalign, endAlign, endTag);
str = replace(str, align, newalign);
end

function str = processFigureOutputs(str)
for k=1:numel(str)
    figure = extractBetween(str(k), "```FigureOutput", "```");
    newfigure = replace(figure, "![", "![HTML,");
    str = replace(str, figure, newfigure);
end
end

function str2md = postprocessLists(str2md)
lines = strsplit(str2md, newline, "CollapseDelimiters", false);
k = 1; n = numel(lines);
while k < n
    line = strtrim(lines(k));
    if startsWith(line, "1.")
        lines(k) = line;
        k = k + 1; cnt = 2;
        line = strtrim(lines(k));
        while k <= n && startsWith(line, "1.")
            line = char(line); line = strtrim(line(3:end));
            lines(k) = num2str(cnt) + ". " + line;
            cnt = cnt + 1; k = k + 1;
            line = strtrim(lines(k));
        end
    else
        k = k + 1;
    end
end
str2md = strjoin(lines, newline);
end

function [status, base64] = encodeImage(image, options)
[status, base64] = ...
    matlab.desktop.editor.export.ExportUtils.encodeImage(image, options);
end

function Warning(msgID, varargin)
status = warning("backtrace", "off");
obj = onCleanup(@() warning("backtrace", status.state));
warning(matlab.desktop.editor.export.ExportUtils.getMsg(msgID, varargin{:}));
end

function markdown = latexTabular2Markdown(...
    markdown, alignment, tabular, options ...
)
cols = extractBetween(tabular, "\begin{tabular} {", "}\hline");
cols = numel(strfind(cols{1}, "|")) - 1;
rows = numel(strfind(tabular, "\hline")) -1;
alignmentCols = getColumnAlignment(alignment, rows, cols);
mdTable = "";
headerRow = "% HeaderRow" + newline;
tabularOrig = tabular;
hasHeaderRow = false;
if contains(tabular, headerRow)
    hasHeaderRow = true;
    tabular = erase(tabular, headerRow);
end
if ~hasHeaderRow
    % In Markdown it's not possible to define a table without a
    % header row. The only way would be to use HTML, but that should be
    % avoided even if AcceptHTML = true.
    % Therefore, we have to generate an empty header row, which means a
    % header row without any text in the cells of the row.
    for k=1:cols+1; mdTable = mdTable + "|"; end
    mdTable = setColumnAlignment(mdTable, cols, alignmentCols);
end
rline = strsplit(tabular, "\\hline");
rline = replace(rline, "&nbsp;", "!!!NBSP!!!");
for r=2:numel(rline)-1
    if r == 3 && hasHeaderRow
        mdTable = setColumnAlignment(mdTable, cols, alignmentCols);
    end
    tcells = strsplit(rline{r}, "&");
    mdTable = mdTable + newline;
    for c=1:numel(tcells)
        tcell = strtrim(tcells{c}); tcell = erase(tcell, newline);
        tcell = erase(tcell, "\\");
        if options.AcceptHTML
            if contains(tcell, "\end{par}")
                tcell = replace(tcell, "\end{par}", " <br> ");
            end
            align = getAlignment(alignment, cols, r-1, c);
            mdTable = mdTable + "| " + md2html(tcell, align) + " ";
        else
            if contains(tcell, "\end{par}")
                % Even if AcceptHTML = false, we use HTML here.
                % Otherwise a paragraph break is ignored in a cell
                % of a Markdown table.
                tcell = replace(tcell, "\end{par}", " <br> ");
                if endsWith(tcell, " <br> ")
                    tcell = tcell(1:end-5);
                end
            end
            mdTable = mdTable + "| " + tcell + " ";
        end
    end
    mdTable = mdTable + " |";
end
mdTable = mdTable + newline + newline;
mdTable = erase(mdTable, "!!!BEGINLEFT!!!");
mdTable = erase(mdTable, "!!!ENDLEFT!!!");
mdTable = erase(mdTable, "!!!BEGINRIGHT!!!");
mdTable = erase(mdTable, "!!!ENDRIGHT!!!");
mdTable = erase(mdTable, "!!!BEGINCENTER!!!");
mdTable = erase(mdTable, "!!!ENDCENTER!!!");
mdTable = replace(mdTable, "!!!NBSP!!!", "&nbsp;");
markdown = replace(markdown, tabularOrig, mdTable);
end

function mdTable = setColumnAlignment(mdTable, cols, alignmentCols)
mdTable = mdTable + newline;
for k=1:cols
    switch alignmentCols(k)
        case "center"
            mdTable = mdTable + "| :-: ";
        case "left"
            mdTable = mdTable + "| :-- ";
        case "right"
            mdTable = mdTable + "| --: ";
    end
end
mdTable = mdTable + "|" + newline;
end

function alignments = extractTableAlignments(latex)
tableOutput = extractBetween(latex, "\begin{matlabtableoutput}", ...
                                 "\end{matlabtableoutput}");
latex = erase(latex, tableOutput);
tables = extractBetween(latex, "\begin{tabular}", "\end{tabular}", ...
                               "Boundaries", "inclusive");
N = numel(tables); alignments = cell(1, N);
for m=1:N
    Cells = strsplit(tables{m}, "&");
    Cells = erase(Cells, "\begin{par}");
    Cells = erase(Cells, "flush");
    Cells = cellfun(@(c) strsplit(c, "\\hline"), Cells, 'UniformOutput', false);
    str = {};
    for n=1:numel(Cells)
        Cell = Cells{n};
        if isscalar(Cell)
            aligns = alignment(Cell);
        elseif contains(Cell{1}, "\begin{tabular}")
            aligns = alignment(Cell{2});
        elseif contains(Cell{2}, "\end{tabular}")
            aligns = alignment(Cell{1});
        else
            aligns = [alignment(Cell{1}), alignment(Cell{2})];
        end
        str = [str, aligns]; %#ok
    end
    alignments(m) = {str};
end
end

function html = md2html(markdown, alignment)
% When applying <p style="text-align:alignment"> markdown </p>
% markdown must be converted to HTML. E.g. **Comment** must be converted
% to <b>Comment</b> .
% Currently we don't do that, so just return markdown.
%
alignParagraph = sprintf('<p style="text-align:%s">', alignment); %#ok
html = markdown;
end

function align = alignment(Cell)
align = extractBetween(Cell, "\begin{", "}");
if isempty(align)
    align = "left";
else
    align = string(align{1});
end
end

function alignmentCols = getColumnAlignment(alignments, rows, cols)
n = numel(alignments);
alignmentCols = strings(1,cols);
for c =1:cols
    cellAlign = cell.empty;
    for r=1:rows
        idx = (r-1)*cols + c;
        if idx <= n
            cellAlign = [cellAlign, alignments(idx)]; %#ok
        end
    end
    cellAlign = unique(cellAlign);
    switch numel(cellAlign)
        case 1
            alignmentCols(c) = cellAlign;
        case 2
            cellAlign = setdiff(cellAlign, "center");
            if isscalar(cellAlign)
                alignmentCols(c) = cellAlign;
            else
                alignmentCols(c) = "left";
            end
        case 3
            alignmentCols(c) = "left";
    end
end
end

function align = getAlignment(alignments, cols, r, c)
n = (r-1)*cols + c;
if n > numel(alignments)
    align = "left";
else
    align = alignments((r-1)*cols + c);
end
end

function str2md = LaTeXList2Markdown(str2md, listtype)
for m=1:numel(str2md)
    beginList = "\begin{" + listtype + "}";
    endList   = "\end{"   + listtype + "}";
    listOrig = extractBetween(str2md{m}, beginList, endList, "Boundaries", "inclusive");
    list = erase(listOrig, beginList);
    list = erase(list, endList);
    list = erase(list, "\setlength{\itemsep}{-1ex}");
    for k=1:numel(list)
        items = strsplit(list{k}, newline);
        items = strtrim(items);
        if listtype == "itemize"
            items = replace(items, '\item{', '- ');
        else
            items = replace(items, '\item{', '1. ');
        end
        items = cellfun(@(item) item(1:end-1), items, "UniformOutput", false);
        items = strjoin(items, newline);
        items = replace(items, {'\{', '\}'}, {'{', '}'});
        str2md = replace(str2md, listOrig{k}, items);
    end
end
end

%-------------------------------------------------------------------------

function str = escapeSpecialCharacters(str)
eqn1 = ExtractBetween(str, "$$", "$$");
for k=1:numel(eqn1)
    str = replace(str, eqn1{k}, "!EQN1!" + num2str(k));
end
eqn2 = ExtractBetween(str, "$", "$");
for k=1:numel(eqn2)
    str = replace(str, eqn2{k}, "!EQN2!" + num2str(k));
end
cmd1 = ExtractBetween(str, "\epstopdfsetup{", newline);
for k=1:numel(cmd1)
    str = replace(str, cmd1{k}, "!CMD1!" + num2str(k));
end
cmd2 = ExtractBetween(str, "\graphicspath{", newline);
for k=1:numel(cmd2)
    str = replace(str, cmd2{k}, "!CMD2!" + num2str(k));
end
cmd3 = ExtractBetween(str, "\setlength{", newline);
for k=1:numel(cmd3)
    str = replace(str, cmd3{k}, "!CMD3!" + num2str(k));
end
gra = ExtractBetween(str, "\includegraphics", newline);
for k=1:numel(gra)
    str = replace(str, gra{k}, "!GRA!" + num2str(k));
end
lab = ExtractBetween(str, "\label{", newline);
for k=1:numel(lab)
    str = replace(str, lab{k}, "!LAB!" + num2str(k));
end
href = ExtractBetween(str, "\href{", "}");
for k=1:numel(href)
    str = replace(str, href{k}, "!HREF!" + num2str(k));
end
ref = ExtractBetween(str, "\hyperref[", "]");
for k=1:numel(ref)
    str = replace(str, ref{k}, "!REF!" + num2str(k));
end
code = ExtractBetween(str, "\begin{matlabcode}", "\end{matlabcode}");
for k=1:numel(code)
    str = replace(str, code{k}, "!CODE!" + num2str(k));
end
verb = ExtractBetween(str, "\begin{verbatim}", "\end{verbatim}");
for k=1:numel(verb)
    str = replace(str, verb{k}, "!VERB!" + num2str(k));
end
mout = ExtractBetween(str, "\begin{matlaboutput}", "\end{matlaboutput}");
for k=1:numel(mout)
    str = replace(str, mout{k}, "!MOUT!" + num2str(k));
end
tout = ExtractBetween(str, "\begin{matlabtableoutput}", "\end{matlabtableoutput}");
for k=1:numel(tout)
    str = replace(str, tout{k}, "!TOUT!" + num2str(k));
end
sout = ExtractBetween(str, "\begin{matlabsymbolicoutput}", "\end{matlabsymbolicoutput}");
for k=1:numel(sout)
    str = replace(str, sout{k}, "!SOUT!" + num2str(k));
end
str = replace(str, "\part*",          "!PART!" );
str = replace(str, "\chapter*",       "!CHAP!" );
str = replace(str, "\section*",       "!SEC!"  );
str = replace(str, "\subsection*",    "!SSEC!" );
str = replace(str, "\subsubsection*", "!SSSEC!");
str = replace(str, "\paragraph*",     "!PAR!"  );
str = replace(str, "\subparagraph*",  "!SPAR!" );

% Now, str only contains text and LaTeX commands that do not contain
% special characters. Mask the remaining special characters: * _ # [ ] > -
specialChars = ["*", "_", "#", "[", "]", ">", "-"];
maskedChars  = "\" + specialChars;
str = replace(str, specialChars, maskedChars);

str = replace(str, "!PART!",  "\part*"         );
str = replace(str, "!CHAP!",  "\chapter*"      );
str = replace(str, "!SEC!",   "\section*"      );
str = replace(str, "!SSEC!",  "\subsection*"   );
str = replace(str, "!SSSEC!", "\subsubsection*");
str = replace(str, "!PAR!",   "\paragraph*"    );
str = replace(str, "!SPAR!",  "\subparagraph*" );
for k=numel(sout):-1:1
    str = replace(str, "!SOUT!" + num2str(k), sout{k});
end
for k=numel(tout):-1:1
    str = replace(str, "!TOUT!" + num2str(k), tout{k});
end
for k=numel(mout):-1:1
    str = replace(str, "!MOUT!" + num2str(k), mout{k});
end
for k=numel(verb):-1:1
    str = replace(str, "!VERB!" + num2str(k), verb{k});
end
for k=numel(code):-1:1
    str = replace(str, "!CODE!" + num2str(k), code{k});
end
for k=numel(ref):-1:1
    str = replace(str, "!REF!" + num2str(k), ref{k});
end
for k=numel(href):-1:1
    str = replace(str, "!HREF!" + num2str(k), href{k});
end
for k=numel(lab):-1:1
    str = replace(str, "!LAB!" + num2str(k), lab{k});
end
for k=numel(gra):-1:1
    str = replace(str, "!GRA!" + num2str(k), gra{k});
end
for k=numel(cmd3):-1:1
    str = replace(str, "!CMD3!" + num2str(k), cmd3{k});
end
for k=numel(cmd2):-1:1
    str = replace(str, "!CMD2!" + num2str(k), cmd2{k});
end
for k=numel(cmd1):-1:1
    str = replace(str, "!CMD1!" + num2str(k), cmd1{k});
end
for k=numel(eqn2):-1:1
    str = replace(str, "!EQN2!" + num2str(k), eqn2{k});
end
for k=numel(eqn1):-1:1
    str = replace(str, "!EQN1!" + num2str(k), eqn1{k});
end
end

%-------------------------------------------------------------------------

function r = ExtractBetween(varargin)
r = sortByLength(extractBetween(varargin{:}, "Boundaries", "inclusive"));
end

%-------------------------------------------------------------------------

function tags = sortByLength(tags)
if ~isempty(tags)
    [~,idx] = sort(cellfun(@strlength, tags), 'descend');
    tags = tags(idx);
end
end

%-------------------------------------------------------------------------

function toc_md = generateMarkdownToC(str, includeTitle)
nl = newline; newlines = nl + " " + nl;
title = extractBetween(str, "\matlabtitle{", nl,"Boundaries","inclusive");
toc = extractBetween(str, "\matlabheading", nl, "Boundaries", "inclusive");
if includeTitle
    toc = [title, toc{:}];
    toc = strtrim(toc);
else
    toc = strtrim(toc);
    toc = toc';
end
toc_md = string(toc);
for k=1:numel(toc_md)
    skip = false;
    tstr = char(toc_md(k));
    if contains(tstr, "\matlabtitle{")
        tstr = erase(tstr,"\matlabtitle{");
        pre = "";
    elseif contains(tstr, "\matlabheading")
        switch extractBetween(toc_md(k), "\matlabheading", "{")
            case ""
                tstr = erase(tstr,"\matlabheading{");
                pre = "&emsp;";
            case "two"
                tstr = erase(tstr,"\matlabheadingtwo{");
                pre = "&emsp;&emsp;";
            case "three"
                tstr = erase(tstr,"\matlabheadingthree{");
                pre = "&emsp;&emsp;&emsp;";
        end
    else
        skip = true;
    end
    if ~skip
        tstr = strtrim(string(tstr(1:end-1)));
        link =  generateLink(tstr);
        tstr = pre + "[" + tstr + "](#" + link + ")" + newlines;
        toc_md = replace(toc_md, toc_md(k), tstr);
    end
end
end

%-------------------------------------------------------------------------

function link = generateLink(link)
% Generate a valid link:
% 1) Remove !!!EQ_N!!!, N an integer, N > 0
% 2) Remove LaTeX formatting like \texttt, \textbf, ...
% 3) Remove leading HTML tags like &em;
% 4) Extract <text> from \href{<link>}{<text>}
% 5) Remove HTML tags
% 6) Replace a space (' ') with a hypen ('-')
% 7) Erase non-alphanumeric characters
% 8) Replace multiple consecutive hyphens by a single hypen
% 9) Change capital to lower letters
% Examples:
% "Applied Linear Algebra: Robotics" -> "applied-linear-algebra-robotics"
% \href{...}{My Script}              -> "my-script"
sTag = "!!!EQ_"; eTag = "!!!";
link = ...                                                      % Step 1
    eraseBetween(link, sTag, eTag, "Boundaries", "inclusive");
latex = ["\texttt","\textbf","\textit","\underline","\text"];   % Step 2
link = erase(link, latex);
link = eraseBetween(link, "&", ";", "Boundaries", "inclusive"); % Step 3
link = char(link);
if contains(link, "\href{")                                     % Step 4
    % \href{<link>}{<text>}
    link = eraseBetween(link, "\href{", "}", "Boundaries", "inclusive");
    link = link(2:end-1); % This is <text> which is used for a link
end
link = eraseBetween(link, "<", "</");                           % Step 5
link = eraseBetween(link, "<", ">",  "Boundaries", "inclusive");
newlink = "";
for k=1:strlength(link)
    c = link(k);
    if c == ' '                                                 % Step 6
        newlink = newlink + "-";
    elseif isstrprop(c, "alphanum")                             % Step 7
        newlink = newlink + c;
    end
end
link = newlink;
while contains(link, "--")                                      % Step 8
    link = replace(link, "--", "-");
end
link = lower(link);                                             % Step 9
if strcmp(link, "") || strcmp(link, "-")
    % Such names are not valid for links. Replace it with a dummy name.
    link = "dummylink";
end
end

%-------------------------------------------------------------------------

function str2md = monospacedHyperlinks(str2md)
% Special case:
% `xxx`\hyperref[label]{`yyy`}`zzz` -> `xxxyyyzzz`
for m = 1:numel(str2md)
    cstr = char(str2md(m));
    refs = extractBetween(str2md(m), "\hyperref[", "{", "Boundaries", "inclusive");
    for n = 1:numel(refs)
        args = extractBetween(str2md(m), refs(n), "}");
        for k=1:numel(args)
            arg = args(k);
            if isempty(arg) || ~contains(arg, "`")
                continue;
            end
            newarg = char(arg);
            pat = refs(n) + arg + "}"; len = strlength(pat); newpat = pat;
            p = strfind(str2md(m), pat);
            if startsWith(arg, "`") && cstr(p-1) == '`'
                newarg = newarg(2:end); pat = "`" + pat;
            end
            if endsWith(arg, "`") && cstr(p+len) == '`'
                newarg = newarg(1:end-1); pat = pat + "`";
            end
            newpat = replace(newpat, arg, newarg);
            str2md(m) = replace(str2md(n), pat, newpat);
        end
    end
end
end

%-------------------------------------------------------------------------

function str2md = GitHubcompatible(str2md)
% Even if the currently generated Markdown is correct and
% renders fine with Visual Studio Code, GitHub can't render
% $\begin{array} ... \end{array}$, e
%
% f =
%  $\displaystyle \left(\begin{array}{c} ... \end{array}\right)$
%
% You have to write
%
% f =
%
% $$\left(\begin{array}{c} ... \end{array}\right)$$
for m=1:numel(str2md)
    tmp = extractBetween(str2md(m), newline + "\hskip1em", "$", "Boundaries", "inclusive");
    for n=1:numel(tmp)
        eq = extractBetween(str2md(m), tmp(n), "$", "Boundaries", "inclusive");
        if contains(eq, "\begin{array}")
            neweq = replace(eq, "\hskip1em", "\hskip2newline");
            neweq = replace(neweq, "$", "$$");
            str2md(m) = replace(str2md(m), eq, neweq);
        end
    end
end
end

%-------------------------------------------------------------------------

function newstr = replaceTeX(str, cmd, stag, etag)
%------------------------------------------------------------------------
% Replaces cmd{...} by stag...etag in str and returns newstr.
% E.g., if cmd equals "\texit", stag and etag equal "*", then replaceTeX
% replaces \textit{...} by *...*.
%
% Note: cmd should not "\texttt". Use replacetexttt instead!
%
% Inputs:
% str, cmd, stag, etag - a string
% Output:
% newstring            - a string
%
% Examples:
% >> replaceTeX("a \textit{bc} d \textit{e}", "\textit", "*", "*")
%
% ans = "a *bc* d *e*"
%
% >> replaceTeX("a \textit{\textbf{bc}} d", "\textbf", "**", "**")
%
% ans = "a \textit{**bc**} d"
%------------------------------------------------------------------------
s = char(str);
arg = TeXarg(s, cmd);
while ~isempty(arg)
    s = replace(s, cmd + "{" + arg + "}", stag + arg + etag);
    s = char(s);
    arg = TeXarg(s, cmd);
end
newstr = s;
end

%------------------------------------------------------------------------

function newstr = replacetexttt(str)
%------------------------------------------------------------------------
% Examples:
% >> replacetexttt("a \texttt{b} c")
%
% ans = ""a `b` c"
%
% >> replacetexttt("a \textbf{\texttt{b}} c")
%
% ans = 'a \textbf{`b`} c'
%
% >> replacetexttt("a \texttt{\textbf{b}} c")
%
% ans = 'a \textbf{`b`} c'
%
% Important: In Markdown, `...` MUST move to the innermost text in a
% sequence of TeX text formatting commands.
%------------------------------------------------------------------------
s = char(str);
arg = TeXarg(s, "\texttt");
while ~isempty(arg)
    arg = ['{', arg, '}']; %#ok
    a = 1; b = a + 1;
    while arg(b) ~= '}'; b = b + 1; end
    a = b - 1;
    while arg(a) ~= '{'; a = a - 1; end
    newarg = replace(arg, arg(a:b), ['{`', arg(a+1:b-1), '`}']);
    s = replace(s, ['\texttt', arg, ], newarg(2:end-1));
    arg = TeXarg(s, "\texttt");
end
newstr = s;
end

function arg = TeXarg(s, cmd)
p = strfind(s, cmd);
if isempty(p)
    arg = string.empty;
    return;
end
a = p(1) + strlength(cmd) + 1; b = a; cnt = 1;
while cnt > 0
    b = b + 1;
    if s(b) == '}'
        cnt = cnt - 1;
    elseif s(b) == '{'
        cnt = cnt + 1;
    end
end
arg = s(a:b-1);
end

%-------------------------------------------------------------------------