function [b,varargout] = parenReference(t,idxOp)
%

% PARENREFERENCE Subscripted reference for a table.
%   B = T(I,J) returns a table B that contains a subset of the rows and
%   variables in the table T.  I and J are positive integers, vectors of
%   positive integers, row/variable names, string/cell arrays containing one or
%   more row/variable names, or logical vectors.  B contains the same
%   property values as T, subsetted for rows or variables where
%   appropriate.

% Copyright 2021-2024 The MathWorks, Inc.

% '()' is a reference to a subset of a table.  If no subscripting
% follows, return the subarray.  Only dot subscripting may follow.

import matlab.internal.datatypes.isUniqueNumeric

try
    if numel(idxOp(1).Indices) ~= t.metaDim.length
        tabular.throwNDSubscriptError(numel(idxOp(1).Indices))
    elseif isscalar(idxOp) && nargout > 1
        % Simple parenthesis indexing can only return a single thing.
        error(message('MATLAB:table:TooManyOutputs'));
    end
    
    % Transform t(row,:).Var into t.Var(row) for performance.
    if numel(idxOp) == 2 && idxOp(2).Type == matlab.indexing.IndexingOperationType.Dot ...
            && ischar(idxOp(1).Indices{2}) && isscalar(idxOp(1).Indices{2}) && idxOp(1).Indices{2} == ':' ...
            && ~matches(idxOp(2).Name,matlab.internal.tabular.private.varNamesDim.reservedNames)             
        b = t.(idxOp(2));
        b = matlab.internal.tabular.selectRows(b,t.subs2inds(idxOp(1).Indices{1},'rowDim'));
        return;
    end

    % Create an empty output table.
    b = t.cloneAsEmpty(); % respect the subclass
    
    % Translate row labels into indices (leaves logical and ':' alone).
    [rowIndices,numRowIndices,~,isColonRows,~,b_rowDim] = t.subs2inds(idxOp(1).Indices{1},'rowDim',matlab.internal.tabular.private.tabularDimension.subsType_reference);
    b.rowDim = b_rowDim;
    
    % Translate variable (column) names into indices (translates logical and ':').
    [varIndices,numVarIndices,~,~,~,b_varDim] = t.subs2inds(idxOp(1).Indices{2},'varDim',matlab.internal.tabular.private.tabularDimension.subsType_reference);
    b.varDim = b_varDim;
    
    % Move the data to the output.
    b_data = cell(1,b.varDim.length);
    t_data = t.data;
    for j = 1:numVarIndices
        var_j = t_data{varIndices(j)};
        if isColonRows
            b_data{j} = var_j; % a fast shared-data copy
        elseif isa(var_j,'tabular') || ismatrix(var_j)
            b_data{j} = var_j(rowIndices,:); % without using reshape, may not have one
        else
            % Each var could have any number of dims, no way of knowing,
            % except how many rows they have.  So just treat them as 2D to get
            % the necessary rows, and then reshape to their original dims.
            sizeOut = size(var_j); sizeOut(1) = numRowIndices;
            b_data{j} = reshape(var_j(rowIndices,:), sizeOut);
        end
    end
    b.data = b_data;
    
    % Create subscripters for the output. If the RHS subscripts are labels or numeric
    % indices, they may have picked out the same row or variable more than once, but
    % selectFrom creates the output labels correctly.
    b.metaDim = t.metaDim;
    
    % Move the per-array properties to the output.
    b.arrayProps = t.arrayProps;

    % parenReference most often returns one output, but it might also return
    % zero or multiple outputs (e.g. t(i,:).Var{:}). Hence their output 
    % args are defined as [b,varargout] so the nargout==1 case can avoid
    % varargout, although that adds complexity to the nargout==0 case. See
    % comments below.
    %
    % nargout == 0 when the callsite has no LHS, and either (1) the subscripting
    % ends in parens and should return one value (listLength isn't called for
    % parens), or (2) the subscripting ends in dot or braces and listLength
    % determines that there is no output (need to do the subscripting call even in
    % this case, to get any error handling that might happen).
    %
    % nargout > 1 when the callsite explicitly asks for multiple outputs, or
    % when the callsite has no LHS and the subscripting ends in dot or braces
    % and listLength determines the number of outputs.
    
    if isscalar(idxOp)
        % If there's no additional subscripting, return the subarray.
        if nargout > 1
            nargoutchk(0,1);
        end
    else
        switch idxOp(2).Type
        case matlab.indexing.IndexingOperationType.Paren
            error(message('MATLAB:table:InvalidSubscriptExpr'));
        case matlab.indexing.IndexingOperationType.Brace
            error(message('MATLAB:table:InvalidSubscriptExpr'));
        case matlab.indexing.IndexingOperationType.Dot
            % The sub-table generated by the first level of paren subscripting
            % will inherit the row label information from t and paren indexing
            % can only be followed by a dot, which would anyway not use row
            % labels for indexing, hence, unlike bracce and dot, no row label
            % translation would be required for parenReference. Hence we can
            % simply forward the remainder of the subscripting expression to be
            % handled by b's subscripting method.
            if nargout == 1
                b = b.(idxOp(2:end));
            elseif nargout > 1
                [b, varargout{1:nargout-1}] = b.(idxOp(2:end));
            else % nargout == 0
                % Let varargout bump magic capture either one output (A) or zero
                % outputs (B). It would be nice to combine (A) with the simple
                % nargout==1 case (they both return one output), but there's no
                % fast/simple way to distinguish (A) from (B), so both rely on
                % varargout. [b,varargout{1:nargout-1}] won't work here, there may
                % not _be_ an output to assign to b.
                [varargout{1:nargout}] = b.(idxOp(2:end)); % ditto
                if isempty(varargout)
                    % There is nothing to return, remove the first output arg.
                    clear b
                else
                    % Shift the return value into the first output arg.
                    b = varargout{1};
                    varargout = {}; % never any additional values
                end
            end
        end
    end
catch ME
    throw(ME);
end
