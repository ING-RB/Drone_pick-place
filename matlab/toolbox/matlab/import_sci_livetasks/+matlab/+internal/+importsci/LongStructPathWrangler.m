% This class is unsupported and might change or be removed without notice in a
% future version.

classdef LongStructPathWrangler < handle
    %LONGSTRUCTPATHWRANGLER
    %   Generates code to use temporary variables to reduce the nested-ness
    %   of struct paths. An example of a struct path is
    %   "file1.Groups(2).Groups(1).Variables(4).Attributes(1)".

    % Copyright 2023 The MathWorks, Inc.

    properties

        % Maximum level of nested-ness allowed before a separate temporary
        % variable will be used to build a substructure. Defined as the
        % number of "." in a struct path + 1. E.g. a struct path like
        % "file1.Groups(2).Groups(1).Variables(4).Attributes(1)"
        % has nested-ness level of 5.
        maxNestednessLevel (1,1) {mustBeInteger, mustBePositive} = 10;

        % The names for temporary variables will be generated by
        % adding an index at the end of the base name
        baseVariableName (1,1) string = "struct";

        % Two same-sized parallel string arrays for mapping between long
        % struct paths and the temporary variables that are used to
        % represent them:

        % fullLongStructPaths contains the full struct paths for which there
        % are temporary variables. They are added in order such that the
        % first path in the array corresponds to the temporary variable
        % "struct1" (if "struct" is the baseVariableName), etc.
        fullLongStructPaths (1,:) string = string([]);

        % longStructPathsSubstitutions also contains the same struct paths
        % for which there are temporary variables in the same order, but
        % the struct paths here may already contain temporary variables.
        %
        % The fullLongStructPaths and
        % longStructPathsSubstitutions arrays are the same size and the
        % struct paths at each index in these arrays are equivalent to each
        % other.
        longStructPathsSubstitutions (1,:) string = string([]);

        % For example (for maxNestednessLevel= 3, baseVariableName = "struct"),
        % the fullLongStructPaths could be:
        % [ "test.G(2).G(1).G(4)", ...  % struct1
        %   "test.G(2).G(1).G(4).G(3).G(1)", ... % struct2
        %   "test.G(2).G(1).G(4).G(3).G(1).Variables(3).Attributes(2)"] % struct3
        %
        % Then longStructPathsSubstitutions will contain the same three
        % struct paths, but they will include the substitutions (path for
        % struct3 would be using struct2 variable, and path for struct2
        % will be using struct1 variable):
        % [ "test.G(2).G(1).G(4)", ... % struct1
        %   "struct1.G(3).G(1)", ... % struct2
        %   "struct2.Variables(3).Attributes(2)"] % struct3
        %

    end

    methods (Access=public)

        function this = LongStructPathWrangler(maxNestedness, baseName)
            % Construct an instance of this class, set the properties

            this.maxNestednessLevel = maxNestedness;
            this.baseVariableName = baseName;
        end

        function [structPathForCode, generatedCode] = generateStructPathAndCode(this, fullStructPath)
            % Given a full struct path, return the struct path within the
            % maximum nested-ness level and the code needed for creating
            % any temporary variables to achieve that. The temporary
            % variables represent parts of the nested structure thus
            % allowing to keep the level of nested-ness limited.

            arguments
                this (1,1) matlab.internal.importsci.LongStructPathWrangler

                % a struct path without any variable substitutions
                % (e.g.
                % "file1.Groups(2).Groups(1).Variables(4).Attributes(1)")
                fullStructPath (1,1) string
            end

            generatedCode = "";

            % if struct is not very nested, we can use the struct path
            % directly and don't need any extra code to use separate
            % temporary variables to build a sub-structure
            if ~this.isTooNested(fullStructPath)
                structPathForCode = fullStructPath;
                return
            end

            % check if we already have some temporary variable for all or
            % parts of this struct path and substitute it in
            structPathForCode = this.replaceStructPathWithVariables(fullStructPath);

            % Now structPathForCode either contains variables to shorten
            % it, or it is unchanged. In either case, if it is still too
            % nested, we need a new variable for it.
            if this.isTooNested(structPathForCode)

                % index for the new temporary variable
                ind = length(this.fullLongStructPaths) + 1;

                % create a name for the temporary variable for this struct
                % path
                varName = this.baseVariableName + ind;

                % save the struct path into the string arrays to indicate
                % that we now have a temporary variable for it
                this.fullLongStructPaths(ind) = fullStructPath;
                this.longStructPathsSubstitutions(ind) = structPathForCode;

                % generate a comment to use the new variable to refer to
                % this part of the overall structure
                generatedCode = generatedCode + newline + ...
                    "% " + string(getString(message(...
                    "import_sci_livetasks:messages:temporaryVariableForSubstructureComment"))) + ...
                    newline + ...
                    "% " + fullStructPath;

                % initialize the new temporary variable as an empty struct
                generatedCode = generatedCode + newline + ...
                    varName + " = struct();" + newline;

                % now we can use variable instead of the struct path
                structPathForCode = varName;
            end

        end


        function structPathWithVariable = replaceStructPathWithVariables(this, structPath)
            % Given a full struct path, see if any portion of it can be
            % replaced with an already existing temporary variable. Return
            % the struct path with the substitution.

            arguments
                this (1,1) matlab.internal.importsci.LongStructPathWrangler
                structPath (1,1) string
            end

            % If we can't replace anything, we will just return the full
            % path as is
            structPathWithVariable = structPath;

            % if we haven't created any temporary variables yet to
            % represent substructures, there will be nothing to replace
            if isempty(this.fullLongStructPaths)
                return
            end

            % Check if any part of the struct path can be replaced with
            % already existing variable. Start with the entire struct path,
            % then go with shorter and shorter portions of it. This way we
            % will substitute with a variable the longest possible portion
            % of the path.
            
            % Break up the struct at the locations of ".". Add an index
            % beyond the length of the string to check if the entire struct
            % can be replaced.
            indicesToCheck = [strfind(structPath, "."), strlength(structPath)+1];

            for i = length(indicesToCheck):-1:1
                pos = indicesToCheck(i); % position where we are breaking up the struct path
                structPathToCheck = extractBefore(structPath, pos);

                % if this struct path is already saved to the variable,
                % substitute that variable in and return the result
                foundStructPathInd = find(matches(this.fullLongStructPaths, ...
                    structPathToCheck));
                if ~isempty(foundStructPathInd)
                    variableName = this.baseVariableName + foundStructPathInd;
                    structPathWithVariable = variableName + "." + ...
                        extractAfter(structPath, pos);
                    return
                end
            end

        end

        function code = useAndClearVariables(this)
            %   Generate code for using the temporary variables to
            %   construct the output structure and for clearing the
            %   temporary variables from the workspace

            arguments
                this (1,1) matlab.internal.importsci.LongStructPathWrangler
            end

            code = "";

            % if there are any temporary variables
            if ~isempty(this.longStructPathsSubstitutions)

                % Start the code with an explaining comment
                code = newline + ...
                    "% " + string(getString(message(...
                    "import_sci_livetasks:messages:useAndClearSubstructureVariablesComment"))) + ...
                    newline;

                % Loop through temporary variables starting with the most
                % recently added (most nested) to build up the output
                % struct. We need to go in the reverse order because the
                % temporary variables in the middle might not be ready to
                % be used until the variables representing the more nested
                % paths towards the end of the array have been used to fill
                % in parts of this structure in the middle of the array.
                for i = length(this.longStructPathsSubstitutions):-1:1
                    % make the variable name from the index
                    subStructVarName = this.baseVariableName + i;

                    % use the temporary variable to assign it back to the
                    % struct path it represents, e.g.:
                    %    struct1.Groups(1).Groups(1).Groups(1) = struct2;
                    code = code + ...
                        this.longStructPathsSubstitutions(i) + " = " + subStructVarName + ...
                        ";" + newline;

                    % clear the temporary variable from the workspace
                    code = code + ...
                        "clear " + subStructVarName + newline;
                end
            end
        end

        function reset(this)
            % Reset the stored temporary variables and the struct paths
            % they represent back to empty

            arguments
                this (1,1) matlab.internal.importsci.LongStructPathWrangler
            end

            this.fullLongStructPaths = string([]);
            this.longStructPathsSubstitutions = string([]);
        end


        function isTooNested = isTooNested(this, structPath)
            % Given a struct path, determine if it exceeds the maximum
            % allowed level of nested-ness

            arguments
                this (1,1) matlab.internal.importsci.LongStructPathWrangler
                structPath (1,1) string
            end

            % Calculate the nested-ness level of the given struct path
            level = length(strfind(structPath, ".")) + 1;

            isTooNested = (level > this.maxNestednessLevel);
        end
    end

end