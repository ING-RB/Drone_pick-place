function R = sprandsym(varargin)
%SPRANDSYM Sparse random symmetric matrix.
%   R = SPRANDSYM(S) is a symmetric random matrix whose lower triangle
%       and diagonal have the same structure as S.  The elements are
%       normally distributed, with mean 0 and variance 1.
%
%   R = SPRANDSYM(n,density) is a symmetric random, n-by-n, sparse 
%       matrix with approximately density*n*n nonzeros; each entry is
%       the sum of one or more normally distributed random samples.
%
%   R = SPRANDSYM(n,density,rc) also has a reciprocal condition number
%       equal to rc.  The distribution of entries is
%       nonuniform; it is roughly symmetric about 0; all are in [-1,1].
%
%       If rc is a VECTOR of length n, then R has eigenvalues rc.
%       Thus, if rc is a positive (nonnegative) vector then R will 
%       be positive (nonnegative) definite. In either case, R is
%       generated by random Jacobi rotations applied to a diagonal
%       matrix with the given eigenvalues or condition number.  It has
%       a great deal of topological and algebraic structure.
%
%   R = SPRANDSYM(n, density, rc, kind) is positive definite.
%
%       If kind = 1, R is generated by random Jacobi rotation of
%          a positive definite diagonal matrix.
%          R has the desired condition number exactly.
%
%       If kind = 2, R is a shifted sum of outer products.
%          R has the desired condition number only
%          approximately, but has less structure.
%
%   R = SPRANDSYM(S,[],rc,3) has the same structure as the MATRIX S
%       and approximate condition number 1/rc.
%
%   R = SPRANDSYM(...,typename) returns a sparse matrix of data type 
%       typename. typename can be "single" or "double". You can use any of 
%       the input arguments in the previous four syntaxes.
%
%   See also SPRANDN, SPRAND.

%   Rob Schreiber and Cleve Moler
%   Copyright 1984-2024 The MathWorks, Inc. 

typename = "double";
nargs = nargin;

% If we support single sparse then do our error checking
support = matlab.internal.feature("SingleSparse");
if support
    % Ensure we have between 1 and 5 arguments
    narginchk(1,5);
    % Check for typename, remove from vargin, and flow through existing
    % input checking.
    if isstring(varargin{nargs}) || ischar(varargin{nargs})
        typename = varargin{nargs};
        nargs = nargs - 1;
        varargin = varargin(1:nargs);
    end
    % Only "single" and "double" are accepted typenames.
    if (isstring(typename) && ~isscalar(typename)) || ...
           (ischar(typename) && ~isrow(typename)) || ...
            (~strcmp(typename, "double") && ~strcmp(typename, "single"))
        error(message('MATLAB:sprandsym:invalidTypename'))
    end
    
    if nargs == 5
        error(message('MATLAB:TooManyInputs'))
    end
else
    % Ensure we have between 1 and 4 arguments. We do not allow typename in
    % this case.
    narginchk(1,4);
end
% sprandsym(S)
if nargs == 1
    S = varargin{1};
    if ~ismatrix(S)
        error(message('MATLAB:sprandsym:ndInput'));
    end
    m = size(S,1);
    [ii,jj] = find(S);
    ii = ii(:);
    jj = jj(:);
    lower = find(ii > jj);  %  find lower triangle
    di = find( ii == jj );  %  find diagonal
    nd = length( di );
    nl = length( lower );
    randVal1 = randn( nd, 1, typename );
    randVal2 = randn( nl, 1, typename );
    i = [ii(lower); jj(lower); ii(di)];
    j = [jj(lower); ii(lower); ii(di)];
    r = [randVal2; randVal2; randVal1];
    R = sparse(i,j,r,m,m);
% sprandsym(n,density[,typename])
elseif nargs == 2
    n = double(varargin{1});
    density = double(varargin{2});
    nl = round( (n*(n+1)/2) * min(density, 1) );
    randValues = randn( nl, 1, typename );
    % Calculate random row/col indices for nl>0; set to 0x1 otherwise
    if(nl > 0)
        ii = randi(n,nl,1);
        jj = randi(n,nl,1);
    else
        ii = zeros(0,1);
        jj = zeros(0,1);
    end
    di = find( ii == jj );
    off = find( ii ~= jj );
    nd = length( di );
    randVal1 = randValues( 1:nd );
    randVal2 = randValues( nd+1 : nl );
    i = [ii(off); jj(off); ii(di)];
    j = [jj(off); ii(off); ii(di)];
    r = [randVal2; randVal2; randVal1];
    R = sparse(i,j,r,n,n);
% sprandsym(n,density,rc[,typename]) or sprandsym({S,n},density,rc,kind[,typename])
else % nargs > 2
    density = double(varargin{2});
    rcond = cast(varargin{3},typename);
    lrc = length(rcond);
    if (lrc == 1)
        if( rcond <= 0 || rcond > 1 )
            error(message('MATLAB:sprandsym:invalidRC'))
        end
    end
    density = min(density, 1);
    % sprandsym(n,density,rc[,typename])
    if(nargs == 3 )
        n = double(varargin{1});
        nnzwanted = round(density*n*n);
        if (lrc == 1)   %   rcond is given
            ratio = ((-1)^nargs) * (rcond ^ (1/(n-1)));
            anz = (ratio .^ ( 0:(n-1)));
        else            % eigenvalues explicitly given
            anz = rcond;
        end
        R = sparse(1:n,1:n, anz);
        % for nargin == 3,  ratio < 0
        % so we start with an indefinite R;
        nnzr = n;
        %
        %   random jacobi rotations
        %
        while ( nnzr < .95*nnzwanted )
            R = rjr(R);
            nnzr = nnz(R);
        end
    % sprandsym(n,density,rc,kind[,typename])
    else  % nargs == 4
        kind = varargin{4};
        % Ensure that kind is 1,2, or 3
        if ~(kind == 1 || kind == 2 || kind == 3)
            error(message('MATLAB:sprandsym:invalidKind'))
        end
        if(kind==3)
            %
            %  add a 2-by-2 rank-1 for each off diagonal
            %
            [ii,jj] = find(varargin{1}); ii = ii(:);  % workaround
            [~, n] = size(varargin{1});
            lower = find(ii > jj);
            nl = length(lower);
            ratio = rcond ^ (1/(nl-1));
            ii = ii(lower);
            jj = jj(lower);
            i = zeros(n + 4*nl,1); 
            j = zeros(n + 4*nl,1); 
            anz = zeros(n + 4*nl,1,typename); 
            p = randperm(n);
            i(1:n) = p;
            j(1:n) = p;
            en = sqrt((28/45) * (1 - ratio^(2*nl)) / (1 - ratio^2));
            anz(1:n) = rcond * en * ones(n,1,typename);
            nnza = n;
            how_big = 1;
            for iouter = 1:nl
                rv = rand(2,1);
                op = how_big * (rv * rv');
                op = op(:);
                ik = ii(iouter);
                jk = jj(iouter);
                i(nnza+1:nnza+4) = [ik; jk; ik; jk];
                j(nnza+1:nnza+4) = [ik; ik; jk; jk];
                anz(nnza+1:nnza+4) = op;
                nnza = nnza + 4;
                how_big = how_big * ratio;
            end
            R = sparse(i(1:nnza),j(1:nnza),anz(1:nnza));
            %  end of kind == 3
        else  %  kind == 1 or 2
            n = double(varargin{1});
            if ~isscalar(n)
                error(message('MATLAB:sprandsym:firstArgNotScalar'));
            end
            nnzwanted = round(density*n*n);
            ratio = ((-1)^nargs) * (rcond ^ (1/(n-1)));
            if (kind == 1)
                R = sparse(1:n,1:n, (ratio .^ ( 0:(n-1)))  );
                nnzr = n;
                %   random jacobi rotations
                while ( nnzr < .95*nnzwanted )
                    R = rjr(R);
                    nnzr = nnz(R);
                end
            else   %  positive definite via sum of outer products (kind == 2)
                MEMFAC = 2;
                NZF = 1.25;
                i = zeros(fix(nnzwanted*MEMFAC),1); 
                j = zeros(fix(nnzwanted*MEMFAC),1); 
                anz = zeros(fix(nnzwanted*MEMFAC),1,typename); 
                %
                %   To start, put a random nonzero in every column / row
                %
                p = randperm(n);
                i(1:n) = p;
                j(1:n) = p;
                %
                % en <- Frobenius norm and max eval estimate for sprandsym
                %  Theory:  A is the sum of 2n terms with weight ratio^(-j)
                %  each has (density*n*n)/2n nonzeros with variance 1/3
                %  assuming all are separate nonzeros, we calculate, by summing
                %  the series that the expected value of ||A||^2 is approximately
                %  en = (n*density/6) * (1-ratio^4n)/(1-ratio^2).  Further,
                %  we approximate max(eig(a)) by ||A||.  We note that
                %  the initial diagonal value is a very close approx to min(eig(a)).
                %  Thus, with the choice rcond * en we get the right cond(a) on
                %  average.
                %
                en = n * density / 6;
                en = en * (1 - ratio^(4*n)) / (1 - ratio^2);
                en = sqrt(en);
                %
                anz(1:n) = rcond * en * ones(n,1,typename);
                nnza = n;   nnztrue = n;
                %
                %   Sum of scaled symmetric outer products with random structure
                %
                how_big = 1;
                for iouter = 1:2*n
                    nzpc = real(fix( 2 + sqrt((NZF*nnzwanted - nnza) / (2*n-iouter+1))));
                    bk = sprandn(n,1,nzpc/n,typename);
                    [ik,jk,anzk] = find(how_big * (bk * bk'));
                    lk = length(ik);
                    i(nnza+1:nnza+lk) = ik; 
                    j(nnza+1:nnza+lk) = jk; 
                    anz(nnza+1:nnza+lk) = anzk;
                    nnza = nnza + lk;
                    nnztrue = nnztrue + (lk - nnz(bk));
                    how_big = how_big * ratio;
                    if (nnztrue > (nnzwanted*1.1)) 
                        break; 
                    end
                end
                R = sparse(i(1:nnza),j(1:nnza),anz(1:nnza));
            end % kind == 2
        end   %  kind == 1 or 2
    end   %  nargs == 4
end      %  nargs > 2
if nargin>1
    R = .5 * (R + R');    % make absolutely symmetric
end
