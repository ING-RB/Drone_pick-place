function R = sprandn(varargin)
%SPRANDN Sparse normally distributed random matrix.
%   R = SPRANDN(S) has the same sparsity structure as S, but normally
%       distributed random entries.
%
%   R = SPRANDN(m,n,density) is a random, m-by-n, sparse matrix with 
%       approximately density*m*n normally distributed nonzero entries.
%       SPRANDN is designed to produce large matrices with small density
%       and will generate significantly fewer nonzeros than requested if
%       m*n is small or density is large.
%
%   R = SPRANDN(m,n,density,rc) also has reciprocal condition number
%       approximately equal to rc.  R is constructed from a sum of
%       matrices of rank one. 
%
%       If rc is a vector of length lr <= min(m,n), then R has 
%       rc as its first lr singular values, all others are zero.
%       In this case, R is generated by random plane rotations
%       applied to a diagonal matrix with the given singular values
%       It has a great deal of topological and algebraic structure.
%
%   R = SPRANDN(...,typename) returns a sparse matrix of data type 
%       typename. typename can be "single" or "double". You can use
%       any of the input arguments in the previous two syntaxes.
%
%   See also SPRAND, SPRANDSYM.

%   Rob Schreiber and Cleve Moler
%   Copyright 1984-2024 The MathWorks, Inc.

typename = "double";
nargs = nargin;

% If we support single sparse then do our error checking
support = matlab.internal.feature("SingleSparse");
if support
    % Ensure we have between 1 and 5 arguments
    narginchk(1,5);
    % Check for typename, remove from vargin, and flow through existing
    % input checking.
    if isstring(varargin{nargs}) || ischar(varargin{nargs})
        typename = varargin{nargs};
        nargs = nargs - 1;
        varargin = varargin(1:nargs);
    end
    % Only "single" and "double" are accepted typenames.
    if (isstring(typename) && ~isscalar(typename)) || ...
           (ischar(typename) && ~isrow(typename)) || ...
            (~strcmp(typename, "double") && ~strcmp(typename, "single"))
        error(message('MATLAB:sprandn:invalidTypename'))
    end

    if nargs == 5
        error(message('MATLAB:TooManyInputs'))
    end
else
    % Ensure we have between 1 and 4 arguments. We do not allow typename in
    % this case.
    narginchk(1,4);
end
% sprandn(S)
if nargs == 1
   S = varargin{1};
   if ~ismatrix(S)
       error(message('MATLAB:sprandn:ndInput'));
   end
   [m,n] = size(S);
   [i,j] = find(S);
   R = sparse(i,j,randn(length(i),1,typename),m,n);
elseif nargs == 2
   error(message('MATLAB:sprandn:TwoInputs'))
% sprandn(m,n,density[,typename])
elseif nargs == 3
   m = double(varargin{1});
   n = double(varargin{2});
   density = double(varargin{3});
   nnzwanted = round(m * n * min(density,1));
   % Calculate random row/col indices for nnzwanted>0; set to 0x1 otherwise
   if (nnzwanted > 0)
       i = randi(m,nnzwanted,1);
       j = randi(n,nnzwanted,1);
   else
       i = zeros(0,1);
       j = zeros(0,1);
   end
   if nnzwanted < m
       ij = unique([i j],'rows');
       i = ij(:,1);
       j = ij(:,2);
       randVals = randn( length(i), 1, typename );
       R = sparse(i,j,randVals,m,n);
   else
       R = sparse(j,i,true,n,m);
       [i,j] = find(R);
       randVals = randn( length(i), 1, typename );
       R = sparse(i,j,randVals,n,m)';
   end
% sprandn(m,n,density,rc[,typename])
else    %    nargin == 4
   m = double(varargin{1});
   n = double(varargin{2});
   density = double(varargin{3});
   rc = cast(varargin{4}, typename);
   nnzwanted = round(min(density,1)*m*n);
   minm = min(m,n);
   maxmn = max(m,n);
   lr = length(rc);
   if (lr == 1)
     if ~(rc <= 1 && rc >= 0 && imag(rc) == 0)
       error(message('MATLAB:sprandn:RcondTooHigh')); 
     end
     rcc = rc;
     rc = randn(minm, 1, typename);
     sg = sign(rc);
     sf = max(rc) - min(rc);
     rc = sg.*(((1 - rcc)./sf).*abs(rc) + rcc);
     [~, ind] = min(abs(rc));
     rc(ind) = sg(ind).*rcc;
     [~, ind] = max(abs(rc));
     rc(ind) = sg(ind).*1;
     lr = minm;
   elseif lr > minm
     lr = minm;
   end
   %
   %   To start, put a random nonzero in every column / row if
   %   there is room enough
   %
   anz = zeros(maxmn, 1, typename);
   anz(1:lr) = rc(1:lr);
   lr = minm;      %   if lr < minm then this adds some zero s.v. 
   sqrt2o2 = sqrt(2)/2;
   while (lr < min(maxmn, nnzwanted))
      ndo = min([lr, nnzwanted-lr, maxmn-lr]);
      anz(lr+1 : lr+ndo) = sqrt2o2 * anz(1:ndo);
      anz(1 : ndo) = sqrt2o2 * anz(1:ndo);
      lr = lr + ndo;
   end
   p = randperm(m);
   q = randperm(n);
   if (m < n)
      p = p(1 + rem((0:n-1), m));
   else
      q = q(1 + rem((0:m-1), n));
   end
   R = sparse(p, q, anz, m, n);
   %
   %   random two-sided rotations
   %
   while ( nnz(R) < .95*nnzwanted )
       R = rjr(R,2);
   end
end     %   nargin == 4
