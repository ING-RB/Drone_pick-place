{% if (false) %}
// Copyright 2024 The MathWorks, Inc.
{% endif %}

{% var slCoderVer = ver('simulinkcoder') %}
//
// Code generated for Simulink model '{%ModelName%}'.
//
// Model version                  : {% get_param(ModelName,'ModelVersion') %}
// Simulink Coder version         : {% [slCoderVer.Version, ' ', slCoderVer.Release, ' ', slCoderVer.Date] %}
// C/C++ source code generated on : {% datestr(now,'ddd mmm dd HH:MM:SS YYYY') %}
//
#pragma once

#include <vector>
#include <string>
#include <utility> // For std::pair
#include <map>

#include "controller_interface/controller_interface.hpp"
#include "hardware_interface/handle.hpp"

#include "realtime_tools/realtime_box.h"
#include "realtime_tools/realtime_buffer.h"
#include "realtime_tools/realtime_publisher.h"

#include "rclcpp/rclcpp.hpp"
#include "rclcpp_lifecycle/state.hpp"

#include "{%ModelName%}.h"
#include "slros2_initialize.h"

// auto-generated by generate_parameter_library
#include "{%ProjectName%}_parameters.hpp"

{% var inportIndices = arrayfun(@(y)isequal(y.PortType,'Inport'), JointInterfaces) %}
{% var outportIndices = arrayfun(@(y)isequal(y.PortType,'Outport'), JointInterfaces) %}
{% var inportRes = JointInterfaces(inportIndices) %}
{% var outportRes = JointInterfaces(outportIndices) %}

{% if ~isempty(inportRes) %}
// Extern declaration for Simulink model input structure
{% InputType %}
{% endif %}

{% if ~isempty(outportRes) %}
// Extern declaration for Simulink model output structure
{% OutputType %}
{% endif %}

namespace {%ProjectName%} {
class {%ClassName%} : public controller_interface::ControllerInterface
{
  public:
    {%ClassName%}();

    ~{%ClassName%}()
    {
      {% TermFcn %};
    }

    controller_interface::InterfaceConfiguration command_interface_configuration() const override;
    controller_interface::InterfaceConfiguration state_interface_configuration() const override;
    
    controller_interface::return_type update(
        const rclcpp::Time & time, const rclcpp::Duration & period) override;

    controller_interface::CallbackReturn on_init() override;
    
    controller_interface::CallbackReturn on_configure(
        const rclcpp_lifecycle::State & previous_state) override;
    
    controller_interface::CallbackReturn on_activate(
        const rclcpp_lifecycle::State & previous_state) override;

    controller_interface::CallbackReturn on_deactivate(
        const rclcpp_lifecycle::State & previous_state) override;

    controller_interface::CallbackReturn on_cleanup(
        const rclcpp_lifecycle::State & previous_state) override;

    controller_interface::CallbackReturn on_error(
        const rclcpp_lifecycle::State & previous_state) override;

    controller_interface::CallbackReturn on_shutdown(
        const rclcpp_lifecycle::State & previous_state) override;

  protected:
    std::shared_ptr<ParamListener> param_listener_;
    Params params_;

  private:
    bool reset();
    void updateDynamicParams();
    std::string convertToInterfaceType(const std::string& input) const;

    {% if ~isempty(outportRes) %}
    // Declare hardware command interfaces
    struct CommandJointHandle{
        std::reference_wrapper<hardware_interface::LoanedCommandInterface> joint_handle;
    };

    std::vector<CommandJointHandle> registered_command_joint_handles_;
    {% endif %}

    {% if ~isempty(inportRes) %}
    // Declare hardware state interfaces
    struct StateJointHandle{
        std::reference_wrapper<hardware_interface::LoanedStateInterface> joint_handle;
    };

    std::vector<StateJointHandle> registered_state_joint_handles_;
    {% endif %}
};

} // namespace {%ProjectName%}