{% if (false) %}
// Copyright 2019-2025 The MathWorks, Inc.
{% endif %}
{% var slCoderVer = ver('simulinkcoder') %}
//
// File ros2nodeinterface.h
//
// Code generated for Simulink model '{%ModelName%}'.
//
// Model version                  : {% get_param(ModelName,'ModelVersion') %}
// Simulink Coder version         : {% [slCoderVer.Version, ' ', slCoderVer.Release, ' ', slCoderVer.Date] %}
// C/C++ source code generated on : {% datestr(now,'ddd mmm dd HH:MM:SS YYYY') %}
//

#ifndef _ROS2_MATLAB_NODEINTERFACE_
#define _ROS2_MATLAB_NODEINTERFACE_
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4265)
#pragma warning(disable : 4458)
#pragma warning(disable : 4100)
#else
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#pragma GCC diagnostic ignored "-Wredundant-decls"
#pragma GCC diagnostic ignored "-Wnon-virtual-dtor"
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wshadow"
#endif //_MSC_VER

#include "rclcpp/rclcpp.hpp"

namespace rclcpp{
namespace executors{
class SLMultiThreadedExecutor;
}
}

{% var IsXCP = contains(ExtmodeInfo.Protocol,'XCP') %}

{% if ~isempty(ModelClassName) %forward definition of Model class %}
class {%ModelClassName%};
{% endif %}
{% if ExtmodeInfo.ExtmodeSim && IsXCP %}
#include "ext_mode.h"
{% endif %}    

#include "{%ModelName%}_types.h"
#include "rtwtypes.h"
{% for i = numel(msgIncludes) %}
#include "{%msgIncludes{i}%}"
{% endfor %}

{% if (ROS.ROSTimeStepping) %}
#include "std_msgs/msg/bool.hpp"
#include "std_msgs/msg/string.hpp"
#include "rosgraph_msgs/msg/clock.hpp"
{% endif %}

namespace ros2 {
namespace matlab {
  //Semaphore using std::CV and std::mutex
  class Semaphore {
  public:
    std::mutex mMutex;
    std::condition_variable mCV;
    std::atomic_uint mCount;
    //
    Semaphore(int count = 0)
      : mCount(count) {
      }
    //
    inline void notify() {
      std::unique_lock<std::mutex> lock(mMutex);
      mCount++;
      mCV.notify_all();
    }
    //
    inline void wait() {
      std::unique_lock<std::mutex> lock(mMutex);
      while (mCount == 0) {
        mCV.wait(lock);
      }
      if (mCount)
        mCount--;
    }
  };
  //NodeInterface
  class NodeInterface {
    NodeInterface(const NodeInterface& );
    NodeInterface& operator=(const NodeInterface& );
    //
    rclcpp::Node::SharedPtr mNode;
    std::shared_ptr<{%ModelClassName%}> mModel;
    std::shared_ptr<rclcpp::executors::SLMultiThreadedExecutor> mExec;
    //
    Semaphore mBaseRateSem;
    std::shared_ptr<std::thread> mBaseRateThread;
    {% if (ROS.ROSTimeStepping) %}
    std::shared_ptr<std::thread> mSchedulerThread;
	{% endif %}    
    {% if ~(ROS.ROSTimeStepping) %}
    rclcpp::TimerBase::SharedPtr mSchedulerTimer;
    rclcpp::CallbackGroup::SharedPtr mSchedulerGroup;
	{% endif %}    
    //
    {% if ~isSingleTasking %}
    // MultiTasking: Rates: {%num2str(numel(SampleTimes))%}
    {% for i = numel(SampleTimes) %}
    {% if (SampleTimes(i).TID ~= 0 || HasExplicitPartitions) %}
    Semaphore mSubRate{%num2str(SampleTimes(i).Idx)%}Sem;
    std::shared_ptr<std::thread> mSubRate{%num2str(SampleTimes(i).Idx)%}Thread;
    {% endif %}
    {% endfor %}
    {% endif %}
    //
    Semaphore mStopSem;
    volatile boolean_T mRunModel;
	{% if ExtmodeInfo.ExtmodeSim && IsXCP %}
	// External mode background thread
	std::shared_ptr<std::thread> mExtModeThread;
	{% endif %}    
  public:
    NodeInterface();
    ~NodeInterface();
    //
    {% if (ROS.GenerateROSComponent) %}
    void initialize();
    {% endif %}
    {% if ~(ROS.GenerateROSComponent) %}
    void initialize(int argc, char * const argv[]);
    {% endif %}
    int run();
    void stop(void);
    void terminate(void);
    //
    boolean_T getStopRequestedFlag(void);
	{% if ExtmodeInfo.ExtmodeSim && IsXCP %}
	extmodeErrorCode_T errorCode;
	void extmodeBackgroundTask(void);
	{% endif %}
    void schedulerThreadCallback(void);
    {% if (ROS.ROSTimeStepping) %}
    void rosClockSubscriberCallback(const rosgraph_msgs::msg::Clock::SharedPtr);
    {% endif %}
    void baseRateTask(void);
    {% if ~isSingleTasking %}
    {% for i = numel(SampleTimes) %}
    {% if (SampleTimes(i).TID ~= 0 || HasExplicitPartitions) %}
    void subRate{%num2str(SampleTimes(i).Idx)%}Task(void);
    {% endif %}
    {% endfor %}
    {% endif %}

    //
    rclcpp::Node::SharedPtr getNode() {
      return mNode;
    }
    //
    std::shared_ptr<{%ModelClassName%}> getModel() {
      return mModel;
    }
  }; //class NodeInterface
  //
  std::shared_ptr<ros2::matlab::NodeInterface> getNodeInterface();
  // Get QoS Settings from RMW
  inline rclcpp::QoS getQOSSettingsFromRMW(const rmw_qos_profile_t& qosProfile) {
      rclcpp::QoS qos(rclcpp::QoSInitialization::from_rmw(qosProfile));
      if (RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL == qosProfile.durability) {
          qos.transient_local();
      } else {
          qos.durability_volatile();
      }
      if (RMW_QOS_POLICY_RELIABILITY_RELIABLE == qosProfile.reliability) {
          qos.reliable();
      } else {
          qos.best_effort();
      }
      return qos;
  }
}//namespace matlab
}//namespace ros2

#ifdef _MSC_VER
#pragma warning(pop)
#else
#pragma GCC diagnostic pop
#endif //_MSC_VER
#endif //_ROS2_MATLAB_ROS2CGEN_MULTIRATE_
