{% if (false) %}
// Copyright 2019-2025 The MathWorks, Inc.
{% endif %}
{% var slCoderVer = ver('simulinkcoder') %}
//
// File ros2nodeinterface.cpp
//
// Code generated for Simulink model '{%ModelName%}'.
//
// Model version                  : {% get_param(ModelName,'ModelVersion') %}
// Simulink Coder version         : {% [slCoderVer.Version, ' ', slCoderVer.Release, ' ', slCoderVer.Date] %}
// C/C++ source code generated on : {% datestr(now,'ddd mmm dd HH:MM:SS YYYY') %}
//

{% var IsXCP = contains(ExtmodeInfo.Protocol,'XCP') %}

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4244)
#pragma warning(disable : 4265)
#pragma warning(disable : 4458)
#pragma warning(disable : 4100)
{% if ExtmodeInfo.ExtmodeSim %link with Ws2_32.lib to bring in socket library %}
#pragma comment(lib, "Ws2_32.lib")
{% endif %}
#else
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#pragma GCC diagnostic ignored "-Wredundant-decls"
#pragma GCC diagnostic ignored "-Wnon-virtual-dtor"
#pragma GCC diagnostic ignored "-Wdelete-non-virtual-dtor"
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wshadow"
#endif //_MSC_VER
#include "rclcpp/rclcpp.hpp"
#include "{%ModelName%}.h"
#include "ros2nodeinterface.h"
#include <thread>
#include <chrono>
#include <utility>

#undef ROS_SET_RTM_ERROR_STATUS
#undef ROS_GET_RTM_ERROR_STATUS
#undef ROS_RTM_STEP_TASK

{% if UseMemberMethodForRTM %}
#define ROS_SET_RTM_ERROR_STATUS(status) {%ModelRTMVarName%}->setErrorStatus(status)
#define ROS_GET_RTM_ERROR_STATUS()       {%ModelRTMVarName%}->getErrorStatus()
#define ROS_RTM_STEP_TASK(id)            {%ModelRTMVarName%}->StepTask(id)
{% endif %}

{% if ~UseMemberMethodForRTM %}
#define ROS_SET_RTM_ERROR_STATUS(status)  rtmSetErrorStatus({%ModelRTMVarName%},(status));
#define ROS_GET_RTM_ERROR_STATUS()        rtmGetErrorStatus({%ModelRTMVarName%})
#define ROS_RTM_STEP_TASK(id)             rtmStepTask({%ModelRTMVarName%},id)
{% endif %}

#include "slros2_multi_threaded_executor.h"
std::vector<rclcpp::SubscriptionBase*> SLROSSubscribers;

{% if ~(ROS.GenerateROSComponent) %}
extern rclcpp::Node::SharedPtr SLROSNodePtr;
{% endif %}

{% if (ROS.GenerateROSComponent) %}
#include "rclcpp_components/register_node_macro.hpp"
rclcpp::Node::SharedPtr SLROSNodePtr;

namespace ros2 {
namespace matlab {
  std::shared_ptr<ros2::matlab::NodeInterface> gMatlabNodeIntr;
  std::shared_ptr<ros2::matlab::NodeInterface> getNodeInterface() {
    return gMatlabNodeIntr;
  }
} //namespace matlab
} //namespace ros2

namespace SLROS2
{
	class SLROSComponent : public rclcpp::Node
	{
	public:
		explicit SLROSComponent(const rclcpp::NodeOptions & options)
		: Node("_{%ModelName%}", options)
		{
			startModelNode();
		}
        ~SLROSComponent()
        {
            stopModelNode();
        }
    private:
        void startModelNode()
        {
            // Create ROS 2 node and assign to global node pointer
			SLROSNodePtr = std::make_shared<rclcpp::Node>("{%ModelName%}", rclcpp::NodeOptions().use_intra_process_comms(true));
			
			// Initialize globally accessible node interface pointer in constructor
			ros2::matlab::gMatlabNodeIntr = std::make_shared<ros2::matlab::NodeInterface>();
    	    ros2::matlab::gMatlabNodeIntr->initialize();

            // Create custom executor and thread to spawn node
            _mExec = std::make_shared<rclcpp::executors::SLMultiThreadedExecutor>();
            _mExec->add_node(SLROSNodePtr);
            for(size_t ctr = 0; ctr<SLROSSubscribers.size();ctr++){
                _mExec->stopSubscriberCallback(SLROSSubscribers[ctr]);
            }
            _spinnerThread = std::thread([this](){ _mExec->spin();});
        }
        void stopModelNode()
        {
            // Terminates and reset node interface
			ros2::matlab::gMatlabNodeIntr->terminate();
    	    ros2::matlab::gMatlabNodeIntr.reset();
            if (_mExec.get()) {
                _mExec->cancel();
            }
            SLROSNodePtr = nullptr;
            if (_spinnerThread.joinable()){
                _spinnerThread.join();
            }
        }
		
        std::shared_ptr<rclcpp::executors::SLMultiThreadedExecutor> _mExec;
        std::thread _spinnerThread;
	}; // class SLROSComponent
} // namespace SLROS2

RCLCPP_COMPONENTS_REGISTER_NODE(SLROS2::SLROSComponent)
{% endif %}

#ifndef RT_MEMORY_ALLOCATION_ERROR_DEF
#define RT_MEMORY_ALLOCATION_ERROR_DEF
const char *RT_MEMORY_ALLOCATION_ERROR = "memory allocation error";
#endif

{% ModelFcnArguments %}
{% if (ROS.ROSTimeStepping) %}
//
// Forward declare the ROS 2 Time stepping and notification related
// functions and global flags/variables
//

// Flag to determine that model should continue to run
static volatile bool modelRuns;
static int numOverruns;
static int32_t _clock_msg_sec;
static uint32_t _clock_msg_nsec;

{% if (ROS.ROSTimeNotification) %}
// Publisher object to publish notification on the step
static rclcpp::Publisher<std_msgs::msg::String>::SharedPtr pubStepNotify;
{% endif %}

//
// Function to publish notification update status of step call
//
static void publishDone(bool status) {
  {% if (ROS.ROSTimeNotification) %}
  static std_msgs::msg::String notifyMsg;
  // Publish model name
  if(status == false){
    notifyMsg.data = "-{%ModelName%}";
  } else {
    notifyMsg.data = "+{%ModelName%}";
  }
  pubStepNotify->publish(notifyMsg);
  {% endif %}
  if (status == true) {
    modelRuns = false;
  }
}

{% endif %}

{% if HasExplicitPartitions %}
extern void AdvanceTaskCounters();
{% endif %}

namespace ros2 {
namespace matlab {
NodeInterface::NodeInterface()
    : mExec()
    , mBaseRateSem()
    , mBaseRateThread()
{% if (ROS.ROSTimeStepping) %}
    , mSchedulerThread()
{% endif %}
{% if ~(ROS.ROSTimeStepping) %}
    , mSchedulerTimer()
{% endif %}
{% if ~isSingleTasking %}
{% for i = numel(SampleTimes) %}
{% if SampleTimes(i).TID ~= 0 || HasExplicitPartitions %}
    , mSubRate{%num2str(SampleTimes(i).Idx)%}Sem()
    , mSubRate{%num2str(SampleTimes(i).Idx)%}Thread()
{% endif %}
{% endfor %}
{% endif %}
{% if ExtmodeInfo.ExtmodeSim && ExtmodeInfo.RunInBackground %}
    , mExtModeThread()
{% endif %}
    , mStopSem()
    , mRunModel(true){
  }

NodeInterface::~NodeInterface() {
    terminate();
  }

{% if (ROS.GenerateROSComponent) %}
void NodeInterface::initialize() {
    try {
        RCLCPP_INFO(SLROSNodePtr->get_logger(),"** Starting the model \"{%ModelName%}\" **\n");
        
        //initialize the model which will initialize the publishers and subscribers
         ROS_SET_RTM_ERROR_STATUS((NULL));
        {%BlockDataInit%}
        {%ModelName%}_initialize({% ModelInitializeArguments %});

       //create the threads for the rates in the Model
        mBaseRateThread = std::make_shared<std::thread>(&NodeInterface::baseRateTask, this);
        {% if ~isSingleTasking %}
        {% for i = numel(SampleTimes) %}
        {% if (SampleTimes(i).TID ~= 0 || HasExplicitPartitions) %}
            mSubRate{%num2str(SampleTimes(i).Idx)%}Thread = std::make_shared<std::thread>(&NodeInterface::subRate{%num2str(SampleTimes(i).Idx)%}Task, this);
        {% endif %}
        {% endfor %}
        {% endif %}
		{% if (ROS.ROSTimeStepping) %}
		mSchedulerThread = std::make_shared<std::thread>(&NodeInterface::schedulerThreadCallback, this);
		{% endif %}
		{% if ~(ROS.ROSTimeStepping) %}
        // Create "MutuallyExclusive" callback group for callback associated with mSchedulerTimer to prevent
        // it from being executed in parallel.
		mSchedulerGroup = SLROSNodePtr->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);
		mSchedulerTimer = SLROSNodePtr->create_wall_timer(std::chrono::nanoseconds({%SampleTimeNsecs%}),std::bind(&NodeInterface::schedulerThreadCallback,this),mSchedulerGroup);
		{% endif %}
    }
    catch (std::exception& ex) {
        std::cout << ex.what() << std::endl;
        throw ex;
    }
    catch (...) {
        std::cout << "Unknown exception" << std::endl;
        throw;
    }
}
{% endif %}
{% if ~(ROS.GenerateROSComponent) %}
void NodeInterface::initialize(int argc, char * const argv[]) {
    try {
        //initialize ros2
        std::vector<char *> args(argv, argv + argc);
        rclcpp::init(static_cast<int>(args.size()), args.data());

        //create the Node specified in Model
        std::string NodeName("{%ModelName%}");
        SLROSNodePtr = std::make_shared<rclcpp::Node>(NodeName);
        RCLCPP_INFO(SLROSNodePtr->get_logger(),"** Starting the model \"{%ModelName%}\" **\n");

        mExec = std::make_shared<rclcpp::executors::SLMultiThreadedExecutor>();
        mExec->add_node(SLROSNodePtr);

		{% if ExtmodeInfo.ExtmodeSim %}
        {
			char* extmodeArg[] = {"{%ModelName%}","-port","{%ExtmodeInfo.Port%}","-verbose","{%ExtmodeInfo.Verbose%}","-w"};
            {% if ~IsXCP %}
			rtExtModeParseArgs(6,(const char_T **)extmodeArg, NULL);
            {% endif %}
            {% if IsXCP %}
            errorCode = extmodeParseArgs(6, (const char_T **)extmodeArg);
            if (errorCode != EXTMODE_SUCCESS) {
                RCLCPP_ERROR(SLROSNodePtr->get_logger(),"!!! Error while parsing ExtModeArgs. Error code: %d",errorCode);
            }
            {% endif %}
		}
		{% endif %}
		
        //initialize the model which will initialize the publishers and subscribers
        ROS_SET_RTM_ERROR_STATUS((NULL));
        {%BlockDataInit%}
        {%ModelName%}_initialize({% ModelInitializeArguments %});
		{% if ExtmodeInfo.ExtmodeSim %}
		/* External mode */
            {% if ~IsXCP %}
		rtSetTFinalForExtMode(&rtmGetTFinal({%ModelRTMVarName%}));
		rtExtModeCheckInit({%num2str(numel(SampleTimes))%});
		{
			boolean_T rtmStopReq = false;
			rtExtModeWaitForStartPkt({%ModelRTMVarName%}->extModeInfo, {%num2str(numel(SampleTimes))%},
				&rtmStopReq);
			if (rtmStopReq) {
				rtmSetStopRequested({%ModelRTMVarName%}, true);
			}
		}
		rtERTExtModeStartMsg();
            {% endif %}
            {% if IsXCP %}
        errorCode = extmodeInit({%ModelRTMVarName%}->extModeInfo, &rtmGetTFinal({%ModelRTMVarName%}));
        if (errorCode != EXTMODE_SUCCESS) {
            RCLCPP_ERROR(SLROSNodePtr->get_logger(),"!!! Extmode Init failed. Error code: %d",errorCode);
        }
        if (errorCode == EXTMODE_SUCCESS) {
            // Wait until a Start or Stop Request has been received from the Host
            extmodeWaitForHostRequest(EXTMODE_WAIT_FOREVER);
            if (extmodeStopRequested()) {
                rtmSetStopRequested({%ModelRTMVarName%}, true);
            }
        }
            {% endif %}
		{% if ExtmodeInfo.RunInBackground %}
		mExtModeThread = std::make_shared<std::thread>(&NodeInterface::extmodeBackgroundTask, this);
		{% endif %}
		{% endif %}

        //create the threads for the rates in the Model
        mBaseRateThread = std::make_shared<std::thread>(&NodeInterface::baseRateTask, this);
        {% if ~isSingleTasking %}
        {% for i = numel(SampleTimes) %}
        {% if (SampleTimes(i).TID ~= 0 || HasExplicitPartitions) %}
            mSubRate{%num2str(SampleTimes(i).Idx)%}Thread = std::make_shared<std::thread>(&NodeInterface::subRate{%num2str(SampleTimes(i).Idx)%}Task, this);
        {% endif %}
        {% endfor %}
        {% endif %}
		{% if (ROS.ROSTimeStepping) %}
		mSchedulerThread = std::make_shared<std::thread>(&NodeInterface::schedulerThreadCallback, this);
		{% endif %}
		{% if ~(ROS.ROSTimeStepping) %}
        // Create "MutuallyExclusive" callback group for callback associated with mSchedulerTimer to prevent
        // it from being executed in parallel.
		mSchedulerGroup = SLROSNodePtr->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);
		mSchedulerTimer = SLROSNodePtr->create_wall_timer(std::chrono::nanoseconds({%SampleTimeNsecs%}),std::bind(&NodeInterface::schedulerThreadCallback,this),mSchedulerGroup);
		{% endif %}
		
		for(size_t ctr = 0; ctr<SLROSSubscribers.size();ctr++){
           mExec->stopSubscriberCallback(SLROSSubscribers[ctr]);
        }
    }
    catch (std::exception& ex) {
        std::cout << ex.what() << std::endl;
        throw ex;
    }
    catch (...) {
        std::cout << "Unknown exception" << std::endl;
        throw;
    }
}

int NodeInterface::run() {
{% if ~(ROS.ROSTimeStepping) %}
  if (mExec) {
    mExec->spin();
  }
{% endif %}
{% if (ROS.ROSTimeStepping) %}
  // Wait for ROS2Time scheduler to finish
  mStopSem.wait();
{% endif %}
  mRunModel = false;
  return 0;
}
{% endif %}

boolean_T NodeInterface::getStopRequestedFlag(void) {
    #ifndef rtmGetStopRequested
    return (!(ROS_GET_RTM_ERROR_STATUS() == (NULL)));
    #else
    return (!(ROS_GET_RTM_ERROR_STATUS()
        == (NULL)) || rtmGetStopRequested({%ModelRTMVarName%}));
    #endif
}

void NodeInterface::stop(void) {
{% if ~(ROS.GenerateROSComponent) %}
  if (mExec.get()) {
    mExec->cancel();
    if (SLROSNodePtr) {
      mExec->remove_node(SLROSNodePtr);
    }
    while (mExec.use_count() > 1);
  }
{% endif %}
}

void NodeInterface::terminate(void) {
    if (mBaseRateThread.get()) {
        mRunModel = false;
        mBaseRateSem.notify();
        mBaseRateThread->join();
{% if (ROS.ROSTimeStepping) %}
        if (mSchedulerThread.get()) {
            mSchedulerThread->join();
            mSchedulerThread.reset();
        }
{% endif %}
{% if ~(ROS.ROSTimeStepping) %}
		if (mSchedulerTimer.get()) {
        	mSchedulerTimer->cancel();
        	mSchedulerTimer->reset();
		}
{% endif %}
{% if ~isSingleTasking %}
{% for i = numel(SampleTimes) %}
{% if (SampleTimes(i).TID ~= 0 || HasExplicitPartitions) %}
        mSubRate{%num2str(SampleTimes(i).Idx)%}Sem.notify();
{% endif %}
{% endfor %}
{% endif %}
{% if ~isSingleTasking %}
{% for i = numel(SampleTimes) %}
{% if (SampleTimes(i).TID ~= 0 || HasExplicitPartitions) %}
        mSubRate{%num2str(SampleTimes(i).Idx)%}Thread->join();
        mSubRate{%num2str(SampleTimes(i).Idx)%}Thread.reset();
{% endif %}
{% endfor %}
{% endif %}
        mBaseRateThread.reset();
    {% if strcmp('on',IncludeMdlTermFcn) %}
        {%ModelName%}_terminate({% ModelTerminateArguments %});
    {% endif %}
    {% if ExtmodeInfo.ExtmodeSim %}
        {% if ~IsXCP %}
        rtExtModeShutdown({%num2str(numel(SampleTimes))%});
        {% endif %}
        {% if IsXCP %}
          extmodeReset();
        {% endif %}
    {% endif %}
{% if ~(ROS.GenerateROSComponent) %}
        mExec.reset();
        SLROSNodePtr.reset();
        rclcpp::shutdown();
{% endif %}
    }
}


{% if (ROS.ROSTimeStepping) %}
//
// ROS Clock topic subscriber callback to run the base rate task
//
void NodeInterface::rosClockSubscriberCallback(const rosgraph_msgs::msg::Clock::SharedPtr msg)
{
  static uint64_t lastEndTime = 0;
  const uint64_t baseRateNanoSec = {%SampleTimeNsecs%};

  const uint64_t currentTime = static_cast<uint64_t>(msg->clock.nanosec) + static_cast<uint64_t>(msg->clock.sec) * 1E9;
  if (lastEndTime == 0) {
    RCLCPP_INFO(SLROSNodePtr->get_logger(),"** Unblocking base-rate at %.6f", (double)currentTime/1E9);
    // Notify model stepping
    modelRuns = true;
    mBaseRateSem.notify();
    // Update lastEndTime
    lastEndTime = currentTime;
  } else {
    const uint64_t interval = currentTime - lastEndTime;
    if (interval >= baseRateNanoSec) {
      uint64_t missedSteps = interval/baseRateNanoSec;
      if (missedSteps < 2) {
        // Missed only one step
        if (modelRuns) {
          // Overrun happens
          ++numOverruns;
          RCLCPP_ERROR(SLROSNodePtr->get_logger(),"Overrun %d\n", numOverruns);
        }
        // Notify model stepping
        modelRuns = true;
        mBaseRateSem.notify();
      } else {
        for (uint64_t i=0; i<missedSteps; ++i) {
          while (modelRuns) {
            // Wait until model finishing the current step
          }
          // Notify model stepping
          modelRuns = true;
          mBaseRateSem.notify();
        }
      }
      lastEndTime = currentTime;
    } else {
      // Publish "done", because there is nothing to do in this time slot
      publishDone(false);
    } 
  }
}

//
// Scheduler Task using ROS 2 Time published by "/clock" topic to run base-rate
//
void NodeInterface::schedulerThreadCallback(void)
{
  rclcpp::QoS qos(rclcpp::QoSInitialization::from_rmw(rmw_qos_profile_default));
#ifdef MW_DEBUG_LOG
  RCLCPP_INFO(SLROSNodePtr->get_logger(),"ROS 2 schedulerTask entered\n");
#endif
  std::string sClockTopic = "/clock";
{% if (ROS.ROSTimeNotification) %}
  pubStepNotify = SLROSNodePtr->create_publisher<std_msgs::msg::String>("{% ROS.StepNotify %}", qos);
{% endif %}
  auto sub = SLROSNodePtr->create_subscription<rosgraph_msgs::msg::Clock>(sClockTopic, qos, std::bind(&ros2::matlab::NodeInterface::rosClockSubscriberCallback,this,std::placeholders::_1));
  if (mExec) {
    mExec->spin();
  }
  // Unblock main thread and terminate
  mStopSem.notify();
  return;
}
{% endif %}
{% if ~(ROS.ROSTimeStepping) %}
//
// Scheduler Task using clock timer to run base-rate
//
void NodeInterface::schedulerThreadCallback(void)
{
	if(mRunModel) {
        mBaseRateSem.notify();
    }
}
{% endif %}
//

//Model specific
{% if isSingleTasking %}
// Base-rate task
void NodeInterface::baseRateTask(void) {
  mRunModel = (ROS_GET_RTM_ERROR_STATUS() ==
              (NULL));
  while (mRunModel) {
    mBaseRateSem.wait();
#ifdef MW_DEBUG_LOG
    RCLCPP_INFO(SLROSNodePtr->get_logger(),"** Base rate task semaphore received\n");
#endif
    if (!mRunModel) break;
	{% if ExtmodeInfo.ExtmodeSim %}
	/* External mode */
        {% if ~IsXCP %}
    {
      boolean_T rtmStopReq = false;
      rtExtModePauseIfNeeded({%ModelRTMVarName%}->extModeInfo, {%num2str(numel(SampleTimes))%},
        &rtmStopReq);
      if (rtmStopReq) {
        rtmSetStopRequested({%ModelRTMVarName%}, true);
      }
      if (rtmGetStopRequested({%ModelRTMVarName%}) == true) {
        ROS_SET_RTM_ERROR_STATUS("Simulation finished");
		mRunModel = false;
        break;
      }
    }
        {% endif %}
        {% if IsXCP %}
    extmodeSimulationTime_T currentTime = (extmodeSimulationTime_T) ({%ModelRTMVarName%})->Timing.taskTime0;
    {
        boolean_T rtmStopReq = false;
        rtmStopReq = !((rtmGetErrorStatus({%ModelRTMVarName%}) == (NULL)));
        mRunModel = !rtmStopReq && !extmodeSimulationComplete() && !extmodeStopRequested();
        if (mRunModel == false) {
            rtmSetErrorStatus({%ModelRTMVarName%}, "Simulation finished");
            break;
        }
    }
        {% endif %}
	{% endif %}

	{% if ExtmodeInfo.ExtmodeSim && ~ExtmodeInfo.RunInBackground %}
        {% if ~IsXCP %}
    /* External mode */
    {
      boolean_T rtmStopReq = false;
      rtExtModeOneStep({%ModelRTMVarName%}->extModeInfo, {%num2str(numel(SampleTimes))%},
                       &rtmStopReq);
      if (rtmStopReq) {
        rtmSetStopRequested({%ModelRTMVarName%}, true);
      }
    }
         {% endif %}
	{% endif %}
    {% if ~HasExplicitPartitions %}
    {%ModelName%}_step(
	{% if ~isempty(ModelStepArguments) %}
	{% ModelStepArguments{1} %}
	{% endif %}
	);
    {% endif %}
    {% if ExtmodeInfo.ExtmodeSim %}
        {% if ~IsXCP %}
    rtExtModeCheckEndTrigger();
         {% endif %}
        {% if IsXCP %}
    extmodeEvent(0, currentTime);
         {% endif %}
    {% endif %}
    mRunModel = !NodeInterface::getStopRequestedFlag();
    {% if (ROS.ROSTimeStepping) %}
    publishDone(true);
    {% endif %}
  }
  NodeInterface::stop();
}
{% endif %}

{% if ~isSingleTasking %}
// Base-rate task for multi-tasking model
void NodeInterface::baseRateTask(void) {
  mRunModel = (ROS_GET_RTM_ERROR_STATUS() ==
              (NULL));
  while (mRunModel) {
    mBaseRateSem.wait();
#ifdef MW_DEBUG_LOG
    RCLCPP_INFO(SLROSNodePtr->get_logger(),"** Base rate task semaphore received\n");
#endif
    if (!mRunModel) break;

    {% if HasExplicitPartitions %}
    //Update concurrent task counter
    AdvanceTaskCounters();
    {% endif %}

    {% for i = numel(SampleTimes) %}
    {% if SampleTimes(i).TID ~= 0 %}
        //Check if subrate {%num2str(SampleTimes(i).TID)%} should be unblocked
        if (ROS_RTM_STEP_TASK({%num2str(SampleTimes(i).TID)%})) {
          mSubRate{%num2str(SampleTimes(i).Idx)%}Sem.notify();
        }
    {% endif %}
    {% if SampleTimes(i).TID == 0 %}
         // Execute the task which needs to run at base rate
        {% if HasExplicitPartitions %}
          mSubRate{%num2str(SampleTimes(i).Idx)%}Sem.notify();
        {% endif %}
    {% endif %}
    {% endfor %}
	{% if ExtmodeInfo.ExtmodeSim %}
	/* External mode */
        {% if ~IsXCP %}
    {
      boolean_T rtmStopReq = false;
      rtExtModePauseIfNeeded({%ModelRTMVarName%}->extModeInfo, {%num2str(numel(SampleTimes))%},
        &rtmStopReq);
      if (rtmStopReq) {
        rtmSetStopRequested({%ModelRTMVarName%}, true);
      }

      if (rtmGetStopRequested({%ModelRTMVarName%}) == true) {
        ROS_SET_RTM_ERROR_STATUS("Simulation finished");
		mRunModel = false;
        break;
      }
    }
        {% endif %}
        {% if IsXCP %}
    extmodeSimulationTime_T currentTime = (extmodeSimulationTime_T) ({%ModelRTMVarName%})->Timing.taskTime0;
    {
        boolean_T rtmStopReq = false;
        rtmStopReq = !((rtmGetErrorStatus({%ModelRTMVarName%}) == (NULL)));
        mRunModel = !rtmStopReq && !extmodeSimulationComplete() && !extmodeStopRequested();
        if (mRunModel == false) {
            rtmSetErrorStatus({%ModelRTMVarName%}, "Simulation finished");
            break;
        }
    }
        {% endif %}
	{% endif %}	
    {% if ~HasExplicitPartitions %}
    {%ModelName%}_step0(
	{% if ~isempty(ModelStepArguments) %}
	{% ModelStepArguments{1} %}
	{% endif %}
	);
    {% endif %}
	{% if ExtmodeInfo.ExtmodeSim && ~ExtmodeInfo.RunInBackground %}
        {% if IsXCP %}
    /* External mode */
    {
      boolean_T rtmStopReq = false;
      rtExtModeOneStep({%ModelRTMVarName%}->extModeInfo, {%num2str(numel(SampleTimes))%},
                       &rtmStopReq);
      if (rtmStopReq) {
        rtmSetStopRequested({%ModelRTMVarName%}, true);
      }
    }
    	{% endif %}	
	{% endif %}	
    {% if ExtmodeInfo.ExtmodeSim %}
        {% if ~IsXCP %}
    rtExtModeCheckEndTrigger();
         {% endif %}
        {% if IsXCP %}
    extmodeEvent(0, currentTime);
         {% endif %}
    {% endif %}
    mRunModel &= !NodeInterface::getStopRequestedFlag(); //If RunModel and not stop requested
    {% if (ROS.ROSTimeStepping) %}
    publishDone(true);
    {% endif %}
  }
  // Shutdown the ROS 2 node
  NodeInterface::stop();
}
{% endif %}

{% if ~isSingleTasking %}
{% for i = numel(SampleTimes) %}
{% if (SampleTimes(i).TID ~= 0 || HasExplicitPartitions) %}
void NodeInterface::subRate{%num2str(SampleTimes(i).Idx)%}Task(void) {
  while (mRunModel) {
    mSubRate{%num2str(SampleTimes(i).Idx)%}Sem.wait();
#ifdef MW_DEBUG_LOG
    RCLCPP_INFO(SLROSNodePtr->get_logger(),"** Sub-rate {%num2str(SampleTimes(i).Idx)%} task semaphore received\n");
#endif
    if (!mRunModel) break;
    {% if ~HasExplicitPartitions %}
    {%ModelName%}_step{%num2str(SampleTimes(i).Idx)%}(
	{% if ~isempty(ModelStepArguments) %}
	{% ModelStepArguments{i} %}
	{% endif %}
	);
    {% endif %}
    {% if HasExplicitPartitions %}
	{%SampleTimes(i).FcnName%}(
    {% if ~isempty(ModelStepArguments) %}
     {% ModelStepArguments{i} %}
    {% endif %}
	);
    {% endif %}
  }
}
{% endif %}
{% endfor %}
{% endif %}

{% if ExtmodeInfo.ExtmodeSim && ExtmodeInfo.RunInBackground %}
void NodeInterface::extmodeBackgroundTask(void)
{
  while (mRunModel) {
    /* External mode */
    {% if ~IsXCP %}
    {
      boolean_T rtmStopReq = false;
      rtExtModeOneStep({%ModelRTMVarName%}->extModeInfo, {%num2str(numel(SampleTimes))%},
                       &rtmStopReq);
      if (rtmStopReq) {
        rtmSetStopRequested({%ModelRTMVarName%}, true);
      }
    }
    {% endif %}
    {% if IsXCP %}
    extmodeBackgroundRun();
    // Sleep for 10 ms to yield to other threads
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    {% endif %}
  }
}
{% endif %}
}//namespace matlab
}//namespace ros2

#ifdef _MSC_VER
#pragma warning(pop)
#else
#pragma GCC diagnostic pop
#endif //_MSC_VER
