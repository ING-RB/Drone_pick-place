  <!doctype html>
  <html>
  <head>
      <meta content="text/html; charset=utf-8" http-equiv="content-type"/>
      <meta name="description" content="A report generated by the MATLAB Report Generator."/>
      <meta name="generator" content="MATLAB Report Generator"/>
      <meta name="dc.creator" content="MathWorks, Inc." />
      <meta name="dc.description" lang="en" content="Default single-file template for formatting HTML reports" />
      <meta name="dc.identifier" content="default-rg-html-file" />
      <meta name="dc.title" lang="en" content="Default Single-File HTML Template" />
      <title>Report</title>
      
      <style>/*<![CDATA[*/ 
  /********************************************************
  *
  * Table of Contents (TOC) styles
  *
  * The TOC is a multilevel, collapsible list generated by
  * the script toc.js in the report's scripts directory.
  *
  *********************************************************/
  
  /* Title of TOC Section
     The TOC template in the report's document part template
     library defines the content and layout of the title.
  */
  span.rgTOCSectionTitle {
    font-family: Arial, Helvetica, sans-serif;
    font-weight: bold;
    font-size: 12pt;
  }
  
  /* TOC container */
  div.TOC {
      background-color: #f2f2f2; /* light gray */
  }
  
  /* top-level TOC entries */
  ul.TOCItems {
      list-style-type:none; /* no bullets */
      padding-left:1em;     /* Indent from left margin */
  }
  
  /* lower-level TOC entries */
  ul.TOCItems  ul {
    list-style-type:none;
    padding-left:1.2em;
  }
  
  /* Title of section targeted by this TOC entry */
  a.TOCItemTitle {
      font-family: Arial, Helvetica, sans-serif;
      font-size: 10pt;
      font-weight:bold;
      color:blue;
      text-decoration: underline;
  }                                                                            
  
  span.TOCHandle {
      display:block;
      float:left;
      height:10px;
      width:10px;
      background-color: transparent;
      border: 1px solid black;
      background-position: center bottom; 
      background-repeat: no-repeat;
      position:relative;
      top:2px;  
      margin-right:5pt;
      cursor:default;
  }
  
  
  span.TOCHandleCollapsed {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAA/SURBVChTY/wPBAxEACYoDQcNDQ1gjA4wFOICRCsEuxGbVcgAJI9i4t+/f6EsTIDha5jp6LbQyDNQNh7AwAAA5zEb+KbHji8AAAAASUVORK5CYII=");
  }
  
  span.TOCHandleCollapsed:hover {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH4AITER4u94/hZAAAAAd0RVh0QXV0aG9yAKmuzEgAAAAMdEVYdERlc2NyaXB0aW9uABMJISMAAAAKdEVYdENvcHlyaWdodACsD8w6AAAADnRFWHRDcmVhdGlvbiB0aW1lADX3DwkAAAAJdEVYdFNvZnR3YXJlAF1w/zoAAAALdEVYdERpc2NsYWltZXIAt8C0jwAAAAh0RVh0V2FybmluZwDAG+aHAAAAB3RFWHRTb3VyY2UA9f+D6wAAAAh0RVh0Q29tbWVudAD2zJa/AAAABnRFWHRUaXRsZQCo7tInAAAAOUlEQVQYla2PsQ0AMAjDoI87n9OJhQrBUI9RlMgOhC04NZBkkubierEFiAkg1oterVOkCv2Xea47Lig/Mlx+VwdyAAAAAElFTkSuQmCC");
  }
  
  span.TOCHandleExpanded {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAArSURBVChTY/wPBAxEACYoTRBQXyHYjQ0NDVAudgCSJ81EKBsvGDBfMzAAAFYzDwbo3WvaAAAAAElFTkSuQmCC");
  }
  
  span.TOCHandleExpanded:hover {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH4AITER8sAJqxCQAAAAd0RVh0QXV0aG9yAKmuzEgAAAAMdEVYdERlc2NyaXB0aW9uABMJISMAAAAKdEVYdENvcHlyaWdodACsD8w6AAAADnRFWHRDcmVhdGlvbiB0aW1lADX3DwkAAAAJdEVYdFNvZnR3YXJlAF1w/zoAAAALdEVYdERpc2NsYWltZXIAt8C0jwAAAAh0RVh0V2FybmluZwDAG+aHAAAAB3RFWHRTb3VyY2UA9f+D6wAAAAh0RVh0Q29tbWVudAD2zJa/AAAABnRFWHRUaXRsZQCo7tInAAAAKUlEQVQYlWOsr6//z0AEYCJGEW0UsjAwMDA0NDTgVdTQ0EC8iYxDwNcAN3oIDWPkPuEAAAAASUVORK5CYII=");
  }
   
 /*DOM MATLABTable styles */
 table.rgMATLABTable {
    text-align: center;
    border: none;
 }
 table.rgMATLABTable th {
    font-weight: bold;
    padding: 0pt 4pt 0pt 4pt;
 }
 table.rgMATLABTable td {
    padding: 0pt 4pt 0pt 4pt;
 }
 table.rgMATLABTable p {
    margin: 0pt 0pt 0pt 0pt;
 }
 
  /* Table  TODO: font-family not necessary since we define it for the body, check with toc*/
  table, th, td {
    font-family: 'Noto Sans', 'Noto Sans CJK JP', 'Noto Sans CJK SC', 'Noto Sans CJK KR';
  }

  /* Body */
  body {
      font-family: 'Noto Sans', 'Noto Sans CJK JP', 'Noto Sans CJK SC', 'Noto Sans CJK KR';
      counter-reset: chapter;
      margin: 0;
  }

  /* Headings */
  h1 {
      font-family: Cambria, 'Noto Sans', 'Noto Sans CJK JP', 'Noto Sans CJK SC', 'Noto Sans CJK KR';
      color: rgb(54,95,145);
      font-size: 14pt;
      font-weight: bold;
      margin-top: 24pt;
      margin-bottom: 0pt;
      white-space: pre;
  }

  h2 {
      font-family: Cambria, 'Noto Sans', 'Noto Sans CJK JP', 'Noto Sans CJK SC', 'Noto Sans CJK KR';
      color: rgb(79,129,189);
      font-size: 13pt;
      font-weight: bold;
      margin-top: 10pt;
      margin-bottom: 0pt;
      white-space: pre;
  }

  h3 {
      font-family: Cambria, 'Noto Sans', 'Noto Sans CJK JP', 'Noto Sans CJK SC', 'Noto Sans CJK KR';
      color: rgb(79,129,189);
      font-size: 11pt;
      font-weight: bold;
      margin-top: 10pt;
      margin-bottom: 0pt;
      white-space: pre;
  }

  h4 {
      font-family: Cambria, 'Noto Sans', 'Noto Sans CJK JP', 'Noto Sans CJK SC', 'Noto Sans CJK KR';
      color: rgb(79,129,189);
      font-size: 11pt;
      font-weight: bold;
      font-style: italic;
      margin-top: 10pt;
      margin-bottom: 0pt;
      white-space: pre;
  }

  h5 {
      font-family: Cambria, 'Noto Sans', 'Noto Sans CJK JP', 'Noto Sans CJK SC', 'Noto Sans CJK KR';
      color: rgb(36,63,96);
      font-size: 11pt;
      margin-top: 10pt;
      margin-bottom: 0pt;
      white-space: pre;
  }

  h6 {
      font-family: Cambria, 'Noto Sans', 'Noto Sans CJK JP', 'Noto Sans CJK SC', 'Noto Sans CJK KR';
      color: rgb(36,63,96);
      font-size: 11pt;
      font-style: italic;
      margin-top: 10pt;
      margin-bottom: 0pt;
      white-space: pre;
  }

 /* Styles for TOC sidebar */

  .sidebar-wrapper {
      height: 100%;
      width: 200px;
      background-color: #fff;
      position: fixed!important;
      display: none;
      z-index: 5;
      overflow: auto;
      word-break: break-all;
  }

  .sidebar-animate-left {
      position: relative;
      animation: animateleft 0.4s;
  }

  @keyframes animateleft {
      from {
          left: -300px;
          opacity: 0;
      }
      to {
          left: 0;
          opacity: 1;
      }
  }

  .overlay {
      position: fixed;
      display: none;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.2);
      z-index: 2;
  }

  .animate-opacity {
      animation: opac 0.8s;
  }

  @keyframes opac {
      from {
          opacity: 0;
      }
      to {
          opacity: 1;
      }
  }

  .sidebar-button {
      border: none;
      display: inline-block;
      padding: 8px 16px;
      font-size: 24px!important;
      vertical-align: middle;
      overflow: hidden;
      text-decoration: none;
      color: inherit;
      background-color: inherit;
      text-align: center;
      cursor: pointer;
      white-space: nowrap;
      position: fixed;
  }

  .sidebar-button:hover {
      color: #000!important;
      background-color: #ccc!important;
  }

  .container {
      padding: 0.01em 16px 16px 60px;
  }

  .current-sidebar-item {
      background-color: rgb(247, 175, 175);
  }

  .collapsible {
      cursor: pointer;
  }

  .collapsible:hover td {
      background-color: #f9f9f9!important;
  }

  
  /*]]>*/</style>
  
      <script>
          //<![CDATA[
  var cssrule;
  (function (cssrule) {
  
      function createStyleSheet() {
          var style = document.createElement("style");
  
          // Add a media (and/or media query) here if you'd like!
          // style.setAttribute("media", "screen")
          // style.setAttribute("media", "@media only screen and (max-width : 1024px)")
  
          // WebKit hack :(
          style.appendChild(document.createTextNode(""));
  
          // Add the <style> element to the page
          document.head.appendChild(style);
  
          return style.sheet;
      }
  
      function addCSSRule(selector, rules, index) {
          if (document.styleSheets) {
              var sheet = createStyleSheet();
              if (sheet) {
                  if (sheet.insertRule) {
                      return sheet.insertRule(selector + " {" + rules + "}", index);
                  }
                  else {
                      return sheet.addRule(selector, rules, index);
                  }
              }
          }
          return null;
      }
      cssrule.addCSSRule = addCSSRule;
  
  })(cssrule || (cssrule = {}));
          //]]>
      </script>
      
      <script>
          //<![CDATA[
  var toc;
  (function (toc) {
      var showDetails = false;
      var headingId = 0;
  
      function createOutline(outline, levels, level) {
          if (level <= levels) {
              var ul = document.createElement("ul");
              
              if (level == 1) {
                  ul.className = "TOCItems";
              } else {
                  ul.style.display = "none";
              }
              
              for (var i = 0; i < outline.length; i++) {
                  ul.appendChild(createSection(outline[i], levels, level));
              }
              
              return ul;
          }
          
          return null;
      }
      
      toc.createOutline = createOutline;
      
      /* 
       * Create an entry in the parent section's list of
       * subsections.
       */
      function createSection(section, levels, level) {
  
          // Create a hyper link to the section targeted
          // by this TOC entry.
          var title = document.createElement("a");
          title.className = "TOCItemTitle SidebarItemTitle";
  
          
          if (section.heading === null) {
              switch (section.associatedNodes[0].nodeName.toLowerCase()) {
                  case "blockquote":
                      title.textContent = "Quoted content";
                      break;
                  case "body":
                      title.textContent = "Document";
                      break;
                  case "details":
                      title.textContent = "Widget";
                      break;
                  case "fieldset":
                      title.textContent = "Form controls";
                      break;
                  case "figure":
                      title.textContent = "Figure";
                      break;
                  case "td":
                      title.textContent = "Data cell";
                      break;
                  case "article":
                      title.textContent = "Article";
                      break;
                  case "aside":
                      title.textContent = "Aside";
                      break;
                  case "nav":
                      title.textContent = "Navigation";
                      break;
                  case "section":
                      title.textContent = "Section";
                      break;
              }
              title.className += "toc_no_title";
          } else {
              title.textContent = section.heading.text;
          }
  
          // Get this entry's target element.
          var linkTarget = section.associatedNodes[0];
          if ((linkTarget.sectionType !== 1 && linkTarget.sectionType !== 2) ||
              (linkTarget.nodeName.toLowerCase() === "body")) {
              linkTarget = section.heading;
          }
          
          // If the link target does not have an id,
          // provide it with a generated id.
          if (linkTarget.id == "") {
              ++headingId;
              linkTarget.id = "h" + headingId.toString();
          }
               
          title.href = "#" + linkTarget.id;
          
          // Create a list item to contain the
          // TOC entry and associated subsection list.
          var li = document.createElement("li");
          li.appendChild(title);
  
          // Recursively create a list of subsections of this section. 
          // If this section lacks subsections,the subsection list will
          // be empty.
          var subsectionList = createOutline(section.childSections, levels, level+1);
          
          if (subsectionList) {
              
              if (subsectionList.childElementCount > 0) {
                  
                  // The current section contains subsections.
                  // Add the list of subsections to this TOC
                  // entry.
                  li.appendChild(subsectionList);
                          
                  // Create the expand/collapse toggle handle.
                  var handle = document.createElement("span");
                  handle.className = "TOCHandle TOCHandleCollapsed";  
                  li.insertBefore(handle, li.childNodes[0]);             
  
                  // Add a click callback handler to hide or show
                  // the subsection TOC entries.
                  handle.addEventListener("click", function(event) {
                      event = event || window.event;
                      var handle = this;
                      
                      // Get this entry's subsection entry
                      // list
                      var li = handle.parentNode;
                      var sublist =  li.querySelector("UL");
                      
                      if (event.ctrlKey || event.metaKey) {
                      
                          var allExpanded = false;                       
                          if (sublist.style.display == "block") {
                              allExpanded = true;
                          }
              
                          var handleClassName = "TOCHandle TOCHandleExpanded";
                          var displayValue = "block";      
                          if (allExpanded) {
                              handleClassName = "TOCHandle TOCHandleCollapsed";
                              displayValue = "none";
                          } 
              
                          var handles = li.querySelectorAll("span.TOCHandle");
                          var i;       
                          for (i = 0; i < handles.length; i++) {
                              handles[i].className = handleClassName;
                          }
          
          
                          var lists = li.querySelectorAll("ul");
                          for (i = 0; i < handles.length; i++) {
                              lists[i].style.display = displayValue;
                          }
          
                          /*
                          if (displayValue = "none") {
                              var topList = tocContainer.querySelector("ul.TOCItems");
                              topList.style.display = "block";        
                          }
                          */
          
                          
                      } else {               
                          // Toggle display of the subsection entry list.
                          if (sublist != null) {
                              if (sublist.style.display == "none") {
                                  sublist.style.display = "block";
                                  handle.className = "TOCHandle TOCHandleExpanded";
                              } else {
                              sublist.style.display = "none";
                              handle.className = "TOCHandle TOCHandleCollapsed";
                              }
                          } 
                      }               
                      
                  });
                  }
              
          }
          return li;
      }
  
  
      function Section() {
          this.parentSection = null;
          this.childSections = [];
          this.firstChild = null;
          this.lastChild = null;
          this.appendChild = function (section) {
              section.parentSection = this;
              this.childSections.push(section);
              if (this.firstChild === null) {
                  this.firstChild = section;
              }
              this.lastChild = section;
          };
  
          this.heading = null;
  
          this.associatedNodes = [];
      }
      toc.Section = Section;
  
      function HTMLOutline(root) {
          var currentOutlinee = null;
  
          var currentSection = null;
  
          var stack = { "lastIndex": -1, "isEmpty": null, "push": null, "pop": null, "top": null };
          stack.isEmpty = function () {
              return stack.lastIndex === -1;
          };
          stack.push = function (e) {
              stack[++stack.lastIndex] = e;
              stack.top = e;
          };
          stack.pop = function () {
              var e = stack.top;
              delete stack[stack.lastIndex--];
              stack.top = stack[stack.lastIndex];
              return e;
          };
          
          function enter(node) {
              if (isElement(node)) {
                  if (!stack.isEmpty() && (isHeadingElement(stack.top) || isHidden(stack.top))) {
                      return;
                  }
                  
                  if (isHidden(node)) {
                      stack.push(node);
                      return;
                  }
                  
                  if (isSectioningContentElement(node) || isSectioningRootElement(node)) {
                      if (currentOutlinee !== null) {
                          stack.push(currentOutlinee);
                      }
                      currentOutlinee = node;
                      currentSection = new Section();
                      associateNodeWithSection(currentOutlinee, currentSection);
                      currentOutlinee.appendSection(currentSection);
                      return;
                  }
                  
                  if (currentOutlinee === null) {
                      return;
                  }
                  
                  if (isHeadingElement(node)) {
                      if (currentSection.heading === null) {
                          currentSection.heading = node;
                          return;
                       }
                       
                      if (currentOutlinee.lastSection.heading === null || node.rank >= currentOutlinee.lastSection.heading.rank) {
                          currentSection = new Section();
                          currentSection.heading = node;
                          currentOutlinee.appendSection(currentSection);
                      } else {
                          var candidateSection = currentSection;
                          do {
                              if (node.rank < candidateSection.heading.rank) {
                                  currentSection = new Section();
                                  currentSection.heading = node;
                                  candidateSection.appendChild(currentSection);
                                  break;
                              }
                              var newCandidate = candidateSection.parentSection;
                              candidateSection = newCandidate;
                          } while(true);
                      }
                      stack.push(node);
                  }
              }
          }
  
          function exit(node) {
              if (isElement(node)) {
                  if (!stack.isEmpty() && node === stack.top) {
                      stack.pop();
                  } else if (!stack.isEmpty() && (isHeadingElement(stack.top) || isHidden(stack.top))) {
                  } else if (!stack.isEmpty() && isSectioningContentElement(node)) {
                      currentOutlinee = stack.pop();
                      currentSection = currentOutlinee.lastSection;
                      for (var i = 0; i < node.sectionList.length; i++) {
                          currentSection.appendChild(node.sectionList[i]);
                      }
                  } else if (!stack.isEmpty() && isSectioningRootElement(node)) {
                      currentOutlinee = stack.pop();
                      currentSection = currentOutlinee.lastSection;
                      while (currentSection.childSections.length > 0) {
                          currentSection = currentSection.lastChild;
                      }
                  } else if (isSectioningContentElement(node) || isSectioningRootElement(node)) {
                      currentOutlinee = null;
                      currentSection = null;
                  }
              }
              if (node.associatedSection === null && currentSection !== null) {
                  associateNodeWithSection(node, currentSection);
              }
          }
  
          function associateNodeWithSection(node, section) {
              section.associatedNodes.push(node);
              node.associatedSection = section;
          }
  
          function isElement(node) {
              return node.nodeType === 1;
          }
  
          function isHidden(node) {
              return node.hidden;
          }
  
          function isSectioningContentElement(node) {
              return node.sectionType === 1;
          }
  
          function isSectioningRootElement(node) {
              return node.sectionType === 2;
          }
  
          function isHeadingElement(node) {
              return node.rank !== undefined;
          }
  
          function extend(node) {
              if (node.nodeType === 1) {
                  switch (node.nodeName.toLowerCase()) {
                      case "blockquote":
                      case "body":
                      case "details":
                      case "dialog":
                      case "fieldset":
                      case "figure":
                      case "td":
                          extendSectioningRootElement(node);
                          break;
                      case "article":
                      case "aside":
                      case "nav":
                      case "section":
                          extendSectioningContentElement(node);
                          break;
                      case "h1":
                      case "h2":
                      case "h3":
                      case "h4":
                      case "h5":
                      case "h6":
                          extendHeadingElement(node);
                          break;
                      case "hgroup":
                          extendHeadingGroupElement(node);
                          break;
                      default:
                          extendNode(node);
                  }
              } else
                  extendNode(node);
          }
  
          function extendNode(node) {
              node.associatedSection = null;
          }
  
          function extendSectioningElement(node) {
              extendNode(node);
              node.sectionList = [];
              node.firstSection = null;
              node.lastSection = null;
  
              node.appendSection = function (section) {
                  this.sectionList.push(section);
                  if (this.firstSection === null) {
                      this.firstSection = section;
                  }
                  this.lastSection = section;
              };
          }
  
          function extendSectioningContentElement(node) {
              extendSectioningElement(node);
              node.sectionType = 1;
          }
  
          function extendSectioningRootElement(node) {
              extendSectioningElement(node);
              node.sectionType = 2;
          }
  
          function extendHeadingContentElement(node) {
              extendNode(node);
              Object.defineProperty(node, "depth", {
                  "get": function () {
                      var section = node.associatedSection;
                      var depth = 1;
                      if (section !== null) {
                          while (section = section.parentSection)
                              ++depth;
                      }
                      return depth;
                  },
                  "configurable": true,
                  "enumerable": true
              });
          }
  
          function extendHeadingElement(node) {
              extendHeadingContentElement(node);
              node.rank = -parseInt(node.nodeName.charAt(1));
              node.text = node.textContent;
          }
  
          function extendHeadingGroupElement(node) {
              extendHeadingContentElement(node);
  
              for (var i = 1; i <= 6; i++) {
                  var h = node.getElementsByTagName("h" + i);
                  if (h.length > 0) {
                      node.rank = -i;
                      node.text = h[0].textContent;
                      break;
                  }
              }
  
              if (node.rank === undefined) {
                  node.rank = -1;
                  node.text = "";
              }
          }
  
          var node = root;
          start:
          while (node) {
              extend(node);
              enter(node);
              if (node.firstChild) {
                  node = node.firstChild;
                  continue start;
              }
              while (node) {
                  exit(node);
                  if (node === root) {
                      break start;
                  }
                  if (node.nextSibling) {
                      node = node.nextSibling;
                      continue start;
                  }
                  node = node.parentNode;
              }
          }
      }
      toc.HTMLOutline = HTMLOutline;

  })(toc || (toc = {}));
          //]]>
      </script>

    <script>
      //<![CDATA[
var sidebar;
(function (sidebar) {

    function createSidebar() {
        // Get all the body content now, this will exclude TOC/LOC. Wrap them in container div
        var contentWrapper = document.createElement('div');
        contentWrapper.className = 'container';

        // Move the body's children into this wrapper and then append wrapper to the body
        while (document.body.firstChild) {
            contentWrapper.appendChild(document.body.firstChild);
        }
        document.body.appendChild(contentWrapper);

        // Add button to open side bar
        var sidebarButton = document.createElement('button');
        sidebarButton.innerHTML = '&#9776';
        sidebarButton.className = 'sidebar-button';

        // Add mouse events to open and close Sidebar
        sidebarButton.addEventListener("mouseover", function () {
            openSidebar();

            highlightSelectedEntry();

            var sideBar = document.getElementById("Sidebar");
            sideBar.addEventListener("mouseleave", closeSidebar);
        });

        // Add touch events to open and close Sidebar
        sidebarButton.addEventListener("touchstart", function () {
            openSidebar();

            highlightSelectedEntry();

            var overlay = document.getElementById("SidebarOverlay");
            overlay.addEventListener("touchstart", closeSidebar);
        });

        contentWrapper.parentNode.insertBefore(sidebarButton, contentWrapper);

        // Add div for overlay
        var overlayDiv = document.createElement('div');
        overlayDiv.id = 'SidebarOverlay';
        overlayDiv.className = 'overlay animate-opacity';
        sidebarButton.parentNode.insertBefore(overlayDiv, sidebarButton);

        var sidebarWrapper = document.createElement('div');
        sidebarWrapper.id = 'Sidebar';
        sidebarWrapper.className = 'sidebar-wrapper sidebar-animate-left';
        overlayDiv.parentNode.insertBefore(sidebarWrapper, overlayDiv);

        // Function to open sidebar
        function openSidebar() {
            document.getElementById("Sidebar").style.display = "block";
            document.getElementById("SidebarOverlay").style.display = "block";
        }

        // Function to close sidebar
        function closeSidebar() {
            document.getElementById("Sidebar").style.display = "none";
            document.getElementById("SidebarOverlay").style.display = "none";
        }

        // Function to highlight the selected entry in the Sidebar
        function highlightSelectedEntry() {
            var sidebarItemList = document.getElementsByClassName('SidebarItemTitle');
            for (var i = 0; i < sidebarItemList.length; i++) {
                sidebarItemList[i].addEventListener('click', function (event) {
                    for (var j = 0; j < sidebarItemList.length; j++) {
                        sidebarItemList[j].classList.remove('current-sidebar-item');
                    }
                    event.target.classList.add('current-sidebar-item');
                });
            }
        }
    }
    sidebar.createSidebar = createSidebar;

    function appendData(data) {
        var sidebarWrapper = document.getElementById("Sidebar");
        sidebarWrapper.appendChild(data);
    }
    sidebar.appendData = appendData;

})(sidebar || (sidebar = {}));
      //]]>
    </script>

    <script>
      //<![CDATA[
  var loc;
(function (loc) {

    function getLOCElements(root, streamName) {
        var str_prefix = streamName + "_loc_caption_id";
        count = 1;
       
        var ul = document.createElement("ul");
        if(streamName === "figure")
            ul.className = "LOFItems";
        else if (streamName === "table")
            ul.className = "LOTItems";
        else
            ul.className = "LOCItems";
        ul.style.display = "none";

        var captions = document.getElementsByClassName("an_" + streamName);
        for (var i = 0; i < captions.length; i++) {
            var node = captions[i];
            var id = str_prefix + count;
            count = count + 1;
            node.parentElement.id = id;
            var li = document.createElement("li");
            var title = document.createElement("a");
            
            if (streamName === "figure")
                title.className = "LOFItemTitle SidebarItemTitle";
            else if (streamName === "table")
                title.className = "LOTItemTitle SidebarItemTitle";
            else
                title.className = "LOCItemTitle SidebarItemTitle";

            title.textContent = node.parentElement.innerText;
            title.href = "#" + id;

            title.addEventListener("click", function (event) {
                //event.preventDefault();
                node.scrollIntoView();
            }, false);
                
            li.appendChild(title);
            ul.appendChild(li);
        }
  
        return ul;
    }
    loc.getLOCElements = getLOCElements;

})(loc || (loc = {}));
    
      //]]>
    </script>
    
      <script>
          //<![CDATA[
          var util;
  (function (util) {
    function toggleTOCVisibility(event, handleId, tocTag) {
      event = event || window.event;
    
      var tocContainer = document.querySelector(tocTag);
      var containerHandle = document.getElementById(handleId);
      
      if (event.ctrlKey || event.metaKey) {
      
          if (!containerHandle.hasOwnProperty("AllExpanded")) {
              containerHandle.AllExpanded = false;
          }
          
          var allExpanded = false;
          if (containerHandle.AllExpanded) {
              allExpanded = true;
          }
              
          var handleClassName = "TOCHandle TOCHandleExpanded";
          var displayValue = "block";
          
          if (allExpanded) {
              handleClassName = "TOCHandle TOCHandleCollapsed";
              displayValue = "none";
          } 
              
          var handles = tocContainer.querySelectorAll("span.TOCHandle");
          var i;       
          for (i = 0; i < handles.length; i++) {
              handles[i].className = handleClassName;
          }
          
          
          var lists = tocContainer.querySelectorAll("ul");
          for (i = 0; i < lists.length; i++) {
              lists[i].style.display = displayValue;
          }
          
          if (displayValue == "none") {
              var topList = tocContainer.querySelector("ul.TOCItems");
              topList.style.display = "block";        
          }
          
          containerHandle.AllExpanded = !allExpanded;
          
          tocContainer.style.display = displayValue;
          containerHandle.className = handleClassName;
          
      } else {
  
          if (tocContainer.style.display == "block") {
              tocContainer.style.display = "none";
              containerHandle.className = "TOCHandle TOCHandleCollapsed";
          } else {
              tocContainer.style.display = "block";
              containerHandle.className = "TOCHandle TOCHandleExpanded";
          }
      }
    }
    
    util.toggleTOCVisibility = toggleTOCVisibility;

      function toggleLOFVisibility(event, handleId) {
          event = event || window.event;

          var containerHandle = document.getElementById(handleId);
          var lofContainer = containerHandle.parentElement.nextElementSibling;

          if (lofContainer.nextElementSibling.style.display == "block") {
               lofContainer.nextElementSibling.style.display = "none";
               containerHandle.className = "LOFHandle LOFHandleCollapsed";
          } else {
               lofContainer.nextElementSibling.style.display = "block";
               containerHandle.className = "LOFHandle LOFHandleExpanded";
          }
      }

      util.toggleLOFVisibility = toggleLOFVisibility;

      function toggleLOTVisibility(event, handleId) {
          event = event || window.event;

          var containerHandle = document.getElementById(handleId);
          var lotContainer = containerHandle.parentElement.nextElementSibling;

          if (lotContainer.nextElementSibling.style.display == "block") {
               lotContainer.nextElementSibling.style.display = "none";
               containerHandle.className = "LOTHandle LOTHandleCollapsed";
          } else {
               lotContainer.nextElementSibling.style.display = "block";
               containerHandle.className = "LOTHandle LOTHandleExpanded";
          }
      }

      util.toggleLOTVisibility = toggleLOTVisibility;

      function toggleLOCVisibility(event, handleId) {
          event = event || window.event;

          var containerHandle = document.getElementById(handleId);
          var lotContainer = containerHandle.parentElement.nextElementSibling;

          if (lotContainer.nextElementSibling.style.display == "block") {
               lotContainer.nextElementSibling.style.display = "none";
               containerHandle.className = "LOCHandle LOCHandleCollapsed";
          } else {
               lotContainer.nextElementSibling.style.display = "block";
               containerHandle.className = "LOCHandle LOCHandleExpanded";
          }
      }

      util.toggleLOCVisibility = toggleLOCVisibility;
    
      function autoNumber() {
      
            function alphabetize(n) {
                var ordA = 'A'.charCodeAt(0);
                var ordZ = 'Z'.charCodeAt(0);
                var len = ordZ - ordA + 1;
    
                var s = "";
                while(n >= 0) {
                    s = String.fromCharCode(n % len + ordA-1) + s;
                    n = Math.floor(n / len) - 1;
                }
                return s;
            }
    
            function romanize (num) {
            if (!+num)
            return false;
            var	digits = String(+num).split(""),
            key = ["","C","CC","CCC","CD","D","DC","DCC","DCCC","CM",
                "","X","XX","XXX","XL","L","LX","LXX","LXXX","XC",
                "","I","II","III","IV","V","VI","VII","VIII","IX"],
            roman = "",
            i = 3;
            while (i--)
            roman = (key[+digits.pop() + (i * 10)] || "") + roman;
            return Array(+digits.join("") + 1).join("M") + roman;
        }
        
        function formatNumber(number, format) {
            var formattedNumber =  "";
            switch (format) {
                case "n":
                case "N":
                    formattedNumber = number.toString();
                break;
                case "a":
                    formattedNumber = alphabetize(number).toLowerCase();
                    break;
                case "A":
                    formattedNumber = alphabetize(number);
                    break;
                case "i":
                    formattedNumber = romanize(number).toLowerCase();
                break;
                case "I":
                    formattedNumber = romanize(number);
                break;
                default:
                    formattedNumber = number.toString();
            }
            return formattedNumber;
        }
          
      var nodes = document.querySelectorAll("h1, h2, h3, h4, h5, h6, autonumber");
      var h1Counter = 0;
      var h2Counter = 0;
      var h3Counter = 0;
      var h4Counter = 0;
      var h5Counter = 0;
      var h6Counter = 0;
      var dict = {};
      for (var i = 0; i < nodes.length; i++) {
          node = nodes[i];
          switch (node.nodeName.toLowerCase()) {
              case "h1":
                  h1Counter = h1Counter + 1;
                  h2Counter = 0;
                  dict["figure"] = 0;
                  dict["table"] = 0;
                  break;
              case "h2":
                  h2Counter = h2Counter + 1;
                  h3Counter = 0;
                  break;
              case "h3":
                  h3Counter = h3Counter + 1;
                  h4Counter = 0;              
                  break;
              case "h4":
                  h4Counter = h4Counter + 1;
                  h5Counter = 0;
                  break;
              case "h5":
                  h5Counter = h5Counter + 1;
                  h6Counter = 0;
                  break;
              case "h6":
                  h6Counter = h6Counter + 1;
                  break;
              case "autonumber":
                  var counterName = node.getAttribute("stream-name");
                  var number = null;
                  switch (counterName.toLowerCase()) {
                      case "h1":
                          number = h1Counter;
                          break;
                      case "h2":
                          number = h2Counter;
                          break;
                      case "h3":
                          number = h3Counter;             
                          break;
                      case "h4":
                          number = h4Counter;
                          break;
                      case "h5":
                          number = h5Counter;
                          break;
                      case "h6":
                          number = h6Counter;
                          break;
                  }
                  var resets = node.parentElement.style["counter-reset"].split(" ");
                  for (var r = 0; r < resets.length - 1; r++) {
                      dict[resets[r]] = 0;
                  }
                  if (number == null) {
                      if (!dict[counterName])
                          dict[counterName] = 0;

                      var t = node.parentElement.style["counter-increment"].split(" ")[0];
                      if (t == counterName) {
                          dict[counterName] += 1;
                      }
                      number = dict[counterName];
                  }
                  var format = node.getAttribute("format");
                  format = format ? format : "n";
                  node.innerHTML = formatNumber(number, format);
                  break
              default:
                  number = "";
          }
          
          
      } 
    }
    
    util.autoNumber = autoNumber;

    function renameSpanToAutonumber() {
        var nodes = document.querySelectorAll("span.an_sect1, span.an_figure, span.an_table, span[stream-name]");
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          var streamName = node.getAttribute("stream-name");
          if(!streamName){
            switch(node.className){
                case "an_sect1":
                    streamName = "h1";
                    break;
                case "an_table":
                    streamName = "table";
                    break;
                case "an_figure":
                    streamName = "figure";
                    break;
            }
          }
          node.setAttribute("stream-name", streamName);
          node.outerHTML = node.outerHTML.replace(/span/g,"autonumber");
          
        }
    }
    util.renameSpanToAutonumber = renameSpanToAutonumber;

    
  })(util || (util = {}))
                 //]]>
      </script>

<script>
   //<![CDATA[
var stIsIE = false;

sorttable = {
    init: function() {
        // quit if this function has already been called
        if (arguments.callee.done) return;
        // flag this function so we don't do the same thing twice
        arguments.callee.done = true;
        // kill the timer
        if (_timer) clearInterval(_timer);

        if (!document.createElement || !document.getElementsByTagName) return;

        sorttable.DATE_RE = /^(\d\d?)[\/\.-](\d\d?)[\/\.-]((\d\d)?\d\d)$/;

        forEach(document.getElementsByTagName('table'), function(table) {
            if (table.className.search(/\bsortable\b/) != -1) {
                sorttable.makeSortable(table);
            }
        });

    },

    makeSortable: function(table) {
        // Safari doesn't support table.tHead, sigh
        if (table.tHead == null) table.tHead = table.getElementsByTagName('thead')[0];

        // work through each column and calculate its type
        rowsinheader = table.tHead.rows.length;
        headrow = table.tHead.rows[rowsinheader-1].cells;
        for (var i=0; i<headrow.length; i++) {
            // manually override the type with a sorttable_type attribute
            if (!headrow[i].className.match(/\bsorttable_nosort\b/)) { // skip this col
                mtch = headrow[i].className.match(/\bsorttable_([a-z0-9]+)\b/);
                if (mtch) { override = mtch[1]; }
                if (mtch && typeof sorttable["sort_"+override] == 'function') {
                    headrow[i].sorttable_sortfunction = sorttable["sort_"+override];
                } else {
                    headrow[i].sorttable_sortfunction = sorttable.guessType(table,i);
                }
                // make it clickable to sort
                headrow[i].sorttable_columnindex = i;
                headrow[i].sorttable_tbody = table.tBodies[0];
                click_addEvent(headrow[i],"click", sorttable.innerSortFunction = function(e) {

                    if (this.className.search(/\bsorttable_sorted\b/) != -1) {
                        // if we're already sorted by this column, just
                        // reverse the table, which is quicker
                        sorttable.reverse(this.sorttable_tbody);
                        this.className = this.className.replace('sorttable_sorted','sorttable_sorted_reverse');
                        this.removeChild(document.getElementById('sorttable_sortfwdind'));
                        sortrevind = document.createElement('span');
                        sortrevind.id = "sorttable_sortrevind";
                        sortrevind.innerHTML = stIsIE ? '&nbsp<font face="webdings">5</font>' : '&nbsp;&#x25B4;';
                        this.appendChild(sortrevind);
                        return;
                    }
                    if (this.className.search(/\bsorttable_sorted_reverse\b/) != -1) {
                        // if we're already sorted by this column in reverse, just
                        // re-reverse the table, which is quicker
                        sorttable.reverse(this.sorttable_tbody);
                        this.className = this.className.replace('sorttable_sorted_reverse',
                                                                'sorttable_sorted');
                        this.removeChild(document.getElementById('sorttable_sortrevind'));
                        sortfwdind = document.createElement('span');
                        sortfwdind.id = "sorttable_sortfwdind";
                        sortfwdind.innerHTML = stIsIE ? '&nbsp<font face="webdings">6</font>' : '&nbsp;&#x25BE;';
                        this.appendChild(sortfwdind);
                        return;
                    }

                    // remove sorttable_sorted classes
                    theadrow = this.parentNode;
                    forEach(theadrow.childNodes, function(cell) {
                        if (cell.nodeType == 1) { // an element
                            cell.className = cell.className.replace('sorttable_sorted_reverse','');
                            cell.className = cell.className.replace('sorttable_sorted','');
                        }
                    });
                    sortfwdind = document.getElementById('sorttable_sortfwdind');
                    if (sortfwdind) { sortfwdind.parentNode.removeChild(sortfwdind); }
                    sortrevind = document.getElementById('sorttable_sortrevind');
                    if (sortrevind) { sortrevind.parentNode.removeChild(sortrevind); }

                    this.className += ' sorttable_sorted';
                    sortfwdind = document.createElement('span');
                    sortfwdind.id = "sorttable_sortfwdind";
                    sortfwdind.innerHTML = stIsIE ? '&nbsp<font face="webdings">6</font>' : '&nbsp;&#x25BE;';
                    this.appendChild(sortfwdind);

                    // build an array to sort. We "decorate" each row with
                    // the actual sort key, sort based on the sort keys,
                    // and then put the rows back in order which is a lot
                    // faster because you only do getInnerText once per row
                    row_array = [];
                    col = this.sorttable_columnindex;
                    rows = this.sorttable_tbody.rows;
                    for (var j=0; j<rows.length; j++) {
                        row_array[row_array.length] = [sorttable.getInnerText(rows[j].cells[col]), rows[j]];
                    }

                    table = theadrow.parentNode.parentNode;
                    
                    //Get the last row 
                    lastRow = table.rows[table.rows.length - 1];

                    // Get the computed styles for the last row and check
                    // whether it has any bottom border set. If the last
                    // row doesn't have any bottom border set, then we need
                    // to check wether the table has any bottom border set.
                    // If the table has any bottom border set, we can
                    // apply that setting to the last row's bottom border.
                    tableRowStyles = getComputedStyle(lastRow);
                    lastRowBottomBorderStyle = tableRowStyles.getPropertyValue("border-bottom-style");
                    if (lastRowBottomBorderStyle === "none") {                      
                    tableStyles = getComputedStyle(table);
                    tableBorderBottomStyle = tableStyles.getPropertyValue("border-bottom-style");
                    if (tableBorderBottomStyle !== "none") {                                   
                    tableBorderBottomColor = tableStyles.getPropertyValue("border-bottom-color");
                    tableBorderBottomWidth = tableStyles.getPropertyValue("border-bottom-width");
                    // Update the row style with the extracted values
                    lastRow.style.borderBottomStyle = tableBorderBottomStyle;
                    lastRow.style.borderBottomColor = tableBorderBottomColor;
                    lastRow.style.borderBottomWidth = tableBorderBottomWidth;
                    }}

                    // sort the array
                    row_array.sort(this.sorttable_sortfunction);

                    tb = this.sorttable_tbody;
                    for (var j=0; j<row_array.length; j++) {
                        tb.appendChild(row_array[j][1]);
                    }
                    delete row_array;
                });
            }
        }
    },

    guessType: function(table, column) {
        // guess the type of a column based on its first non-blank row
        sortfn = sorttable.sort_alpha;
        for (var i=0; i<table.tBodies[0].rows.length; i++) {
            text = sorttable.getInnerText(table.tBodies[0].rows[i].cells[column]);
            if (text != '') {
                if (text.match(/^-?[£$¤]?[\d,.]+%?$/)) {
                    return sorttable.sort_numeric;
                }
                // check for a date: dd/mm/yyyy or dd/mm/yy
                // can have / or . or - as separator
                // can be mm/dd as well
                possdate = text.match(sorttable.DATE_RE)
                if (possdate) {
                    // looks like a date
                    first = parseInt(possdate[1]);
                    second = parseInt(possdate[2]);
                    if (first > 12) {
                        // definitely dd/mm
                        return sorttable.sort_ddmm;
                    } else if (second > 12) {
                        return sorttable.sort_mmdd;
                    } else {
                        // looks like a date, but we can't tell which, so assume
                        // that it's dd/mm (English imperialism!) and keep looking
                        sortfn = sorttable.sort_ddmm;
                    }
                }
            }
        }
        return sortfn;
    },

    getInnerText: function(node) {
        // gets the text we want to use for sorting for a cell.
        // strips leading and trailing whitespace.

        if (!node) return "";

        hasInputs = (typeof node.getElementsByTagName == 'function') &&
            node.getElementsByTagName('input').length;

        if (typeof node.textContent != 'undefined' && !hasInputs) {
            return node.textContent.replace(/^\s+|\s+$/g, '');
        }
        else if (typeof node.innerText != 'undefined' && !hasInputs) {
            return node.innerText.replace(/^\s+|\s+$/g, '');
        }
        else if (typeof node.text != 'undefined' && !hasInputs) {
            return node.text.replace(/^\s+|\s+$/g, '');
        }
        else {
            switch (node.nodeType) {
                case 3:
                    if (node.nodeName.toLowerCase() == 'input') {
                        return node.value.replace(/^\s+|\s+$/g, '');
                    }
                case 4:
                    return node.nodeValue.replace(/^\s+|\s+$/g, '');
                    break;
                case 1:
                case 11:
                    var innerText = '';
                    for (var i = 0; i < node.childNodes.length; i++) {
                        innerText += sorttable.getInnerText(node.childNodes[i]);
                    }
                    return innerText.replace(/^\s+|\s+$/g, '');
                    break;
                default:
                    return '';
            }
        }
    },

    reverse: function(tbody) {
        // reverse the rows in a tbody
        newrows = [];
        for (var i=0; i<tbody.rows.length; i++) {
            newrows[newrows.length] = tbody.rows[i];
        }
        for (var i=newrows.length-1; i>=0; i--) {
            tbody.appendChild(newrows[i]);
        }
        delete newrows;
    },

    /* sort functions
    each sort function takes two parameters, a and b
    you are comparing a[0] and b[0] */
    sort_numeric: function(a,b) {
        aa = parseFloat(a[0].replace(/[^0-9.-]/g,''));
        if (isNaN(aa)) aa = 0;
        bb = parseFloat(b[0].replace(/[^0-9.-]/g,''));
        if (isNaN(bb)) bb = 0;
        return aa-bb;
    },
    sort_alpha: function(a,b) {
        if (a[0]==b[0]) return 0;
        if (a[0]<b[0]) return -1;
        return 1;
    },
    sort_ddmm: function(a,b) {
        mtch = a[0].match(sorttable.DATE_RE);
        y = mtch[3]; m = mtch[2]; d = mtch[1];
        if (m.length == 1) m = '0'+m;
        if (d.length == 1) d = '0'+d;
        dt1 = y+m+d;
        mtch = b[0].match(sorttable.DATE_RE);
        y = mtch[3]; m = mtch[2]; d = mtch[1];
        if (m.length == 1) m = '0'+m;
        if (d.length == 1) d = '0'+d;
        dt2 = y+m+d;
        if (dt1==dt2) return 0;
        if (dt1<dt2) return -1;
        return 1;
    },
    sort_mmdd: function(a,b) {
        mtch = a[0].match(sorttable.DATE_RE);
        y = mtch[3]; d = mtch[2]; m = mtch[1];
        if (m.length == 1) m = '0'+m;
        if (d.length == 1) d = '0'+d;
        dt1 = y+m+d;
        mtch = b[0].match(sorttable.DATE_RE);
        y = mtch[3]; d = mtch[2]; m = mtch[1];
        if (m.length == 1) m = '0'+m;
        if (d.length == 1) d = '0'+d;
        dt2 = y+m+d;
        if (dt1==dt2) return 0;
        if (dt1<dt2) return -1;
        return 1;
    }
}

if (document.addEventListener) {
    document.addEventListener("DOMContentLoaded", sorttable.init, false);
}

if (/WebKit/i.test(navigator.userAgent)) {
    var _timer = setInterval(function() {
        if (/loaded|complete/.test(document.readyState)) {
            sorttable.init(); // call the onload handler
        }
    }, 10);
}

/* for other browsers */
window.onload = sorttable.init;

function click_addEvent(element, type, handler) {
    if (element.addEventListener) {
        element.addEventListener(type, handler, false);
    } else {
        // assign each event handler a unique ID
        if (!handler.$$guid) handler.$$guid = click_addEvent.guid++;
        // create a hash table of event types for the element
        if (!element.events) element.events = {};
        // create a hash table of event handlers for each element/event pair
        var handlers = element.events[type];
        if (!handlers) {
            handlers = element.events[type] = {};
            // store the existing event handler (if there is one)
            if (element["on" + type]) {
                handlers[0] = element["on" + type];
            }
        }
        // store the event handler in the hash table
        handlers[handler.$$guid] = handler;
        // assign a global event handler to do all the work
        element["on" + type] = handleEvent;
    }
};
// a counter used to create unique IDs
click_addEvent.guid = 1;

function removeEvent(element, type, handler) {
    if (element.removeEventListener) {
        element.removeEventListener(type, handler, false);
    } else {
        // delete the event handler from the hash table
        if (element.events && element.events[type]) {
            delete element.events[type][handler.$$guid];
        }
    }
};

function handleEvent(event) {
    var returnValue = true;
    // grab the event object (IE uses a global event object)
    event = event || fixEvent(((this.ownerDocument || this.document || this).parentWindow || window).event);
    // get a reference to the hash table of event handlers
    var handlers = this.events[event.type];
    // execute each event handler
    for (var i in handlers) {
        this.$$handleEvent = handlers[i];
        if (this.$$handleEvent(event) === false) {
            returnValue = false;
        }
    }
    return returnValue;
};

function fixEvent(event) {
    // add W3C standard event methods
    event.preventDefault = fixEvent.preventDefault;
    event.stopPropagation = fixEvent.stopPropagation;
    return event;
};
fixEvent.preventDefault = function() {
    this.returnValue = false;
};
fixEvent.stopPropagation = function() {
    this.cancelBubble = true;
}

// array-like enumeration
if (!Array.forEach) { // mozilla already supports this
    Array.forEach = function(array, block, context) {
        for (var i = 0; i < array.length; i++) {
            block.call(context, array[i], i, array);
        }
    };
}

// generic enumeration
Function.prototype.forEach = function(object, block, context) {
    for (var key in object) {
        if (typeof this.prototype[key] == "undefined") {
            block.call(context, object[key], key, object);
        }
    }
};

// character enumeration
String.forEach = function(string, block, context) {
    Array.forEach(string.split(""), function(chr, index) {
        block.call(context, chr, index, string);
    });
};

// globally resolve forEach enumeration
var forEach = function(object, block, context) {
    if (object) {
        var resolve = Object; // default
        if (object instanceof Function) {
            // functions have a "length" property
            resolve = Function;
        } else if (object.forEach instanceof Function) {
            // the object implements a custom forEach method so use that
            object.forEach(block, context);
            return;
        } else if (typeof object == "string") {
            // the object is a string
            resolve = String;
        } else if (typeof object.length == "number") {
            // the object is array-like
            resolve = Array;
        }
        resolve.forEach(object, block, context);
    }
};  
//]]>
    </script>

    <script>
        //<![CDATA[

        var collapsible;
        (function (collapsible) {

            // Function to handle the click event on collapsible rows
            function handleCollapsibleRowClick(event) {
                const currRow = event.target.closest("tr");
                const nextRow = currRow.nextElementSibling;
                if (nextRow) {
                    const tbl = event.target.closest("table");
                    const rows = tbl.rows;

                    // Determine whether we are expanding or collapsing
                    const expanding = nextRow.style.display === "none";
                    if (expanding) {
                        // Expand the rows
                        toggleRows(currRow, rows, true);
                    } else {
                        // Collapse the rows
                        toggleRows(currRow, rows, false);
                    }
                }
            }
            collapsible.handleCollapsibleRowClick = handleCollapsibleRowClick;

            // Function to recursively collapse/expand all the nested rows beneath a given row
            function toggleRows(currRow, rows, expandOrCollapse) {
                const collapseCount = parseInt(currRow.getAttribute('rows-collapse'));
                let nextRowIndex = currRow.rowIndex + 1;
                for (let i = 1; i <= collapseCount && nextRowIndex < rows.length; i++, nextRowIndex++) {
                    const nextRow = rows[nextRowIndex];
                    toggleRowDisplay(nextRow, expandOrCollapse);

                    // If this row is also collapsible, it might have its own nested rows to collapse/expand
                    if (nextRow.classList.contains('collapsible')) {
                        // Recursively toggle its nested rows
                        toggleRows(nextRow, rows, expandOrCollapse);
                    }
                }
            }

            // Function to toggle the display of a row
            function toggleRowDisplay(row, expandOrCollapse) {
                row.style.display = expandOrCollapse ? "table-row" : "none";
            }

        })(collapsible || (collapsible = {}));


        // Add event listener to collapsible table rows
        document.addEventListener("DOMContentLoaded", function() {
            document.querySelectorAll('.collapsible').forEach(function(row) {
                row.addEventListener('click', collapsible.handleCollapsibleRowClick);
            });
        });

        //]]>
    </script>
      
      <script>
          //<![CDATA[
          function outline() {
              util.renameSpanToAutonumber();
              util.autoNumber();
              var toc_elements = document.querySelectorAll('div#toc, toc');
              var loc_elements = document.querySelectorAll('div#loc, loc');

              if (toc_elements.length != 0 || loc_elements.length != 0){
                  sidebar.createSidebar();
              }  
              
              if (toc_elements.length != 0) {
                  var content = document.body;
                  toc.HTMLOutline(content);
                  if (content.sectionList) {
                      for (var toc_index = 0; toc_index < toc_elements.length; ++toc_index) {
                          var toc_element = toc_elements[toc_index];
                          var toc_levels = 6;
                          var toc_levels_attribute = toc_element.getAttribute('number-of-levels');
                          if (toc_levels_attribute) {
                              toc_levels = Number(toc_levels_attribute);
                          }
                          toc_element.appendChild(toc.createOutline(content.sectionList, toc_levels, 1));
                      }
                  }
                  var toc_element = document.querySelector('div#toc, toc');
                  if (toc_element.nextElementSibling == null) {
                      // TOC element is in its own div element, so append that div element to the sidebar
                      var tocParentDiv = toc_element.parentElement;
                  }
                  else {
                      // TOC element shares a div element with other elements. Add it to its own div
                      // and then append to sidebar
                      var tocParentDiv = document.createElement("div")
                      tocParentDiv.appendChild(toc_element);
                  }
                  sidebar.appendData(tocParentDiv);
              }

              for (var i = 0; i < loc_elements.length; i++) {
                  var loc_element = loc_elements[i];
                  var content = document.body;
                  if (loc_element.nextElementSibling == null) {
                      // LOC element is in its own div element, so append that div element to the sidebar
                      var locParentDiv = loc_element.parentElement;
                  }
                  else {
                      // LOC element shares a div element with other elements. Add it to its own div
                      // and then append to sidebar
                      var locParentDiv = document.createElement("div");
                      locParentDiv.appendChild(loc_element);
                  }
                  var streamName = loc_element.getAttribute("an-stream-name");
                  var locElements = loc.getLOCElements(content, streamName);
                  locParentDiv.appendChild(locElements);
                  sidebar.appendData(loc_element.parentElement);
              }

              // Open HTMLModuleTabs reporter's first tab on report load
              moduletabs.clickFirstTab();
          }
          //]]>
      </script>

    <script>
        //<![CDATA[
            var moduletabs;
            (function (moduletabs) {

                function openTab() {
                    var tabToOpen = 0;
                    var tabLabelButtons = document.getElementsByClassName("HTMLModuleTabsLabelButton");
                      for (var i = 0; i < tabLabelButtons.length; i++) {
                        if (event.currentTarget.innerHTML == tabLabelButtons[i].innerHTML) {
                            if (!tabLabelButtons[i].className.endsWith(" active")) {
                                tabLabelButtons[i].className += " active";
                            }
                            tabToOpen = i;
                        } else {
                            tabLabelButtons[i].className = tabLabelButtons[i].className.replace(" active", "");
                        }
                      }

                      var tabcontent = document.getElementsByClassName("HTMLModuleTabsContentPane");
                      for (var j = 0; j < tabcontent.length; j++) {
                        if (j == tabToOpen) {
                            tabcontent[j].style.display = "block";
                        } else {
                            tabcontent[j].style.display = "none";
                        }
                      }
            }
            moduletabs.openTab = openTab;

            function clickFirstTab() {
                var tabLabelButtons = document.getElementsByClassName("HTMLModuleTabsLabelButton");
                if (tabLabelButtons.length != 0) {
                    tabLabelButtons[0].click();
                }
            }
            moduletabs.clickFirstTab = clickFirstTab;

            function closeTabs() {
                // close the current content pane
                event.currentTarget.parentElement.style.display='none';

                // Make all tabs to be inactive
                var tabLabelButtons = document.getElementsByClassName("HTMLModuleTabsLabelButton");
                for (var i = 0; i < tabLabelButtons.length; i++) {
                    tabLabelButtons[i].className = tabLabelButtons[i].className.replace(" active", "");
                }
            }
            moduletabs.closeTabs = closeTabs;

        })(moduletabs || (moduletabs = {}));
        //]]>
    </script>

  </head>
  
  <body bgcolor="white" text="black" onload="outline()"> 
      <dplibrary>
      </dplibrary>
  </body>
  </html>
